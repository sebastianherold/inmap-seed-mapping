FileName,Label,FileContent
Apache20LicenseHelp.java,apache-util,"package org.processmining.help;

public class Apache20LicenseHelp {

	public final static String TEXT = """"
			+ ""Retrieves (live) and shows the Apache 2.0 License."";
}
"
LGPLLicenseHelp.java,basic-util,"package org.processmining.basicutils.help;

public class LGPLLicenseHelp {

	public final static String TEXT = """"
			+ ""Retrieves (live) and shows the L-GPL License."";
}
"
ObjectArrayImpl.java,basic-util,"package org.processmining.basicutils.models.impl;

import java.io.File;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.Reader;
import java.util.ArrayList;
import java.util.List;

import org.processmining.basicutils.models.ObjectArray;
import org.processmining.framework.abstractplugins.AbstractImportPlugin;
import org.processmining.framework.plugin.PluginContext;

import com.csvreader.CsvReader;

public abstract class ObjectArrayImpl<K> implements ObjectArray<K>  {
	protected List<K> list = new ArrayList<K>();
	
	public void init() {
		list = new ArrayList<K>();
	}

	public int addElement(K element) {
		list.add(element);
		return list.size() - 1;
	}

	public int removeElement(K element) {
		int ret = list.indexOf(element);
		list.remove(element);
		return ret;
	}

	public void addElement(int index, K element) {
		list.add(index, element);
	}

	public void removeElement(int index) {
		list.remove(index);
	}

	public K getElement(int index) {
		return list.get(index);
	}

	public int getSize() {
		return list.size();
	}
	
	@SuppressWarnings(""unchecked"")
	public void importFromStream(PluginContext context, InputStream input, String parent, AbstractImportPlugin importer) throws Exception {
		Reader streamReader = new InputStreamReader(input);
		CsvReader csvReader = new CsvReader(streamReader);
		init();
		while (csvReader.readRecord()) {
			String fileName = csvReader.get(0);
			if (parent != null && fileName.indexOf(File.separator) == -1) {
				fileName = parent + File.separator + fileName;
			}
			System.out.println(""Importing element "" + fileName);
			K element = (K) importer.importFile(context, fileName);
			this.addElement(element);
		}
		csvReader.close();
	}
}
"
LGPLLicense.java,basic-util,"package org.processmining.basicutils.models;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.net.MalformedURLException;
import java.net.URL;

import org.processmining.framework.util.HTMLToString;

public class LGPLLicense implements HTMLToString {

	public String toHTMLString(boolean includeHTMLTags) {
		StringBuffer buffer = new StringBuffer();
		URL url;
		InputStream is = null;
		BufferedReader br;
		String line;
		String start = ""<div dir=\""ltr\"">"";
		String end = ""/div>"";

		if (includeHTMLTags) {
			buffer.append(""<html>"");
		}
		try {
			url = new URL(""https://www.gnu.org/licenses/lgpl.html"");
			is = url.openStream(); // throws an IOException
			br = new BufferedReader(new InputStreamReader(is));
			boolean copy = false;

			while ((line = br.readLine()) != null) {
				if (line.indexOf(start) >= 0) {
					copy = true;
					line = line.substring(line.indexOf(start) + start.length());
				}
				if (line.indexOf(end) > 0) {
					line = line.substring(0, line.indexOf(end) - 1);
					if (copy) {
						copy = false;
						buffer.append(line);
						buffer.append(""\n"");
					}
				}
				if (copy) {
					buffer.append(line);
					buffer.append(""\n"");
				}
			}
		} catch (MalformedURLException mue) {
			mue.printStackTrace();
		} catch (IOException ioe) {
			ioe.printStackTrace();
		} finally {
			try {
				if (is != null)
					is.close();
			} catch (IOException ioe) {
				// nothing to see here
			}
		}
		if (includeHTMLTags) {
			buffer.append(""</html>"");
		}

		return buffer.toString();
	}

}
"
ObjectArray.java,basic-util,"package org.processmining.basicutils.models;

import java.io.File;
import java.io.InputStream;

import org.processmining.framework.plugin.PluginContext;

public interface ObjectArray<K> {
	/**
	 * Initializes the object array.
	 */
	void init();

	/**
	 * Add the element to the array
	 * @param element
	 * @return the index of the element
	 */
	int addElement(K element);

	/**
	 * Remove the element from the array
	 * @param element
	 * @return
	 */
	int removeElement(K element);

	/**
	 * Add the element at the specific index
	 * @param index
	 * @param element
	 */
	void addElement(int index, K element);

	/**
	 * Remove the element at the specific index
	 * @param index
	 */
	void removeElement(int index);

	/**
	 * Return the element at the specific index
	 * @param index
	 * @return
	 */
	K getElement(int index);
	
	int getSize();
	
	public void importFromStream(PluginContext context, InputStream input, String parent) throws Exception;
	public void exportToFile(PluginContext context, File file) throws Exception;
}
"
PluginParametersImpl.java,basic-util,"package org.processmining.basicutils.parameters.impl;

import org.processmining.basicutils.parameters.PluginParameters;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.events.Logger.MessageLevel;

public class PluginParametersImpl implements PluginParameters {

	private int messageLevel;
	private boolean tryConnections;
	
	public PluginParametersImpl() {
		setMessageLevel(PluginParameters.MESSAGE);
		setTryConnections(true);
	}
	
	public PluginParametersImpl(PluginParameters parameters) {
		setMessageLevel(parameters.getMessageLevel());
		setTryConnections(parameters.isTryConnections());
	}
	
	public boolean equals(Object object) {
		if (object instanceof PluginParametersImpl) {
			PluginParametersImpl parameters = (PluginParametersImpl) object;
			return getMessageLevel() == parameters.getMessageLevel()
					&& isTryConnections() == parameters.isTryConnections();
		}
		return false;
	}
	
	public int getMessageLevel() {
		return messageLevel;
	}

	public void setMessageLevel(int messageLevel) {
		this.messageLevel = messageLevel;
	}
	
	public void displayMessage(String text) {
		if (messageLevel >= PluginParameters.MESSAGE) {
			System.out.println(text);
		}
	}
	
	public void displayWarning(String text) {
		if (messageLevel >= PluginParameters.WARNING) {
			System.out.println(text);
		}
	}
	
	public void displayError(String text) {
		if (messageLevel >= PluginParameters.ERROR) {
			System.err.println(text);
		}
	}

	public void displayMessage(PluginContext context, String text) {
		if (messageLevel >= PluginParameters.MESSAGE) {
			context.log(text, MessageLevel.NORMAL);
		}
	}
	
	public void displayWarning(PluginContext context, String text) {
		if (messageLevel >= PluginParameters.WARNING) {
			context.log(text, MessageLevel.WARNING);
		}
	}
	
	public void displayError(PluginContext context, String text) {
		if (messageLevel >= PluginParameters.ERROR) {
			context.log(text, MessageLevel.ERROR);
		}
	}

	public boolean isTryConnections() {
		return tryConnections;
	}

	public void setTryConnections(boolean tryConnections) {
		this.tryConnections = tryConnections;
	}
}
"
PluginParameters.java,basic-util,"package org.processmining.basicutils.parameters;

import org.processmining.framework.plugin.PluginContext;

public interface PluginParameters {

	public final static int MESSAGE = 1;
	public final static int WARNING = 2;
	public final static int ERROR = 3;
	public final static int DEBUG = 4;

	public int getMessageLevel();

	public void setMessageLevel(int messageLevel);
	
	public void displayMessage(String text);
	
	public void displayWarning(String text);
	
	public void displayError(String text);

	public void displayMessage(PluginContext context, String text);
	
	public void displayWarning(PluginContext context, String text);
	
	public void displayError(PluginContext context, String text);

	public boolean isTryConnections();

	public void setTryConnections(boolean tryConnections);
}
"
LGPLLicensePlugin.java,basic-util,"package org.processmining.basicutils.plugins;

import org.processmining.basicutils.help.LGPLLicenseHelp;
import org.processmining.basicutils.models.LGPLLicense;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginVariant;

@Plugin(name = ""Show L-GPL License"", parameterLabels = { }, returnLabels = { ""Apache License, Version 2.0"" }, returnTypes = { LGPLLicense.class }, help = LGPLLicenseHelp.TEXT)
public class LGPLLicensePlugin {

	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""H.M.W. Verbeek"", email = ""h.m.w.verbeek@tue.nl"")
	@PluginVariant(variantLabel = ""Show L-GPL License"", requiredParameterLabels = { })
	public LGPLLicense runUI(UIPluginContext context) {
		return new LGPLLicense();
	}

	/**
	 * @deprecated Use runUI instead.
	 */
	@Deprecated
	public LGPLLicense show(UIPluginContext context) {
		return runUI(context);
	}
}
"
HTMLUtils.java,basic-util,"package org.processmining.basicutils.utils;

public class HTMLUtils {

	public static String encode(String s) {
		return s.replaceAll(""&"", ""&amp;"").replaceAll(""<"", ""&lt"").replaceAll("">"", ""&gt;"");
	}
}
"
StringConstants.java,basic-util,"package org.processmining.basicutils.utils;

public class StringConstants {

	public final static String START = "" |start> "";
	public final static String END = "" [end] "";
	
}
"
HTMLUtils.java,basic-util,"package org.processmining.utils;

/**
 * @deprecated Use HTMLUtils from org.processmining.basicutils.utils
 */
@Deprecated
public class HTMLUtils {

	public static String encode(String s) {
		return s.replaceAll(""&"", ""&amp;"").replaceAll(""<"", ""&lt"").replaceAll("">"", ""&gt;"");
	}
}
"
AbstractMultiSet.java,context,"package org.processmining.framework.util.collection;

import java.util.AbstractCollection;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.NoSuchElementException;
import java.util.Set;

import org.processmining.framework.util.Cast;

/**
 * This class implements a mutliset. The implementation is synchronized.
 * 
 * @author bfvdonge
 * 
 * @param <T>
 *            the type of the objects in this multiset.
 */
public abstract class AbstractMultiSet<T, M extends Map<T, Integer>> extends AbstractCollection<T> implements
		MultiSet<T> {

	protected M map;
	protected int size;
	private int hashCode;
	private boolean hashValid = false;

	private static final long serialVersionUID = -6521454214767452945L;

	abstract <S> MultiSet<S> newMultiSet(Collection<S> collection);

	abstract MultiSet<T> newMultiSet();

	/**
	 * Keeps all elements of the given collection in this multiset. Multicities
	 * are taken into account, i.e. as many of the same objects are kept as
	 * returned by the collections iterator.
	 * 
	 * @return true if the multiset changed from calling this method.
	 */
	@Override
	public boolean retainAll(Collection<?> c) {
		hashValid = false;
		return retainAll(newMultiSet(c));
	}

	/**
	 * adds one object to the multiset. If the object was not contained before,
	 * then it now has one occerrence, otherwise, the number of occurrences is
	 * increased.
	 * 
	 * @return true, since the collection is always modified.
	 */
	@Override
	public boolean add(T par) {
		add(par, 1);
		hashValid = false;
		return true;
	}

	/**
	 * Keeps all elements of the given collection in this multiset.
	 * Multiplicities are taken into account.
	 * 
	 * @return true if the multiset changed from calling this method.
	 */
	public boolean retainAll(MultiSet<?> c) {
		boolean changed = false;
		Iterator<T> it = map.keySet().iterator();
		while (it.hasNext()) {
			T key = it.next();
			
			Integer occToRetain = c.occurrences(key);
			Integer occInThis = occurrences(key);
			if (occInThis >= occToRetain) {
				// keep occToRetain
				size -= (occInThis - occToRetain);
				if (occToRetain == 0) {
					it.remove();
				} else {
					map.put(key, occToRetain);
				}
				changed = true;
				hashValid = false;
			}
		}
		return changed;
	}

	/**
	 * Adds the given object to the multiset, as many times as indicated by the
	 * given weight parameter.
	 * 
	 * @param par
	 *            the object to add
	 * @param weight
	 *            the number of times to add it
	 * @return the new number of occurrences of the object (>0)
	 */
	public Integer add(T par, Integer weight) {
		if (weight == 0) {
			return weight;
		}
		hashValid = false;
		long newSize = (long) size + (long) weight;
		if (newSize > Integer.MAX_VALUE) {
			size = Integer.MAX_VALUE;
		} else {
			size = (int) newSize;
		}
		if (!map.containsKey(par)) {
			assert (weight > 0);
			map.put(par, weight);
			return weight;
		} else {
			long num = (long) map.get(par) + (long) weight;
			if (num > Integer.MAX_VALUE) {
				num = Integer.MAX_VALUE;
			}
			if (num == 0) {
				map.remove(par);
			} else {
				assert (num > 0);
				map.put(par, (int) num);
			}
			return (int) num;
		}
	}

	/**
	 * Adds the given collection to this multiset. If the given collection is
	 * not a multiset, then the implementation is diverted to
	 * abstractcollection.
	 * 
	 * @param collection
	 *            the collection to add
	 * @return true if the multiset changed due to this method call.
	 */
	@Override
	public boolean addAll(Collection<? extends T> collection) {
		if (collection.isEmpty()) {
			return false;
		}
		hashValid = false;
		if (collection instanceof MultiSet<?>) {
			MultiSet<? extends T> mset = Cast.<MultiSet<? extends T>>cast(collection);
			for (T key : mset.baseSet()) {
				add(key, mset.occurrences(key));
			}
		} else {
			for (T key : collection) {
				add(key);
			}
		}
		return true;
	}

	/**
	 * Converts this multiset to a list, such that each element occurs as often
	 * as returned by the iterator of the multiset (its number of occurrences).
	 * 
	 * @return a list of objects as returned by the iterator
	 */
	public List<T> toList() {
		List<T> list = new ArrayList<T>(size);
		for (T occ : this) {
			list.add(occ);
		}
		return list;
	}

	/**
	 * returns true if this multiset is less or equal to the given multiset,
	 * i.e. all objects in this multiset should be contained in the given set
	 * and the number of occurrences in the given set is at least the number of
	 * occurrences in this multiset.
	 * 
	 * @param multiSet
	 *            the multiset to test
	 * @return true if the given multiset is less or equal.
	 */
	public boolean isLessOrEqual(MultiSet<T> multiSet) {
		for (T element : baseSet()) {
			if (multiSet.occurrences(element) < occurrences(element)) {
				return false;
			}
		}
		return true;
	}

	protected boolean containsAtLeast(T element, int occ) {
		return occurrences(element) >= occ;
	}

	/**
	 * returns true if the multisets are equal, i.e. if they contain the same
	 * objects with the same number of occurrences.
	 */
	@Override
	public boolean equals(Object o) {
		if (o instanceof AbstractMultiSet<?, ?>) {
			return map.equals(((AbstractMultiSet<?, ?>) o).map);
		}
		return false;
	}

	/**
	 * returns the size of the multiset, i.e. the sum over the multiplicities of
	 * all contained objects.
	 */
	@Override
	public int size() {
		return size;
	}

	/**
	 * returns a string representing this multiset. The string contains, between
	 * brackets, pairs of objects and their multiplicities.
	 */
	@Override
	public String toString() {
		String s = ""["";
		for (Map.Entry<T, Integer> entry : map.entrySet()) {
			if (!s.equals(""["")) {
				s += "" "";
			}
			s += ""("" + entry.getKey() + "","" + entry.getValue() + "")"";
		}
		return s + ""]"";
	}

	/**
	 * returns a hashCode for this multiset.
	 */
	@Override
	public int hashCode() {
		if (!hashValid) {
			hashCode = map.hashCode();
			hashValid = true;
		}
		return hashCode;

	}

	/**
	 * returns the number of occurrences of the given object in this multiset.
	 * 
	 * @param source
	 *            the object to get the occurrences for
	 * @return the number of occurrences, 0 if the object does not occur.
	 */
	public Integer occurrences(Object source) {
		return (map.keySet().contains(source) ? map.get(source) : 0);
	}

	/**
	 * returns an iterator over the elements of the multiset. Note that if an
	 * object appears n times in the multiset, it is returned n times by the
	 * iterator.
	 * 
	 * For an iterator over unique elements of the multiset, use the toSet()
	 * method.
	 */
	@Override
	public Iterator<T> iterator() {
		return new MultiSetIterator<T, M>(this);
	}

	/**
	 * returns an unmodifiable set of unique objects in the multiset.
	 * 
	 * @return an unmodifiable set of unique objects in the multiset.
	 */
	public Set<T> baseSet() {
		return Collections.unmodifiableSet(map.keySet());
	}

	/**
	 * checks whether the number of occurrences of the given object is greater
	 * or equal to 1.
	 */
	@Override
	public boolean contains(Object o) {
		return map.containsKey(o);
	}

	/**
	 * Checks whether the number of occurrences of elements in the given
	 * collection is at most what is specified in this collection, i.e., this
	 * method returns (new MultiSet(c)).isLessOrEqual(this)
	 */
	@SuppressWarnings(""unchecked"")
	@Override
	public boolean containsAll(Collection<?> c) {
		MultiSet set;
		if (c instanceof MultiSet) {
			set = (MultiSet) c;
		} else {
			set = newMultiSet(c);
		}
		return set.isLessOrEqual(this);
	}

	/**
	 * removes the given object from this multiset, if it is in there. Only one
	 * occurrence is removed, i.e. contains(o) can still be true after calling
	 * remove(o)
	 */
	@SuppressWarnings(""unchecked"")
	@Override
	public boolean remove(Object o) {
		if (occurrences(o) == 0) {
			return false;
		} else {
			hashValid = false;
			// removing 1 occurrence
			size--;
			Integer occ = map.get(o);
			if (occ == 1) {
				map.remove(o);
				return true;
			} else {
				// since o is in this multiset, it can safely
				// be cast to T
				map.put((T) o, occ - 1);
				return true;
			}
		}
	}

	/**
	 * removes the elements in the given multiset from this multiset.
	 * 
	 * @param mset
	 *            the multiset of elements needing to be removed.
	 * @return a new multiset where the occurrences are the occurrences in this
	 *         multiset, minus the occurrences in the given multiset
	 */
	@Override
	public boolean removeAll(Collection<?> collection) {
		if (collection instanceof AbstractMultiSet<?, ?>) {
			return !removeAllMultiSet(Cast.<AbstractMultiSet<?, ?>>cast(collection), newMultiSet()).isEmpty();
		} else {
			boolean b = false;
			for (Object o : collection) {
				b |= remove(o);
			}
			return b;
		}
	}

	protected <S extends MultiSet<T>> S removeAllMultiSet(AbstractMultiSet<?, ?> mset, S removed) {
		for (Map.Entry<?, Integer> entry : mset.map.entrySet()) {
			if (!map.containsKey(entry.getKey())) {
				continue;
			}
			// Since map.containsKey(entry.getKey()), this is a safe cast
			T key = Cast.<T>cast(entry.getKey());
			Integer val = map.get(key);
			// What's the minimum of the amount I have and the amount I have to remove
			Integer toRemove = Math.min(entry.getValue(), val);
			removed.add(key, toRemove);

			size -= toRemove;
			if (val - toRemove == 0) {
				map.remove(key);
			} else {
				assert (val - toRemove > 0);
				map.put(key, val - toRemove);
			}
		}
		hashValid = false;
		return removed;
	}

	public String toHTMLString(boolean includeHTMLTags) {

		String s = (includeHTMLTags ? ""<html>"" : """") + ""["";
		for (Map.Entry<T, Integer> entry : map.entrySet()) {
			if (!s.endsWith(""["")) {
				s += "","";
			}
			s += entry.getKey();
			if (entry.getValue() > 1) {
				s += ""<sup>"" + entry.getValue() + ""</sup>"";
			}
		}
		return s + ""]"" + (includeHTMLTags ? ""</html>"" : """");
	}

	@Override
	public void clear() {
		map.clear();
		hashValid = false;
		size = 0;
	}

	@Override
	public boolean isEmpty() {
		return size == 0;
	}

}

/**
 * Provides an iterator over a MultiSet. This iterator returns objects as many
 * times as they are contained in the multiset.
 * 
 * @author bfvdonge
 * 
 * @param <T>
 */
class MultiSetIterator<T, M extends Map<T, Integer>> implements Iterator<T> {

	private final AbstractMultiSet<T, M> multiset;
	private final Iterator<Map.Entry<T, Integer>> iterator;
	private Entry<T, Integer> currentEntry = null;
	private Integer toGiveCount = 0;
	private boolean removed = false;

	public MultiSetIterator(AbstractMultiSet<T, M> multiset) {
		this.multiset = multiset;
		this.iterator = multiset.map.entrySet().iterator();
	}

	public boolean hasNext() {
		// No next object, if toGiveCount ==0 and iterator has no next object
		return !((toGiveCount == 0) && !iterator.hasNext());
	}

	public T next() throws NoSuchElementException {
		if (!hasNext()) {
			throw new NoSuchElementException();
		}
		if (toGiveCount == 0) {
			this.currentEntry = iterator.next();
			this.toGiveCount = currentEntry.getValue();
		}
		// reduce the toGiveCount by 1.
		toGiveCount--;
		removed = false;
		return currentEntry.getKey();
	}

	public void remove() {
		if (removed) {
			throw new IllegalStateException();
		}
		int val = currentEntry.getValue();
		if (val > 1) {
			currentEntry.setValue(val - 1);
		} else {
			iterator.remove();
		}
		multiset.size--;
		removed = true;
	}

}
"
AbstractImportPlugin.java,context,"package org.processmining.framework.abstractplugins;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.InputStream;
import java.net.URI;
import java.net.URL;

import javax.swing.filechooser.FileFilter;

import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.PluginVariant;

/**
 * Note that implementing classes of this baseclass should carry the
 * UIImportPlugin annotation
 * 
 * Subclasses of AbstractImportPlugin should use the @Plugin Annotation as
 * follows:
 * 
 * @Plugin( name = ""{any name}"", parameterLabels={""Filename""}, returnLabels = {
 *          {The right return labels} }, returnTypes = { {The right return
 *          classes} })
 * 
 * 
 * @author bfvdonge
 * 
 */
public abstract class AbstractImportPlugin implements ImportPlugin {

	private File file = null;

	/*
	 * (non-Javadoc)
	 * 
	 * @see org.processmining.plugins.abstractplugins.ImportPlugin#getFile()
	 */
	public File getFile() {
		return file;
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see
	 * org.processmining.plugins.abstractplugins.ImportPlugin#importFile(org
	 * .processmining.framework.plugin.PluginContext, java.lang.String)
	 */
	@PluginVariant(requiredParameterLabels = { 0 })
	public Object importFile(PluginContext context, String filename) throws Exception {
		file = new File(filename);
		return importFromStream(context, new FileInputStream(file), filename, file.length());
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see
	 * org.processmining.plugins.abstractplugins.ImportPlugin#importFile(org
	 * .processmining.framework.plugin.PluginContext, java.net.URI)
	 */
	@PluginVariant(requiredParameterLabels = { 0 })
	public Object importFile(PluginContext context, URI uri) throws Exception {
		return importFromStream(context, uri.toURL().openStream(), uri.toString(), 0);
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see
	 * org.processmining.plugins.abstractplugins.ImportPlugin#importFile(org
	 * .processmining.framework.plugin.PluginContext, java.net.URL)
	 */
	@PluginVariant(requiredParameterLabels = { 0 })
	public Object importFile(PluginContext context, URL url) throws Exception {
		file = new File(url.toURI());
		return importFromStream(context, url.openStream(), url.toString(), 0);
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see
	 * org.processmining.plugins.abstractplugins.ImportPlugin#importFile(org
	 * .processmining.framework.plugin.PluginContext, java.io.File)
	 */
	@PluginVariant(requiredParameterLabels = { 0 })
	public Object importFile(PluginContext context, File f) throws Exception {
		file = f;
		InputStream stream = getInputStream(f);
		return importFromStream(context, stream, file.getName(), file.length());
	}

	/**
	 * This method returns an inputStream for a file. Note that the default
	 * implementation returns ""new FileInputStream(file);""
	 * 
	 * @param file
	 * @return
	 * @throws FileNotFoundException
	 */
	protected InputStream getInputStream(File file) throws Exception {
		return new FileInputStream(file);
	}

	/**
	 * This method is called by all plugin variants to do the actual importing.
	 * 
	 * @param context
	 * @param input
	 * @param filename
	 * @param fileSizeInBytes
	 * @return
	 * @throws Exception
	 */
	protected abstract Object importFromStream(PluginContext context, InputStream input, String filename,
			long fileSizeInBytes) throws Exception;

}

class ZipFilter extends FileFilter {

	private final FileFilter parent;

	public ZipFilter(FileFilter parent) {
		this.parent = parent;
	}

	public boolean accept(File f) {
		return (f.getAbsolutePath().endsWith("".zip"") || parent.accept(f));
	}

	public String getDescription() {
		return parent.getDescription();
	}

}"
ImportPlugin.java,context,"package org.processmining.framework.abstractplugins;

import java.io.File;
import java.net.URI;
import java.net.URL;

import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.PluginVariant;

/**
 * This interface should be implemented by plugins that serve as input plugins.
 * 
 * Such a plugin should have the @Plugin annotation on the class level and does
 * not have to define any variants, as these are defined in the interface.
 * 
 * @author bfvdonge
 * 
 */

public interface ImportPlugin {

	/**
	 * Returns the File object this plugin was instantiated with.
	 * 
	 * @return
	 */
	public File getFile();

	@PluginVariant(requiredParameterLabels = { 0 })
	public Object importFile(PluginContext context, String filename) throws Exception;

	@PluginVariant(requiredParameterLabels = { 0 })
	public Object importFile(PluginContext context, URI uri) throws Exception;

	@PluginVariant(requiredParameterLabels = { 0 })
	public Object importFile(PluginContext context, URL url) throws Exception;

	@PluginVariant(requiredParameterLabels = { 0 })
	public Object importFile(PluginContext context, File f) throws Exception;

}"
AlphanumComparator.java,context,"package org.processmining.framework.util.collection;

/*
 * The Alphanum Algorithm is an improved sorting algorithm for strings
 * containing numbers. Instead of sorting numbers in ASCII order like a standard
 * sort, this algorithm sorts numbers in numeric order.
 * 
 * The Alphanum Algorithm is discussed at http://www.DaveKoelle.com
 * 
 * 
 * This library is free software; you can redistribute it and/or modify it under
 * the terms of the GNU Lesser General Public License as published by the Free
 * Software Foundation; either version 2.1 of the License, or any later version.
 * 
 * This library is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
 * details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
 */

import java.util.Comparator;

/**
 * This is an updated version with enhancements made by Daniel Migowski, Andre
 * Bogus, and David Koelle
 * 
 * To convert to use Templates (Java 1.5+): - Change ""implements Comparator"" to
 * ""implements Comparator<String>"" - Change ""compare(Object o1, Object o2)"" to
 * ""compare(String s1, String s2)"" - Remove the type checking and casting in
 * compare().
 * 
 * To use this class: Use the static ""sort"" method from the
 * java.util.Collections class: Collections.sort(your list, new
 * AlphanumComparator());
 */
public class AlphanumComparator implements Comparator<String> {
	private final boolean isDigit(char ch) {
		return ch >= 48 && ch <= 57;
	}

	/**
	 * Length of string is passed in for improved efficiency (only need to
	 * calculate it once)
	 **/
	private final String getChunk(String s, int slength, int marker) {
		StringBuilder chunk = new StringBuilder();
		char c = s.charAt(marker);
		chunk.append(c);
		marker++;
		if (isDigit(c)) {
			while (marker < slength) {
				c = s.charAt(marker);
				if (!isDigit(c))
					break;
				chunk.append(c);
				marker++;
			}
		} else {
			while (marker < slength) {
				c = s.charAt(marker);
				if (isDigit(c))
					break;
				chunk.append(c);
				marker++;
			}
		}
		return chunk.toString();
	}

	public int compare(String s1, String s2) {
		int thisMarker = 0;
		int thatMarker = 0;
		int s1Length = s1.length();
		int s2Length = s2.length();

		while (thisMarker < s1Length && thatMarker < s2Length) {
			String thisChunk = getChunk(s1, s1Length, thisMarker);
			thisMarker += thisChunk.length();

			String thatChunk = getChunk(s2, s2Length, thatMarker);
			thatMarker += thatChunk.length();

			// If both chunks contain numeric characters, sort them numerically
			int result = 0;
			if (isDigit(thisChunk.charAt(0)) && isDigit(thatChunk.charAt(0))) {
				// Simple chunk comparison by length.
				int thisChunkLength = thisChunk.length();
				result = thisChunkLength - thatChunk.length();
				// If equal, the first different number counts
				if (result == 0) {
					for (int i = 0; i < thisChunkLength; i++) {
						result = thisChunk.charAt(i) - thatChunk.charAt(i);
						if (result != 0) {
							return result;
						}
					}
				}
			} else {
				result = thisChunk.compareTo(thatChunk);
			}

			if (result != 0)
				return result;
		}

		return s1Length - s2Length;
	}
}
"
AuthoredType.java,context,"package org.processmining.framework.annotations;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Retention(RetentionPolicy.RUNTIME)
@Target( { ElementType.TYPE })
public @interface AuthoredType {

	public final static String TUE = ""Eindhoven University of Technology"";

	/**
	 * Specifies the user-readable type for this class
	 * 
	 * @return
	 */
	String typeName();

	/**
	 * Specifies the affiliation of the author
	 * 
	 * @return
	 */
	String affiliation();

	/**
	 * specifies the e-mail address of the author
	 * 
	 * @return
	 */
	String email();

	/**
	 * Specifies the name of the author
	 * 
	 * @return
	 */
	String author();

	/**
	 * Specifies the website of the author (note that this should be URL style,
	 * i.e. with http://)
	 * 
	 * @return
	 */
	String website() default ""http://www.processmining.org"";

}
"
Icon.java,context,"package org.processmining.framework.annotations;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Retention(RetentionPolicy.RUNTIME)
@Target( { ElementType.TYPE })
public @interface Icon {

	/**
	 * Specifies the relative path to the icon to be loaded if this type has to
	 * be represented by an Icon
	 * 
	 * @return
	 */
	public String icon();
}
"
TestMethod.java,context,"package org.processmining.framework.annotations;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * By adding this annotation to a method, the method is flagged as a test method
 * for ProM. A hudson server should, on each commit, find all methods annotated
 * with this annotation and exectute it.
 * 
 * The method should not require parameters and should be declared static. The
 * return type of the method should be: <code>String</code>.
 * 
 * The string returned by this method is compared to either the string defined
 * in the output field, or with the contents of the file indicated by
 * filename().
 * 
 * If both filename and output are specified, then only output is used and the
 * file is ignored.
 * 
 * @author bfvdonge
 * 
 */
@Retention(RetentionPolicy.RUNTIME)
@Target({ ElementType.METHOD })
public @interface TestMethod {

	String filename() default """";

	String output() default """";
	
	boolean returnSystemOut() default false;

}
"
AddJarsForPackageRunnable.java,context,"package org.processmining.framework.boot;

import java.io.File;
import java.net.MalformedURLException;
import java.net.URL;
import java.util.ArrayList;
import java.util.List;

import org.processmining.framework.boot.Boot.Level;
import org.processmining.framework.packages.PackageDescriptor;
import org.processmining.framework.plugin.PluginManager;
import org.processmining.framework.util.PathHacker;

/**
 * Threaded implementation of the addJarsForPackage method
 * 
 * @author berti
 *
 */
public class AddJarsForPackageRunnable extends Thread {
	PackageDescriptor pack;
	Level verbose;
	PluginManager plugins;
	
	public AddJarsForPackageRunnable(PackageDescriptor pack, Level verbose, PluginManager plugins) {
		this.pack = pack;
		this.verbose = verbose;
		this.plugins = plugins;
	}
	
	/**
	 * Entry point for thread
	 */
	public void run() {
		if (verbose == Level.ALL) {
			System.out.println(""Scanning package: "" + pack);
		}
		File dir = pack.getLocalPackageDirectory();
		if (!dir.exists() || !dir.isDirectory() || !dir.canRead()) {
			if (verbose == Level.ALL) {
				System.out.println(""  Error: package directory does not exist: "" + dir);
			}
			return;
		}
		// First, recusively iterate subfolders, where no scanning for plugins is necessary
		// this ensures all requires libraries are known when scanning for plugins
		for (File f : dir.listFiles()) {
			// Scan for jars. Only jars in the root of the package will be scanned for
			// plugins and other annotations.
			if (f.isDirectory()) {
				Boot.addJarsFromPackageDirectory(f, verbose, plugins);
				try {
					Boot.addURLToClasspath(f.toURI().toURL());
				} catch (MalformedURLException e) {
				}
			}
		}
		
		// Now scan the jar files in the package root folder.
		for (File f : dir.listFiles()) {
			if (f.getAbsolutePath().endsWith(PluginManager.JAR_EXTENSION)) {
				URL url;
				try {
					url = f.toURI().toURL();
					if (verbose == Level.ALL) {
						System.out.println(""  scanning for plugins: "" + url);
					}
					Boot.addURLToClasspath(url);
					if (f.getAbsolutePath().endsWith(PluginManager.JAR_EXTENSION)) {
						plugins.register(url, pack);
					}
				} catch (MalformedURLException e) {
					e.printStackTrace();
				}
			}
		}
		
		List<Thread> subthreads = new ArrayList<Thread>();
		PathHacker.addLibraryPathFromDirectory(pack.getLocalPackageDirectory());
		try {
			PathHacker.addJar(pack.getLocalPackageDirectory().toURI().toURL());
			for (File f : pack.getLocalPackageDirectory().listFiles()) {
				if (f.isDirectory()) {
					PathHackerRunnable runnable = new PathHackerRunnable(pack, verbose, plugins, f);
					subthreads.add(runnable);
					subthreads.get(subthreads.size()-1).start();
				}
			}
		} catch (MalformedURLException e) {
			assert (false);
		}
				
		for (Thread t : subthreads) {
			try {
				t.join();
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}
	}
}
"
Boot.java,context,"package org.processmining.framework.boot;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.lang.reflect.Method;
import java.net.HttpURLConnection;
import java.net.MalformedURLException;
import java.net.URL;
import java.net.URLClassLoader;
import java.net.URLConnection;
import java.util.ArrayList;
import java.util.List;
import java.util.Properties;
import java.util.prefs.Preferences;

import org.processmining.framework.packages.PackageDescriptor;
import org.processmining.framework.packages.PackageManager;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.PluginManager;
import org.processmining.framework.plugin.annotations.Bootable;
import org.processmining.framework.plugin.annotations.PluginLevel;
import org.processmining.framework.plugin.annotations.PluginQuality;
import org.processmining.framework.plugin.impl.PluginManagerImpl;
import org.processmining.framework.util.CommandLineArgumentList;
import org.processmining.framework.util.OsUtil;
import org.processmining.framework.util.PathHacker;

public class Boot {

	public static enum Level {
		NONE, ERROR, ALL

	}

	public static String PROM_VERSION;
	public static String RELEASE_PACKAGE;
	public static String LIB_FOLDER;
	public static String IMAGES_FOLDER;
	public static String PROM_USER_FOLDER;
	public static String MACRO_FOLDER;
	public static String PACKAGE_FOLDER;
	public static String WORKSPACE_FOLDER;
	public static PluginQuality PLUGIN_QUALITY_THRESHOLD;
	public static PluginLevel PLUGIN_LEVEL_THRESHOLD;
	public static Level VERBOSE;
	public static URL DEFAULT_REPOSITORY;
	public static int OPENXES_SHADOW_SIZE;
	public static int CONNECT_TIMEOUT;
	public static int READ_TIMEOUT;

	public static boolean HIDE_OLD_PACKAGES;
	public static boolean CHECK_PACKAGES;

	public static String AUTO_UPDATE;

	public final static String LAST_RELEASE_AUTOINSTALLED_KEY = ""last_release_autoinstalled"";
	public static final String LAST_RELEASE_PACKAGE_KEY = ""last_release_package_installed"";
	public final static String TRACKING_BY_GA_ALLOWED = ""tracking_by_GA_allowed"";

	/**
	 * Versions of ProM.Lite should have a PROM_VERSION in the ini file that
	 * identifies the specific version. This should be prefixed by the
	 * LITE_PREFIX
	 */
	public static final String LITE_PREFIX = "".Lite"";

	static {

		/*
		 * Preset defaults, just in case something fails down th eroad.
		 */
		PROM_VERSION = """";
		RELEASE_PACKAGE = ""RunnerUpPackages"";
		VERBOSE = Level.NONE;
		LIB_FOLDER = ""lib"";
		IMAGES_FOLDER = ""images"";
		MACRO_FOLDER = ""macros"";
		try {
			DEFAULT_REPOSITORY = new URL(""http://www.promtools.org/prom6/packages/packages.xml"");
		} catch (MalformedURLException e1) {
			e1.printStackTrace();
		}
		PROM_USER_FOLDER = System.getProperty(""user.home"", """") + File.separator + "".ProM"";
		PACKAGE_FOLDER = PROM_USER_FOLDER + File.separator + ""packages"";
		WORKSPACE_FOLDER = PROM_USER_FOLDER + File.separator + ""workspace"";
		HIDE_OLD_PACKAGES = false;
		CHECK_PACKAGES = false;
		PLUGIN_QUALITY_THRESHOLD = PluginQuality.VeryPoor;
		PLUGIN_LEVEL_THRESHOLD = PluginLevel.Local;
		CONNECT_TIMEOUT = 100;
		READ_TIMEOUT = 1000;

		Properties ini = new Properties();
		FileInputStream is;
		try {
			is = new FileInputStream(""ProM.ini"");

			try {
				ini.load(is);
				is.close();

				if (!ini.containsKey(""PROM_VERSION"") || !ini.containsKey(""RELEASE_PACKAGE"")) {
					throw new RuntimeException(""Error while reading ProM.ini file, missing required""
							+ "" keys PROM_VERSION and or RELEASE_PACKAGE . Exiting ProM."");
				}

				PROM_VERSION = ini.getProperty(""PROM_VERSION"");
				if (!PROM_VERSION.contains(""."")) {
					PROM_VERSION = """";
				}

				RELEASE_PACKAGE = ini.getProperty(""RELEASE_PACKAGE"");

				//		OPENXES_SHADOW_SIZE = Integer.parseInt(ini.getProperty(""OPENXES_SHADOW_SIZE"", ""4""));
				//		NikeFS2FileAccessMonitor.instance(OPENXES_SHADOW_SIZE);

				CONNECT_TIMEOUT = Integer.parseInt(ini.getProperty(""CONNECT_TIMEOUT"", ""100""));
				READ_TIMEOUT = Integer.parseInt(ini.getProperty(""READ_TIMEOUT"", ""1000""));

				try {
					VERBOSE = Level.valueOf(ini.getProperty(""VERBOSE"", Level.ALL.name()));
				} catch (IllegalArgumentException e) {
					if (e.getMessage().toLowerCase().endsWith("".true"")) {
						VERBOSE = Level.ALL;
					} else if (e.getMessage().toLowerCase().endsWith("".false"")) {
						VERBOSE = Level.NONE;
					} else {
						throw e;
					}
				}

				LIB_FOLDER = ini.getProperty(""LIB_FOLDER"", ""lib"").replace(""/"", File.separator);
				PathHacker.addLibraryPathFromDirectory(new File(""."" + File.separator + LIB_FOLDER));

				IMAGES_FOLDER = LIB_FOLDER + File.separator
						+ ini.getProperty(""IMAGES_FOLDER"", ""images"").replace(""/"", File.separator);
				PathHacker.addLibraryPathFromDirectory(new File(""."" + File.separator + IMAGES_FOLDER));

				MACRO_FOLDER = LIB_FOLDER + File.separator
						+ ini.getProperty(""MACRO_FOLDER"", ""macros"").replace(""/"", File.separator);
				PathHacker.addLibraryPathFromDirectory(new File(""."" + File.separator + MACRO_FOLDER));

				String defaultRepository = ""http://www.promtools.org/prom6/packages""
						+ PROM_VERSION.replaceAll(""\\."", """") + ""/packages.xml"";
				String repository = getBestRepository(ini.getProperty(""PACKAGE_URL"", defaultRepository).split("" ""),
						defaultRepository);

				try {
					DEFAULT_REPOSITORY = new URL(repository);
				} catch (MalformedURLException e) {
					try {
						DEFAULT_REPOSITORY = new URL(defaultRepository);
					} catch (MalformedURLException e1) {
						assert (false);
					}
				}

				String prom_user_folder = ini.getProperty(""PROM_USER_FOLDER"", """").replace(""/"", File.separator);
				if (prom_user_folder.equals("""")) {
					PROM_USER_FOLDER = System.getProperty(""user.home"", """") + File.separator + "".ProM""
							+ PROM_VERSION.replaceAll(""\\."", """");
				} else {
					PROM_USER_FOLDER = prom_user_folder;
				}

				PACKAGE_FOLDER = PROM_USER_FOLDER + File.separator
						+ ini.getProperty(""PACKAGE_FOLDER"", ""packages"").replace(""/"", File.separator);

				WORKSPACE_FOLDER = PROM_USER_FOLDER + File.separator
						+ ini.getProperty(""WORKSPACE_FOLDER"", ""workspace"").replace(""/"", File.separator);

				HIDE_OLD_PACKAGES = new Boolean(ini.getProperty(""HIDE_OLD_PACKAGES"", ""false""));
				CHECK_PACKAGES = new Boolean(ini.getProperty(""CHECK_PACKAGES"", ""false""));
				AUTO_UPDATE = new String(ini.getProperty(""AUTO_UPDATE"", ""never""));

				PLUGIN_QUALITY_THRESHOLD = PluginQuality.VeryPoor;
				String threshold = ini.getProperty(""PLUGIN_QUALITY_THRESHOLD"", PLUGIN_QUALITY_THRESHOLD.getName());
				for (PluginQuality quality : PluginQuality.values()) {
					if (quality.getName().equals(threshold)) {
						PLUGIN_QUALITY_THRESHOLD = quality;
						break;
					}
				}

				PLUGIN_LEVEL_THRESHOLD = PluginLevel.Local;
				threshold = ini.getProperty(""PLUGIN_LEVEL_THRESHOLD"", PLUGIN_LEVEL_THRESHOLD.getName());
				for (PluginLevel level : PluginLevel.values()) {
					if (level.getName().equals(threshold)) {
						PLUGIN_LEVEL_THRESHOLD = level;
						break;
					}
				}

				if (VERBOSE == Level.ALL) {
					System.out.println(""Plug-in level threshold set to "" + PLUGIN_LEVEL_THRESHOLD.getName());
					System.out.println(""Plug-in quality threshold set to "" + PLUGIN_QUALITY_THRESHOLD.getName());
					System.out.println(""Ini file processed"");
				}
			} catch (IOException e) {
				//					throw new RuntimeException(""Error while reading ProM.ini file. Exiting ProM."", e);
				if (VERBOSE != Level.NONE) {
					System.err.println(""Error while reading ProM.ini file.\n"" + e + ""\nReverting to default settings."");
				}
			}
		} catch (FileNotFoundException e) {
			//				throw new RuntimeException(""ProM.ini file not found. Exiting ProM."", e);
			if (VERBOSE != Level.NONE) {
				System.err.println(""ProM.ini file not found.\n"" + e + ""\nReverting to default settings."");
			}
		}

	}

	/*
	 * Gets the best repository from a list of repositories, where best means
	 * the one that responds fastest. To measure the latter, we read only the
	 * first character from the stream, and measure the wall-clock time this
	 * took. If no repository can be returned, the default repository is
	 * returned.
	 */
	public static String getBestRepository(String[] repositories, String defaultRepository) {
		/*
		 * The best repository so far.
		 */
		String bestRepository = defaultRepository;
		/*
		 * If no repositories are provided, use only the default repository.
		 */
		if (repositories.length == 0) {
			repositories = new String[] { defaultRepository };
		}
		/*
		 * If there is only a single repository, that one has to be the best
		 * one.
		 */
		if (repositories.length == 1) {
			bestRepository = repositories[0];
		} else {
			/*
			 * Multiple repositories. Try to get them to respond, and use the
			 * one that responds the fastest.
			 */
			bestRepository = null;
			long bestTime = 0;
			/*
			 * Have a 'dry run' with i = -1, which actually connects to the
			 * first repository.
			 */
			for (int i = -1; i < repositories.length; i++) {
				try {
					/*
					 * Setup a connection...
					 */
					URL url = new URL(repositories[i < 0 ? 0 : i]);
					URLConnection conn = url.openConnection();
					if (conn instanceof HttpURLConnection) {
						HttpURLConnection httpCon = (HttpURLConnection) conn;
						if (Boot.CONNECT_TIMEOUT > 0) {
							httpCon.setConnectTimeout(Boot.CONNECT_TIMEOUT);
						}
						if (Boot.READ_TIMEOUT > 0) {
							httpCon.setReadTimeout(Boot.READ_TIMEOUT);
						}
					}
					/*
					 * ...and a stream.
					 */
					InputStream stream = conn.getInputStream();
					/*
					 * Try to read some first characters on the stream.
					 */
					long time = -System.nanoTime();
					for (int j = 0; j < 10; j++) {
						stream.read();
					}
					time += System.nanoTime();
					/*
					 * Do not weigh this time too much, to take setup times into account.
					 */
					time /= 1000;
					/*
					 * Try to read some additional characters on the stream.
					 */
					time -= System.nanoTime();
					for (int j = 0; j < 1000; j++) {
						stream.read();
					}
					time += System.nanoTime();
					/*
					 * Stream can now be closed.
					 */
					stream.close();
					/*
					 * If not a dry run, see whether this repository is better.
					 */
					if (i >= 0) {
						System.out.println(""[Boot] Repository "" + repositories[i] + "" took "" + time + "" nanoseconds."");
						/*
						 * Update the best repository and the best time, if
						 * needed.
						 */
						if (bestRepository == null || time < bestTime) {
							bestRepository = repositories[i];
							bestTime = time;
							System.out.println(""[Boot] New best repository "" + repositories[i]);
						}
					}
				} catch (MalformedURLException e) {
					System.err.println(""[Boot] URL error with repository "" + repositories[i < 0 ? 0 : i] + "": "" + e.getMessage());
				} catch (IOException e) {
					System.err.println(""[Boot] I/O error with repository "" + repositories[i < 0 ? 0 : 1] + "": "" + e.getMessage());
				}
			}
			/*
			 * Fail safe: If no repository was found, use the default one.
			 */
			if (bestRepository == null) {
				bestRepository = defaultRepository;
			}
		}
		/*
		 * Return the best repository found.
		 */
		return bestRepository;
	}

	public static boolean isLatestReleaseInstalled() {
		return Preferences.userNodeForPackage(Boot.class).get(LAST_RELEASE_AUTOINSTALLED_KEY, """").equals(PROM_VERSION)
				&& Preferences.userNodeForPackage(Boot.class).get(LAST_RELEASE_PACKAGE_KEY, """").equals(RELEASE_PACKAGE);
	}

	public static void setReleaseInstalled(String version, String releasePackage) {
		Preferences.userNodeForPackage(Boot.class).put(LAST_RELEASE_AUTOINSTALLED_KEY, version);
		Preferences.userNodeForPackage(Boot.class).put(LAST_RELEASE_PACKAGE_KEY, releasePackage);
	}

	public static void setLatestReleaseInstalled() {
		setReleaseInstalled(PROM_VERSION, RELEASE_PACKAGE);
	}

	public static boolean isTrackingByGAAllowed() {
		return Preferences.userNodeForPackage(Boot.class).get(TRACKING_BY_GA_ALLOWED, ""false"").equals(""true"");
	}

	public static void boot(Class<?> bootClass, Class<? extends PluginContext> pluginContextClass, String... args)
			throws Exception {
		long start = System.currentTimeMillis();
		// First instantiate the package manager
		PackageManager packages = PackageManager.getInstance();
		// Then the plugin manager, as it listens to the package manager
		PluginManagerImpl.initialize(pluginContextClass);
		PluginManager plugins = PluginManagerImpl.getInstance();

		OsUtil.setWorkingDirectoryAtStartup();

		long startPackages = System.currentTimeMillis();
		packages.initialize(VERBOSE);
		if (VERBOSE == Level.ALL) {
			System.out.println("">>> Scanning for packages took "" + (System.currentTimeMillis() - startPackages)
					/ 1000.0 + "" seconds"");
		}

		long startPlugins = System.currentTimeMillis();
		URLClassLoader sysloader = (URLClassLoader) ClassLoader.getSystemClassLoader();
		URL[] defaultURLs = sysloader.getURLs();

		//	new URLClassLoader(new URL[] { packages.getPackagesDirectory().toURL() });

		if (VERBOSE == Level.ALL) {
			for (URL def : defaultURLs) {
				System.out.println(""known jar file: "" + def);
			}
			System.out.println(""Loading plugins from packages."");
		}

		/**
		 * (berti) Made ""addJarsForPackage"" method as thread to use parallelism
		 */
		List<Thread> loadingThreadsPackage = new ArrayList<Thread>();
		for (PackageDescriptor pack : packages.getEnabledPackages()) {
			if (VERBOSE == Level.ALL) {
				System.out.println(""Processing Package: "" + pack.getName());
			}
			//addJarsForPackage(pack, VERBOSE, plugins);
			AddJarsForPackageRunnable addJarsForPackage = new AddJarsForPackageRunnable(pack, VERBOSE, plugins);
			loadingThreadsPackage.add(addJarsForPackage);
			loadingThreadsPackage.get(loadingThreadsPackage.size() - 1).start();
		}

		// wait for each thread to finish the job before continuing
		for (Thread t : loadingThreadsPackage) {
			t.join();
		}

		if (VERBOSE == Level.ALL) {
			System.out.println(""Loading from: classpath"");
		}

		File f = new File(""."" + File.separator + LIB_FOLDER);
		String libPath = f.getCanonicalPath();
		addURLToClasspath(f.toURI().toURL());
		for (URL url : defaultURLs) {
			if (VERBOSE == Level.ALL) {
				System.out.println(""Processing url: "" + url);
			}
			if (!(new File(url.toURI()).getCanonicalPath().startsWith(libPath))) {
				if (VERBOSE == Level.ALL) {
					System.out.println(""Scanning for plugins: "" + url);
				}
				plugins.register(url, null);
			} else {
				if (VERBOSE == Level.ALL) {
					System.out.println(""Skipping: "" + url.getFile() + "" while scanning for plugins."");
				}
			}
		}

		//		for (URL url : sysloader.getURLs()) {
		//			System.err.println(""URL = "" + url);
		//		}

		if (VERBOSE == Level.ALL) {
			System.out.println("">>> Scanning for plugins took "" + (System.currentTimeMillis() - startPlugins) / 1000.0
					+ "" seconds"");
		}

		boot(bootClass, args);

		if (VERBOSE == Level.ALL) {
			System.out.println("">>> Total startup took "" + (System.currentTimeMillis() - start) / 1000.0 + "" seconds"");
		}
	}

	/*
	 * (non-Javadoc) * @see
	 * org.processmining.framework.plugin.PluginManager#boot(java.lang.Class,
	 * java.lang.String[])
	 */
	public static Object boot(Class<?> bootClass, String... args) throws Exception {
		Method bootMethod = null;

		for (Method method : bootClass.getMethods()) {
			if (method.isAnnotationPresent(Bootable.class)) {
				if (bootMethod == null) {
					bootMethod = method;
				} else {
					throw new IllegalArgumentException(""Cannot have more than one @Bootable method in a class"");
				}
			}
		}
		if (bootMethod == null) {
			throw new IllegalArgumentException(""No @Bootable annotation found: "" + bootClass.getName());
		}

		CommandLineArgumentList argList = new CommandLineArgumentList();
		for (String arg : args) {
			argList.add(arg);
		}

		return bootMethod.invoke(bootMethod.getDeclaringClass().newInstance(), argList);
	}

	public static void addJarsForPackage(PackageDescriptor pack, Boot.Level verbose, PluginManager plugins) {
		if (verbose == Level.ALL) {
			System.out.println(""Scanning package: "" + pack);
		}
		File dir = pack.getLocalPackageDirectory();
		if (!dir.exists() || !dir.isDirectory() || !dir.canRead()) {
			if (verbose == Level.ALL) {
				System.out.println(""  Error: package directory does not exist: "" + dir);
			}
			return;
		}
		// First, recusively iterate subfolders, where no scanning for plugins is necessary
		// this ensures all requires libraries are known when scanning for plugins
		for (File f : dir.listFiles()) {
			// Scan for jars. Only jars in the root of the package will be scanned for
			// plugins and other annotations.
			if (f.isDirectory()) {
				addJarsFromPackageDirectory(f, verbose, plugins);
				try {
					addURLToClasspath(f.toURI().toURL());
				} catch (MalformedURLException e) {
				}
			}
		}
		// Now scan the jar files in the package root folder.
		for (File f : dir.listFiles()) {
			if (f.getAbsolutePath().endsWith(PluginManager.JAR_EXTENSION)) {
				URL url;
				try {
					url = f.toURI().toURL();
					if (verbose == Level.ALL) {
						System.out.println(""  scanning for plugins: "" + url);
					}
					addURLToClasspath(url);
					if (f.getAbsolutePath().endsWith(PluginManager.JAR_EXTENSION)) {
						plugins.register(url, pack);
					}
				} catch (MalformedURLException e) {
					e.printStackTrace();
				}
			}

		}
		PathHacker.addLibraryPathFromDirectory(pack.getLocalPackageDirectory());
		try {
			PathHacker.addJar(pack.getLocalPackageDirectory().toURI().toURL());
			for (File f : pack.getLocalPackageDirectory().listFiles()) {
				if (f.isDirectory()) {
					PathHacker.addJar(f.toURI().toURL());
				}
			}
		} catch (MalformedURLException e) {
			assert (false);
		}

	}

	/**
	 * Scan for jars and add them to the classpath.
	 * 
	 * @param dir
	 *            the folder (or jar file) to scan
	 * @param verbose
	 *            true if output required
	 * @param plugins
	 *            the plugin manager
	 * @param scanClasses
	 *            If true, then all classes are scanned for annotations and for
	 *            plugins. This property recusively propagates to sub-folders.
	 */
	static void addJarsFromPackageDirectory(File dir, Boot.Level verbose, PluginManager plugins) {

		for (File f : dir.listFiles()) {
			if (f.isDirectory()) {
				addJarsFromPackageDirectory(f, verbose, plugins);
			}
		}
		for (File f : dir.listFiles()) {
			if (f.getAbsolutePath().endsWith(PluginManager.JAR_EXTENSION)) {
				try {
					URL url = f.toURI().toURL();
					if (verbose == Level.ALL) {
						System.out.println(""  adding to classpath: "" + url);
					}
					addURLToClasspath(url);
				} catch (MalformedURLException e) {
					e.printStackTrace();

				}
			}
		}
	}

	static void addURLToClasspath(URL url) {
		try {
			URLClassLoader sysloader = (URLClassLoader) ClassLoader.getSystemClassLoader();
			Method method = URLClassLoader.class.getDeclaredMethod(""addURL"", new Class<?>[] { URL.class });

			method.setAccessible(true);
			method.invoke(sysloader, new Object[] { url });
		} catch (Throwable t) {
			t.printStackTrace();
		}
	}
}
"
PathHackerRunnable.java,context,"package org.processmining.framework.boot;

import java.io.File;
import java.net.MalformedURLException;

import org.processmining.framework.boot.Boot.Level;
import org.processmining.framework.packages.PackageDescriptor;
import org.processmining.framework.plugin.PluginManager;
import org.processmining.framework.util.PathHacker;

/**
 * Threaded executions of PathHacker addJar
 * 
 * @author berti
 *
 */
public class PathHackerRunnable extends Thread {
	PackageDescriptor pack;
	Level verbose;
	PluginManager plugins;
	File f;
	
	public PathHackerRunnable(PackageDescriptor pack, Level verbose, PluginManager plugins, File f) {
		this.pack = pack;
		this.verbose = verbose;
		this.plugins = plugins;
		this.f = f;
	}
	
	/**
	 * Entry point for thread
	 */
	public void run() {
		//System.out.println(""pathHacker ""+f.toURI());
		try {
			PathHacker.addJar(f.toURI().toURL());
		} catch (MalformedURLException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
}
"
BreadthFirstExpandCollection.java,context,"package org.processmining.framework.util.search;

import java.util.Collection;

public class BreadthFirstExpandCollection<N> extends DepthFirstExpandCollection<N> {

	public void add(Collection<? extends N> newElements) {
		stack.addAll(0, newElements);
	}

}
"
ComparablePair.java,context,"package org.processmining.framework.util.collection;

import org.processmining.framework.util.Pair;

public class ComparablePair<F extends Comparable<? super F>, S extends Comparable<? super S>> extends Pair<F, S>
		implements Comparable<ComparablePair<F, S>> {

	public ComparablePair(F first, S second) {
		super(first, second);
	}

	public <T extends Comparable<? super T>> int compareTo(T x, T y) {
		if (x == null) {
			return y == null ? 0 : -1;
		} else {
			return x.compareTo(y);
		}
	}

	public int compareTo(ComparablePair<F, S> other) {
		if (other == null) {
			return 1;
		}
		int result = compareTo(first, other.first);
		return result == 0 ? compareTo(second, other.second) : result;
	}

}
"
ConnectionDoesntExistMessage.java,context,"package org.processmining.framework.connections.annotations;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Retention(RetentionPolicy.RUNTIME)
@Target({ ElementType.TYPE })
public @interface ConnectionDoesntExistMessage {

	public String message() default """";
}
"
ConnectionObjectFactory.java,context,"package org.processmining.framework.connections.annotations;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * Annotation used on plugins to signal that they can construct a Connection on
 * objects.
 * 
 * The type of connection produced is given by the return type of the plugin, of
 * which there should be only 1, which is assignable from Connection.class.
 * 
 * To avoid lifelocks such a plugin should not request any connection on its
 * inputs. If no connection can be made, <code>null</code> should be returned.
 * 
 * @author bfvdonge
 * 
 */
@Retention(RetentionPolicy.RUNTIME)
@Target( { ElementType.METHOD, ElementType.TYPE })
public @interface ConnectionObjectFactory {

}
"
Connection.java,context,"package org.processmining.framework.connections;

import java.util.Collection;
import java.util.Set;

import org.processmining.framework.annotations.AuthoredType;
import org.processmining.framework.annotations.Icon;
import org.processmining.framework.util.collection.MultiSet;

/**
 * A connection describes a relation between objects. The connection keeps a
 * number of weak references between the objects in the relation. Each object
 * should have a label describing the role of the object in the relation. These
 * roles are unique
 * 
 * Note that for all implementations of Connection, it is essential to consider
 * memory consumption. Connections are kept in the framework for as long as the
 * isRemoved() method returns false, hence this method should return true at the
 * earliest occasion.
 * 
 * All implementations of this class should carry the following annotations:
 * @KeepInProMCache
 * @ConnectionAnnotation
 * @ConnectionDoesntExistMessage(message = ""Message for case that connection Doesn't Exist"")
 * 
 * @author bfvdonge
 * 
 */
@AuthoredType(typeName = ""Connection"", affiliation = AuthoredType.TUE, author = ""B.F. van Dongen"", email = ""b.f.v.dongen@tue.nl"")
@Icon(icon = ""resourcetype_connection_30x35.png"")
public interface Connection {

	/**
	 * Return the label of the connection
	 * 
	 * @return
	 */
	public String getLabel();

	/**
	 * Return the ID of the connection.
	 * 
	 * @return
	 */
	public ConnectionID getID();

	/**
	 * Return true if all objects given as parameter are contained in the
	 * connection. Multiplicities are taken into account, however order is
	 * abstracted from
	 * 
	 * @param objects
	 *            the objects to check for
	 * @return
	 */
	public boolean containsObjects(Object... objects);

	/**
	 * Return true if all objects given as parameter are contained in the
	 * connection. Multiplicities are taken into account, i.e. each object
	 * should occur as often as it is returned by the iterator of the given
	 * collection however order is abstracted from
	 * 
	 * @param objects
	 *            the objects as a collection
	 * @return
	 */
	public boolean containsObjects(Collection<?> objects);

	/**
	 * Return true if one of the objects connected by this connection no longer
	 * exists, i.e. it is collected by the garbage collector.
	 * 
	 * @return
	 */
	public boolean isRemoved();

	/**
	 * Return all objects contained in this connection, without their labels.
	 * 
	 * By contract, this method should always return the same set of objects
	 * after the connections was created, i.e. connections may only be changed
	 * by changing the contents of the objects, but not by changing the
	 * pointers.
	 * 
	 * @return
	 */
	public MultiSet<Object> getObjects();

	/**
	 * Return the roles of all objects in this connection
	 * 
	 * @return
	 */
	public Set<String> getRoles();

	/**
	 * Return the object with the given role in this connection The type of the
	 * returned object is T. However, no checks have to be performed to see if
	 * the cast can be made. It is up to the calling method to ensure this cast
	 * is safe.
	 * 
	 * @param <T>
	 *            The type of object that should be returned.
	 * @param role
	 *            the role the returned object has to have
	 * @return the object attached to this role (not null).
	 */
	public <T> T getObjectWithRole(String role);

	/**
	 * Removes the connection. After calling this method, isRemoved()returns
	 * true;
	 */
	public void remove();

	/**
	 * sets the label of the connection to the new name
	 * 
	 * @param name
	 */
	public void setLabel(String name);

	/**
	 * This method should be called as soon as the connection is changed, for
	 * example if the label changed, or if the contents of one of the connected
	 * objects changes.
	 * 
	 * By calling this method, the connection manager should be notified.
	 */
	public void updated();

	/**
	 * Sets the manager for the connection. This method is called by the
	 * connection manager as soon as this connection is added to that manager. A
	 * connection should keep a reference to the manager only in a transient
	 * field.
	 * 
	 * @param manager
	 */
	void setManager(ConnectionManager manager);

}
"
ConnectionAnnotation.java,context,"package org.processmining.framework.connections;

import java.lang.annotation.ElementType;
import java.lang.annotation.Inherited;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * This annotation is used by the framework to scan for all implementations if
 * Connection.
 * 
 * @author bfvdonge
 * 
 */
@Retention(RetentionPolicy.RUNTIME)
@Target({ ElementType.TYPE })
@Inherited
public @interface ConnectionAnnotation {

}
"
ConnectionCannotBeObtained.java,context,"package org.processmining.framework.connections;

import org.processmining.framework.connections.annotations.ConnectionDoesntExistMessage;

/**
 * Exception thrown by the connectionmanager if a requested connection does not
 * exist.
 * 
 * @author bfvdonge
 * 
 */
public class ConnectionCannotBeObtained extends Exception {

	private final Class<? extends Object> connectionType;

	/**
	 * Constructor with message and cause
	 * 
	 * @param reason
	 *            The reason of throwing this exception
	 * @param ex
	 *            the cause of this exception
	 */
	public ConnectionCannotBeObtained(String reason, ConnectionCannotBeObtained ex) {
		this(reason + "" \n "" + ex.getMessage(), ex.connectionType);
	}

	/**
	 * Constructor with reason, connection type and objects. The message is set
	 * to: ""No known connection of type + connectionType + "" between "" +
	 * Arrays.toString(objects) + "" ["" + reason + ""]"";
	 * 
	 * @param reason
	 *            The reason of throwing this exception
	 * @param connectionType
	 *            The requested connection type
	 * @param objects
	 *            the objects on which a connection was requested
	 */
	public ConnectionCannotBeObtained(String reason, Class<?> connectionType, Object... objects) {
		super(""No connection of type "" + connectionType.getSimpleName() + 
//				"" can be obtained for objects: "" + Arrays.toString(objects) + 
				""\n The reason given is: "" + reason + ""\n ""
				+ getDoesntExistMessage(connectionType))
				;
		this.connectionType = connectionType;
	}

	/**
	 * 
	 */
	private static final long serialVersionUID = 224232280740635702L;

	private static String getDoesntExistMessage(Class<?> connectionType) {
		if (connectionType == null) {
			return """";
		}
		String s = """";
		ConnectionDoesntExistMessage message = connectionType.getAnnotation(ConnectionDoesntExistMessage.class);
		if (message != null) {
			s = message.message();
		}
		if ((connectionType != Connection.class) && (connectionType.getSuperclass() != null)
				&& (Connection.class.isAssignableFrom(connectionType.getSuperclass()))) {
			s = getDoesntExistMessage(connectionType.getSuperclass()) + "" \n "" + s;
		}
		for (Class<?> sup : connectionType.getInterfaces()) {
			if (Connection.class.isAssignableFrom(sup)) {
				s = getDoesntExistMessage(connectionType.getSuperclass()) + "" \n "" + s;
			}
		}
		return s;

	}

}
"
ConnectionID.java,context,"package org.processmining.framework.connections;

import org.processmining.framework.ProMID;

/**
 * ID of a connection. Need not to be persistent over serialization.
 * 
 * @author bfvdonge
 * 
 */
public interface ConnectionID extends ProMID {


}
"
ConnectionManager.java,context,"package org.processmining.framework.connections;

import java.util.Collection;

import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.events.ConnectionObjectListener;

public interface ConnectionManager {

	/**
	 * Returns a collection of connections between the objects specified, such
	 * that the type of the connection is assignable from the given
	 * connectionType (unless the parameter equals null).
	 * 
	 * If no connections satisfying these criteria exist and the required type
	 * is specified and no required name is specified, then the global context
	 * searches for all available plugins with a ConnectionObjectFactory
	 * annotation, which can be executed in a child of the given PluginContext
	 * and accept the given objects as input
	 * 
	 * If such plugins exist, the first of these plugins is selected and invoked
	 * on the given objects. The result is obtained from the plugin and a new
	 * connection is registered of the right type. This connection is then
	 * returned.
	 * 
	 * @param <T>
	 *            the type of the requested connection.
	 * @param connectionType
	 *            The type of the object requested. This type can be null, in
	 *            which case all types are considered.
	 * @param context
	 *            The context which requests the connection. If a plugin is
	 *            invoked to create a connection, a child context of this
	 *            context is instantiated
	 * @param objects
	 *            the objects which should be connected by the requested
	 *            connection. There might be more objects involved in the
	 *            connection
	 * @return A collection of connections of the requested type T. If no
	 *         connection exists, an exception is thrown, hence the collection
	 *         is never empty.
	 * @throws ConnectionCannotBeObtained
	 *             if the requested connection does not exist and cannot be
	 *             produced in the given context.
	 */
	<T extends Connection> Collection<T> getConnections(Class<T> connectionType, PluginContext context,
			Object... objects) throws ConnectionCannotBeObtained;

	/**
	 * Returns a connection between the objects specified, such that the type of
	 * the connection is assignable from the given connectionType (unless the
	 * parameter equals null).
	 * 
	 * If no connections satisfying these criteria exist and the required type
	 * is specified and no required name is specified, then the global context
	 * searches for all available plugins with a ConnectionObjectFactory
	 * annotation, which can be executed in a child of the given PluginContext
	 * and accept the given objects as input
	 * 
	 * If such plugins exist, the first of these plugins is selected and invoked
	 * on the given objects. The result is obtained from the plugin and a new
	 * connection is registered of the right type. This connection is then
	 * returned.
	 * 
	 * @param <T>
	 *            the type of the requested connection.
	 * @param connectionType
	 *            The type of the object requested. This type can be null, in
	 *            which case all types are considered.
	 * @param context
	 *            The context which requests the connection. If a plugin is
	 *            invoked to create a connection, a child context of this
	 *            context is instantiated
	 * @param objects
	 *            the objects which should be connected by the requested
	 *            connection. There might be more objects involved in the
	 *            connection
	 * @return A connection of the requested type T. If no connection exists, an
	 *         exception is thrown, hence null is never returned.
	 * @throws ConnectionCannotBeObtained
	 *             if the requested connection does not exist and cannot be
	 *             produced in the given context.
	 */
	<T extends Connection> T getFirstConnection(Class<T> connectionType, PluginContext context, Object... objects)
			throws ConnectionCannotBeObtained;

	/**
	 * Returns the connection with the given ID.
	 * 
	 * @param id
	 *            the connection ID
	 * @return the connection with the given ID
	 */
	Connection getConnection(ConnectionID id) throws ConnectionCannotBeObtained;

	/**
	 * Returns the list of registered connectionObject listeners
	 * 
	 * @return the list of registered connectionObject listeners
	 */
	ConnectionObjectListener.ListenerList getConnectionListeners();

	/**
	 * Returns a collection of connection IDs registered to this global context.
	 * 
	 * @return the ids of the registered connections
	 */
	Collection<ConnectionID> getConnectionIDs();

	/**
	 * Adds the given connection to the framework.
	 * 
	 * @param connection
	 *            The connection to be registered
	 * @return the given parameter connection
	 */
	<T extends Connection> T addConnection(T connection);

	/**
	 * Returns whether connections are enabled. If not, then connecitons will not be added.
	 * @return whether connections are enabled
	 */
	boolean isEnabled();

	/**
	 * Sets whether connections are enabled.
	 * @param isEnabled whether connections should be enabled
	 */
	void setEnabled(boolean isEnabled);

	void clear();
}
"
DynamicConnection.java,context,"package org.processmining.framework.connections;

/**
 * Tagger interface to indicate that a connection will change after
 * instantiation. Since the actual objects involved in the connection are not
 * allowed to change, these changes should be limited to the contents of the
 * connection itself.
 * 
 * The main use for this interface is in serialization, where DynamicConnections
 * are only serialized when ProM is closed.
 * 
 * @author bfvdonge
 * 
 */
public interface DynamicConnection {

}
"
AbstractConnection.java,context,"package org.processmining.framework.connections.impl;

import java.lang.ref.WeakReference;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Objects;
import java.util.Set;

import org.processmining.framework.connections.Connection;
import org.processmining.framework.connections.ConnectionAnnotation;
import org.processmining.framework.connections.ConnectionID;
import org.processmining.framework.connections.ConnectionManager;
import org.processmining.framework.connections.annotations.ConnectionDoesntExistMessage;
import org.processmining.framework.plugin.annotations.KeepInProMCache;
import org.processmining.framework.util.collection.HashMultiSet;
import org.processmining.framework.util.collection.MultiSet;

/**
 * Note that for all implementations of Connection, it is essential to consider
 * memory consumption. Connections are kept in the framework for as long as the
 * isRemoved() method returns false, hence this method should return true at the
 * earliest occasion.
 * 
 * The AbstractConnection keeps weak references to the objects added through the
 * put methods. As soon as one of these objects is collected by the garbage
 * collector, then this connection becomes removed. Therefore, it is essential
 * that subclasses of the AbstractConnection do not keep pointers to these
 * objects, or at least only keep weak references.
 * 
 * This class is annotated with @ConnectionAnnotation. Therefore, none of the
 * implementing classes have to do so explicitly.
 * 
 * @author bfvdonge
 * 
 */
@KeepInProMCache
@ConnectionAnnotation
@ConnectionDoesntExistMessage(message = ""Connection Doesn't Exist"")
public abstract class AbstractConnection implements Connection {

	private final Map<String, WeakReference<?>> mapping;
	private static final long serialVersionUID = -9049359040527952685L;

	private String label;

	private final ConnectionID id;
	protected transient ConnectionManager manager = null;

	protected AbstractConnection(String label) {
		if (label == null) {
			throw new NullPointerException(""Connection label should not be NULL"");
		}
		this.label = label;
		id = new ConnectionIDImpl();
		mapping = new HashMap<String, WeakReference<?>>();
	}

	public void setManager(ConnectionManager manager) {
		this.manager = manager;
	}

	public String getLabel() {
		return label;
	}

	public boolean containsObjects(Object... objects) {
		return containsObjects(Arrays.asList(objects));
	}

	public boolean containsObjects(Collection<?> objects) {
		Collection<WeakReference<?>> references = new ArrayList<WeakReference<?>>(mapping.values());

		for (Object o : objects) {
			boolean found = false;
			Iterator<WeakReference<?>> it = references.iterator();
			while (!found && it.hasNext()) {
				Object referenced = it.next().get();
				if (o.getClass().isArray() && referenced.getClass().isArray()) {
					// We are dealing with an array type
					if (Arrays.equals((Object[]) o, (Object[]) referenced)) {
						// Found a match for this object.
						found = true;
					}
				} else {
					if (referenced.equals(o)) {
						// Found a match for this object.
						found = true;
					}
				}
				if (found) {
					it.remove();
				}
			}
			if (!found) {
				return false;
			}
		}
		return true;
	}

	public boolean isRemoved() {
//		System.gc(); // By doing this, object are removed earlier from the workspace.
		for (Map.Entry<String, WeakReference<?>> t : mapping.entrySet()) {
			Object o = t.getValue().get();
//			System.out.println(""[AbstractionConnection] isRemoved "" + this.getClass().getName() + ""@"" + t.getKey() + "": "" + o);			
			if (o == null) {
				return true;
			}
		}
		return false;
	}

	public String toString() {
		return ""Connection labelled "" + label + "", connecting "" + super.toString();
	}

	@Override
	public int hashCode() {
		return Objects.hashCode(id);
	}

	public MultiSet<Object> getObjects() {
		MultiSet<Object> result = new HashMultiSet<Object>();
		for (Map.Entry<String, WeakReference<?>> t : mapping.entrySet()) {
			Object o = t.getValue().get();
			if (o != null) {
				result.add(o);
			} else {
				return new HashMultiSet<Object>();
			}
		}
		return result;
	}

	@Override
	public boolean equals(Object o) {
		if (this == o) {
			return true;
		}
		if (o == null) {
			return false;
		}
		if (!(o instanceof AbstractConnection)) {
			return false;
		}
		AbstractConnection a = (AbstractConnection) o;
		if (id == null) {
			if (a.id != null) {
				return false;
			}
		} else if (!id.equals(a.id)) {
			return false;
		}
		return true;
	}

	public ConnectionID getID() {
		return id;
	}

	@SuppressWarnings(""unchecked"")
	public <T> T getObjectWithRole(String role) {
		assert (get(role) != null);
		return (T) get(role);
	}

	public Set<String> getRoles() {
		return mapping.keySet();
	}

	protected <T> WeakReference<T> put(String role, T o) {
		WeakReference<T> ref = new WeakReference<T>(o);
		mapping.put(role, ref);
		return ref;
	}

	protected void remove(String role) {
		mapping.remove(role);
	}

	protected Object get(String role) {
		return mapping.get(role).get();
	}

	protected Map<String, WeakReference<?>> getMapping() {
		return mapping;
	}

	/**
	 * Removes the connection. After calling this method, isRemoved()returns
	 * true;
	 */
	public void remove() {
		for (Map.Entry<String, WeakReference<?>> t : mapping.entrySet()) {
			t.getValue().clear();
		}
	}

	/**
	 * sets the label of the connection to the new name
	 * 
	 * @param name
	 */
	public void setLabel(String name) {
		if (name == null) {
			throw new NullPointerException(""Connection label should not be NULL"");
		}
		boolean changed = name.equals(label);
		this.label = name;
		if (changed) {
			updated();
		}
	}

	public void updated() {
		if (manager != null) {
			manager.getConnectionListeners().fireConnectionUpdated(id);
		}
	}

	private Object readResolve() {
		manager = null;
		return this;
	}
}
"
AbstractStrongReferencingConnection.java,context,"package org.processmining.framework.connections.impl;

import java.lang.ref.WeakReference;
import java.util.Collection;
import java.util.HashSet;
import java.util.Map;

public abstract class AbstractStrongReferencingConnection extends AbstractConnection {

	// Keep a strong reference to some objects, as these
	// would otherwise fault the connection.
	// When checking for removal, these objects are ignored, i.e. the connection
	// is considered to be removed if any of the weak references has been nullified.
	private final Collection<Object> objectReferences = new HashSet<Object>();

	public AbstractStrongReferencingConnection(String label) {
		super(label);
	}

	protected <T> WeakReference<T> putStrong(String role, T o) {
		objectReferences.add(o);
		return super.put(role, o);
	}

	@Override
	public boolean isRemoved() {
		for (Map.Entry<String, WeakReference<?>> t : getMapping().entrySet()) {
			Object o = t.getValue().get();
			if (objectReferences.contains(o)) {
				// Skip the objects to which Hard links need to be kept.
				continue;
			}
			if (o == null) {
				return true;
			}
		}
		return false;
	}

}"
ConnectionIDImpl.java,context,"package org.processmining.framework.connections.impl;

import java.util.UUID;

import org.processmining.framework.ProMID;
import org.processmining.framework.connections.ConnectionID;

public class ConnectionIDImpl implements ConnectionID {

	private final UUID id = UUID.randomUUID();

	public String toString() {
		return id.toString();
	}

	public int hashCode() {
		return id.hashCode();
	}

	public boolean equals(Object o) {
		if (!(o instanceof ConnectionIDImpl)) {
			return false;
		} else {
			return ((ConnectionIDImpl) o).id.equals(id);
		}
	}

	public boolean equalsIgnoreType(Object o) {
		return toString().equals(o.toString());
	}

	public int compareTo(ProMID o) {
		return o.getUUID().compareTo(id);
	}

	public UUID getUUID() {
		return id;
	}

}
"
ConnectionManagerImpl.java,context,"package org.processmining.framework.connections.impl;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;

import org.processmining.framework.connections.Connection;
import org.processmining.framework.connections.ConnectionCannotBeObtained;
import org.processmining.framework.connections.ConnectionID;
import org.processmining.framework.connections.ConnectionManager;
import org.processmining.framework.connections.annotations.ConnectionObjectFactory;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.PluginExecutionResult;
import org.processmining.framework.plugin.PluginManager;
import org.processmining.framework.plugin.PluginParameterBinding;
import org.processmining.framework.plugin.events.ConnectionObjectListener;
import org.processmining.framework.plugin.events.Logger.MessageLevel;
import org.processmining.framework.util.Pair;

public class ConnectionManagerImpl implements ConnectionManager {

	private final Map<ConnectionID, Connection> connections = new HashMap<ConnectionID, Connection>();
	private final ConnectionObjectListener.ListenerList connectionListeners = new ConnectionObjectListener.ListenerList();
	private final PluginManager pluginManager;
	private boolean isEnabled = true;

	public ConnectionManagerImpl(PluginManager pluginManager) {
		this.pluginManager = pluginManager;

	}

	/**
	 * Returns the list of registered connectionObject listeners
	 * 
	 * @return the list of registered connectionObject listeners
	 */
	public ConnectionObjectListener.ListenerList getConnectionListeners() {
		return connectionListeners;
	}

	public boolean isEnabled() {
		return isEnabled;
	}

	public void setEnabled(boolean isEnabled) {
		this.isEnabled = isEnabled;
	}

	public void clear() {
		connections.clear();
	}
	
	public <T extends Connection> T addConnection(T connection) {
		if (isEnabled) {
			synchronized (connections) {
				connections.put(connection.getID(), connection);
				connection.setManager(this);
				connectionListeners.fireConnectionCreated(connection.getID());
			}
		}
		return connection;
	}

	public Connection getConnection(ConnectionID id) throws ConnectionCannotBeObtained {
		Connection c = connections.get(id);
		synchronized (connections) {
			if (c == null || c.isRemoved()) {
				connections.remove(c);
				connectionListeners.fireConnectionDeleted(id);
				if (c != null)
					throw new ConnectionCannotBeObtained(""Objects were deleted"", c.getClass());
				else
					throw new ConnectionCannotBeObtained(""Objects were deleted"", Object.class);
			}
			return c;
		}
	}

	public <T extends Connection> T getFirstConnection(Class<T> connectionType, PluginContext context,
			Object... objects) throws ConnectionCannotBeObtained {
		return getConnections(true, connectionType, context, objects).iterator().next();
	}

	public <T extends Connection> Collection<T> getConnections(Class<T> connectionType, PluginContext context,
			Object... objects) throws ConnectionCannotBeObtained {
		return getConnections(false, connectionType, context, objects);
	}

	@SuppressWarnings(""unchecked"")
	private <T extends Connection> Collection<T> getConnections(boolean stopAtFirst, Class<T> connectionType,
			PluginContext context, Object... objects) throws ConnectionCannotBeObtained {
		List<T> available = new ArrayList<T>(1);
		//System.gc();
		synchronized (connections) {
			Iterator<Map.Entry<ConnectionID, Connection>> it = connections.entrySet().iterator();
			while (it.hasNext()) {
				Entry<ConnectionID, Connection> entry = it.next();
				Connection c = entry.getValue();
				if (c.isRemoved()) {
					it.remove();
					connectionListeners.fireConnectionDeleted(c.getID());
					continue;
				}
				if (((connectionType == null) || connectionType.isAssignableFrom(c.getClass()))
						&& c.containsObjects(objects)) {
					context.log(""Connection found: "" + c, MessageLevel.DEBUG);
					available.add((T) c);
					if (stopAtFirst) {
						return available;
					}
				}
			}
		}
		if (!available.isEmpty()) {
			return available;
		}
		if ((connectionType == null) || (objects.length <= 1)) {
			throw new ConnectionCannotBeObtained(""No plugin available to create connection"", connectionType, objects);

		}
		Class<?>[] types = new Class<?>[objects.length];
		for (int i = 0; i < objects.length; i++) {
			types[i] = objects[i].getClass();
		}

		Collection<Pair<Integer, PluginParameterBinding>> plugins = pluginManager.find(ConnectionObjectFactory.class,
				connectionType, context.getClass(), true, false, false, types);
		if (plugins.isEmpty()) {
			throw new ConnectionCannotBeObtained(""No plugin available to create connection"", connectionType, objects);
		}
		PluginContext c2 = context.createChildContext(""Creating connection of Type "" + connectionType);
		Pair<Integer, PluginParameterBinding> pair = plugins.iterator().next();
		PluginParameterBinding binding = pair.getSecond();
		try {

			PluginExecutionResult pluginResult = binding.invoke(c2, objects);
			pluginResult.synchronize();
			T connectionObject = pluginResult.<T>getResult(pair.getFirst());

			if (connectionObject == null) {
				throw new ConnectionCannotBeObtained(""Factory plugin returned null."", connectionType, objects);
			}
			available.add(addConnection(connectionObject));
			context.log(""Added connection: "" + connectionObject, MessageLevel.DEBUG);
			return available;
		} catch (Exception e) {
			throw new ConnectionCannotBeObtained(e.getMessage(), connectionType, objects);
		} finally {
			c2.getParentContext().deleteChild(c2);
		}
	}

	public Collection<ConnectionID> getConnectionIDs() {
		return connections.keySet();
	}

}
"
CLI.java,context,"package org.processmining.contexts.cli;

import jargs.gnu.CmdLineParser;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.lang.reflect.InvocationTargetException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import org.processmining.contexts.scripting.ScriptExecutor;
import org.processmining.contexts.scripting.ScriptExecutor.ScriptExecutionException;
import org.processmining.contexts.scripting.Signature;
import org.processmining.framework.boot.Boot;
import org.processmining.framework.boot.Boot.Level;
import org.processmining.framework.plugin.annotations.Bootable;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.util.AutoHelpCommandLineParser;
import org.processmining.framework.util.CommandLineArgumentList;
import org.processmining.framework.util.Pair;

public class CLI {
	@Plugin(name = ""CLI"", parameterLabels = {}, returnLabels = {}, returnTypes = {}, userAccessible = false)
	@Bootable
	public Object main(CommandLineArgumentList commandlineArguments) throws Throwable {
		//try {
		if (Boot.VERBOSE != Level.NONE) {
			System.out.println(""Starting script execution engine..."");
			System.out.println(commandlineArguments);
		}

		CLIContext globalContext = new CLIContext();
		ScriptExecutor executor = new ScriptExecutor(globalContext.getMainPluginContext());
		Pair<List<String>, List<String>> params = parseCommandLine(commandlineArguments, executor);

		if (params != null) {
			List<String> scripts = params.getFirst();
			List<String> scriptArguments = params.getSecond();
			try {
				executor.bind(""arguments"", scriptArguments);

				for (String script : scripts) {
					executor.execute(script);
				}
			} catch (ScriptExecutionException e) {
				System.err.println(""Error while executing '""+commandlineArguments+""'"");
				System.err.println(e);
				throw e;
			}
		}
		//} catch (Throwable t) {
		//	t.printStackTrace();
		//	System.err.println(t);
			// System.exit(1);
		//}
		/*
		 * try { File f = new File(OsUtil.getProMUserDirectory(),
		 * ""testrepo.xml""); Repository repo = new Repository(f.toURI().toURL());
		 * PackageManager.getInstance().addRepository(repo);
		 * 
		 * PackageManager.getInstance().update();
		 * 
		 * PackageDescriptor toInstall = null; System.out.println(""Enabled:"");
		 * for (PackageDescriptor pack :
		 * PackageManager.getInstance().getEnabledPackages()) {
		 * System.out.println(""  -  "" + pack); }
		 * System.out.println(""Installed:""); for (PackageDescriptor pack :
		 * PackageManager.getInstance().getInstalledPackages()) {
		 * System.out.println(""  -  "" + pack); } System.out.println(""Latest:"");
		 * for (PackageDescriptor pack :
		 * PackageManager.getInstance().getLatestPackages()) {
		 * System.out.println(""  - "" + pack); if
		 * (pack.getName().equals(""holub"")) { toInstall = pack; } }
		 * PackageManager.getInstance().installOrUpdate(toInstall);
		 * PackageManager.getInstance().uninstall(toInstall);
		 * System.out.println(""Done."");
		 * System.out.println(PackageManager.getInstance()); } catch (Exception
		 * e) { e.printStackTrace(); }
		 */
		// System.exit(0);
		return null;
	}

	private Pair<List<String>, List<String>> parseCommandLine(CommandLineArgumentList arguments, ScriptExecutor executor)
			throws IOException {
		AutoHelpCommandLineParser parser = new AutoHelpCommandLineParser(""java "" + this.getClass().getCanonicalName());

		CmdLineParser.Option helpOption = parser.addHelp(parser.addBooleanOption('h', ""help""),
				""Print this help message and exit"");
		CmdLineParser.Option listOption = parser.addHelp(parser.addBooleanOption('l', ""list""),
				""List all available plugins on standard output and exit"");
		CmdLineParser.Option stdinOption = parser.addHelp(parser.addBooleanOption('i', ""stdin""),
				""Read script from standard input"");
		CmdLineParser.Option scriptOption = parser.addHelp(parser.addStringOption('s', ""script""),
				""Execute the script given on the command line"");
		CmdLineParser.Option fileOption = parser.addHelp(parser.addStringOption('f', ""file""),
				""Read script from the given file"");

		try {
			parser.parse(arguments.toStringArray());
		} catch (CmdLineParser.OptionException e) {
			System.err.println(e.getMessage());
			parser.printUsage();
			return null;
		}

		if ((Boolean) parser.getOptionValue(listOption, Boolean.FALSE)) {
			for (Signature plugin : executor.getAvailablePlugins()) {
				System.out.println(plugin.toString(25, 1));
			}
			return null;
		}
		if ((Boolean) parser.getOptionValue(helpOption, Boolean.FALSE)) {
			parser.printUsage();
			return null;
		}

		List<String> scripts = new ArrayList<String>();
		if ((Boolean) parser.getOptionValue(stdinOption, Boolean.FALSE)) {
			scripts.add(readFromStdin());
		}
		for (Object script : parser.getOptionValues(scriptOption)) {
			scripts.add(script.toString());
		}
		for (Object scriptFile : parser.getOptionValues(fileOption)) {
			scripts.add(readFile(scriptFile.toString()));
		}

		return new Pair<List<String>, List<String>>(scripts, new ArrayList<String>(Arrays.asList(parser
				.getRemainingArgs())));
	}

	public static String readFile(String scriptFile) throws IOException {
		InputStream is = new FileInputStream(scriptFile);
		String result = readWholeStream(is);
		is.close();
		return result;
	}

	private static String readFromStdin() throws IOException {
		return readWholeStream(System.in);
	}

	private static String readWholeStream(InputStream is) throws IOException {
		InputStreamReader reader = new InputStreamReader(new BufferedInputStream(is));
		StringBuffer result = new StringBuffer();
		int c;

		while ((c = reader.read()) != -1) {
			result.append((char) c);
		}
		return result.toString();
	}

	public static void main(String[] args) throws Throwable {
	  try {
	    Boot.boot(CLI.class, CLIPluginContext.class, args);
	  } catch (InvocationTargetException e) {
	    throw e.getCause();
	  }
	}
}
"
CLIContext.java,context,"package org.processmining.contexts.cli;

import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.impl.AbstractGlobalContext;

public class CLIContext extends AbstractGlobalContext {

	private final CLIPluginContext mainPluginContext;

	public CLIContext() {
		super();

		mainPluginContext = new CLIPluginContext(this, ""Main Plugin Context"");
	}

	@Override
	protected CLIPluginContext getMainPluginContext() {
		return mainPluginContext;
	}

	@Override
	public Class<? extends PluginContext> getPluginContextType() {
		return CLIPluginContext.class;
	}

}
"
CLIPluginContext.java,context,"package org.processmining.contexts.cli;

import java.util.concurrent.Executor;
import java.util.concurrent.Executors;

import org.processmining.framework.plugin.GlobalContext;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.Progress;
import org.processmining.framework.plugin.impl.AbstractPluginContext;

public class CLIPluginContext extends AbstractPluginContext {

	private final Executor executor;

	public CLIPluginContext(GlobalContext context, String label) {
		super(context, label);
		// This context is NOT a child of another context,
		// hence should behave in an asynchronous way.
		executor = Executors.newCachedThreadPool();
		progress = new CLIProgressBar(this);
	}

	protected CLIPluginContext(CLIPluginContext context, String label) {
		super(context, label);
		progress = new CLIProgressBar(this);
		// This context is a child of another context,
		// hence should behave in a synchronous way.
		if (context/*.getParentContext()*/ == null) {
			// this context is on the first level below the user-initiated
			// plugins
			executor = Executors.newCachedThreadPool();
		} else {
			// all subtasks take the pool of the parent.
			executor = context.getExecutor();
		}
	}

	@Override
	protected synchronized PluginContext createTypedChildContext(String label) {
		return new CLIPluginContext(this, label);
	}

	public Executor getExecutor() {
		return executor;
	}

	@Override
	public Progress getProgress() {
		return progress;
	}

	@Override
	public CLIContext getGlobalContext() {
		return (CLIContext) super.getGlobalContext();
	}

	@Override
	public CLIPluginContext getRootContext() {
		return (CLIPluginContext) super.getRootContext();
	}
}
"
CLIProgressBar.java,context,"package org.processmining.contexts.cli;

import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.impl.ProgressBarImpl;

public class CLIProgressBar extends ProgressBarImpl {

	public CLIProgressBar(PluginContext context) {
		super(context);
	}
}
"
PromTestException.java,context,"package org.processmining.contexts.cli;

import java.io.PrintWriter;
import java.io.StringWriter;
import java.lang.reflect.Method;
import java.util.List;

import junit.framework.AssertionFailedError;

/**
 * Exception that stores all collected failed tests that arised in {@link PromTestFramework}.
 * Call {@link #toString()} for a formatted test report.
 * 
 * @author dfahland
 */
public class PromTestException extends Exception {

	/**
	 * 
	 */
	private static final long serialVersionUID = 3476724712772295479L;
	
	/**
	 * Associates a test case to a thrown exception that occurred during
	 * its execution.
	 */
	protected static class WrappedException {
		protected Method test = null;
		protected String testScript = null;
		protected Throwable thrown = null;
		
		public WrappedException(Method test, Throwable thrown) {
			this.test = test;
			this.thrown = thrown;
		}
		
		public WrappedException(String testScript, Throwable thrown) {
			this.testScript = testScript;
			this.thrown = thrown;
		}
	}
	
	/**
	 * Associates a test case to expected and returned results in case the test was not
	 * successful.
	 */
	protected static class ResultMismatch {
		protected Method test = null;
		protected String expected = null;
		protected String result = null;
		
		protected String testScript = null;
		protected AssertionFailedError junitResult = null;
		
		public ResultMismatch(Method test, String expected, String result) {
			this.test = test;
			this.expected = expected;
			this.result = result;
		}
		
		public ResultMismatch(String testScript, AssertionFailedError junitResult) {
			this.testScript = testScript;
			this.junitResult = junitResult;
		}

	}
	
	private List<ResultMismatch> failures;
	private List<WrappedException> errors;
	
	public PromTestException(List<ResultMismatch> failures, List<WrappedException> errors) {
		this.failures = failures;
		this.errors = errors;
	}
	
	public String toString() {
		
		StringBuilder sb = new StringBuilder();

		sb.append(""============================================================\n"");
		sb.append(""Number of failed tests: ""+failures.size()+""\n"");
		sb.append(""============================================================\n"");
		for (ResultMismatch fail : failures) {
			if (fail.test != null)
				sb.append(getTestName(fail.test)+""\n"");
			else
				sb.append(fail.testScript+""\n"");
			
			if (fail.junitResult != null) {
				sb.append(""--- ASSERTION FAILED ---------------------------------------\n"");
				sb.append(fail.junitResult.toString()+""\n"");				
				sb.append(""============================================================\n"");
			} else {
				sb.append(""--- RESULT -------------------------------------------------\n"");
				sb.append(fail.result+""\n"");
				sb.append(""--- EXPECTED -----------------------------------------------\n"");
				sb.append(fail.expected+""\n"");
				sb.append(""============================================================\n"");
			}
		}
		
		sb.append(""============================================================\n"");
		sb.append(""Number of errors: ""+errors.size()+""\n"");
		sb.append(""============================================================\n"");
		for (WrappedException error : errors) {
			if (error.test != null)
				sb.append(getTestName(error.test)+""\n"");
			else
				sb.append(error.testScript+""\n"");
			
			sb.append(""--- EXCEPTION ----------------------------------------------\n"");
			sb.append(error.thrown.toString()+""\n"");
			sb.append(""--- stack trace --------------------------------------------\n"");
		    final StringWriter result = new StringWriter();
		    final PrintWriter printWriter = new PrintWriter(result);
		    error.thrown.printStackTrace(printWriter);
			sb.append(result.toString()+""\n"");
			sb.append(""============================================================\n"");
		}

		return sb.toString();
	}

	private static String getTestName (Method m) {
		return m.getClass().toString()+"".""+m.getName();
	}
}
"
PromTestFramework.java,context,"package org.processmining.contexts.cli;

import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileFilter;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.net.MalformedURLException;
import java.net.URISyntaxException;
import java.net.URL;
import java.net.URLClassLoader;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.jar.JarEntry;
import java.util.jar.JarInputStream;

import org.processmining.framework.annotations.TestMethod;
import org.processmining.framework.boot.Boot;
import org.processmining.framework.boot.Boot.Level;
import org.processmining.framework.plugin.PluginManager;
import org.processmining.framework.plugin.annotations.Bootable;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.impl.PluginCacheEntry;
import org.processmining.framework.util.CommandLineArgumentList;

public class PromTestFramework {

	@Plugin(name = ""ProMTest"", parameterLabels = {}, returnLabels = {}, returnTypes = {}, userAccessible = false)
	@Bootable
	public Object main(CommandLineArgumentList commandlineArguments) throws Throwable {
		System.out.println(""Entering ProM Test Framework"");
		
		// from where do we read the tests
		String classesToTestDir = null;			// default
		
		if (commandlineArguments.size() != 2)
			throw new Exception(""Error. The ProM Test Framework requires 2 arguments: (1) location of classes that contain tests, (2) location of test files"");
		
		// directory where test cases are stored
		classesToTestDir = commandlineArguments.get(0); 
		// read location where test input files and expected test outputs are stored
		final String testFileRoot = commandlineArguments.get(1);
		
		// scan directory for tests
		getAllTestMethods(classesToTestDir);
		
		// and run tests, collect all failed tests
		List<PromTestException.ResultMismatch> failedTest = new LinkedList<PromTestException.ResultMismatch>();
		List<PromTestException.WrappedException> errorTest = new LinkedList<PromTestException.WrappedException>();
		
		System.out.println(""Running ""+testMethods.size()+"" tests:"");
		for (Method test : testMethods) {
			
			try {
				System.out.println(test);
				
				// run test and get test result
				String result = (String)test.invoke(null);
				// load expected result
				String expected = null;
				if (testResultFromOutputAnnotation(test)) {
					expected = test.getAnnotation(TestMethod.class).output();
				} else if (testResultFromFile(test)) {
					expected = readFile(testFileRoot+""/""+test.getAnnotation(TestMethod.class).filename());
				}
				// compare result and expected
				if (!result.equals(expected)) {
					// test failed, store for reporting
					failedTest.add(
						new PromTestException.ResultMismatch(test, expected, result));
				}
			} catch (Throwable e) {
				// test crashed, store exception for reporting
				errorTest.add(
						new PromTestException.WrappedException(test, e));
			}
		}
		
		if (!failedTest.isEmpty() || ! errorTest.isEmpty()) {
			throw new PromTestException(failedTest, errorTest);
		}
		
    	return null;
	}
	
	private void getAllTestMethods(String lookUpDir) throws Exception {
		
		URL[] defaultURLs;
		
		if (lookUpDir == null) {
			URLClassLoader sysloader = (URLClassLoader) ClassLoader.getSystemClassLoader();
			defaultURLs = sysloader.getURLs();
		} else {
			File f = new File(lookUpDir);
			defaultURLs = new URL[] { f.toURI().toURL()	};
		}
		
		File f = new File(""."" + File.separator + Boot.LIB_FOLDER);
		String libPath = f.getCanonicalPath();

		for (URL url : defaultURLs) {
			if (Boot.VERBOSE == Level.ALL) {
				System.out.println(""Processing url: "" + url);
			}
			if (!(new File(url.toURI()).getCanonicalPath().startsWith(libPath))) {
				if (Boot.VERBOSE == Level.ALL) {
					System.out.println(""Scanning for tests: "" + url);
				}
				register(url);
			} else {
				if (Boot.VERBOSE == Level.ALL) {
					System.out.println(""Skipping: "" + url.getFile() + "" while scanning for tests."");
				}
			}
		}
	}
	
	/**
	 * (non-Javadoc)
	 * 
	 * @see
	 * org.processmining.framework.plugin.PluginManager#register(java.net.URL)
	 */
	public void register(URL url) {
		if (url.getProtocol().equals(PluginManager.FILE_PROTOCOL)) {
			try {
				File file = new File(url.toURI());

				if (file.isDirectory()) {
					scanDirectory(file);
					return;
				}
				// we ignore: PluginManager.MCR_EXTENSION
				else if (file.getAbsolutePath().endsWith(PluginManager.JAR_EXTENSION)) {
					scanUrl(url);
				}
			} catch (URISyntaxException e) {
				// fireError(url, e, null);
				System.err.println(e);
			}
		} else {
			// scanUrl(url);
			System.err.println(""Loading tests from ""+url+"" not supported."");
		}
	}
	
	private void scanDirectory(File file) {
		try {
			URL url = file.toURI().toURL();
			URLClassLoader loader = new URLClassLoader(new URL[] { url });

			Queue<File> todo = new LinkedList<File>();
			FileFilter filter = new FileFilter() {
				public boolean accept(File pathname) {
					return pathname.isDirectory() || pathname.getPath().endsWith(PluginManager.CLASS_EXTENSION);
				}
			};

			todo.add(file);
			while (!todo.isEmpty()) {
				File dir = todo.remove();

				for (File f : dir.listFiles(filter)) {
					if (f.isDirectory()) {
						todo.add(f);
					} else {
						if (f.getAbsolutePath().endsWith(PluginManager.CLASS_EXTENSION)) {
							loadClassFromFile(loader, url,
									makeRelativePath(file.getAbsolutePath(), f.getAbsolutePath()));
						}
					}
				}
			}
		} catch (MalformedURLException e) {
			//fireError(null, e, null);
			System.err.println(e);
		}
	}
	
	private void scanUrl(URL url) {
		URLClassLoader loader = new URLClassLoader(new URL[] { url });
		PluginCacheEntry cached = new PluginCacheEntry(url, Boot.VERBOSE);

		if (cached.isInCache()) {
			for (String className : cached.getCachedClassNames()) {
				loadClass(loader, url, className);
			}
		} else {
			try {
				InputStream is = url.openStream();
				JarInputStream jis = new JarInputStream(is);
				JarEntry je;
				List<String> loadedClasses = new ArrayList<String>();

				while ((je = jis.getNextJarEntry()) != null) {
					if (!je.isDirectory() && je.getName().endsWith(PluginManager.CLASS_EXTENSION)) {
						String loadedClass = loadClassFromFile(loader, url, je.getName());
						loadedClasses.add(loadedClass);
					}
				}
				jis.close();
				is.close();

				cached.update(loadedClasses);
			} catch (IOException e) {
				//fireError(url, e, null);
				System.err.println(e);
			}
		}
	}


	private String makeRelativePath(String root, String absolutePath) {
		String relative = absolutePath;

		if (relative.startsWith(root)) {
			relative = relative.substring(root.length());
			if (relative.startsWith(File.separator)) {
				relative = relative.substring(File.separator.length());
			}
		}
		return relative;
	}
	
	private static final char PACKAGE_SEPARATOR = '.';
	private static final char URL_SEPARATOR = '/';
	private static final char INNER_CLASS_MARKER = '$';

	
	private String loadClassFromFile(URLClassLoader loader, URL url, String classFilename) {
		if (classFilename.indexOf(INNER_CLASS_MARKER) >= 0) {
			// we're not going to load inner classes
			return null;
		}
		return loadClass(loader, url, classFilename.substring(0, classFilename.length() - PluginManager.CLASS_EXTENSION.length())
				.replace(URL_SEPARATOR, PACKAGE_SEPARATOR).replace(File.separatorChar, PACKAGE_SEPARATOR));
	}
	

	private final List<Method> testMethods = new LinkedList<Method>();
	
	/**
	 * Returns the name of the class, if it is annotated, or if any of its
	 * methods carries a plugin annotation!
	 * 
	 * @param loader
	 * @param url
	 * @param className
	 * @return
	 */
	private String loadClass(URLClassLoader loader, URL url, String className) {
		boolean isAnnotated = false;

		if ((className == null) || className.trim().equals("""")) {
			return null;
		}

		className = className.trim();
		try {
			Class<?> pluginClass = Class.forName(className, false, loader);
			/*
			// Check if plugin annotation is present
			if (pluginClass.isAnnotationPresent(Plugin.class) && isGoodPlugin(pluginClass)) {
				PluginDescriptorImpl pl = new PluginDescriptorImpl(pluginClass, pluginContextType);
				addPlugin(pl);
			}*/

			for (Method method : pluginClass.getMethods()) {
				
				if (method.isAnnotationPresent(TestMethod.class) && isGoodTest(method)) {
					testMethods.add(method);
				}
			}
		} catch (Throwable t) {
			// fireError(url, t, className);
			if (Boot.VERBOSE != Level.NONE) {
				System.err.println(""[Framework] ERROR while scanning for testable plugins at: "" + url + "":"");
				System.err.println(""   in file :"" + className);
				System.err.println(""   "" + t.getMessage());
				t.printStackTrace();
			}
		}
		return isAnnotated ? className : null;
	}
	
	private boolean isGoodTest(Method method) {
		
		assert(method.isAnnotationPresent(TestMethod.class));
		
		// check annotations
		if (!testResultFromFile(method) && !testResultFromOutputAnnotation(method)) {
			if (Boot.VERBOSE != Level.NONE) {
				System.err.println(""Test "" + method.toString() + "" could not be loaded. ""
						+ ""No expected test result specified."");
			}
			return false;
		}

		// check return type: must be String
		if ((method.getModifiers() & Modifier.STATIC) == 0) {
			if (Boot.VERBOSE != Level.NONE) {
				System.err.println(""Test "" + method.toString() + "" could not be loaded. ""
						+ ""Test must be static."");
			}
			return false;
		}

		// check return type: must be String
		if (!method.getReturnType().equals(String.class)) {
			if (Boot.VERBOSE != Level.NONE) {
				System.err.println(""Test "" + method.toString() + "" could not be loaded. ""
						+ ""Return result must be java.lang.String"");
			}
			return false;
		}

		// check parameter types: must be empty
		Class<?>[] pars = method.getParameterTypes();
		if (pars != null && pars.length > 0) {
			if (Boot.VERBOSE != Level.NONE) {
				System.err.println(""Test "" + method.toString() + "" could not be loaded. ""
						+ ""A test must not take any parameters."");
			}
			return false;			
		}
		return true;
	}

	/**
	 * @param method
	 * @return <code>true</code> iff the method is annotated with
	 *         {@link TestMethod#filename()}. Then the result of the test will
	 *         be compared to the contents of a file.
	 */
	private static boolean testResultFromFile(Method method) {
		assert(method.isAnnotationPresent(TestMethod.class));		
		return 
			method.getAnnotation(TestMethod.class).filename() != null
			&& !method.getAnnotation(TestMethod.class).filename().isEmpty();
	}

	/**
	 * @param method
	 * @return <code>true</code> iff the method is annotated with
	 *         {@link TestMethod#output()}. Then the result of the test will
	 *         be compared to the specified string.
	 */
	private static boolean testResultFromOutputAnnotation(Method method) {
		assert(method.isAnnotationPresent(TestMethod.class));
		return
			method.getAnnotation(TestMethod.class).output() != null
			&& !method.getAnnotation(TestMethod.class).output().isEmpty();
	}
	
	private static String readFile(String scriptFile) throws IOException {
		InputStream is = new FileInputStream(scriptFile);
		String result = readWholeStream(is);
		is.close();
		return result;
	}

	private static String readWholeStream(InputStream is) throws IOException {
		InputStreamReader reader = new InputStreamReader(new BufferedInputStream(is));
		StringBuffer result = new StringBuffer();
		int c;

		while ((c = reader.read()) != -1) {
			result.append((char) c);
		}
		return result.toString();
	}
	
	public static void main(String[] args) throws Throwable {
	  try {
	    Boot.boot(PromTestFramework.class, CLIPluginContext.class, args);
	  } catch (InvocationTargetException e) {
	    throw e.getCause();
	  }
	}
}
"
ScriptExecutor.java,context,"package org.processmining.contexts.scripting;

import java.io.FileNotFoundException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Set;
import java.util.concurrent.ExecutionException;

import org.processmining.framework.boot.Boot;
import org.processmining.framework.boot.Boot.Level;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.PluginDescriptor;
import org.processmining.framework.plugin.annotations.CLI;
import org.processmining.framework.util.StringUtils;

import bsh.EvalError;
import bsh.Interpreter;
import bsh.TargetError;

/**
 * Script interpretor for ProM. The class provides a wrapper around
 * the Java BSH {@link Interpreter} to initialize all available plugins
 * from the .ProM user directory in an {@link Interpreter}. This
 * interpreter can the be used to interpret Java code at run-time
 * against the plugins, which allows for scripted execution of ProM plugins.
 * 
 * @author dfahland and others
 */
public class ScriptExecutor {

	// the interpreter used to run a script
	private Interpreter interpreter;
	// the plugin context in which the interpreter is executed, it
	// allows to retrieve the available plugins
	private final PluginContext context;

	// set of all method signatures announced by available plugins
	private Set<Signature> availablePlugins;
	// set of all method signatures announced by plugins that could not
	// be loaded for one reason or the other
	private Set<Signature> failedPlugins;

	/**
	 * Meant to provide diagnostic information in case a script fails.
	 */
	public class ScriptExecutionException extends Exception {

		private static final long serialVersionUID = -4777627419215658865L;

		public ScriptExecutionException(EvalError e) {
			super(e);
		}
		
		public ScriptExecutionException(String e) {
			super(e);
		}
	}

	/**
	 * Initialize a new interpreter with all available plugins.
	 * 
	 * @param context
	 * @throws ScriptExecutionException
	 */
	public ScriptExecutor(PluginContext context) throws ScriptExecutionException {
		this.context = context;
		
		availablePlugins = new HashSet<Signature>();
		failedPlugins = new HashSet<Signature>();
		
		init();
	}

	/**
	 * Execute a script in the interpreter.
	 * 
	 * @param script
	 * @throws ScriptExecutionException
	 */
	public void execute(String script) throws Throwable {
		try {
			interpreter.eval(script);
		} catch (EvalError e) {
		  
			// provide more detailed error messages
			if (e instanceof TargetError) {
				TargetError e2 = (TargetError)e;
				
				if (e2.getTarget() instanceof ExecutionException) {
					ExecutionException e3 = (ExecutionException)e2.getTarget();
					
					if (e3.getCause() instanceof FileNotFoundException) {
						System.err.println(""Error. The script tries to access a non-existing file path:\n  ""+
								((FileNotFoundException)e3.getCause()).getMessage());
					}
					
				  throw e3.getCause();
				} else if (e2.getTarget() instanceof java.util.concurrent.CancellationException) {
				  System.err.println(""Script execution was cancelled. Message:\n""+e);
				  throw e2.getTarget();
				} else if (e2.getTarget() instanceof java.lang.AssertionError) {
				  throw e2.getTarget();
				}
			}
			throw new ScriptExecutionException(e);
		}
	}
	
	/**
	 * Iterate over all registered plugins, find their declared methods
	 * and try to create an invocation context for each. Return the list
	 * of plugins that succeeded, and save the list of methods that failed.
	 * 
	 * @return
	 */
	private LinkedList<PluginDescriptor> workingPlugins() {
		LinkedList<PluginDescriptor> workingPlugins = new LinkedList<PluginDescriptor>();

		Set<Signature> foundSignatures = new HashSet<Signature>();
		String nl = System.getProperty(""line.separator"");
		int pluginIndex = 0;

		for (PluginDescriptor plugin : context.getPluginManager().getAllPlugins())
		{
			if (Boot.VERBOSE == Level.ALL) System.out.println(""checking ""+plugin.getName());

			// method signatures of this plugin
			Set<Signature> thisPluginSignatures = new HashSet<Signature>();
			
			try {
				
				StringBuffer init = new StringBuffer();
				Interpreter pluginInterpreter = new Interpreter();
				pluginInterpreter.set(""__main_context"", context);
				
				// the right context type is checked at start by the
				// pluginmanager
				// if
				// (plugin.getContextType().isAssignableFrom(context.getClass()))
				// {
				for (int j = 0; j < plugin.getParameterTypes().size(); j++) {
					Signature signature = getSignature(plugin, j);
					thisPluginSignatures.add(signature);

					if (!foundSignatures.contains(signature)) {
						foundSignatures.add(signature);
						pluginIndex++;

						pluginInterpreter.set(""__plugin_descriptor"" + pluginIndex, plugin);
						pluginInterpreter.set(""__plugin_method_index"" + pluginIndex, j);

						if (signature.getReturnTypes().size() == 1) {
							init.append(Object.class.getCanonicalName());
						} else {
							init.append(Object[].class.getCanonicalName());
						}
						init.append("" "" + signature.getName() + ""("");

						int index = 0;
						for (Class<?> cl : signature.getParameterTypes()) {
							if (index > 0) {
								init.append("", "");
							}
							init.append(cl.getCanonicalName());
							init.append("" p"" + index++);
						}
						init.append("") {"" + nl);
						init.append(""    "" + PluginContext.class.getCanonicalName()
								+ "" context = __main_context.createChildContext(\""Result of "");
						init.append(signature.getName() + ""\"");"" + nl);

						init.append(""    __plugin_descriptor"" + pluginIndex + "".invoke(__plugin_method_index""
								+ pluginIndex + "", context, new "" + (Object[].class.getCanonicalName()) + "" { "");
						for (int i = 0; i < signature.getParameterTypes().size(); i++) {
							if (i > 0) {
								init.append("", "");
							}
							init.append(""p"" + i);
						}
						init.append("" });"" + nl);

						if (signature.getReturnTypes().size() > 1) {
							init.append(""    context.getResult().synchronize();"" + nl);
							init.append(""    "" + Object[].class.getCanonicalName() + "" result = new ""
									+ Object.class.getCanonicalName() + ""[context.getResult().getSize()];"" + nl);
							init
									.append(""    for (int i = 0; i < result.length; i++) { result[i] = context.getResult().getResult(i); }""
											+ nl);
							init.append(""    return result;"" + nl);
						} else {
							init.append(""    return context.getFutureResult(0).get();"" + nl);
						}
						init.append(""}"" + nl);
					}
				}

				//pluginInterpreter.eval(init.toString());
				workingPlugins.addLast(plugin);		// this plugin works, remeber it
			
			} catch (EvalError e) {
				System.err.println(""Failed to load plugin ""+plugin.getName());
				failedPlugins.addAll(thisPluginSignatures);
				
			} catch (NoClassDefFoundError e) {
				System.err.println(""Failed to load plugin ""+plugin.getName());
				System.err.println(""Missing class ""+e.getMessage());
				failedPlugins.addAll(thisPluginSignatures);
			}
			workingPlugins.addLast(plugin);
		}
		return workingPlugins;
	}

	private void init() throws ScriptExecutionException {
		String nl = System.getProperty(""line.separator"");
		int pluginIndex = 0;

		try {
		StringBuffer init = new StringBuffer();
		interpreter = new Interpreter();
		interpreter.set(""__main_context"", context);
		
		System.out.println(""initializing all plugins"");
	
    	for (PluginDescriptor plugin : context.getPluginManager().getAllPlugins()) {
    	// skip scanning for working plugins. question: why does scanning for working plugins
    	// take so much more time?
		//for (PluginDescriptor plugin : workingPlugins()) {
			
			if (Boot.VERBOSE == Level.ALL) System.out.println(""initializing ""+plugin.getName());
			// the right context type is checked at start by the pluginmanager
			// if (plugin.getContextType().isAssignableFrom(context.getClass()))
			// {
			for (int j = 0; j < plugin.getParameterTypes().size(); j++) {
				Signature signature = getSignature(plugin, j);

				if (!availablePlugins.contains(signature)) {
					availablePlugins.add(signature);
					pluginIndex++;

					interpreter.set(""__plugin_descriptor"" + pluginIndex, plugin);
					interpreter.set(""__plugin_method_index"" + pluginIndex, j);

					// The following code generates a piece of Java code which declares a Java method.
					// This Java method is a wrapper for the plugin method we are currently initializing.
					// The name of the new Java method is a transcription of the name that was declared in
					// the @PluginVariant{} annotation of the plugin (or the name of the owning @Plugin class).
					// The body of the wrapper method uses ProM's invocation context and plugin descriptor
					// to correctly call the plugin with the given parameters, it also returns the results
					// after the plugin had been executed.

					// A script can then use the transcribed name of the Java plugin to call the plugin.

					// signature of the wrapper method: return type, name, ...
					if (signature.getReturnTypes().size() == 1) {
						init.append(Object.class.getCanonicalName());
					} else {
						init.append(Object[].class.getCanonicalName());
					}
					init.append("" "" + signature.getName() + ""("");

					// signature of the wrapper method: ... parameters ...
					int index = 0;
					for (Class<?> cl : signature.getParameterTypes()) {
						if (index > 0) {
							init.append("", "");
						}
						init.append(cl.getCanonicalName());
						init.append("" p"" + index++);
					}

					// body of the wrapper method: get execution context and invoke plugin
					init.append("") {"" + nl);
					init.append(""    "" + PluginContext.class.getCanonicalName()
							+ "" context = __main_context.createChildContext(\""Result of "");
					init.append(signature.getName() + ""\"");"" + nl);

					init.append(""    __plugin_descriptor"" + pluginIndex + "".invoke(__plugin_method_index""
							+ pluginIndex + "", context, new "" + (Object[].class.getCanonicalName()) + "" { "");
					for (int i = 0; i < signature.getParameterTypes().size(); i++) {
						if (i > 0) {
							init.append("", "");
						}
						init.append(""p"" + i);
					}
					init.append("" });"" + nl);

					// body of the wrapper method: wait for plugin method to complete and return result
					if (signature.getReturnTypes().size() > 1) {
						init.append(""    context.getResult().synchronize();"" + nl);
						init.append(""    "" + Object[].class.getCanonicalName() + "" result = new ""
								+ Object.class.getCanonicalName() + ""[context.getResult().getSize()];"" + nl);
						init
						.append(""    for (int i = 0; i < result.length; i++) { result[i] = context.getResult().getResult(i); }""
								+ nl);
						init.append(""    return result;"" + nl);
					} else {
						init.append(""    return context.getFutureResult(0).get();"" + nl);
					}
					init.append(""}"" + nl);
					// finished declaring wrapper method 
				}
			} // for each plugin variant
    	} // for each plugin

    	// compile the Java code for all wrapper methods
    	interpreter.eval(init.toString());
				
		} catch (EvalError e) {
			System.err.println(""Failed to load one of the plugins."");
			throw new ScriptExecutionException(e);
		} catch (NoClassDefFoundError e) {
			System.err.println(""Failed to load one of the plugins."");
			throw new ScriptExecutionException(""Missing class ""+e.getMessage());
		}
	}

	private Signature getSignature(PluginDescriptor plugin, int index) {
		String name;

		if (plugin.hasAnnotation(CLI.class)) {
			name = plugin.getAnnotation(CLI.class).functionName();
		} else {
			name = plugin.getName();
		}
		return new Signature(plugin.getReturnTypes(), StringUtils.getJavaIdentifier(name), plugin
				.getParameterTypes(index));
	}

	public void bind(String name, Object value) throws ScriptExecutionException {
		try {
			interpreter.set(name, value);
		} catch (EvalError e) {
			throw new ScriptExecutionException(e);
		}
	}

	public List<Signature> getAvailablePlugins() {
		List<Signature> result = new ArrayList<Signature>(availablePlugins);

		Collections.sort(result, new Comparator<Signature>() {
			public int compare(Signature a, Signature b) {
				return a.getName().compareTo(b.getName());
			}
		});
		return result;
	}
}
"
Signature.java,context,"package org.processmining.contexts.scripting;

import java.util.Collections;
import java.util.List;

public class Signature {

	private final String name;
	private final List<Class<?>> parameterTypes;
	private final List<Class<?>> returnTypes;

	Signature(List<Class<?>> returnTypes, String name, List<Class<?>> parameterTypes) {
		this.returnTypes = returnTypes;
		this.name = name;
		this.parameterTypes = parameterTypes;
	}

	public boolean equals(Object o) {
		if (!(o instanceof Signature)) {
			return false;
		}
		Signature other = (Signature) o;
		return name.equals(other.name) && parameterTypes.equals(other.parameterTypes);
	}

	public int hashCode() {
		return name.hashCode();
	}

	public String getName() {
		return name;
	}

	public List<Class<?>> getParameterTypes() {
		return Collections.unmodifiableList(parameterTypes);
	}

	public List<Class<?>> getReturnTypes() {
		return returnTypes;
	}

	public String toString() {
		return toString(1, 1);
	}

	public String toString(int indent1, int indent2) {
		String result = getName() + ""("";

		boolean isFirst = true;
		for (Class<?> param : getParameterTypes()) {
			if (isFirst) {
				isFirst = false;
			} else {
				result += "", "";
			}
			result += param.getSimpleName();
		}
		result += "") -> "";

		if (getReturnTypes().size() > 1) {
			result += ""("";
		}
		isFirst = true;
		for (Class<?> type : getReturnTypes()) {
			if (isFirst) {
				isFirst = false;
			} else {
				result += "", "";
			}
			result += type.getSimpleName();
		}
		if (getReturnTypes().size() > 1) {
			result += "")"";
		}
		return result;
	}
}
"
AllInclassMethodTests.java,context,"package org.processmining.contexts.test;

import java.io.File;
import java.io.FileFilter;
import java.io.IOException;
import java.io.InputStream;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.net.MalformedURLException;
import java.net.URISyntaxException;
import java.net.URL;
import java.net.URLClassLoader;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.jar.JarEntry;
import java.util.jar.JarInputStream;

import org.processmining.framework.annotations.TestMethod;
import org.processmining.framework.boot.Boot;
import org.processmining.framework.boot.Boot.Level;
import org.processmining.framework.plugin.PluginManager;

/**
 * Utility class to collect all methods annotated with <code>@TestMethod</code>
 * from a given location of compiled Java classes.
 * 
 * @author dfahland
 */
public class AllInclassMethodTests {

	// the list fo all found methods
	private final List<Method> testMethods = new LinkedList<Method>();
	
	/**
	 * @return all found methods
	 */
	public List<Method> getAllTestMethods() {
		return testMethods;
	}
	
	/**
	 * Find all methods with annotation <code>@TestMethod</code> in the given
	 * loop up directory. The classes can be stored inside a JAR file. The list
	 * of found methods can be retrieved with {@link #getAllTestMethods()}.
	 * 
	 * This method can be run several times to scan classes from different
	 * directories.
	 * 
	 * @param lookUpDir
	 */
	public void collectAllTestMethods(String lookUpDir)  {
		
		System.out.println(""Collecting inclass method tests from ""+lookUpDir);

		try {
	
			URL[] defaultURLs;
			
			if (lookUpDir == null) {
				URLClassLoader sysloader = (URLClassLoader) ClassLoader.getSystemClassLoader();
				defaultURLs = sysloader.getURLs();
			} else {
				File f = new File(lookUpDir);
				defaultURLs = new URL[] { f.toURI().toURL()	};
			}
			
			File f = new File(""."" + File.separator + Boot.LIB_FOLDER);
			String libPath = f.getCanonicalPath();
	
			for (URL url : defaultURLs) {
				if (Boot.VERBOSE == Level.ALL) {
					System.out.println(""Processing url: "" + url);
				}
				if (!(new File(url.toURI()).getCanonicalPath().startsWith(libPath))) {
					if (Boot.VERBOSE == Level.ALL) {
						System.out.println(""Scanning for tests: "" + url);
					}
					register(url);
				} else {
					if (Boot.VERBOSE == Level.ALL) {
						System.out.println(""Skipping: "" + url.getFile() + "" while scanning for tests."");
					}
				}
			}
		} catch (MalformedURLException e) {
			System.err.println(lookUpDir+"" gives an invalid URL.\n""+e);
		} catch (URISyntaxException e) {
			System.err.println(lookUpDir+"" gives an invalid URI.\n""+e);
		} catch (IOException e) {
			System.err.println(""Could not read ""+lookUpDir+""\n""+e);
		}
	}
	
	private void register(URL url) {
		if (url.getProtocol().equals(PluginManager.FILE_PROTOCOL)) {
			try {
				File file = new File(url.toURI());

				if (file.isDirectory()) {
					scanDirectory(file);
					return;
				}
				// we ignore: PluginManager.MCR_EXTENSION
				else if (file.getAbsolutePath().endsWith(PluginManager.JAR_EXTENSION)) {
					scanUrl(url);
				}
			} catch (URISyntaxException e) {
				// fireError(url, e, null);
				System.err.println(e);
			}
		} else {
			// scanUrl(url);
			System.err.println(""Loading tests from ""+url+"" not supported."");
		}
	}
	
	private void scanDirectory(File file) {
		try {
			URL url = file.toURI().toURL();
			URLClassLoader loader = new URLClassLoader(new URL[] { url });

			Queue<File> todo = new LinkedList<File>();
			FileFilter filter = new FileFilter() {
				public boolean accept(File pathname) {
					return pathname.isDirectory() || pathname.getPath().endsWith(PluginManager.CLASS_EXTENSION);
				}
			};

			todo.add(file);
			while (!todo.isEmpty()) {
				File dir = todo.remove();

				for (File f : dir.listFiles(filter)) {
					if (f.isDirectory()) {
						todo.add(f);
					} else {
						if (f.getAbsolutePath().endsWith(PluginManager.CLASS_EXTENSION)) {
							loadClassFromFile(loader, url,
									makeRelativePath(file.getAbsolutePath(), f.getAbsolutePath()));
						}
					}
				}
			}
		} catch (MalformedURLException e) {
			//fireError(null, e, null);
			System.err.println(e);
		}
	}
	
	private void scanUrl(URL url) {
		URLClassLoader loader = new URLClassLoader(new URL[] { url });
		try {
			InputStream is = url.openStream();
			JarInputStream jis = new JarInputStream(is);
			JarEntry je;
			List<String> loadedClasses = new ArrayList<String>();

			while ((je = jis.getNextJarEntry()) != null) {
				if (!je.isDirectory() && je.getName().endsWith(PluginManager.CLASS_EXTENSION)) {
					String loadedClass = loadClassFromFile(loader, url, je.getName());
					loadedClasses.add(loadedClass);
				}
			}
			jis.close();
			is.close();

		} catch (IOException e) {
			//fireError(url, e, null);
			System.err.println(e);
		}
	}


	private String makeRelativePath(String root, String absolutePath) {
		String relative = absolutePath;

		if (relative.startsWith(root)) {
			relative = relative.substring(root.length());
			if (relative.startsWith(File.separator)) {
				relative = relative.substring(File.separator.length());
			}
		}
		return relative;
	}
	
	private static final char PACKAGE_SEPARATOR = '.';
	private static final char URL_SEPARATOR = '/';
	private static final char INNER_CLASS_MARKER = '$';

	
	private String loadClassFromFile(URLClassLoader loader, URL url, String classFilename) {
//		if (classFilename.indexOf(INNER_CLASS_MARKER) >= 0) {
//			// we're not going to load inner classes
//			return null;
//		}
		return loadClass(loader, url, classFilename.substring(0, classFilename.length() - PluginManager.CLASS_EXTENSION.length())
				.replace(URL_SEPARATOR, PACKAGE_SEPARATOR).replace(File.separatorChar, PACKAGE_SEPARATOR));
	}
	

	/**
	 * Returns the name of the class, if it is annotated, or if any of its
	 * methods carries a plugin annotation!
	 * 
	 * @param loader
	 * @param url
	 * @param className
	 * @return
	 */
	private String loadClass(URLClassLoader loader, URL url, String className) {
		boolean isAnnotated = false;

		if ((className == null) || className.trim().equals("""")) {
			return null;
		}

		className = className.trim();
		try {
			Class<?> pluginClass = Class.forName(className, false, loader);
			/*
			// Check if plugin annotation is present
			if (pluginClass.isAnnotationPresent(Plugin.class) && isGoodPlugin(pluginClass)) {
				PluginDescriptorImpl pl = new PluginDescriptorImpl(pluginClass, pluginContextType);
				addPlugin(pl);
			}*/

			for (Method method : pluginClass.getMethods()) {
				
				if (method.isAnnotationPresent(TestMethod.class) && isGoodTest(method)) {
					testMethods.add(method);
				}
			}
		} catch (Throwable t) {
			// fireError(url, t, className);
			if (Boot.VERBOSE != Level.NONE) {
				System.err.println(""[Framework] ERROR while scanning for tests at: "" + url + "":"");
				System.err.println(""   in file :"" + className);
				System.err.println(""   "" + t.getMessage());
				t.printStackTrace();
			}
		}
		return isAnnotated ? className : null;
	}
	
	private boolean isGoodTest(Method method) {
		
		assert(method.isAnnotationPresent(TestMethod.class));
		
		// check annotations
		if (!testExpectedFromFile(method) && !testExpectedFromOutputAnnotation(method)) {
			if (Boot.VERBOSE != Level.NONE) {
				System.err.println(""Test "" + method.toString() + "" could not be loaded. ""
						+ ""No expected test result specified."");
			}
			return false;
		}

		// check return type: must be String
		if ((method.getModifiers() & Modifier.STATIC) == 0) {
			if (Boot.VERBOSE != Level.NONE) {
				System.err.println(""Test "" + method.toString() + "" could not be loaded. ""
						+ ""Test must be static."");
			}
			return false;
		}

		// check return type: must be String
		if (!method.getReturnType().equals(String.class)) {
			if (Boot.VERBOSE != Level.NONE) {
				System.err.println(""Test "" + method.toString() + "" could not be loaded. ""
						+ ""Return result must be java.lang.String"");
			}
			return false;
		}

		// check parameter types: must be empty
		Class<?>[] pars = method.getParameterTypes();
		if (pars != null && pars.length > 0) {
			if (Boot.VERBOSE != Level.NONE) {
				System.err.println(""Test "" + method.toString() + "" could not be loaded. ""
						+ ""A test must not take any parameters."");
			}
			return false;			
		}
		return true;
	}

	/**
	 * @param method
	 * @return <code>true</code> iff the method is annotated with
	 *         {@link TestMethod#filename()}. Then the result of the test will
	 *         be compared to the contents of a file.
	 */
	public static boolean testExpectedFromFile(Method method) {
		assert(method.isAnnotationPresent(TestMethod.class));		
		return 
			method.getAnnotation(TestMethod.class).filename() != null
			&& !method.getAnnotation(TestMethod.class).filename().isEmpty();
	}

	/**
	 * @param method
	 * @return <code>true</code> iff the method is annotated with
	 *         {@link TestMethod#output()}. Then the result of the test will
	 *         be compared to the specified string.
	 */
	public static boolean testExpectedFromOutputAnnotation(Method method) {
		assert(method.isAnnotationPresent(TestMethod.class));
		return
			method.getAnnotation(TestMethod.class).output() != null
			&& !method.getAnnotation(TestMethod.class).output().isEmpty();
	}
	
	/**
	 * @param method
	 * @return <code>true</code> iff the method is annotated with
	 *         <code>{@link TestMethod#returnSystemOut()} == true</code>.
	 *         Then the return result of the method will be everything the
	 *         method wrote to {@link System#out}.
	 */
	public static boolean testResultFromSystemOut(Method method) {
		assert(method.isAnnotationPresent(TestMethod.class));
		return
			method.getAnnotation(TestMethod.class).returnSystemOut() == true;
	}
	
	public static String getTestName (Method m) {
		return m.getClass().toString()+"".""+m.getName();
	}
	
	@TestMethod(output=""correct output"")
	public static String test_basicOutputTest() {
		return ""correct output"";
	}
	
	@TestMethod(filename=""testresult_AllInclassMethodTests_basicFileTest.txt"")
	public static String test_basicFileTest() {
		return ""correct output (filetest)"";
	}

	@TestMethod(filename=""testresult_AllInclassMethodTests_basicFileTest.txt"", output=""correct output"")
	public static String test_dualTest() {
		return ""correct output"";
	}
	
	@TestMethod(filename=""testresult_AllInclassMethodTests_basicFileTest.txt"", returnSystemOut=true)
	public static String test_basicFileTest_OutputStream() {
		System.out.print(""correct output"");
		System.out.print("" (filetest)"");
		return null;
	}
}
"
AllStandardScriptTests.java,context,"package org.processmining.contexts.test;

import java.io.File;
import java.util.LinkedList;
import java.util.List;

/**
 * Utility class to collect all test scripts annotated in a given directory.
 * 
 * @author dfahland
 */
public class AllStandardScriptTests {
	
	public static final String TESTSCRIPT_FILE_EXTENSION = ""txt"";

	/**
	 * @param lookUpDir
	 * @return all test script files in the given directory
	 */
	public static List<String> getAllTestScripts(String lookUpDir) {
		
		System.out.println(""Collecting scripted tests from ""+lookUpDir);
		
		List<String> testScriptFiles = new LinkedList<String>();
		
		File dir = new File(lookUpDir);
		if (dir.isDirectory()) {
			for (String file : dir.list()) {
				if (file.endsWith(TESTSCRIPT_FILE_EXTENSION)) {
					testScriptFiles.add(file);
				}
			}
		} else if (lookUpDir.endsWith(TESTSCRIPT_FILE_EXTENSION)) {
			testScriptFiles.add(lookUpDir);
		}
		
		return testScriptFiles;
	}

}
"
FactoryRunner.java,context,"/****************************************************************************
 * Copyright (c) 2011. All rights reserved. Ted Young.
 * Original source code published at
 * http://tedyoung.me/2011/01/22/junit-runtime-tests-overview/
 * 
 * Code adapted for ProM by Dirk Fahland.
 ****************************************************************************/
package org.processmining.contexts.test.factory;

import java.lang.reflect.Modifier;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.LinkedList;
import java.util.List;

import org.junit.After;
import org.junit.Before;
import org.junit.runners.BlockJUnit4ClassRunner;
import org.junit.runners.model.FrameworkMethod;
import org.junit.runners.model.InitializationError;
import org.junit.runners.model.TestClass;

/**
 * A helper method that can be used to modify how JUnit executes a test suite.
 * Add annotation <code>@RunWith(FactoryRunner.class)</code> to the JUnit test
 * to hook this helper to the JUnit test suite. When executing the test suite
 * with JUnit, all methods of the test suite that are annotated with {@link TestFactory}
 * will be executed before all other tests. Each of these methods dynamically
 * adds a number of JUnit tests to the test suite.
 * 
 * @author Ted Young
 */
public class FactoryRunner extends BlockJUnit4ClassRunner {
	protected LinkedList<FrameworkMethod> tests = new LinkedList<FrameworkMethod>();

	public FactoryRunner(Class<?> clazz) throws InitializationError {
		super(clazz);
		try {
			computeTests();
		}
		catch (Exception e) {
			throw new InitializationError(e);
		}
	}

	protected void computeTests() throws Exception {
		tests.addAll(super.computeTestMethods());
		tests.addAll(computeFactoryTests());
		
		// This is called here to ensure the test class constructor is called at least
		// once during testing.  If a test class has only TestFactories, than the 
		// test class will never be instantiated by JUnit.
		createTest();
	}
	
	protected Collection<? extends FrameworkMethod> computeFactoryTests() throws Exception {
		List<FrameworkFactoryTest> tests = new LinkedList<FrameworkFactoryTest>();

		// Final all methods in our test class marked with @TestFactory.
		for (FrameworkMethod method: getTestClass().getAnnotatedMethods(TestFactory.class)) {
			// Make sure the TestFactory method is static
			if (!Modifier.isStatic(method.getMethod().getModifiers()))
				throw new InitializationError(""TestFactory "" + method + "" must be static."");

			// Execute the method (statically)
			Object instances = method.getMethod().invoke(getTestClass().getJavaClass());

			// Did the factory return an array?  If so, make it a list.
			if (instances.getClass().isArray())
				instances = Arrays.asList((Object[]) instances);

			// Did the factory return a scalar object?  If so, put it in a list.
			if (!(instances instanceof Iterable<?>))
				instances = Collections.singletonList(instances);

			// For each object returned by the factory.
			for (Object instance: (Iterable<?>) instances) {
				// Find any methods marked with @FactoryTest.
				for (FrameworkMethod m: new TestClass(instance.getClass()).getAnnotatedMethods(FactoryTest.class))
					tests.add(new FrameworkFactoryTest(m.getMethod(), instance, method.getName()));
			}
		}

		return tests;
	}
	
	/**
	 * {@inheritDoc}
	 * @see org.junit.runners.BlockJUnit4ClassRunner#computeTestMethods()
	 */
	@Override
	protected List<FrameworkMethod> computeTestMethods() {
		return tests;
	}
	
	/**
	 * This method overrides the original method <code>validateInstanceMethods(...)</code>
	 * of {@link BlockJUnit4ClassRunner} to avoid a crash of the JUnit test suite caused
	 * by adding {@link FactoryTest}s to the test suite before pre-defined tests are loaded.
	 * 
	 * The original method is marked <code>@Deprecated</code>. 
	 * TODO: Remove this overriding method once the original is removed from the JUnit framework. 
	 */
	@Override
	@SuppressWarnings(""deprecation"")
	protected void validateInstanceMethods(List<Throwable> errors) {
		validatePublicVoidNoArgMethods(After.class, false, errors);
		validatePublicVoidNoArgMethods(Before.class, false, errors);
		validateTestMethods(errors);
	}
}



"
FactoryTest.java,context,"/****************************************************************************
 * Copyright (c) 2011. All rights reserved. Ted Young.
 * Original source code published at
 * http://tedyoung.me/2011/01/22/junit-runtime-tests-overview/
 * 
 * Code adapted for ProM by Dirk Fahland.
 ****************************************************************************/

package org.processmining.contexts.test.factory;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * This annotation declares a Java method as 'Test Factory Method'
 * which will be turned into a JUnit test for each object that is
 * registered at the {@link TestFactory}.
 *  
 * @author Ted Young
 */
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface FactoryTest {
}
"
FrameworkFactoryTest.java,context,"/****************************************************************************
 * Copyright (c) 2011. All rights reserved. Ted Young.
 * Original source code published at
 * http://tedyoung.me/2011/01/22/junit-runtime-tests-overview/
 * 
 * Code adapted for ProM by Dirk Fahland.
 ****************************************************************************/

package org.processmining.contexts.test.factory;

import java.lang.reflect.Method;

import org.junit.runners.model.FrameworkMethod;

/**
 * Encapsulates a test method to be invoked by the JUnit framework. This particular
 * class encapsulates test methods that are added dynamically to a JUnit test suite
 * during execution and provides additional information for these methods. 
 *  
 * @author Ted Young, Dirk Fahland
 */
class FrameworkFactoryTest extends FrameworkMethod {
	private Object target;
	private String name;

	public FrameworkFactoryTest(Method method, Object target, String name) {
		super(method);
		this.target = target;
		this.name = name;
	}

	@Override
	public Object invokeExplosively(Object target, Object... params) throws Throwable {
		// Executes the test method on the supplied target (returned by the TestFactory)
		// and not the instance generated by FrameworkMethod.
		return super.invokeExplosively(this.target, params);
	}

	@Override
	public String getName() {
		return String.format(""%s=%s.%s[%s]"", name, target.getClass().getSimpleName(), getMethod().getName(), target.toString());
	}
}
"
TestFactory.java,context,"/****************************************************************************
 * Copyright (c) 2011. All rights reserved. Ted Young.
 * Original source code published at
 * http://tedyoung.me/2011/01/22/junit-runtime-tests-overview/
 * 
 * Code adapted for ProM by Dirk Fahland.
 ****************************************************************************/
package org.processmining.contexts.test.factory;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
import java.util.List;

/**
 * This annotation can be added to a method in a JUnit test class. When
 * executing the JUnit test suite, a {@link FactoryRunner} that is hooked
 * to the JUnit Test will use the annotated method to generate and add
 * new JUnit to the test suite. The annotated Method has to return a 
 * {@link List} of Objects that have member methods that are annotated
 * with {@link FactoryTest}.
 *  
 * @author Ted Young
 */
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface TestFactory {
}
"
InclassMethodTest.java,context,"

package org.processmining.contexts.test;

import java.io.BufferedInputStream;
import java.io.ByteArrayOutputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.PrintStream;
import java.lang.reflect.Method;

import junit.framework.Assert;
import junit.framework.AssertionFailedError;

import org.processmining.contexts.test.factory.FactoryTest;
import org.processmining.framework.annotations.TestMethod;

/**
 * Encapsulate a method (annotated with {@link TestMethod}) in a 
 * JUnit test. 
 * 
 * @author Dirk Fahland
 */
public class InclassMethodTest {
	
	private Method test;
	private String testFileRoot;

	/**
	 * Encapsulate the given method (annotated with {@link TestMethod}) in a 
	 * JUnit test. When executed, the test may access files stored at
	 * <code>testFileRoot</code>. 
	 * 
	 * @param method
	 * @param testFileRoot
	 */
	public InclassMethodTest(Method method, String testFileRoot) {
		this.test = method;
		this.testFileRoot = testFileRoot;
	}
	
	/**
	 * Invokes the method annotated with {@link TestMethod} and compares the
	 * result with an expected value. Comparison is done using
	 * {@link Assert#assertEquals(String, String, String)}
	 * 
	 * @throws Throwable
	 */
	@FactoryTest
	public void test() throws Throwable {
		
		System.out.println(""--- TESTCASE: ""+this.test+"" -----------------------"");
		System.err.println(""--- TESTCASE: ""+this.test+"" -----------------------"");
		
		System.out.flush();
		// depending on the test, we redirect System.out to a new output stream
		// which we then compare against the expected result
		PrintStream oldSystemOut = System.out;
		OutputStream resultOutStream = new ByteArrayOutputStream();
		PrintStream tempSystemOut = new PrintStream(resultOutStream);
		
		if (AllInclassMethodTests.testResultFromSystemOut(test)) {
			// write System.out temporarily into the resultOutStream 
			System.setOut(tempSystemOut);
		}
		
		// run test and get test result
		String result = """";
		
		try {
			result = (String)test.invoke(null);
		} catch (java.lang.reflect.InvocationTargetException e) {
			// if a user used JUnit Assertion statements in the routine, then the failed
			// assertions are wrappted in InvocationTargetExceptions, unwrap and rethrow
			if (e.getCause() instanceof AssertionFailedError) {
				throw e.getCause();
			}
		}
		
		if (AllInclassMethodTests.testResultFromSystemOut(test)) {
			// get test result from resultOutStream and restore old output system out
			result = resultOutStream.toString();
			tempSystemOut.close();
			System.setOut(oldSystemOut);
		}
		
		// load expected result
		String expected = null;
		if (AllInclassMethodTests.testExpectedFromOutputAnnotation(test)) {
			expected = test.getAnnotation(TestMethod.class).output();
		} else if (AllInclassMethodTests.testExpectedFromFile(test)) {
			expected = readFile(testFileRoot+""/""+test.getAnnotation(TestMethod.class).filename());
		}
		
		expected = expected.replace(""\r"", """");
		result = result.replace(""\r"", """");
		
		Assert.assertEquals(getTestName(test), expected, result);
	}

	/**
	 * @param scriptFileName
	 * @return contents of the file at the given scriptFileName
	 * @throws IOException
	 */
	private static String readFile(String scriptFileName) throws IOException {
		InputStream is = new FileInputStream(scriptFileName);
		String result = readWholeStream(is);
		is.close();
		return result;
	}

	/**
	 * Read an input stream into a string.
	 * 
	 * @param is
	 * @return contents of the input stream
	 * @throws IOException
	 */
	private static String readWholeStream(InputStream is) throws IOException {
		InputStreamReader reader = new InputStreamReader(new BufferedInputStream(is));
		StringBuffer result = new StringBuffer();
		int c;

		while ((c = reader.read()) != -1) {
			result.append((char) c);
		}
		return result.toString();
	}

	/**
	 * @param m
	 * @return qualified Java name pointing to the location of the test in the Java class
	 */
	private static String getTestName (Method m) {
		return m.getDeclaringClass().toString()+"".""+m.getName();
	}
	
	/*
	 * (non-Javadoc)
	 * @see java.lang.Object#toString()
	 */
	public String toString() {
		return getTestName(test);
	}
}
"
PromTest.java,context,"package org.processmining.contexts.test;

import java.lang.reflect.Method;
import java.util.Collection;
import java.util.LinkedList;
import java.util.List;

import junit.framework.TestCase;

import org.junit.runner.RunWith;
import org.processmining.contexts.test.factory.FactoryRunner;
import org.processmining.contexts.test.factory.TestFactory;
import org.processmining.framework.annotations.TestMethod;

/**
 * The base class for unit tests in ProM. A class the extends this class is a JUnit
 * test suite that gets automatically enriched with two kinds of tests.
 * 
 * 1) Inclass Method Tests: these are tests generated from all methods in the plugin
 *    code that are annotated with {@link TestMethod} and the corresponding attributes.
 *    Tests are generated from all classes stored in {@value #defaultClassFileLocations}.
 *    
 * 2) Automated test scripts: these are tests that run a sequence of scripted tests
 *    that are stored in a specified location: {@link #defaultTestScriptDir}.
 *    
 * The tests may access files/compare results to files stored in {@link #defaultTestDir}.
 * 
 * @author Dirk Fahland
 */
@RunWith(value=FactoryRunner.class)
public class PromTest extends TestCase {
	
	/**
	 * Default location of test files that is used if the system property
	 * <code>test.testFileRoot</code> is not set. Overwrite this value if
	 * necessary. Default value {@value #defaultTestDir}.
	 */
	public static final String defaultTestDir = ""./tests/testfiles"";
	
	/**
	 * Default location of test script files inside {@link #defaultTestDir}
	 * that is used if the system property <code>test.testScriptRoot</code>
	 * is not set. By default, this location is {@value #defaultTestScriptDir}.
	 * Overwrite this value if necessary.
	 */
	public static final String defaultTestScriptDir = ""autoscripts"";
	
	/**
	 * Default location of class files that contain methods which are annotated
	 * with {@link TestMethod} and which shall be run in the JUnit test. Overwrite
	 * this value if necessary. Default value {@value #defaultTestDir}.
	 */
	public static final String defaultClassFileLocations = ""./bin"";
	
	@TestFactory
	public static Collection<? extends Object> testScripts() {

		String testFileRoot = System.getProperty(""test.testFileRoot"", defaultTestDir);
	    String testScriptRoot = System.getProperty(""test.testScriptRoot"", testFileRoot+""/""+defaultTestScriptDir);
	    
		List<String> testScripts = AllStandardScriptTests.getAllTestScripts(testScriptRoot);
		List<StandardScriptTest> tests = new LinkedList<StandardScriptTest>();
		for (String scriptFile : testScripts) {
			System.out.println("" found ""+testScriptRoot+""/""+scriptFile);
			tests.add(new StandardScriptTest(testScriptRoot+""/""+scriptFile));	
		}
		
		return tests;
	}
	
	@TestFactory
	public static Collection<? extends Object> inlineTests() {

		String testFileRoot = System.getProperty(""test.testFileRoot"", defaultTestDir);
		String lookUpDirString = System.getProperty(""test.inclassTestsAt"", defaultClassFileLocations);
		
		LinkedList<String> lookUpDirs = new LinkedList<String>();
		int comma;
		while ((comma = lookUpDirString.indexOf("","")) >= 0) {
			String dir = lookUpDirString.substring(0, comma);
			lookUpDirs.add(dir);
			lookUpDirString = lookUpDirString.substring(comma+1);
		}
		lookUpDirs.add(lookUpDirString);
		
		AllInclassMethodTests testCollector = new AllInclassMethodTests();
		for (String classFileLocation : lookUpDirs)
			testCollector.collectAllTestMethods(classFileLocation);
		
		List<Method> testMethods = testCollector.getAllTestMethods();
		List<InclassMethodTest> tests = new LinkedList<InclassMethodTest>();
		for (Method m : testMethods) {
			System.out.println("" found ""+AllInclassMethodTests.getTestName(m));
			tests.add(new InclassMethodTest(m, testFileRoot));	
		}

		return tests;
	}
}
"
StandardScriptTest.java,context,"package org.processmining.contexts.test;

import org.processmining.contexts.cli.CLI;
import org.processmining.contexts.test.factory.FactoryTest;

public class StandardScriptTest {
	
	private String testScript;
	
	public StandardScriptTest(String testScript) {
		this.testScript = testScript;
	}

	@FactoryTest
	public void test() throws Throwable {

		System.out.println(""--- TESTCASE: ""+testScript+"" -----------------------"");
		System.err.println(""--- TESTCASE: ""+testScript+"" -----------------------"");

		String args[] = new String[] {""-f"", testScript};
		CLI.main(args);
	}
	
	/*
	 * (non-Javadoc)
	 * @see java.lang.Object#toString()
	 */
	public String toString() {
		return testScript;
	}
}
"
UIExportPlugin.java,context,"package org.processmining.contexts.uitopia.annotations;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Retention(RetentionPolicy.RUNTIME)
@Target( { ElementType.TYPE })
public @interface UIExportPlugin {
	public String description();

	public String extension();

	public String pack() default """";
}
"
UIImportPlugin.java,context,"package org.processmining.contexts.uitopia.annotations;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * Annotation is used in the interface
 * org.processmining.contexts.uitopia.specialplugins.ImportPlugin to signal the
 * framework that this is an import plugin.
 * 
 * @author bfvdonge
 * 
 */

@Retention(RetentionPolicy.RUNTIME)
@Target( { ElementType.TYPE })
public @interface UIImportPlugin {
	public String description();

	public String[] extensions();
	
	public String pack() default """";
}
"
UITopiaVariant.java,context,"package org.processmining.contexts.uitopia.annotations;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Retention(RetentionPolicy.RUNTIME)
@Target({ ElementType.METHOD })
public @interface UITopiaVariant {

	public final static String USEPLUGIN = ""Use Plugin Name"";
	public final static String USEVARIANT = ""Use Variant Name"";

	public final static String EHV = ""Eindhoven University of Technology"";

	String uiLabel() default USEPLUGIN;

	String uiHelp() default USEPLUGIN;

	String affiliation();

	String email();

	String author();

	String website() default ""http://www.processmining.org"";

	String pack() default """";
}
"
Visualizer.java,context,"package org.processmining.contexts.uitopia.annotations;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Retention(RetentionPolicy.RUNTIME)
@Target( { ElementType.TYPE, ElementType.METHOD })
public @interface Visualizer {

	public final static String USEPLUGINNAME = ""Use Plugin Name"";

	/**
	 * Returns the name of the visualizer.
	 * 
	 * @return A short string (< 20 characters)
	 */
	public String name() default USEPLUGINNAME;

	public String pack() default """";
}
"
ProgressOverlayDialog.java,context,"package org.processmining.contexts.uitopia.hub.overlay;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Component;
import java.awt.Dimension;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

import javax.swing.BorderFactory;
import javax.swing.Box;
import javax.swing.BoxLayout;
import javax.swing.JComponent;
import javax.swing.JLabel;
import javax.swing.JPanel;

import org.deckfour.uitopia.ui.components.ImageLozengeButton;
import org.deckfour.uitopia.ui.main.MainView;
import org.deckfour.uitopia.ui.overlay.AbstractOverlayDialog;
import org.deckfour.uitopia.ui.util.ImageLoader;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.framework.plugin.events.ProgressEventListener;

import com.fluxicon.slickerbox.components.RoundedPanel;
import com.fluxicon.slickerbox.components.SlickerProgressBar;

public class ProgressOverlayDialog extends AbstractOverlayDialog implements ProgressEventListener {

	public static interface CancellationListener {
		public void cancel();
	}

	/**
	 * 
	 */
	private static final long serialVersionUID = 2065412432371789921L;
	protected static Color colorBgUp = new Color(80, 80, 80);
	protected static Color colorBgDown = new Color(40, 40, 40);
	protected static Color colorBgInner = new Color(200, 200, 200, 120);
	protected static Color colorFg = new Color(40, 40, 40);

	private final SlickerProgressBar progress;
	private final JLabel title;
	private final JLabel label;
	private final ImageLozengeButton cancelButton;

	public ProgressOverlayDialog(MainView mainView, final UIPluginContext context, String aTitle) {
		this(mainView, aTitle, new CancellationListener() {

			public void cancel() {
				context.getProgress().cancel();
			}

		});
		context.getProgressEventListeners().add(this);
	}

	public ProgressOverlayDialog(MainView mainView, String aTitle, final CancellationListener cancellationListener) {
		super(aTitle);

		setOpaque(false);
		setLayout(new BorderLayout());
		setBorder(BorderFactory.createEmptyBorder(30, 30, 30, 30));

		setLayout(new BoxLayout(this, BoxLayout.X_AXIS));

		RoundedPanel innerPanel = new RoundedPanel(20, 0, 0);
		innerPanel.setAlignmentX(Component.CENTER_ALIGNMENT);
		innerPanel.setBackground(colorBgInner);
		innerPanel.setMinimumSize(new Dimension(300, 120));
		innerPanel.setMaximumSize(new Dimension(600, 130));
		innerPanel.setPreferredSize(new Dimension(500, 130));
		innerPanel.setLayout(new BoxLayout(innerPanel, BoxLayout.Y_AXIS));
		innerPanel.setBorder(BorderFactory.createEmptyBorder(5, 20, 5, 20));

		progress = new SlickerProgressBar();
		progress.setOpaque(false);
		progress.setIndeterminate(true);

		title = new JLabel(aTitle);
		title.setAlignmentX(Component.LEFT_ALIGNMENT);
		title.setOpaque(false);
		title.setFont(title.getFont().deriveFont(16.0f));

		label = new JLabel("""");
		label.setFont(label.getFont().deriveFont(12.0f));
		label.setAlignmentX(Component.LEFT_ALIGNMENT);
		label.setOpaque(false);

		cancelButton = new ImageLozengeButton(ImageLoader.load(""cancel_white_30x30.png""), ""Cancel"",
				new Color(90, 0, 0), new Color(160, 0, 0), 4);
		cancelButton.setLabelColor(Color.white);
		cancelButton.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				cancellationListener.cancel();
				cancelButton.setEnabled(false);
			}
		});

		JPanel buttonPanel = new JPanel();
		buttonPanel.setOpaque(false);
		buttonPanel.setBorder(BorderFactory.createEmptyBorder());
		buttonPanel.setLayout(new BoxLayout(buttonPanel, BoxLayout.X_AXIS));
		buttonPanel.add(Box.createHorizontalGlue());
		buttonPanel.add(progress);
		buttonPanel.add(Box.createHorizontalStrut(10));
		buttonPanel.add(cancelButton);
		buttonPanel.add(Box.createHorizontalGlue());

		innerPanel.add(Box.createVerticalGlue());
		innerPanel.add(alignLeft(title));
		innerPanel.add(Box.createVerticalStrut(10));
		innerPanel.add(buttonPanel);
		innerPanel.add(Box.createVerticalStrut(8));
		innerPanel.add(alignLeft(label));
		innerPanel.add(Box.createVerticalGlue());

		add(Box.createHorizontalGlue());
		add(innerPanel);
		add(Box.createHorizontalGlue());

	}

	protected JPanel alignLeft(JComponent component) {
		JPanel enclosure = new JPanel();
		enclosure.setOpaque(false);
		enclosure.setBorder(BorderFactory.createEmptyBorder());
		enclosure.setLayout(new BoxLayout(enclosure, BoxLayout.X_AXIS));
		enclosure.add(component);
		enclosure.add(Box.createHorizontalGlue());
		return enclosure;
	}

	protected JPanel alignRight(JComponent component) {
		JPanel enclosure = new JPanel();
		enclosure.setOpaque(false);
		enclosure.setBorder(BorderFactory.createEmptyBorder());
		enclosure.setLayout(new BoxLayout(enclosure, BoxLayout.X_AXIS));
		enclosure.add(Box.createHorizontalGlue());
		enclosure.add(component);
		return enclosure;
	}

	public void changeProgress(int p) {
		progress.setValue(p);
	}

	public void changeProgressBounds(int lowBo, int upBo) {
		progress.setMinimum(lowBo);
		progress.setMaximum(upBo);
		progress.setIndeterminate(upBo <= lowBo);
	}

	public void changeProgressCaption(String newCaption) {
		label.setText(newCaption);
		revalidate();
	}

	public void changeProgressIndeterminate(boolean indeterminate) {
		progress.setIndeterminate(indeterminate);
	}

	public int getMaximum() {
		return progress.getMaximum();
	}

	public void setIndeterminate(boolean b) {
		progress.setIndeterminate(b);

	}

}
"
ProMActionManager.java,context,"package org.processmining.contexts.uitopia.hub;

import java.net.URL;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashSet;
import java.util.List;
import java.util.SortedSet;
import java.util.TreeSet;

import org.deckfour.uitopia.api.hub.ActionManager;
import org.deckfour.uitopia.api.model.ActionType;
import org.deckfour.uitopia.api.model.Parameter;
import org.deckfour.uitopia.api.model.ResourceType;
import org.processmining.contexts.uitopia.UIContext;
import org.processmining.contexts.uitopia.annotations.UIExportPlugin;
import org.processmining.contexts.uitopia.annotations.UIImportPlugin;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.contexts.uitopia.annotations.Visualizer;
import org.processmining.contexts.uitopia.model.ProMAction;
import org.processmining.framework.plugin.PluginDescriptor;
import org.processmining.framework.plugin.PluginManager.PluginManagerListener;
import org.processmining.framework.plugin.PluginParameterBinding;

public class ProMActionManager implements ActionManager<ProMAction>, PluginManagerListener {

	private final SortedSet<ProMAction> actions = new TreeSet<ProMAction>();
	private final UIContext context;

	private ProMActionManager(UIContext context) {

		this.context = context;
		for (PluginDescriptor plugin : context.getPluginManager().getAllPlugins(true)) {
			addPlugin(plugin);
		}
		context.getPluginManager().addListener(this);
	}

	private void addPlugin(PluginDescriptor plugin) {
		for (int i = 0; i < plugin.getNumberOfMethods(); i++) {
			// See if this is an action
			if (checkPlugin(context, plugin, i)) {
				// Construct an action
				ProMAction action = new ProMAction(context.getResourceManager(), context.getPluginManager(), plugin, i);
				actions.add(action);
			}
		}

	}

	private static ProMActionManager instance = null;

	public static ProMActionManager initialize(UIContext context) {
		if (instance == null) {
			instance = new ProMActionManager(context);
		}
		return instance;
	}

	/**
	 * Returns a list of actions, such that these actions accepts all given
	 * input resources and result in at least on of the output resources.
	 */
	public List<ProMAction> getActions(List<ResourceType> input, List<ResourceType> output) {
		return getActions(input, output, null);
	}

	private Collection<ResourceType> getResourcesTypesFor(List<? extends Parameter> parameters) {
		Collection<ResourceType> types = new HashSet<ResourceType>();
		for (Parameter par : parameters) {
			types.add(par.getType());
		}

		return types;
	}

	public List<ProMAction> getActions(List<ResourceType> parameters, List<ResourceType> requiredOutput, ActionType type) {

		List<ProMAction> enabledActions = new ArrayList<ProMAction>();

		actionLoop: for (ProMAction action : actions) {

			// Check for type match
			if ((type != null) && !action.getType().equals(type)) {
				// types don't match
				continue;
			}

			// Check if all given output types are present in the plugin's output
			Collection<ResourceType> outputs = getResourcesTypesFor(action.getOutput());
			for (ResourceType required : requiredOutput) {
				boolean found = false;
				for (ResourceType output : outputs) {
					found |= required.isAssignableFrom(output);
					if (found) {
						break;
					}
				}
				if (!found) {
					continue actionLoop;
				}
			}

			// Check for enabledness using a pluginparamterbinding
			Class<?>[] types = new Class<?>[parameters.size()];
			int i = 0;
			for (ResourceType r : parameters) {
				types[i++] = r.getTypeClass();
			}
			List<PluginParameterBinding> bindings = PluginParameterBinding.Factory.tryToBind(
					context.getPluginManager(), action.getPlugin(), action.getMethodIndex(), false, false, types);
			bindings.addAll(PluginParameterBinding.Factory.tryToBind(context.getPluginManager(), action.getPlugin(),
					action.getMethodIndex(), true, false, types));

			if (bindings.isEmpty()) {
				continue;
			}

			enabledActions.add(action);
		}

		return enabledActions;
	}

	public List<ProMAction> getActions() {
		return new ArrayList<ProMAction>(actions);
	}

	private boolean checkPlugin(UIContext context, PluginDescriptor plugin, int methodIndex) {
		if (plugin.getAnnotation(Visualizer.class) != null) {
			return false;
		}
		if (plugin.getAnnotation(UIImportPlugin.class) != null) {
			return false;
		}
		if (plugin.getAnnotation(UIExportPlugin.class) != null) {
			return false;
		}
		if (plugin.getAnnotation(UITopiaVariant.class, methodIndex) == null) {
			return false;
		}
		for (int p = 0; p < plugin.getParameterNames().size(); p++) {
			Class<?> type = plugin.getPluginParameterType(methodIndex, p);
			if ((type != null) && !context.getResourceManager().isResourceType(type)) {
				return false;
			}
		}
		return true;
	}

	public void error(URL source, Throwable t, String className) {
		System.err.println(""Error while adding plugin from "" + className);
	}

	public void newPlugin(PluginDescriptor plugin, Collection<Class<?>> newTypes) {
		// First, register the new resource types with the resource manager
		for (Class<?> newType : newTypes) {
			context.getResourceManager().addType(newType);
		}
		// Now add the plugins.
		addPlugin(plugin);

		if (plugin.getAnnotation(Visualizer.class) != null) {
			HashSet<Class<?>> parTypes = new HashSet<Class<?>>();
			for (int i = 0; i < plugin.getNumberOfMethods(); i++) {
				parTypes.addAll(plugin.getParameterTypes(i));
			}
			for (Class<?> parType : parTypes) {
				// this plugin might be a visualizes for any of its parameter types, so
				// notify the viewmanager of this.
				context.getViewManager().registerResourceType(context.getResourceManager().getResourceTypeFor(parType));
			}
		}
		if (plugin.getAnnotation(UIImportPlugin.class) != null) {
			// added an import plugin, signal the resource manager.
			context.getResourceManager().addedImportPlugins();
		}
		//		if (plugin.getAnnotation(UIExportPlugin.class) != null) {
		// Export plugins are built on the fly anyway.
		//		}

	}
}
"
ProMCategoryManager.java,context,"package org.processmining.contexts.uitopia.hub;

import java.util.ArrayList;
import java.util.List;

import org.deckfour.uitopia.api.hub.CategoryManager;
import org.deckfour.uitopia.api.model.Category;
import org.processmining.contexts.uitopia.UIContext;
import org.processmining.contexts.uitopia.model.ProMCategory;
import org.processmining.framework.plugin.annotations.PluginCategory;

public class ProMCategoryManager implements CategoryManager {

	private static ProMCategoryManager instance = null;
	private List<Category> categories;

	public ProMCategoryManager() {
		categories = new ArrayList<>();

		for (PluginCategory c : PluginCategory.values()) {
			ProMCategory newCat = new ProMCategory(c);
			categories.add(newCat);
		}

	}

	public List<Category> getCategories() {

		return categories;
	}

	public static CategoryManager initialize(UIContext uiContext) {
		if(instance == null){
			instance = new ProMCategoryManager();
		}
		return instance;
	}

}"
ProMResourceManager.java,context,"package org.processmining.contexts.uitopia.hub;

import java.awt.EventQueue;
import java.io.File;
import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import java.util.concurrent.CancellationException;
import java.util.concurrent.ConcurrentHashMap;
import java.util.prefs.Preferences;

import javax.swing.JFileChooser;
import javax.swing.JOptionPane;
import javax.swing.SwingUtilities;
import javax.swing.filechooser.FileFilter;
import javax.swing.filechooser.FileNameExtensionFilter;

import org.deckfour.uitopia.api.hub.ResourceManager;
import org.deckfour.uitopia.api.model.Resource;
import org.deckfour.uitopia.api.model.ResourceFilter;
import org.deckfour.uitopia.api.model.ResourceType;
import org.processmining.contexts.uitopia.UIContext;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.contexts.uitopia.annotations.UIExportPlugin;
import org.processmining.contexts.uitopia.annotations.UIImportPlugin;
import org.processmining.contexts.uitopia.hub.overlay.ProgressOverlayDialog;
import org.processmining.contexts.uitopia.model.ProMCResource;
import org.processmining.contexts.uitopia.model.ProMPOResource;
import org.processmining.contexts.uitopia.model.ProMResource;
import org.processmining.contexts.uitopia.model.ProMResourceType;
import org.processmining.framework.ProMID;
import org.processmining.framework.connections.Connection;
import org.processmining.framework.connections.ConnectionAnnotation;
import org.processmining.framework.connections.ConnectionCannotBeObtained;
import org.processmining.framework.connections.ConnectionID;
import org.processmining.framework.connections.ConnectionManager;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.PluginExecutionResult;
import org.processmining.framework.plugin.PluginParameterBinding;
import org.processmining.framework.plugin.events.ConnectionObjectListener;
import org.processmining.framework.plugin.events.Logger.MessageLevel;
import org.processmining.framework.plugin.events.PluginLifeCycleEventListener;
import org.processmining.framework.plugin.events.ProvidedObjectLifeCycleListener;
import org.processmining.framework.providedobjects.ProvidedObjectDeletedException;
import org.processmining.framework.providedobjects.ProvidedObjectID;
import org.processmining.framework.providedobjects.ProvidedObjectManager;

public class ProMResourceManager extends UpdateSignaller implements ResourceManager<ProMResource<?>>,
		ProvidedObjectLifeCycleListener, PluginLifeCycleEventListener, ConnectionObjectListener {

	private static final String LASTIMPORTFILE = ""last import file location"";

	private static final String LASTEXPORTFILE = ""last export file location"";

	private static final String FAVORITEIMPORT = ""favorite import for type "";

	private static final String FAVORITEEXPORT = ""favorite export for type "";

	private static ProMResourceManager instance = null;

	private final Map<Class<?>, ProMResourceType> resourceClasses = new ConcurrentHashMap<Class<?>, ProMResourceType>();
	private final Map<ProMID, ProMResource<?>> resources = new ConcurrentHashMap<ProMID, ProMResource<?>>();

	private final UIContext context;

	private Map<FileFilter, PluginParameterBinding> importplugins;

	private final ProvidedObjectManager poManager;

	// HV Remember last file imported and exported.
	private File lastImportedFile;
	private File lastExportedFile;

	private Boolean importPluginAdded = true;

	private final Preferences preferences;

	private ConnectionManager connectionManager;

	private ProMResourceManager(UIContext context) {

		this.context = context;
		for (Class<?> type : context.getPluginManager().getKnownObjectTypes()) {
			addType(type);
		}
		for (Class<?> type : context.getPluginManager().getKnownClassesAnnotatedWith(ConnectionAnnotation.class)) {
			addType(type);
		}
		poManager = context.getProvidedObjectManager();
		poManager.getProvidedObjectLifeCylceListeners().add(this);

		connectionManager = context.getConnectionManager();
		connectionManager.getConnectionListeners().add(this);

		// HV No last file imported or exported yet.
		preferences = Preferences.userNodeForPackage(getClass());

		String name = preferences.get(LASTIMPORTFILE, null);
		lastImportedFile = name == null ? null : new File(name);
		while (lastImportedFile != null && !lastImportedFile.exists()) {
			lastImportedFile = lastImportedFile.getParentFile();
		}
		name = preferences.get(LASTEXPORTFILE, null);
		lastExportedFile = name == null ? null : new File(name);
		while (lastExportedFile != null && !lastExportedFile.exists()) {
			lastExportedFile = lastExportedFile.getParentFile();
		}
	}

	public ResourceType addType(Class<?> type) {
		return resourceClasses.put(type, new ProMResourceType(type));
	}

	public static ProMResourceManager initialize(UIContext context) {
		if (instance == null) {
			instance = new ProMResourceManager(context);
		}
		return instance;
	}

	/*
	 * HV: Return a default exporter for known types. Fortunately, this handling
	 * of favorite is all String based, so we do not need to know the actual
	 * types (only their names).
	 */
	private String getDefaultExport(String typeName) {
		// The typeName matches whatever the ProM workspace shows in the second line of an object (basically, this is the class name). 
		// The returned label should match with whatever is in the @UIExportPlugin declaration.
		if (typeName.equals(""XLog"")) {
			return ""XES files"";
		} else if (typeName.equals(""Petrinet"")) {
			return ""PNML files"";
		} else if (typeName.equals(""AcceptingPetriNet"")) {
			return ""Accepting Petri Net"";
		} else if (typeName.equals(""PetriNetWithData"")) {
			// Particularly useful, as this may prevent novice users from using the usual PNML export, which does not export data.
			return ""Data-aware PNML files"";
		}
		return """";
	}

	public Collection<FileFilter> getExportFilters(Resource resource) {
		Collection<FileFilter> exportfilters = new HashSet<FileFilter>();
		Set<PluginParameterBinding> potentialExportPlugins = context.getPluginManager().getPluginsAcceptingInAnyOrder(
				UIPluginContext.class, true, File.class, resource.getType().getTypeClass());

		for (PluginParameterBinding binding : potentialExportPlugins) {
			if (binding.getPlugin().getAnnotation(UIExportPlugin.class) != null) {
				String description = binding.getPlugin().getAnnotation(UIExportPlugin.class).description();
				String extension = binding.getPlugin().getAnnotation(UIExportPlugin.class).extension();
				FileNameExtensionFilter filter = new FileNameExtensionFilter(description, extension);
				exportfilters.add(filter);
			}
		}
		return exportfilters;
	}

	public boolean exportResource(Resource resource) throws IOException {
		assert(resource instanceof ProMResource<?>);

		String lastChosenExportPlugin = preferences.get(FAVORITEEXPORT + resource.getType().getTypeName(), """");
		if (lastChosenExportPlugin.isEmpty()) {
			// HV: No favorite set yet by user. Use reasonable default values for known types.
			lastChosenExportPlugin = getDefaultExport(resource.getType().getTypeName());
		}
		FileFilter lastChosenFilter = null;

		Map<FileFilter, PluginParameterBinding> exportplugins = new TreeMap<FileFilter, PluginParameterBinding>(
				new Comparator<FileFilter>() {

					public int compare(FileFilter f1, FileFilter f2) {
						return f1.getDescription().toLowerCase().compareTo(f2.getDescription().toLowerCase());
					}
				});
		Set<PluginParameterBinding> potentialExportPlugins = context.getPluginManager().getPluginsAcceptingInAnyOrder(
				UIPluginContext.class, true, File.class, resource.getType().getTypeClass());

		for (PluginParameterBinding binding : potentialExportPlugins) {
			if (binding.getPlugin().getAnnotation(UIExportPlugin.class) != null) {
				String description = binding.getPlugin().getAnnotation(UIExportPlugin.class).description();
				String extension = binding.getPlugin().getAnnotation(UIExportPlugin.class).extension();
				FileNameExtensionFilter filter = new FileNameExtensionFilter(description, extension);
				exportplugins.put(filter, binding);
				if (description.equals(lastChosenExportPlugin)) {
					lastChosenFilter = filter;
				}
			}
		}

		// HV Start at location last file was exported.
		JFileChooser fc = (lastExportedFile != null ? new JFileChooser(lastExportedFile) : new JFileChooser());
		for (FileFilter filter : exportplugins.keySet()) {
			fc.addChoosableFileFilter(filter);
		}
		fc.setAcceptAllFileFilterUsed(false);
		if (lastChosenFilter != null) {
			fc.setFileFilter(lastChosenFilter);
		}

		askForFile: while (true) {
			int returnVal = fc.showSaveDialog(context.getUI());

			if ((returnVal == JFileChooser.APPROVE_OPTION) && (fc.getSelectedFile() != null)) {
				File file = fc.getSelectedFile();
				FileNameExtensionFilter selectedFilter = (FileNameExtensionFilter) fc.getFileFilter();
				if (selectedFilter == null) {
					selectedFilter = (FileNameExtensionFilter) exportplugins.keySet().iterator().next();
				}

				String postfix = ""."" + selectedFilter.getExtensions()[0];
				if (!file.getAbsolutePath().endsWith(postfix)) {
					String name = file.getAbsolutePath() + postfix;
					file = new File(name);
				}
				if (!file.createNewFile()) {
					int ow = JOptionPane.showConfirmDialog(context.getUI(),
							""Are you sure you want to overwrite "" + file.getName(), ""Confirm overwrite"",
							JOptionPane.YES_NO_OPTION);
					if (ow == JOptionPane.NO_OPTION) {
						continue askForFile;
					}
				}

				// HV Remember last file exported (and imported if not initialized yet).
				lastExportedFile = file.getParentFile();
				preferences.put(LASTEXPORTFILE, lastExportedFile.getAbsolutePath());
				if (lastImportedFile == null) {
					lastImportedFile = lastExportedFile;
					preferences.put(LASTIMPORTFILE, lastImportedFile.getAbsolutePath());
				}

				PluginParameterBinding binding = exportplugins.get(selectedFilter);

				preferences.put(FAVORITEEXPORT + resource.getType().getTypeName(),
						binding.getPlugin().getAnnotation(UIExportPlugin.class).description());

				UIPluginContext importContext = context.getMainPluginContext()
						.createChildContext(""Saving file with "" + binding.getPlugin().getName());

				PluginExecutionResult result = binding.invoke(importContext, file,
						((ProMResource<?>) resource).getInstance());
				context.getProvidedObjectManager().createProvidedObjects(importContext);

				try {
					result.synchronize();
				} catch (CancellationException e) {
					context.getMainPluginContext().log(""Export of "" + file + "" cancelled."");
					return false;
				} catch (Exception e) {
					JOptionPane.showMessageDialog(context.getUI(),
							""<html>Error with export of "" + file + "":<br>"" + e.getMessage() + ""</html>"",
							""Error while exporting"", JOptionPane.ERROR_MESSAGE);
					return false;
				} finally {
					importContext.getParentContext().deleteChild(importContext);
				}
				return true;
			}

			return false;
		}
	}

	public java.util.List<ProMResource<?>> getAllResources() {
		return new ArrayList<ProMResource<?>>(resources.values());
	}

	public java.util.List<ProMResource<?>> getAllResources(ResourceFilter filter) {
		return filterList(getAllResources(), filter);
	}

	public java.util.List<ResourceType> getAllSupportedResourceTypes() {
		java.util.List<ResourceType> types = new ArrayList<ResourceType>();
		types.addAll(resourceClasses.values());
		return types;
	}

	public java.util.List<ProMResource<?>> getChildrenOf(final Resource parent) {
		return getAllResources(new ResourceFilter() {
			public boolean accept(Resource res) {
				return getParentsOf(res).contains(parent);
			}
		});
	}

	public java.util.List<ProMResource<?>> getChildrenOf(final Resource parent, final ResourceFilter filter) {
		return getAllResources(new ResourceFilter() {
			public boolean accept(Resource res) {
				return filter.accept(res) && getParentsOf(res).contains(parent);
			}
		});
	}

	public java.util.List<ProMResource<?>> getFavoriteResources() {
		return getAllResources(new ResourceFilter() {
			public boolean accept(Resource res) {
				return res.isFavorite();
			}
		});
	}

	public java.util.List<ProMResource<?>> getFavoriteResources(final ResourceFilter filter) {
		return getAllResources(new ResourceFilter() {
			public boolean accept(Resource res) {
				return filter.accept(res) && res.isFavorite();
			}
		});
	}

	public java.util.List<ProMResource<?>> getImportedResources() {
		return getAllResources(new ResourceFilter() {
			public boolean accept(Resource res) {
				return getParentsOf(res).isEmpty();
			}
		});
	}

	public java.util.List<ProMResource<?>> getImportedResources(final ResourceFilter filter) {
		return getAllResources(new ResourceFilter() {
			public boolean accept(Resource res) {
				return filter.accept(res) && getParentsOf(res).isEmpty();
			}
		});
	}

	public java.util.List<ProMResource<?>> getParentsOf(Resource child) {
		return new ArrayList<ProMResource<?>>(((ProMResource<?>) child).getParents());
	}

	public java.util.List<ProMResource<?>> getParentsOf(Resource child, ResourceFilter filter) {
		java.util.List<ProMResource<?>> filtered = new ArrayList<ProMResource<?>>(
				((ProMResource<?>) child).getParents());
		return filterList(filtered, filter);
	}

	/**
	 * Start the import dialog for a resource. Can be called from the EDT or any
	 * other thread. Makes sure that the dialog-part of the actual import is run in the EDT.
	 */
	public boolean importResource() {
		if (EventQueue.isDispatchThread()) {
			/*
			 * Called from the EDT. OK.
			 */
			importResourceInEDT();
		} else {
			/*
			 * Not called from the EDT. Have the EDT take care of it.
			 */
			try {
				SwingUtilities.invokeAndWait(new Runnable() {
					public void run() {
						importResourceInEDT();
					}
				});
			} catch (InvocationTargetException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}
		return true;
	}

	/*
	 * This method should only be called from the EDT thread.
	 */
	private synchronized boolean importResourceInEDT() {
		if (!EventQueue.isDispatchThread()) {
			System.err.println(""Method should only be called from EDT"");
			return false;
		}
		synchronized (importPluginAdded) {
			if (importPluginAdded) {
				buildImportPlugins();
				importPluginAdded = false;
			}
		}
		// HV Start from the location of the last file imported.
		final JFileChooser fc = (lastImportedFile != null ? new JFileChooser(lastImportedFile) : new JFileChooser());
		for (FileFilter filter : importplugins.keySet()) {
			fc.addChoosableFileFilter(filter);
		}
		fc.setAcceptAllFileFilterUsed(true);
		/*
		 * Disable multi-selection, as this allows for the user to select two
		 * files simultaneously that cannot be handled by a single importer. The
		 * user can only use one importer...
		 */
		fc.setMultiSelectionEnabled(true);
		fc.setFileFilter(fc.getAcceptAllFileFilter());

		/*
		 * HV: This method does run in the EDT. 
		 */
		int returnVal = fc.showOpenDialog(context.getUI());

		if (returnVal == JFileChooser.APPROVE_OPTION) {
			/*
			 * As a result of disabling the multi-selection, use a different way
			 * to get the selected file(s).
			 */
			File[] files = fc.getSelectedFiles();
			//			File[] files = new File[]{ fc.getSelectedFile() };

			// XL: parse file one for one
			boolean importedSuccessfully = true;
			for (final File f : files) {
				PluginParameterBinding binding = importplugins.get(fc.getFileFilter());
				importedSuccessfully &= importResourceInEDT(binding, f);
			}
			return importedSuccessfully;

		} else {
			return false;

		}
	}

	/**
	 * Can be called from the EDT or any other thread.
	 */
	public synchronized boolean importResources(File... files) {
		return importResource(null, files);
	}

	/**
	 * Can be called from the EDT or any other thread. Makes sure that the
	 * dialog-par tof the actual import is run in the EDT.
	 */
	public boolean importResource(final PluginParameterBinding binding, final File... files) {
		if (EventQueue.isDispatchThread()) {
			/*
			 * Called from the EDT. OK.
			 */
			importResourceInEDT(binding, files);
		} else {
			/*
			 * Not called from the EDT. Have the EDZT take care of it.
			 */
			try {
				SwingUtilities.invokeAndWait(new Runnable() {
					public void run() {
						importResourceInEDT(binding, files);
					}
				});
			} catch (InvocationTargetException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}
		return true;
	}

	/*
	 * This method should be called from the EDT.
	 */
	private synchronized boolean importResourceInEDT(PluginParameterBinding binding, final File... files) {
		if (!EventQueue.isDispatchThread()) {
			System.err.println(""Method should only be called from EDT"");
			return false;
		}
		synchronized (importPluginAdded) {
			if (importPluginAdded) {
				buildImportPlugins();
				importPluginAdded = false;
			}
		}

		// HV Remember the location of the last file imported (and exported if not initialized yet).
		lastImportedFile = files[0].getParentFile();
		preferences.put(LASTIMPORTFILE, lastImportedFile.getAbsolutePath());
		if (lastExportedFile == null) {
			lastExportedFile = lastImportedFile;
			preferences.put(LASTEXPORTFILE, lastExportedFile.getAbsolutePath());
		}

		if (binding == null) {
			// user chose the ""all files"" option
			Map<String, PluginParameterBinding> bindings = new HashMap<String, PluginParameterBinding>();
			for (FileFilter filter : importplugins.keySet()) {
				// HV: Only show plug-ins that can handle all files, as all files will be imported by it.
				boolean ok = true;
				for (File file : files) {
					if (!filter.accept(file)) {
						ok = false;
					}
				}
				if (ok) {
					bindings.put(filter.getDescription(), importplugins.get(filter));
				}
			}
			if (bindings.size() == 0) {
				// 	TODO: No plugins available based on filetype
				// 	show all plugins
				for (FileFilter filter : importplugins.keySet()) {
					bindings.put(filter.getDescription(), importplugins.get(filter));
				}
			}
			if (bindings.size() == 0) {
				/*
				 * HV: This method does run in the EDT. 
				 */
				JOptionPane.showMessageDialog(context.getUI(), ""No import plugins available"",
								""No input plugins available!"", JOptionPane.ERROR_MESSAGE);
				return false;
			}

			binding = bindings.values().iterator().next();
			if (bindings.size() > 1) {

				String key = FAVORITEIMPORT + extractFileType(files[0].getAbsolutePath());
				final String[] possibilities = bindings.keySet().toArray(new String[0]);
				final String preferredImport = preferences.get(key, possibilities[0]);

				String selected = (String) JOptionPane.showInputDialog(context.getUI(),
									""Available Import Plugins for file "" + files[0].getName() + "":"",
									""Select an import plugin..."", JOptionPane.PLAIN_MESSAGE, null, possibilities,
									preferredImport);

				if (selected == null) {
					return false;
				}

				preferences.put(key, selected);
				binding = bindings.get(selected);
			}
		}
		if (binding == null) {
			// No import was selected.
			return false;
		}

		// HV: Dialog-part is now done, hence we can off-load the actual importing to another thread.
		// This frees the EDT for showing the progress bar while doing the import.
		final PluginParameterBinding finalBinding = binding;
		Runnable importThread = new Runnable() {
			public void run() {
				importResourceNotInEDT(finalBinding, files);
			}
		};
		(new Thread(importThread)).start();
		return true;
	}
	
	private boolean importResourceNotInEDT(final PluginParameterBinding binding, final File... files) {
		if (EventQueue.isDispatchThread()) {
			System.err.println(""Method should never be called from EDT"");
			return false;
		}
		/*
		 * Synchronize on the provided object manager to prevent multiple imports 
		 * talking at the same time to this manager.
		 */
		synchronized(context.getProvidedObjectManager()) {
		for (File f : files) {
			UIPluginContext importContext = context.getMainPluginContext()
					.createChildContext(""Opening file with "" + binding.getPlugin().getName());
			importContext.getPluginLifeCycleEventListeners().add(this);

			ProgressOverlayDialog progress = new ProgressOverlayDialog(context.getController().getMainView(),
					importContext, ""Importing "" + binding.getPlugin().getName());
			context.getController().getMainView().showOverlay(progress);
//			Thread.yield();

			PluginExecutionResult result = binding.invoke(importContext, f);
			context.getProvidedObjectManager().createProvidedObjects(importContext);

			try {
				result.synchronize();
			} catch (CancellationException e) {
				context.getController().getMainView().hideOverlay();
				SwingUtilities.invokeLater(new Runnable() {
					public void run() {
						JOptionPane.showMessageDialog(context.getUI(), ""Import of "" + files + "" cancelled."", ""Import cancelled"",
								JOptionPane.WARNING_MESSAGE);
					}
				});
				context.getMainPluginContext().log(""Import of "" + files + "" cancelled."");
				return false;
			} catch (final Exception e) {
				context.getController().getMainView().hideOverlay();
				SwingUtilities.invokeLater(new Runnable() {
					public void run() {
						JOptionPane.showMessageDialog(context.getUI(),
								""<html>Error with import of "" + files + "":<br>"" + e.getMessage() + ""</html>"", ""Import failed"",
								JOptionPane.ERROR_MESSAGE);
					}
				});
				context.getMainPluginContext().log(""Error with import of "" + files + ""."", MessageLevel.ERROR);
				context.getMainPluginContext().log(e);
				return false;
			} finally {
				importContext.getParentContext().deleteChild(importContext);
			}

			context.getController().getMainView().hideOverlay();
		}
		}
		return true;

	}

	private String extractFileType(String filename) {
		/*
		 * HV: Restrict the length of the extension to 9 characters.
		 */
		int indexName = Math.max(filename.lastIndexOf(File.separatorChar), filename.length() - 10);
		int indexDot = filename.indexOf('.', indexName);
		if (indexDot < 0) {
			// No dot in filename, hence no extension.
			return """";
		}
		return filename.substring(indexDot);
	}

	private void buildImportPlugins() {
		importplugins = new TreeMap<FileFilter, PluginParameterBinding>(new Comparator<FileFilter>() {

			public int compare(FileFilter f1, FileFilter f2) {
				return f1.getDescription().toLowerCase().compareTo(f2.getDescription().toLowerCase());
			}
		});

		Set<PluginParameterBinding> potentialImportPlugins = context.getPluginManager()
				.getPluginsAcceptingOrdered(UIPluginContext.class, true, File.class);

		for (PluginParameterBinding binding : potentialImportPlugins) {
			if (binding.getPlugin().hasAnnotation(UIImportPlugin.class)) {
				FileNameExtensionFilter filter = new FileNameExtensionFilter(
						binding.getPlugin().getAnnotation(UIImportPlugin.class).description(),
						binding.getPlugin().getAnnotation(UIImportPlugin.class).extensions());
				importplugins.put(filter, binding);
			}
		}

	}

	public ResourceType getResourceTypeFor(Class<?> type) {
		return resourceClasses.get(type);
	}

	public boolean isResourceType(Class<?> type) {
		return resourceClasses.keySet().contains(type);
	}

	private java.util.List<ProMResource<?>> filterList(java.util.List<ProMResource<?>> filtered,
			ResourceFilter filter) {
		synchronized (filtered) {
			Iterator<ProMResource<?>> it = filtered.iterator();
			while (it.hasNext()) {
				if (!filter.accept(it.next())) {
					it.remove();
				}
			}
		}
		return filtered;
	}

	public java.util.List<ResourceType> getResourceTypes(java.util.List<? extends Resource> res) {
		ArrayList<ResourceType> types = new ArrayList<ResourceType>(res.size());
		for (Resource r : res) {
			types.add(r.getType());
		}
		return types;
	}

	public void providedObjectCreated(ProvidedObjectID objectID, PluginContext context) {
		// Ignore. Only respond when a future of an object is ready.
	}

	public void providedObjectDeleted(ProvidedObjectID id) {
		if (resources.remove(id) != null) {
			signalUpdate();
		}
	}

	public void providedObjectFutureReady(ProvidedObjectID id) {
		Class<?> type;
		try {
			type = context.getProvidedObjectManager().getProvidedObjectType(id);
		} catch (ProvidedObjectDeletedException e) {
			// If the object has been deleted, try the next one
			return;
		}
		ResourceType resType = getResourceTypeFor(type);
		if (resType != null) {
			ProMResource<?> res;
			try {
				res = context.getResourceManager()
						.getResourceForInstance(context.getProvidedObjectManager().getProvidedObjectObject(id, true));
				if (res == null) {
					res = new ProMPOResource(context, null, resType, id,
							Collections.<Collection<ProMPOResource>>emptyList());
					addResource(id, res);
				}
			} catch (ProvidedObjectDeletedException e) {
				// If the object has been deleted, try the next one
				return;
			}
		}
	}

	public void providedObjectNameChanged(ProvidedObjectID id) {
		// Ignore. Access to the object is provided using late-binding, hence
		// the last version of the label is always returned by the resource
		if (resources.containsKey(id)) {
			signalUpdate();
		}
	}

	public void providedObjectObjectChanged(ProvidedObjectID id) {
		// Ignore. Access to the object is provided using late-binding, hence
		// the last version of the object is always returned by the resource
		if (resources.containsKey(id)) {
			signalUpdate();
		}
	}

	@SuppressWarnings(""unchecked"")
	public <R extends ProMResource<?>> R addResource(ProvidedObjectID id, R res) {
		if (resources.containsKey(id)) {
			return (R) resources.get(id);
		} else {
			resources.put(id, res);
			signalUpdate();
			return res;
		}
	}

	public ProMResource<?> getResourceForInstance(Object o) {
		for (ProMResource<?> resource : getAllResources()) {
			if (resource.getInstance() == o) {
				return resource;
			}
		}
		return null;
	}

	//********************************************************************
	// PluginLifeCycle.
	//

	public void pluginCancelled(PluginContext context) {
		// TODO Auto-generated method stub

	}

	public void pluginCompleted(PluginContext pluginContext) {
		PluginExecutionResult result = pluginContext.getResult();
		for (int i = 0; i < result.getSize(); i++) {
			ProvidedObjectID id = result.getProvidedObjectID(i);
			Class<?> type;
			try {
				type = context.getProvidedObjectManager().getProvidedObjectType(id);
			} catch (ProvidedObjectDeletedException e) {
				// If the object has been deleted, try the next one
				continue;
			}
			ResourceType resType = getResourceTypeFor(type);
			if (resType != null) {
				ProMResource<?> res = new ProMPOResource(context, null, resType, id,
						Collections.<Collection<ProMPOResource>>emptyList());
				res = addResource(id, res);
				if (i + 1 == result.getPlugin().getMostSignificantResult()) {
					res.setFavorite(true);
				}
			}
		}
	}

	public void pluginCreated(PluginContext context) {
		// gracefully ignore
	}

	public void pluginDeleted(PluginContext context) {
		// gracefully ignore
	}

	public void pluginFutureCreated(PluginContext context) {
		// gracefully ignore
	}

	public void pluginResumed(PluginContext context) {
		// gracefully ignore
	}

	public void pluginStarted(PluginContext context) {
		// gracefully ignore
	}

	public void pluginSuspended(PluginContext context) {
		// gracefully ignore
	}

	public void pluginTerminatedWithError(PluginContext context, Throwable t) {
		// gracefully ignore
	}

	public void addedImportPlugins() {
		synchronized (importPluginAdded) {
			importPluginAdded = true;
		}
	}

	//********************************************************************
	// ConnectionListener.
	//

	public void connectionCreated(ConnectionID id) {
		if (!resources.containsKey(id)) {
			Connection conn;
			try {
				conn = connectionManager.getConnection(id);
				if (!conn.isRemoved()) {
					// TODO
					java.util.List<Collection<ProMPOResource>> values = new ArrayList<Collection<ProMPOResource>>();
					for (Object o : conn.getObjects().baseSet()) {
						ProMResource<?> r = context.getResourceManager().getResourceForInstance(o);
						if (r != null) {
							assert(r instanceof ProMPOResource);
							Collection<ProMPOResource> c = new LinkedList<ProMPOResource>();
							c.add((ProMPOResource) r);
							values.add(c);
						}
					}

					ProMCResource res = new ProMCResource(context, null, getResourceTypeFor(conn.getClass()), id,
							values);
					resources.put(id, res);
					signalUpdate();
				}
			} catch (ConnectionCannotBeObtained e) {
				// do nothing
			}
		}
	}

	public void connectionDeleted(ConnectionID id) {
		resources.remove(id);
		// No need to alert serializer, the connection will not be serialized if it has
		// been removed/destroyed.
	}

	public void connectionUpdated(ConnectionID id) {
		assert(resources.containsKey(id));
		// No need to alert the serializer, the connections is not serialized yet, it will
		// be on exit, not earlier.
		signalUpdate();
	}

}
"
ProMTaskManager.java,context,"package org.processmining.contexts.uitopia.hub;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

import org.deckfour.uitopia.api.event.TaskListener;
import org.deckfour.uitopia.api.hub.TaskManager;
import org.deckfour.uitopia.api.model.Action;
import org.deckfour.uitopia.api.model.Resource;
import org.processmining.contexts.uitopia.UIContext;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.contexts.uitopia.model.ProMAction;
import org.processmining.contexts.uitopia.model.ProMPOResource;
import org.processmining.contexts.uitopia.model.ProMTask;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.PluginContextID;
import org.processmining.framework.plugin.events.PluginLifeCycleEventListener;

public class ProMTaskManager implements TaskManager<ProMTask, ProMPOResource>, PluginLifeCycleEventListener {

	private final Set<ProMTask> tasks = new HashSet<ProMTask>();
	private final Set<ProMTask> activeTasks = new HashSet<ProMTask>();
	private final UIContext context;

	private final Map<PluginContextID, ProMTask> context2task = new HashMap<PluginContextID, ProMTask>();

	private ProMTaskManager(UIContext context) {
		this.context = context;
	}

	private static ProMTaskManager instance = null;

	public static ProMTaskManager initialize(UIContext context) {
		if (instance == null) {
			instance = new ProMTaskManager(context);
		}
		return instance;
	}

	public ProMTask execute(Action action, java.util.List<Collection<? extends Resource>> parameterValues,
			TaskListener listener) throws Exception {

		assert (action instanceof ProMAction);
		java.util.List<Collection<ProMPOResource>> list = new ArrayList<Collection<ProMPOResource>>();
		for (Collection<? extends Resource> v : parameterValues) {
			Collection<ProMPOResource> l = new ArrayList<ProMPOResource>();
			for (Resource r : v) {
				if (!(r instanceof ProMPOResource)) {
					throw new Exception(""Cannot instantiate plugins on Connections"");
				}
				l.add((ProMPOResource) r);
			}
			list.add(l);
		}

		UIPluginContext pluginContext = context.getMainPluginContext().createChildContext(action.getName());

		pluginContext.getPluginLifeCycleEventListeners().add(this);

		ProMTask task;
		synchronized (context2task) {
			task = new ProMTask(context, (ProMAction) action, list, pluginContext, listener);
			context2task.put(pluginContext.getID(), task);
		}
		return task;
	}

	public java.util.List<ProMTask> getActiveTasks() {
		return new ArrayList<ProMTask>(activeTasks);
	}

	public java.util.List<ProMTask> getAllTasks() {
		return new ArrayList<ProMTask>(tasks);
	}

	public void pluginCancelled(PluginContext context) {
		synchronized (context2task) {
			activeTasks.remove(context2task.get(context.getID()));
			context.getParentContext().deleteChild(context);
		}
	}

	public void pluginCompleted(PluginContext context) {
		synchronized (context2task) {
			activeTasks.remove(context2task.get(context.getID()));
			context.getParentContext().deleteChild(context);
		}
	}

	public void pluginCreated(PluginContext context) {
		synchronized (context2task) {
			tasks.add(context2task.get(context.getID()));
		}
	}

	public void pluginDeleted(PluginContext context) {
		synchronized (context2task) {
			activeTasks.remove(context2task.get(context.getID()));
			context.getParentContext().deleteChild(context);
		}
	}

	public void pluginFutureCreated(PluginContext context) {
		// Gracefully ignore
	}

	public void pluginResumed(PluginContext context) {
		synchronized (context2task) {
			activeTasks.add(context2task.get(context.getID()));
		}
	}

	public void pluginStarted(PluginContext context) {
		synchronized (context2task) {
			activeTasks.add(context2task.get(context.getID()));
		}
	}

	public void pluginSuspended(PluginContext context) {
		synchronized (context2task) {
			activeTasks.remove(context2task.get(context.getID()));
		}
	}

	public void pluginTerminatedWithError(PluginContext context, Throwable t) {
		synchronized (context2task) {
			activeTasks.remove(context2task.get(context.getID()));
			context.getParentContext().deleteChild(context);
		}
	}

	public boolean isActionableResource(Resource r) {
		return r instanceof ProMPOResource;
	}
	
	public boolean isActionableResource(java.util.List<Resource> resources) {
		for(Resource r : resources){
			if(!(r instanceof ProMPOResource)){
				return false;
			}
		}
		return true;
	}

	public boolean isAnActionableResource(java.util.List<Resource> resources) {
		for(Resource r : resources){
			if(r instanceof ProMPOResource){
				return true;
			}
		}
		return false;
	}

}
"
ProMViewManager.java,context,"package org.processmining.contexts.uitopia.hub;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

import javax.swing.JComponent;

import org.deckfour.uitopia.api.hub.ViewManager;
import org.deckfour.uitopia.api.model.Resource;
import org.deckfour.uitopia.api.model.ResourceType;
import org.deckfour.uitopia.api.model.View;
import org.deckfour.uitopia.api.model.ViewType;
import org.processmining.contexts.uitopia.UIContext;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.contexts.uitopia.annotations.Visualizer;
import org.processmining.contexts.uitopia.model.ProMViewType;
import org.processmining.framework.plugin.PluginParameterBinding;
import org.processmining.framework.plugin.ProMCanceller;
import org.processmining.framework.util.Pair;

public class ProMViewManager extends UpdateSignaller implements ViewManager {

	private static ProMViewManager instance = null;
	private final UIContext context;
	private final Map<Class<?>, List<ViewType>> viewClasses = new HashMap<Class<?>, List<ViewType>>();
	private final List<View> views;

	private ProMViewManager(UIContext context) {
		this.context = context;
		views = new ArrayList<View>();

		for (ResourceType type : context.getResourceManager().getAllSupportedResourceTypes()) {
			registerResourceType(type);
		}
	}

	public void registerResourceType(final ResourceType type) {
		viewClasses.put(type.getTypeClass(), new ArrayList<ViewType>(0));
		Set<Pair<Integer, PluginParameterBinding>> visualizers = context.getPluginManager().find(Visualizer.class,
				JComponent.class, UIPluginContext.class, true, false, true, type.getTypeClass());
		Set<Pair<Integer, PluginParameterBinding>> cancellableVisualizers = context.getPluginManager().find(Visualizer.class,
				JComponent.class, UIPluginContext.class, true, false, true, type.getTypeClass(), ProMCanceller.class);
		for (Pair<Integer, PluginParameterBinding> binding : visualizers) {
			viewClasses.get(type.getTypeClass()).add(new ProMViewType(this, type, binding));
		}
		for (Pair<Integer, PluginParameterBinding> binding : cancellableVisualizers) {
			viewClasses.get(type.getTypeClass()).add(new ProMViewType(this, type, binding));
		}
		Collections.sort(viewClasses.get(type.getTypeClass()), new Comparator<ViewType>() {

			public int compare(ViewType o1, ViewType o2) {
				if (o1 == o2 || o1.equals(o2)) {
					return 0;
				}
				boolean isO1ExactMatch = o1.getPrimaryType() == type.getTypeClass();
				boolean isO2ExactMatch = o2.getPrimaryType() == type.getTypeClass();
				if (isO1ExactMatch && !isO2ExactMatch) {
					return -1;
				} else if (!isO1ExactMatch && isO2ExactMatch) {
					return 1;
				} else {
					return 0;	
				} 				
			}
		});
	}

	public static ProMViewManager initialize(UIContext context) {
		if (instance == null) {
			instance = new ProMViewManager(context);
		}
		return instance;
	}

	public List<ViewType> getViewTypes(Resource resource) {
		List<ViewType> result = viewClasses.get(resource.getType().getTypeClass());
		return (result == null ? Collections.<ViewType>emptyList() : result);
	}
	
	public List<ViewType> getViewTypes(List<Resource> resources) {
		List<ViewType> views = new ArrayList<ViewType>();
		for(Resource r : resources){
			views.addAll(getViewTypes(r));
		}
		return views;
	}

	public List<View> getViews() {
		return views;
	}

	public void addView(View view) {
		synchronized (views) {
			views.add(view);
			signalUpdate();
		}
	}

	public void removeView(View view) {
		synchronized (views) {
			views.remove(view);
			view.destroy();
			signalUpdate();
		}
	}

	public UIContext getContext() {
		return context;
	}



}
"
UpdateSignaller.java,context,"package org.processmining.contexts.uitopia.hub;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.List;

import org.deckfour.uitopia.api.event.UpdateListener;

public class UpdateSignaller {

	private final List<UpdateListener> listeners = new ArrayList<UpdateListener>();

	public UpdateSignaller() {
		super();
	}

	public void addListener(UpdateListener listener) {
		synchronized (listeners) {
			listeners.add(listener);
			listener.updated();
		}
	}

	public Collection<UpdateListener> getListeners() {
		return Collections.unmodifiableCollection(listeners);
	}

	public void removeAllListeners() {
		synchronized (listeners) {
			listeners.clear();
		}
	}

	public void removeListener(UpdateListener listener) {
		synchronized (listeners) {
			listeners.remove(listener);
		}
	}

	protected void signalUpdate() {
		synchronized (listeners) {
			for (UpdateListener listener : listeners) {
				listener.updated();
			}
		}
	}

}"
AbstractAuthored.java,context,"package org.processmining.contexts.uitopia.model;

import java.net.URI;
import java.net.URL;

import org.deckfour.uitopia.api.model.Author;

public class AbstractAuthored {

	public Author getAuthor() {
		// TODO
		return new Author() {

			public String getAffiliation() {
				// TODO Auto-generated method stub
				return ""Eindhoven University of Technology"";
			}

			public String getEmail() {
				// TODO Auto-generated method stub
				return ""foo@bar.com"";
			}

			public String getName() {
				// TODO Auto-generated method stub
				return ""John Doe"";
			}

			public URI getWebsite() {
				// TODO Auto-generated method stub
				try {
					return new URL(""http://www.processmining.org"").toURI();
				} catch (Exception e) {
					return null;
				}
			}

		};
	}
}
"
ProMAction.java,context,"package org.processmining.contexts.uitopia.model;

import java.lang.reflect.Array;
import java.net.URI;
import java.net.URL;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;

import javax.swing.ImageIcon;

import org.deckfour.uitopia.api.model.Action;
import org.deckfour.uitopia.api.model.ActionStatus;
import org.deckfour.uitopia.api.model.ActionType;
import org.deckfour.uitopia.api.model.Author;
import org.deckfour.uitopia.api.model.Category;
import org.deckfour.uitopia.api.model.Parameter;
import org.deckfour.uitopia.api.model.Resource;
import org.deckfour.uitopia.api.model.ResourceType;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.contexts.uitopia.hub.ProMResourceManager;
import org.processmining.framework.plugin.PluginDescriptor;
import org.processmining.framework.plugin.PluginManager;
import org.processmining.framework.plugin.PluginParameterBinding;
import org.processmining.framework.util.Cast;

public class ProMAction implements Action, Comparable<ProMAction> {

	private final PluginDescriptor plugin;
	private final int methodIndex;
	private final List<Parameter> inputs;
	private String name;
	private final List<Parameter> outputs;
	private final boolean[] isResource;
	private final int[] resourceIndex;
	private final Author author;
	private final PluginManager pluginManager;
	private final String pack;
	
	private String help;
	private String[] keywords;
	private String[] catergories;

	public ProMAction(ProMResourceManager resourceManager, PluginManager pluginManager, final PluginDescriptor plugin,
			final int methodIndex) {
		this.pluginManager = pluginManager;
		this.plugin = plugin;
		this.methodIndex = methodIndex;

		name = plugin.getAnnotation(UITopiaVariant.class, methodIndex).uiLabel();
		if (name.equals(UITopiaVariant.USEPLUGIN)) {
			name = plugin.getName();
		} else if (name.equals(UITopiaVariant.USEVARIANT)) {
			name = plugin.getMethodLabel(methodIndex);
		}

		help = plugin.getAnnotation(UITopiaVariant.class, methodIndex).uiHelp();
		if (help.equals(UITopiaVariant.USEPLUGIN)) {
			help = plugin.getHelp();
		} else if (help.equals(UITopiaVariant.USEVARIANT)) {
			help = plugin.getMethodHelp(methodIndex);
		}

		catergories = plugin.getCategories();
		keywords = plugin.getKeywords();
		
		pack = plugin.getAnnotation(UITopiaVariant.class, methodIndex).pack();

		author = new Author() {

			public String getAffiliation() {
				return plugin.getAnnotation(UITopiaVariant.class, methodIndex).affiliation();
			}

			public String getEmail() {
				return plugin.getAnnotation(UITopiaVariant.class, methodIndex).email();
			}

			public String getName() {
				return plugin.getAnnotation(UITopiaVariant.class, methodIndex).author();
			}

			public URI getWebsite() {
				URI uri = null;
				try {
					uri = new URL(plugin.getAnnotation(UITopiaVariant.class, methodIndex).website()).toURI();
				} catch (Exception e) {
					try {
						uri = new URL(""http://www.processmining.org"").toURI();
					} catch (Exception e2) {
					}
				}
				return uri;
			}

		};

		isResource = new boolean[plugin.getParameterNames(methodIndex).size()];
		resourceIndex = new int[plugin.getParameterNames(methodIndex).size()];

		inputs = new ArrayList<Parameter>();
		int resIndex = 0;
		for (int i = 0; i < plugin.getParameterNames(methodIndex).size(); i++) {
			Class<?> type = plugin.getParameterTypes(methodIndex).get(i);

			String name = plugin.getParameterNames(methodIndex).get(i);

			boolean isArray = type.isArray();
			if (isArray) {
				type = type.getComponentType();
			}
			ResourceType resType = resourceManager.getResourceTypeFor(type);

			if (resType != null) {
				inputs.add(new ProMParameter(name, i, resType, isArray));
				isResource[i] = true;
				resourceIndex[i] = resIndex++;
			} else {
				isResource[i] = false;
				resourceIndex[i] = -1;
			}
		}

		outputs = new ArrayList<Parameter>();
		for (int i = 0; i < plugin.getReturnNames().size(); i++) {
			Class<?> type = plugin.getReturnTypes().get(i);
			String name = plugin.getReturnNames().get(i);

			boolean isArray = type.isArray();
			if (type.isArray()) {
				type = type.getComponentType();
			}
			ResourceType resType = resourceManager.getResourceTypeFor(type);
			if (resType != null) {
				outputs.add(new ProMParameter(name, i, resType, isArray));
			}
		}

	}

	public boolean handlesCancel() {
		return plugin.handlesCancel();
	}

	public List<Parameter> getInput() {
		return inputs;
	}

	public String getName() {
		return name;
	}

	public String getPackage() {
		return pack;
	}

	public List<Parameter> getOutput() {
		return outputs;
	}

	public <R extends Resource> List<PluginParameterBinding> getBindings(List<Collection<R>> parameterValues,
			boolean executable) {
		Class<?>[] types = new Class<?>[parameterValues.size()];
		for (int i = 0; i < parameterValues.size(); i++) {
			Collection<? extends Resource> resources = parameterValues.get(i);
			if (resources.isEmpty()) {
				types[i] = null;
				continue;
			}
			types[i] = resources.iterator().next().getType().getTypeClass();
			if (resources.size() > 1) {
				types[i] = Array.newInstance(types[i], 0).getClass();
			}
		}

		return PluginParameterBinding.Factory.tryToBind(pluginManager, plugin, methodIndex, executable, false, types);

	}

	public ActionStatus getStatus(List<Collection<? extends Resource>> parameterValues) {

		// This cast is safe, since ProMResource is a final class, i.e. the given collection
		// cannot be based on subtypes. 
		List<Collection<ProMResource<?>>> promParameterValues = Cast
				.<java.util.List<Collection<ProMResource<?>>>>cast(parameterValues);

		List<PluginParameterBinding> bindings = getBindings(promParameterValues, true);

		if (!bindings.isEmpty()) {
			return ActionStatus.EXECUTABLE;
		}

		bindings = getBindings(promParameterValues, false);

		if (!bindings.isEmpty()) {
			return ActionStatus.INCOMPLETE;
		}

		return ActionStatus.INVALID;

	}

	public ActionType getType() {
		if (UIPluginContext.class.isAssignableFrom(plugin.getContextType(methodIndex))) {
			return ActionType.INTERACTIVE;
		} else {
			return ActionType.HEADLESS;
		}
	}

	public PluginDescriptor getPlugin() {
		return plugin;
	}

	public int getMethodIndex() {
		return methodIndex;
	}

	public int compareTo(ProMAction action) {
		int c = getName().compareTo(action.getName());
		if (c == 0) {
			return methodIndex - action.methodIndex;
		}
		return c;
	}

	public int getMostSignificantResultIndex() {
		return plugin.getMostSignificantResult();
	}

	public boolean equals(Object o) {
		return (o instanceof ProMAction ? plugin.equals(((ProMAction) o).plugin)
				&& (methodIndex == ((ProMAction) o).methodIndex) : false);
	}

	public int hashCode() {
		return 37 * plugin.hashCode() + methodIndex;
	}

	public String toString() {
		return getName();
	}

	public Author getAuthor() {
		return author;
	}

	public String getHelp() {
		return help;
	}

	public String[] getCategories() {
		return catergories;
	}

	public String[] getKeywords() {
		return keywords;
	}

	public boolean isOfCategory(Category category) {
		for (String c : catergories) {
			if (category.getName().equals(c)) {
				return true;
			}
		}
		return false;
	}
	
	public ImageIcon getIcon() {
		/*
		 * HV: For the time being, we simply use the icon of the package. 
		 * Later on, we can introduce icons that are specific for a plug-ins.
		 */
		if (plugin.getIcon() != null) {
			return plugin.getIcon();
		}
//		PackageDescriptor pack = plugin.getPackage();
//		if (pack != null) {
//			return PMIconCache.getIcon(pack);
//		}
		/*
		 * No icon.
		 */
		return null;
	}
	
	public URL getURL() {
		/*
		 * HV: For the time being, we simply use the URL of th epackage.
		 * Later on, we can introduce URLs that are specific for plug-ins.
		 */
		if (plugin.getURL() != null) {
			return plugin.getURL();
		}
//		PackageDescriptor pack = plugin.getPackage();
//		if (pack != null) {
//			try {
//				return new URL(pack.getURL());
//			} catch (MalformedURLException e) {
//			}	
//		}
		/*
		 * No URL.
		 */
		return null;
	}
}
"
ProMCategory.java,context,"package org.processmining.contexts.uitopia.model;

import org.deckfour.uitopia.api.model.Category;
import org.processmining.framework.plugin.annotations.PluginCategory;

public class ProMCategory implements Category {

	private PluginCategory c;

	public ProMCategory(PluginCategory c){
		this.c = c;
	}
	public String getName() {
		return c.getName();
	}

	public String getDescription() {
		return c.getDescription();
	}

	public String getFilterImage() {
		return c.getImageFilterFilename();
	}
	
}
"
ProMCResource.java,context,"package org.processmining.contexts.uitopia.model;

import java.util.Collection;
import java.util.List;

import org.deckfour.uitopia.api.model.Action;
import org.deckfour.uitopia.api.model.ResourceType;
import org.processmining.contexts.uitopia.UIContext;
import org.processmining.framework.connections.Connection;
import org.processmining.framework.connections.ConnectionCannotBeObtained;
import org.processmining.framework.connections.ConnectionID;

public class ProMCResource extends ProMResource<ConnectionID> {

	public ProMCResource(UIContext context, Action sourceAction, ResourceType resType, ConnectionID id,
			List<Collection<ProMPOResource>> parameterValues) {
		super(context, sourceAction, resType, id, parameterValues);
		// TODO Auto-generated constructor stub
	}

	public void destroy() {
		isDestroyed = true;
		try {
			for (ProMResource<?> r : context.getResourceManager().getAllResources()) {
				r.parents.remove(this);
			}
			context.getConnectionManager().getConnection(id).remove();
		} catch (ConnectionCannotBeObtained e) {
		}

	}

	public String getName() {
		try {
			return context.getConnectionManager().getConnection(id).getLabel();
		} catch (ConnectionCannotBeObtained e) {
			isDestroyed = true;
			return ""This object is no longer available"";
		}
	}

	public void setName(String name) {
		try {
			context.getConnectionManager().getConnection(id).setLabel(name);
			if (listener != null) {
				listener.changed(this, false);
			}
		} catch (ConnectionCannotBeObtained e) {
			isDestroyed = true;
		}
	}

	/**
	 * Provides access to the object of the type specified by this resource.
	 * 
	 * @return The object carried by this resource.
	 */
	public Connection getInstance() {
		try {
			return context.getConnectionManager().getConnection(id);
		} catch (ConnectionCannotBeObtained e) {
			isDestroyed = true;
			return null;
		}
	}
}
"
ProMParameter.java,context,"package org.processmining.contexts.uitopia.model;

import org.deckfour.uitopia.api.model.Parameter;
import org.deckfour.uitopia.api.model.ResourceType;

public class ProMParameter implements Parameter {

	private final ResourceType type;
	private final String name;
	private final int index;
	private final boolean isArray;

	public ProMParameter(String name, int index, ResourceType type, boolean isArray) {
		this.name = name;
		this.index = index;
		this.type = type;
		this.isArray = isArray;
	}

	public boolean isRequired() {
		return true;
	}

	public String getName() {
		return name;
	}

	public ResourceType getType() {
		return type;
	}

	public int getRealParameterIndex() {
		return index;
	}

	public int getMaxCardinality() {
		return isArray ? Parameter.CARDINALITY_INFINITY : 1;
	}

	public int getMinCardinality() {
		return 1;
	}
}
"
ProMPOResource.java,context,"package org.processmining.contexts.uitopia.model;

import java.util.Collection;
import java.util.List;

import org.deckfour.uitopia.api.model.Action;
import org.deckfour.uitopia.api.model.ResourceType;
import org.processmining.contexts.uitopia.UIContext;
import org.processmining.framework.providedobjects.ProvidedObjectDeletedException;
import org.processmining.framework.providedobjects.ProvidedObjectID;

public class ProMPOResource extends ProMResource<ProvidedObjectID> {

	public ProMPOResource(UIContext context, Action sourceAction, ResourceType resType, ProvidedObjectID id,
			List<Collection<ProMPOResource>> parameterValues) {
		super(context, sourceAction, resType, id, parameterValues);
	}

	public void destroy() {
		isDestroyed = true;
		try {
			context.getProvidedObjectManager().deleteProvidedObject(id);
			for (ProMResource<?> r : context.getResourceManager().getAllResources()) {
				r.parents.remove(this);
			}
		} catch (ProvidedObjectDeletedException e) {
			// THat's fine
		}
	}

	public String getName() {
		try {
			return context.getProvidedObjectManager().getProvidedObjectLabel(id);
		} catch (ProvidedObjectDeletedException e) {
			return ""This object is no longer available"";
		}
	}

	public void setName(String name) {
		try {
			context.getProvidedObjectManager().relabelProvidedObject(id, name);
			if (listener != null) {
				listener.changed(this, false);
			}
		} catch (ProvidedObjectDeletedException e) {
			// Should not happen, unless destroy has been called
			assert (false);
		}
	}

	/**
	 * Provides access to the object of the type specified by this resource.
	 * 
	 * @return The object carried by this resource.
	 */
	public Object getInstance() {
		try {
			return context.getProvidedObjectManager().getProvidedObjectObject(id, true);
		} catch (ProvidedObjectDeletedException e) {
			return null;
		}
	}

}
"
ProMResource.java,context,"package org.processmining.contexts.uitopia.model;

import java.awt.Image;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import org.deckfour.uitopia.api.model.Action;
import org.deckfour.uitopia.api.model.Resource;
import org.deckfour.uitopia.api.model.ResourceType;
import org.deckfour.uitopia.api.model.View;
import org.processmining.contexts.uitopia.UIContext;
import org.processmining.framework.ProMID;

public abstract class ProMResource<I extends ProMID> implements Resource {

	public static interface Listener {
		public void changed(ProMResource<?> resource, boolean fullUpdate);
	}

	protected final ResourceType resType;
	protected boolean favorite = false;
	protected long creationTime;
	protected long lastAccessTime = System.currentTimeMillis();
	protected final I id;
	protected final Set<ProMPOResource> parents;
	protected final UIContext context;
	protected View view = null;
	protected final Action sourceAction;
	protected boolean isDestroyed = false;
	protected Listener listener;

	private static Long currentTime = System.currentTimeMillis();

	public ProMResource(UIContext context, Action sourceAction, ResourceType resType, I id,
			List<Collection<ProMPOResource>> parameterValues) {
		assert resType != null;
		this.sourceAction = sourceAction;
		this.resType = resType;
		this.id = id;
		synchronized (currentTime) {
			currentTime = Math.max(currentTime + 1, System.currentTimeMillis());
			creationTime = currentTime;
		}
		parents = new HashSet<ProMPOResource>();
		this.context = context;

		for (Collection<ProMPOResource> col : parameterValues) {
			parents.addAll(col);
		}

	}

	public void setListener(Listener listener) {
		this.listener = listener;
	}

	public void setParents(Set<ProMPOResource> parents) {
		this.parents.clear();
		this.parents.addAll(parents);
	}

	public Date getCreationTime() {
		return new Date(creationTime);
	}

	public Date getLastAccessTime() {
		return new Date(lastAccessTime);
	}

	public void setCreationTime(long creationTime) {
		this.creationTime = creationTime;
	}

	public void setLastAccessTime(long lastAccessTime) {
		this.lastAccessTime = lastAccessTime;
	}

	public Collection<ProMPOResource> getParents() {
		return Collections.unmodifiableCollection(parents);
	}

	public Image getPreview(int maxWidth, int maxHeight) {
		if (view == null) {
			return resType.getTypeIcon();
		}
		return view.getPreview(maxWidth, maxHeight);
	}

	public void setView(ProMView view) {
		this.view = view;
	}

	public Action getSourceAction() {
		return sourceAction;
	}

	public boolean isFavorite() {
		return favorite;
	}

	public void setFavorite(boolean favorite) {
		this.favorite = favorite;
		if (listener != null) {
			listener.changed(this, false);
		}
	}

	public void updateLastAccessTime() {
		lastAccessTime = System.currentTimeMillis();
	}

	public ResourceType getType() {
		return resType;
	}

	public boolean equals(Object o) {
		if (!(o instanceof ProMResource)) {
			return false;
		}
		ProMResource<?> p = (ProMResource<?>) o;
		return p.id.equals(id);
	}

	public int hashCode() {
		return id.hashCode();
	}

	public String toString() {
		return getName();
	}

	public ProMID getID() {
		return id;
	}

	public boolean isDestroyed() {
		return isDestroyed;
	}

	public abstract Object getInstance();
}
"
ProMResourceType.java,context,"package org.processmining.contexts.uitopia.model;

import java.awt.Image;
import java.net.URI;
import java.net.URL;

import org.deckfour.uitopia.api.model.Author;
import org.deckfour.uitopia.api.model.ResourceType;
import org.deckfour.uitopia.ui.util.ImageLoader;
import org.processmining.framework.annotations.AuthoredType;
import org.processmining.framework.annotations.Icon;

public class ProMResourceType implements ResourceType {

	private final Class<?> type;
	private Author author;
	private Image icon;
	private String name;
	private final static String DEFAULT_ICON = ""resourcetype_model_30x35.png"";

	public ProMResourceType(Class<?> aType) {
		type = aType;

		final ResourceTypeInfo typeInfo = ProMResourceTypeInformation.getInstance().getInfoFor(aType);
		if (typeInfo != null) {
			author = typeInfo;
			name = typeInfo.getTypeName();
			icon = ImageLoader.load(typeInfo.getIcon());

		} else {
			if (type.isAnnotationPresent(AuthoredType.class)) {
				author = new Author() {

					public String getAffiliation() {
						return type.getAnnotation(AuthoredType.class).affiliation();
					}

					public String getEmail() {
						return type.getAnnotation(AuthoredType.class).email();
					}

					public String getName() {
						return type.getAnnotation(AuthoredType.class).author();
					}

					public URI getWebsite() {
						URI uri = null;
						try {
							uri = new URL(type.getAnnotation(AuthoredType.class).website()).toURI();
						} catch (Exception e) {
							try {
								uri = new URL(""http://www.processmining.org"").toURI();
							} catch (Exception e2) {
							}
						}
						return uri;
					}

				};
				name = type.getAnnotation(AuthoredType.class).typeName();
			} else {
				author = new Author() {

					public String getAffiliation() {
						return ""Affiliation unknown"";
					}

					public String getEmail() {
						return ""h.m.w.verbeek@tue.nl"";
					}

					public String getName() {
						return ""Author unknown"";
					}

					public URI getWebsite() {
						URI uri = null;
						try {
							uri = new URL(""http://www.processmining.org"").toURI();
						} catch (Exception e2) {
						}
						return uri;
					}
				};
				name = type.getSimpleName();
			}

			if (type.isAnnotationPresent(Icon.class)) {
				icon = ImageLoader.load(type.getAnnotation(Icon.class).icon());
			}

			/*
			 * HV: No icon found yet. Use default.
			 */
			if (icon == null) {
				if (type.getName().equals(""org.deckfour.xes.model.XLog"")) {
					/*
					 * HV: The framework does not know the XLog interface, and
					 * OpenXES does not know the @Icon annotation. Therefore, we
					 * hardcode the link between an XLog and its icon here.
					 */
					icon = ImageLoader.load(""resourcetype_log_30x35.png"");
				} else {
					icon = ImageLoader.load(DEFAULT_ICON);
				}
			}
		}

	}

	public Author getTypeAuthor() {
		return author;
	}

	public Class<?> getTypeClass() {
		return type;
	}

	public Image getTypeIcon() {
		return icon;
	}

	public String getTypeName() {
		return name;
	}

	public boolean isAssignableFrom(ResourceType type) {
		return getTypeClass().isAssignableFrom(type.getTypeClass());
	}

	public boolean equals(Object o) {
		if (!(o instanceof ResourceType)) {
			return false;
		}
		ResourceType rt = (ResourceType) o;
		return (type.equals(rt.getTypeClass()) && getTypeName().equals(rt.getTypeName()));

	}

	public int hashCode() {
		return type.hashCode() + 37 * getTypeName().hashCode();
	}

}
"
ProMResourceTypeInformation.java,context,"package org.processmining.contexts.uitopia.model;

import java.net.URI;
import java.net.URL;
import java.util.HashMap;
import java.util.Map;

import org.deckfour.uitopia.api.model.Author;

public class ProMResourceTypeInformation {

	private final static Map<Class<?>, ResourceTypeInfo> typeInfo = new HashMap<Class<?>, ResourceTypeInfo>();
	private static ProMResourceTypeInformation instance;

	private ProMResourceTypeInformation() {
	}

	public final static ProMResourceTypeInformation getInstance() {
		if (instance == null) {
			instance = new ProMResourceTypeInformation();
		}
		return instance;
	}

	public ResourceTypeInfo getInfoFor(Class<?> type) {
		return typeInfo.get(type);
	}
	
	public void setInfoFor(Class<?> type, String typename, String affiliation, String email, String author, String website,
			String icon) {
		typeInfo.put(type, new ResourceTypeInfo(typename, affiliation, email, author, website, icon));
	}
}

class ResourceTypeInfo implements Author {

	public String affiliation;
	public String email;
	public String author;
	public String website;
	public String icon;
	public String typename;

	public ResourceTypeInfo(String typename, String affiliation, String email, String author, String website,
			String icon) {
		this.typename = typename;
		this.affiliation = affiliation;
		this.email = email;
		this.author = author;
		this.website = website;
		this.icon = icon;
	}

	public String getTypeName() {
		return typename;
	}

	public String getAffiliation() {
		return affiliation;
	}

	public String getEmail() {
		return email;
	}

	public String getName() {
		return author;
	}

	public URI getWebsite() {
		URI uri = null;
		try {
			uri = new URL(website).toURI();
		} catch (Exception e2) {
		}
		return uri;
	}

	public String getIcon() {
		return icon;
	}

}
"
ProMTask.java,context,"package org.processmining.contexts.uitopia.model;

import java.lang.reflect.Array;
import java.util.Collection;
import java.util.Iterator;

import javax.swing.JComponent;

import org.deckfour.uitopia.api.event.TaskListener;
import org.deckfour.uitopia.api.event.TaskListener.InteractionResult;
import org.deckfour.uitopia.api.model.ResourceType;
import org.deckfour.uitopia.api.model.Task;
import org.processmining.contexts.uitopia.UIContext;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.PluginContextID;
import org.processmining.framework.plugin.PluginExecutionResult;
import org.processmining.framework.plugin.ProMFuture;
import org.processmining.framework.plugin.events.Logger;
import org.processmining.framework.plugin.events.PluginLifeCycleEventListener;
import org.processmining.framework.plugin.events.ProgressEventListener;
import org.processmining.framework.providedobjects.ProvidedObjectDeletedException;
import org.processmining.framework.providedobjects.ProvidedObjectID;

public class ProMTask implements Task<ProMPOResource>, ProgressEventListener, Logger, PluginLifeCycleEventListener {

	private final ProMAction action;
	private PluginExecutionResult result;
	private int lowbo = 0, upbo = 0, progress = 0;
	private final TaskListener listener;
	private final UIContext context;
	private final java.util.List<Collection<ProMPOResource>> parameterValues;
	private final java.util.List<ProvidedObjectID> providedObjectIds;
	private boolean active;
	private final UIPluginContext pluginContext;

	public ProMTask(UIContext context, ProMAction action, java.util.List<Collection<ProMPOResource>> parameterValues,
			UIPluginContext pluginContext, TaskListener listener) {
		this.context = context;
		this.action = action;
		this.parameterValues = parameterValues;
		this.pluginContext = pluginContext;
		this.listener = listener;
		changeProgressIndeterminate(true);

		// In this constructor, the task should set up a context for the plugin
		// carried by the action. All resources of the action should have values,
		// i.e. the action should be executable. 
		//		assert (action.getStatus(parameterValues) == ActionStatus.EXECUTABLE);

		// Then, using the resources attached to the input parameters of the 
		// action, possibly some other input parameters need to be found, for example
		// be scanning for connections. This is up to the implementing classes.
		pluginContext.getProgressEventListeners().add(this);
		pluginContext.getLoggingListeners().add(this);
		pluginContext.getPluginLifeCycleEventListeners().add(this);

		Object[] args = unpackResourceCollections(parameterValues);

		// The plugin should be invoked and this task should attach itself as 
		// a progress listener
		pluginContext.setTask(this);
		synchronized (this) {
			active = true;
			pluginContext.getParentContext().getPluginLifeCycleEventListeners().firePluginCreated(pluginContext);
			result = action.getPlugin().invoke(action.getMethodIndex(), pluginContext, args);
			providedObjectIds = context.getProvidedObjectManager().createProvidedObjects(pluginContext);
		}
	}

	public void destroy() {
		if (result != null) {
			if (pluginContext.getProgress() != null) {
				// We have a progress. Have it take care of the futures and such.
				pluginContext.getProgress().cancel();
			} else {
				// We cancel all futures that might exist in this
				// result. Canceling the first only would also work,
				// but this is potentially faster.
				try {
					for (int i = 0; i < result.getSize(); i++) {
						Object o = result.getResult(i);
						if (o instanceof ProMFuture<?>) {
							result.<ProMFuture<?>>getResult(i).cancel(!action.handlesCancel());
						}
					}
				} catch (NullPointerException _) {
					// Happens when task terminates before we can cancel all children
				}
			}
			for (ProvidedObjectID id : getProvidedObjectIds()) {
				try {
					context.getProvidedObjectManager().deleteProvidedObject(id);
				} catch (ProvidedObjectDeletedException e) {
					//Ignore
				}
			}
			result = null;
		}
		progress = upbo;
		listener.updateProgress(1.0);
	}

	public ProMAction getAction() {
		return action;
	}

	public double getProgress() {
		return (double) progress / (double) (upbo - lowbo);
	}

	public InteractionResult showConfiguration(String title, JComponent configuration) {
		return listener.showConfiguration(title, configuration);
	}

	public InteractionResult showWizard(String title, boolean first, boolean last, JComponent configuration) {
		return listener.showWizard(title, first, last, configuration);
	}

	public java.util.List<Collection<ProMPOResource>> getParameterValues() {
		//		java.util.List<Collection<ProMResource<?>>> list = new ArrayList<Collection<ProMResource<?>>>();
		//		for (Collection<ProMPOResource> v : parameterValues) {
		//			Collection<ProMResource<?>> l = new ArrayList<ProMResource<?>>(v);
		//			list.add(l);
		//		}
		return parameterValues;
	}

	private Object[] unpackResourceCollections(java.util.List<Collection<ProMPOResource>> parameters) {
		Object[] objects = new Object[parameters.size()];

		for (int i = 0; i < parameters.size(); i++) {
			if (action.getInput().get(i).getMaxCardinality() == 1) {
				objects[i] = parameters.get(i).iterator().next().getInstance();
			} else {
				Object[] list = (Object[]) Array.newInstance(action.getInput().get(i).getType().getTypeClass(),
						parameters.get(i).size());
				Iterator<ProMPOResource> it = parameters.get(i).iterator();
				int j = 0;
				while (it.hasNext()) {
					list[j++] = it.next().getInstance();
				}
				objects[i] = list;
			}
		}

		return objects;

	}

	//****************ProgressEventListener Interface************************

	public void changeProgress(int progress) {
		this.progress = progress;
		lowbo = Math.min(lowbo, progress);
		upbo = Math.max(upbo, progress);
		listener.updateProgress(getProgress());
	}

	public void changeProgressBounds(int lowBo, int upBo) {
		lowbo = lowBo;
		upbo = upBo;
		progress = 0;
		listener.updateProgress(Math.max(Math.min(lowBo, progress), upBo));
	}

	public void changeProgressCaption(String newCaption) {
		// Gracefully ignore.
	}

	public void changeProgressIndeterminate(boolean indeterminate) {
		if (indeterminate) {
			lowbo = 0;
			upbo = 1;
			progress = 0;
			listener.updateProgress(0.5);
		}
	}

	//****************Logger Interface************************
	public void log(String message, PluginContextID contextID, MessageLevel messageLevel) {
		switch (messageLevel) {
			case DEBUG :
				listener.debug(message);
				break;
			case NORMAL :
				listener.info(message);
				break;
			case ERROR :
				listener.error(message);
				break;
			case WARNING :
				listener.warning(message);
				break;
			case TEST :
				listener.debug(message);
				break;
		}
	}

	public void log(Throwable t, PluginContextID contextID) {
		listener.error(t.getMessage(), t);
	}

	public void pluginCancelled(PluginContext context) {
		// Gracefully ignore. Only the completed is of interest
		listener.completed();
		active = false;
		result = null;
		changeProgress(upbo);
	}

	public void pluginCompleted(PluginContext pluginContext) {
		ProMPOResource[] setResult = null;
		int sig = action.getMostSignificantResultIndex();
		if (sig < 0) {
			// One of the inputs should be returned as the most significant result
			// find the corresponding parameter for this plugin variant.
			sig = action.getPlugin().getIndexInMethod(action.getMethodIndex(), -sig - 1);

			Collection<ProMPOResource> par = parameterValues.get(sig);
			// Visualize the first resource parameter in the end.
			setResult = par.toArray(new ProMPOResource[0]);
			sig = -1;
		}
		for (int i = 0; i < result.getSize(); i++) {
			ProvidedObjectID id = result.getProvidedObjectID(i);
			Class<?> type;
			try {
				type = context.getProvidedObjectManager().getProvidedObjectType(id);
			} catch (ProvidedObjectDeletedException e) {
				// If the object has been deleted, try the next one
				continue;
			}
			ResourceType resType = context.getResourceManager().getResourceTypeFor(type);
			if (resType != null) {
				ProMPOResource res = new ProMPOResource(context, action, resType, id, parameterValues);
				res = context.getResourceManager().addResource(id, res);

				if (i + 1 == sig) {
					res.setFavorite(true);
					setResult = new ProMPOResource[] { res };
				}
			}
		}
		listener.completed(setResult);
		active = false;
		result = null;
		changeProgress(upbo);
	}

	public void pluginCreated(PluginContext pluginContext) {
		// Gracefully ignore. Only the completed is of interest
	}

	public void pluginDeleted(PluginContext pluginContext) {
		// Gracefully ignore. Only the completed is of interest
	}

	public void pluginFutureCreated(PluginContext pluginContext) {
		// Gracefully ignore. Only the completed is of interest
	}

	public void pluginResumed(PluginContext pluginContext) {
		// Gracefully ignore. Only the completed is of interest
	}

	public void pluginStarted(PluginContext pluginContext) {
		// Gracefully ignore. Only the completed is of interest
	}

	public void pluginSuspended(PluginContext pluginContext) {
		// Gracefully ignore. Only the completed is of interest
	}

	public void pluginTerminatedWithError(PluginContext pluginContext, Throwable t) {
		// Gracefully ignore. Only the completed is of interest
		listener.completed();
		active = false;
		result = null;
		changeProgress(upbo);
	}

	public java.util.List<ProvidedObjectID> getProvidedObjectIds() {
		return providedObjectIds;
	}

	public String toString() {
		return (active ? ""[A]"" : ""[I]"") + action.toString();
	}

}
"
ProMView.java,context,"package org.processmining.contexts.uitopia.model;

import java.awt.BorderLayout;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.GraphicsConfiguration;
import java.awt.GraphicsDevice;
import java.awt.GraphicsEnvironment;
import java.awt.HeadlessException;
import java.awt.Image;
import java.awt.RenderingHints;
import java.awt.Transparency;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.image.BufferedImage;
import java.util.List;
import java.util.concurrent.CancellationException;

import javax.swing.BorderFactory;
import javax.swing.BoxLayout;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JComponent;
import javax.swing.JEditorPane;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.SwingUtilities;

import org.deckfour.uitopia.api.model.Resource;
import org.deckfour.uitopia.api.model.View;
import org.deckfour.uitopia.api.model.ViewType;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.contexts.uitopia.hub.ProMViewManager;
import org.processmining.contexts.uitopia.hub.overlay.ProgressOverlayDialog;
import org.processmining.framework.plugin.PluginDescriptor;
import org.processmining.framework.plugin.PluginExecutionResult;
import org.processmining.framework.plugin.PluginParameterBinding;
import org.processmining.framework.plugin.ProMCanceller;
import org.processmining.framework.util.Pair;

import com.fluxicon.slickerbox.factory.SlickerFactory;
import com.google.common.base.Throwables;

public class ProMView implements View {

	private final class ProMViewRunnable implements Runnable {

		private JComponent content;
		private ProgressOverlayDialog dialog;

		private String message;
		private String stacktrace;
		private PluginDescriptor descriptor;

		public ProMViewRunnable(JComponent content, ProgressOverlayDialog dialog, String message, String stacktrace,
				PluginDescriptor descriptor) {
			this.content = content;
			this.dialog = dialog;
			this.message = message;
			this.stacktrace = stacktrace;
			this.descriptor = descriptor;
		}

		public void run() {
			component.removeAll();
			if (content != null) {
				try {
					content.repaint();
					component.add(content, BorderLayout.CENTER);
				} catch (Exception e) {
					e.printStackTrace();
					//ignore
					message = e.getMessage();
					stacktrace = Throwables.getStackTraceAsString(e);
				}
			}
			if (component.getComponents().length == 0) {
				component.add(buildErrorComponent(message, stacktrace, descriptor), BorderLayout.CENTER);
			}
			dialog.changeProgress(dialog.getMaximum());
		}

		private JComponent buildErrorComponent(final String message, final String stacktrace,
				final PluginDescriptor plugin) {
			final JPanel errorPanel = new JPanel();
			errorPanel.setLayout(new BoxLayout(errorPanel, BoxLayout.Y_AXIS));
			String userfriendlyMessage = String.format(
					""<html><h1>Unable to produce the requested visualization</h1><h2>Error Message</h2><h3>%s</b></h3></html>"",
					message);
			final JEditorPane messagePanel = new JEditorPane(""text/html"", userfriendlyMessage);
			messagePanel.setEditable(false);
			final JButton debugButton = SlickerFactory.instance().createButton(""Show Debug Information"");
			debugButton.setAlignmentX(JComponent.CENTER_ALIGNMENT);
			debugButton.addActionListener(new ActionListener() {

				public void actionPerformed(ActionEvent e) {
					String debugMessage = String.format(
							""<html><body><h1>Unable to produce the requested visualization</h1>""
									+ ""<h2>Error Message</h2><h3>%s</b></h3>""
									+ ""<h2>Debug Information for Reporting</h2>"" + ""<p><b>Visualizer</b>: %s</p>""
									+ ""<p><b>Stack trace</b>: %s</p>"" + ""</body></html>"",
							message, plugin.getName(),
							stacktrace.replace(System.getProperty(""line.separator""), ""<p>\n""));
					messagePanel.setText(debugMessage);
					messagePanel.setCaretPosition(0);
					debugButton.removeActionListener(this);
					errorPanel.remove(debugButton);
					errorPanel.validate();
				}
			});
			errorPanel.add(new JScrollPane(messagePanel));
			errorPanel.add(debugButton);
			return errorPanel;
		}
	}

	private static final class ProMCancellerImpl implements ProMCanceller {

		private boolean isCancelled = false;

		public boolean isCancelled() {
			return isCancelled;
		}

		public void cancel() {
			isCancelled = true;
		}

	}

	private final JPanel component;
	private final ProMViewManager manager;
	private String name;
	private final ProMResource<?> resource;
	protected static GraphicsConfiguration gc;
	private final ProMViewType type;
	private BufferedImage original;
	private BufferedImage scaledImage;
	private final Pair<Integer, PluginParameterBinding> binding;
	private boolean working = true;
	private final ProMCancellerImpl proMCanceller;

	public ProMView(ProMViewManager manager, ProMViewType type, ProMResource<?> resource, String name,
			Pair<Integer, PluginParameterBinding> binding) {
		this.manager = manager;
		this.type = type;
		this.resource = resource;
		this.binding = binding;
		resource.setView(this);
		this.name = name;
		component = new JPanel(new BorderLayout());
		component.setBorder(BorderFactory.createEmptyBorder());
		component.setOpaque(false);
		original = toBufferedImage(resource.getType().getTypeIcon());
		proMCanceller = new ProMCancellerImpl();
		refresh(0);
	}

	public void destroy() {
		component.removeAll();
		proMCanceller.cancel();
	}

	public String getCustomName() {
		return name;
	}

	public Image getPreview(int maxWidth, int maxHeight) {
		synchronized (original) {

			int originalWidth = original.getWidth();
			int originalHeight = original.getHeight();
			double scaleFactor = (double) maxWidth / (double) originalWidth;
			double scaleY = (double) maxHeight / (double) originalHeight;
			if (scaleY < scaleFactor) {
				scaleFactor = scaleY;
			}

			int scaledWidth = Math.max(1, (int) (originalWidth * scaleFactor));
			int scaledHeight = Math.max(1, (int) (originalHeight * scaleFactor));

			scaledImage = createCompatibleImage(scaledWidth, scaledHeight);
			Graphics2D g2ds = scaledImage.createGraphics();
			g2ds = scaledImage.createGraphics();
			g2ds.setRenderingHint(RenderingHints.KEY_INTERPOLATION, RenderingHints.VALUE_INTERPOLATION_BILINEAR);
			g2ds.drawImage(original, 0, 0, scaledWidth, scaledHeight, null);
			g2ds.dispose();
			return scaledImage;
		}

	}

	public Resource getResource() {
		return resource;
	}

	public JComponent getViewComponent() {
		return component;
	}

	public void setCustomName(String name) {
		this.name = name;
	}

	private BufferedImage createCompatibleImage(int width, int height) {
		if (gc == null) {
			gc = component.getGraphicsConfiguration();
			if (gc == null) {
				gc = GraphicsEnvironment.getLocalGraphicsEnvironment().getDefaultScreenDevice()
						.getDefaultConfiguration();
			}
		}
		return gc.createCompatibleImage(width, height, Transparency.TRANSLUCENT);
	}

	public ViewType getType() {
		return type;
	}

	public void captureNow() {
		// Record a screen-capture of the currenly visible frame
		synchronized (original) {
			Dimension size = component.getSize();
			if (size.width > 0 && size.height > 0) {
				original = createCompatibleImage(size.width, size.height);
				Graphics2D g2d = original.createGraphics();
				component.paint(g2d);
				g2d.dispose();
			}
		}

	}

	// This method returns a buffered image with the contents of an image
	private BufferedImage toBufferedImage(Image image) {
		if (image instanceof BufferedImage) {
			return (BufferedImage) image;
		}

		// This code ensures that all the pixels in the image are loaded
		image = new ImageIcon(image).getImage();

		// Create a buffered image with a format that's compatible with the screen
		BufferedImage bimage = null;
		GraphicsEnvironment ge = GraphicsEnvironment.getLocalGraphicsEnvironment();
		try {
			// Determine the type of transparency of the new buffered image
			int transparency = Transparency.OPAQUE;

			// Create the buffered image
			GraphicsDevice gs = ge.getDefaultScreenDevice();
			GraphicsConfiguration gc = gs.getDefaultConfiguration();
			bimage = gc.createCompatibleImage(image.getWidth(null), image.getHeight(null), transparency);
		} catch (HeadlessException e) {
			// The system does not have a screen
		}

		if (bimage == null) {
			// Create a buffered image using the default color model
			int type = BufferedImage.TYPE_INT_RGB;
			bimage = new BufferedImage(image.getWidth(null), image.getHeight(null), type);
		}

		// Copy image to buffered image
		Graphics g = bimage.createGraphics();

		// Paint the image onto the buffered image
		g.drawImage(image, 0, 0, null);
		g.dispose();

		return bimage;
	}

	public void refresh() {
		refresh(0);
	}

	public void refresh(final int millisToPopup) {

		final UIPluginContext context = manager.getContext().getMainPluginContext()
				.createChildContext(""Visualizing: "" + resource.getName());
		context.getParentContext().getPluginLifeCycleEventListeners().firePluginCreated(context);

		final ProgressOverlayDialog dialog = new ProgressOverlayDialog(
				manager.getContext().getController().getMainView(), context,
				""Please wait while updating visualization..."");
		dialog.setIndeterminate(false);

		Thread thread = new Thread(new Runnable() {

			public void run() {
				manager.getContext().getController().getMainView().showOverlay(dialog);
				synchronized (ProMView.this) {
					working = true;
				}

				PluginExecutionResult result = getVisualizationResult(context, proMCanceller);

				String message = ""no message"";
				String stacktrace = ""unavailable"";
				JComponent content = null;
				try {
					context.log(""Starting visualization of "" + resource);
					result.synchronize();
					content = result.getResult(binding.getFirst());

					if (content == null) {
						throw new Exception(""The visualiser for "" + resource.toString()
								+ "" returned null. Please select another visualiser."");
					}
				} catch (CancellationException e) {
					proMCanceller.cancel();
					message = ""The visualiser is cancelled."";
					stacktrace = ""not available"";
				} catch (Exception e) {
					message = e.getMessage();
					stacktrace = Throwables.getStackTraceAsString(e);
				} finally {
					context.getParentContext().deleteChild(context);
					SwingUtilities.invokeLater(
							new ProMViewRunnable(content, dialog, message, stacktrace, result.getPlugin()));
					synchronized (ProMView.this) {
						working = false;
						ProMView.this.notifyAll();
					}
					manager.getContext().getController().getMainView().hideOverlay();
				}

			}

			private PluginExecutionResult getVisualizationResult(final UIPluginContext context,
					ProMCanceller proMCanceller) {
				PluginParameterBinding parameterBinding = binding.getSecond();
				List<Class<?>> parameterTypes = parameterBinding.getPlugin()
						.getParameterTypes(parameterBinding.getMethodIndex());
				if (parameterTypes.size() == 2 && parameterTypes.get(1) == ProMCanceller.class) {
					return parameterBinding.invoke(context, resource.getInstance(), proMCanceller);
				} else {
					return parameterBinding.invoke(context, resource.getInstance());
				}
			}

		});
		thread.start();

	}

	public synchronized boolean isReady() {
		return !working;
	}

}
"
ProMViewType.java,context,"package org.processmining.contexts.uitopia.model;

import java.text.MessageFormat;

import org.deckfour.uitopia.api.model.Resource;
import org.deckfour.uitopia.api.model.ResourceType;
import org.deckfour.uitopia.api.model.View;
import org.deckfour.uitopia.api.model.ViewType;
import org.processmining.contexts.uitopia.annotations.Visualizer;
import org.processmining.contexts.uitopia.hub.ProMViewManager;
import org.processmining.framework.packages.PackageDescriptor;
import org.processmining.framework.plugin.PluginDescriptor;
import org.processmining.framework.plugin.PluginParameterBinding;
import org.processmining.framework.util.Pair;

public class ProMViewType extends AbstractAuthored implements ViewType {

	private final ResourceType acceptedType;
	private final Pair<Integer, PluginParameterBinding> binding;
	private final ProMViewManager manager;
	private String name;

	public ProMViewType(ProMViewManager manager, ResourceType acceptedType,
			Pair<Integer, PluginParameterBinding> binding) {
		this.manager = manager;
		this.acceptedType = acceptedType;
		this.binding = binding;
		name = binding.getSecond().getPlugin().getAnnotation(Visualizer.class).name();
		if (name.equals(Visualizer.USEPLUGINNAME)) {
			name = binding.getSecond().getPlugin().getName();
		}
	}

	public View createView(Resource res) throws IllegalArgumentException {
		assert (res instanceof ProMResource);
		ProMResource<?> pr = ((ProMResource<?>) res);
		return new ProMView(manager, this, pr, res.getName(), binding);
	}

	public String getTypeName() {
		if (name.startsWith(""@"") && name.contains("" "")) {
			return name.substring(name.indexOf("" "") + 1);
		}
		return name;
	}

	public ResourceType getViewableType() {
		return acceptedType;
	}

	public String toString() {
		PackageDescriptor packageDesc = binding.getSecond().getPlugin().getPackage();
		if (packageDesc != null) {
			return MessageFormat.format(""{0} ({1})"", getTypeName(), packageDesc.getName());
		} else {
			return MessageFormat.format(""{0}"", getTypeName());
		}		
	}

	public boolean equals(Object o) {
		if (o instanceof ProMViewType) {
			ProMViewType vt = (ProMViewType) o;
			return vt.binding.equals(binding);
		}
		return false;
	}

	public int hashCode() {
		return binding.hashCode();
	}

	public Class<?> getPrimaryType() {
		PluginParameterBinding pluginMethod = binding.getSecond();
		PluginDescriptor plugin = pluginMethod.getPlugin();
		return plugin.getPluginParameterType(pluginMethod.getMethodIndex(), 0);
	}
}
"
PMController.java,context,"package org.processmining.contexts.uitopia.packagemanager;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.List;
import java.util.Set;
import java.util.prefs.BackingStoreException;

import org.processmining.framework.boot.Boot;
import org.processmining.framework.packages.PackageDescriptor;
import org.processmining.framework.packages.PackageManager;
import org.processmining.framework.packages.UnknownPackageTypeException;
import org.processmining.framework.packages.impl.CancelledException;

public class PMController {

	private final PMMainView mainView;
	private final PackageManager manager;
	private String query;

	public PMController(Boot.Level verbose) {
		manager = PackageManager.getInstance();
		manager.initialize(verbose);
		try {
			manager.update(false, verbose);
		} catch (CancelledException e) {
			e.printStackTrace();
		} catch (UnknownPackageTypeException e) {
			e.printStackTrace();
		}

		mainView = new PMMainView(this);
	}
	
	public void cleanPackageCache() throws BackingStoreException {
		manager.cleanPackageCache();
	}

	/**
	 * Select a package, select the right tab and return the selected PMPackage
	 * 
	 * @param packageName
	 * @return null if no package with such name exists.
	 */
	public PMPackage selectPackage(String packageName) {
		Set<PackageDescriptor> available = manager.getAvailablePackages();
		for (PackageDescriptor d : available) {
			if (d.getName().equals(packageName)) {
				// package descriptor d is available
				PMPackage pack = new PMPackage(d);
				setStatus(pack, d);
				mainView.showWorkspaceView(pack);
				return pack;
			}
		}
		return null;
	}

	public PMMainView getMainView() {
		return mainView;
	}

	public java.util.List<PMPackage> getToUninstallPackages() {
		Set<PackageDescriptor> descriptors = manager.getAvailablePackages();
		java.util.List<PMPackage> list = new ArrayList<PMPackage>();
		for (PackageDescriptor descriptor : descriptors) {
			PMPackage pack = new PMPackage(descriptor);
			PackageDescriptor installed = manager.findInstalledVersion(descriptor);
			if ((installed != null) && installed.equals(descriptor)) {
				list.add(pack);
				setStatus(pack, descriptor);
			}
		}
		return list;
	}

	public java.util.List<? extends PMPackage> getToUpdatePackages() {
		Set<PackageDescriptor> descriptors = manager.getAvailablePackages();
		java.util.List<PMPackage> list = new ArrayList<PMPackage>();
		for (PackageDescriptor available : descriptors) {
			PMPackage pack = new PMPackage(available);
			PackageDescriptor installed = manager.findInstalledVersion(available);
			if ((installed != null && manager.isAvailable(available)) && //
					installed.getVersion().lessThan(available.getVersion())) {
				list.add(pack);
				setStatus(pack, available);
			}
		}
		return list;
	}

	public java.util.List<? extends PMPackage> getToInstallPackages() {
		Set<PackageDescriptor> descriptors = manager.getAvailablePackages();
		java.util.List<PMPackage> list = new ArrayList<PMPackage>();
		for (PackageDescriptor descriptor : descriptors) {
			PMPackage pack = new PMPackage(descriptor);
			PackageDescriptor installed = manager.findInstalledVersion(descriptor);
			if (installed == null && manager.isAvailable(descriptor)) {
				list.add(pack);
				setStatus(pack, descriptor);
			}
		}
		return list;
	}

	public java.util.List<PMPackage> getParentPackages(PMPackage reference) {
		Set<PackageDescriptor> descriptors = manager.getAvailablePackages();
		java.util.List<PMPackage> list = new ArrayList<PMPackage>();
		for (PackageDescriptor descriptor : descriptors) {
			if (reference.getDependencies().contains(descriptor.getName())) {
				PMPackage pack = new PMPackage(descriptor);
				list.add(pack);
				setStatus(pack, descriptor);
			}
		}
		return list;
	}

	public java.util.List<PMPackage> getChildPackages(PMPackage reference) {
		Set<PackageDescriptor> descriptors = manager.getAvailablePackages();
		java.util.List<PMPackage> list = new ArrayList<PMPackage>();
		for (PackageDescriptor descriptor : descriptors) {
			if (descriptor.getDependencies().contains(reference.getPackageName())) {
				PMPackage pack = new PMPackage(descriptor);
				list.add(pack);
				setStatus(pack, descriptor);
			}
		}
		return list;
	}

	public void setStatus(PMPackage pack, PackageDescriptor descriptor) {
		PackageDescriptor installed = manager.findInstalledVersion(descriptor);
		if (installed != null) {
			if (manager.isAvailable(descriptor) && !installed.equals(descriptor)) {
				pack.setStatus(PMPackage.PMStatus.TOUPDATE);
			} else {
				pack.setStatus(PMPackage.PMStatus.TOUNINSTALL);
			}
		} else {
			if (manager.isAvailable(descriptor)) {
				pack.setStatus(PMPackage.PMStatus.TOINSTALL);
			} else {
				pack.setStatus(PMPackage.PMStatus.DEAD);
			}
		}
	}

	public void update(final PMPackage pack, final PMWorkspaceView view) {
		Thread t = new Thread(new Runnable() {

			public void run() {
				try {
					manager.install(Arrays.asList(new PackageDescriptor[] { pack.getDescriptor() }));
					view.updatePackages();
				} catch (CancelledException e) {
					e.printStackTrace();
				} catch (UnknownPackageTypeException e) {
					e.printStackTrace();
				}
			}

		});
		t.start();
	}

	public void update(final Collection<PMPackage> packs, final PMWorkspaceView view) {
		Thread t = new Thread(new Runnable() {

			public void run() {
				try {
					List<PackageDescriptor> pds = new ArrayList<PackageDescriptor>();
					for (PMPackage p : packs) {
						pds.add(p.getDescriptor());
					}
					manager.install(pds);
					view.updatePackages();
				} catch (CancelledException e) {
					e.printStackTrace();
				} catch (UnknownPackageTypeException e) {
					e.printStackTrace();
				}
			}

		});
		t.start();
	}

	public void remove(final PMPackage pack, final PMWorkspaceView view) {
		Thread t = new Thread(new Runnable() {

			public void run() {
				try {
					manager.uninstall(Arrays.asList(new PackageDescriptor[] { pack.getDescriptor() }));
					view.updatePackages();
				} catch (CancelledException e) {
					e.printStackTrace();
				}
			}

		});
		t.start();
	}

	public void remove(final Collection<PMPackage> packs, final PMWorkspaceView view) {
		Thread t = new Thread(new Runnable() {

			public void run() {
				try {
					List<PackageDescriptor> pds = new ArrayList<PackageDescriptor>();
					for (PMPackage p : packs) {
						pds.add(p.getDescriptor());
					}
					manager.uninstall(pds);
					view.updatePackages();
				} catch (CancelledException e) {
					e.printStackTrace();
				}
			}

		});
		t.start();
	}

	public String getQuery() {
		return query == null ? """" : query;
	}

	public void setQuery(String query) {
		this.query = query;
	}
}
"
PMFrame.java,context,"package org.processmining.contexts.uitopia.packagemanager;

import java.awt.BorderLayout;
import java.awt.Point;
import java.awt.Toolkit;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.io.IOException;

import javax.swing.JFrame;
import javax.swing.WindowConstants;

import org.deckfour.uitopia.ui.conf.ConfigurationSet;
import org.deckfour.uitopia.ui.conf.UIConfiguration;
import org.deckfour.uitopia.ui.util.ImageLoader;
import org.processmining.framework.boot.Boot;
import org.processmining.framework.plugin.annotations.Bootable;
import org.processmining.framework.util.CommandLineArgumentList;

public class PMFrame extends JFrame {

	private static final long serialVersionUID = 3000058846006966241L;

	private static final String CONF_X = ""window_x"";
	private static final String CONF_Y = ""window_y"";
	private static final String CONF_WIDTH = ""window_width"";
	private static final String CONF_HEIGHT = ""window_height"";

	private final ConfigurationSet conf;

	private final PMController controller;

	public PMFrame() {
		controller = new PMController(Boot.VERBOSE);

		// register closing action..
		setDefaultCloseOperation(WindowConstants.DO_NOTHING_ON_CLOSE);
		addWindowListener(new WindowAdapter() {
			public void windowClosing(WindowEvent e) {
				exitApplication(true);
			}

			public void windowClosed(WindowEvent e) {
				windowClosing(e);
			}
		});
		addComponentListener(new ComponentAdapter() {
			public void componentMoved(ComponentEvent e) {
				saveWindowState();
			}

			public void componentResized(ComponentEvent e) {
				saveWindowState();
			}
		});
		// restore window position and size
		conf = UIConfiguration.master().getChild(this.getClass().getCanonicalName());
		restoreWindowState();
		// set up window contents
		setLayout(new BorderLayout());
		this.add(controller.getMainView(), BorderLayout.CENTER);
		setTitle(""ProM UITopia Package Manager"");
		// show frame
	}

	protected void saveWindowState() {
		Point p = getLocation();
		conf.setInteger(CONF_X, p.x);
		conf.setInteger(CONF_Y, p.y);
		conf.setInteger(CONF_WIDTH, getWidth());
		conf.setInteger(CONF_HEIGHT, getHeight());
	}

	protected void restoreWindowState() {
		int x = conf.getInteger(CONF_X, 10);
		int y = conf.getInteger(CONF_Y, 10);
		int width = conf.getInteger(CONF_WIDTH, 1024);
		int height = conf.getInteger(CONF_HEIGHT, 750);
		x = Math.max(0, x);
		y = Math.max(0, y);
		width = Math.min(width, Toolkit.getDefaultToolkit().getScreenSize().width);
		height = Math.min(height, Toolkit.getDefaultToolkit().getScreenSize().height);
		this.setLocation(x, y);
		this.setSize(width, height);
	}

	protected void exitApplication(boolean askUser) {
		saveConfig();
		System.exit(0);
	}

	public void saveConfig() {
		try {
			UIConfiguration.save();
		} catch (IOException e) {
			System.err.println(""ERROR: Could not save UITopia configuration!"");
			e.printStackTrace();
		}
	}

	@Bootable
	public Object main(CommandLineArgumentList args) {
		return this;
	}

	public static void main(String[] args) throws Exception {
		PMFrame frame = (PMFrame) Boot.boot(PMFrame.class, args);
		frame.setIconImage(ImageLoader.load(""prom_icon_32x32.png""));
		frame.setVisible(true);
	}

	public PMController getController() {
		return controller;
	}
}
"
PMIconCache.java,context,"package org.processmining.contexts.uitopia.packagemanager;

import java.awt.Image;
import java.net.MalformedURLException;
import java.net.URL;
import java.util.HashMap;
import java.util.Map;

import javax.swing.ImageIcon;

import org.processmining.framework.packages.PackageDescriptor;

public class PMIconCache {

	/*
	 * Cache the retrieved icons. Prevents unnecessary access over the network.
	 */
	private static Map<String, ImageIcon> iconMap = new HashMap<String, ImageIcon>();
	private static Map<String, ImageIcon> iconPreviewMap = new HashMap<String, ImageIcon>();

	public static ImageIcon getIcon(PackageDescriptor pack) {
		synchronized (iconMap) {
			/*
			 * Check whether icon already in cache
			 */
			if (iconMap.containsKey(pack.getLogoURL())) {
				/*
				 * Yes, it is. Return cached icon.
				 */
				return iconMap.get(pack.getLogoURL());
			}
			/*
			 * No, it is not. Retrieve icon and put in cache.
			 */
			System.out.println(""[PMIconCache] Retrieving icon for URL "" + pack.getLogoURL());
			ImageIcon icon = null;
			try {
				URL logoURL = new URL(pack.getLogoURL());
				icon = new ImageIcon(logoURL);
			} catch (MalformedURLException e) {
				System.err.println(""[PMIconCache] Retrieving icon for URL "" + pack.getLogoURL() + "" failed: ""
						+ e.getMessage());
			}
			iconMap.put(pack.getLogoURL(), icon);
			return icon;
		}
	}

	public static ImageIcon getIcon(PMPackage pack) throws MalformedURLException {
		return getIcon(pack.getDescriptor());
	}

	public static ImageIcon getIconPreview(PackageDescriptor pack) {
		synchronized (iconPreviewMap) {
			/*
			 * Check whether icon preview already in cache
			 */
			ImageIcon icon = iconPreviewMap.get(pack.getLogoURL());
			if (icon != null) {
				/*
				 * Yes, it is. Return cached icon preview.
				 */
				return icon;
			}
			/*
			 * No, it is not. Get icon preview and put in cache.
			 */
			Image image = getPreview(getIcon(pack), 150, 150);
			if (image != null) {
				icon = new ImageIcon(image);
				iconPreviewMap.put(pack.getLogoURL(), icon);
			}
			return icon;
		}
	}

	public static ImageIcon getIconPreview(PMPackage pack) {
		return getIconPreview(pack.getDescriptor());
	}

	public static Image getPreview(ImageIcon icon, int w, int h) {
		if (icon != null) {
			Image img = icon.getImage();
			int width = icon.getIconWidth();
			int height = icon.getIconHeight();
			float xScale = w / (float) width;
			float yScale = h / (float) height;
			float scale = (xScale < yScale ? xScale : yScale);
			return img.getScaledInstance((int) (width * scale), (int) (height * scale), Image.SCALE_SMOOTH);
		}
		return null;
	}
}
"
PMListener.java,context,"package org.processmining.contexts.uitopia.packagemanager;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.net.MalformedURLException;
import java.net.URL;
import java.util.zip.ZipException;

import javax.xml.parsers.ParserConfigurationException;

import org.deckfour.uitopia.ui.main.Overlayable;
import org.processmining.framework.packages.PackageDescriptor;
import org.processmining.framework.packages.PackageManager;
import org.processmining.framework.packages.UnknownPackageException;
import org.processmining.framework.packages.events.PackageManagerListener;
import org.processmining.framework.packages.impl.CancelledException;
import org.xml.sax.SAXException;

public class PMListener implements PackageManagerListener {

	private final Overlayable overlayable;

	public PMListener(Overlayable overlayable) {
		this.overlayable = overlayable;

	}

	private PMOverlay pmOverlay;

	public synchronized void exception(Throwable t) {
		if (t instanceof IOException) {
			exception(""I/O Exception: "" + t, true);
		} else if (t instanceof SAXException) {
			exception(""SAX Exception: "" + t, true);
		} else if (t instanceof ParserConfigurationException) {
			exception(""Parser Configuration Exception: "" + t, true);
		} else if (t instanceof UnknownPackageException) {
			exception(""Unknown Package Exception: "" + t, true);
		} else if (t instanceof MalformedURLException) {
			exception(""Malformed URL Exception: "" + t, true);
		} else if (t instanceof FileNotFoundException) {
			exception(""File Not Found Exception: "" + t, true);
		} else if (t instanceof CancelledException) {
			exception(""Cancelled Exception: "" + t, true);
		} else if (t instanceof SecurityException) {
			exception(""Security Exception: "" + t, true);
		} else if (t instanceof ZipException) {
			exception(""ZIP Exception: "" + t, true);
		} else {
			exception(t.getMessage());
		}
	}

	public synchronized void exception(String exception) {
		exception(exception, false);
	}

	private void exception(String exception, boolean hasPrefix) {
		pmOverlay.addText((hasPrefix ? """" : ""Error: "") + exception);	
	}
	
	public synchronized void startDownload(String packageName, URL url, PackageDescriptor pack) {
		pmOverlay.setPackage(pack);
		pmOverlay.addText(""Downloading: "" + packageName);
	}

	public synchronized void startInstall(String packageName, File folder, PackageDescriptor pack) {
		pmOverlay.setPackage(pack);
		pmOverlay.addText(""Installing: "" + packageName);
	}

	public synchronized void sessionComplete(boolean error) {
		PackageManager.getInstance().setCanceller(null);
		pmOverlay.finishedInstall(error);
		pmOverlay.getResultBlocking();
	}

	public synchronized void sessionStart() {
		pmOverlay = new PMOverlay(overlayable);
		PackageManager.getInstance().setCanceller(pmOverlay);
		pmOverlay.addText(""Started package manager session"");
		overlayable.showOverlay(pmOverlay);

	}

	public synchronized void finishedInstall(String packageName, File folder, PackageDescriptor pack) {
		pmOverlay.addText(""Succesfully installed: "" + packageName);
	}
}
"
PMMainView.java,context,"package org.processmining.contexts.uitopia.packagemanager;

import java.awt.BorderLayout;
import java.awt.Color;

import javax.swing.BorderFactory;
import javax.swing.JComponent;
import javax.swing.JPanel;
import javax.swing.SwingUtilities;

import org.deckfour.uitopia.ui.conf.ConfigurationSet;
import org.deckfour.uitopia.ui.conf.UIConfiguration;
import org.deckfour.uitopia.ui.main.MainViewport;
import org.deckfour.uitopia.ui.main.Overlayable;
import org.deckfour.uitopia.ui.main.Viewable;
import org.deckfour.uitopia.ui.overlay.OverlayEnclosure;
import org.deckfour.uitopia.ui.overlay.TwoButtonOverlayDialog;
import org.processmining.framework.packages.PackageManager;

public class PMMainView extends JPanel implements Overlayable {

	private static final long serialVersionUID = -3555712585055859714L;

	public enum View {

		WORKSPACE();

		private Viewable viewable;

		public Viewable getViewable() {
			return viewable;
		}

		public void setViewable(Viewable viewable) {
			this.viewable = viewable;
		}

	}

	private final PMController controller;

	private final ConfigurationSet conf;
	//	private MainToolbar toolbar;
	private final MainViewport viewport;

	private View activeView;
	private final PMWorkspaceView workspaceView;

	private OverlayEnclosure overlay;
	private final PMListener listener;

	public PMMainView(PMController controller) {
		this.controller = controller;
		setOpaque(false);
		setBorder(BorderFactory.createEmptyBorder());
		setLayout(new BorderLayout());
		viewport = new MainViewport();
		//		toolbar = new MainToolbar(this);
		//		this.add(toolbar, BorderLayout.NORTH);
		this.add(viewport, BorderLayout.CENTER);
		JPanel blankView = new JPanel();
		blankView.setBackground(new Color(50, 50, 50));
		show(blankView);
		workspaceView = new PMWorkspaceView(controller);
		View.WORKSPACE.setViewable(workspaceView);
		conf = UIConfiguration.master().getChild(this.getClass().getCanonicalName());
		activeView = View.valueOf(conf.get(""activeView"", ""WORKSPACE""));
		showView(activeView);

		listener = new PMListener(this);
		PackageManager.getInstance().addListener(listener);
	}

	public PMController controller() {
		return controller;
	}

	public PMWorkspaceView getWorkspaceView() {
		return workspaceView;
	}

	public void showWorkspaceView() {
		if (!activeView.equals(View.WORKSPACE)) {
			showView(View.WORKSPACE);
		}
	}

	public void showWorkspaceView(PMPackage selected) {
		workspaceView.showPackage(selected);
		showWorkspaceView();
	}

	protected void showView(View view) {
		if (activeView.getViewable() != view.getViewable()) {
			activeView.getViewable().viewFocusLost();
		}
		if (view.equals(View.WORKSPACE)) {
			show(workspaceView);
		}
		conf.set(""activeView"", view.name());
		if (activeView.getViewable() != view.getViewable()) {
			view.getViewable().viewFocusGained();
		}
		activeView = view;
		//		toolbar.activateTab(view);
	}

	public void show(JComponent view) {
		viewport.setView(view);
	}

	public void showOverlay(JComponent overlay) {
		final OverlayEnclosure enclosure = new OverlayEnclosure(overlay, 1024, 768);
		SwingUtilities.invokeLater(new Runnable() {
			public void run() {
				//				toolbar.setEnabled(false);
				viewport.showOverlay(enclosure);
			}
		});
		this.overlay = enclosure;
	}

	public boolean showOverlayDialog(TwoButtonOverlayDialog dialog) {
		//		dialog.setMainView(this);
		//		showOverlay(dialog);
		//		return dialog.getResultBlocking();
		return true;
	}

	public void hideOverlay() {
		//		toolbar.setEnabled(true);
		viewport.hideOverlay();
	}

	public boolean hideOverlay(JComponent overlay) {
		if ((this.overlay != null) && (this.overlay.getEnclosed() == overlay)) {
			hideOverlay();
			return true;
		} else {
			return false;
		}
	}

}
"
PMMemoryView.java,context,"package org.processmining.contexts.uitopia.packagemanager;

import info.clearthought.layout.TableLayout;
import info.clearthought.layout.TableLayoutConstants;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.prefs.BackingStoreException;
import java.util.prefs.Preferences;

import javax.swing.BoxLayout;
import javax.swing.JButton;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JPanel;

import org.deckfour.uitopia.ui.components.ImageLozengeButton;
import org.deckfour.uitopia.ui.util.ImageLoader;
import org.processmining.framework.boot.Boot;
import org.processmining.framework.util.OsUtil;

import com.fluxicon.slickerbox.components.RoundedPanel;

public class PMMemoryView extends RoundedPanel implements ActionListener {

	/**
	 * 
	 */
	private static final long serialVersionUID = 2483996283422006055L;

	/*
	 * Get whether we are running in 64 bit mode, this allows allocating more
	 * than 1300 MB of memory.
	 */
	private static boolean is64bit = OsUtil.is64Bit();
	/*
	 * Get the available memory.
	 */
	private static long mem = OsUtil.getPhysicalMemory() / (1024 * 1024);

	/*
	 * Start with using 1 GB of memory.
	 */
	private static MemoryOption selectedMem = MemoryOption.XMX1G;
	private static MemoryOption oldSelectedMem = MemoryOption.XMX1G;

	private PMController controller;

	private enum MemoryOption implements ActionListener {
		XMX1G(""1G"", true), // 1 GB
		XMX1300M(""1300M"", true), // 1300 MB, about the limit in 32 bit mode
		XMX2G(""2G"", is64bit && mem >= 2 * 1024), // 2 GB
		XMX3G(""3G"", is64bit && mem >= 3 * 1024), // 3 GB
		XMX4G(""4G"", is64bit && mem >= 4 * 1024), // 4 GB
		XMX6G(""6G"", is64bit && mem >= 6 * 1024), // 6 GB
		XMX8G(""8G"", is64bit && mem >= 8 * 1024), // 8 GB
		XMX12G(""12G"", is64bit && mem >= 12 * 1024), // 12 GB
		XMX16G(""16G"", is64bit && mem >= 16 * 1024); // 16 GB

		/*
		 * Text to be added to ""-Xmx""
		 */
		private String size;
		/*
		 * Whether this memory option is available on this computer.
		 */
		private boolean isAvailable;
		/*
		 * Button to show when this option is selected.
		 */
		private ImageLozengeButton selected;
		/*
		 * Button to show when this option is not selected.
		 */
		private ImageLozengeButton notSelected;

		/*
		 * Creates a memory option.
		 */
		private MemoryOption(String size, boolean isAllowed) {
			this.size = size;
			this.isAvailable = isAllowed;
		}

		/*
		 * Returns the string to add to ""-Xmx"".
		 */
		public String toString() {
			return size;
		}

		/*
		 * Returns the string to put on the buttons.
		 */
		public String toDisplay() {
			return size.replace(""G"", "" GB"").replace(""M"", "" MB"");
		}

		/*
		 * Returns whether this option is available.
		 */
		public boolean isAvailable() {
			return isAvailable;
		}

		/*
		 * Returns the current shown button.
		 */
		public JButton getButton(boolean isSelected) {
			return isSelected ? selected : notSelected;
		}

		/*
		 * Initialize this memory option. Creates the buttons, sets the tool
		 * tip, and the action listener.
		 */
		public void init(ActionListener actionListener) {
			selected = new ImageLozengeButton(ImageLoader.load(""remove_30x30_black.png""), toDisplay());
			selected.setEnabled(false);
			notSelected = new ImageLozengeButton(ImageLoader.load(""action_30x30_black.png""), toDisplay());
			notSelected.setToolTipText(""Use "" + toDisplay() + "" of memory when running ProM"");
			notSelected.addActionListener(actionListener);
		}

		/*
		 * Act on a button being selected.
		 * 
		 * @see
		 * java.awt.event.ActionListener#actionPerformed(java.awt.event.ActionEvent
		 * )
		 */
		public void actionPerformed(ActionEvent e) {
			/*
			 * Check whether my button was selected.
			 */
			if (e.getSource() == notSelected) {
				/*
				 * Yes, it was. Set my memory size.
				 */
				selectedMem = this;
			}
		}
	};

	/*
	 * Creates the memory view panel.
	 */
	public PMMemoryView(PMController controller) {
		super(20, 5, 0);
		this.controller = controller;
		setBackground(new Color(160, 160, 160));
		setLayout(new BorderLayout());
		try {
			/*
			 * Try to read the current memory option from file, and set the
			 * default accordingly.
			 */
			String version = Boot.PROM_VERSION.replaceAll(""\\."", """");
			FileReader reader = new FileReader(""ProM"" + version + "".l4j.ini"");
			char[] a = new char[10];
			reader.read(a);
			reader.close();
			String b = String.valueOf(a);
			for (MemoryOption size : MemoryOption.values()) {
				if (b.startsWith(""-Xmx"" + size)) {
					/*
					 * Found a match. Set this option as default.
					 */
					selectedMem = size;
					continue;
				}
			}
		} catch (FileNotFoundException e) {
		} catch (IOException e) {
		}
		setupUI();
		update();
	}

	/*
	 * Sets up the buttons.
	 */
	private void setupUI() {
		/*
		 * Initialize all buttons.
		 */
		for (MemoryOption size : MemoryOption.values()) {
			size.init(this);
		}
	}

	/*
	 * A button was pressed. Check every option, and then update.
	 */
	public void actionPerformed(ActionEvent e) {
		for (MemoryOption size : MemoryOption.values()) {
			/*
			 * Check whether the button belongs to this option.
			 */
			size.actionPerformed(e);
		}
		update();
	}

	/*
	 * Update the memory view.
	 */
	private void update() {
		updateFiles();
		double layoutSize[][] = { { TableLayoutConstants.FILL, TableLayoutConstants.FILL, TableLayoutConstants.FILL, TableLayoutConstants.FILL }, { 30, TableLayoutConstants.FILL } };
		setLayout(new TableLayout(layoutSize));
		
		/*
		 * Create new buttonPanel.
		 */
		JPanel buttonPanel = new RoundedPanel(20, 5, 0);
		buttonPanel.setBackground(new Color(80, 80, 80));
		buttonPanel.setLayout(new BoxLayout(buttonPanel, BoxLayout.X_AXIS));

		for (MemoryOption size : MemoryOption.values()) {
			/*
			 * Only add button if available.
			 */
			if (size.isAvailable()) {
				/*
				 * Use selected button if selected, not-selected button
				 * otherwise.
				 */
				buttonPanel.add(size.getButton(selectedMem == size));
			}
		}
		/*
		 * Refresh with new button panel.
		 */
		removeAll();
		add(new JLabel(""Manage memory setting""), ""0, 0, 1, 0"");
		add(buttonPanel, ""0, 1, 1, 1"");

		JPanel gaButtonPanel = new RoundedPanel(20, 5, 0);
		gaButtonPanel.setBackground(new Color(80, 80, 80));
		gaButtonPanel.setLayout(new BoxLayout(gaButtonPanel, BoxLayout.X_AXIS));

		final ImageLozengeButton enableGAButton = new ImageLozengeButton(ImageLoader.load(""action_30x30_black.png""), ""Enable"");
		final ImageLozengeButton disableGAButton = new ImageLozengeButton(ImageLoader.load(""remove_30x30_black.png""), ""Disable"");
		if (Preferences.userNodeForPackage(Boot.class).get(Boot.TRACKING_BY_GA_ALLOWED, ""false"").equals(""true"")) {
			enableGAButton.setEnabled(false);
			disableGAButton.setEnabled(true);
		} else {
			enableGAButton.setEnabled(true);
			disableGAButton.setEnabled(false);
		}
		enableGAButton.setToolTipText(""Select this button to enable tracking with GA"");
		disableGAButton.setToolTipText(""Select this button to disable tracking with GA"");
		enableGAButton.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				Preferences.userNodeForPackage(Boot.class).put(Boot.TRACKING_BY_GA_ALLOWED, ""true"");
				enableGAButton.setEnabled(false);
				disableGAButton.setEnabled(true);
			}			
		});
		disableGAButton.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				Preferences.userNodeForPackage(Boot.class).put(Boot.TRACKING_BY_GA_ALLOWED, ""false"");
				enableGAButton.setEnabled(true);
				disableGAButton.setEnabled(false);
			}			
		});
		gaButtonPanel.add(enableGAButton);
		gaButtonPanel.add(disableGAButton);
		add(new JLabel(""Manage Google Analytics (GA) setting""), ""2, 0"");
		add(gaButtonPanel, ""2, 1"");
		
		JPanel cacheButtonPanel = new RoundedPanel(20, 5, 0);
		cacheButtonPanel.setBackground(new Color(80, 80, 80));
		cacheButtonPanel.setLayout(new BoxLayout(cacheButtonPanel, BoxLayout.X_AXIS));

		ImageLozengeButton cleanCacheButton = new ImageLozengeButton(ImageLoader.load(""remove_30x30_black.png""),
				""Clear"", new Color(140, 140, 140), new Color(40, 140, 40), 2);
		cleanCacheButton.setToolTipText(PMTooltips.REMOVEBUTTON);
		cleanCacheButton.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				cleanCache();
			}
		});

		cacheButtonPanel.add(cleanCacheButton);
		add(new JLabel(""Manage Plugin Cache""), ""3, 0"");
		add(cacheButtonPanel, ""3, 1"");

		revalidate();
	}

	protected void cleanCache() {
		try {
			controller.cleanPackageCache();
		} catch (BackingStoreException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

	/*
	 * Updates the necessary files with the new memory option.
	 */
	private void updateFiles() {
		if (oldSelectedMem == selectedMem) {
			return;
		}
		String version = Boot.PROM_VERSION.replaceAll(""\\."", """");
		if (OsUtil.isRunningWindows()) {
			/*
			 * Windows. Need to update ini file and bat file.
			 */
			if (!updateIniFile() || !updateBatFile()) {
				/*
				 * Something failed. Possibly, the PM was not run in
				 * Administrator mode.
				 */
				JOptionPane
						.showMessageDialog(
								null,
								""Unable to set memory limit (-Xmx""
										+ selectedMem
										+ "") in ProM""
										+ version
										+ "".l4j.ini and/or ProM""
										+ version
										+ "".bat file.\nPlease run the Package Manager as administrator, or set the memory limit manually."");
				selectedMem = oldSelectedMem;
				return;
			}
		} else if (OsUtil.isRunningLinux() || OsUtil.isRunningUnix()) {
			/*
			 * Linux or UNIX. Need to update sh file (and init file for reading
			 * default option next time).
			 */
			if (!updateIniFile() || !updateShFile()) {
				JOptionPane.showMessageDialog(null, ""Unable to set memory limit (-Xmx"" + selectedMem + "") in ProM""
						+ version + "".l4j.ini and/or ProM"" + version
						+ "".sh file.\nPlease set the memory limit manually."");
				selectedMem = oldSelectedMem;
				return;
			}
		}
		/*
		 * No MAC support (yet), sorry.
		 */
		oldSelectedMem = selectedMem;
	}

	private boolean updateFile(String ext) {
		try {
			String version = Boot.PROM_VERSION.replaceAll(""\\."", """");
			Path path = Paths.get(""ProM"" + version + ext);
			Charset charset = StandardCharsets.UTF_8;
			String content = new String(Files.readAllBytes(path), charset);
			String oldMem = ""-Xmx"" + oldSelectedMem;
			String newMem = ""-Xmx"" + selectedMem;
			content = content.replaceAll(oldMem, newMem);
			Files.write(path, content.getBytes(charset));
			return true;
		} catch (FileNotFoundException e) {
			return false;
		} catch (UnsupportedEncodingException e) {
			return false;
		} catch (IOException e) {
			return false;
		}
	}

	private boolean updateIniFile() {
		return updateFile("".l4j.ini"");
	}

	private boolean updateBatFile() {
		return updateFile("".bat"");
	}

	private boolean updateShFile() {
		return updateFile("".sh"");
	}

}
"
PMOverlay.java,context,"package org.processmining.contexts.uitopia.packagemanager;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Image;
import java.util.Timer;
import java.util.TimerTask;

import javax.swing.BorderFactory;
import javax.swing.ImageIcon;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JTextArea;
import javax.swing.ScrollPaneConstants;

import org.deckfour.uitopia.ui.main.Overlayable;
import org.deckfour.uitopia.ui.overlay.TwoButtonOverlayDialog;
import org.processmining.framework.packages.PackageDescriptor;
import org.processmining.framework.packages.PackageManager;

import com.fluxicon.slickerbox.factory.SlickerDecorator;

public class PMOverlay extends TwoButtonOverlayDialog implements PackageManager.Canceller {

	/**
	 * Timeout in seconds after which dialog disappears
	 */
	private final static int TIMEOUT = 10;

	private static final long serialVersionUID = 4721480656622194553L;
	private final JTextArea log;
	private final JLabel label = new JLabel("""");
	private final JLabel iconLabel = new JLabel("""");
	private boolean cancelled;

	public PMOverlay(Overlayable view) {
		super(view, ""External Packages Required"", ""Cancel"", ""  OK  "", null);

		JPanel mainPanel = new JPanel(new BorderLayout());
		mainPanel.setOpaque(false);
		mainPanel.setLayout(new BorderLayout());
		mainPanel.setBorder(BorderFactory.createEmptyBorder(30, 30, 30, 30));

		label.setBorder(BorderFactory.createEmptyBorder(5, 5, 5, 5));
		iconLabel.setBorder(BorderFactory.createEmptyBorder(5, 5, 5, 5));

		log = new JTextArea();
		log.setOpaque(false);
		log.setBorder(BorderFactory.createEmptyBorder());
		log.setLineWrap(true);
		log.setWrapStyleWord(true);

		JScrollPane scrollpane = new JScrollPane(log);
		scrollpane.setOpaque(false);
		scrollpane.getViewport().setOpaque(false);
		scrollpane.setBorder(BorderFactory.createEmptyBorder());
		scrollpane.setViewportBorder(BorderFactory.createEmptyBorder());
		scrollpane.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);
		scrollpane.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_AS_NEEDED);
		SlickerDecorator.instance().decorate(scrollpane.getVerticalScrollBar(), new Color(0, 0, 0, 0),
				new Color(20, 20, 20), new Color(60, 60, 60));
		scrollpane.getVerticalScrollBar().setOpaque(false);

		scrollpane.setPreferredSize(new Dimension(800, 100));
		scrollpane.setMinimumSize(new Dimension(0, 100));
		scrollpane.setSize(new Dimension(800, 100));

		JPanel southPanel = new JPanel(new BorderLayout());
		southPanel.setOpaque(false);
		southPanel.setBorder(BorderFactory.createEmptyBorder());

		//		JCheckBox check = new JCheckBox(
		//				""Automatically install new versions of packages (requires an internet connection (xx))"");
		//		check.setOpaque(false);
		//		check.setSelected(PackageManager.getInstance().doAutoUpdate());
		//		check.addItemListener(new ItemListener() {
		//
		//			public void itemStateChanged(ItemEvent e) {
		//				if (e.getStateChange() == ItemEvent.DESELECTED) {
		//					PackageManager.getInstance().setAutoUpdate(false);
		//				} else if (e.getStateChange() == ItemEvent.SELECTED) {
		//					PackageManager.getInstance().setAutoUpdate(true);
		//				}
		//			}
		//		});

		southPanel.add(scrollpane, BorderLayout.CENTER);
		//		southPanel.add(check, BorderLayout.SOUTH);

		mainPanel.add(label, BorderLayout.CENTER);
		mainPanel.add(southPanel, BorderLayout.SOUTH);
		mainPanel.add(iconLabel, BorderLayout.EAST);

		setPayload(mainPanel);
		cancelled = false;
		getCancelButton().setEnabled(true);
		getOKButton().setEnabled(false);
	}

	public void setPackage(PackageDescriptor pack) {
		label.setText(pack.toHTML());
		ImageIcon icon = PMIconCache.getIcon(pack);
		if (icon != null) {
			Image img = icon.getImage();
			int m = icon.getIconHeight() > icon.getIconWidth() ? 200 : -200;
			iconLabel.setIcon(new ImageIcon(img.getScaledInstance(-m, m, Image.SCALE_SMOOTH)));
		} else {
			iconLabel.setIcon(null);
			return;
		}
	}

	public void addText(String text) {
		log.append(text);
		log.append(""\n"");
		log.setCaretPosition(log.getText().length());
	}

	public void clear() {
		log.setText("""");
	}

	public void finishedInstall(boolean error) {
		getOKButton().setEnabled(true);
		getCancelButton().setEnabled(false);
		if (error) {
			// HV: Do not auto-close on an error, as the error message will get lost.
			// Wait for the user to close the overlay.
			//close(true);

			// Indicate that an error has occurred.
			addText(""An error has occurred. Please select OK to continue."");
			log.setForeground(new Color(90, 0, 0));
		} else {
			final String message = ""Closing in "" + TIMEOUT + "" seconds."";
			log.append(message);
			final Timer t = new Timer();
			t.schedule(new TimerTask() {

				private int remaining = TIMEOUT - 1;
				private int lastlength = message.length();

				public void run() {
					if (remaining == 0) {
						cancel();
						return;
					}
					String s = ""Closing in "" + (remaining--) + "" seconds."";
					int l = log.getText().length();
					log.replaceRange(s, l - lastlength, l);
					lastlength = s.length();
				}

			}, 1000L, 1000L);
			t.schedule(new TimerTask() {

				public void run() {
					close(true);
				}

			}, 1000L * TIMEOUT);
		}

	}

	public boolean isCancelled() {
		return cancelled;
	}

	@Override
	public void close(boolean okayed) {
		if (!okayed) {
			cancelled = true;
		}
		super.close(okayed);
	}

}
"
PMPackage.java,context,"package org.processmining.contexts.uitopia.packagemanager;

import java.util.Set;

import org.processmining.framework.packages.PackageDescriptor;

public class PMPackage {

	public static enum PMStatus {
		TOUNINSTALL, TOUPDATE, TOINSTALL, DEAD
	};

	private final PackageDescriptor descriptor;
	private boolean isFavorite;
	private PMStatus status;

	public PMPackage(PackageDescriptor descriptor) {
		this.descriptor = descriptor;
		isFavorite = false;
		status = PMStatus.TOINSTALL;
	}

	public PackageDescriptor getDescriptor() {
		return descriptor;
	}

	public PMStatus getStatus() {
		return status;
	}

	public void setStatus(PMStatus status) {
		this.status = status;
	}

	public Set<String> getDependencies() {
		return descriptor.getDependencies();
	}

	public String getPackageName() {
		return descriptor.getName();
	}

	public String getAuthorName() {
		return descriptor.getAuthor();
	}

	public String getDescription() {
		return descriptor.getDescription();
	}

	public String getVersion() {
		return ""Version "" + descriptor.getVersion();
	}

	public String getLicense() {
		return descriptor.getLicense();
	}
	
	public boolean isFavorite() {
		return isFavorite;
	}

	public void setFavorite(boolean f) {
		isFavorite = f;
	}

//	public Image getPreview(int w, int h) {
//		try {
//			ImageIcon icon = PMIconCache.getIcon(this);
//			Image img = icon.getImage();
//			int width = icon.getIconWidth();
//			int height = icon.getIconHeight();
//			float xScale = w / (float) width;
//			float yScale = h / (float) height;
//			float scale = (xScale < yScale ? xScale : yScale);
//			return img.getScaledInstance((int) (width * scale), (int) (height * scale), Image.SCALE_SMOOTH);
//		} catch (MalformedURLException e) {
//		}
//		return null;
//	}
//
	public boolean equals(Object o) {
		if (o instanceof PMPackage) {
			return ((PMPackage) o).descriptor.equals(descriptor);
		} else {
			return false;
		}
	}

	public int hashCode() {
		return descriptor.hashCode();
	}

}
"
PMPackageListBrowser.java,context,"package org.processmining.contexts.uitopia.packagemanager;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashSet;
import java.util.List;

import javax.swing.BorderFactory;
import javax.swing.Box;
import javax.swing.BoxLayout;
import javax.swing.ButtonGroup;
import javax.swing.JComponent;
import javax.swing.JLabel;
import javax.swing.JList;
import javax.swing.JPanel;
import javax.swing.JRadioButton;
import javax.swing.JScrollPane;
import javax.swing.ListSelectionModel;
import javax.swing.ScrollPaneConstants;
import javax.swing.SwingUtilities;
import javax.swing.event.ListSelectionEvent;
import javax.swing.event.ListSelectionListener;

import org.deckfour.uitopia.ui.components.ImageLozengeButton;
import org.deckfour.uitopia.ui.components.ImageRadioButton;
import org.deckfour.uitopia.ui.util.ArrangementHelper;
import org.deckfour.uitopia.ui.util.ImageLoader;
import org.processmining.framework.util.OsUtil;

import com.fluxicon.slickerbox.components.RoundedPanel;
import com.fluxicon.slickerbox.factory.SlickerDecorator;

public class PMPackageListBrowser extends JPanel {

	/**
	 * 
	 */
	private static final long serialVersionUID = 8111058383691281752L;

	public enum Type {
		TOUNINSTALL, TOUPDATE, TOINSTALL, SELECTION
	}

	private static final int VIEWPORT_WIDTH = 500;

	private final PMController controller;
	private List<? extends PMPackage> packages = new ArrayList<PMPackage>();

	private final Type type;

	private PMPackageListModel listModel;
	private JList<? extends PMPackage> packageList;
	private JComponent viewport;
	private JLabel header;

	private JRadioButton sortByPackageName;
	private JRadioButton sortByAuthorName;

	private PMPackageView pmPackageView = null;

	private boolean is64bit = OsUtil.is64Bit();
	private long mem = OsUtil.getPhysicalMemory() / (1024 * 1024);
	private int selectedMem = (is64bit ? 2 : 1);
	private int oldSelectedMem = 1;

	private RoundedPanel memPanel = new RoundedPanel(100, 0, 0);
	private ImageLozengeButton button1gbSelected = new ImageLozengeButton(ImageLoader.load(""remove_30x30_black.png""),
			""1 GB"");
	private ImageLozengeButton button2gbSelected = new ImageLozengeButton(ImageLoader.load(""remove_30x30_black.png""),
			""2 GB"");
	private ImageLozengeButton button4gbSelected = new ImageLozengeButton(ImageLoader.load(""remove_30x30_black.png""),
			""4 GB"");
	private ImageLozengeButton button8gbSelected = new ImageLozengeButton(ImageLoader.load(""remove_30x30_black.png""),
			""4 GB"");
	private ImageLozengeButton button16gbSelected = new ImageLozengeButton(ImageLoader.load(""remove_30x30_black.png""),
			""4 GB"");
	private ImageLozengeButton button1gbNotSelected = new ImageLozengeButton(
			ImageLoader.load(""action_30x30_black.png""), ""1 GB"");
	private ImageLozengeButton button2gbNotSelected = new ImageLozengeButton(
			ImageLoader.load(""action_30x30_black.png""), ""2 GB"");
	private ImageLozengeButton button4gbNotSelected = new ImageLozengeButton(
			ImageLoader.load(""action_30x30_black.png""), ""4 GB"");
	private ImageLozengeButton button8gbNotSelected = new ImageLozengeButton(
			ImageLoader.load(""action_30x30_black.png""), ""8 GB"");
	private ImageLozengeButton button16gbNotSelected = new ImageLozengeButton(
			ImageLoader.load(""action_30x30_black.png""), ""16 GB"");

	public PMPackageListBrowser(PMController controller, Type type) {
		this.controller = controller;
		this.type = type;
		setupUI();
		updateData();
	}

	public boolean isEmpty() {
		return packages.isEmpty();
	}

	public void selectPackage(String name) {
		for (int i = 0; i < listModel.getSize(); i++) {
			if (((PMPackage) listModel.getElementAt(i)).getPackageName().equals(name)) {
				packageList.setSelectedIndex(i);
				packageList.ensureIndexIsVisible(i);
				return;
			}
		}
	}

	public void setSelectionContent(PMPackage reference, boolean showParents) {
		if (showParents) {
			packages = controller.getParentPackages(reference);
		} else {
			packages = controller.getChildPackages(reference);
		}
		String rel = showParents ? ""Parents of "" : ""Children of "";
		header.setText(rel + reference.getPackageName());
	}

	public void showPackage(PMPackage res) {
		if (res == null) {
			packageList.setSelectedIndex(0);
			packageList.ensureIndexIsVisible(0);
			return;
		}
		for (int i = 0; i < listModel.getSize(); i++) {
			if (listModel.getElementAt(i).equals(res)) {
				packageList.setSelectedIndex(i);
				packageList.ensureIndexIsVisible(i);
				break;
			}
		}
	}

	private void setupUI() {
		setOpaque(true);
		setBackground(new Color(180, 180, 180));
		setBorder(BorderFactory.createEmptyBorder());
		JPanel browser = new JPanel();
		browser.setBorder(BorderFactory.createEmptyBorder(5, 5, 5, 5));
		browser.setLayout(new BorderLayout());
		browser.setOpaque(true);
		browser.setBackground(new Color(180, 180, 180));
		listModel = new PMPackageListModel(packages);
		packageList = new JList(listModel);
		packageList.setBackground(new Color(160, 160, 160));
		packageList.setCellRenderer(new PMPackageListCellRenderer());
		packageList.setSelectionMode(ListSelectionModel.MULTIPLE_INTERVAL_SELECTION);
		packageList.addListSelectionListener(new ListSelectionListener() {
			public void valueChanged(ListSelectionEvent e) {
				updateViewport();
			}
		});
		sortByPackageName = new ImageRadioButton(ImageLoader.load(""sortByPackage_27x20_white.png""));
		sortByAuthorName = new ImageRadioButton(ImageLoader.load(""sortByAuthor_27x20_white.png""));
		ButtonGroup sortGroup = new ButtonGroup();
		sortGroup.add(sortByPackageName);
		sortGroup.add(sortByAuthorName);
		sortByPackageName.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				SwingUtilities.invokeLater(new Runnable() {
					public void run() {
						sortList(true);
					}
				});
			}
		});
		sortByPackageName.setToolTipText(PMTooltips.SORTBYPACKAGENAME);
		sortByAuthorName.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				SwingUtilities.invokeLater(new Runnable() {
					public void run() {
						sortList(true);
					}
				});
			}
		});
		sortByAuthorName.setToolTipText(PMTooltips.SORTBYAUTHORNAME);
		sortByPackageName.setSelected(true);
		// assemble header
		header = new JLabel(""No selection to show"");
		header.setOpaque(false);
		header.setFont(header.getFont().deriveFont(16f));
		header.setForeground(new Color(60, 60, 60));
		// assemble sort panel
		JPanel sortPanel = new JPanel();
		sortPanel.setMinimumSize(new Dimension(180, 40));
		sortPanel.setMaximumSize(new Dimension(20000, 40));
		sortPanel.setPreferredSize(new Dimension(200, 40));
		sortPanel.setOpaque(false);
		sortPanel.setBorder(BorderFactory.createEmptyBorder());
		sortPanel.setLayout(new BoxLayout(sortPanel, BoxLayout.X_AXIS));
		JLabel sortLabel = new JLabel(""sort by"");
		sortLabel.setFont(sortLabel.getFont().deriveFont(10f));
		sortLabel.setForeground(new Color(80, 80, 80));
		sortPanel.add(sortLabel);
		sortPanel.add(Box.createHorizontalStrut(10));
		sortPanel.add(sortByPackageName);
		sortPanel.add(Box.createHorizontalStrut(5));
		sortPanel.add(sortByAuthorName);
		sortPanel.add(Box.createHorizontalGlue());
		// assemble list view
		JScrollPane listScrollPane = new JScrollPane(packageList);
		listScrollPane.setBorder(BorderFactory.createEmptyBorder());
		SlickerDecorator.instance().decorate(listScrollPane, new Color(180, 180, 180), new Color(40, 40, 40),
				new Color(100, 100, 100));
		listScrollPane.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);
		listScrollPane.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_AS_NEEDED);
		listScrollPane.setViewportBorder(BorderFactory.createLineBorder(new Color(100, 100, 100), 2));
		// top panel
		JPanel topPanel = new JPanel();
		topPanel.setMinimumSize(new Dimension(180, 60));
		topPanel.setMaximumSize(new Dimension(20000, 60));
		topPanel.setPreferredSize(new Dimension(200, 60));
		topPanel.setOpaque(false);
		topPanel.setBorder(BorderFactory.createEmptyBorder());
		topPanel.setLayout(new BoxLayout(topPanel, BoxLayout.Y_AXIS));
		// assemble browser view
		if (type.equals(Type.SELECTION)) {
			topPanel.add(ArrangementHelper.pushLeft(header));
			topPanel.add(sortPanel);
			browser.add(topPanel, BorderLayout.NORTH);
		} else {
			browser.add(sortPanel, BorderLayout.NORTH);
		}
		browser.add(listScrollPane, BorderLayout.CENTER);
		// assemble all
		viewport = new JPanel();
		viewport.setOpaque(false);
		viewport.setLayout(new BorderLayout());
		viewport.setBorder(BorderFactory.createEmptyBorder(40, 10, 5, 5));
		viewport.setMinimumSize(new Dimension(VIEWPORT_WIDTH, 10));
		viewport.setMaximumSize(new Dimension(VIEWPORT_WIDTH, 10000));
		viewport.setPreferredSize(new Dimension(VIEWPORT_WIDTH, 400));
		setLayout(new BorderLayout());
		this.add(browser, BorderLayout.CENTER);
		this.add(viewport, BorderLayout.EAST);
	}

	private void sortList(boolean keepSelection) {
		final Object selected = packageList.getSelectedValue();
		if (sortByPackageName.isSelected()) {
			listModel.sortByPackageName();
		} else if (sortByAuthorName.isSelected()) {
			listModel.sortByAuthorName();
		}
		if (keepSelection) {
			for (int i = 0; i < listModel.getSize(); i++) {
				if (listModel.getElementAt(i).equals(selected)) {
					packageList.setSelectedIndex(i);
					packageList.ensureIndexIsVisible(i);
					break;
				}
			}
		}
		revalidate();
		repaint();
	}

	public void updateData() {
		if (type.equals(Type.TOUNINSTALL)) {
			packages = controller.getToUninstallPackages();
		} else if (type.equals(Type.TOUPDATE)) {
			packages = controller.getToUpdatePackages();
		} else if (type.equals(Type.TOINSTALL)) {
			packages = controller.getToInstallPackages();
		}

		// Filter packages to keep only those that match the given query
		String query = controller.getQuery();
		List<PMPackage> filteredPackages = new ArrayList<PMPackage>();
		if (query.isEmpty()) {
			filteredPackages.addAll(packages);
		} else {
			for (PMPackage pack : packages) {
				if (pack.getAuthorName().toLowerCase().matches(query) || pack.getPackageName().toLowerCase().matches(query)
						|| pack.getDescription().toLowerCase().matches(query) || pack.getVersion().toLowerCase().matches(query)
						|| pack.getDescriptor().getOrganisation().toLowerCase().matches(query)
						|| pack.getDescriptor().getAuthor().toLowerCase().matches(query)
						|| pack.getDescriptor().getDescription().toLowerCase().matches(query)
						|| pack.getDescriptor().getMaintainer().toLowerCase().matches(query)
						|| pack.getDescriptor().getLicense().toLowerCase().matches(query)
						|| pack.getDescriptor().getName().toLowerCase().matches(query)
						|| pack.getDescriptor().getKeywords().toLowerCase().matches(query)) {
					filteredPackages.add(pack);
				}
			}
		}
		listModel = new PMPackageListModel(filteredPackages);
		final Object selected = packageList.getSelectedValue();
		int index = packageList.getSelectedIndex();

		packageList.setModel(listModel);
		sortList(false);
		packageList.setSelectedValue(selected, true);
		if (packageList.isSelectionEmpty()) {
			int i = Math.max(0, Math.min(index, filteredPackages.size() - 1));
			packageList.setSelectedIndex(i);
			packageList.ensureIndexIsVisible(i);
		}

	}

	private void updateViewport() {
		viewport.removeAll();
		List<? extends PMPackage> selected = packageList.getSelectedValuesList();
		Collection<PMPackage> selectedPacks = new HashSet<PMPackage>();
		for (int i = 0; i < selected.size(); i++) {
			selectedPacks.add(selected.get(i));
		}
		if (!selectedPacks.isEmpty()) {
			pmPackageView = new PMPackageView(selectedPacks, controller);
			viewport.add(pmPackageView, BorderLayout.CENTER);
		} else {
			viewport.add(new JLabel(""No packages selected""), BorderLayout.CENTER);
		}
		viewport.revalidate();
	}

	public PMPackageView getPackageView() {
		return pmPackageView;
	}
}
"
PMPackageListCellRenderer.java,context,"package org.processmining.contexts.uitopia.packagemanager;

import java.awt.AlphaComposite;
import java.awt.Color;
import java.awt.Component;
import java.awt.Dimension;
import java.awt.GradientPaint;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Image;
import java.awt.RenderingHints;

import javax.swing.BorderFactory;
import javax.swing.JComponent;
import javax.swing.JList;
import javax.swing.ListCellRenderer;

import org.deckfour.uitopia.ui.util.ImageLoader;

public class PMPackageListCellRenderer extends JComponent implements ListCellRenderer {

	private static final long serialVersionUID = 413965516084559714L;

	private static final Color COLOR_PASSIVE_TOP = new Color(160, 160, 160);
	private static final Color COLOR_PASSIVE_BOTTOM = new Color(150, 150, 150);
	private static final Color COLOR_PASSIVE_TEXT = new Color(30, 30, 30);
	private static final Color COLOR_ACTIVE_TOP_G = new Color(80, 160, 80);
	private static final Color COLOR_ACTIVE_BOTTOM_G = new Color(40, 120, 40);
	private static final Color COLOR_ACTIVE_TOP_Y = new Color(160, 160, 80);
	private static final Color COLOR_ACTIVE_BOTTOM_Y = new Color(120, 120, 40);
	private static final Color COLOR_ACTIVE_TOP_R = new Color(160, 80, 80);
	private static final Color COLOR_ACTIVE_BOTTOM_R = new Color(120, 40, 40);
	private static final Color COLOR_ACTIVE_TEXT = new Color(0, 0, 0);
	private static final Color COLOR_DEAD_TOP = new Color(80, 80, 80);
	private static final Color COLOR_DEAD_BOTTOM = new Color(40, 40, 40);
	private static final Color COLOR_DEAD_TEXT = new Color(160, 160, 160);
	private static final Color COLOR_TRANSPARENT = new Color(0, 0, 0, 0);

	private static final Image favoriteIcon = ImageLoader.load(""favorite_30x30.png"");

	private static final int HEIGHT = 60;

	private PMPackage pack;
	private boolean selected;

	private boolean paintArrow = true;

	public PMPackageListCellRenderer() {
		this(true);
	}

	public PMPackageListCellRenderer(boolean paintArrow) {
		this.paintArrow = paintArrow;
		setOpaque(true);
		setBorder(BorderFactory.createEmptyBorder());
		setMinimumSize(new Dimension(100, HEIGHT));
		setMaximumSize(new Dimension(1000, HEIGHT));
		setPreferredSize(new Dimension(250, HEIGHT));
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see javax.swing.JComponent#paintComponent(java.awt.Graphics)
	 */
	@Override
	protected void paintComponent(Graphics g) {
		int height = getHeight();
		int width = getWidth();
		Graphics2D g2d = (Graphics2D) g.create();
		g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
		// paint background
		if (selected) {
			switch (pack.getStatus()) {
				case TOUNINSTALL :
					g2d.setPaint(new GradientPaint(0, 0, COLOR_ACTIVE_TOP_G, 0, height, COLOR_ACTIVE_BOTTOM_G));
					break;
				case TOUPDATE :
					g2d.setPaint(new GradientPaint(0, 0, COLOR_ACTIVE_TOP_Y, 0, height, COLOR_ACTIVE_BOTTOM_Y));
					break;
				case TOINSTALL :
					g2d.setPaint(new GradientPaint(0, 0, COLOR_ACTIVE_TOP_R, 0, height, COLOR_ACTIVE_BOTTOM_R));
					break;
				case DEAD :
					g2d.setPaint(new GradientPaint(0, 0, COLOR_DEAD_TOP, 0, height, COLOR_DEAD_BOTTOM));
					break;
			}
		} else {
			switch (pack.getStatus()) {
				case DEAD :
					g2d.setPaint(new GradientPaint(0, 0, COLOR_DEAD_TOP, 0, height, COLOR_DEAD_BOTTOM));
					break;
				default :
					g2d.setPaint(new GradientPaint(0, 0, COLOR_PASSIVE_TOP, 0, height, COLOR_PASSIVE_BOTTOM));
					break;
			}
		}
		g2d.fillRect(0, 0, width, height);
		// paint icon
		//		Image icon = pack.getPreview(10, 10);
		//		int iconX = 10;
		//		int iconY = (height - icon.getHeight(null)) / 2;
		//		g2d.drawImage(icon, iconX, iconY, null);
		// paint text
		if (selected) {
			switch (pack.getStatus()) {
				case DEAD :
					g2d.setPaint(new GradientPaint(width - 20, 0, COLOR_DEAD_TEXT, width, 0, COLOR_TRANSPARENT));
					break;
				default :
					g2d.setPaint(new GradientPaint(width - 20, 0, COLOR_ACTIVE_TEXT, width, 0, COLOR_TRANSPARENT));
					break;
			}
		} else {
			switch (pack.getStatus()) {
				case DEAD :
					g2d.setPaint(new GradientPaint(width - 20, 0, COLOR_DEAD_TEXT, width, 0, COLOR_TRANSPARENT));
					break;
				default :
					g2d.setPaint(new GradientPaint(width - 20, 0, COLOR_PASSIVE_TEXT, width, 0, COLOR_TRANSPARENT));
					break;
			}
		}
		g2d.setFont(g2d.getFont().deriveFont(13f));
		int textX = 20; // + icon.getWidth(null);
		int textY = HEIGHT / 2;
		g2d.drawString(pack.getPackageName(), textX, textY - 6);
		g2d.setFont(g2d.getFont().deriveFont(10f));
		g2d.drawString(pack.getAuthorName(), textX, textY + 10);
		g2d.drawString(pack.getVersion(), textX, textY + 22);
		if (pack.isFavorite()) {
			int fwidth = favoriteIcon.getWidth(null);
			int fheight = favoriteIcon.getHeight(null);
			if (!selected) {
				g2d.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, 0.6f));
			} else {
				g2d.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, 0.8f));
			}
			int posX = width - fwidth - 20;
			if (paintArrow) {
				posX -= 20;
			}
			g2d.drawImage(favoriteIcon, posX, (height - fheight) / 2, null);
		}
		if (selected && paintArrow) {
			g2d.setColor(new Color(10, 10, 10, 200));
			int yMid = height / 2;
			int x[] = { width - 30, width - 10, width - 30, width - 28 };
			int y[] = { yMid - 10, yMid, yMid + 10, yMid };
			g2d.fillPolygon(x, y, 4);
		}
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see
	 * javax.swing.ListCellRenderer#getListCellRendererComponent(javax.swing
	 * .JList, java.lang.Object, int, boolean, boolean)
	 */
	public Component getListCellRendererComponent(JList list, Object value, int index, boolean isSelected,
			boolean cellHasFocus) {
		pack = (PMPackage) value;
		selected = isSelected;
		return this;
	}
}
"
PMPackageListModel.java,context,"package org.processmining.contexts.uitopia.packagemanager;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;

import javax.swing.AbstractListModel;

public class PMPackageListModel extends AbstractListModel {

	/**
	 * 
	 */
	private static final long serialVersionUID = 4483191311607087069L;

	private static final Comparator<PMPackage> COMP_PACKAGE_NAME = new Comparator<PMPackage>() {
		public int compare(PMPackage r1, PMPackage r2) {
			return r1.getPackageName().compareTo(r2.getPackageName());
		}
	};

	private static final Comparator<PMPackage> COMP_AUTHOR_NAME = new Comparator<PMPackage>() {
		public int compare(PMPackage r1, PMPackage r2) {
			return r1.getAuthorName().compareTo(r2.getAuthorName());
		}
	};

	private final List<? extends PMPackage> fullList;
	private List<? extends PMPackage> filteredList;
	private boolean filterFavorites;
	private Comparator<PMPackage> comparator;

	public PMPackageListModel(List<? extends PMPackage> packages) {
		fullList = packages;
		filteredList = new ArrayList<PMPackage>(packages);
		filterFavorites = false;
		comparator = PMPackageListModel.COMP_PACKAGE_NAME;
	}

	public void sortByPackageName() {
		comparator = PMPackageListModel.COMP_PACKAGE_NAME;
		updateList();
	}

	public void sortByAuthorName() {
		comparator = PMPackageListModel.COMP_AUTHOR_NAME;
		updateList();
	}

	public void setFilterFavorites(boolean isFiltered) {
		filterFavorites = isFiltered;
		updateList();
	}

	private void updateList() {
		filteredList = new ArrayList<PMPackage>(fullList);
		if (filterFavorites) {
			ArrayList<PMPackage> filtered = new ArrayList<PMPackage>();
			for (PMPackage r : filteredList) {
				if (r.isFavorite()) {
					filtered.add(r);
				}
			}
			filteredList = filtered;
		}
		Collections.sort(filteredList, comparator);
		fireContentsChanged(this, 0, getSize() - 1);
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see javax.swing.ListModel#getElementAt(int)
	 */
	public Object getElementAt(int index) {
		return filteredList.get(index);
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see javax.swing.ListModel#getSize()
	 */
	public int getSize() {
		return filteredList.size();
	}
}
"
PMPackageView.java,context,"package org.processmining.contexts.uitopia.packagemanager;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Cursor;
import java.awt.Desktop;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.io.IOException;
import java.net.URI;
import java.net.URISyntaxException;
import java.util.Collection;
import java.util.HashSet;

import javax.swing.AbstractButton;
import javax.swing.BorderFactory;
import javax.swing.Box;
import javax.swing.BoxLayout;
import javax.swing.ImageIcon;
import javax.swing.JLabel;
import javax.swing.JPanel;

import org.deckfour.uitopia.ui.components.ImageLozengeButton;
import org.deckfour.uitopia.ui.util.ArrangementHelper;
import org.deckfour.uitopia.ui.util.ImageLoader;
import org.processmining.contexts.uitopia.packagemanager.PMPackage.PMStatus;

import com.fluxicon.slickerbox.components.RoundedPanel;

public class PMPackageView extends RoundedPanel {

	private static final long serialVersionUID = 8110954844773778705L;

	private final Collection<PMPackage> packs;
	private final PMPackage pack;
	private final PMController controller;

	//	private AbstractButton actionButton;
	private AbstractButton installButton;
	private AbstractButton updateButton;
	private AbstractButton removeButton;
	private AbstractButton parentButton;
	private AbstractButton childrenButton;

	public PMPackageView(PMPackage pack, PMController controller) {
		super(20, 5, 15);
		this.packs = new HashSet<PMPackage>();
		this.packs.add(pack);
		this.pack = pack;
		this.controller = controller;
		setupUI();
	}

	public PMPackageView(Collection<PMPackage> packs, PMController controller) {
		super(20, 5, 15);
		this.packs = packs;
		this.pack = (packs.isEmpty() ? null : packs.iterator().next());
		this.controller = controller;
		setupUI();
	}

	private void setupUI() {
		setBackground(new Color(160, 160, 160));
		setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));
		if (packs.size() == 1) {
			// assemble info panel
			JPanel infoPanel = new JPanel();
			infoPanel.setMaximumSize(new Dimension(500, 180));
			infoPanel.setOpaque(false);
			infoPanel.setLayout(new BorderLayout());
			//			Image icon = pack.getPreview(150, 150);
			JLabel preview = null;
			//			if (icon != null) {
			ImageIcon icon = PMIconCache.getIconPreview(pack);
			if (icon != null) {
				preview = new JLabel(icon);
				//				preview.setSize(150, 150);
				preview.setOpaque(false);
			}
			JPanel detailsPanel = new JPanel();
			detailsPanel.setOpaque(false);
			detailsPanel.setBorder(BorderFactory.createEmptyBorder(0, 20, 15, 0));
			detailsPanel.setLayout(new BoxLayout(detailsPanel, BoxLayout.Y_AXIS));
			detailsPanel.add(styleLabel(pack.getPackageName(), new Color(10, 10, 10), 18));
			detailsPanel.add(Box.createVerticalStrut(3));
			detailsPanel.add(styleLabel(pack.getAuthorName(), new Color(30, 30, 30), 14));
			detailsPanel.add(Box.createVerticalStrut(12));
			detailsPanel.add(styleLabel(pack.getVersion(), new Color(60, 60, 60), 12));
			detailsPanel.add(Box.createVerticalStrut(5));
			detailsPanel.add(styleLinkedLabel(""<html><i>License: "" + pack.getLicense() + ""</i></html>"",
					getLink2License(pack.getLicense()), new Color(60, 60, 60), 12));
			detailsPanel.add(Box.createVerticalStrut(5));
			String text = ""<html><i>"";
			if (pack.getDescription() == null) {
				text += ""No description"";
			} else {
				text += ""Description: "" + pack.getDescription();
			}
			text += ""</i></html>"";
			detailsPanel.add(styleLabel(text, new Color(60, 60, 60), 12));
			detailsPanel.add(Box.createVerticalGlue());
			if (preview != null) {
				infoPanel.add(preview, BorderLayout.WEST);
			}
			infoPanel.add(detailsPanel, BorderLayout.CENTER);
			this.add(infoPanel);
			this.add(Box.createVerticalStrut(25));
		}

		// assemble actions panel
		RoundedPanel actionsPanel = new RoundedPanel(50, 0, 0);
		actionsPanel.setBackground(new Color(80, 80, 80));
		actionsPanel.setLayout(new BoxLayout(actionsPanel, BoxLayout.X_AXIS));
		actionsPanel.setBorder(BorderFactory.createEmptyBorder());
		installButton = new ImageLozengeButton(ImageLoader.load(""action_30x30_black.png""), ""Install"", new Color(140,
				140, 140), new Color(140, 40, 40), 2);
		installButton.setToolTipText(PMTooltips.INSTALLBUTTON);
		installButton.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				installPacks();
			}
		});
		updateButton = new ImageLozengeButton(ImageLoader.load(""action_30x30_black.png""), ""Update "", new Color(140,
				140, 140), new Color(40, 140, 40), 2);
		updateButton.setToolTipText(PMTooltips.UPDATEBUTTON);
		updateButton.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				updatePacks();
			}
		});
		removeButton = new ImageLozengeButton(ImageLoader.load(""remove_30x30_black.png""), ""Remove "", new Color(140,
				140, 140), new Color(40, 140, 40), 2);
		removeButton.setToolTipText(PMTooltips.REMOVEBUTTON);
		removeButton.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				removePacks();
			}
		});
		boolean showInstall = false;
		boolean showUpdate = false;
		boolean showRemove = false;
		for (PMPackage p : packs) {
			switch (p.getStatus()) {
				case TOINSTALL :
					showInstall = true;
					break;
				case TOUPDATE :
					showUpdate = true;
					break;
				case TOUNINSTALL :
					showRemove = true;
					break;
				default :
			}
		}
		int width = 10;
		if (showInstall) {
			actionsPanel.add(Box.createHorizontalGlue());
			actionsPanel.add(installButton);
			width += 110;
		}
		if (showUpdate) {
			actionsPanel.add(Box.createHorizontalGlue());
			actionsPanel.add(updateButton);
			width += 110;
		}
		if (showRemove) {
			actionsPanel.add(Box.createHorizontalGlue());
			actionsPanel.add(removeButton);
			width += 110;
		}
		if (!showInstall && !showUpdate && !showRemove) {
			actionsPanel.add(Box.createHorizontalGlue());
			actionsPanel.add(styleLabel(""No actions available"", new Color(160, 160, 160), 12));
			width += 110;
		}
		actionsPanel.setMinimumSize(new Dimension(width, 50));
		actionsPanel.setMaximumSize(new Dimension(width, 50));
		actionsPanel.setPreferredSize(new Dimension(width, 50));
		//		switch (pack.getStatus()) {
		//			case TOUNINSTALL :
		//				actionButton = new ImageLozengeButton(ImageLoader.load(""remove_30x30_black.png""),
		//						""Remove              "", new Color(140, 140, 140), new Color(140, 40, 40), 2);
		//				actionButton.setToolTipText(PMTooltips.REMOVEBUTTON);
		//				break;
		//			case TOUPDATE :
		//				actionButton = new ImageLozengeButton(ImageLoader.load(""action_30x30_black.png""),
		//						""Update              "", new Color(140, 140, 140), new Color(40, 140, 40), 2);
		//				actionButton.setToolTipText(PMTooltips.UPDATEBUTTON);
		//				break;
		//			default :
		//				actionButton = new ImageLozengeButton(ImageLoader.load(""action_30x30_black.png""),
		//						""Install             "", new Color(140, 140, 140), new Color(40, 140, 40), 2);
		//				actionButton.setToolTipText(PMTooltips.INSTALLBUTTON);
		//				break;
		//		}
		//		actionButton.addActionListener(new ActionListener() {
		//			public void actionPerformed(ActionEvent e) {
		//				action();
		//			}
		//		});
		//		actionsPanel.add(Box.createHorizontalGlue());
		//		actionsPanel.add(actionButton);
		actionsPanel.add(Box.createHorizontalGlue());
		this.add(ArrangementHelper.pushLeft(actionsPanel));
		this.add(Box.createVerticalStrut(25));

		if (packs.size() == 1) {
			// assemble family panel
			RoundedPanel familyPanel = new RoundedPanel(50, 0, 0) {
				private static final long serialVersionUID = 6739005088069438989L;

				@Override
				protected void paintComponent(Graphics g) {
					super.paintComponent(g);
					// add fancy arrowhead
					int yMid = getHeight() / 2;
					int x[] = { 15, 45, 42, 45 };
					int y[] = { yMid, yMid - 15, yMid, yMid + 15 };
					g.setColor(new Color(120, 120, 120));
					g.fillPolygon(x, y, 4);
				}
			};
			familyPanel.setBackground(new Color(80, 80, 80));
			familyPanel.setLayout(new BoxLayout(familyPanel, BoxLayout.Y_AXIS));
			familyPanel.setMinimumSize(new Dimension(220, 100));
			familyPanel.setMaximumSize(new Dimension(220, 100));
			familyPanel.setPreferredSize(new Dimension(220, 100));
			familyPanel.setBorder(BorderFactory.createEmptyBorder(5, 55, 5, 15));
			parentButton = new ImageLozengeButton(ImageLoader.load(""parent_30x30_black.png""), ""Show parents"");
			parentButton.addActionListener(new ActionListener() {
				public void actionPerformed(ActionEvent e) {
					showParents();
				}
			});
			parentButton.setToolTipText(PMTooltips.PARENTBUTTON);
			childrenButton = new ImageLozengeButton(ImageLoader.load(""children_30x30_black.png""), ""Show children"");
			childrenButton.addActionListener(new ActionListener() {
				public void actionPerformed(ActionEvent e) {
					showChildren();
				}
			});
			childrenButton.setToolTipText(PMTooltips.CHILDRENBUTTON);
			familyPanel.add(Box.createVerticalGlue());
			familyPanel.add(parentButton);
			familyPanel.add(Box.createVerticalStrut(5));
			familyPanel.add(childrenButton);
			familyPanel.add(Box.createVerticalGlue());
			this.add(ArrangementHelper.pushLeft(familyPanel));
			this.add(Box.createVerticalGlue());
		}
	}

	/**
	 * Returns true if the package was installed or updated, false otherwise.
	 * 
	 * @return
	 */
	//	public boolean action() {
	//		if (pack.getStatus() == PMStatus.TOUNINSTALL) {
	//			controller.remove(pack, controller.getMainView().getWorkspaceView());
	//			return false;
	//		} else {
	//			// (pack.getStatus() == PMStatus.TOUPDATE)  ||
	//			// (pack.getStatus() == PMStatus.TOINSTALL)
	//			controller.update(pack, controller.getMainView().getWorkspaceView());
	//			return true;
	//		}
	//	}

	public boolean installPacks() {
		boolean allDone = true;
		Collection<PMPackage> pp = new HashSet<PMPackage>();
		for (PMPackage p : packs) {
			if (pack.getStatus() == PMStatus.TOINSTALL) {
				pp.add(p);
			} else {
				allDone = false;
			}
		}
		if (!pp.isEmpty()) {
			controller.update(pp, controller.getMainView().getWorkspaceView());
			return allDone;
		}
		return false;
	}

	public boolean updatePacks() {
		boolean allDone = true;
		Collection<PMPackage> pp = new HashSet<PMPackage>();
		for (PMPackage p : packs) {
			if (pack.getStatus() == PMStatus.TOUPDATE) {
				pp.add(p);
			} else {
				allDone = false;
			}
		}
		if (!pp.isEmpty()) {
			controller.update(pp, controller.getMainView().getWorkspaceView());
			return allDone;
		}
		return false;
	}

	public boolean removePacks() {
		boolean allDone = true;
		Collection<PMPackage> pp = new HashSet<PMPackage>();
		for (PMPackage p : packs) {
			if (pack.getStatus() != PMStatus.TOINSTALL) {
				pp.add(p);
			} else {
				allDone = false;
			}
		}
		if (!pp.isEmpty()) {
			controller.remove(pp, controller.getMainView().getWorkspaceView());
			return allDone;
		}
		return false;
	}

	private void showParents() {
		controller.getMainView().getWorkspaceView().showParentsOf(pack);
	}

	private void showChildren() {
		controller.getMainView().getWorkspaceView().showChildrenOf(pack);
	}

	private JLabel styleLabel(String text, Color color, float size) {
		JLabel label = new JLabel(text);
		label.setOpaque(false);
		label.setForeground(color);
		label.setFont(label.getFont().deriveFont(size));
		return label;
	}

	private JLabel styleLinkedLabel(String text, final String link, Color color, float size) {
		JLabel label = styleLabel(text, color, size);
		if (link != null) {
			label.setCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR));
			label.addMouseListener(new MouseAdapter() {
				public void mouseClicked(MouseEvent e) {
					if (e.getClickCount() > 0) {
						if (Desktop.isDesktopSupported()) {
							Desktop desktop = Desktop.getDesktop();
							try {
								URI uri = new URI(link);
								desktop.browse(uri);
							} catch (IOException ex) {
								ex.printStackTrace();
							} catch (URISyntaxException ex) {
								ex.printStackTrace();
							}
						}
					}
				}
			});
		}
		return label;
	}

	private String getLink2License(String license) {
		if (license.equals(""LGPL"") || license.equals(""L-GPL"") || license.equals(""Lesser GPL"")) {
			return ""http://www.gnu.org/licenses/lgpl.html"";
		}
		if (license.equals(""ProM""))	{
			return ""http://www.promtools.org/doku.php?id=license"";
		}
		if (license.equals(""Apache 2.0"")) {
			return ""http://www.apache.org/licenses/LICENSE-2.0.html"";
		}
		if (license.equals(""Apache"")) {
			return ""http://www.apache.org/licenses/LICENSE-1.0"";
		}
		if (license.equals(""Apache 1.1"")) {
			return ""http://www.apache.org/licenses/LICENSE-1.1"";
		}
		if (license.equals(""BSD 3-Clause"")) {
			return ""http://opensource.org/licenses/BSD-3-Clause"";
		}
		if (license.equals(""BSD"")) {
			return ""https://opensource.org/licenses/BSD-2-Clause"";
		}
		if (license.equals(""CPL"")) {
			return ""https://opensource.org/licenses/cpl1.0.php"";
		}
		if (license.equals(""Daikon-specific license"")) {
			return ""http://plse.cs.washington.edu/daikon/download/doc/daikon.html#License"";
		}
		if (license.equals(""dev.java.net \""Other\"" License"")) {
			return ""https://tablelayout.dev.java.net/servlets/LicenseDetails?licenseID=18"";
		}
		if (license.equals(""EPL 1.0"") || license.equals(""EPL"")) {
			return ""http://www.eclipse.org/legal/epl-v10.html"";
		}
		if (license.equals(""GPL"")) {
			return ""http://www.gnu.org/licenses/gpl.html"";
		}
		if (license.equals(""GPL v2"")) {
			return ""http://www.gnu.org/licenses/gpl-2.0.html"";
		}
		if (license.equals(""AGPL"") || license.equals(""A-GPL"") || license.equals(""Affero GPL"")) {
			return ""https://www.gnu.org/licenses/agpl.html"";
		}
		if (license.equals(""MIT"")) {
			return ""http://www.opensource.org/licenses/mit-license.php"";
		}
		if (license.equals(""Mozilla Public License v1.0"")) {
			return ""https://www-archive.mozilla.org/MPL/MPL-1.0.html"";
		}
		return null;
	}
}
"
PMSearchView.java,context,"package org.processmining.contexts.uitopia.packagemanager;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Font;
import java.awt.Image;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

import javax.swing.BorderFactory;
import javax.swing.JLabel;

import org.deckfour.uitopia.ui.util.ImageLoader;
import org.deckfour.uitopia.ui.util.LinkLabel;
import org.deckfour.uitopia.ui.util.Tooltips;

import com.fluxicon.slickerbox.components.RoundedPanel;
import com.fluxicon.slickerbox.components.SlickerSearchField;

public class PMSearchView extends RoundedPanel {

	private static final long serialVersionUID = 5079107169836528703L;

	private final PMWorkspaceBrowser pmWorkspaceBrowser;
	private final PMController controller;
	private SlickerSearchField filterSearch;

	public PMSearchView(PMWorkspaceBrowser pmWorkspaceBrowser, PMController controller) {
		super(20, 5, 0);
		this.pmWorkspaceBrowser = pmWorkspaceBrowser;
		this.controller = controller;
		setBackground(new Color(160, 160, 160));
		setLayout(new BorderLayout());
		setupUI();
	}

	private void setupUI() {
		// Filter: Text search
		filterSearch = new SlickerSearchField(50, 40, new Color(140, 140, 140), new Color(80, 80, 80),
				new Color(40, 40, 40), new Color(20, 20, 20));
		filterSearch.requestFocusInWindow();
		filterSearch.setFont(filterSearch.getFont().deriveFont(Font.BOLD, 14.0f));
		filterSearch.addSearchListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				updateFilter();
			}
		});
		filterSearch.setToolTipText(Tooltips.ACTIONFILTERSEARCHFIELD);
		this.add(filterSearch);		
		
		// Add clickable ProM icon.
		Image appIcon = ImageLoader.load(""prom_logo_101x40.png"");
		JLabel logoLabel = new LinkLabel(appIcon, ""http://www.promtools.org"");
		logoLabel.setOpaque(false);
		logoLabel.setBorder(BorderFactory.createEmptyBorder());
		this.add(logoLabel, BorderLayout.WEST);
	}

	private void updateFilter() {
		// construct search reges from search field
		String search = filterSearch.getSearchText().toLowerCase().trim();
		if (search.length() > 0) {
			search.replaceAll(""\\w"", ""(.*)"");
			search = ""(.*)"" + search + ""(.*)"";
		} else {
			search = ""(.*)"";
		}
		// filter list of packages according to search field
		controller.setQuery(search);
		if (!search.isEmpty())
			pmWorkspaceBrowser.update();
	}
}
"
PMTooltips.java,context,"package org.processmining.contexts.uitopia.packagemanager;

public class PMTooltips {
	public static final String REMOVEBUTTON = ""Remove selected packages"";
	public static final String UPDATEBUTTON = ""Update selected packages"";
	public static final String INSTALLBUTTON = ""Install selected packages"";

	public static final String PARENTBUTTON = ""Show required packages"";
	public static final String CHILDRENBUTTON = ""Show supported packages"";

	public static final String SORTBYPACKAGENAME = ""Sort packages on package name"";
	public static final String SORTBYAUTHORNAME = ""Sort packages on author name"";
}
"
PMWorkspaceBrowser.java,context,"package org.processmining.contexts.uitopia.packagemanager;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

import javax.swing.JComponent;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.SwingUtilities;

import org.deckfour.uitopia.ui.util.ImageLoader;
import org.processmining.framework.boot.Boot;

import com.fluxicon.slickerbox.components.IconVerticalTabbedPane;

public class PMWorkspaceBrowser extends JPanel {

	private static final long serialVersionUID = -1467890361679445697L;
	private static final Color BG = new Color(180, 180, 180);
	private static final Color FG = new Color(60, 60, 60);

	private IconVerticalTabbedPane tabs;
	private final PMController controller;

	private PMPackageListBrowser browserToUninstall;
	private PMPackageListBrowser browserToUpdate;
	private PMPackageListBrowser browserToInstall;
	private PMPackageListBrowser browserSelection;

	private PMPackage selectionPack;
	private boolean selectionParent;

	private final static String TOUNINSTALL = ""Up to date"";
	private final static String TOPUDATE = ""Out of date"";
	private final static String TOINSTALL = ""Not installed"";
	private final static String SELECTION = ""Selection"";

	public PMWorkspaceBrowser(PMController controller) {
		this.controller = controller;
		setLayout(new BorderLayout());
		setOpaque(false);
		setupUI();
		selectionPack = null;
		selectionParent = true;
		//		PackageManager.getInstance().addListener(
		//				new UpdateListener() {
		//					public void updated() {
		//						updatePackages();
		//					}
		//				});
	}

	public PMPackageListBrowser getSelectedBrowser() {
		return (PMPackageListBrowser) tabs.getSelected();
	}

	public void showPackage(PMPackage pack) {
		if (pack.getStatus() == PMPackage.PMStatus.TOUNINSTALL) {
			tabs.selectTab(TOUNINSTALL);
			browserToUninstall.showPackage(pack);
		} else if (pack.getStatus() == PMPackage.PMStatus.TOUPDATE) {
			tabs.selectTab(TOPUDATE);
			browserToUpdate.showPackage(pack);
		} else {
			tabs.selectTab(TOINSTALL);
			browserToInstall.showPackage(pack);
		}
	}

	public void updatePackages() {
		if (selectionPack != null) {
			browserSelection.setSelectionContent(selectionPack, selectionParent);
		}
		SwingUtilities.invokeLater(new Runnable() {

			public void run() {
				JComponent tab = tabs.getSelected();
				if ((tab != null) && (tab instanceof PMPackageListBrowser)) {
					((PMPackageListBrowser) tab).updateData();
				}
			}
		});
	}

	public void showParentsOf(PMPackage pack) {
		selectionPack = pack;
		selectionParent = true;
		browserSelection.setSelectionContent(selectionPack, selectionParent);
		tabs.selectTab(SELECTION);
	}

	public void showChildrenOf(PMPackage pack) {
		selectionPack = pack;
		selectionParent = false;
		browserSelection.setSelectionContent(selectionPack, selectionParent);
		tabs.selectTab(SELECTION);
	}

	private void setupUI() {
		this.add(new PMSearchView(this, controller), BorderLayout.NORTH);

		browserToUninstall = new PMPackageListBrowser(controller, PMPackageListBrowser.Type.TOUNINSTALL);
		browserToUpdate = new PMPackageListBrowser(controller, PMPackageListBrowser.Type.TOUPDATE);
		browserToInstall = new PMPackageListBrowser(controller, PMPackageListBrowser.Type.TOINSTALL);
		browserSelection = new PMPackageListBrowser(controller, PMPackageListBrowser.Type.SELECTION);

		tabs = new IconVerticalTabbedPane(FG, BG, 100);
		tabs.setPassiveBackground(new Color(140, 140, 140));
		tabs.setMouseOverFadeColor(new Color(90, 90, 90));

		tabs.addTab(TOUNINSTALL, ImageLoader.load(""uptodate_60x60_black.png""), browserToUninstall,
				new ActionListener() {
					public void actionPerformed(ActionEvent e) {
						browserToUninstall.updateData();
					}
				});
		tabs.addTab(TOPUDATE, ImageLoader.load(""outofdate_60x60_black.png""), browserToUpdate, new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				browserToUpdate.updateData();
			}
		});
		tabs.addTab(TOINSTALL, ImageLoader.load(""notinstalled_60x60_black.png""), browserToInstall,
				new ActionListener() {
					public void actionPerformed(ActionEvent e) {
						browserToInstall.updateData();
					}
				});
		tabs.addTab(SELECTION, ImageLoader.load(""selection_60x60_black.png""), browserSelection, new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				browserSelection.updateData();
			}
		});

		/*
		 * Pre-select the tab that is most likely of use to the user
		 */
		PMPackageListBrowser currentBrowser = browserToUninstall;
		if (currentBrowser.isEmpty()) {
			currentBrowser = browserToUpdate;
			if (currentBrowser.isEmpty()) {
				currentBrowser = browserToInstall;
				if (currentBrowser.isEmpty()) {
					/*
					 * No packages at all. User may have no internet conenction.
					 */
					JOptionPane.showMessageDialog(controller.getMainView(),
							""No packages were found. Please check your internet connection."");
				}
			}
		}
		/*
		 * And pre-select the most important package.
		 */
		currentBrowser.selectPackage(Boot.RELEASE_PACKAGE);
		tabs.selectTab(currentBrowser);

		this.add(tabs, BorderLayout.CENTER);
		this.add(new PMMemoryView(controller), BorderLayout.SOUTH);
	}

	public void update() {
		browserToUninstall.updateData();
		browserToUpdate.updateData();
		browserToInstall.updateData();
		browserSelection.updateData();
	}
}
"
PMWorkspaceView.java,context,"package org.processmining.contexts.uitopia.packagemanager;

import java.awt.BorderLayout;

import javax.swing.BorderFactory;
import javax.swing.JPanel;

import org.deckfour.uitopia.ui.components.TiledPanel;
import org.deckfour.uitopia.ui.components.ViewHeaderBar;
import org.deckfour.uitopia.ui.main.Viewable;
import org.deckfour.uitopia.ui.util.ImageLoader;

public class PMWorkspaceView extends JPanel implements Viewable {

	/**
	 * 
	 */
	private static final long serialVersionUID = 8491411287370473317L;
	private ViewHeaderBar header;
	private final JPanel contents;
	private final PMWorkspaceBrowser browser;

	public PMWorkspaceView(final PMController controller) {
		setLayout(new BorderLayout());
		setOpaque(true);
		setBorder(BorderFactory.createEmptyBorder());
		contents = new TiledPanel(ImageLoader.load(""tile_wooden.jpg""));
		contents.setBorder(BorderFactory.createEmptyBorder(20, 40, 20, 40));
		contents.setLayout(new BorderLayout());
		browser = new PMWorkspaceBrowser(controller);
		contents.add(browser, BorderLayout.CENTER);
		this.add(contents, BorderLayout.CENTER);
	}

	public ViewHeaderBar getHeader() {
		return header;
	}

	public void showPackage(PMPackage pack) {
		browser.showPackage(pack);
	}

	public void showParentsOf(PMPackage pack) {
		browser.showParentsOf(pack);
	}

	public void showChildrenOf(PMPackage pack) {
		browser.showChildrenOf(pack);
	}

	public void updatePackages() {
		browser.updatePackages();
	}

	public void viewFocusGained() {
	}

	public void viewFocusLost() {
	}

	public PMPackageView getPackageView() {
		return browser.getSelectedBrowser().getPackageView();

	}

	//	public void showFavorites() {
	//		browser.showFavorites();
	//	}
}
"
UI.java,context,"package org.processmining.contexts.uitopia;

import java.io.File;
import java.net.URL;
import java.util.ArrayList;
import java.util.Collection;

import javax.swing.JLabel;
import javax.swing.JOptionPane;

import org.deckfour.uitopia.ui.UITopiaController;
import org.deckfour.uitopia.ui.main.Overlayable;
import org.deckfour.uitopia.ui.overlay.TwoButtonOverlayDialog;
import org.deckfour.uitopia.ui.util.ImageLoader;
import org.processmining.contexts.uitopia.packagemanager.PMController;
import org.processmining.contexts.uitopia.packagemanager.PMFrame;
import org.processmining.contexts.uitopia.packagemanager.PMMainView;
import org.processmining.contexts.uitopia.packagemanager.PMPackage;
import org.processmining.contexts.uitopia.packagemanager.PMPackage.PMStatus;
import org.processmining.framework.boot.Boot;
import org.processmining.framework.packages.PackageDescriptor;
import org.processmining.framework.packages.PackageManager;
import org.processmining.framework.packages.events.PackageManagerListener;
import org.processmining.framework.plugin.annotations.Bootable;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.util.CommandLineArgumentList;

public class UI {

	@Plugin(name = ""UITopia"", parameterLabels = {}, returnLabels = {}, returnTypes = {}, userAccessible = false)
	@Bootable
	public Object main(CommandLineArgumentList commandlineArguments) {
		UIContext globalContext;
		globalContext = new UIContext();
		globalContext.initialize();
		final UITopiaController controller = new UITopiaController(globalContext);
		globalContext.setController(controller);
		globalContext.setFrame(controller.getFrame());
		controller.getFrame().setIconImage(ImageLoader.load(""prom_icon_32x32.png""));
		controller.getFrame().setVisible(true);
		controller.getMainView().showWorkspaceView();
		controller.getMainView().getWorkspaceView().showFavorites();

		globalContext.startup();

		for (String cmd : commandlineArguments) {
			File f = new File(cmd);
			if (f.exists() && f.isFile()) {
				globalContext.getResourceManager().importResource(null, f);
			}
		}

		return controller;
	}

	public static void main(String[] args) throws Exception {

		if (Boot.AUTO_UPDATE.equals(""auto"") || Boot.AUTO_UPDATE.equals(""user"") || !Boot.isLatestReleaseInstalled()) {
			Boot.setReleaseInstalled("""", """");
			PMFrame frame = (PMFrame) Boot.boot(PMFrame.class);
			frame.setIconImage(ImageLoader.load(""prom_icon_32x32.png""));
			// Now select the release package
			PMPackage releasePackage = frame.getController().selectPackage(Boot.RELEASE_PACKAGE);
			if (releasePackage == null) {
				Boot.boot(UI.class, UIPluginContext.class, args);
				throw new Exception(""Cannot find release package defined in ProM.ini file: "" + Boot.RELEASE_PACKAGE
						+ "". Continuing to load ProM."");
			}

			if (releasePackage.getStatus() == PMStatus.TOUNINSTALL) {

				int option = JOptionPane.NO_OPTION;

				if (Boot.AUTO_UPDATE.equals(""auto"") || Boot.AUTO_UPDATE.equals(""user"")) {
					/*
					 * HV: Check for packages to install or update.
					 */
					PMController pmController = frame.getController();
					if (Boot.AUTO_UPDATE.equals(""user"")) {
						if (!pmController.getToInstallPackages().isEmpty()) {
							if (!pmController.getToUpdatePackages().isEmpty()) {
								option = JOptionPane.showConfirmDialog(frame,
										""New packages and package updates are available.\nDo you want ProM to install and/or update them now?"",
										""Install and update packages?"", JOptionPane.YES_NO_OPTION);
							} else {
								option = JOptionPane.showConfirmDialog(frame,
										""New packages are available.\nDo you want ProM to install them now?"",
										""Install packages?"", JOptionPane.YES_NO_OPTION);
							}
						} else if (!pmController.getToUpdatePackages().isEmpty()) {
							option = JOptionPane.showConfirmDialog(frame,
									""Package updates are available.\nDo you want ProM to update them now?"",
									""Update packages?"", JOptionPane.YES_NO_OPTION);
						}
					} else { // auto
						option = JOptionPane.YES_OPTION;
					}
					if (option == JOptionPane.YES_OPTION) {
						// Start listening
						UIPackageManagerListener listener = new UIPackageManagerListener(frame, args);
						PackageManager.getInstance().addListener(listener);

						// Show the package manager
						frame.setVisible(true);
						Collection<PMPackage> toUpdate = new ArrayList<PMPackage>();
						toUpdate.addAll(pmController.getToInstallPackages());
						toUpdate.addAll(pmController.getToUpdatePackages());

						frame.getController().update(toUpdate, frame.getController().getMainView().getWorkspaceView());

						// ProM will be started as soon as the package manager finishes.

						synchronized (listener) {
							while (!listener.isDone()) {
								listener.wait();
							}
						}

					}
				}

				if (option == JOptionPane.NO_OPTION) {
					// Package is upToDate and installed.
					// Do not show package manager and start ProM
					Boot.setLatestReleaseInstalled();
					Boot.boot(UI.class, UIPluginContext.class, args);
				}

			} else {

				// Start listening
				UIPackageManagerListener listener = new UIPackageManagerListener(frame, args);
				PackageManager.getInstance().addListener(listener);

				// Show the package manager
				frame.setVisible(true);

				// And install the release package!
				frame.getController().update(releasePackage, frame.getController().getMainView().getWorkspaceView());

				// ProM will be started as soon as the package manager finishes.

				synchronized (listener) {
					while (!listener.isDone()) {
						listener.wait();
					}
				}

			}

			//Boot.setLatestReleaseInstalled();
		} else {
			Boot.boot(UI.class, UIPluginContext.class, args);
		}

	}
}

class FirstTimeOverlay extends TwoButtonOverlayDialog {

	/**
	 * 
	 */
	private static final long serialVersionUID = 494237962617678531L;

	public FirstTimeOverlay(Overlayable mainView) {
		super(mainView, ""Starting ProM"", ""Cancel"", ""  OK  "", //
				new JLabel(""<html>All packages have been installed and/or updated.<BR>""
						+ ""Please wait while starting ProM.<BR><BR>""
						+ ""If this is the first time you run ProM on this computer, please be patient.</html>""));

		getCancelButton().setEnabled(true);
		getOKButton().setEnabled(false);

	}

	@Override
	public void close(boolean okayed) {
		if (!okayed) {
			System.exit(0);
		}
		super.close(okayed);
	}

}

class UIPackageManagerListener implements PackageManagerListener {

	private final String[] args;
	private final PMFrame frame;
	private boolean done = false;

	public UIPackageManagerListener(PMFrame frame, String[] args) {
		this.frame = frame;
		this.args = args;
	}

	public void exception(Throwable t) {
	}

	public void exception(String exception) {
	}

	public void finishedInstall(String packageName, File folder, PackageDescriptor pack) {
	}

	public void sessionComplete(boolean error) {
		synchronized (this) {
			done = true;
			this.notifyAll();
		}
		PackageManager.getInstance().removeListener(this);
		showOverlayAfterInstall();
	}

	public void sessionStart() {
	}

	public void startDownload(String packageName, URL url, PackageDescriptor pack) {
	}

	public void startInstall(String packageName, File folder, PackageDescriptor pack) {
	}

	public boolean isDone() {
		return done;
	}

	private void showOverlayAfterInstall() {
		PMMainView overlayable = frame.getController().getMainView();

		FirstTimeOverlay dialog = new FirstTimeOverlay(overlayable);

		overlayable.showOverlay(dialog);
		frame.saveConfig();

		try {
			Boot.boot(UI.class, UIPluginContext.class, args);
			Boot.setLatestReleaseInstalled();
		} catch (Exception e1) {
			throw new RuntimeException(e1);
		} finally {
			frame.setVisible(false);
		}

	}

}"
UIContext.java,context,"package org.processmining.contexts.uitopia;

import java.util.Date;
import java.util.List;

import org.deckfour.uitopia.api.event.TaskListener;
import org.deckfour.uitopia.api.hub.CategoryManager;
import org.deckfour.uitopia.api.hub.FrameworkHub;
import org.deckfour.uitopia.api.model.Author;
import org.deckfour.uitopia.ui.UITopiaController;
import org.deckfour.uitopia.ui.UITopiaFrame;
import org.processmining.contexts.uitopia.hub.ProMActionManager;
import org.processmining.contexts.uitopia.hub.ProMCategoryManager;
import org.processmining.contexts.uitopia.hub.ProMResourceManager;
import org.processmining.contexts.uitopia.hub.ProMTaskManager;
import org.processmining.contexts.uitopia.hub.ProMViewManager;
import org.processmining.contexts.uitopia.model.ProMAction;
import org.processmining.contexts.uitopia.model.ProMPOResource;
import org.processmining.contexts.uitopia.model.ProMResource;
import org.processmining.contexts.uitopia.model.ProMTask;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.impl.AbstractGlobalContext;

public class UIContext extends AbstractGlobalContext implements
		FrameworkHub<ProMAction, ProMTask, ProMResource<?>, ProMPOResource> {

	private final UIPluginContext mainPluginContext;
	private UITopiaFrame frame;
	private ProMResourceManager resourceManager;
	private ProMActionManager actionManager;
	private ProMTaskManager taskManager;
	private ProMViewManager viewManager;
	private CategoryManager categoryManager;
	private UITopiaController controller;

	public UIContext() {
		super();
		mainPluginContext = new UIPluginContext(this, ""Main Plugin Context"");

	}

	public void initialize() {
		resourceManager = ProMResourceManager.initialize(this);
		taskManager = ProMTaskManager.initialize(this);
		actionManager = ProMActionManager.initialize(this);
		viewManager = ProMViewManager.initialize(this);
		categoryManager = ProMCategoryManager.initialize(this);
	}

	public void setFrame(UITopiaFrame frame) {
		this.frame = frame;
	}

	public CategoryManager getCategoryManager() {
		return categoryManager;
	}

	@Override
	public UIPluginContext getMainPluginContext() {
		return mainPluginContext;
	}

	@Override
	public Class<? extends PluginContext> getPluginContextType() {
		return UIPluginContext.class;
	}

	public List<Author> getFrameworkAuthors() {
		// TODO Auto-generated method stub
		return null;
	}

	public Date getFrameworkReleaseDate() {
		// TODO Auto-generated method stub
		return null;
	}

	public String getFrameworkVersion() {
		// TODO Auto-generated method stub
		return null;
	}

	public ProMResourceManager getResourceManager() {
		return resourceManager;
	}

	public ProMActionManager getActionManager() {
		return actionManager;
	}

	public ProMTaskManager getTaskManager() {
		return taskManager;
	}

	public ProMViewManager getViewManager() {
		return viewManager;
	}

	public void shutdown(TaskListener arg0) {
	}

	public void startup() {
		// Nothing to do (since (de)serialization was abandoned).
	}

	public UITopiaFrame getUI() {
		return frame;
	}

	public UITopiaController getController() {
		return controller;
	}

	public void setController(UITopiaController controller) {
		this.controller = controller;
	}

}
"
UIPluginContext.java,context,"package org.processmining.contexts.uitopia;

import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.File;
import java.io.IOException;
import java.util.concurrent.Executor;
import java.util.concurrent.Executors;
import java.util.prefs.Preferences;

import javax.swing.JComponent;
import javax.swing.JFileChooser;
import javax.swing.filechooser.FileFilter;
import javax.swing.filechooser.FileNameExtensionFilter;

import org.deckfour.uitopia.api.event.TaskListener.InteractionResult;
import org.deckfour.uitopia.api.model.ActionType;
import org.processmining.contexts.uitopia.model.ProMTask;
import org.processmining.framework.plugin.GlobalContext;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.Progress;
import org.processmining.framework.plugin.impl.AbstractPluginContext;

public class UIPluginContext extends AbstractPluginContext {

	/*
	 * The field UIPluginContext.PREF is never read locally private static final
	 * String PREF = ""guiplugincontext"";
	 */
	private final Executor executor;
	private ProMTask task;

	UIPluginContext(GlobalContext context, String label) {
		super(context, label);
		// This context is NOT a child of another context,
		// hence should behave in an asynchronous way.
		executor = Executors.newCachedThreadPool();

		//TODO: Setup progressbar
		// progress = new GUIProgressBar(this);

	}

	protected UIPluginContext(UIPluginContext context, String label) {
		super(context, label);

		// TODO: Setup Progress
		// progress = new GUIProgressBar(this);

		// This context is a child of another context,
		// hence should behave in a synchronous way.
		if (context/*.getParentContext()*/ == null) {
			// this context is on the first level below the user-initiated
			// plugins
			executor = Executors.newCachedThreadPool();
		} else {
			// all subtasks take the pool of the parent.
			executor = context.getExecutor();
		}

		setTask(context.task);
	}

	@Override
	protected synchronized PluginContext createTypedChildContext(String label) {
		return new UIPluginContext(this, label);
	}

	public Executor getExecutor() {
		return executor;
	}

	/*
	 * [HV] The method getPreferences() from the type UIPluginContext is never
	 * used locally
	 */
	@SuppressWarnings(""unused"")
	private Preferences getPreferences() {
		return Preferences.userNodeForPackage(UIPluginContext.class);
	}

	/*
	 * [HV] The declared exception IOException is not actually thrown by the
	 * method openFile(FileFilter) from type UIPluginContext
	 */
	@SuppressWarnings(""unused"")
	public File openFile(final FileFilter filter) throws IOException {
		// TODO
		return null;
	}

	/*
	 * [HV] The declared exception IOException is not actually thrown by the
	 * method saveFile(String, String...) from type UIPluginContext
	 */
	@SuppressWarnings(""unused"")
	public File saveFile(String defaultExtension, String... extensions) throws IOException {
		// TODO
		return null;
	}

	/*
	 * [HV] The declared exception IOException is not actually thrown by the
	 * method openFiles(FileFilter) from type UIPluginContext
	 */
	@SuppressWarnings(""unused"")
	public File[] openFiles(FileFilter filter) throws IOException {
		// TODO
		return null;
	}

	public Progress getProgress() {
		return progress;
	}

	public UIContext getGlobalContext() {
		return (UIContext) super.getGlobalContext();
	}

	public UIPluginContext getRootContext() {
		return (UIPluginContext) super.getRootContext();
	}

	public void setTask(ProMTask task) {
		this.task = task;
	}

	/**
	 * Return the task being executed in this PluginContext; useful for registering new resources with this task.
	 * @return the task
	 */
	public ProMTask getTask() {
		return task;
	}

	public InteractionResult showConfiguration(String title, JComponent configuration) {
		if (task == null) {
			return InteractionResult.CANCEL;
		}
		assert (task.getAction().getType() == ActionType.INTERACTIVE);
		return task.showConfiguration(title, configuration);
	}

	public InteractionResult showWizard(String title, boolean first, boolean last, JComponent configuration) {
		if (task == null) {
			return InteractionResult.CANCEL;
		}
		assert (task.getAction().getType() == ActionType.INTERACTIVE);
		return task.showWizard(title, first, last, configuration);
	}

	@Override
	public UIPluginContext createChildContext(String label) {
		return (UIPluginContext) super.createChildContext(label);
	}
}

class FileChooserPropertyListener implements PropertyChangeListener {

	public FileChooserPropertyListener(String ext) {
		this.ext = ext.toLowerCase();
	}

	public String ext;

	public void propertyChange(PropertyChangeEvent evt) {
		if (evt.getPropertyName().equals(JFileChooser.FILE_FILTER_CHANGED_PROPERTY)) {
			ext = ((FileNameExtensionFilter) evt.getNewValue()).getExtensions()[0].toLowerCase();
		}
	}
}
"
HtmlPanel.java,context,"package org.processmining.contexts.util;

import java.awt.Desktop;
import java.io.IOException;
import java.net.URISyntaxException;

import javax.swing.GroupLayout;
import javax.swing.GroupLayout.Alignment;
import javax.swing.JEditorPane;
import javax.swing.event.HyperlinkEvent;
import javax.swing.event.HyperlinkListener;

import org.processmining.contexts.uitopia.annotations.Visualizer;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginLevel;
import org.processmining.framework.util.HTMLToString;

public class HtmlPanel extends javax.swing.JPanel implements HyperlinkListener {

	@Plugin(name = ""Visualize HTML text"", //
	level = PluginLevel.PeerReviewed,
	parameterLabels = { ""HTML text"" }, //
	returnLabels = { ""HTML panel"" }, //
	returnTypes = { HtmlPanel.class }, //
	userAccessible = true, //
	help = ""Visualizes HTML text."", mostSignificantResult = 1)
	@Visualizer
	public static HtmlPanel visualizeHTML(PluginContext context, HTMLToString htmlText) {
		return new HtmlPanel(htmlText.toHTMLString(true));
	}

	/**
	 * Opens hyperlinks in standard browser (see
	 * http://forums.sun.com/thread.jspa?threadID=5403426)
	 */
	public void hyperlinkUpdate(HyperlinkEvent event) {
		if (event.getEventType() == HyperlinkEvent.EventType.ACTIVATED) {
			try {
				Desktop.getDesktop().browse(event.getURL().toURI());
			} catch (IOException e) {
			} catch (URISyntaxException e) {
			}
		}
	}

	/**
	 * 
	 */
	private static final long serialVersionUID = -8692121995363561628L;

	/** Creates new form HtmlReport */
	public HtmlPanel(String diagnosis) {
		initComponents(diagnosis);
	}

	/**
	 * This method is called from within the constructor to initialize the form.
	 * WARNING: Do NOT modify this code. The content of this method is always
	 * regenerated by the Form Editor.
	 */
	// <editor-fold defaultstate=""collapsed"" desc=""Generated Code"">//GEN-BEGIN:initComponents
	private void initComponents(String diagnosis) {

		jScrollPane1 = new javax.swing.JScrollPane();
		jTextPane1 = new javax.swing.JEditorPane();
		jTextPane1.setEditable(false);
		jTextPane1.addHyperlinkListener(this);

		jTextPane1.setContentType(""text/html"");
		jTextPane1.setText(diagnosis);
		jScrollPane1.setViewportView(jTextPane1);

		GroupLayout layout = new GroupLayout(this);
		setLayout(layout);
		layout.setHorizontalGroup(layout.createParallelGroup(Alignment.LEADING).addGroup(
				layout.createSequentialGroup().addContainerGap().addComponent(jScrollPane1, GroupLayout.DEFAULT_SIZE,
						641, Short.MAX_VALUE).addContainerGap()));
		layout.setVerticalGroup(layout.createParallelGroup(Alignment.LEADING).addGroup(
				layout.createSequentialGroup().addContainerGap().addComponent(jScrollPane1, GroupLayout.DEFAULT_SIZE,
						3860, Short.MAX_VALUE).addContainerGap()));
	}// </editor-fold>

	// Variables declaration - do not modify
	private javax.swing.JScrollPane jScrollPane1;
	private JEditorPane jTextPane1;
	// End of variables declaration
}
"
PortLabelCell.java,context,"package org.processmining.contexts.util.jgraph;

import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;

import javax.swing.tree.MutableTreeNode;

import org.jgraph.graph.AttributeMap;
import org.jgraph.graph.DefaultGraphCell;
import org.jgraph.graph.GraphConstants;

public class PortLabelCell extends DefaultGraphCell {

	public PortLabelCell(Object o, Point2D topLeft) {
		super(o);
		if (topLeft == null) {
			topLeft = new Point2D.Double(20, 20);
		}
		GraphConstants.setBounds(getAttributes(), new Rectangle2D.Double(topLeft.getX(), topLeft.getY(), 10, 10));

	}

	public PortLabelCell(Object o, AttributeMap map, MutableTreeNode[] nodes) {
		super(o, map, nodes);
	}

	/**
	 * 
	 */
	private static final long serialVersionUID = -3154130726739617209L;

}"
PortLabelVertexView.java,context,"package org.processmining.contexts.util.jgraph;

import java.awt.BasicStroke;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Component;
import java.awt.Dimension;
import java.awt.FontMetrics;
import java.awt.GradientPaint;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Stroke;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.StringTokenizer;

import javax.swing.JLabel;
import javax.swing.JPanel;

import org.jgraph.JGraph;
import org.jgraph.graph.CellView;
import org.jgraph.graph.CellViewRenderer;
import org.jgraph.graph.GraphConstants;
import org.jgraph.graph.GraphModel;
import org.jgraph.graph.VertexRenderer;
import org.jgraph.graph.VertexView;

/**
 * 
 */
public class PortLabelVertexView extends VertexView {

	/**
	 * 
	 */
	private static final long serialVersionUID = -4669647479882266935L;

	/**
	 * the renderer for this view
	 */
	protected static WrapperPortLabelRenderer renderer = new WrapperPortLabelRenderer();

	protected CellView[] ports;

	/**
	 * Creates new instance of <code>InstanceView</code>.
	 */
	public PortLabelVertexView() {
		super();
	}

	/**
	 * Creates new instance of <code>InstanceView</code> for the specified graph
	 * cell.
	 * 
	 * @param arg0
	 *            a graph cell to create view for
	 */
	public PortLabelVertexView(Object arg0) {
		super(arg0);
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see org.jgraph.graph.AbstractCellView#getRenderer()
	 */
	public CellViewRenderer getRenderer() {
		return renderer;
	}

	public static class WrapperPortLabelRenderer extends JPanel implements CellViewRenderer {

		/**
		 * 
		 */
		private static final long serialVersionUID = 5603848567918969169L;

		private transient static JLabel label = new JLabel();

		private transient static PortLabelVertexRenderer portLabelRenderer = new PortLabelVertexRenderer();

		/**
		 * Cache the current graph for drawing
		 */
		protected transient JGraph graph = null;

		transient protected Color gradientColor = null;

		/** Cached hasFocus and selected value. */
		transient protected boolean hasFocus, selected, preview;

		/**
		 * Constructs a renderer that may be used to render vertices.
		 */
		public WrapperPortLabelRenderer() {
			super(new BorderLayout());
			this.add(portLabelRenderer, BorderLayout.CENTER);
			this.add(label, BorderLayout.SOUTH);
			label.setOpaque(false);
			setOpaque(false);

		}

		public Component getRendererComponent(JGraph graph, CellView view, boolean sel, boolean focus, boolean preview) {
			portLabelRenderer.getRendererComponent(graph, view, sel, focus, preview);
			label.setText(view.getCell().toString());
			this.graph = graph;
			selected = sel;
			this.preview = preview;
			hasFocus = focus;
			installAttributes(view);
			return this;
		}

		public void paint(Graphics g) {
			if ((gradientColor != null) && !preview) {
				setOpaque(false);
				Graphics2D g2d = (Graphics2D) g;
				g2d.setPaint(new GradientPaint(0, 0, getBackground(), getWidth(), getHeight(), gradientColor, true));
				g2d.fillRect(0, 0, getWidth(), getHeight());
			}
			if (selected) {
				paintSelectionBorder(g);
			}
			super.paint(g);
		}

		protected void paintSelectionBorder(Graphics g) {
			Graphics2D g2 = (Graphics2D) g;
			Stroke previousStroke = g2.getStroke();
			float[] dash = new float[] { 5f, 5f };
			g2.setStroke(new BasicStroke(2, BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER, 10.0f, dash, 0.0f));
			g.setColor(Color.RED);
			g.drawRect(0, 0, getWidth() - 1, getHeight() - 1);
			g2.setStroke(previousStroke);
		}

		public Point2D getPerimeterPoint(VertexView view, Point2D source, Point2D p) {
			return portLabelRenderer.getPerimeterPoint(view, source, p);
		}

		protected void installAttributes(CellView view) {
			Map<?, ?> attributes = view.getAllAttributes();
			label.setVerticalAlignment(GraphConstants.getVerticalAlignment(attributes));
			label.setHorizontalAlignment(GraphConstants.getHorizontalAlignment(attributes));
			label.setVerticalTextPosition(GraphConstants.getVerticalTextPosition(attributes));
			label.setHorizontalTextPosition(GraphConstants.getHorizontalTextPosition(attributes));
			label.setFont(GraphConstants.getFont(attributes));
			gradientColor = GraphConstants.getGradientColor(attributes);
		}
	}

	/**
	 * The renderer class for instance view.
	 */
	public static class PortLabelVertexRenderer extends VertexRenderer {

		/**
		 * 
		 */
		private static final long serialVersionUID = -2599058809422643000L;

		protected CellView[] ports = null;

		protected FontMetrics fontMetrics = null;

		public static transient int PORTLABELSPACING = 5;

		public static transient int MINIMUMHORIZONTALSPACING = 15;

		public static transient int MINIMUMVERTICALSPACING = 2;

		/**
		 * The vertical distance added to the label height to make the color
		 * backdrop extend beyond the label text
		 */
		public static transient int COLORHEIGHTBUFFER = 4;

		/**
		 * The maximum width of a label, any label more than this value in width
		 */
		public static transient int MAXLABELWIDTH = 100;

		/*
		 * (non-Javadoc)
		 * 
		 * @see java.awt.Component#paint(java.awt.Graphics)
		 */
		public void paint(Graphics g) {
			selected = false;
			super.paint(g);
			g.setColor(getForeground());
			paintPortLabels(g);
		}

		public Component getRendererComponent(JGraph graph, CellView view, boolean sel, boolean focus, boolean preview) {
			// Do not display the label, the wrapper does this
			setText(null);
			// Finds the ports and install them into the renderer
			Graphics2D g = (Graphics2D) graph.getGraphics();
			if (g != null) {
				fontMetrics = g.getFontMetrics();
				Object cell = view.getCell();
				GraphModel model = graph.getModel();
				int childCount = model.getChildCount(cell);
				List<CellView> result = new ArrayList<CellView>(childCount);
				for (int i = 0; i < childCount; i++) {
					Object child = model.getChild(cell, i);
					if (model.isPort(child)) {
						CellView portView = graph.getGraphLayoutCache().getMapping(child, false);
						if (portView != null) {
							result.add(portView);
						}
					}
				}

				ports = new CellView[result.size()];
				result.toArray(ports);
			}
			Component c = super.getRendererComponent(graph, view, sel, focus, preview);
			// Do not display the label, the wrapper does this
			setText(null);
			return c;
		}

		/**
		 * Install the attributes of specified cell in this renderer instance.
		 * This means, retrieve every published key from the cells hashtable and
		 * set global variables or superclass properties accordingly.
		 * 
		 * @param view
		 *            the cell view to retrieve the attribute values from.
		 */
		protected void installAttributes(CellView view) {
			Map<?, ?> map = view.getAllAttributes();
			setIcon(GraphConstants.getIcon(map));
			setOpaque(GraphConstants.isOpaque(map));
			setBorder(GraphConstants.getBorder(map));
			setVerticalAlignment(GraphConstants.getVerticalAlignment(map));
			setHorizontalAlignment(GraphConstants.getHorizontalAlignment(map));
			bordercolor = GraphConstants.getBorderColor(map);
			borderWidth = Math.max(1, Math.round(GraphConstants.getLineWidth(map)));
			setOpaque(false);
			setFont(GraphConstants.getFont(map));
		}

		/**
		 * Draws a <code>String</code>. Its horizontal position <code>x</code>
		 * is given and its vertical position is centered on given
		 * <code>y</code>.
		 * 
		 * @param g
		 *            a <code>Graphics2D</code> to draw with
		 * @param label
		 *            a <code>String</code> to draw
		 * @param x
		 *            an offset to left edge of the bounding box of vertex
		 * @param y
		 *            an offset to center of the string
		 * @param background
		 *            the background color, if any, behind the text
		 * @param isLeftLabel
		 *            whether or not this label is on the left-hand side of the
		 *            vertex
		 */
		public static void drawPortLabel(Graphics g, String labelValue, double x, double y, Color background,
				boolean isLeftLabel) {
			FontMetrics metrics = g.getFontMetrics();
			StringTokenizer st = new StringTokenizer(labelValue, ""\n"");
			List<String> labels = new ArrayList<String>(st.countTokens());
			while (st.hasMoreTokens()) {
				labels.add(st.nextToken());
			}
			double height = metrics.getStringBounds(labelValue, g).getHeight();
			double i = -.5;
			for (String label : labels) {

				int sw = metrics.stringWidth(label);
				// If string is longer than allowed, concat it, replacing excess
				// with ""...""
				int tries = 0;
				if (sw > MAXLABELWIDTH) {
					int dotLength = metrics.stringWidth(""..."");
					while ((sw > MAXLABELWIDTH) && (tries < 5)) {
						int characters = label.length();
						double stringRatio = (double) (MAXLABELWIDTH - dotLength) / (double) sw;
						int newStringLength = (int) (characters * stringRatio);
						// Shorten string with each try
						newStringLength -= tries;
						if (newStringLength < characters) {
							String newLabel = label.substring(0, newStringLength);
							newLabel += ""..."";
							int newStringWidth = metrics.stringWidth(newLabel);
							if (newStringWidth < MAXLABELWIDTH) {
								label = newLabel;
								sw = newStringWidth;
							}
						}
						tries++;
					}
				}
				int sh = metrics.getHeight();
				int offsetX = 0;
				if (isLeftLabel) {
					offsetX = PORTLABELSPACING;
				} else {
					offsetX = -sw - PORTLABELSPACING;
				}
				g.drawString(label, (int) x + offsetX, (int) ((y + sh / 2) + height * i));
				i += 1.0;
			}
		}

		/**
		 * Paints port labels the view.
		 * 
		 * @param g
		 *            a <code>Graphics2D</code> to draw with
		 */
		public void paintPortLabels(Graphics g) {
			if ((ports != null) && (ports.length > 0)) {
				CellView parentView = ports[0].getParentView();
				Rectangle2D bounds = GraphConstants.getBounds(parentView.getAllAttributes());
				// Get the bounds of the vertex and deduct twice the cell label
				// height plus the vertical buffer distance from it.
				double height = bounds.getHeight();
				Color oldBackground = getBackground();
				for (int i = 0; i < ports.length; i++) {
					String labelValue = ports[i].getCell().toString();
					if (labelValue == null) {
						labelValue = new String();
					}
					Point2D portOffset = GraphConstants.getOffset(ports[i].getAllAttributes());
					Color portBackground = GraphConstants.getBackground(ports[i].getAllAttributes());
					double x = 0;
					double y = 0;
					if (portOffset != null) {
						if (bounds != null) {
							// By x position should be 0 or the width of the
							// vertex
							x = portOffset.getX() * bounds.getWidth() / GraphConstants.PERMILLE;
							// The y position is the proportion of the vertex
							// height available for port label. Remember a bit
							// is reserved either end for the vertex label.
							y = portOffset.getY() * height / GraphConstants.PERMILLE;
							if (portOffset.getX() == 0) {
								drawPortLabel(g, labelValue, x, y, portBackground, true);
							} else if (portOffset.getX() == GraphConstants.PERMILLE) {
								drawPortLabel(g, labelValue, x, y, portBackground, false);
							}
						}
					}
				}
				setBackground(oldBackground);
			}
		}

		public Dimension getPreferredSize() {
			Dimension vertexPreferredSize = super.getPreferredSize();
			if ((ports != null) && (fontMetrics != null)) {
				int heightPerLabel = fontMetrics.getHeight() + MINIMUMVERTICALSPACING;
				double left = 0, right = 0;
				double maxLeft = 0, maxRight = 0;
				for (int i = 0; i < ports.length; i++) {
					String labelValue = ports[i].getCell().toString();
					if (labelValue == null) {
						labelValue = """";
					}
					StringTokenizer st = new StringTokenizer(labelValue, ""\n"");
					List<String> labels = new ArrayList<String>(st.countTokens());
					while (st.hasMoreTokens()) {
						labels.add(st.nextToken());
					}
					Point2D portOffset = GraphConstants.getOffset(ports[i].getAllAttributes());
					if (portOffset != null) {
						for (String label : labels) {
							int sw = fontMetrics.stringWidth(label);
							// Limit the size of labels to MAXLABELWIDTH
							if (sw > MAXLABELWIDTH) {
								sw = MAXLABELWIDTH;
							}
							if (portOffset.getX() == 0) {
								left += heightPerLabel;
								maxLeft = Math.max(maxLeft, sw);
							} else if (portOffset.getX() == GraphConstants.PERMILLE) {
								right += heightPerLabel;
								maxRight = Math.max(maxRight, sw);
							}
						}
					}
				}
				int maxX = 1 + Math.max((int) vertexPreferredSize.getWidth(),
						(2 * MAXLABELWIDTH + MINIMUMHORIZONTALSPACING));//(maxLeft + maxRight + MINIMUMHORIZONTALSPACING));
				return new Dimension(maxX, (int) Math.max(left, right));
			}
			return vertexPreferredSize;
		}
	}
}"
StringVisualizer.java,context,"package org.processmining.contexts.util;

import java.awt.Color;

import javax.swing.BorderFactory;
import javax.swing.JComponent;
import javax.swing.JLabel;
import javax.swing.JScrollPane;
import javax.swing.ScrollPaneConstants;

import org.processmining.contexts.uitopia.annotations.Visualizer;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;

import com.fluxicon.slickerbox.factory.SlickerDecorator;

public class StringVisualizer {

	@Visualizer
	@Plugin(name = ""String Visualizer"", parameterLabels = ""String"", returnLabels = ""Label of String"", returnTypes = JComponent.class)
	public static JComponent visualize(PluginContext context, String tovisualize) {
		JScrollPane sp = new JScrollPane();
		sp.setOpaque(false);
		sp.getViewport().setOpaque(false);
		sp.setBorder(BorderFactory.createEmptyBorder());
		sp.setViewportBorder(BorderFactory.createLineBorder(new Color(10, 10, 10), 2));
		sp.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);
		sp.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_AS_NEEDED);
		SlickerDecorator.instance().decorate(sp.getVerticalScrollBar(), new Color(0, 0, 0, 0),
				new Color(140, 140, 140), new Color(80, 80, 80));
		sp.getVerticalScrollBar().setOpaque(false);

		JLabel l = new JLabel(tovisualize);
		sp.setViewportView(l);

		return sp;
	}
}
"
ToolTipComboBox.java,context,"package org.processmining.contexts.util;

/***********************************************************
 * This software is part of the ProM package * http://www.processmining.org/ * *
 * Copyright (c) 2003-2006 TU/e Eindhoven * and is licensed under the * Common
 * Public License, Version 1.0 * by Eindhoven University of Technology *
 * Department of Information Systems * http://is.tm.tue.nl * *
 **********************************************************/

import java.awt.Component;
import java.util.Vector;

import javax.swing.ComboBoxModel;
import javax.swing.DefaultComboBoxModel;
import javax.swing.JComboBox;
import javax.swing.JList;
import javax.swing.plaf.basic.BasicComboBoxRenderer;

/**
 * <p>
 * Title:
 * </p>
 * 
 * <p>
 * Description:
 * </p>
 * 
 * <p>
 * Copyright: Copyright (c) 2004
 * </p>
 * 
 * <p>
 * Company:
 * </p>
 * 
 * @author not attributable
 * @version 1.0
 */
public class ToolTipComboBox extends JComboBox {
	/**
	 * 
	 */
	private static final long serialVersionUID = -492241585719051368L;

	/**
	 * Creates a <code>ToolTipComboBox</code> that takes it's items from an
	 * existing <code>ComboBoxModel</code>. Since the <code>ComboBoxModel</code>
	 * is provided, a combo box created using this constructor does not create a
	 * default combo box model and may impact how the insert, remove and add
	 * methods behave.
	 * 
	 * @param aModel
	 *            the <code>ComboBoxModel</code> that provides the displayed
	 *            list of items
	 * @see DefaultComboBoxModel
	 */
	public ToolTipComboBox(ComboBoxModel aModel) {
		super(aModel);
		setRenderer(new ToolTipComboBoxRenderer());
	}

	/**
	 * Creates a <code>ToolTipComboBox</code> that contains the elements in the
	 * specified array. By default the first item in the array (and therefore
	 * the data model) becomes selected.
	 * 
	 * @param items
	 *            an array of objects to insert into the combo box
	 * @see DefaultComboBoxModel
	 */
	public ToolTipComboBox(final Object items[]) {
		super(items);
		setRenderer(new ToolTipComboBoxRenderer());
	}

	/**
	 * Creates a <code>ToolTipComboBox</code> that contains the elements in the
	 * specified Vector. By default the first item in the vector and therefore
	 * the data model) becomes selected.
	 * 
	 * @param items
	 *            an array of vectors to insert into the combo box
	 * @see DefaultComboBoxModel
	 */
	public ToolTipComboBox(Vector<?> items) {
		super(items);
		setRenderer(new ToolTipComboBoxRenderer());
	}

	/**
	 * Creates a <code>ToolTipComboBox</code> with a default data model. The
	 * default data model is an empty list of objects. Use <code>addItem</code>
	 * to add items. By default the first item in the data model becomes
	 * selected.
	 * 
	 * @see DefaultComboBoxModel
	 */
	public ToolTipComboBox() {
		super();
		setRenderer(new ToolTipComboBoxRenderer());
	}
}

class ToolTipComboBoxRenderer extends BasicComboBoxRenderer {
	/**
	 * 
	 */
	private static final long serialVersionUID = 513853339785774728L;

	public Component getListCellRendererComponent(JList list, Object value, int index, boolean isSelected,
			boolean cellHasFocus) {
		if (isSelected) {
			setBackground(list.getSelectionBackground());
			setForeground(list.getSelectionForeground());
			if (-1 < index) {
				list.setToolTipText(value.toString());
			}
		} else {
			setBackground(list.getBackground());
			setForeground(list.getForeground());
		}
		setFont(list.getFont());
		setText((value == null) ? """" : value.toString());
		return this;
	}
}
"
DepthFirstExpandCollection.java,context,"package org.processmining.framework.util.search;

import java.util.Collection;
import java.util.Stack;

public class DepthFirstExpandCollection<N> implements ExpandCollection<N> {

	protected Stack<N> stack = new Stack<N>();

	public void add(Collection<? extends N> newElements) {
		stack.addAll(newElements);
	}

	public N pop() {
		return stack.pop();
	}

	public boolean isEmpty() {
		return stack.isEmpty();
	}

}
"
ExpandCollection.java,context,"package org.processmining.framework.util.search;

import java.util.Collection;

/**
 * 
 * @author bfvdonge
 * 
 * @param <N>
 */
public interface ExpandCollection<N> {

	/**
	 * Gets and removes the first element to be expanded by the node expander.
	 * 
	 * Implementing classes may assume that isEmpty() returns false before any
	 * call to pop, i.e. the first line of the implementation can be:
	 * <code>assert (!isEmpty())</code>
	 * 
	 * @return the first element to be investigated by the searcher.
	 */
	public N pop();

	/**
	 * Adds the given elements to the collection. Note that implementing classes
	 * may safely assume that the calling thread owns the monitor, i.e. there is
	 * no need to synchronize on the collection retained by this
	 * expandcollection and removals are allowed. Furthermore, the implementing
	 * class may decide not to include any of the given newElements if it
	 * decides that they are not to be investigated further.
	 * 
	 * @param newElements
	 *            the nodes to expand further
	 */
	public void add(Collection<? extends N> newElements);

	/**
	 * Checks whether or not the collection retained by this ExpandCollection is
	 * empty. If this method returns false, a call to pop() can be made.
	 * 
	 * @return
	 */
	public boolean isEmpty();

}
"
HashMultiSet.java,context,"package org.processmining.framework.util.collection;

import java.util.Collection;
import java.util.HashMap;
import java.util.Map;

public class HashMultiSet<T> extends AbstractMultiSet<T, Map<T, Integer>> {

	/**
	 * Constructs a new multiset, such that all elements of the given collection
	 * are added as many times as they are returned by the iterator of that
	 * collection.
	 * 
	 * @param collection
	 *            Representing the objects that should be put in a multiset
	 */
	public HashMultiSet(Collection<? extends T> collection) {
		this();
		addAll(collection);
	}

	/**
	 * Constructs a new multiset, such that all elements of the given collection
	 * are added as many times as they are in the given array.
	 * 
	 * @param collection
	 *            Representing the objects that should be put in a multiset
	 */
	public HashMultiSet(T[] collection) {
		this();
		for (T par : collection) {
			add(par);
		}
	}

	/**
	 * Constructs a new, empty multiset, such that all elements of the given
	 * collection are added as many times as they are returned by the iterator
	 * of that collection.
	 */
	public HashMultiSet() {
		size = 0;
		map = new HashMap<T, Integer>();
	}

	<S> MultiSet<S> newMultiSet(Collection<S> collection) {
		return new HashMultiSet<S>(collection);
	}

	MultiSet<T> newMultiSet() {
		return new HashMultiSet<T>();
	}
}
"
LinkedHashMultiSet.java,context,"package org.processmining.framework.util.collection;

import java.util.Collection;
import java.util.LinkedHashMap;

public class LinkedHashMultiSet<T> extends HashMultiSet<T> {

	/**
	 * Constructs a new multiset, such that all elements of the given collection
	 * are added as many times as they are returned by the iterator of that
	 * collection.
	 * 
	 * @param collection
	 *            Representing the objects that should be put in a multiset
	 */
	public LinkedHashMultiSet(Collection<? extends T> collection) {
		this();
		addAll(collection);
	}

	/**
	 * Constructs a new multiset, such that all elements of the given collection
	 * are added as many times as they are in the given array.
	 * 
	 * @param collection
	 *            Representing the objects that should be put in a multiset
	 */
	public LinkedHashMultiSet(T... collection) {
		this();
		for (T par : collection) {
			add(par);
		}
	}

	/**
	 * Constructs a new, empty multiset, such that all elements of the given
	 * collection are added as many times as they are returned by the iterator
	 * of that collection.
	 */
	public LinkedHashMultiSet() {
		size = 0;
		map = new LinkedHashMap<T, Integer>();
	}

}
"
MultiSet.java,context,"package org.processmining.framework.util.collection;

import java.util.Collection;
import java.util.List;
import java.util.Set;

import org.processmining.framework.util.HTMLToString;

/**
 * This class implements a mutliset. The implementation is synchronized.
 * 
 * @author bfvdonge
 * 
 * @param <T>
 *            the type of the objects in this multiset.
 */
public interface MultiSet<T> extends Collection<T>, HTMLToString {

	/**
	 * Adds the given object to the multiset, as many times as indicated by the
	 * given weight parameter.
	 * 
	 * @param par
	 *            the object to add
	 * @param weight
	 *            the number of times to add it
	 * @return the new number of occurrences of the object (>0)
	 */
	public Integer add(T par, Integer weight);

	/**
	 * Converts this multiset to a list, such that each element occurs as often
	 * as returned by the iterator of the multiset (its number of occurrences).
	 * 
	 * @return a list of objects as returned by the iterator
	 */
	public List<T> toList();

	/**
	 * returns true if this multiset is less or equal to the given multiset,
	 * i.e. all objects in this multiset should be contained in the given set
	 * and the number of occurrences in the given set is at least the number of
	 * occurrences in this multiset.
	 * 
	 * @param multiSet
	 *            the multiset to test
	 * @return true if the given multiset is less or equal.
	 */
	public boolean isLessOrEqual(MultiSet<T> multiSet);

	/**
	 * returns the number of occurrences of the given object in this multiset.
	 * 
	 * @param source
	 *            the object to get the occurrences for
	 * @return the number of occurrences, 0 if the object does not occur.
	 */
	public Integer occurrences(Object source);

	/**
	 * returns an unmodifiable set of unique objects in the multiset.
	 * 
	 * @return an unmodifiable set of unique objects in the multiset.
	 */
	public Set<T> baseSet();

}
"
MultiThreadedSearcher.java,context,"package org.processmining.framework.util.search;

import java.rmi.server.UID;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Executor;

import javax.swing.SwingWorker;

import org.processmining.framework.plugin.Progress;

/**
 * This class implements a multi-threaded search algorithm.
 * 
 * Internally, each instance of this class keeps a stack of objects of type N,
 * representing the nodes in the tree. Each thread pops an element off the stack
 * and asks the registered NodeExpander<N> to expand it. If the node turns out
 * to be a leaf, the expander is asked to process the leaf.
 * 
 * The use of this class is as follows (in pseudo-code):
 * 
 * <code>
 * Collection<N> initialSearchNodes;
 * Collection<N> resultCollection;
 * NodeExpander<N> expander = new NodeExpander<N>();
 * MultiThreadedSearcher<N> searcher = new MultiThreadedSearcher<N>(expander, BREADTHFIRST);
 * searcher.addInitialNodes(initialSearchNodes);
 * 
 * searcher.startSearch(executor, progress, resultCollection); 
 * </code>
 * 
 * Note that if you use this code from a plugin, you can also use:
 * 
 * <code>
 * searcher.startSearch(context.getExecutor(), context.getProgress(), resultCollection);
 * </code>
 * 
 * The progress object given to the startSearch method is only used for
 * cancellation checks, i.e. progress is never incremented.
 * 
 * @author bfvdonge
 * 
 * @param <N>
 */
public class MultiThreadedSearcher<N> {

	/**
	 * Constant representing a DEPTH-FIRST search.
	 */
	public final static int DEPTHFIRST = 0;

	/**
	 * Constant representing a BREADTH-FIRST search.
	 */
	public final static int BREADTHFIRST = 1;

	private final NodeExpander<N> expander;
	private final int threads;
	private Map<MultiThreadedSearchWorker<N>, Boolean> waiting;
	private final ExpandCollection<N> stack;

	/**
	 * Instantiates a searcher. The searcher will use as many threads as
	 * specified. Furthermore, the given expander is used for the expansion of
	 * search nodes and the processing of leaf nodes.
	 * 
	 * The searchtype can be either DEPTHFIRST, or BREADTHFIRST. In the first
	 * case, new nodes produced by the expand method of the expander are added
	 * to the bottom of the stack, whereas in the latter case, the new nodes are
	 * pushed to the top of the stack.
	 * 
	 * @param numberOfThreads
	 *            specifies the number of threads to use. If unsure how to set
	 *            this value, use the other constructor without this parameter
	 * @param expander
	 *            The expander that will be used to expand each search node and
	 *            process the leafs of the search tree
	 * @param searchType
	 *            the type of search, either DEPTHFIRST or BREADTHFIRST
	 */
	public MultiThreadedSearcher(int numberOfThreads, NodeExpander<N> expander, int searchType) {
		this.threads = numberOfThreads;
		this.expander = expander;
		if (searchType == DEPTHFIRST) {
			this.stack = new DepthFirstExpandCollection<N>();
		} else if (searchType == BREADTHFIRST) {
			this.stack = new BreadthFirstExpandCollection<N>();
		} else {
			throw new IllegalArgumentException(""Wrong search type specified."");
		}
	}

	/**
	 * Instantiates a searcher. The searcher will use as many threads as the
	 * virtual machine reports to have CPUs. Furthermore, the given expander is
	 * used for the expansion of search nodes and the processing of leaf nodes.
	 * 
	 * The searchtype can be either DEPTHFIRST, or BREADTHFIRST. In the first
	 * case, new nodes produced by the expand method of the expander are added
	 * to the bottom of the stack, whereas in the latter case, the new nodes are
	 * pushed to the top of the stack.
	 * 
	 * By default, as many threads are used as there are CPUs reported by
	 * <code>Runtime.getRuntime().availableProcessors()</code>
	 * 
	 * @param expander
	 *            The expander that will be used to expand each search node and
	 *            process the leafs of the search tree
	 * @param searchType
	 *            the type of search, either DEPTHFIRST or BREADTHFIRST
	 */
	public MultiThreadedSearcher(NodeExpander<N> expander, int searchType) {
		this(Runtime.getRuntime().availableProcessors(), expander, searchType);
	}

	/**
	 * Instantiates a searcher. The searcher will use as many threads as
	 * specified. Furthermore, the given expander is used for the expansion of
	 * search nodes and the processing of leaf nodes and the given
	 * expandCollection to store nodes that need to be expanded further.
	 * 
	 * @param numberOfThreads
	 *            specifies the number of threads to use. If unsure how to set
	 *            this value, use the other constructor without this parameter
	 * @param expander
	 *            The expander that will be used to expand each search node and
	 *            process the leafs of the search tree
	 * @param expandCollection
	 *            the collection to store nodes that need to be expanded
	 */
	public MultiThreadedSearcher(int numberOfThreads, NodeExpander<N> expander, ExpandCollection<N> expandCollection) {
		this.threads = numberOfThreads;
		this.expander = expander;
		this.stack = expandCollection;
	}

	/**
	 * Instantiates a searcher. The searcher will use as many threads as
	 * specified. Furthermore, the given expander is used for the expansion of
	 * search nodes and the processing of leaf nodes and the given
	 * expandCollection to store nodes that need to be expanded further.
	 * 
	 * By default, as many threads are used as there are CPUs reported by
	 * <code>Runtime.getRuntime().availableProcessors()</code>
	 * 
	 * @param expander
	 *            The expander that will be used to expand each search node and
	 *            process the leafs of the search tree
	 * @param expandCollection
	 *            the collection to store nodes that need to be expanded
	 */
	public MultiThreadedSearcher(NodeExpander<N> expander, ExpandCollection<N> expandCollection) {
		this(Runtime.getRuntime().availableProcessors(), expander, expandCollection);
	}

	/**
	 * Sets the initial nodes of the search tree. Note that you can provide an
	 * empty collection, in which case the search returns immediately, without
	 * calling any methods in the expander.
	 * 
	 * @param initialNodes
	 *            the collection of initial nodes.
	 */
	public void addInitialNodes(Collection<N> initialNodes) {
		synchronized (stack) {
			stack.add(initialNodes);
		}
	}

	/**
	 * Sets the initial nodes of the search tree. Note that you don't have to
	 * provide any nodes, in which case the search returns immediately, without
	 * calling any methods in the expander.
	 * 
	 * @param initialNodes
	 *            zero or more initial nodes.
	 */
	public void addInitialNodes(N... initialNodes) {
		synchronized (stack) {
			stack.add(Arrays.asList(initialNodes));
		}
	}

	/**
	 * A call to this method initiates the search. The calling thread is
	 * suspended until the search is completed, or the progress was canceled.
	 * The resultCollection given to this method is passes through to the
	 * processLeaf method of the NodeExpander, i.e. no changes to this
	 * collection are made by the searcher.
	 * 
	 * @param executor
	 *            The executor in which the searcher can schedule it's threads.
	 *            If called from a plugin, use context.getExector() to pass to
	 *            this method.
	 * @param progress
	 *            The progress which is polled for cancellation. Note that no
	 *            other changes are made to the progress. If changes are
	 *            necessary, this has to be handled by the NodeExpander. If
	 *            called from a plugin, use context.getProgress() to pass to
	 *            this method.
	 * @param resultCollection
	 *            The collection in which the final result is stored by the
	 *            processLeaf method of the node expander. Note that the
	 *            searcher does not change this collection in any way, nor does
	 *            it handle any necessary synchronization.
	 * @throws InterruptedException
	 *             If one of the threads was interupted;
	 * @throws ExecutionException
	 *             If one of the threads threw an exception;
	 */
	public void startSearch(final Executor executor, final Progress progress, final Collection<N> resultCollection)
			throws InterruptedException, ExecutionException {

		// Set the number of waiting threads to 0;
		waiting = new HashMap<MultiThreadedSearchWorker<N>, Boolean>();

		MultiThreadedSearchWorker<N> worker = null;

		// Syncrhonize on the object ""waiting"" to make sure that first all
		// workers are registered to this map, before any of them accesses it.
		synchronized (waiting) {
			for (int i = 0; i < threads; i++) {
				worker = new MultiThreadedSearchWorker<N>(this, progress, resultCollection);
				waiting.put(worker, false);
			}
		}

		for (MultiThreadedSearchWorker<N> w : waiting.keySet()) {
			executor.execute(w);
		}

		// Just synchronize on the last worker. It stops only when all workers are finished.
		worker.get();

	}

	NodeExpander<N> getExpander() {
		return expander;
	}

	ExpandCollection<N> getStack() {
		return stack;
	}

	boolean setWaiting(MultiThreadedSearchWorker<N> worker, Boolean state) {
		synchronized (waiting) {
			waiting.put(worker, state);
			return !waiting.containsValue(false);
		}
	}
}

class MultiThreadedSearchWorker<N> extends SwingWorker<Object, Void> {

	private final MultiThreadedSearcher<N> owner;
	private final Progress progress;

	private final Collection<N> resultCollection;

	private final ExpandCollection<N> stack;
	private final UID id = new UID();

	public MultiThreadedSearchWorker(MultiThreadedSearcher<N> owner, Progress progress, Collection<N> resultCollection) {
		this.owner = owner;
		this.progress = progress;
		this.resultCollection = resultCollection;
		this.stack = owner.getStack();
	}

	public int hashCode() {
		return id.hashCode();
	}

	@SuppressWarnings(""unchecked"")
	public boolean equals(Object o) {
		if (o instanceof MultiThreadedSearchWorker) {
			return id.equals(((MultiThreadedSearchWorker) o).id);
		}
		return false;
	}

	@Override
	protected Object doInBackground() throws Exception {
		while (!progress.isCancelled()) {
			// First get the node to expand
			N toExpand = getNodeToExpand(progress);
			if (toExpand == null) {
				// Cancellation occurred, or the search is finished.
				// stop execution
				synchronized (stack) {
					stack.notifyAll();
				}
				break /* while */;
			}

			// Ask the expander for new nodes. Note that this call does not 
			// synchronize on stack, hence multiple of these calls can be 
			// processed in parallel.
			Collection<N> expandFurther = owner.getExpander().expandNode(toExpand, progress, resultCollection);

			// Let the searcher process the newly found nodes. Note that this is
			// synchronized as it requires to change the stack.
			processNewNodes(toExpand, expandFurther, resultCollection, progress);
		}
		// all threads are done, so quit.
		return null;
	}

	private N getNodeToExpand(Progress progress) throws InterruptedException {
		synchronized (stack) {
			while (!progress.isCancelled()) {
				if (stack.isEmpty()) {
					// Notify the searcher that we enter the waiting state
					if (owner.setWaiting(this, true)) {
						// All threads are waiting for the stack and this is the last
						// that will start waiting. Hence, there is nothing to do anymore.
						// Stop the execution by returning null.
						return null;
					} else {
						// Let's sleep until stack is filled again.
						stack.wait();
						continue;
					}
				} else {
					// Notify the searcher that we leave the waiting state
					owner.setWaiting(this, false);
					// get the node to expand.
					N toExpand = stack.pop();
					stack.notifyAll();
					return toExpand;
				}
			}
		}
		// In case of a cancellation, throw an exception;
		owner.setWaiting(this, true);
		return null;
	}

	private void processNewNodes(N toExpand, Collection<N> expandFurther, final Collection<N> resultCollection,
			Progress progress) {
		synchronized (stack) {
			if (!expandFurther.isEmpty()) {
				// There are tuples that need to be expanded further.
				stack.add(expandFurther);
			} else {
				synchronized (resultCollection) {
					owner.getExpander().processLeaf(toExpand, progress, resultCollection);
				}
			}
			// notify threads waiting on stack
			stack.notifyAll();
		}

	}

}
"
NodeExpander.java,context,"package org.processmining.framework.util.search;

import java.util.Collection;

import org.processmining.framework.plugin.Progress;

/**
 * This class is used by the MultiThreadedSearcher to handle callbacks. Each
 * time the searcher considers a node, it asks the registered expander to expand
 * the node. If a node cannot be expanded, then a call to processLeaf is made.
 * The expander should not process any leafs from within the expandNode method.
 * 
 * @author bfvdonge
 * 
 * @param <N>
 */
public interface NodeExpander<N> {

	/**
	 * This method is called by the searcher when a node in the search tree has
	 * to be considered for expansion. The node to expand is given as a
	 * parameter and the method should return a collection of nodes representing
	 * the children of this node. If the node turns out to be a leaf, an empty
	 * collection has to be returned.
	 * 
	 * @param toExpand
	 *            The node to expand.
	 * @param progress
	 *            The progress indicator provided to the searcher in which this
	 *            expander is registered. The expander may increment the
	 *            progress, but it should check for cancellation, especially
	 *            when doing long computations.
	 * @param unmodifiableResultCollection
	 *            the leafs of the search space that have been added to the
	 *            resultCollection by the processLeaf method. Note that any
	 *            access to this collection should be synchronized and this
	 *            collection should not be modified in this method. However the
	 *            provided collection is modifiable, as for synchronization
	 *            purposes, the actual resultCollection is provided.
	 * @return A collection of child nodes, or an empty collection if this node
	 *         turns out to be a leaf.
	 */
	public Collection<N> expandNode(N toExpand, Progress progress, Collection<N> unmodifiableResultCollection);

	/**
	 * This method is called by the searcher to which this expander is
	 * registered each time a leaf was encountered. The provided
	 * resultCollection was specified in the startSearch method of the searcher
	 * and can be used to store this result. A typical implementation is:
	 * 
	 * <code>
	 * synchronized(resultCollection) {
	 *     resultCollection.add(leaf);
	 * }
	 * </code>
	 * 
	 * However, more advanced implementations are possible.
	 * 
	 * Finally, note that calls to this method are not thread-safe, i.e. the
	 * implementing class should take care of synchronization on the
	 * resultCollection if necessary (as in the example above).
	 * 
	 * @param leaf
	 *            The node that was found to be a leaf by the expandNode method
	 *            (i.e. the expandNode method returned and empty collection)
	 * @param progress
	 *            The progress indicator provided to the searcher in which this
	 *            expander is registered. The expander may increment the
	 *            progress, but it should check for cancellation, especially
	 *            when doing long computations.
	 * @param resultCollection
	 *            The collection to which to add the leaf node. More advanced
	 *            computations are allowed here, i.e. the resultCollection can
	 *            be changed. Note however that this requires syncrhonization on
	 *            the collection, as calls to this method are not thread-safe.
	 */
	public void processLeaf(N leaf, Progress progress, Collection<N> resultCollection);

}
"
CommandLineInterface.java,context,"package org.processmining.framework.packages;

import jargs.gnu.CmdLineParser;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.SortedSet;

import org.processmining.framework.boot.Boot.Level;
import org.processmining.framework.util.AutoHelpCommandLineParser;
import org.processmining.framework.util.Pair;

public class CommandLineInterface {

	private final PackageManager manager;

	public CommandLineInterface(PackageManager manager) {
		this.manager = manager;
	}

	public int run(String[] args) {
		AutoHelpCommandLineParser.Command[] commands = { new UpdateCommand(manager),
				new InstallOrRemoveCommand(manager), new ListCommand(manager) };
		AutoHelpCommandLineParser parser = new AutoHelpCommandLineParser(""java ""
				+ PackageManager.class.getCanonicalName(), commands);

		CmdLineParser.Option helpOption = parser.addHelp(parser.addBooleanOption('h', ""help""),
				""Print this help message and exit"");

		try {
			parser.parse(args);
		} catch (CmdLineParser.OptionException e) {
			System.err.println(e.getMessage());
			parser.printUsage();
			return 1;
		}

		if ((parser.getRemainingArgs().length == 0) || (Boolean) parser.getOptionValue(helpOption, Boolean.FALSE)) {
			parser.printUsage();
			return 0;
		}

		int exitcode;
		try {
			manager.initialize(Level.ALL);
			exitcode = parser.runCommand();
		} catch (Throwable e) {
			e.printStackTrace();
			return 1;
		}

		if (exitcode == -1) {
			parser.printUsage();
			return 1;
		}
		return exitcode;
	}

}

class UpdateCommand extends AutoHelpCommandLineParser.Command {

	private final PackageManager manager;

	public UpdateCommand(PackageManager manager) {
		super(""update"", ""Retrieve the latest package definitions from all repositories"");
		this.manager = manager;
	}

	@Override
	public int run(List<String> args) throws Exception {
		System.out.println(""Updating..."");
		manager.update(true, Level.ALL);
		System.out.println(""Done."");
		return 0;
	}

}

class InstallOrRemoveCommand extends AutoHelpCommandLineParser.Command {

	private final PackageManager manager;

	public InstallOrRemoveCommand(PackageManager manager) {
		super(""change"",
				""Install the packages preceded by +, remove packages preceded by x (example: change +packageA:1.0 xpackageB)"");
		this.manager = manager;
	}

	@Override
	public int run(List<String> args) throws Exception {
		List<PackageDescriptor> toInstall = new ArrayList<PackageDescriptor>();
		List<PackageDescriptor> toRemove = new ArrayList<PackageDescriptor>();

		Set<PackageDescriptor> all = new HashSet<PackageDescriptor>(manager.getInstalledPackages());
		all.addAll(manager.getAvailablePackages());
		Map<String, SortedSet<PackageDescriptor>> map = PackageManager.getPackageMap(all);

		for (String packageNameAndAction : args) {
			if ((packageNameAndAction.length() > 1)
					&& ((packageNameAndAction.charAt(0) == 'x') || (packageNameAndAction.charAt(0) == '+'))) {
				Pair<String, PackageVersion> packageName = parse(packageNameAndAction.substring(1));
				boolean install = packageNameAndAction.charAt(0) == '+';
				Set<PackageDescriptor> versions = map.get(packageName.getFirst());
				PackageDescriptor p = null;

				if ((versions != null) && !versions.isEmpty()) {
					if (packageName.getSecond() == null) {
						// take latest version if no version was given
						p = versions.toArray(new PackageDescriptor[0])[versions.size() - 1];
					} else {
						for (PackageDescriptor v : versions) {
							if (v.getVersion().equals(packageName.getSecond())) {
								p = v;
								break;
							}
						}
					}
				}

				if (p == null) {
					System.out.println(""Could not find package "" + packageNameAndAction.substring(1)
							+ "" in the list of available packages, skipping."");
				} else {
					System.out.println(""Selected "" + p + "" for "" + (install ? ""installation"" : ""removal"") + ""..."");
					if (install) {
						toInstall.add(p);
					} else {
						toRemove.add(p);
					}
				}
			} else {
				System.out
						.println(""Invalid package specification (please use + or - to indicate installation or removal), skipping."");
			}
		}

		if (toInstall.isEmpty() && toRemove.isEmpty()) {
			System.out.println(""Nothing to install or remove."");
		} else {
			System.out.println(""Starting installation..."");
			manager.install(toInstall);
			manager.uninstall(toRemove);
			PackageStateReport report = manager.getLatestReport();

			System.out.print(report);
			System.out.println(report.hasErrors() ? ""Installation is NOT performed."" : ""Installation done."");
		}
		return 0;
	}

	private Pair<String, PackageVersion> parse(String name) {
		int hyphen = name.indexOf(':');

		if (hyphen >= 0) {
			return new Pair<String, PackageVersion>(name.substring(0, hyphen), new PackageVersion(
					name.substring(hyphen + 1)));
		} else {
			return new Pair<String, PackageVersion>(name, null);
		}
	}
}

class ListCommand extends AutoHelpCommandLineParser.Command {

	private final PackageManager manager;

	public ListCommand(PackageManager manager) {
		super(""list"", ""List all known packages and their status (A=available,I=installed,B=broken,+=has update)"");
		this.manager = manager;
	}

	@Override
	public int run(List<String> args) throws Exception {
		Set<PackageDescriptor> installed = manager.getInstalledPackages();
		Collection<PackageDescriptor> enabled = manager.getEnabledPackages();

		Set<PackageDescriptor> all = new HashSet<PackageDescriptor>(manager.getInstalledPackages());
		all.addAll(manager.getAvailablePackages());

		for (Map.Entry<String, SortedSet<PackageDescriptor>> item : PackageManager.getPackageMap(all).entrySet()) {
			PackageDescriptor installedPackage = null;
			PackageVersion highestVersion = null;
			boolean isEnabled = false;
			String versions = """";

			for (PackageDescriptor pack : item.getValue()) {
				if (installed.contains(pack)) {
					installedPackage = pack;
				}
				if (enabled.contains(pack)) {
					isEnabled = true;
				}
				if (versions.length() > 0) {
					versions += "", "";
				}
				versions += pack.getVersion();
				highestVersion = pack.getVersion();
			}

			if (installedPackage == null) {
				System.out.println(""A  "" + item.getKey() + "" ["" + versions + ""]"");
			} else if (isEnabled) {
				System.out.println(""I"" + (installedPackage.getVersion().lessThan(highestVersion) ? ""+"" : "" "") + "" ""
						+ installedPackage + "" ["" + versions + ""]"");
			} else {
				System.out.println(""B"" + (installedPackage.getVersion().lessThan(highestVersion) ? ""+"" : "" "") + "" ""
						+ installedPackage + "" ["" + versions + ""]"");
			}
		}
		return 0;
	}
}
"
PackageManagerListener.java,context,"package org.processmining.framework.packages.events;

import java.io.File;
import java.net.URL;
import java.util.EventListener;

import org.processmining.framework.packages.PackageDescriptor;
import org.processmining.framework.plugin.events.ProMEventListenerList;

public interface PackageManagerListener extends EventListener {

	public class ListenerList extends ProMEventListenerList<PackageManagerListener> {
		public void fireSessionStart() {
			for (PackageManagerListener listener : getListeners()) {
				listener.sessionStart();
			}
		}

		public void fireSessionComplete(boolean error) {
			for (PackageManagerListener listener : getListeners()) {
				listener.sessionComplete(error);
			}
		}

		public void fireStartDownload(String packageName, URL url, PackageDescriptor pack) {
			for (PackageManagerListener listener : getListeners()) {
				listener.startDownload(packageName, url, pack);
			}
		}

		public void fireStartInstall(String packageName, File folder, PackageDescriptor pack) {
			for (PackageManagerListener listener : getListeners()) {
				listener.startInstall(packageName, folder, pack);
			}
		}

		public void fireFinishedInstall(String packageName, File folder, PackageDescriptor pack) {
			for (PackageManagerListener listener : getListeners()) {
				listener.finishedInstall(packageName, folder, pack);
			}
		}

		public void fireException(String exception) {
			for (PackageManagerListener listener : getListeners()) {
				listener.exception(exception);
			}
		}

		public void fireException(Throwable t) {
			for (PackageManagerListener listener : getListeners()) {
				listener.exception(t);
			}
		}
	}

	public void sessionStart();

	public void exception(Throwable t);

	public void exception(String exception);

	public void startDownload(String packageName, URL url, PackageDescriptor pack);

	public void startInstall(String packageName, File folder, PackageDescriptor pack);

	public void finishedInstall(String packageName, File folder, PackageDescriptor pack);

	public void sessionComplete(boolean error);

}
"
CancelledException.java,context,"package org.processmining.framework.packages.impl;

import org.xml.sax.SAXException;

public class CancelledException extends SAXException {

	/**
	 * 
	 */
	private static final long serialVersionUID = -1288614934031744810L;

}
"
PackageConfigPerister.java,context,"package org.processmining.framework.packages.impl;

import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStream;
import java.io.Writer;
import java.net.MalformedURLException;
import java.net.URL;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import javax.xml.parsers.ParserConfigurationException;
import javax.xml.parsers.SAXParser;
import javax.xml.parsers.SAXParserFactory;

import org.processmining.framework.boot.Boot;
import org.processmining.framework.packages.PackageDescriptor;
import org.processmining.framework.packages.PackageDescriptor.OS;
import org.processmining.framework.packages.PackageManager;
import org.processmining.framework.packages.PackageManager.Canceller;
import org.processmining.framework.packages.PackageSet;
import org.processmining.framework.packages.Repository;
import org.xml.sax.Attributes;
import org.xml.sax.SAXException;
import org.xml.sax.helpers.DefaultHandler;

public class PackageConfigPerister {

	private static final String nl = System.getProperty(""line.separator"");

	private PackageConfigPerister() {
	}

	public static void read(File f, Set<Repository> repositories, PackageSet available, PackageSet installed,
			Canceller canceller) throws ParserConfigurationException, SAXException, IOException {
		InputStream is = new BufferedInputStream(new FileInputStream(f));
		try {
			read(is, repositories, available, installed, canceller);
		} finally {
			is.close();
		}
	}

	public static void read(InputStream is, Set<Repository> repositories, PackageSet available, PackageSet installed,
			Canceller canceller) throws ParserConfigurationException, SAXException, IOException {
		BufferedInputStream bis = new BufferedInputStream(is);
		ConfigHandler handler = new ConfigHandler(repositories, available, installed, canceller);
		SAXParserFactory parserFactory = SAXParserFactory.newInstance();

		parserFactory.setNamespaceAware(false);
		parserFactory.setValidating(false);
		try {
			// Some old JAXP versions may throw the UnsupportedOperation Exception in the next call.
			parserFactory.setSchema(null);
		} catch (UnsupportedOperationException ex) {
			// Ignore.
		}

		SAXParser parser = parserFactory.newSAXParser();
		parser.parse(bis, handler);
		bis.close();
	}

	public static Set<PackageDescriptor> listRepository(InputStream is, Canceller canceller)
			throws ParserConfigurationException, SAXException, IOException {
		Set<Repository> repos = new HashSet<Repository>();
		PackageSet available = new PackageSet();
		PackageSet installed = new PackageSet();

		read(is, repos, available, installed, canceller);
		return available;
	}

	static private class ConfigHandler extends DefaultHandler {

		private static final String PACKAGES = ""packages"";
		private static final String URL_ATTR = ""url"";
		private static final String VERSION_ATTR = ""version"";
		private static final String NAME_ATTR = ""name"";
		private static final String DEPENDENCY = ""dependency"";
		private static final String PACKAGE = ""package"";
		private static final String REPOSITORY = ""repository"";
		private static final String CONFLICT = ""conflict"";
		private static final String DESCRIPTION_ATTR = ""desc"";
		private static final String ORGANISATION_ATTR = ""org"";
		private static final String AUTHOR_ATTR = ""author"";
		private static final String AUTO_ATTR = ""auto"";
		private static final String LICENSE_ATTR = ""license"";
		private static final Object INSTALLED = ""installed-packages"";
		private static final String HAS_PLUGINS_ATTR = ""hasPlugins"";
		private static final String OS_ATTR = ""os"";
		private static final String MAINTAINER_ATTR = ""maintainer"";

		private static final String LOGO_URL_ATTR = ""logo"";
		private static final String KEYWORDS_ATTR = ""keywords"";

		private Repository curRepo = null;
		private String curPackageName = null;
		private String curPackageVersion = null;
		private final List<String> dependencies = new ArrayList<String>();
		private final List<String> conflicts = new ArrayList<String>();
		private String curPackageURL;
		private String curLogoURL;
		private String curPackageDesc;
		private String curPackageOrg;
		private String curPackageAuthor;
		private String curPackageLicense;
		private String curPackageAutoInstalled;
		private String curPackageHasPlugins;
		private boolean insideInstalled = false;

		private final Set<Repository> repositories;
		private final Set<PackageDescriptor> available;
		private final Set<PackageDescriptor> installed;
		private final Canceller canceller;
		private String curPackageOS;
		private String curPackageMaintainer;
		private String curKeywords;
		private URL contextURL;
		
		public ConfigHandler(Set<Repository> repositories, Set<PackageDescriptor> available,
				Set<PackageDescriptor> installed, Canceller canceller) {
			this.available = available;
			this.installed = installed;
			this.repositories = repositories;
			this.canceller = canceller;
			
			/*
			 * Set a context for the URLs. This allows us to use relative URLs in the repositories.
			 */
			String repository = Boot.DEFAULT_REPOSITORY.toString();
			int lastPathSeparator = repository.lastIndexOf(""/"");
			String context = repository.substring(0, lastPathSeparator + 1);
			try {
				this.contextURL = new URL(context);
			} catch (MalformedURLException e) {
				try {
					this.contextURL = new URL(""http://www.promtools.org/prom6/packages/"");
				} catch (MalformedURLException e2) {
					assert(false);
				}
			}
			System.out.println(""[PackageConfigPerister] Context URL set to "" + this.contextURL);
		}

		@Override
		public void startElement(String uri, String local, String qName, Attributes attributes) throws SAXException {
			if ((canceller != null) && canceller.isCancelled()) {
				throw new CancelledException();
			}
			qName = qName.toLowerCase();

			if ((curRepo == null) && (curPackageName == null)) {
				if (qName.equals(INSTALLED)) {
					insideInstalled = true;
				} else if (!insideInstalled && qName.equals(REPOSITORY)) {
					String url = attributes.getValue(URL_ATTR);

					if ((url != null) && (url.trim().length() > 0)) {
						try {
							/*
							 * Use the context for URLs.
							 */
							curRepo = new Repository(new URL(contextURL, url.trim()));
						} catch (MalformedURLException e) {
							System.err.println(""Invalid URL for repository, skipping: "" + url);
						}
					}
				} else if (qName.equals(PACKAGE)) {
					String name = attributes.getValue(NAME_ATTR);
					String version = attributes.getValue(VERSION_ATTR);
					String url = attributes.getValue(URL_ATTR);
					String logo = attributes.getValue(LOGO_URL_ATTR);
					String desc = attributes.getValue(DESCRIPTION_ATTR);
					String org = attributes.getValue(ORGANISATION_ATTR);
					String license = attributes.getValue(LICENSE_ATTR);
					String author = attributes.getValue(AUTHOR_ATTR);
					String auto = attributes.getValue(AUTO_ATTR);
					String hasPlugins = attributes.getValue(HAS_PLUGINS_ATTR);
					String os = attributes.getValue(OS_ATTR);
					String maintainer = attributes.getValue(MAINTAINER_ATTR);
					String keywords = attributes.getValue(KEYWORDS_ATTR);

					if ((name != null) && (name.trim().length() > 0) && //
							(version != null) && (version.trim().length() > 0) && //
							(os != null) && (os.trim().length() > 0) && //
							(url != null) && (url.trim().length() > 0)) {
						curPackageName = name;
						curPackageVersion = version;
						try {
							/*
							 * Use the context for URLs.
							 */
							curPackageURL = new URL(contextURL, url).toString();
						} catch (MalformedURLException e) {
							/*
							 * Use of context not possible. As before.
							 */
							curPackageURL = url;
						}
						curPackageOS = os;
						if (logo != null) {
							try {
								/*
								 * Use the context for logo URLs.
								 */
								curLogoURL = new URL(contextURL, logo).toString();
							} catch (MalformedURLException e) {
								/*
								 * Use of context not possible. As before.
								 */
								curLogoURL = """";
							}
						} else {
							curLogoURL = """";
						}
						curPackageDesc = desc == null ? """" : desc;
						curPackageOrg = org == null ? """" : org;
						curPackageLicense = license == null ? """" : license;
						curPackageAuthor = author == null ? """" : author;
						curPackageMaintainer = maintainer == null ? author : maintainer;
						curPackageAutoInstalled = auto == null ? """" : auto;
						curPackageHasPlugins = hasPlugins == null ? """" : hasPlugins;
						curKeywords = keywords == null ? """" : keywords;
						dependencies.clear();
						conflicts.clear();
					}
				}
			} else if ((curPackageName != null) && qName.equals(DEPENDENCY)) {
				String name = attributes.getValue(NAME_ATTR);

				if ((name != null) && (name.trim().length() > 0)) {
					dependencies.add(name);
				}
			} else if ((curPackageName != null) && qName.equals(CONFLICT)) {
				String name = attributes.getValue(NAME_ATTR);

				if ((name != null) && (name.trim().length() > 0)) {
					conflicts.add(name);
				}
			}
		}

		@Override
		public void endElement(String uri, String local, String qName) throws SAXException {
			if ((canceller != null) && canceller.isCancelled()) {
				throw new CancelledException();
			}
			qName = qName.toLowerCase();

			if (qName.equals(INSTALLED)) {
				insideInstalled = false;
			} else if ((curRepo != null) && qName.equals(REPOSITORY)) {
				repositories.add(curRepo);
				curRepo = null;
			} else if ((curPackageName != null) && qName.equals(PACKAGE)) {
				OS os = OS.fromString(curPackageOS);
				if (os.isUsable()) {
					PackageDescriptor pack = new PackageDescriptor(curPackageName, curPackageVersion, os,
							curPackageDesc, curPackageOrg, curPackageAuthor, curPackageMaintainer, curPackageLicense,
							curPackageURL, curLogoURL,  curKeywords, ""true"".equals(curPackageAutoInstalled), !""false""
									.equals(curPackageHasPlugins), dependencies, conflicts);
					if (insideInstalled) {
						installed.add(pack);
					} else {
						if (Boot.HIDE_OLD_PACKAGES) {
							// Suggested by Massimiliano de Leoni
							PackageDescriptor foundPack = null;
							for (PackageDescriptor availablePack : available) {
								if (availablePack.getName().equals(pack.getName())) {
									foundPack = availablePack;
									break;
								}
							}
							if (foundPack != null) {
								if (foundPack.getVersion().lessThan(pack.getVersion())) {
									available.remove(foundPack);
									available.add(pack);
								} else {
									// Skip, pack is dominated by foundPack.
								}
							} else {
								available.add(pack);
							}
						} else {
							available.add(pack);
						}
					}
				}
				curPackageName = null;
			}
		}
	}

	public static void write(File config, Set<Repository> repositories, Set<PackageDescriptor> available,
			Set<PackageDescriptor> installed) throws IOException {
		Writer writer = new FileWriter(config);

		// TODO properly escape all raw strings

		writer.write(""<?xml version=\""1.0\"" encoding=\""iso-8859-1\""?>"" + nl);
		writer.write(""<"" + ConfigHandler.PACKAGES + "">"" + nl);
		for (Repository repo : repositories) {
			writer.write(""  <"" + ConfigHandler.REPOSITORY + "" "" + ConfigHandler.URL_ATTR + ""=\"""" + repo.getURL() + ""\""""
					+ "" />"" + nl);
		}
		for (PackageDescriptor pack : available) {
			/*
			 * Do not write to local repo if known to be unavailable.
			 */
			if (PackageManager.getInstance().isAvailable(pack)) {
				writePackage(pack, writer);
			}
		}
		writer.write(""  <"" + ConfigHandler.INSTALLED + "">"" + nl);
		for (PackageDescriptor pack : installed) {
			writePackage(pack, writer);
		}
		writer.write(""  </"" + ConfigHandler.INSTALLED + "">"" + nl);

		writer.write(""</"" + ConfigHandler.PACKAGES + "">"" + nl);
		writer.close();
	}

	private static void writePackage(PackageDescriptor pack, Writer writer) throws IOException {
		writer.write(""  <"" + ConfigHandler.PACKAGE + //
				"" "" + ConfigHandler.NAME_ATTR + ""=\"""" + pack.getName() + ""\"""" + //
				"" "" + ConfigHandler.VERSION_ATTR + ""=\"""" + pack.getVersion() + ""\"""" + //
				"" "" + ConfigHandler.OS_ATTR + ""=\"""" + pack.getOS().getName() + ""\"""" + //
				"" "" + ConfigHandler.URL_ATTR + ""=\"""" + pack.getURL() + ""\"""" + //
				"" "" + ConfigHandler.DESCRIPTION_ATTR + ""=\"""" + pack.getDescription() + ""\"""" + //
				"" "" + ConfigHandler.ORGANISATION_ATTR + ""=\"""" + pack.getOrganisation() + ""\"""" + //
				"" "" + ConfigHandler.AUTO_ATTR + ""=\"""" + (pack.getAutoInstalled() ? ""true"" : ""false"") + ""\"""" + //
				"" "" + ConfigHandler.HAS_PLUGINS_ATTR + ""=\"""" + (pack.hasPlugins() ? ""true"" : ""false"") + ""\"""" + //
				"" "" + ConfigHandler.LICENSE_ATTR + ""=\"""" + pack.getLicense() + ""\"""" + //
				"" "" + ConfigHandler.AUTHOR_ATTR + ""=\"""" + pack.getAuthor() + ""\"""" + //
				"" "" + ConfigHandler.MAINTAINER_ATTR + ""=\"""" + pack.getMaintainer() + ""\"""" + //
				"" "" + ConfigHandler.LOGO_URL_ATTR + ""=\"""" + pack.getLogoURL() + ""\"""" + //
				"" "" + ConfigHandler.KEYWORDS_ATTR + ""=\"""" + pack.getKeywords() + ""\"""" + //
				"">"" + nl);
		for (String dep : pack.getDependencies()) {
			writer.write(""    <"" + ConfigHandler.DEPENDENCY + "" "" + ConfigHandler.NAME_ATTR + ""=\"""" + dep + ""\""""
					+ "" />"" + nl);
		}
		for (String confl : pack.getConflicts()) {
			writer.write(""    <"" + ConfigHandler.CONFLICT + "" "" + ConfigHandler.NAME_ATTR + ""=\"""" + confl + ""\""""
					+ "" />"" + nl);
		}
		writer.write(""  </"" + ConfigHandler.PACKAGE + "">"" + nl);
	}
}
"
PackageDescriptor.java,context,"package org.processmining.framework.packages;

import java.io.File;
import java.util.Collections;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Set;

import org.processmining.framework.util.OsUtil;

public class PackageDescriptor implements Comparable<PackageDescriptor> {

	public static enum OS {
		WIN64(""win64"", OsUtil.isRunningWindows() && OsUtil.is64Bit()), //
		WIN32(""win32"", OsUtil.isRunningWindows() && OsUtil.is32Bit()), //
		LIN32(""linux32"", OsUtil.isRunningLinux() && OsUtil.is32Bit()), //
		LIN64(""linux64"", OsUtil.isRunningLinux() && OsUtil.is64Bit()), //
		MAC(""mac"", OsUtil.isRunningMacOsX()), //
		ALL(""all"", true);

		private final String name;
		private final boolean usable;

		private OS(String name, boolean usable) {
			this.name = name;
			this.usable = usable;
		}

		public String getName() {
			return name;
		}

		public static OS fromString(String curPackageOS) {
			for (OS os : OS.values()) {
				if (os.name.equals(curPackageOS)) {
					return os;
				}
			}
			return ALL;
		}

		public boolean isUsable() {
			return usable;
		}
	}

	private final String name;
	private final PackageVersion version;
	private final String description;
	private final String organisation;
	private final String author;
	private final String license;
	private final String url;
	private final boolean autoInstalled;
	private final boolean hasPlugins;
	private final Set<String> dependencies;
	private final Set<String> conflicts;
	private boolean broken;
	private final String logoUrl;
	private final OS os;
	private final String maintainer;
	private final String keywords;

	public PackageDescriptor(String name, String version, OS os, String description, String organisation,
			String author, String maintainer, String license, String url, String logoUrl, String keywords,
			boolean autoInstalled, boolean hasPlugins, List<String> dependencies, List<String> conflicts) {
		this.name = name;
		this.os = os;
		this.maintainer = maintainer;
		this.logoUrl = logoUrl;
		this.autoInstalled = autoInstalled;
		this.hasPlugins = hasPlugins;
		this.version = new PackageVersion(version);
		this.description = description;
		this.organisation = organisation;
		this.author = author;
		this.license = license;
		this.url = url;
		this.keywords = keywords;
		this.dependencies = Collections.unmodifiableSet(new HashSet<String>(dependencies));
		this.conflicts = Collections.unmodifiableSet(new HashSet<String>(conflicts));
		broken = false;
	}

	@Override
	public String toString() {
		return name + ""-"" + version;
	}

	@Override
	public boolean equals(Object other) {
		if (!(other instanceof PackageDescriptor)) {
			return false;
		}
		return name.equals(((PackageDescriptor) other).name) && //
				version.equals(((PackageDescriptor) other).version) && //
				os.equals(((PackageDescriptor) other).os);
	}

	@Override
	public int hashCode() {
		return name.hashCode() * 37 + version.hashCode();
	}

	public String getName() {
		return name;
	}

	public PackageVersion getVersion() {
		return version;
	}

	public String getURL() {
		return url;
	}

	public String getLogoURL() {
		return logoUrl;
	}

	public Set<String> getDependencies() {
		return dependencies;
	}

	public Set<String> getConflicts() {
		return conflicts;
	}

	public File getLocalPackageDirectory() {
		return new File(PackageManager.getInstance().getPackagesDirectory(), makeFilename(name + ""-"" + version));
	}

	private static String makeFilename(String filename) {
		return filename.toLowerCase().replaceAll(""[^a-zA-Z0-9-.]"", ""_"");
	}

	public void setHasBrokenDependencies() {
		broken = true;
	}

	public boolean hasBrokenDependencies() {
		return broken;
	}

	public String getDescription() {
		return description;
	}

	public String getOrganisation() {
		return organisation;
	}

	public String getAuthor() {
		return author;
	}

	public String getLicense() {
		return license;
	}

	public OS getOS() {
		return os;
	}

	public String getMaintainer() {
		return maintainer;
	}

	public String getKeywords() {
		return keywords;
	}

	public boolean getAutoInstalled() {
		return autoInstalled;
	}

	public boolean hasPlugins() {
		return hasPlugins;
	}

	public String toHTML() {
		StringBuffer buffer = new StringBuffer();

		buffer.append(""<HTML><TABLE>"");
		buffer.append(""<TR><TD>Package:</TD><TD>"" + description + ""</TD></TR>"");
		buffer.append(""<TR><TD>Version:</TD><TD>"" + version + ""</TD></TR>"");
		buffer.append(""<TR><TD>Organisation:</TD><TD>"" + organisation + ""</TD></TR>"");
		buffer.append(""<TR><TD>Author(s):</TD><TD>"" + author + ""</TD></TR>"");
		buffer.append(""<TR><TD>Maintained by:</TD><TD>"" + maintainer + ""</TD></TR>"");
		buffer.append(""<TR><TD>License:</TD><TD>"" + license + ""</TD></TR>"");

		buffer.append(""<TR><TD>Dependencies:</TD>"");
		if (dependencies.isEmpty()) {
			buffer.append(""<TD>none</TD></TR>"");
		} else {
			for (Iterator<String> it = dependencies.iterator(); it.hasNext();) {
				buffer.append(""<TD>"" + it.next() + ""</TD></TR>"");
				if (it.hasNext()) {
					buffer.append(""<TR><TD> </TD>"");
				}
			}
		}
		buffer.append(""<TR><TD>Conflicts:</TD>"");
		if (conflicts.isEmpty()) {
			buffer.append(""<TD>none</TD></TR>"");
		} else {
			for (Iterator<String> it = conflicts.iterator(); it.hasNext();) {
				buffer.append(""<TD>"" + it.next() + ""</TD></TR>"");
				if (it.hasNext()) {
					buffer.append(""<TR><TD> </TD>"");
				}
			}
		}

		buffer.append(""</TABLE></HTML>"");

		return buffer.toString();
	}

	public int compareTo(PackageDescriptor pack) {
		if (pack.name.equals(name)) {
			if (version.equals(pack.version)) {
				return os.compareTo(pack.os);
			}
			return -version.compareTo(pack.version);
		}
		return name.compareTo(pack.name);
	}
}
"
PackageManager.java,context,"package org.processmining.framework.packages;

import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.HttpURLConnection;
import java.net.MalformedURLException;
import java.net.URL;
import java.net.URLConnection;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.SortedSet;
import java.util.TreeSet;
import java.util.prefs.BackingStoreException;
import java.util.prefs.Preferences;

import javax.xml.parsers.ParserConfigurationException;

import org.apache.commons.compress.archivers.zip.ZipArchiveEntry;
import org.apache.commons.compress.archivers.zip.ZipFile;
import org.processmining.framework.boot.Boot;
import org.processmining.framework.boot.Boot.Level;
import org.processmining.framework.packages.events.PackageManagerListener;
import org.processmining.framework.packages.impl.CancelledException;
import org.processmining.framework.packages.impl.PackageConfigPerister;
import org.processmining.framework.plugin.impl.PluginCacheEntry;
import org.processmining.framework.plugin.impl.PluginManagerImpl;
import org.processmining.framework.util.OsUtil;
import org.xml.sax.SAXException;

/*
 * Package manager goals: - Packages are completely independent from plugins and
 * are simply a distribution mechanism - Easy to provide a package as a single
 * zip or jar file, with an xml description file - Easy addition of custom
 * repositories - Transparent caching of packages - Transparent use in
 * development - Should be possible to depend on / resolve packages in an Ant
 * script - Should be easy to develop a package in Eclipse - Versions need to be
 * managed and version conflicts need to be resolved - Handles (possibly
 * transitive and circular) dependencies - Cleaning out all files from the
 * package directory of packages which are de-installed
 * 
 * @author peter
 */
public class PackageManager {
	private final static String DO_AUTO_UPDATES = ""do_auto_updates"";
	private static final String LITE_VERSION_INSTALLED = ""lite_version_installed"";

	public static interface Canceller {
		public boolean isCancelled();
	}

	private static final String TEMP_INSTALL_DIR_POSTFIX = ""-temp-install-dir"";
	private static final String CONFIG_XML = ""packages.xml"";

	private static final String nl = System.getProperty(""line.separator"");

	private static final int UNIX_OWNER_EXECUTABLE_BIT = 64;

	private static PackageManager instance = null;
	private final Set<Repository> repositories = new HashSet<Repository>();
	private final PackageSet installed = new PackageSet();
	private final PackageSet available = new PackageSet();

	/*
	 * Maps every package descriptor to whether it is still available. This map
	 * acts as a cache to prevent us from have to access the URL over and over
	 * again.
	 * 
	 * This map is also used by PackageConfigPersiter when writing the packages
	 * to the local repo again. As a result, packages that are known to be
	 * unavailable will not be written back to the local repo.
	 */
	private Map<PackageDescriptor, Boolean> availability;
	
	/**
	 * Checks whether a package is still available. This prevents the user from
	 * installing or updating a package that cannot be installed anymore.
	 * 
	 * @param descriptor
	 *            The descriptor of the package.
	 * @return Whether the URL of the package descriptor can be opened
	 *         successfully.
	 */
	public boolean isAvailable(PackageDescriptor descriptor) {
		if (!Boot.CHECK_PACKAGES) {
			return true;
		}
		/*
		 * First check the cache.
		 */
		if (availability.containsKey(descriptor)) {
			/*
			 * In cache, return cached result.
			 */
			return availability.get(descriptor);
		}
		/*
		 * Not in cache, check whether URL still exists.
		 */
		InputStream is = null;
		try {
			URL url = new URL(descriptor.getURL());
			URLConnection conn = url.openConnection();
			if (conn instanceof HttpURLConnection) {
				HttpURLConnection httpCon = (HttpURLConnection) conn;
				if (Boot.CONNECT_TIMEOUT > 0) {
					httpCon.setConnectTimeout(Boot.CONNECT_TIMEOUT);
				}
				if (Boot.READ_TIMEOUT > 0) {
					httpCon.setReadTimeout(Boot.READ_TIMEOUT);
				}
				//					httpCon.connect();
			}

			is = conn.getInputStream();
		} catch (Exception e) {
			/*
			 * Something's wrong with this URL. Mark it as unavailable.
			 */
			System.err.println(""Package found in local repository, but not in global repository: "" + descriptor);
			availability.put(descriptor, false);
			return false;
		} finally {
			try {
				is.close();
			} catch (Exception e) {
			}
		}
		//		System.out.println(""Package available: ""+ descriptor);
		/*
		 * All fine, still available. Mark it as such.
		 */
		availability.put(descriptor, true);
		return true;
	}

	private PackageManager() {
		availability = new HashMap<PackageDescriptor, Boolean>();
	}

	private final PackageManagerListener.ListenerList listeners = new PackageManagerListener.ListenerList();
	private PackageStateReport report = null;
	private Canceller canceller = null;
	private boolean doAutoUpdate = false;
	private Preferences preferences = Preferences.userNodeForPackage(getClass());

	public static PackageManager getInstance() {
		if (instance == null) {
			instance = new PackageManager();
		}
		return instance;
	}

	public static void main(String[] args) {
		System.exit(new CommandLineInterface(getInstance()).run(args));
	}

	private File getConfigFile() {
		return new File(OsUtil.getProMPackageDirectory(), CONFIG_XML);
	}

	public void addListener(PackageManagerListener listener) {
		listeners.add(listener);
	}

	public void removeListener(PackageManagerListener listener) {
		listeners.remove(listener);
	}

	public File getPackagesDirectory() {
		return new File(Boot.PACKAGE_FOLDER);
	}

	public void initialize(Boot.Level verbose) {

		doAutoUpdate = Boolean.parseBoolean(preferences.get(DO_AUTO_UPDATES, Boolean.FALSE.toString()));

		String liteVersion = preferences.get(LITE_VERSION_INSTALLED, ""UNKNOWN"");
		if (Boot.PROM_VERSION.startsWith(Boot.LITE_PREFIX) && !liteVersion.equals(Boot.PROM_VERSION)) {
			preferences.put(LITE_VERSION_INSTALLED, Boot.PROM_VERSION);
			if (verbose == Level.ALL) {
				System.out.println("">>> New ProM-Lite installation found."");
				System.out.println("">>> Clearing package cache."");
			}
			try {
				cleanPackageCache();
			} catch (BackingStoreException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}

		getPackagesDirectory().mkdirs();
		File config = getConfigFile();

		if (verbose == Level.ALL) {
			System.out.println("">>> Loading packages from "" + config.getAbsolutePath());
		}

		try {
			writeDefaultConfigIfNeeded(config);

			repositories.clear();
			available.clear();
			installed.clear();
			PackageConfigPerister.read(config, repositories, available, installed, canceller);
			resolveAllConflicts(verbose);

		} catch (Exception e) {
			listeners.fireException(e);
		}
	}

	private void scanRepositories(Boot.Level verbose) throws ParserConfigurationException, SAXException, IOException {

		final Comparator<Repository> comp = new Comparator<Repository>() {

			public int compare(Repository o1, Repository o2) {
				return o1.getURL().toString().compareTo(o2.getURL().toString());
			}
		};

		Set<Repository> read = new TreeSet<Repository>(comp);
		Set<Repository> toRead = new TreeSet<Repository>(comp);
		toRead.addAll(repositories);

		toRead.add(new Repository(Boot.DEFAULT_REPOSITORY));
		while (!toRead.isEmpty()) {
			for (Repository rep : toRead) {
				URL packages = rep.getURL();
				if (verbose == Level.ALL) {
					System.out.println("">>> Loading packages from "" + packages);
				}
				URLConnection conn = packages.openConnection();
				if (conn instanceof HttpURLConnection) {
					HttpURLConnection httpCon = (HttpURLConnection) conn;
					if (Boot.CONNECT_TIMEOUT > 0) {
						httpCon.setConnectTimeout(Boot.CONNECT_TIMEOUT);
					}
					if (Boot.READ_TIMEOUT > 0) {
						httpCon.setReadTimeout(Boot.READ_TIMEOUT);
					}
					//					httpCon.connect();
				}
				long time = -System.currentTimeMillis();
				try {
					PackageConfigPerister.read(conn.getInputStream(), repositories, available, installed, canceller);
					time += System.currentTimeMillis();
					if (Boot.VERBOSE == Level.ALL) {
						System.out.println(""Read package in "" + time + "" milliseconds."");
					}
				} catch (FileNotFoundException e) {
					// did not find the file for some package
					time += System.currentTimeMillis();
					if (Boot.VERBOSE != Level.NONE) {
						System.err.println(""Failed to read package (file not found)."");
					}
				} catch (IOException e) {
					time += System.currentTimeMillis();
					if (Boot.VERBOSE != Level.NONE) {
						System.err.println(""Failed to read package in "" + time + "" milliseconds."");
					}
				}
			}
			read.addAll(toRead);
			toRead.clear();
			toRead.addAll(repositories);
			toRead.removeAll(read);
		}

	}

	private void writeDefaultConfigIfNeeded(File config) throws IOException {
		config.createNewFile();
		if (config.length() == 0) {
			PackageConfigPerister
					.write(config,
							new HashSet<Repository>(Arrays.asList(new Repository[] { new Repository(
									Boot.DEFAULT_REPOSITORY) })), new HashSet<PackageDescriptor>(),
							new HashSet<PackageDescriptor>());
		}
	}

	private void resolveAllConflicts(Boot.Level verbose) throws UnknownPackageException {
		boolean ok;

		do {
			ok = true;

			Map<String, PackageDescriptor> enabled = new HashMap<String, PackageDescriptor>();
			for (PackageDescriptor pack : getEnabledPackages()) {
				enabled.put(pack.getName(), pack);
			}
			for (PackageDescriptor pack : enabled.values()) {
				for (String dep : pack.getDependencies()) {
					PackageDescriptor p = enabled.get(dep);

					if (p == null) {
						pack.setHasBrokenDependencies();
						ok = false;

						if (verbose == Level.ALL) {
							System.out.println(""     deactivating: "" + pack + "" (missing at least "" + dep + "")"");
						}
						break;
					}
				}
				for (String conf : pack.getConflicts()) {
					PackageDescriptor p = enabled.get(conf);

					if (p != null) {
						pack.setHasBrokenDependencies();
						ok = false;

						if (verbose == Level.ALL) {
							System.out
									.println(""     deactivating: "" + pack + "" (conflicts with at least "" + conf + "")"");
						}
						break;
					}
				}
			}
		} while (!ok);
	}

	public String toString() {
		StringBuffer result = new StringBuffer();
		Set<PackageDescriptor> allPackages = new HashSet<PackageDescriptor>();

		for (Repository repo : repositories) {
			result.append(""Repository: "" + repo.getURL() + nl);
		}

		allPackages.addAll(installed);
		allPackages.addAll(available);
		for (PackageDescriptor pack : allPackages) {
			String status;

			if (installed.contains(pack)) {
				if (!pack.hasBrokenDependencies()) {
					status = ""I"";
				} else {
					status = ""M"";
				}
				boolean hasUpgrade = false;
				if (available.contains(pack)) {
					for (PackageDescriptor p : available) {
						if (p.equals(pack)) {
							hasUpgrade = pack.getVersion().lessThan(p.getVersion());
							break;
						}
					}
				}
				status += hasUpgrade ? ""+"" : "" "";
			} else {
				status = ""A "";
			}
			result.append(status + "" "" + pack);
			result.append(nl);
			if (!pack.getDependencies().isEmpty()) {
				result.append(""      (depends on: "" + pack.getDependencies() + "")"" + nl);
			}
			if (!pack.getConflicts().isEmpty()) {
				result.append(""      (conflicts with: "" + pack.getConflicts() + "")"" + nl);
			}
		}
		return result.toString();
	}

	public Set<Repository> getRepositories() {
		return Collections.unmodifiableSet(repositories);
	}

	//	public void addRepository(Repository repository) {
	//		repositories.add(repository);
	//		save();
	//	}

	public void removeRepository(Repository repository) {
		repositories.remove(repository);
		save();
	}

	public Set<PackageDescriptor> getInstalledPackages() {
		return Collections.unmodifiableSet(installed);
	}

	public Set<PackageDescriptor> getAvailablePackages() {
		return Collections.unmodifiableSet(available);
	}

	public Collection<PackageDescriptor> getEnabledPackages() throws UnknownPackageException {
		List<PackageDescriptor> result = new ArrayList<PackageDescriptor>();

		Set<PackageDescriptor> broken = new HashSet<PackageDescriptor>();

		Set<PackageDescriptor> installed = new HashSet<PackageDescriptor>(this.installed);

		/*
		 * During every iteration we should be able to add at least one package
		 * to the result set. Hence, we should need at most as many iterations
		 * as we have packages to add. If after this number if iterations some
		 * packages have not yet been added, there should be a cyclic dependency
		 * somewhere between the remaining packages.
		 * 
		 * Initialize the number of iterations we have still left.
		 */
		int iterationsLeft = installed.size();

		/*
		 * Iterate as long as needed.
		 */
		while (!installed.isEmpty() && iterationsLeft > 0) {
			Set<String> requiredPackages = new HashSet<String>();

			Iterator<PackageDescriptor> it = installed.iterator();
			while (it.hasNext()) {
				PackageDescriptor pack = it.next();
				if (pack.hasBrokenDependencies()) {
					broken.add(pack);
					it.remove();
				} else {

					if (getPackageMap(result).keySet().containsAll(pack.getDependencies())) {
						result.add(pack);
						it.remove();
					} else {
						// remember all packages that have been required
						requiredPackages.addAll(pack.getDependencies());
					}
				}
			}

			// after this iteration check whether we have any chance to resolve
			// the remaining dependencies: if not, throw an exception
			Set<String> listedPackages = new HashSet<String>(getPackageMap(this.installed).keySet());
			requiredPackages.removeAll(listedPackages);
			if (!requiredPackages.isEmpty()) {
				for (String required : requiredPackages) {
					System.out.println(""Cannot find required package: "" + required);
				}
				throw new UnknownPackageException(requiredPackages.toString());
			}
			/*
			 * One less iteration left.
			 */
			iterationsLeft--;
		}

		if (installed.isEmpty()) {
			if (Boot.VERBOSE == Level.ALL) {
				System.out.println("">>> All dependencies have been resolved"");
			}
		} else {
			if (Boot.VERBOSE != Level.NONE) {
				System.err.println("">>> The dependencies for the following packages have not been resolved:"");
				for (PackageDescriptor pack : installed) {
					System.err.println("">>>     "" + pack + "" "" + pack.getDependencies());
				}
			}
		}

		return result;
	}

	private void save() {
		try {
			PackageConfigPerister.write(getConfigFile(), repositories, available, installed);
		} catch (IOException e) {
			listeners.fireException(e);
			return;
		}
	}

	public void update(boolean autoInstall, Boot.Level verbose) throws CancelledException, UnknownPackageTypeException {

		try {
			scanRepositories(verbose);
		} catch (Exception e) {
			// continue with known repositories
			e.printStackTrace();
		}
		Map<String, SortedSet<PackageDescriptor>> map = PackageManager.getPackageMap(available);

		Set<PackageDescriptor> packs = new HashSet<PackageDescriptor>();

		// TODO allow clients to monitor progress and report errors

		//		for (Repository repository : repositories) {
		//			if ((canceller != null) && canceller.isCancelled()) {
		//				return;
		//			}
		//			System.out.println(""Updating: "" + repository);
		//			try {
		//				InputStream is = repository.getURL().openStream();
		//
		//				try {
		//					packs.addAll(PackageConfigPerister.listRepository(is, canceller));
		//				} catch (ParserConfigurationException e) {
		//					listeners.fireException(e);
		//					throw new CancelledException();
		//				} catch (CancelledException e) {
		//					throw e;
		//				} catch (SAXException e) {
		//					listeners.fireException(e);
		//					throw new CancelledException();
		//				} finally {
		//					is.close();
		//				}
		//			} catch (IOException e) {
		//				listeners.fireException(e);
		//				throw new CancelledException();
		//			}
		//			System.out.println(""Done updating: "" + repository);
		//		}
		//
		//		available.clear();
		//		available.addAll(packs);

		if (autoInstall) {
			List<PackageDescriptor> toRemove = new ArrayList<PackageDescriptor>();
			List<PackageDescriptor> toInstall = new ArrayList<PackageDescriptor>();
			for (PackageDescriptor pack : packs) {
				PackageDescriptor inst = findInstalledVersion(pack);
				if ((inst != null) && inst.getVersion().lessThan(pack.getVersion())) {
					// package was already installed, but new version is available.
					// old version remains, just in case this is required by some
					// existing plugins.
					System.out.println(""Found new version of installed package: "" + pack.getName());
					toInstall.add(pack);
					toRemove.add(inst);
				} else if ((inst == null) && pack.hasPlugins()) {
					// Install all available packages that carry plugins.
					System.out.println(""Found new package which contains plugins: "" + pack.getName());
					toInstall.add(pack);
					for (String dep : pack.getDependencies()) {
						if (!containsPackage(installed, dep)) {
							SortedSet<PackageDescriptor> packages = map.get(dep);
							if ((packages == null) || packages.isEmpty()) {
								toInstall.remove(pack);
								continue;
							}
							boolean found = false;
							for (PackageDescriptor p : packages) {
								toInstall.add(p);
								found = true;
								break;
							}
							if (!found) {
								toInstall.remove(pack);
							}

						}
					}
				}
			}
			if (!toInstall.isEmpty()) {
				System.out.println(""Installing packages: "" + toInstall.toString());
				install(toInstall);
				uninstall(toRemove);
				// execute does a save, no need to do that twice.
			} else {
				save();
			}
		} else {
			save();
		}
	}

	public PackageDescriptor findInstalledVersion(PackageDescriptor pack) {
		for (PackageDescriptor p : installed) {
			if (p.getName().equals(pack.getName())) {
				return p;
			}
		}
		return null;
	}

	public PackageDescriptor[] findOrInstallPackages(String... packageNames) throws UnknownPackageTypeException,
			UnknownPackageException, CancelledException {

		if (doAutoUpdate) {
			update(false, Level.NONE);
		}

		PackageDescriptor[] result = new PackageDescriptor[packageNames.length];
		List<PackageDescriptor> toInstall = new ArrayList<PackageDescriptor>(result.length);

		// First, consider all available packages
		Map<String, SortedSet<PackageDescriptor>> map = PackageManager.getPackageMap(available);

		// Check for each package if it might be installed
		for (int i = 0; i < packageNames.length; i++) {
			SortedSet<PackageDescriptor> packages = map.get(packageNames[i]);
			if ((packages == null) || packages.isEmpty()) {
				// No package is available with the name: names[i]
				throw new UnknownPackageException(packageNames[i]);
			}

			// Use the first available package for this name.
			// If there are more, they are sorted by 
			// version, latest version first.
			result[i] = packages.first();
			if (!doAutoUpdate) {
				// See if any of the versions is installed. If not,
				// install the latest
				for (PackageDescriptor d : packages) {
					if (installed.contains(d)) {
						result[i] = d;
						break;
					}
				}
			}
			if (!installed.contains(result[i])) {
				toInstall.add(result[i]);
			}

		}
		if (!toInstall.isEmpty()) {
			// Install some packages that were available, but not installed
			install(toInstall);
		}

		return result;
	}

	public void install(List<PackageDescriptor> toInstall) throws UnknownPackageTypeException, CancelledException {
		if ((canceller != null) && canceller.isCancelled()) {
			throw new CancelledException();
		}
		boolean exception = false;
		try {
			listeners.fireSessionStart();
			Set<PackageDescriptor> toAdd = new HashSet<PackageDescriptor>(toInstall);

			Map<String, SortedSet<PackageDescriptor>> map = PackageManager.getPackageMap(available);

			// TODO: rewrite these statements to take care of versions.
			//			// These need to be added
			//			toAdd.removeAll(getInstalledPackages());
			//			// No need to install packages that need to be removed anyway
			//			toAdd.removeAll(toRemove);

			Set<PackageDescriptor> newState = new HashSet<PackageDescriptor>(getInstalledPackages());
			newState.addAll(toAdd);

			checkConsistency(newState);
			boolean error = false;
			do {
				HashSet<String> extra = new HashSet<String>();
				for (Map.Entry<PackageDescriptor, Set<String>> item : report.getMissingDependencies().entrySet()) {
					extra.addAll(item.getValue());
				}
				if (!extra.isEmpty()) {
					for (String s : extra) {
						if (!map.containsKey(s) || map.get(s) == null) {
							// package required that is not available, break.
							error = true;
							System.err.println(""[PackageManager] Package "" + s + "" is not available."");
						} else {
							PackageDescriptor first = map.get(s).first();
							toAdd.add(first);
							newState.add(first);
						}
					}
					checkConsistency(newState);
				}
			} while (!error && !report.getMissingDependencies().isEmpty());

			HashSet<PackageDescriptor> toRemove = new HashSet<PackageDescriptor>();
			while (!error && !report.getPackagesWithMultipleVersions().isEmpty()) {
				// Resolved all dependencies, now check for multiple versions.
				for (Map.Entry<String, SortedSet<PackageDescriptor>> item : report.getPackagesWithMultipleVersions()
						.entrySet()) {
					Iterator<PackageDescriptor> it = item.getValue().iterator();
					it.next();
					while (it.hasNext()) {
						PackageDescriptor p = it.next();
						newState.remove(p);
						toRemove.add(p);
					}
				}
				checkConsistency(newState);
			}

			if (!report.hasErrors()) {
				for (PackageDescriptor pack : toAdd) {
					installPackage(pack);
				}

				installed.clear();
				installed.addAll(newState);

				uninstall(toRemove);

				save();

			}

		} catch (UnknownPackageTypeException e) {
			exception = true;
			throw e;
		} catch (CancelledException e) {
			exception = true;
			throw e;
		} finally {

			// Before propagating the error, make sure to signal the listeners of this error.
			listeners.fireSessionComplete(exception);
		}

	}

	public void uninstall(Collection<PackageDescriptor> toRemove) throws CancelledException {
		if ((canceller != null) && canceller.isCancelled()) {
			throw new CancelledException();
		}

		Set<PackageDescriptor> newState = new HashSet<PackageDescriptor>(getInstalledPackages());
		newState.removeAll(toRemove);

		checkConsistency(newState);
		boolean error = false;
		do {
			// All packages that now have broken dependencies should also be uninstalled
			newState.removeAll(report.getMissingDependencies().keySet());
			checkConsistency(newState);
		} while (!error && !report.getMissingDependencies().isEmpty());

		if (!report.hasErrors()) {

			removePackages(newState);

			installed.clear();
			installed.addAll(newState);

			save();

		}

	}

	public void setCanceller(Canceller canceller) {
		this.canceller = canceller;

	}

	public PackageStateReport getLatestReport() {
		synchronized (report) {
			return report;
		}
	}

	public void checkConsistency() {
		checkConsistency(getInstalledPackages());
	}

	private void checkConsistency(Set<PackageDescriptor> packages) {
		Map<String, SortedSet<PackageDescriptor>> multipleVersions = new HashMap<String, SortedSet<PackageDescriptor>>();
		Map<PackageDescriptor, Set<String>> missing = new HashMap<PackageDescriptor, Set<String>>();
		Map<PackageDescriptor, Set<String>> conflicts = new HashMap<PackageDescriptor, Set<String>>();

		// check whether at most one version of each package is installed
		for (Map.Entry<String, SortedSet<PackageDescriptor>> item : getPackageMap(packages).entrySet()) {
			if (item.getValue().size() > 1) {
				SortedSet<PackageDescriptor> versions = multipleVersions.get(item.getKey());

				if (versions == null) {
					versions = new TreeSet<PackageDescriptor>();
					multipleVersions.put(item.getKey(), versions);
				}
				versions.addAll(item.getValue());
			}
		}

		// check whether all dependencies are satisfied
		for (PackageDescriptor pack : packages) {
			for (String dep : pack.getDependencies()) {
				if (!containsPackage(packages, dep)) {
					Set<String> misses = missing.get(pack);

					if (misses == null) {
						misses = new HashSet<String>();
						missing.put(pack, misses);
					}
					misses.add(dep);
				}
			}
		}

		// check whether all conflicts are satisfied
		for (PackageDescriptor pack : packages) {
			for (String conf : pack.getConflicts()) {
				if (containsPackage(packages, conf)) {
					Set<String> conflictsWith = conflicts.get(pack);

					if (conflictsWith == null) {
						conflictsWith = new HashSet<String>();
						conflicts.put(pack, conflictsWith);
					}
					conflictsWith.add(conf);
				}
			}
		}

		report = new PackageStateReport(multipleVersions, missing, conflicts);
	}

	private boolean containsPackage(Set<PackageDescriptor> packages, String dep) {
		for (PackageDescriptor pack : packages) {
			if (dep.equals(pack.getName())) {
				return true;
			}
		}
		return false;
	}

	public static Map<String, SortedSet<PackageDescriptor>> getPackageMap(Collection<PackageDescriptor> packages) {
		Map<String, SortedSet<PackageDescriptor>> result = new HashMap<String, SortedSet<PackageDescriptor>>();

		for (PackageDescriptor pack : packages) {
			SortedSet<PackageDescriptor> list = result.get(pack.getName());

			if (list == null) {
				list = new TreeSet<PackageDescriptor>();
				result.put(pack.getName(), list);
			}
			list.add(pack);
		}
		return result;
	}

	private void installPackage(PackageDescriptor pack) throws UnknownPackageTypeException, CancelledException {
		File packageDir = pack.getLocalPackageDirectory();
		File tempDir = new File(packageDir.getAbsolutePath() + TEMP_INSTALL_DIR_POSTFIX);
		URL url;
		try {
			url = new URL(pack.getURL());
		} catch (MalformedURLException e) {
			listeners.fireException(e);
			return;
		}

		recursivelyDeleteDir(tempDir);
		recursivelyDeleteDir(packageDir);

		tempDir.mkdirs();
		packageDir.mkdirs();

		if (url.toString().toLowerCase().endsWith("".jar"")) {
			installJar(url, packageDir, pack.getName() + ""-"" + pack.getVersion(), pack);
		} else if (url.toString().toLowerCase().endsWith("".zip"")) {
			installZip(url, tempDir, packageDir, pack.getName() + ""-"" + pack.getVersion(), pack);
		} else {
			throw new UnknownPackageTypeException(pack);
		}
		if (PluginManagerImpl.getInstance() != null) {
			Boot.addJarsForPackage(pack, Level.ALL, PluginManagerImpl.getInstance());
		}
		recursivelyDeleteDir(tempDir);
	}

	private void removePackages(Collection<PackageDescriptor> toKeep) throws CancelledException {
		if ((canceller != null) && canceller.isCancelled()) {
			throw new CancelledException();
		}
		File packageDir = getPackagesDirectory();
		File[] files = packageDir.listFiles();
		Set<File> installations = new HashSet<File>();

		for (PackageDescriptor pack : toKeep) {
			if ((canceller != null) && canceller.isCancelled()) {
				throw new CancelledException();
			}
			installations.add(pack.getLocalPackageDirectory());
		}

		if (files != null) {
			for (File file : files) {
				if (!file.isDirectory()) {
					file.delete();
				} else if (!installations.contains(file)) {
					recursivelyDeleteDir(file);
				}
			}
		}
	}

	/*
	 * private Set<PackageDescriptor>
	 * findReverseDependenciesInInstalled(PackageDescriptor pack) { return
	 * findReverseDependencies(pack, installed); }
	 * 
	 * private Set<PackageDescriptor>
	 * findDependenciesInAvailable(PackageDescriptor pack,
	 * Set<PackageVersionRange> missing) { return findDependencies(pack,
	 * missing, available); }
	 * 
	 * private static Set<PackageDescriptor> findDependencies(PackageDescriptor
	 * pack, Set<PackageVersionRange> missing, Set<PackageDescriptor> packages)
	 * { Set<PackageDescriptor> result = new HashSet<PackageDescriptor>();
	 * Set<PackageVersionRange> todo = new HashSet<PackageVersionRange>();
	 * Set<PackageVersionRange> done = new HashSet<PackageVersionRange>();
	 * 
	 * while (!todo.isEmpty()) { PackageVersionRange dep =
	 * todo.iterator().next(); boolean found = false;
	 * 
	 * todo.remove(dep); done.add(dep);
	 * 
	 * for (PackageDescriptor p : packages) { if (dep.isSatisfiedBy(p)) {
	 * result.add(p); found = true; for (PackageVersionRange r :
	 * p.getDependencies()) { if (!done.contains(r)) { todo.add(r); } } break; }
	 * } if (!found) { missing.add(dep); } } return result; }
	 * 
	 * private static Set<PackageDescriptor>
	 * findReverseDependencies(PackageDescriptor pack, Set<PackageDescriptor>
	 * packages) { Set<PackageDescriptor> result = new
	 * HashSet<PackageDescriptor>();
	 * 
	 * for (PackageDescriptor p : packages) { Set<PackageVersionRange> missing =
	 * new HashSet<PackageVersionRange>(); Set<PackageDescriptor> deps =
	 * findDependencies(p, missing, packages);
	 * 
	 * if (deps.contains(pack)) { result.add(p); } } return result; }
	 */

	private void installZip(URL source, File temp, File unzipTo, String name, PackageDescriptor pack)
			throws CancelledException {
		File sourceZipFile = new File(temp, "".package.zip"");

		// download zip file

		listeners.fireStartDownload(name, source, pack);
		OutputStream out = null;
		try {
			out = new BufferedOutputStream(new FileOutputStream(sourceZipFile));
			copyInputStream(source.openStream(), out);
		} catch (Exception e) {
			listeners.fireException(e);
			throw new CancelledException();
		} finally {
			if (out != null) {
				try {
					out.close();
				} catch (IOException e) {
					throw new CancelledException();
				}
			}

		}

		listeners.fireStartInstall(name, unzipTo, pack);

		try {
			// extract zip file
			ZipFile zipFile = new ZipFile(sourceZipFile);
			Enumeration<?> zipFileEntries = zipFile.getEntries();

			while (zipFileEntries.hasMoreElements()) {
				ZipArchiveEntry entry = (ZipArchiveEntry) zipFileEntries.nextElement();
				File destFile = new File(unzipTo, entry.getName());

				if (entry.isDirectory()) {
					destFile.mkdirs();
				} else {
					destFile.getParentFile().mkdirs();

					OutputStream o = new FileOutputStream(destFile);
					try {
						copyInputStream(zipFile.getInputStream(entry), o);
					} finally {
						o.close();
					}

					//Only for non-windows operating systems: Check if the executable bit was set in the zip-archive,
					//if so, set it on the file system too. (Only checks and sets the owner executable bit.)
					if (!OsUtil.isRunningWindows()
							&& (entry.getUnixMode() & UNIX_OWNER_EXECUTABLE_BIT) == UNIX_OWNER_EXECUTABLE_BIT) {
						destFile.setExecutable(true);
					}
				}

			}
			zipFile.close();
		} catch (Exception e) {
			listeners.fireException(e);
			throw new CancelledException();
		}
		listeners.fireFinishedInstall(name, unzipTo, pack);
	}

	private void installJar(URL source, File dest, String name, PackageDescriptor pack) throws CancelledException {
		InputStream in = null;
		try {
			in = source.openStream();

			OutputStream out = null;
			File outFile = new File(dest, name + "".jar"");
			try {
				out = new FileOutputStream(outFile);
			} catch (FileNotFoundException e) {
				listeners.fireException(e);
				return;
			} finally {
				if (out != null) {
					out.close();
				}
			}
			listeners.fireStartDownload(name, source, pack);
			copyInputStream(in, out);
			listeners.fireStartInstall(name, outFile, pack);

			in.close();
			listeners.fireFinishedInstall(name, outFile, pack);
		} catch (IOException e) {
			listeners.fireException(e);
			throw new CancelledException();
		}
	}

	private void recursivelyDeleteDir(File dir) {
		if (dir.isDirectory()) {
			for (String child : dir.list()) {
				recursivelyDeleteDir(new File(dir, child));
			}
		}
		dir.delete();
	}

	private void copyInputStream(InputStream in, OutputStream out) throws IOException, CancelledException {
		try {
			byte[] buffer = new byte[1024];
			int len;

			while ((len = in.read(buffer)) >= 0) {
				if ((canceller != null) && canceller.isCancelled()) {
					throw new CancelledException();
				}
				out.write(buffer, 0, len);
			}
		} finally {
			try {
				in.close();
			} finally {
				out.close();
			}
		}
	}

	public PackageManagerListener.ListenerList getListeners() {
		return listeners;
	}

	@Deprecated
	public boolean doAutoUpdate() {
		return doAutoUpdate;
	}

	@Deprecated
	public void setAutoUpdate(boolean doAutoUpdate) {
		this.doAutoUpdate = doAutoUpdate;
		this.preferences.put(DO_AUTO_UPDATES, Boolean.toString(doAutoUpdate));

	}

	/**
	 * Cleans the package cache in the registry. This is automatically done for
	 * ProM-Lite the first time when a new version of ProM-Lite is booted.
	 * 
	 * @throws BackingStoreException
	 */
	public void cleanPackageCache() throws BackingStoreException {
		PluginCacheEntry.clearSettingsCache();

	}
}
"
PackageSet.java,context,"package org.processmining.framework.packages;

import java.util.HashSet;

import org.processmining.framework.packages.PackageDescriptor.OS;

public class PackageSet extends HashSet<PackageDescriptor> {

	private static final long serialVersionUID = -5010658216636461231L;

	public boolean add(PackageDescriptor e) {
		if (e.getOS() == OS.WIN64) {
			// check for removal of Win32 version
			for (PackageDescriptor pack : this) {
				if (pack.getName().equals(e.getName()) && //
						pack.getVersion().equals(e.getVersion()) && //
						pack.getOS() == OS.WIN32) {
					remove(pack);
					break;
				}
			}
		} else {
			if (e.getOS() == OS.WIN32) {
				// Check if Win64 version already in the set
				for (PackageDescriptor pack : this) {
					if (pack.getName().equals(e.getName()) && //
							pack.getVersion().equals(e.getVersion()) && //
							pack.getOS() == OS.WIN64) {
						// win64 version already available. Don't add 32 bit version.
						return false;
					}
				}
			}
		}
		return super.add(e);
	}
}
"
PackageStateReport.java,context,"package org.processmining.framework.packages;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.SortedSet;

public class PackageStateReport {

	private final Map<PackageDescriptor, Set<String>> missing;
	private final Map<PackageDescriptor, Set<String>> conflicts;
	private final Map<String, SortedSet<PackageDescriptor>> multipleVersions;

	public PackageStateReport(Map<String, SortedSet<PackageDescriptor>> multipleVersions,
			Map<PackageDescriptor, Set<String>> missing, Map<PackageDescriptor, Set<String>> conflicts) {
		this.multipleVersions = multipleVersions;
		this.conflicts = conflicts;
		this.missing = missing;
	}

	public Map<PackageDescriptor, Set<String>> getMissingDependencies() {
		return missing;
	}

	public Map<PackageDescriptor, Set<String>> getConflictingPackages() {
		return conflicts;
	}

	public Map<String, SortedSet<PackageDescriptor>> getPackagesWithMultipleVersions() {
		return multipleVersions;
	}

	public String toString() {
		List<String> lines = new ArrayList<String>();

		for (Map.Entry<String, SortedSet<PackageDescriptor>> item : getPackagesWithMultipleVersions().entrySet()) {
			lines.add(""Package "" + item.getKey() + "" has or will have multiple versions installed:"");
			for (PackageDescriptor p : item.getValue()) {
				lines.add(""  "" + p);
			}
		}
		for (Map.Entry<PackageDescriptor, Set<String>> item : getMissingDependencies().entrySet()) {
			lines.add(""Package "" + item.getKey() + "" depends on packages which are and will not be installed:"");
			for (String dep : item.getValue()) {
				lines.add(""  "" + dep);
			}
		}
		for (Map.Entry<PackageDescriptor, Set<String>> item : getConflictingPackages().entrySet()) {
			lines.add(""Package "" + item.getKey() + "" conflicts with packages which are or will be installed:"");
			for (String confl : item.getValue()) {
				lines.add(""  "" + confl);
			}
		}

		StringBuffer result = new StringBuffer();
		for (String s : lines) {
			result.append(s);
			result.append(System.getProperty(""line.separator""));
		}
		return result.toString();
	}

	public boolean hasErrors() {
		return !getConflictingPackages().isEmpty() || !getMissingDependencies().isEmpty()
				|| !getPackagesWithMultipleVersions().isEmpty();
	}
}
"
PackageVersion.java,context,"package org.processmining.framework.packages;

import java.util.ArrayList;
import java.util.List;

public class PackageVersion implements Comparable<PackageVersion> {

	private final List<Integer> version;

	public PackageVersion(String version) {
		this.version = parse(version);
	}

	private List<Integer> parse(String v) {
		List<Integer> result = new ArrayList<Integer>();
		String[] components = v.split(""[^0-9]"");

		for (String c : components) {
			if (c.length() > 0) {
				result.add(Integer.parseInt(c));
			}
		}
		return result;
	}

	public boolean equals(Object o) {
		if (!(o instanceof PackageVersion)) {
			return false;
		}
		return version.equals(((PackageVersion) o).version);
	}

	public int hashCode() {
		return version.hashCode();
	}

	public String toString() {
		String result = new String();

		for (Integer i : version) {
			if (result.length() > 0) {
				result += '.';
			}
			result += i;
		}
		return result;
	}

	public boolean lessOrEqual(PackageVersion v) {
		return compareTo(v) <= 0;
	}

	public boolean lessThan(PackageVersion v) {
		return compareTo(v) < 0;
	}

	public int compareTo(PackageVersion v) {
		for (int i = 0; i < version.size(); i++) {
			if (i < v.version.size()) {
				int self = version.get(i);
				int other = v.version.get(i);

				if (self < other) {
					return -1;
				} else if (self > other) {
					return 1;
				}
			} else {
				return 1;
			}
		}
		return version.size() == v.version.size() ? 0 : -1;
	}
}
"
Repository.java,context,"package org.processmining.framework.packages;

import java.net.URL;

public class Repository {

	private final URL url;

	public Repository(URL url) {
		this.url = url;
	}

	public URL getURL() {
		return url;
	}

	public String toString() {
		return ""Repository("" + getURL().toString() + "")"";
	}

	public boolean equals(Object other) {
		if (!(other instanceof Repository)) {
			return false;
		}
		return ((Repository) other).getURL().equals(url);
	}

	public int hashCode() {
		return url.hashCode();
	}
}
"
UnknownPackageException.java,context,"package org.processmining.framework.packages;

public class UnknownPackageException extends Exception {

	/**
	 * 
	 */
	private static final long serialVersionUID = 1037754203430229972L;
	private final String name;

	public UnknownPackageException(String name) {
		super(""Unknow package: "" + name);
		this.name = name;
	}

	public String getName() {
		return name;
	}
}
"
UnknownPackageTypeException.java,context,"package org.processmining.framework.packages;

public class UnknownPackageTypeException extends Exception {

	private static final long serialVersionUID = -7248277354439798414L;
	private final PackageDescriptor pack;

	public UnknownPackageTypeException(PackageDescriptor pack) {
		super(""Unknow package file type: "" + pack.getURL());
		this.pack = pack;
	}

	public PackageDescriptor getPack() {
		return pack;
	}
}
"
Bootable.java,context,"package org.processmining.framework.plugin.annotations;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface Bootable {
}
"
CLI.java,context,"package org.processmining.framework.plugin.annotations;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface CLI {
	String functionName();
}
"
KeepInProMCache.java,context,"package org.processmining.framework.plugin.annotations;

import java.lang.annotation.ElementType;
import java.lang.annotation.Inherited;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * Annotation that is used as a base annotation for all classes that need to be
 * kept in cache by the ProM framework. When a class carries this annotation,
 * the ProM PluginManager will scan the class during first boot and store the
 * class in the cache for future reference.
 * 
 * This allows ProM to build a mapping from annotations to annotated classes
 * during boot.
 * 
 * @author bfvdonge
 * 
 */

@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Inherited
public @interface KeepInProMCache {

}
"
Plugin.java,context,"package org.processmining.framework.plugin.annotations;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Retention(RetentionPolicy.RUNTIME)
@Target({ ElementType.METHOD, ElementType.TYPE })
public @interface Plugin {

	/**
	 * Returns the name identifying this plugin in a human readable way.
	 * 
	 * @return
	 */
	String name();

	/**
	 * Returns an Array of strings, such that each String is an initial label
	 * for a returned object. Plugins can change this label during execution.
	 * 
	 * The length of the array should be the same as the length of the
	 * returnTypes array.
	 * 
	 * @return
	 */
	String[] returnLabels();

	/**
	 * Returns an Array of Class objects, such that each class object represents
	 * the type of the returned object at that index, i.e. the plugin should
	 * return as many objects as the length of this array, and each object
	 * should be of the type given in this array.
	 * 
	 * @return
	 */
	Class<?>[] returnTypes();

	/**
	 * Returns the labels of the parameters for this plugin.
	 * 
	 * If the Plugin annotation is used on a method, then the number of elements
	 * in this array should correspond to the number of parameters that the
	 * method requires, not counting the first parameter of type PluginContext.
	 * 
	 * If the plugin annotation is used on a class, then each variant should
	 * indicate which subset of parameters it requires. Each parameter should
	 * appear in at least one variant.
	 * 
	 * Note that the types of the parameters are not specified in the
	 * annotation. Instead they are derived from the method definitions that
	 * contain the logic of this plugin. Parameters can be overloaded, i.e. the
	 * same parameter can have multiple types.
	 * 
	 * @return
	 */
	String[] parameterLabels();

	/**
	 * Returns the help / description for this plugin.
	 * 
	 * @return Empty string as default
	 */
	String help() default """";

	/**
	 * Signals the framework to make this plugin user-accessible. If a plugin is
	 * not user-accessible, it does not show up in any UI
	 * 
	 * @return Defaults to true.
	 */
	boolean userAccessible() default true;

	/**
	 * Returns the index + 1 in the result array of the most significant result
	 * for this plugin, i.e. if the first element in the array is the most
	 * significant, then the value of this parameter should be 1.
	 * 
	 * If the plugin does not return anything interesting itself, but considers
	 * one of it's inputs to be the most significant one, then a negative value
	 * should be returned. I.e. if the first parameter is the most significant
	 * result, a value of -1 has to be returned. Note that this parameter should
	 * always be included in all variants
	 * 
	 * @return the index in the result array of the most significant result. If
	 *         no results are returned by this plugin, anything can be returned.
	 *         Defaults to 1
	 * 
	 */
	int mostSignificantResult() default 1;

	/**
	 * Whether this plugin handles cancel itself. If this is true, the plug-in
	 * will not be killed but is allowed to terminate itself by monitoring
	 * isCancelled.
	 * 
	 * @return
	 */
	boolean handlesCancel() default false;

	/**
	 * Categories define the 'type' of functionality the plugin provides.
	 */
	PluginCategory[] categories() default { PluginCategory.Analytics };

	/**
	 * Keywords / tags for the plugin (extra description)
	 */
	String[] keywords() default {};
	
	/**
	 * Indication of quality for plug-in.
	 * @return
	 */
	PluginQuality quality() default PluginQuality.VeryPoor;
	/**
	 * Indication of level for plug-in.
	 * @return
	 */
	PluginLevel level() default PluginLevel.NightlyBuild;
	
	String icon() default """";
	String url() default """";
}
"
PluginCategory.java,context,"package org.processmining.framework.plugin.annotations;

/**
 * Plugin Category
 * 
 * @author mleemans
 * 
 *         Possible categories specifying the 'type' of functionality the plugin
 *         provides.
 */
public enum PluginCategory {
	Discovery( //
			""Discovery"", //
			""Discovery plugin constructs a model from a given event log"", //
			""action_filter_discovery_20x20.png""), //
	ConformanceChecking( //
			""Conformance Checking"", //
			""Conformance checking plugin check conformance between a given a model and a given event log"", //
			""action_filter_conformance_20x20.png""), //
	Enhancement( //
			""Enhancement"", //
			""Enhancement plugin enhances a given model using a given log"", //
			""action_filter_enhancement_20x20.png""), //
	Filtering( //
			""Filtering"", //
			""Filtering plugin filters or clusters a given log"", //
			""action_filter_filtering_20x20.png""), //
	Analytics( //
			""Analytics"", //
			""Analytic plugin provides additional analysis for a given log"", //
			""action_filter_analytics_20x20.png"");

	private final String name;
	private final String description;
	private final String imageFilterFilename;

	private PluginCategory(String name, String description, String imageFilterFilename) {
		this.name = name;
		this.description = description;
		this.imageFilterFilename = imageFilterFilename;
	}

	public String getName() {
		return name;
	}

	public String getDescription() {
		return description;
	}

	public String getImageFilterFilename() {
		return imageFilterFilename;
	}

}
"
PluginLevel.java,context,"package org.processmining.framework.plugin.annotations;

public enum PluginLevel {
	Local( //
			""Local"", //
			1), //
	NightlyBuild( //
			""NightlyBuild"", //
			2), //
	Regular( //
			""Regular"", //
			3), //
	PeerReviewed( //
			""PeerReviewed"", //
			4), //
	BulletProof( //
			""BulletProof"", //
			5);

	private final String name;
	private final int value;

	private PluginLevel(String name, int value) {
		this.name = name;
		this.value = value;
	}

	public String getName() {
		return name;
	}

	public int getValue() {
		return value;
	}

}
"
PluginQuality.java,context,"package org.processmining.framework.plugin.annotations;

public enum PluginQuality {
	VeryPoor( //
			""VeryPoor"", //
			0), //
	Poor( //
			""Poor"", //
			1), //
	Fair( //
			""Fair"", //
			2), //
	Good( //
			""Good"", //
			3), //
	VeryGood( //
			""VeryGood"", //
			4);

	private final String name;
	private final int value;

	private PluginQuality(String name, int value) {
		this.name = name;
		this.value = value;
	}

	public String getName() {
		return name;
	}

	public int getValue() {
		return value;
	}
}
"
PluginVariant.java,context,"package org.processmining.framework.plugin.annotations;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface PluginVariant {

	/**
	 * Each plugin variant specifies the required parameter labels in this
	 * Array. The array should be at most as long as the parameterLabels array
	 * of the Plugin annotation. Furthermore, all elements of the array should
	 * be indices in the parametersLabels array of the Plugin annotation and the
	 * elements should be ordered.
	 * 
	 * @return
	 */
	int[] requiredParameterLabels();

	/**
	 * This String represents the label of the plugin variant. This label is
	 * used to identify different variants of the same plugin, specifically when
	 * multiple variants accept the same parameters of the same types.
	 */
	String variantLabel() default """";

	/**
	 * Returns the help / description for this plugin variant.
	 * 
	 * @return Empty string as default
	 */
	String help() default """";

}
"
ConnectionObjectListener.java,context,"package org.processmining.framework.plugin.events;

import java.util.EventListener;

import org.processmining.framework.connections.ConnectionID;

public interface ConnectionObjectListener extends EventListener {

	public class ListenerList extends ProMEventListenerList<ConnectionObjectListener> {
		public void fireConnectionCreated(ConnectionID connectionID) {
			for (ConnectionObjectListener listener : getListeners()) {
				listener.connectionCreated(connectionID);
			}
		}

		public void fireConnectionDeleted(ConnectionID id) {
			for (ConnectionObjectListener listener : getListeners()) {
				listener.connectionDeleted(id);
			}
		}

		public void fireConnectionUpdated(ConnectionID id) {
			for (ConnectionObjectListener listener : getListeners()) {
				listener.connectionUpdated(id);
			}
		}
	}

	/**
	 * This method signals the creation of a connection with the given ID. For
	 * access to the actual connection, the connectionManager should be used.
	 * 
	 * @param connectionID
	 */
	public void connectionCreated(ConnectionID connectionID);

	/**
	 * This method signals the deletion of a connection with the given ID. For
	 * access to the actual connection, the connectionManager should be used.
	 * 
	 * @param connectionID
	 */
	public void connectionDeleted(ConnectionID connectionID);

	/**
	 * This method signals that the connection with the given ID was updated.
	 * For access to the actual connection, the connectionManager should be
	 * used.
	 * 
	 * Be aware, that the actual pointers to the objects connected by the
	 * Connection with the given ID are not changed. Furthermore, it is wise not
	 * to update connections too often.
	 * 
	 * @param connectionID
	 */
	public void connectionUpdated(ConnectionID connectionID);

}
"
FutureListener.java,context,"package org.processmining.framework.plugin.events;

import java.util.EventListener;

import org.processmining.framework.plugin.ProMFuture;

public interface FutureListener extends EventListener {

	public class ListenerList extends ProMEventListenerList<FutureListener> {
		public void fireFutureReady(ProMFuture<? extends Object> future) {
			for (FutureListener listener : getListeners()) {
				listener.futureReady(future);
			}
		}
	}

	public void futureReady(ProMFuture<? extends Object> future);

}
"
Logger.java,context,"package org.processmining.framework.plugin.events;

import java.util.EventListener;

import org.processmining.framework.plugin.PluginContextID;

public interface Logger extends EventListener {

	public enum MessageLevel {
		/**
		 * Normal message level, for information during runtime
		 */
		NORMAL("" "", ""Normal""),
		/**
		 * Warning message level, for warning messages during runtime
		 */
		WARNING(""W"", ""Warning""),
		/**
		 * Error message level, for error information during ruintime. Use in
		 * case error can be recovered from, i.e. not in case of exception
		 * handling.
		 */
		ERROR(""E"", ""Error""),
		/**
		 * All TEST messages are omitted in the release version.
		 */
		TEST(""T"", ""Test""),
		/**
		 * All DEBUG messages are omitted in the release version.
		 */
		DEBUG(""D"", ""Debug"");

		private final String shortName;
		private final String longName;

		MessageLevel(String shortName, String longName) {
			this.shortName = shortName;
			this.longName = longName;
		}

		public String getShortName() {
			return shortName;
		}

		public String getLongName() {
			return longName;
		}
	}

	public class ListenerList extends ProMEventListenerList<Logger> {

		public void fireLog(String message, PluginContextID contextID, MessageLevel messageLevel) {
			for (Logger listener : getListeners()) {
				listener.log(message, contextID, messageLevel);
			}
		}

		public void fireLog(Throwable t, PluginContextID contextID) {
			for (Logger listener : getListeners()) {
				listener.log(t, contextID);
			}
		}
	}

	public void log(String message, PluginContextID contextID, MessageLevel messageLevel);

	public void log(Throwable t, PluginContextID contextID);

}
"
NameChangeListener.java,context,"package org.processmining.framework.plugin.events;

import java.util.EventListener;

public interface NameChangeListener extends EventListener {

	public class ListenerList extends ProMEventListenerList<NameChangeListener> {
		public void fireNameChanged(String newName) {
			for (NameChangeListener listener : getListeners()) {
				listener.nameChanged(newName);
			}
		}
	}

	public void nameChanged(String newName);
}
"
PluginLifeCycleEventListener.java,context,"package org.processmining.framework.plugin.events;

import java.util.EventListener;

import org.processmining.framework.plugin.PluginContext;

public interface PluginLifeCycleEventListener extends EventListener {

	/**
	 * This method is invoked on a parent context, if a child context of that
	 * parent is created.
	 * 
	 * @param context
	 *            the new Child context
	 */
	public void pluginCreated(PluginContext context);

	/**
	 * This method is invoked on a context, if it is started
	 * 
	 * @param context
	 *            the context
	 */
	public void pluginStarted(PluginContext context);

	/**
	 * This method is invoked on a context, if it is suspended
	 * 
	 * @param context
	 *            the context
	 */
	public void pluginSuspended(PluginContext context);

	/**
	 * This method is invoked on a context, if it is resumed
	 * 
	 * @param context
	 *            the context
	 */
	public void pluginResumed(PluginContext context);

	/**
	 * This method is invoked on a context, if it is completed
	 * 
	 * @param context
	 *            the context
	 */
	public void pluginCompleted(PluginContext context);

	/**
	 * This method is invoked on a context, if it is cancelled
	 * 
	 * @param context
	 *            the context
	 */
	public void pluginCancelled(PluginContext context);

	/**
	 * This method is invoked on a context, if it throws an exception
	 * 
	 * @param context
	 *            the context
	 */
	public void pluginTerminatedWithError(PluginContext context, Throwable t);

	/**
	 * This method is invoked on a context, if it's future was set.
	 * 
	 * @param context
	 *            the context
	 */
	public void pluginFutureCreated(PluginContext context);

	/**
	 * This method is invoked on a context, if it's deleted from its parent
	 * 
	 * @param context
	 *            the context
	 */
	public void pluginDeleted(PluginContext context);

	public class List extends ProMEventListenerList<PluginLifeCycleEventListener> {
		public void firePluginCreated(PluginContext context) {
			for (PluginLifeCycleEventListener listener : getListeners()) {
				listener.pluginCreated(context);
			}
		}

		public void firePluginStarted(PluginContext context) {
			for (PluginLifeCycleEventListener listener : getListeners()) {
				listener.pluginStarted(context);
			}
		}

		public void firePluginSuspended(PluginContext context) {
			for (PluginLifeCycleEventListener listener : getListeners()) {
				listener.pluginSuspended(context);
			}
		}

		public void firePluginResumed(PluginContext context) {
			for (PluginLifeCycleEventListener listener : getListeners()) {
				listener.pluginResumed(context);
			}
		}

		public void firePluginCompleted(PluginContext context) {
			for (PluginLifeCycleEventListener listener : getListeners()) {
				listener.pluginCompleted(context);
			}
		}

		public void firePluginCancelled(PluginContext context) {
			for (PluginLifeCycleEventListener listener : getListeners()) {
				listener.pluginCancelled(context);
			}
		}

		public void firePluginTerminatedWithError(PluginContext context, Throwable t) {
			for (PluginLifeCycleEventListener listener : getListeners()) {
				listener.pluginTerminatedWithError(context, t);
			}
		}

		public void firePluginFutureCreated(PluginContext context) {
			for (PluginLifeCycleEventListener listener : getListeners()) {
				listener.pluginFutureCreated(context);
			}
		}

		public void firePluginDeleted(PluginContext context) {
			for (PluginLifeCycleEventListener listener : getListeners()) {
				listener.pluginDeleted(context);
			}
		}
	}
}"
ProgressEventListener.java,context,"package org.processmining.framework.plugin.events;

import java.util.EventListener;

public interface ProgressEventListener extends EventListener {

	void changeProgressCaption(String newCaption);

	void changeProgress(int progress);

	void changeProgressBounds(int lowBo, int upBo);

	void changeProgressIndeterminate(boolean indeterminate);

	public class ListenerList extends ProMEventListenerList<ProgressEventListener> {
		public void fireProgressCaptionChanged(String newCaption) {
			for (ProgressEventListener listener : getListeners()) {
				listener.changeProgressCaption(newCaption);
			}
		}

		public void fireProgressChanged(int progress) {
			for (ProgressEventListener listener : getListeners()) {
				listener.changeProgress(progress);
			}
		}

		public void fireProgressBoundsChanged(int lowBo, int upBo) {
			for (ProgressEventListener listener : getListeners()) {
				listener.changeProgressBounds(lowBo, upBo);
			}
		}

		public void fireProgressIndeterminateChanged(boolean indeterminate) {
			for (ProgressEventListener listener : getListeners()) {
				listener.changeProgressIndeterminate(indeterminate);
			}
		}
	}
}"
ProMEventListenerList.java,context,"package org.processmining.framework.plugin.events;

import java.lang.ref.WeakReference;
import java.util.ArrayList;
import java.util.EventListener;
import java.util.Iterator;
import java.util.List;

public class ProMEventListenerList<T extends EventListener> {

	private final List<WeakReference<T>> listeners = new ArrayList<WeakReference<T>>(2);

	public void add(T listener) {
		synchronized (listeners) {
			listeners.add(new WeakReference<T>(listener));
		}
	}

	public int getListenerCount() {
		return listeners.size();
	}

	protected List<T> getListeners() {
		List<T> result = new ArrayList<T>();
		Iterator<WeakReference<T>> it = listeners.iterator();
		while (it.hasNext()) {
			T object = it.next().get();
			if (object != null) {
				result.add(object);
			} else {
				it.remove();
			}
		}
		return result;
	}

	public void remove(T listener) {
		while (listeners.contains(listener)) {
			listeners.remove(listener);
		}
	}

	public String toString() {
		return listeners.toString();
	}

	public void removeAll() {
		listeners.clear();
	}

}"
ProvidedObjectLifeCycleListener.java,context,"package org.processmining.framework.plugin.events;

import java.util.EventListener;

import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.providedobjects.ProvidedObjectID;

public interface ProvidedObjectLifeCycleListener extends EventListener {

	public void providedObjectCreated(ProvidedObjectID objectID, PluginContext context);

	public void providedObjectFutureReady(ProvidedObjectID objectID);

	public void providedObjectNameChanged(ProvidedObjectID objectID);

	public void providedObjectObjectChanged(ProvidedObjectID objectID);

	public void providedObjectDeleted(ProvidedObjectID objectID);

	public class ListenerList extends ProMEventListenerList<ProvidedObjectLifeCycleListener> {
		public void fireProvidedObjectCreated(ProvidedObjectID objectID, PluginContext context) {
			for (ProvidedObjectLifeCycleListener listener : getListeners()) {
				listener.providedObjectCreated(objectID, context);
			}
		}

		public void fireProvidedObjectNameChanged(ProvidedObjectID objectID) {
			for (ProvidedObjectLifeCycleListener listener : getListeners()) {
				listener.providedObjectNameChanged(objectID);
			}
		}

		public void fireProvidedObjectObjectChanged(ProvidedObjectID objectID) {
			for (ProvidedObjectLifeCycleListener listener : getListeners()) {
				listener.providedObjectObjectChanged(objectID);
			}
		}

		public void fireProvidedObjectDeleted(ProvidedObjectID objectID) {
			for (ProvidedObjectLifeCycleListener listener : getListeners()) {
				listener.providedObjectDeleted(objectID);
			}
		}

		public void fireProvidedObjectFutureReady(ProvidedObjectID objectID) {
			for (ProvidedObjectLifeCycleListener listener : getListeners()) {
				listener.providedObjectFutureReady(objectID);
			}
		}
	}
}
"
GlobalContext.java,context,"package org.processmining.framework.plugin;

import org.processmining.framework.connections.ConnectionManager;
import org.processmining.framework.providedobjects.ProvidedObjectManager;

/**
 * Any implementation should maintain a referencte to a single plugin context.
 * This plugin context is then used create children, in which plugins are
 * executed.
 * 
 * @author bfvdonge
 * 
 */
public interface GlobalContext {

	/**
	 * Returns the plugin manager. The plugin manager can be used to query for
	 * plugins which are registered in ProM.
	 * 
	 * @return the plugin manager
	 */
	PluginManager getPluginManager();

	/**
	 * Returns the providedObject manager. The providedObject manager can be
	 * used to query for providedObjects which are registered in ProM. The
	 * manager should be a ProvidedObjectListener on all PluginInstanceContexts
	 * created by createRootInstanceContext.
	 * 
	 * @return the providedObject manager
	 */
	ProvidedObjectManager getProvidedObjectManager();

	/**
	 * Returns the connection manager. The connection manager can be used to
	 * query for connections which are registered in ProM.
	 * 
	 * @return the connection manager
	 */

	ConnectionManager getConnectionManager();

	/**
	 * The GlobalContext implementation should create IDs for all PluginContexts
	 * instantiated for it.
	 * 
	 * @return
	 */
	PluginContextID createNewPluginContextID();

	/**
	 * This method invokes the specified plugin in a context which is a child of
	 * the main plugin context maintained by this globalContext. No results are
	 * provided to the method calling this method and the plugin is executed
	 * some time in the future, as decided by the implementing class.
	 * 
	 * @param plugin
	 *            The plugin that should be invoked by the framework
	 * @param index
	 *            The index of the plugin method that should be invoked.
	 * @param objects
	 *            The objects to serve as input as accepted by the method at
	 *            index of the plugin
	 */
	void invokePlugin(PluginDescriptor plugin, int index, Object... objects);

	/**
	 * This method invokes the specified binding in a context which is a child
	 * of the main plugin context maintained by this globalContext. No results
	 * are provided to the method calling this method and the plugin is executed
	 * some time in the future, as decided by the implementing class.
	 * 
	 * @param binding
	 *            The binding that should be invoked by the framework
	 * @param objects
	 *            The objects to serve as input as accepted by the given
	 *            binding.
	 */
	void invokeBinding(PluginParameterBinding binding, Object... objects);

	/**
	 * Returns the specific type of the PluginContext. This type is used to
	 * instantiate new contexts in which to invoke plugins.
	 * 
	 * @return the type of PluginContext provided by this global context
	 */
	Class<? extends PluginContext> getPluginContextType();

}
"
AbstractGlobalContext.java,context,"package org.processmining.framework.plugin.impl;

import org.processmining.framework.connections.ConnectionManager;
import org.processmining.framework.connections.impl.ConnectionManagerImpl;
import org.processmining.framework.plugin.GlobalContext;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.PluginContextID;
import org.processmining.framework.plugin.PluginDescriptor;
import org.processmining.framework.plugin.PluginManager;
import org.processmining.framework.plugin.PluginParameterBinding;
import org.processmining.framework.plugin.events.Logger;
import org.processmining.framework.providedobjects.ProvidedObjectManager;
import org.processmining.framework.providedobjects.impl.ProvidedObjectManagerImpl;

/**
 * Since this context should maintain a link to a single plugin context, and
 * PluginContextImpl is abstract, this context is also abstract.
 * 
 * @author bfvdonge
 * 
 */
public abstract class AbstractGlobalContext implements GlobalContext {

	private final ProvidedObjectManager providedObjectManager = new ProvidedObjectManagerImpl();
	private final ConnectionManager connectionManager = new ConnectionManagerImpl(PluginManagerImpl.getInstance());
	protected final Logger.ListenerList loggingEventListeners = new Logger.ListenerList();

	public PluginManager getPluginManager() {
		return PluginManagerImpl.getInstance();
	}

	public ConnectionManager getConnectionManager() {
		return connectionManager;
	}

	public ProvidedObjectManager getProvidedObjectManager() {
		return providedObjectManager;
	}

	public PluginContextID createNewPluginContextID() {
		return new PluginContextIDImpl();
	}

	public void invokeBinding(PluginParameterBinding binding, Object... objects) {

		PluginContext c2 = getMainPluginContext().createChildContext(binding.getPlugin().getName());

		try {
			// Create a new providedObject, by passing the future to the
			// providedObjectManager;
			getMainPluginContext().getPluginLifeCycleEventListeners().firePluginCreated(c2);
			binding.invoke(c2, objects);
			getProvidedObjectManager().createProvidedObjects(c2);

		} catch (IllegalArgumentException e) {
			getMainPluginContext().log(e);
			return;
		} finally {
			c2.getParentContext().deleteChild(c2);
		}

		// Since the result is still being calculated, we can only
		// use the defaultResultName for the providedObject.

	}

	public void invokePlugin(PluginDescriptor plugin, int index, Object... objects) {
		PluginContext c2 = getMainPluginContext().createChildContext(plugin.getName());

		try {
			// Create a new providedObject, by passing the future to the
			// providedObjectManager;
			getMainPluginContext().getPluginLifeCycleEventListeners().firePluginCreated(c2);
			plugin.invoke(index, c2, objects);
			getProvidedObjectManager().createProvidedObjects(c2);

		} catch (IllegalArgumentException e) {
			getMainPluginContext().log(e);
			return;
		} finally {
			c2.getParentContext().deleteChild(c2);
		}

		// Since the result is still being calculated, we can only
		// use the defaultResultName for the providedObject.

	}

	protected abstract PluginContext getMainPluginContext();

	public abstract Class<? extends PluginContext> getPluginContextType();

}
"
AbstractPluginContext.java,context,"package org.processmining.framework.plugin.impl;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashSet;
import java.util.Set;
import java.util.SortedSet;
import java.util.TreeSet;
import java.util.concurrent.CancellationException;
import java.util.concurrent.ExecutionException;

import org.processmining.framework.connections.Connection;
import org.processmining.framework.connections.ConnectionCannotBeObtained;
import org.processmining.framework.connections.ConnectionManager;
import org.processmining.framework.plugin.GlobalContext;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.PluginContextID;
import org.processmining.framework.plugin.PluginDescriptor;
import org.processmining.framework.plugin.PluginExecutionResult;
import org.processmining.framework.plugin.PluginManager;
import org.processmining.framework.plugin.PluginParameterBinding;
import org.processmining.framework.plugin.ProMFuture;
import org.processmining.framework.plugin.Progress;
import org.processmining.framework.plugin.RecursiveCallException;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.events.Logger;
import org.processmining.framework.plugin.events.Logger.MessageLevel;
import org.processmining.framework.plugin.events.PluginLifeCycleEventListener;
import org.processmining.framework.plugin.events.ProgressEventListener;
import org.processmining.framework.providedobjects.ProvidedObjectManager;
import org.processmining.framework.util.Cast;
import org.processmining.framework.util.Pair;

public abstract class AbstractPluginContext implements PluginContext {

	private final GlobalContext context;
	private final PluginContext parentPluginContext;

	private final PluginLifeCycleEventListener.List lifeCycleEventListeners = new PluginLifeCycleEventListener.List();
	private final ProgressEventListener.ListenerList progressEventListeners = new ProgressEventListener.ListenerList();
	private final Logger.ListenerList loggers = new Logger.ListenerList();

	protected Progress progress;
	private PluginDescriptor descriptor;
	private final java.util.List<PluginContext> childContexts = new ArrayList<PluginContext>(0);
	private PluginExecutionResult futures = null;
	private final PluginContextID id;
	private String label = """";
	private int methodIndex = -1;

	/**
	 * Create a new root plugin instance context.
	 * 
	 * @param context
	 *            the global context in which this instance context is used
	 */
	public AbstractPluginContext(GlobalContext context, String label) {
		assert (context != null);
		this.context = context;
		id = context.createNewPluginContextID();
		this.label = label;
		parentPluginContext = null;
		progress = new ProgressBarImpl(this);
	}

	protected AbstractPluginContext(AbstractPluginContext context, String label) {
		assert (context != null);
		this.context = context.getGlobalContext();
		id = this.context.createNewPluginContextID();
		this.label = label;
		parentPluginContext = context;
		progress = new ProgressBarImpl(this);
	}

	public Pair<PluginDescriptor, Integer> getPluginDescriptor() {
		return new Pair<PluginDescriptor, Integer>(descriptor, methodIndex);
	}

	public GlobalContext getGlobalContext() {
		return context;
	}

	public PluginLifeCycleEventListener.List getPluginLifeCycleEventListeners() {
		return lifeCycleEventListeners;
	}

	public ProgressEventListener.ListenerList getProgressEventListeners() {
		return progressEventListeners;
	}

	public Progress getProgress() {
		return progress;
	}

	public PluginContextID getID() {
		return id;
	}

	public ConnectionManager getConnectionManager() {
		return context.getConnectionManager();
	}

	public String getLabel() {
		return label;
	}

	public boolean hasPluginDescriptorInPath(PluginDescriptor plugin, int methodIndex) {
		return ((methodIndex == this.methodIndex) && (plugin == descriptor))
				|| (getParentContext() == null ? false : getParentContext().hasPluginDescriptorInPath(plugin,
						methodIndex));
	}

	public void setPluginDescriptor(PluginDescriptor descriptor, int methodIndex) throws FieldSetException,
			RecursiveCallException {
		if ((getParentContext() != null) && getParentContext().hasPluginDescriptorInPath(descriptor, methodIndex)) {
			throw new RecursiveCallException(this, descriptor, methodIndex);
		}
		if (this.descriptor == null) {
			this.methodIndex = methodIndex;
			this.descriptor = descriptor;
		} else {
			throw new FieldSetException(""descriptor"",
					""Use getGlobalContext().createInstanceContext() to create a new instance context"");
		}
	}

	public PluginContext createChildContext(String label) {
		PluginContext context = createTypedChildContext(label);
		childContexts.add(context);
		return context;
	}

	public java.util.List<PluginContext> getChildContexts() {
		return Collections.unmodifiableList(childContexts);
	}

	public PluginContext getParentContext() {
		return parentPluginContext;
	}

	protected abstract PluginContext createTypedChildContext(String label);

	/**
	 * This method returns the PluginExecutionResult of the plugin which is
	 * invoked in this context. This future result is set by
	 * PluginManager.invoke() and will not be available (will be null) until the
	 * invoke() method is called.
	 * 
	 * @return The PluginExecutionResult that represents the result of this
	 *         plugin invocation
	 * @throws FieldNotSetException
	 *             If the future is not know to this context
	 */
	public PluginExecutionResult getResult() {
		return futures;
	}

	public ProMFuture<?> getFutureResult(int i) {
		assert (futures != null);
		Object o = futures.getResult(i);
		assert (o instanceof ProMFuture<?>);
		// Note that if this cast cannot be performed,
		// an exception should be thrown. This method should
		// only be called from the body of a plugin
		return futures.<ProMFuture<?>>getResult(i);
	}

	public void setFuture(PluginExecutionResult futureToBe) {
		assert (futures == null);
		futures = futureToBe;
	}

	public boolean equals(Object o) {
		if (o instanceof PluginContext) {
			return ((PluginContext) o).getID().equals(id);
		}
		return false;

	}

	public String toString() {
		return getID() + "": "" + getLabel();
	}

	public boolean isDistantChildOf(PluginContext context) {
		if (getParentContext() == null) {
			return false;
		}
		return getParentContext().getID().equals(context.getID()) || getParentContext().isDistantChildOf(context);
	}

	/**
	 * The provided String is provided to the context for information. It can
	 * for example signal a state change of a plugin. Note that some contexts
	 * can completely ignore this message.
	 * 
	 * @param message
	 *            the message to log
	 * @param level
	 *            the message level
	 */
	public void log(String message, MessageLevel level) {
		loggers.fireLog(message, id, level);
	}

	/**
	 * Same as calling log(message, MessageLevel.NORMAL);
	 * 
	 * @param message
	 *            The message
	 */
	public void log(String message) {
		loggers.fireLog(message, id, MessageLevel.NORMAL);
	}

	/**
	 * The provided Exception is provided to the context. It signals the context
	 * about an error in the plugin, that specifically lead to abnormal
	 * termination. The plugin signaling the exception is no longer executing!
	 * 
	 * @param exception
	 *            the exception thrown
	 */
	public void log(Throwable exception) {
		loggers.fireLog(exception, id);
		System.err.println(""-------- The following exception was logged by the framework: "");
		System.err.println(""         The exception was probalby handled properly. "");
		exception.printStackTrace();
		System.err.println(""--------------------------------------------------------------"");
		
	}

	/**
	 * Returns the plugin manager. The plugin manager can be used to query for
	 * plugins which are registered in ProM.
	 * 
	 * @return the plugin manager
	 */
	public PluginManager getPluginManager() {
		return context.getPluginManager();
	}

	/**
	 * Returns the providedObject manager. The providedObject manager can be
	 * used to query for providedObjects which are registered in ProM. The
	 * manager should be a ProvidedObjectListener on all PluginInstanceContexts
	 * created by createRootInstanceContext.
	 * 
	 * @return the providedObject manager
	 */
	public ProvidedObjectManager getProvidedObjectManager() {
		return context.getProvidedObjectManager();
	}

	/**
	 * The GlobalContext implementation should create IDs for all PluginContexts
	 * instantiated for it.
	 * 
	 * @return
	 */
	public PluginContextID createNewPluginContextID() {
		return context.createNewPluginContextID();
	}

	/**
	 * This method invokes the specified plugin in a context which is a child of
	 * the main plugin context maintained by this globalContext;
	 * 
	 * @param plugin
	 * @param objects
	 *            The objects to serve as input. Note that all elements should
	 *            implement Object, or be a ProMFuture<?>.
	 */
	public void invokePlugin(PluginDescriptor plugin, int index, Object... objects) {
		context.invokePlugin(plugin, index, objects);
	}

	public void invokeBinding(PluginParameterBinding binding, Object... objects) {
		context.invokeBinding(binding, objects);
	}

	public Logger.ListenerList getLoggingListeners() {
		return loggers;
	}

	public PluginContext getRootContext() {
		if (parentPluginContext == null) {
			return this;
		} else {
			return parentPluginContext.getRootContext();
		}
	}

	public boolean deleteChild(PluginContext child) {
		if (childContexts.contains(child)) {
			childContexts.remove(child);
			for (PluginContext context : new ArrayList<PluginContext>(child.getChildContexts())) {
				child.deleteChild(context);
			}
			child.getPluginLifeCycleEventListeners().firePluginDeleted(child);
			return true;
		}
		return false;
	}

	public <T extends Connection> T addConnection(T c) {
		return getConnectionManager().addConnection(c);
	}

	public Class<? extends PluginContext> getPluginContextType() {
		return this.getClass();
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @seeorg.processmining.framework.util.ObjectConstructorInterface#
	 * tryToFindOrConstructAllObjects(java.lang.Class,
	 * org.processmining.framework.plugin.PluginContext, java.lang.Class,
	 * java.lang.String, java.lang.Object)
	 */
	public <T, C extends Connection> Collection<T> tryToFindOrConstructAllObjects(Class<T> type,
			Class<C> connectionType, String role, Object... input) throws ConnectionCannotBeObtained {
		return findOrConstructAllObjects(false, type, null, connectionType, role, input);
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @seeorg.processmining.framework.util.ObjectConstructorInterface#
	 * tryToFindOrConstructFirstObject(java.lang.Class,
	 * org.processmining.framework.plugin.PluginContext, java.lang.Class,
	 * java.lang.String, java.lang.Object)
	 */
	public <T, C extends Connection> T tryToFindOrConstructFirstObject(Class<T> type, Class<C> connectionType,
			String role, Object... input) throws ConnectionCannotBeObtained {
		return findOrConstructAllObjects(true, type, null, connectionType, role, input).iterator().next();
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @seeorg.processmining.framework.util.ObjectConstructorInterface#
	 * tryToFindOrConstructFirstNamedObject(java.lang.Class, java.lang.String,
	 * org.processmining.framework.plugin.PluginContext, java.lang.Class,
	 * java.lang.String,
	 * 
	 * java.lang.Object)
	 */
	public <T, C extends Connection> T tryToFindOrConstructFirstNamedObject(Class<T> type, String name,
			Class<C> connectionType, String role, Object... input) throws ConnectionCannotBeObtained {
		return findOrConstructAllObjects(true, type, name, connectionType, role, input).iterator().next();
	}

	private <T, C extends Connection> Collection<T> constructAllObjects(boolean stopAtFirst, Class<T> type,
			String name, Object... input) throws CancellationException, InterruptedException, ExecutionException {
		Class<?>[] types;
		if (input != null) {
			types = new Class<?>[input.length];
			for (int i = 0; i < input.length; i++) {
				types[i] = input[i].getClass();
			}
		} else {
			types = new Class<?>[0];
			input = new Object[0];
		}

		// Find available plugins
		Set<Pair<Integer, PluginParameterBinding>> set = getPluginManager().find(Plugin.class, type,
				getPluginContextType(), true, false, false, types);

		if (set.isEmpty()) {
			throw new RuntimeException(""No plugin available to build this type of object: "" + type.toString());
		}

		// Filter on the given name, if given.
		if (name != null) {
			Set<Pair<Integer, PluginParameterBinding>> filteredSet = new HashSet<Pair<Integer, PluginParameterBinding>>();
			for (Pair<Integer, PluginParameterBinding> pair : set) {
				if (name.equals(pair.getSecond().getPlugin().getName())) {
					filteredSet.add(pair);
				}
			}
			set.clear();
			set.addAll(filteredSet);
		}

		if (set.isEmpty()) {
			throw new RuntimeException(""No named plugin available to build this type of object: "" + name + "", ""
					+ type.toString());
		}

		SortedSet<Pair<Integer, PluginParameterBinding>> plugins = new TreeSet<Pair<Integer, PluginParameterBinding>>(
				new Comparator<Pair<Integer, PluginParameterBinding>>() {

					public int compare(Pair<Integer, PluginParameterBinding> arg0,
							Pair<Integer, PluginParameterBinding> arg1) {
						int c = arg0.getSecond().getPlugin().getReturnNames().size()
								- arg1.getSecond().getPlugin().getReturnNames().size();
						if (c == 0) {
							c = arg0.getSecond().compareTo(arg1.getSecond());
						}
						if (c == 0) {
							c = arg0.getFirst() - arg1.getFirst();
						}
						return c;
					}

				});
		plugins.addAll(set);

		Collection<T> result = new ArrayList<T>(stopAtFirst ? 1 : plugins.size());

		// get the first available plugin
		ExecutionException ex = null;
		for (Pair<Integer, PluginParameterBinding> pair : plugins) {
			PluginParameterBinding binding = pair.getSecond();
			// create a context to execute this plugin in
			PluginContext child = createChildContext(""Computing: "" + type.toString());
			getPluginLifeCycleEventListeners().firePluginCreated(child);

			// Invoke the binding
			PluginExecutionResult pluginResult = binding.invoke(child, input);

			// synchronize on the required result and continue
			try {
				pluginResult.synchronize();

				// get all results and pass them to the framework as provided objects
				getProvidedObjectManager().createProvidedObjects(child);
				result.add(pluginResult.<T>getResult(pair.getFirst()));
				if (stopAtFirst) {
					break;
				}
			} catch (ExecutionException e) {
				// Try next plugin if stop at first, otherwise rethrow
				ex = e;
			} finally {
				child.getParentContext().deleteChild(child);
			}
		}
		if (result.isEmpty()) {
			assert (ex != null);
			throw ex;
		}
		return result;
	}

	private <T, C extends Connection> Collection<T> findOrConstructAllObjects(boolean stopAtFirst, Class<T> type,
			String name, Class<C> connectionType, String role, Object... input) throws ConnectionCannotBeObtained {

		Collection<T> accepted = new ArrayList<T>();
		try {
			for (C conn : getConnectionManager().getConnections(connectionType, this, input)) {
				Object object = conn.getObjectWithRole(role);
				if (type.isAssignableFrom(object.getClass())) {
					accepted.add(Cast.<T>cast(object));
				}
			}
		} catch (Exception e) {
			// Don't care, let's try to construct later
		}
		if (!accepted.isEmpty()) {
			return accepted;
		}
		try {
			return constructAllObjects(stopAtFirst, type, name, input);
		} catch (Exception e) {
			throw new ConnectionCannotBeObtained(e.getMessage(), connectionType);
		}
	}

	public void clear() {
		getProvidedObjectManager().clear();
		getConnectionManager().clear();
	}
}"
AbstractPluginDescriptor.java,context,"package org.processmining.framework.plugin.impl;

import java.lang.reflect.Array;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.concurrent.CancellationException;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;

import javax.swing.JOptionPane;

import org.processmining.framework.boot.Boot;
import org.processmining.framework.plugin.InSufficientResultException;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.PluginDescriptor;
import org.processmining.framework.plugin.PluginExecutionResult;
import org.processmining.framework.plugin.ProMFuture;
import org.processmining.framework.plugin.RecursiveCallException;
import org.processmining.framework.plugin.events.Logger.MessageLevel;
import org.processmining.framework.util.GoogleAnalyticsUtil;

public abstract class AbstractPluginDescriptor implements PluginDescriptor {

	@SuppressWarnings( { ""unchecked"" })
	private Object[] prepareAndWaitForArgs(PluginContext context, int methodIndex, List<Class<?>> parameterTypes,
			Object... args) throws CancellationException, InterruptedException, ExecutionException, FieldSetException,
			RecursiveCallException {
		Object[] result = new Object[args.length + 1];
		// copy the args to result
		System.arraycopy(args, 0, result, 1, args.length);
		boolean[] done = new boolean[result.length];
		Arrays.fill(done, false);
		boolean timeoutOccurred = false;
		do {
			timeoutOccurred = false;
			for (int i = 1; i < result.length; i++) {
				if (done[i]) {
					continue;
				}
				if (result[i] == null) {
					throw new IllegalArgumentException(""Cannot pass <null> as a parameter to a plugin"");
				}
				if ((result[i] instanceof ProMFuture)) {
					// synchronize on this get() method
					// any exception is forwarded.
					try {
						// try to get the result within 100 millisecond
						result[i] = ((ProMFuture) result[i]).get(100L, TimeUnit.MILLISECONDS);
						done[i] = true;
					} catch (TimeoutException e) {
						// A timeout exception occurred, no big deal,
						// just wait longer
						timeoutOccurred = true;
					}
				}
				if (result[i] instanceof Object[]) {
					// This array can contain a combination of rightly typed
					// objects, or futures on
					// rightly types objects, or futures on other arrays.
					Object[] array = (Object[]) result[i];
					boolean futureLeft = false;
					for (int j = 0; j < array.length; j++) {
						if (array[j] instanceof ProMFuture) {
							try {
								// try to get the result within 1 second
								array[j] = ((ProMFuture) array[j]).get(100L, TimeUnit.MILLISECONDS);
							} catch (TimeoutException e) {
								// A timeout exception occurred, no big deal,
								// just wait longer
								timeoutOccurred = true;
								futureLeft |= true;
							}
						}
					}
					if (!futureLeft) {
						List<Object> list = new ArrayList<Object>();
						for (int j = 0; j < array.length; j++) {
							if (array[j].getClass().isArray()) {
								for (int k = 0; k < ((Object[]) array[j]).length; k++) {
									list.add(((Object[]) array[j])[k]);
								}
							} else {
								list.add(array[j]);
							}
						}

						result[i] = list.toArray((Object[]) Array.newInstance(parameterTypes.get(i - 1)
								.getComponentType(), 0));
						done[i] = true;
					}

				}
			}
			if (timeoutOccurred) {
				// At least one of my input objects is not ready yet
				// try again in 2 seconds.
				Thread.sleep(2000);
			}
		} while (timeoutOccurred);

		context.setPluginDescriptor(this, methodIndex);
		result[0] = context;

		return result;
	}
	

	public PluginExecutionResult invoke(final int methodIndex, final PluginContext context, final Object... args) {

		ProMFuture<?>[] futures = new ProMFuture[Math.max(1, getReturnTypes().size())];

		Class<?> returnType;
		String name;
		final PluginExecutionResultImpl lock;
		if (getReturnTypes().size() == 0) {
			returnType = void.class;
			name = ""nothing"";
			lock = new PluginExecutionResultImpl(new Class<?>[] { returnType }, new String[0], this);
		} else {
			returnType = getReturnTypes().get(0);
			name = getReturnNames().get(0);
			lock = new PluginExecutionResultImpl(getReturnTypes().toArray(new Class<?>[0]), getReturnNames().toArray(
					new String[0]), this);
		}

		futures[0] = new ProMFuture<Object>(returnType, name) {

			@Override
			protected Object doInBackground() throws Exception {
				context.getPluginLifeCycleEventListeners().firePluginStarted(context);
				synchronized (lock) {
					// First, do a get on all Future objects in the args list

					Object[] allArgs = prepareAndWaitForArgs(context, methodIndex, getParameterTypes(methodIndex), args);

					// copy the result back into parameters, i.e. all futures
					// are unwrapped at this point and arrays are correctly typed.
					Object[] parameters = new Object[allArgs.length - 1];
					System.arraycopy(allArgs, 1, parameters, 0, parameters.length);
					lock.setInput(parameters);

					// All objects are available, now any exceptions
					// are forwarded, so start the computation of
					// this plugin
					try {
						if (Boot.isTrackingByGAAllowed()) {
							System.out.println(""[AbstractPluginDescriptor] Using GoogleAnalytics"");
							(new GoogleAnalyticsUtil()).runPluginEvent(getName(), getPackage() != null ? getPackage().getName() : null);
						}
						System.out.println(""Start plug-in "" + getName());
						long time = -System.currentTimeMillis();
						Object[] result = execute(context, methodIndex, allArgs);
						time += System.currentTimeMillis();
						System.out.println(""End plug-in "" + getName() + "", took "" + time + "" milliseconds"");

						if ((result == null) && !getReturnType().equals(void.class)) {
							throw new InSufficientResultException(getName(), lock.getExpectedSize(), 0);
						} else if (result.length < lock.getExpectedSize()) {
							throw new InSufficientResultException(getName(), lock.getExpectedSize(), result.length);
						} else if (result.length > lock.getExpectedSize()) {
							context.log(""Plugin "" + getName() + "" produced "" + result.length + "" results, while ""
									+ lock.getExpectedSize() + "" results were declared. Extra results are ignored."",
									MessageLevel.WARNING);
						}

						lock.setResult(result);
						lock.notifyAll();
						Object object = lock.getObject(0);
						return object;
					} catch (Exception ex) {
						if (ex.getCause() instanceof Exception) {
							ex = (Exception) ex.getCause();
						}
						lock.setException(ex);
						lock.notifyAll();
						//						context.getPluginLifeCycleEventListeners().firePluginTerminatedWithError(context, ex);
						//						context.log(ex);
						throw ex;
					}
				}
			}

			@Override
			protected void done() {
				if (context != null) {
					if (isCancelled()) {
						context.getPluginLifeCycleEventListeners().firePluginCancelled(context);
					} else {
						try {
							get();
							context.getPluginLifeCycleEventListeners().firePluginCompleted(context);
						} catch (Exception e) {
							JOptionPane.showMessageDialog(null, ""Exception happened: ""+e.getMessage());
							context.getPluginLifeCycleEventListeners().firePluginTerminatedWithError(context, e);
							context.log(e);
						}
					}

				}

			}
		};

		for (int i = 1; i < getReturnTypes().size(); i++) {
			final int j = i;
			returnType = getReturnTypes().get(i);
			name = getReturnNames().get(i);

			futures[i] = new ProMFuture<Object>(returnType, name) {
				@Override
				protected Object doInBackground() throws Exception {
					synchronized (lock) {
						while ((lock.getObject(j) instanceof ProMFuture<?>) && (lock.getException() == null)) {
							lock.wait();
						}
						Object object = lock.getObject(j);
						if ((object != null) && (lock.getException() == null)) {
							return object;
						}
						throw (lock.getException());
					}

				}
			};
		}

		lock.setResult(futures);

		context.setFuture(lock);
		context.getPluginLifeCycleEventListeners().firePluginFutureCreated(context);
		assert (context.getParentContext() != null);
		for (int i = 0; i < futures.length; i++) {
			context.getParentContext().getExecutor().execute(futures[i].getRunnable());
		}

		return lock;
	}

	/**
	 * In this method, the pluginDescriptor should do the actual work of
	 * concstructing the result. Note that no objects passed in the allArgs
	 * argument are futures anymore.
	 * 
	 * @param context
	 * @param methodIndex
	 * @param allArgs
	 * @return
	 * @throws Exception
	 */
	protected abstract Object[] execute(PluginContext context, int methodIndex, Object... allArgs) throws Exception;

}
"
DependsOnUnknownException.java,context,"package org.processmining.framework.plugin.impl;

/**
 * thrown by the constructor of a plugindescritor if it depends on a plugin not
 * yet in the system.
 * 
 * @author bfvdonge
 * 
 */
public class DependsOnUnknownException extends Exception {

	public DependsOnUnknownException(String message) {
		super(message);
	}

	private static final long serialVersionUID = 4219323628021104089L;

}
"
FieldNotSetException.java,context,"package org.processmining.framework.plugin.impl;

public class FieldNotSetException extends Exception {

	private static final long serialVersionUID = 6942427887070071817L;

	public FieldNotSetException(String fieldName, String message) {
		super(""Field "" + fieldName + "" was not yet set. "" + message);
	}
}
"
FieldSetException.java,context,"package org.processmining.framework.plugin.impl;

public class FieldSetException extends Exception {

	private static final long serialVersionUID = 1024657629198603241L;

	public FieldSetException(String fieldName, String message) {
		super(""Field "" + fieldName + "" was already set. "" + message);
	}
}
"
PluginCacheEntry.java,context,"package org.processmining.framework.plugin.impl;

import java.io.File;
import java.net.URI;
import java.net.URISyntaxException;
import java.net.URL;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Set;
import java.util.TreeSet;
import java.util.prefs.BackingStoreException;
import java.util.prefs.Preferences;

import org.processmining.framework.boot.Boot;
import org.processmining.framework.boot.Boot.Level;
import org.processmining.framework.packages.PackageDescriptor;

public class PluginCacheEntry {

	//	private byte[] buffer = new byte[2 * 1024 * 1024];

	private static final String CURRENT_VERSION = ""currentversion"";

	private static final String FILE_PROTOCOL = ""file"";

	private static final Set<String> STANDARD_JRE_DIRS = new HashSet<String>(
			Arrays.asList(new String[] { ""jdk"", ""jre"", }));
	private static final String STANDARD_JRE_LIB_DIR = ""lib"";
	private static final String STANDARD_JRE_EXT_DIR = ""ext"";
	private static final Set<String> STANDARD_JAR_FILES = new HashSet<String>(Arrays.asList(new String[] {
			""resources.jar"", ""rt.jar"", ""jsse.jar"", ""jce.jar"", ""charsets.jar"", ""dnsns.jar"", ""localedata.jar"",
			""qtjava.jar"", ""sunjce_provider.jar"", ""sunmscapi.jar"", ""sunpkcs11.jar"" }));

	private final URL url;
	private boolean inCache;
	private Set<String> classNames;
	private String key;
	private Boot.Level verbose;

	private final PackageDescriptor packageDescriptor;

	private final String jarName;

	private static Preferences PACKAGECACHE = initCache();

	//	private static MessageDigest digest;
	//
	//	static {
	//		try {
	//			digest = MessageDigest.getInstance(""MD5"");
	//		} catch (NoSuchAlgorithmException e) {
	//			// no MD5 available, so we cannot reliably detect whether the JAR is
	//			// cached or not
	//			digest = null;
	//		}
	//	}

	/**
	 * Deprecated. Use the version with the package descriptor for a
	 * significantly faster cache lookup
	 * 
	 * @param url
	 * @param verbose
	 */
	@Deprecated
	public PluginCacheEntry(URL url, Boot.Level verbose) {
		this(url, verbose, null);
	}

	private static Preferences initCache() {
		return Preferences.userNodeForPackage(PluginCacheEntry.class).parent().node(""_plugincache"");
	}

	public PluginCacheEntry(URL url, Boot.Level verbose, PackageDescriptor packageDescriptor) {
		this.url = url;
		this.verbose = verbose;
		this.packageDescriptor = packageDescriptor;
		this.jarName = packageDescriptor == null ? url.toString().substring(url.toString().lastIndexOf('/') + 1)
				.toLowerCase() : packageDescriptor.getName().toLowerCase();
		reset();

		try {
			init();
		} catch (Throwable e) {
			System.err.println(""Error caching JAR file: "" + e.getMessage());
			reset();
		}
	}

	public String getKey() {
		return key;
	}

	private void reset() {
		inCache = false;
		classNames = new HashSet<String>();
		key = null;
	}

	public boolean isInCache() {
		return inCache;
	}

	public Set<String> getCachedClassNames() {
		return classNames;
	}

	public void removeFromCache() {
		if (key != null) {
			getSettings().remove(key);
		}
	}

	private void init() throws URISyntaxException {
		if (!url.getProtocol().equals(FILE_PROTOCOL)) {
			return;
		}

		if (isStandardJar()) {
			inCache = true;
			return;
		}

		if (packageDescriptor == null) {
			//			if (digest == null) {
			//				return;
			//			}
			key = createFileBasedKey(new File(url.toURI()));
			if (key == null) {
				return;
			}
		} else {
			key = createPackageBasedKey();
		}

		String names = getSettings().get(key, null);

		if (names == null) {
			return;
		}

		if (verbose == Level.ALL) {
			System.out.println(""Plugins found in cache. "");
		}

		try {
			int subkeys = Integer.parseInt(names);
			for (int i = 0; i < subkeys; i++) {
				parseKey(key + ""-"" + i);
			}

		} catch (NumberFormatException e) {
			parseKey(key);
		}
		inCache = true;
	}

	private String createPackageBasedKey() {
		assert packageDescriptor != null;
		String key;
		key = packageDescriptor.getName();
		key += "" "";
		key += packageDescriptor.getVersion();
		return key.toLowerCase();
	}

	private String createFileBasedKey(File file) {
		//		InputStream is = null;
		//		try {
		long modified = file.lastModified();

		key = Long.toHexString(modified);

		//			int numRead = 0;
		//
		//			is = url.openStream();
		//			while ((numRead = is.read(buffer)) > 0) {
		//				digest.update(buffer, 0, numRead);
		//			}

		//		} catch (IOException e) {
		//			return null;
		//		} finally {
		//			if (is != null) {
		//				try {
		//					is.close();
		//				} catch (IOException e) {
		//
		//				}
		//			}
		//		}

		//		key = """";
		//		for (byte b : digest.digest()) {
		//			// append the signed byte as an unsigned hex number
		//			key += Integer.toString(0xFF & b, 16);
		//		}

		// No need to put the jarName in the key anymore.
		//		key += "" "" + new File(new URI(url.toString())).getName();
		//		if (key.length() > 80) {
		//			// make sure they is not too long for the preferences API
		//			key = key.substring(0, 80);
		//		}
		return key;
	}

	private void parseKey(String key) {
		String names = getSettings().get(key, null);

		//System.out.println(""  -> FOUND IN CACHE"");
		for (String className : names.split(""/"")) {
			if (className.length() > 0) {
				//System.out.println(""     - "" + className);
				classNames.add(className);
			}
		}
	}

	private boolean isStandardJar() throws URISyntaxException {
		try {
			File file = new File(new URI(url.toString()));
			String filename = file.getName().toLowerCase();

			if (STANDARD_JAR_FILES.contains(filename)) {
				String libDir = file.getParentFile().getName().toLowerCase();
				String jreDir = removeNonAlphaChars(file.getParentFile().getParentFile().getName().toLowerCase());

				if (libDir.equals(STANDARD_JRE_EXT_DIR)) {
					libDir = file.getParentFile().getParentFile().getName().toLowerCase();
					jreDir = removeNonAlphaChars(file.getParentFile().getParentFile().getParentFile().getName()
							.toLowerCase());
				}
				if (libDir.equals(STANDARD_JRE_LIB_DIR)) {
					return STANDARD_JRE_DIRS.contains(jreDir);
				}
			}
		} catch (NullPointerException e) {
			// probably the file doesn't have enough parent paths
		}
		return false;
	}

	private String removeNonAlphaChars(String s) {
		String result = """";

		for (int i = 0; i < s.length(); i++) {
			if (('a' <= s.charAt(i)) && (s.charAt(i) <= 'z')) {
				result += s.substring(i, i + 1);
			}
		}
		return result;
	}

	public void update(List<String> classes) {
		if (key != null) {
			String newKey = key;
			//			if (packageDescriptor == null) {
			//				newKey = createKey();
			//				if (newKey == null) {
			//					return;
			//				}
			//			} else {
			//				newKey = createPackageBasedKey();
			//			}

			if (verbose == Level.ALL) {
				System.out.println(""UPDATING CACHE: "" + key);
			}

			// updating. Remove the previpous version if present and add the new classes

			String previous = getSettings().get(CURRENT_VERSION, null);
			if (previous != null) {
				TreeSet<String> installed = new TreeSet<>(Arrays.asList(previous.split(""/"")));
				Iterator<String> it = installed.iterator();
				if (installed.size() >= 5) {
					// already keeping 5 versions alive. Remove one if
					// current not already present.
					if (!installed.contains(newKey)) {
						String toRemove = it.next();
						getSettings().remove(toRemove);

					}
				}
				previous = newKey;
				while (it.hasNext()) {
					previous += '/';
					previous += it.next();
				}
				getSettings().put(CURRENT_VERSION, previous);

			} else {
				getSettings().put(CURRENT_VERSION, newKey);
			}

			classNames.clear();
			for (String name : classes) {
				if ((name != null) && (name.length() > 0)) {
					classNames.add(name);
				}
			}

			StringBuffer value = new StringBuffer("""");
			for (String name : classNames) {
				if (verbose == Level.ALL) {
					System.out.println(""               : "" + name);
				}
				value.append(name);
				value.append(""/"");
			}

			if (value.length() > Preferences.MAX_VALUE_LENGTH) {
				int subkeys = (value.length() / Preferences.MAX_VALUE_LENGTH) + 1;
				getSettings().put(key, """" + subkeys);
				for (int i = 0; i < subkeys; i++) {
					getSettings().put(
							key + ""-"" + i,
							value.substring(i * Preferences.MAX_VALUE_LENGTH,
									Math.min((i + 1) * Preferences.MAX_VALUE_LENGTH, value.length())));
				}
			} else {

				getSettings().put(key, value.toString());
			}
		}
	}

	/**
	 * If a package descriptor is given, we use that to build the cache. The
	 * version number is increased automatically now with every build/release,
	 * hence we can use that to determine the cache.
	 * 
	 * @return
	 */
	private Preferences getSettings() {

		//		String className = getClass().getName();
		//		int pkgEndIndex = className.lastIndexOf('.');
		//		if (pkgEndIndex < 0) {
		//			className = ""/<unnamed>"";
		//		} else {
		//			String packageName = className.substring(0, pkgEndIndex);
		//			className = ""/"" + packageName.replace('.', '/');
		//		}
		if (packageDescriptor == null) {
			//			return Preferences.userRoot().node(className + ""/_jarfiles/"" + jarName);
			return PACKAGECACHE.node(""_jarfiles/"" + jarName);

		} else {
			return PACKAGECACHE.node(jarName);
			//			return Preferences.userRoot().node(className + '/' + jarName);
		}
	}

	/**
	 * Clear the cache here.
	 * 
	 * @return
	 */
	public static void clearSettingsCache() throws BackingStoreException {
		Preferences node = Preferences.userNodeForPackage(PluginCacheEntry.class);
		node.removeNode();
		node.flush();
		PACKAGECACHE.removeNode();
		PACKAGECACHE.flush();
		PACKAGECACHE = initCache();
	}

}
"
PluginContextIDImpl.java,context,"package org.processmining.framework.plugin.impl;

import java.util.UUID;

import org.processmining.framework.plugin.PluginContextID;

public class PluginContextIDImpl implements PluginContextID {

	private final UUID id = UUID.randomUUID();

	public String toString() {
		return id.toString();
	}

	public int hashCode() {
		return id.hashCode();
	}

	public boolean equals(Object o) {
		if (!(o instanceof PluginContextIDImpl)) {
			return false;
		} else {
			return ((PluginContextIDImpl) o).id.equals(id);
		}
	}

	public int compareTo(PluginContextID o) {
		if (!(o instanceof PluginContextIDImpl)) {
			// Nasty implementation and not likely to be necessary,
			// as the ProvidedObjectManager should take care of not
			// using different object as ID.
			return PluginContextIDImpl.class.getName().compareTo(o.getClass().getName());
		} else {
			return ((PluginContextIDImpl) o).id.compareTo(id);
		}
	}
}
"
PluginDescriptorIDImpl.java,context,"package org.processmining.framework.plugin.impl;

import java.lang.reflect.Method;

import org.processmining.framework.plugin.PluginDescriptorID;

public class PluginDescriptorIDImpl implements PluginDescriptorID {

	private final String id;

	public PluginDescriptorIDImpl(Method pluginMethod) {
		String temp = pluginMethod.toGenericString();
		int index = temp.indexOf("" throws "");
		if (index >= 0) {
			temp = temp.substring(0, index);
		}
		id = temp;
	}

	public PluginDescriptorIDImpl(Class<?> pluginClass) {
		id = pluginClass.getName();
	}

//	public PluginDescriptorIDImpl(MacroPluginDescriptorImpl macroPluginDescriptorImpl) {
//		id = macroPluginDescriptorImpl.getFileName();
//	}

	public String toString() {
		return id;
	}

	public int hashCode() {
		return id.hashCode();
	}

	public boolean equals(Object o) {
		if (!(o instanceof PluginDescriptorIDImpl)) {
			return false;
		} else {
			return ((PluginDescriptorIDImpl) o).id.equals(id);
		}
	}

	public int compareTo(PluginDescriptorID o) {
		if (!(o instanceof PluginDescriptorIDImpl)) {
			// Nasty implementation and not likely to be necessary,
			// as the ProvidedObjectManager should take care of not
			// using different object as ID.
			return PluginDescriptorIDImpl.class.getName().compareTo(o.getClass().getName());
		} else {
			return ((PluginDescriptorIDImpl) o).id.compareTo(id);
		}
	}
}
"
PluginDescriptorImpl.java,context,"package org.processmining.framework.plugin.impl;

import java.io.IOException;
import java.io.InputStream;
import java.lang.annotation.Annotation;
import java.lang.reflect.AnnotatedElement;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.net.URL;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import javax.imageio.ImageIO;
import javax.swing.ImageIcon;

import org.processmining.framework.boot.Boot;
import org.processmining.framework.packages.PackageDescriptor;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.PluginDescriptor;
import org.processmining.framework.plugin.PluginDescriptorID;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginCategory;
import org.processmining.framework.plugin.annotations.PluginLevel;
import org.processmining.framework.plugin.annotations.PluginQuality;
import org.processmining.framework.plugin.annotations.PluginVariant;

public class PluginDescriptorImpl extends AbstractPluginDescriptor {

	private final AnnotatedElement annotatedElement;
	// This list contains either Class<? extends Object> or
	// Class<? extends Object[]>
	private final PluginDescriptorID id;
	private final List<List<Class<?>>> parameterTypes;
	private List<String> parameterNames;
	private final List<Class<?>> returnTypes;
	private final List<Method> methods;
	private final List<String> returnNames;
	private final String name;
	//	public Class<? extends PluginContext> contextType = null;
	private final Class<?> declaringClass;
	private final PackageDescriptor pack;

	private String help;
	private String[] keywords;
	private PluginCategory[] categories;
	private PluginQuality quality;
	private PluginLevel level;
	private ImageIcon icon;
	private URL url;

	private final static Map<String, ImageIcon> icons = new HashMap<String, ImageIcon>();
	private final static Map<String, URL> urls = new HashMap<String, URL>();

	PluginDescriptorImpl(Method method, PackageDescriptor pack) throws Exception {
		assert (method != null);
		assert (method.isAnnotationPresent(Plugin.class));
		this.pack = pack;
		id = new PluginDescriptorIDImpl(method);
		parameterTypes = new ArrayList<List<Class<?>>>(1);
		ArrayList<Class<?>> list = new ArrayList<Class<?>>(method.getParameterTypes().length - 1);
		parameterTypes.add(list);
		declaringClass = method.getDeclaringClass();

		for (Class<?> par : method.getParameterTypes()) {
			if (!PluginContext.class.isAssignableFrom(par)) {
				list.add(par);
			}
		}
		methods = new ArrayList<Method>(1);
		methods.add(method);

		annotatedElement = method;
		name = method.getAnnotation(Plugin.class).name();
		help = method.getAnnotation(Plugin.class).help();
		keywords = method.getAnnotation(Plugin.class).keywords();
		categories = method.getAnnotation(Plugin.class).categories();
		quality = method.getAnnotation(Plugin.class).quality();
		level = method.getAnnotation(Plugin.class).level();

		String iconString = method.getAnnotation(Plugin.class).icon();
		if (icons.containsKey(iconString)) {
			icon = icons.get(iconString);
		} else {
			icon = iconString.isEmpty() ? null : new ImageIcon(new URL(iconString));
			if (icon != null) {
				System.out.println(""[PluginDescriptorImpl] Found icon at "" + iconString);
			} else {
				System.out.println(""[PluginDescriptorImpl] Found no icon at "" + iconString);
			}
			icons.put(iconString, icon);
		}

		String urlString = method.getAnnotation(Plugin.class).url();
		if (urls.containsKey(urlString)) {
			url = urls.get(urlString);
		} else {
			url = urlString.isEmpty() ? null : new URL(urlString);
			urls.put(urlString, url);
		}

		//		System.out.println(""PluginDescriptorImpl,\"""" + name + ""\"",\"""" + (pack == null ? """" : pack.getName()) + ""\"""");

		parameterNames = Arrays.asList(getAnnotation(Plugin.class).parameterLabels());
		if (parameterNames.size() == 0) {
			parameterNames = new ArrayList<String>(parameterTypes.size());
			for (Class<?> par : list) {
				parameterNames.add(par.getSimpleName());
			}
		}

		returnTypes = Arrays.asList(getAnnotation(Plugin.class).returnTypes());
		assert (getAnnotation(Plugin.class).returnLabels().length == returnTypes.size());
		returnNames = Arrays.asList(getAnnotation(Plugin.class).returnLabels());
	}

	PluginDescriptorImpl(Class<?> type, Class<? extends PluginContext> acceptedContext, PackageDescriptor pack)
			throws Exception {
		assert (type != null);
		assert (type.isAnnotationPresent(Plugin.class));

		this.pack = pack;
		id = new PluginDescriptorIDImpl(type);
		annotatedElement = type;
		declaringClass = type;
		methods = new ArrayList<Method>();

		String[] pls = getAnnotation(Plugin.class).parameterLabels();

		int max = -1;
		for (Method method : type.getMethods()) {
			if (method.isAnnotationPresent(PluginVariant.class)) {
				if (method.getParameterTypes()[0].isAssignableFrom(acceptedContext)) {
					methods.add(method);
				}

				int[] requiredPar = method.getAnnotation(PluginVariant.class).requiredParameterLabels();
				for (int i : requiredPar) {
					if (i > max) {
						max = i;
					}
				}
			}
		}
		max++;

		parameterTypes = new ArrayList<List<Class<?>>>(methods.size());

		for (Method method : methods) {
			int[] requiredPar = method.getAnnotation(PluginVariant.class).requiredParameterLabels();
			ArrayList<Class<?>> list = new ArrayList<Class<?>>(method.getParameterTypes().length - 1);
			for (int i = 0; i < requiredPar.length; i++) {
				list.add(method.getParameterTypes()[i + 1]);
			}
			parameterTypes.add(list);
		}

		name = type.getAnnotation(Plugin.class).name();
		help = type.getAnnotation(Plugin.class).help();
		keywords = type.getAnnotation(Plugin.class).keywords();
		categories = type.getAnnotation(Plugin.class).categories();
		quality = type.getAnnotation(Plugin.class).quality();
		level = type.getAnnotation(Plugin.class).level();
		//		System.out.println(""PluginDescriptorImpl,\"""" + name + ""\"",\"""" + (pack == null ? """" : pack.getName()) + ""\"""");

		String iconString = type.getAnnotation(Plugin.class).icon();
		if (icons.containsKey(iconString)) {
			icon = icons.get(iconString);
		} else {
			/*
			 * Read the icon from a lib/images folder.
			 */
			InputStream url = Thread.currentThread().getContextClassLoader()
					.getResourceAsStream(""images/"" + iconString);
			if (url == null) {
				icon = null;
			} else {
				try {
					icon = new ImageIcon(ImageIO.read(url));
				} catch (IOException e) {
					icon = null;
				}
			}

			//			icon = iconString.isEmpty() ? null : new ImageIcon(new URL(iconString));
			if (icon != null) {
				System.out.println(""[PluginDescriptorImpl] Found icon at "" + iconString);
			} else {
				System.out.println(""[PluginDescriptorImpl] Found no icon at "" + iconString);
			}
			icons.put(iconString, icon);
		}

		String urlString = type.getAnnotation(Plugin.class).url();
		if (urls.containsKey(urlString)) {
			url = urls.get(urlString);
		} else {
			url = urlString.isEmpty() ? null : new URL(urlString);
			urls.put(urlString, url);
		}

		// There are either no parameters, or all parameters are required at least once
		// in all variants, ignoring the specific context.
		//
		if ((pls.length > 0) && (pls.length < max)) {
			String message = ""Plugin "" + name
					+ "" could not be added as a plugin. There is at lease one declared parameter type,""
					+ "" which is not used by any of the plugin's variants."";
			throw new AssertionError(message);
		}

		parameterNames = Arrays.asList(pls);

		returnTypes = Arrays.asList(type.getAnnotation(Plugin.class).returnTypes());
		assert (getAnnotation(Plugin.class).returnLabels().length == returnTypes.size());
		returnNames = Arrays.asList(type.getAnnotation(Plugin.class).returnLabels());
	}

	PluginDescriptorImpl(String className, String name, Class<?>[] parTypes, PackageDescriptor pack) throws Exception {
		this(Class.forName(className).getMethod(name, parTypes), pack);
	}

	public PackageDescriptor getPackage() {
		return pack;
	}

	public int getMostSignificantResult() {
		return getAnnotation(Plugin.class).mostSignificantResult();
	}

	AnnotatedElement getAnnotatedElement() {
		return annotatedElement;
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see
	 * org.processmining.framework.plugin.PluginDescriptor#hasAnnotation(java
	 * .lang.Class)
	 */
	public boolean hasAnnotation(Class<? extends Annotation> annotationClass) {
		return getAnnotatedElement().isAnnotationPresent(annotationClass);
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see
	 * org.processmining.framework.plugin.PluginDescriptor#getAnnotation(java
	 * .lang.Class)
	 */
	public <T extends Annotation> T getAnnotation(Class<T> annotationClass) {
		return getAnnotatedElement().getAnnotation(annotationClass);
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see org.processmining.framework.plugin.PluginDescriptor#getName()
	 */
	public String getName() {
		return name;
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see org.processmining.framework.plugin.PluginDescriptor#hashCode()
	 */
	@Override
	public int hashCode() {
		return id.hashCode();
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see
	 * org.processmining.framework.plugin.PluginDescriptor#equals(java.lang.
	 * Object)
	 */
	@Override
	public boolean equals(Object other) {
		if (!(other instanceof PluginDescriptorImpl)) {
			return false;
		}
		PluginDescriptorImpl otherDesc = (PluginDescriptorImpl) other;
		return id.equals(otherDesc.id);

		// note: this does not compare whether the plugins have been loaded by
		// the same class loader
		// return getMethod().getDeclaringClass().getName().equals(
		// otherDesc.getMethod().getDeclaringClass().getName())
		// && getMethod().getName()
		// .equals(otherDesc.getMethod().getName());
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see org.processmining.framework.plugin.PluginDescriptor#toString()
	 */
	@Override
	public String toString() {
		return getName();
	}

	protected Object[] execute(PluginContext context, int methodIndex, Object... allArgs) throws Exception {
		Method method = getMethod(methodIndex);
		if (returnTypes.size() > 1) { // method.getReturnType().isArray())
			// {
			Object[] result;
			if ((method.getModifiers() & Modifier.STATIC) == Modifier.STATIC) {
				result = (Object[]) method.invoke(null, allArgs);
			} else {
				result = (Object[]) method.invoke(declaringClass.newInstance(), allArgs);
			}

			return result;
		} else {
			Object result;
			if ((method.getModifiers() & Modifier.STATIC) == Modifier.STATIC) {
				result = method.invoke(null, allArgs);
			} else {
				result = method.invoke(declaringClass.newInstance(), allArgs);
			}

			return new Object[] { result };
		}
	}

	protected Method findMethod(Object[] allArgs) {
		for (Method m : ((Class<?>) annotatedElement).getMethods()) {
			if (m.isAnnotationPresent(PluginVariant.class)) {
				boolean match = (m.getParameterTypes().length == allArgs.length);
				for (int i = 0; (i < allArgs.length) && match; i++) {
					Class<?> type = m.getParameterTypes()[i];
					if (type.isArray()) {
						if (allArgs[i].getClass().isArray()) {
							for (Object o : (Object[]) allArgs[i]) {
								match &= type.getComponentType().isAssignableFrom(o.getClass());
							}
						} else {
							match = false;
						}
					} else {
						match &= type.isAssignableFrom(allArgs[i].getClass());
					}
				}
				if (match) {
					return m;
				}
			}
		}
		return null;
	}

	/**
	 * returns the labels of the objects returned if this plugin is invoked, in
	 * the order in which they are returned
	 * 
	 * @return
	 */
	public List<Class<? extends Object>> getReturnTypes() {
		return Collections.unmodifiableList(returnTypes);
	}

	public List<Class<?>> getParameterTypes(int methodIndex) {
		return Collections.unmodifiableList(getParameterTypes().get(methodIndex));
	}

	public Class<?> getPluginParameterType(int methodIndex, int parameterIndex) {
		if (methods.get(methodIndex).isAnnotationPresent(PluginVariant.class)) {
			int[] req = methods.get(methodIndex).getAnnotation(PluginVariant.class).requiredParameterLabels();
			for (int j = 0; j < req.length; j++) {
				if (req[j] == parameterIndex) {
					return parameterTypes.get(methodIndex).get(j);
				}
			}
			return null;
		} else {
			return parameterTypes.get(methodIndex).get(parameterIndex);
		}
	}

	public List<List<Class<?>>> getParameterTypes() {
		return Collections.unmodifiableList(parameterTypes);
	}

	public List<String> getParameterNames() {
		return Collections.unmodifiableList(parameterNames);
	}

	public Set<Class<?>> getTypesAtParameterIndex(int index) {
		HashSet<Class<?>> result = new HashSet<Class<?>>();
		for (int j = 0; j < methods.size(); j++) {
			Class<?> name = getPluginParameterType(j, index);
			if (name != null) {
				result.add(name);
			}
		}

		return result;
	}

	/**
	 * Return the number of methods in this plugin.
	 * 
	 * @return
	 */
	public int getNumberOfMethods() {
		return methods.size();
	}

	public List<String> getParameterNames(int methodIndex) {
		if (methods.get(methodIndex).isAnnotationPresent(PluginVariant.class)) {
			ArrayList<String> list = new ArrayList<String>();
			int[] req = methods.get(methodIndex).getAnnotation(PluginVariant.class).requiredParameterLabels();
			for (int i : req) {
				list.add(parameterNames.get(i));
			}
			return Collections.unmodifiableList(list);
		} else {
			return Collections.unmodifiableList(parameterNames);
		}
	}

	public String getPluginParameterName(int methodIndex, int parameterIndex) {
		if (methods.get(methodIndex).isAnnotationPresent(PluginVariant.class)) {
			int[] req = methods.get(methodIndex).getAnnotation(PluginVariant.class).requiredParameterLabels();
			for (int j = 0; j < req.length; j++) {
				if (req[j] == parameterIndex) {
					return parameterNames.get(parameterIndex);
				}
			}
			return null;
		} else {
			return parameterNames.get(parameterIndex);
		}
	}

	/**
	 * returns the types of the objects returned if this plugin is invoked, in
	 * the order in which they are returned
	 * 
	 * @return
	 */
	public List<String> getReturnNames() {
		return Collections.unmodifiableList(returnNames);
	}

	public PluginDescriptorID getID() {
		return id;
	}

	@SuppressWarnings(""unchecked"")
	public Class<? extends PluginContext> getContextType(int methodIndex) {
		return (Class<? extends PluginContext>) methods.get(methodIndex).getParameterTypes()[0];
	}

	public int compareTo(PluginDescriptor plugin) {
		if (plugin.equals(this)) {
			return 0;
		}

		int c = getName().toLowerCase().compareTo(plugin.getName().toLowerCase());
		if (c == 0) {
			c = id.compareTo(plugin.getID());
		}
		return c;
	}

	Method getMethod(int i) {
		return methods.get(i);
	}

	public int getIndexInParameterNames(int methodIndex, int methodParameterIndex) {
		if (methods.get(methodIndex).isAnnotationPresent(PluginVariant.class)) {
			int[] req = methods.get(methodIndex).getAnnotation(PluginVariant.class).requiredParameterLabels();
			return req[methodParameterIndex];
		} else {
			return methodParameterIndex;
		}
	}

	public int getIndexInMethod(int methodIndex, int parameterIndex) {
		if (methods.get(methodIndex).isAnnotationPresent(PluginVariant.class)) {
			int[] req = methods.get(methodIndex).getAnnotation(PluginVariant.class).requiredParameterLabels();
			for (int i = 0; i < req.length; i++) {
				if (req[i] == parameterIndex) {
					return i;
				}
			}
			return -1;
		} else {
			return parameterIndex;
		}
	}

	public String getMethodLabel(int methodIndex) {
		if (methods.get(methodIndex).isAnnotationPresent(PluginVariant.class)
				&& !methods.get(methodIndex).getAnnotation(PluginVariant.class).variantLabel().equals("""")) {
			return methods.get(methodIndex).getAnnotation(PluginVariant.class).variantLabel();
		} else {
			return name;
		}
	}

	public boolean isUserAccessible() {
		return getAnnotation(Plugin.class).userAccessible();
	}

	public boolean handlesCancel() {
		return getAnnotation(Plugin.class).handlesCancel();
	}

	public <T extends Annotation> T getAnnotation(Class<T> annotationClass, int methodIndex) {
		return getMethod(methodIndex).getAnnotation(annotationClass);
	}

	public boolean hasAnnotation(Class<? extends Annotation> annotationClass, int methodIndex) {
		return getMethod(methodIndex).getAnnotation(annotationClass) != null;
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see org.processmining.framework.plugin.PluginDescriptor#getName()
	 */
	public String getHelp() {
		return help;
	}

	public String getMethodHelp(int methodIndex) {
		if (methods.get(methodIndex).isAnnotationPresent(PluginVariant.class)
				&& !methods.get(methodIndex).getAnnotation(PluginVariant.class).help().equals("""")) {
			return methods.get(methodIndex).getAnnotation(PluginVariant.class).help();
		} else {
			return name;
		}
	}

	public String[] getKeywords() {
		return this.keywords;
	}

	public String[] getCategories() {
		String[] categoryLabels = new String[this.categories.length];
		for (int i = 0; i < this.categories.length; i++) {
			categoryLabels[i] = this.categories[i].getName();//.getName();
		}
		return categoryLabels;
	}

	public boolean meetsQualityThreshold() {
		return Boot.PLUGIN_QUALITY_THRESHOLD.getValue() <= quality.getValue();
	}

	public boolean meetsLevelThreshold() {
		return Boot.PLUGIN_LEVEL_THRESHOLD.getValue() <= level.getValue();
	}

	public ImageIcon getIcon() {
		return icon;
	}

	public URL getURL() {
		return url;
	}
}
"
PluginExecutionResultImpl.java,context,"package org.processmining.framework.plugin.impl;

import java.util.Arrays;
import java.util.concurrent.CancellationException;
import java.util.concurrent.ExecutionException;

import org.processmining.framework.plugin.IncorrectReturnTypeException;
import org.processmining.framework.plugin.PluginDescriptor;
import org.processmining.framework.plugin.PluginExecutionResult;
import org.processmining.framework.plugin.ProMFuture;
import org.processmining.framework.plugin.events.NameChangeListener;
import org.processmining.framework.providedobjects.ProvidedObjectID;
import org.processmining.framework.util.Cast;

public class PluginExecutionResultImpl implements PluginExecutionResult {

	private Object[] objects;
	private Exception exception = null;
	private final Class<?>[] returnTypes;
	private final String pluginName;
	private final String[] returnNames;
	private final ProvidedObjectID[] ids;
	private Object[] parameters;
	private final PluginDescriptor plugin;

	public PluginExecutionResultImpl(Class<?>[] returnTypes, String[] returnNames, PluginDescriptor plugin) {
		this.returnNames = returnNames;
		this.plugin = plugin;
		pluginName = plugin.getName();
		objects = new Object[returnTypes.length];
		ids = new ProvidedObjectID[returnTypes.length];
		this.returnTypes = returnTypes;
		Arrays.fill(objects, null);
		Arrays.fill(ids, null);
	}

	public int getSize() {
		return returnNames.length;
	}

	void setResult(Object[] objects) throws IncorrectReturnTypeException {
		this.objects = objects;
		for (int i = 0; i < returnTypes.length; i++) {
			if (!returnTypes[i].equals(void.class)) {
				if (objects[i] == null) {
					continue;
				}
				Class<?> type = objects[i].getClass();
				if (objects[i] instanceof ProMFuture<?>) {
					type = Cast.<ProMFuture<?>>cast(objects[i]).getReturnType();
				}
				if (!returnTypes[i].isAssignableFrom(type)) {
					throw new IncorrectReturnTypeException(pluginName, i, returnTypes[i], objects[i].getClass());
				}
				if (objects[i] instanceof ProMFuture<?>) {
					final int index = i;
					((ProMFuture<?>) objects[i]).getNameChangeListeners().add(new NameChangeListener() {

						public void nameChanged(String newName) {
							returnNames[index] = newName;
						}
					});
				}
			}
		}
	}

	Object getObject(int resultIndex) {
		return objects[resultIndex];
	}

	void setException(Exception t) {
		exception = t;
	}

	Exception getException() {
		return exception;
	}

	@SuppressWarnings(""unchecked"")
	public <T> T getResult(int resultIndex) throws ClassCastException {
		return (T) getObject(resultIndex);
	}

	public String getResultName(int resultIndex) {
		synchronized (objects) {
			if (getObject(resultIndex) instanceof ProMFuture<?>) {
				return Cast.<ProMFuture<?>>cast(getObject(resultIndex)).getLabel();
			} else {
				return returnNames[resultIndex];
			}
		}
	}

	public String[] getResultNames() {
		return returnNames;
	}

	public Object[] getResults() {
		return objects;
	}

	public void synchronize() throws CancellationException, ExecutionException, InterruptedException {
		for (int i = 0; i < objects.length; i++) {
			if (objects[i] instanceof ProMFuture<?>) {
				Object o = Cast.<ProMFuture<?>>cast(objects[i]).get();
				synchronized (objects) {
					objects[i] = o;
				}
			}
		}
	}

	int getExpectedSize() {
		return objects.length;
	}

	public void setProvidedObjectID(int i, ProvidedObjectID id) {
		ids[i] = id;
	}

	public ProvidedObjectID getProvidedObjectID(int i) {
		return ids[i];
	}

	public void setInput(Object[] parameters) {
		this.parameters = parameters;
	}

	public Object[] getParameters() {
		return parameters;
	}

	@SuppressWarnings(""unchecked"")
	public <T> Class<? super T> getType(int i) {
		return (Class<? super T>) returnTypes[i];
	}

	public PluginDescriptor getPlugin() {
		return plugin;
	}

}
"
PluginManagerImpl.java,context,"package org.processmining.framework.plugin.impl;

import java.io.File;
import java.io.FileFilter;
import java.io.IOException;
import java.io.InputStream;
import java.lang.annotation.Annotation;
import java.lang.reflect.AnnotatedElement;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.net.MalformedURLException;
import java.net.URISyntaxException;
import java.net.URL;
import java.net.URLClassLoader;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Queue;
import java.util.Set;
import java.util.SortedSet;
import java.util.TreeSet;
import java.util.jar.JarEntry;
import java.util.jar.JarInputStream;

import javax.swing.event.EventListenerList;

import org.processmining.framework.boot.Boot;
import org.processmining.framework.boot.Boot.Level;
import org.processmining.framework.packages.PackageDescriptor;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.PluginDescriptor;
import org.processmining.framework.plugin.PluginDescriptorID;
import org.processmining.framework.plugin.PluginManager;
import org.processmining.framework.plugin.PluginParameterBinding;
import org.processmining.framework.plugin.annotations.Bootable;
import org.processmining.framework.plugin.annotations.KeepInProMCache;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.framework.util.Pair;
import org.processmining.framework.util.collection.ComparablePair;

public final class PluginManagerImpl implements PluginManager {

	private static final char PACKAGE_SEPARATOR = '.';
	private static final char URL_SEPARATOR = '/';
	private static final char INNER_CLASS_MARKER = '$';

	private static PluginManagerImpl pluginManager;

	private final Set<Class<?>> knownObjectTypes = new HashSet<Class<?>>();

	private final Map<PluginDescriptorID, PluginDescriptor> plugins = new HashMap<PluginDescriptorID, PluginDescriptor>();
	private final Map<Class<? extends Annotation>, Set<PluginDescriptor>> annotation2plugins = new HashMap<Class<? extends Annotation>, Set<PluginDescriptor>>();
	private final EventListenerList pluginManagerListeners = new EventListenerList();
	private final Class<? extends PluginContext> pluginContextType;

	private final Map<Class<? extends Annotation>, Set<Class<?>>> annotatedClasses = new HashMap<Class<? extends Annotation>, Set<Class<?>>>();

	private PluginManagerImpl(Class<? extends PluginContext> pluginContextType) {
		this.pluginContextType = pluginContextType;
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see
	 * org.processmining.framework.plugin.PluginManager#addErrorListener(org
	 * .processmining.framework.plugin.PluginManagerImpl.ErrorListener)
	 */
	public void addListener(PluginManagerListener listener) {
		pluginManagerListeners.add(PluginManagerListener.class, listener);
	}

	public Set<Class<?>> getKnownClassesAnnotatedWith(Class<? extends Annotation> annotationType) {
		Set<Class<?>> set = annotatedClasses.get(annotationType);
		if (set == null) {
			return Collections.emptySet();
		} else {
			return Collections.unmodifiableSet(set);
		}
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see
	 * org.processmining.framework.plugin.PluginManager#removeErrorListener(
	 * org.processmining.framework.plugin.PluginManagerImpl.ErrorListener)
	 */
	public void removeListener(PluginManagerListener listener) {
		pluginManagerListeners.remove(PluginManagerListener.class, listener);
	}

	protected void fireError(URL url, Throwable t, String className) {
		for (PluginManagerListener listener : pluginManagerListeners.getListeners(PluginManagerListener.class)) {
			listener.error(url, t, className);
		}

	}

	protected void firePluginAdded(PluginDescriptor plugin, Collection<Class<?>> types) {
		for (PluginManagerListener listener : pluginManagerListeners.getListeners(PluginManagerListener.class)) {
			listener.newPlugin(plugin, types);
		}
	}

	public static void initialize(Class<? extends PluginContext> pluginContextType) {
		if (pluginManager == null) {
			pluginManager = new PluginManagerImpl(pluginContextType);
		}
	}

	public static PluginManager getInstance() {
		return pluginManager;
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see
	 * org.processmining.framework.plugin.PluginManager#register(java.net.URL)
	 */
	public void register(URL url, PackageDescriptor pack) {
		URLClassLoader loader = new URLClassLoader(new URL[] { url });
		register(url, pack, loader);
	}

	public void register(URL url, PackageDescriptor pack, ClassLoader loader) {
		if (url.getProtocol().equals(FILE_PROTOCOL)) {
			try {
				File file = new File(url.toURI());

				if (file.isDirectory()) {
					scanDirectory(file, pack, loader);
					return;
				}
				//				if (file.getAbsolutePath().endsWith(PluginManager.MCR_EXTENSION)) {
				//					try {
				//						loadClassFromMacro(url.toURI(), pack);
				//					} catch (DependsOnUnknownException e) {
				//						// Can't add this URL.
				//					}
				//				}
				if (file.getAbsolutePath().endsWith(JAR_EXTENSION)) {
					scanUrl(url, pack, loader);
				}
			} catch (URISyntaxException e) {
				fireError(url, e, null);
			}
		} else {
			scanUrl(url, pack, loader);
		}
	}

	private void scanDirectory(File file, PackageDescriptor pack, ClassLoader loader) {
		try {
			URL url = file.toURI().toURL();

			Queue<File> todo = new LinkedList<File>();
			FileFilter filter = new FileFilter() {
				public boolean accept(File pathname) {
					return pathname.isDirectory() || pathname.getPath().endsWith(CLASS_EXTENSION)
							|| pathname.getPath().endsWith(MCR_EXTENSION) || pathname.getPath().endsWith(JAR_EXTENSION);

				}
			};

			todo.add(file);
			while (!todo.isEmpty()) {
				File dir = todo.remove();

				for (File f : dir.listFiles(filter)) {
					if (f.isDirectory()) {
						todo.add(f);
					} else {
						if (f.getAbsolutePath().endsWith(CLASS_EXTENSION)) {
							loadClassFromFile(loader, url,
									makeRelativePath(file.getAbsolutePath(), f.getAbsolutePath()), pack);
							//						} else if (f.getAbsolutePath().endsWith(MCR_EXTENSION)) {
							//							try {
							//								loadClassFromMacro(f.toURI(), pack);
							//							} catch (DependsOnUnknownException e) {
							//								todo.add(dir);
							//							}
						} else if (f.getAbsolutePath().endsWith(JAR_EXTENSION)) {
							scanUrl(f.toURI().toURL(), pack, loader);
						}
					}
				}
			}
		} catch (MalformedURLException e) {
			fireError(null, e, null);
		}
	}

	private String makeRelativePath(String root, String absolutePath) {
		String relative = absolutePath;

		if (relative.startsWith(root)) {
			relative = relative.substring(root.length());
			if (relative.startsWith(File.separator)) {
				relative = relative.substring(File.separator.length());
			}
		}
		return relative;
	}

	private void scanUrl(URL url, PackageDescriptor pack, ClassLoader loader) {

		PluginCacheEntry cached = new PluginCacheEntry(url, Boot.VERBOSE, pack);

		if (cached.isInCache()) {
			for (String className : cached.getCachedClassNames()) {
				loadClass(loader, url, className, pack);
			}
		} else {
			try {
				InputStream is = url.openStream();
				JarInputStream jis = new JarInputStream(is);
				JarEntry je;
				List<String> loadedClasses = new ArrayList<String>();

				while ((je = jis.getNextJarEntry()) != null) {
					if (!je.isDirectory() && je.getName().endsWith(CLASS_EXTENSION)) {
						String loadedClass = loadClassFromFile(loader, url, je.getName(), pack);
						if (loadedClass != null) {
							loadedClasses.add(loadedClass);
						}
					}
				}
				jis.close();
				is.close();

				cached.update(loadedClasses);
			} catch (IOException e) {
				fireError(url, e, null);
			}
		}
	}

	private String loadClassFromFile(ClassLoader loader, URL url, String classFilename, PackageDescriptor pack) {
		if (classFilename.indexOf(INNER_CLASS_MARKER) >= 0) {
			// we're not going to load inner classes
			return null;
		}
		return loadClass(loader, url,
				classFilename.substring(0, classFilename.length() - CLASS_EXTENSION.length())
						.replace(URL_SEPARATOR, PACKAGE_SEPARATOR).replace(File.separatorChar, PACKAGE_SEPARATOR),
				pack);
	}

	//	private String loadClassFromMacro(URI macroFile, PackageDescriptor pack) throws DependsOnUnknownException {
	//		MacroPluginDescriptorImpl plugin = null;
	//		try {
	//			plugin = new MacroPluginDescriptorImpl(new File(macroFile), this, pack);
	//			addPlugin(plugin);
	//		} catch (DOMException e) {
	//			e.printStackTrace();
	//		} catch (IOException e) {
	//			e.printStackTrace();
	//		} catch (SAXException e) {
	//			e.printStackTrace();
	//		} catch (ParserConfigurationException e) {
	//			e.printStackTrace();
	//		} catch (ClassNotFoundException e) {
	//			e.printStackTrace();
	//		} catch (DependsOnUnknownException e) {
	//			throw e;
	//		}
	//		return plugin == null ? null : plugin.getFileName();
	//	}

	/**
	 * Returns the name of the class, if it is annotated, or if any of its
	 * methods carries a plugin annotation!
	 * 
	 * @param loader
	 * @param url
	 * @param className
	 * @return
	 */
	private String loadClass(ClassLoader loader, URL url, String className, PackageDescriptor pack) {
		boolean isAnnotated = false;

		if ((className == null) || className.trim().equals("""") || className.startsWith(""bin-test-instrument"") || className.equals(loader.getClass().getName())) {
			return null;
		}

		className = className.trim();
		try {
			Class<?> pluginClass = Class.forName(className, false, loader);
			//isAnnotated = (pluginClass.getAnnotations().length > 0);

			// register all annotated classes
			if (pluginClass.isAnnotationPresent(KeepInProMCache.class)
					&& !Modifier.isAbstract(pluginClass.getModifiers())) {
				Annotation[] annotations = pluginClass.getAnnotations();
				isAnnotated = true;
				for (int i = 0; i < annotations.length; i++) {
					Set<Class<?>> set = annotatedClasses.get(annotations[i].annotationType());
					if (set == null) {
						set = new HashSet<Class<?>>();
						annotatedClasses.put(annotations[i].annotationType(), set);
					}
					set.add(pluginClass);
				}
			}

			Method[] methods = pluginClass.getMethods();
			// Check if plugin annotation is present
			if (pluginClass.isAnnotationPresent(Plugin.class) && isGoodPlugin(pluginClass, methods)) {
				PluginDescriptorImpl pl = new PluginDescriptorImpl(pluginClass, pluginContextType, pack);
				addPlugin(pl);
				isAnnotated = true;
			}

			for (Method method : methods) {
				if (method.isAnnotationPresent(Plugin.class) && isGoodPlugin(method)) {
					try {
						PluginDescriptorImpl pl = new PluginDescriptorImpl(method, pack);
						addPlugin(pl);
						isAnnotated = true;
					} catch (Exception e) {
						fireError(url, e, className);
						if (Boot.VERBOSE != Level.NONE) {
							System.err.println(""ERROR while adding plugin: "" + url + "":"" + e.getMessage());
						}
					}
				}
			}
		} catch (Throwable t) {
			fireError(url, t, className);
			if (Boot.VERBOSE != Level.NONE) {
				System.err.println(""ERROR while scanning for plugins at: "" + url + "":"");
				System.err.println(""   in file :"" + className);
				System.err.println(""   "" + t.getMessage());
				//t.printStackTrace();
			}
		}
		if (isAnnotated && !className.startsWith(""org.processmining."")) {
			System.err.println(""INFO class "" + className + "" contains plug-ins."");
		}
		return isAnnotated ? className : null;
	}

	private void addPlugin(PluginDescriptorImpl pl) {
		PluginDescriptorImpl old = (PluginDescriptorImpl) plugins.put(pl.getID(), pl);

		/*
		 * HV 20181130
		 * Sometimes, ProM seems to freeze when started after having updated or installed packages.
		 * However, instead of freezing it seems to be in a busy wait due to an endless loop related
		 * to the annotation2plunis variable. Somehow, it loops endlessly over a set in this map.
		 * Apparently, this set is corrupted somehow. Possibly, the code below is not reentrant.
		 * Therefore, I've added the synchronized on the variable.
		 */
		synchronized (annotation2plugins) {
			if (old != null) {
				if (Boot.VERBOSE == Level.ALL) {
					System.out.println(""Found new version of plugin: "" + pl.getName() + "" ....overwriting."");
				}
				for (Annotation annotation : old.getAnnotatedElement().getAnnotations()) {
					annotation2plugins.get(annotation.annotationType()).remove(old);
				}
			}

			for (Annotation annotation : pl.getAnnotatedElement().getAnnotations()) {
				Set<PluginDescriptor> pls = annotation2plugins.get(annotation.annotationType());
				if (pls == null) {
					pls = new TreeSet<PluginDescriptor>();
					annotation2plugins.put(annotation.annotationType(), pls);
				}
				pls.add(pl);

			}
		}
		checkTypesAfterAdd(pl);

	}

	//	private void addPlugin(MacroPluginDescriptorImpl pl) {
	//		PluginDescriptor old = plugins.put(pl.getID(), pl);
	//
	//		if (old != null) {
	//			if (Boot.VERBOSE == Level.ALL) {
	//				System.out.println(""Found new version of plugin: "" + pl.getName() + "" ....overwriting."");
	//			}
	//			annotation2plugins.get(Plugin.class).remove(old);
	//		}
	//
	//		Set<PluginDescriptor> pls = annotation2plugins.get(Plugin.class);
	//		if (pls == null) {
	//			pls = new TreeSet<PluginDescriptor>();
	//			annotation2plugins.put(Plugin.class, pls);
	//		}
	//		pls.add(pl);
	//
	//		checkTypesAfterAdd(pl);
	//	}

	private void checkTypesAfterAdd(PluginDescriptor pl) {
		HashSet<Class<?>> newTypes = new HashSet<Class<?>>();
		for (List<Class<?>> parTypes : pl.getParameterTypes()) {
			newTypes.addAll(addKnownObjectTypes(parTypes));
		}
		newTypes.addAll(addKnownObjectTypes(pl.getReturnTypes()));

		firePluginAdded(pl, newTypes);
	}

	private Collection<Class<?>> addKnownObjectTypes(Collection<Class<?>> types) {
		List<Class<?>> newTypes = new ArrayList<Class<?>>();
		for (Class<?> type : types) {
			if (type.isArray()) {
				if (knownObjectTypes.add(type.getComponentType())) {
					newTypes.add(type.getComponentType());
				}
			}
			if (knownObjectTypes.add(type)) {
				newTypes.add(type);
			}
		}
		return newTypes;
	}

	private boolean isGoodPlugin(Class<?> type, Method[] methods) {
		try {
			if (!isRightlyAnnotated(type)) {
				return false;
			}
			String[] names = type.getAnnotation(Plugin.class).parameterLabels();
			Class<?>[] returnTypes = type.getAnnotation(Plugin.class).returnTypes();

			// Check if there is at least one method annotated with PluginVariant
			List<Method> pluginMethods = new ArrayList<Method>(methods.length);
			for (Method m : methods) {
				if (m.isAnnotationPresent(PluginVariant.class)) {
					pluginMethods.add(m);
				}
			}

			// Check if for all methods, the requiredTypes are set Correctly
			Iterator<Method> it = pluginMethods.iterator();
			loop: while (it.hasNext()) {
				Method m = it.next();
				int[] required = m.getAnnotation(PluginVariant.class).requiredParameterLabels();
				Set<Integer> set = new HashSet<Integer>();
				for (int i : required) {
					set.add(i);
					if ((i < 0) || (i >= names.length)) {
						if (Boot.VERBOSE != Level.NONE) {
							System.err.println(""Method "" + m.toString()
									+ "" could not be added as a plugin. At least one required parameter is not a valid index.""
									+ ""There is no parameterlabel at index "" + i);
						}
						it.remove();
						continue loop;
					}
				}
				if (set.size() != required.length) {
					if (Boot.VERBOSE != Level.NONE) {
						System.err.println(""Method "" + m.toString()
								+ "" could not be added as a plugin. Some required indices are duplicated."");
					}
					it.remove();
				}
			}

			// Check for corresponding contexts at first indes
			it = pluginMethods.iterator();
			loop: while (it.hasNext()) {
				Method m = it.next();
				if (!isCorrectPluginContextType(m)) {
					if (Boot.VERBOSE != Level.NONE) {
						System.err.println(""Method "" + m.toString()
								+ "" could not be added as a plugin. The context should be asked as first parameter and should be a the same, or a superclass of ""
								+ pluginContextType.getName() + ""."");
					}
					it.remove();
					continue loop;
				}
			}

			it = pluginMethods.iterator();
			loop: while (it.hasNext()) {
				Method m = it.next();
				if ((returnTypes.length > 1) && !Object[].class.isAssignableFrom(m.getReturnType())
						&& !Object.class.equals(m.getReturnType())) {
					if (Boot.VERBOSE != Level.NONE) {
						System.err.println(""Method "" + m.toString()
								+ "" could not be added as a plugin. The plugin should return an array of objects as specified in the context."");
					}
					it.remove();
					continue loop;
				}
			}

			if (pluginMethods.isEmpty()) {
				if (Boot.VERBOSE != Level.NONE) {
					System.err.println(""Plugin "" + type.toString()
							+ "" could not be added as a plugin. At least one variant has to be specified."");
				}
				return false;
			}

			return true;

		} catch (NoClassDefFoundError e) {
			// required class not on classpath, cannot load as plugin
			return false;
		}
	}

	private boolean isCorrectPluginContextType(Method method) {
		if (method.getParameterTypes().length == 0) {
			return false;
		}
		if (!PluginContext.class.isAssignableFrom(method.getParameterTypes()[0])) {
			return false;
		}
		if (!method.getParameterTypes()[0].isAssignableFrom(pluginContextType)) {
			return false;
		}
		return true;
	}

	private boolean isRightlyAnnotated(AnnotatedElement element) {
		if (element.getAnnotation(Plugin.class).returnLabels().length != element.getAnnotation(Plugin.class)
				.returnTypes().length) {
			if (Boot.VERBOSE != Level.NONE) {
				System.err.println(""Plugin "" + element.toString() + "" could not be added as a plugin, the number of ""
						+ ""return types and return labels do not match."");
			}
			return false;
		}
		return true;
	}

	private boolean isGoodPlugin(Method method) throws NoClassDefFoundError {
		try {
			if (!isRightlyAnnotated(method)) {
				return false;
			}

			if ((method.getAnnotation(Plugin.class).parameterLabels().length != 0)
					&& (method.getAnnotation(Plugin.class).parameterLabels().length != method.getParameterTypes().length
							- 1)) {
				if (Boot.VERBOSE != Level.NONE) {
					System.err.println(""Plugin "" + method.toString() + "" could not be added as a plugin, the number of""
							+ "" parameter labels does not match the number of parameters."");
				}
				return false;
			}

			//		if (void.class.equals(method.getReturnType())) {
			//			System.err.println(""Method "" + method.toGenericString()
			//					+ "" could not be added as a plugin, as the resultType is void."");
			//			return false;
			//		}

			Class<?>[] returnTypes = method.getAnnotation(Plugin.class).returnTypes();
			if ((returnTypes.length > 1) && !Object[].class.isAssignableFrom(method.getReturnType())
					&& !Object.class.equals(method.getReturnType())) {
				if (Boot.VERBOSE != Level.NONE) {
					System.err.println(""Method "" + method.toString()
							+ "" could not be added as a plugin. The plugin should return an ""
							+ ""array of objects as specified in the context."");
				}
				return false;
			}

			Class<?>[] pars = method.getParameterTypes();
			if (!isCorrectPluginContextType(method)) {
				if (!method.isAnnotationPresent(Bootable.class)) {
					if (Boot.VERBOSE != Level.NONE) {
						System.err.println(""Method "" + method.toGenericString()
								+ "" could not be added as a plugin, the first parameter has to be a ""
								+ ""PluginContext and assignable from "" + pluginContextType.getName() + ""."");
					}
				}
				return false;
			}
			for (int i = 1; i < pars.length; i++) {
				Class<?> type = pars[i];
				if (PluginContext.class.isAssignableFrom(type)) {
					if (Boot.VERBOSE != Level.NONE) {
						System.err.println(""Method "" + method.toGenericString()
								+ "" could not be added as a plugin, only one context can be requested."");
					}
					return false;
				}
			}
			for (int i = 0; i < pars.length; i++) {
				if (pars[i].getTypeParameters().length > 0) {
					if (Boot.VERBOSE != Level.NONE) {
						System.err.println(""Method "" + method.toGenericString()
								+ "" could not be added as a plugin, as one of the parameters ""
								+ ""is derived from a Type using Generics"");
					}
					return false;
				}
			}
			return true;
		} catch (NoClassDefFoundError e) {
			// required class not on classpath, cannot load as plugin
			return false;
		}
	}

	public Set<Pair<Integer, PluginParameterBinding>> find(Class<? extends Annotation> annotation, Class<?> resultType,
			Class<? extends PluginContext> contextType, boolean totalMatch, boolean orderedParameters,
			boolean mustBeUserVisible, Class<?>... parameters) {

		Set<Pair<Integer, PluginParameterBinding>> result = new TreeSet<Pair<Integer, PluginParameterBinding>>();
		Set<PluginDescriptor> pls = annotation2plugins.get(annotation);
		if (pls == null) {
			return result;
		}
		for (PluginDescriptor plugin : pls) {
			if (mustBeUserVisible && (!plugin.meetsQualityThreshold() || !plugin.meetsLevelThreshold())) {
				/*
				 * Plug-in does not meet some required threshold to do so.
				 * Ignore it.
				 */
				continue;
			}
			if (!mustBeUserVisible || plugin.isUserAccessible()) {
				int i = (resultType == null ? 0 : plugin.getReturnTypes().indexOf(resultType));
				if (i < 0) {
					// Check for returned subtypes of the requested type
					i = checkIfRequestedReturnTypeIsPresent(plugin, resultType);
				}
				if (i >= 0) {
					for (int j = 0; j < plugin.getParameterTypes().size(); j++) {
						if (!plugin.getContextType(j).isAssignableFrom(contextType)) {
							// Check context types
							continue;
						}

						List<PluginParameterBinding> list = PluginParameterBinding.Factory.tryToBind(this, plugin, j,
								totalMatch, orderedParameters, parameters);
						for (PluginParameterBinding binding : list) {

							result.add(new ComparablePair<Integer, PluginParameterBinding>(i, binding));
							//							// Quit the loop since only one binding is to be
							//							// found.
							//							j = plugin.getParameterTypes().size();
						}
					}
				}
			}
		}
		return result;
	}

	public Set<Pair<Integer, PluginParameterBinding>> find(Class<? extends Annotation> annotation,
			Class<?>[] resultTypes, Class<? extends PluginContext> contextType, boolean totalMatch,
			boolean orderedParameters, boolean mustBeUserVisible, Class<?>... parameters) {

		if (resultTypes == null || resultTypes.length == 0) {
			throw new UnsupportedOperationException(
					""Cannot find plugins with empty or null list of return types using the find method with list input."");
		}

		Set<Pair<Integer, PluginParameterBinding>> result = new TreeSet<Pair<Integer, PluginParameterBinding>>();
		Set<PluginDescriptor> pls = annotation2plugins.get(annotation);
		if (pls == null) {
			return result;
		}
		for (PluginDescriptor plugin : pls) {
			if (mustBeUserVisible && (!plugin.meetsQualityThreshold() || !plugin.meetsLevelThreshold())) {
				/*
				 * Plug-in does not meet some required threshold to do so.
				 * Ignore it.
				 */
				continue;
			}
			if (!mustBeUserVisible || plugin.isUserAccessible()) {
				List<Class<?>> returnTypes = plugin.getReturnTypes();
				int[] indices = new int[resultTypes.length];
				boolean ok = returnTypes.size() == indices.length;

				for (int r = 0; ok && r < resultTypes.length; r++) {
					Class<?> resultType = resultTypes[r];
					// check if return type at index r is the right type
					ok &= isParameterAssignable(returnTypes.get(r), resultTypes[r]);
				}
				if (ok) {
					for (int j = 0; j < plugin.getParameterTypes().size(); j++) {
						if (!plugin.getContextType(j).isAssignableFrom(contextType)) {
							// Check context types
							continue;
						}

						List<PluginParameterBinding> list = PluginParameterBinding.Factory.tryToBind(this, plugin, j,
								totalMatch, orderedParameters, parameters);
						for (PluginParameterBinding binding : list) {

							for (int r = 0; r < resultTypes.length; r++) {
								result.add(new ComparablePair<Integer, PluginParameterBinding>(r, binding));
							}
							//							// Quit the loop since only one binding is to be
							//							// found.
							//							j = plugin.getParameterTypes().size();
						}
					}
				}
			}
		}
		return result;
	}

	private int checkIfRequestedReturnTypeIsPresent(PluginDescriptor plugin, Class<?> resultType) {
		for (int i = 0; i < plugin.getReturnTypes().size(); i++) {
			if (isParameterAssignable(plugin.getReturnTypes().get(i), resultType)) {
				return i;
			}
		}

		return -1;
	}

	public Collection<PluginDescriptor> find(String pluginName) {
		List<PluginDescriptor> result = new ArrayList<PluginDescriptor>();
		for (PluginDescriptor plugin : plugins.values()) {
			if (plugin.getName().equals(pluginName)) {
				result.add(plugin);
			}
		}
		return result;
	}

	public PluginDescriptor getPlugin(PluginDescriptorID id) {
		return plugins.get(id);
	}

	public PluginDescriptor getPlugin(String id) {
		for (Map.Entry<PluginDescriptorID, PluginDescriptor> entry : plugins.entrySet()) {
			if (entry.getKey().toString().equals(id)) {
				return entry.getValue();
			}
		}
		return null;
	}

	public Set<PluginParameterBinding> getPluginsAcceptingAtLeast(Class<? extends PluginContext> contextType,
			boolean mustBeUserVisible, Class<?>... parameters) {
		Set<PluginParameterBinding> result = new TreeSet<PluginParameterBinding>();
		for (Pair<Integer, PluginParameterBinding> pair : find(Plugin.class, (Class<?>) null, contextType, false, false,
				mustBeUserVisible, parameters)) {
			result.add(pair.getSecond());
		}
		return result;
	}

	public Set<PluginParameterBinding> getPluginsAcceptingInAnyOrder(Class<? extends PluginContext> contextType,
			boolean mustBeUserVisible, Class<?>... parameters) {
		Set<PluginParameterBinding> result = new TreeSet<PluginParameterBinding>();
		for (Pair<Integer, PluginParameterBinding> pair : find(Plugin.class, (Class<?>) null, contextType, true, false,
				mustBeUserVisible, parameters)) {
			result.add(pair.getSecond());
		}
		return result;
	}

	public Set<PluginParameterBinding> getPluginsAcceptingOrdered(Class<? extends PluginContext> contextType,
			boolean mustBeUserVisible, Class<?>... parameters) {
		Set<PluginParameterBinding> result = new TreeSet<PluginParameterBinding>();
		for (Pair<Integer, PluginParameterBinding> pair : find(Plugin.class, (Class<?>) null, contextType, true, true,
				mustBeUserVisible, parameters)) {
			result.add(pair.getSecond());
		}
		return result;
	}

	public Set<Pair<Integer, PluginDescriptor>> getPluginsResultingIn(Class<?> resultType,
			Class<? extends PluginContext> contextType, boolean mustBeUserVisible) {
		Set<Pair<Integer, PluginDescriptor>> result = new TreeSet<Pair<Integer, PluginDescriptor>>();
		for (Pair<Integer, PluginParameterBinding> pair : find(Plugin.class, resultType, contextType, false, false,
				mustBeUserVisible)) {
			result.add(new ComparablePair<Integer, PluginDescriptor>(pair.getFirst(), pair.getSecond().getPlugin()));
		}
		for (Pair<Integer, PluginParameterBinding> pair : find(Plugin.class, resultType, contextType, true, false,
				mustBeUserVisible)) {
			result.add(new ComparablePair<Integer, PluginDescriptor>(pair.getFirst(), pair.getSecond().getPlugin()));
		}
		return result;
	}

	private SortedSet<PluginDescriptor> getAllPluginsSorted(boolean canBeUserVisible, boolean mustBeUserVisible) {
		SortedSet<PluginDescriptor> result = new TreeSet<PluginDescriptor>();
		for (PluginDescriptor plugin : plugins.values()) {
			boolean visible = plugin.isUserAccessible();
			if (mustBeUserVisible && (!plugin.meetsQualityThreshold() || !plugin.meetsLevelThreshold())) {
				/*
				 * Plug-in can be user visible (that is, should end up in the
				 * GUI), but does not meet some required threshold. Ignore it.
				 */
				continue;
			}
			// Do not include, if:
			// mustBeUserVisible AND NOT visible, OR
			// visible AND NOT canBeUserVisible
			if (!((mustBeUserVisible && !visible) || (!canBeUserVisible && visible))) {
				result.add(plugin);
			}
		}
		return Collections.unmodifiableSortedSet(result);
	}

	public SortedSet<PluginDescriptor> getAllPlugins() {
		return getAllPluginsSorted(true, false);
	}

	public SortedSet<PluginDescriptor> getAllPlugins(boolean mustBeVisible) {
		return getAllPluginsSorted(mustBeVisible, mustBeVisible);
	}

	public boolean isParameterAssignable(Class<?> instanceType, Class<?> requestedType) {
		if (requestedType.isAssignableFrom(instanceType)) {
			return true;
		}
		if (requestedType.isArray() && requestedType.getComponentType().isAssignableFrom(instanceType)) {
			return true;
		}
		return false;
	}

	public Set<Class<?>> getKnownObjectTypes() {
		return Collections.unmodifiableSet(knownObjectTypes);
	}

}"
ProgressBarImpl.java,context,"package org.processmining.framework.plugin.impl;

import java.util.ArrayList;
import java.util.List;

import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.PluginExecutionResult;
import org.processmining.framework.plugin.ProMFuture;
import org.processmining.framework.plugin.Progress;

public class ProgressBarImpl implements Progress {

	private int value = 0;
	private int min = 0;
	private int max = 1;
	private boolean indeterminate = true;
	private String message = """";

	private static final long serialVersionUID = -3950799546173352932L;
	private final PluginContext context;
	private boolean canceled = false;

	public ProgressBarImpl(PluginContext context) {
		this.context = context;
	}

	public void setCaption(String message) {
		this.message = message;
		context.getProgressEventListeners().fireProgressCaptionChanged(message);
	}

	public void inc() {
		context.getProgressEventListeners().fireProgressChanged(++value);
		// Thread.yield();
	}

	public void setMinimum(int value) {
		min = value;
		context.getProgressEventListeners().fireProgressBoundsChanged(min, max);
	}

	public void setMaximum(int value) {
		max = value;
		context.getProgressEventListeners().fireProgressBoundsChanged(min, max);
	}

	public void setValue(int value) {
		this.value = value;
		context.getProgressEventListeners().fireProgressChanged(value);
		// Thread.yield();
	}

	public int getValue() {
		return value;
	}

	public void setIndeterminate(boolean makeIndeterminate) {
		indeterminate = makeIndeterminate;
		context.getProgressEventListeners().fireProgressIndeterminateChanged(makeIndeterminate);
	}

	public String getCaption() {
		return message;
	}

	public boolean isIndeterminate() {
		return indeterminate;
	}

	public int getMaximum() {
		return max;
	}

	public int getMinimum() {
		return min;
	}

	public boolean isCancelled() {
		PluginExecutionResult results = context.getResult();
		// [HV] To be safe, check the following:
		if (results == null) {
			return false;
		}
		for (int i = 0; !canceled && (i < results.getSize()); i++) {
			try {
				Object o = results.getResult(i);
				if (o instanceof ProMFuture<?>) {
					return results.<ProMFuture<?>>getResult(i).isCancelled();
				}
			} catch (Exception e) {
				// cancel on fail;
				return true;
			}
		}
		return canceled;
	}

	public void cancel() {
		canceled = true;
		// BVD: Cancel all children too!
		List<PluginContext> children = new ArrayList<>(context.getChildContexts());
		for (PluginContext child : children) {
			if (child != null && child.getProgress() != null) {
				child.getProgress().cancel();
			}
		}
		// Now cancel ProMFutures
		PluginExecutionResult results = context.getResult();
		for (int i = 0; i < results.getSize(); i++) {
			Object o = results.getResult(i);
			if (o instanceof ProMFuture<?>) {
				results.<ProMFuture<?>>getResult(i).cancel(true);
			}
		}
	}

}
"
IncorrectReturnTypeException.java,context,"package org.processmining.framework.plugin;

/**
 * Thrown when a plugin returns an object of the wrong type.
 * 
 * @author bfvdonge
 * 
 */
public class IncorrectReturnTypeException extends RuntimeException {

	private static final long serialVersionUID = 8553687837509819311L;

	public IncorrectReturnTypeException(String plugin, int index, Class<?> expected, Class<?> returned) {
		super(""Plugin "" + plugin + "" produced the wrong type of result at index "" + index + "": Expected: "" + expected
				+ "", but received: "" + (returned == null ? ""nothing"" : returned) + ""."");
	}
}
"
InSufficientResultException.java,context,"package org.processmining.framework.plugin;

/**
 * Thrown when a plugin returns less results than declared.
 * 
 * @author bfvdonge
 * 
 */
public class InSufficientResultException extends RuntimeException {

	private static final long serialVersionUID = -1416206990218147728L;

	public InSufficientResultException(String plugin, int expected, int returned) {
		super(""Plugin "" + plugin + "" produced "" + returned + "" results, while "" + expected + "" results were declared."");
	}

}
"
ObjectConstructor.java,context,"package org.processmining.framework.plugin;

import java.util.Collection;

import org.processmining.framework.connections.Connection;
import org.processmining.framework.connections.ConnectionCannotBeObtained;

public interface ObjectConstructor {

	/**
	 * Finds as many objects of the given type as can be found through the
	 * connections of the other given type. If no objects can be found, it
	 * constructs as many objects of the given type as there are plugins
	 * available to the framework to do so. These plugins should be able to
	 * execute in a child of the given context and accept, in any order, exactly
	 * the input provided. Any other objects returned by the plugin, not being
	 * the requested type are added to the provided objects of the framework.
	 * Also, listeners are notified where applicable. If no plugings exist, or
	 * if these plugins fail, a ConnectionDoesntExistException is thrown.
	 * 
	 * @param <T>
	 *            The type of the return object required.
	 * @param <C extends Connection> The type of the connections to use when
	 *        trying to find the objects.
	 * @param type
	 *            the type of the return object required.
	 * @param connectionType
	 *            the type of the connections to use when trying to find the
	 *            objects.
	 * @param role
	 *            the assumed role of the object in the connection. Given a
	 *            connection, the object can be retrieved through the role.
	 * @param input
	 *            the input on which the plugin should work
	 * @return a collection of objects as found or returned by the plugins.
	 */
	public <T, C extends Connection> Collection<T> tryToFindOrConstructAllObjects(Class<T> type,
			Class<C> connectionType, String role, Object... input) throws ConnectionCannotBeObtained;

	/**
	 * Returns the first object of the given type as can be found through the
	 * connections of the other given type. If no objects can be found, it
	 * constructs as an object of the given type using a plugin available to the
	 * framework to do so. This plugins should be able to execute in a child of
	 * the given context and accept, in any order, exactly the input provided.
	 * Any other objects returned by the plugin, not being the requested type
	 * are added to the provided objects of the framework. Also, listeners are
	 * notified where applicable. If no plugins exist, or if these plugins fail,
	 * a ConnectionDoesntExistException is thrown.
	 * 
	 * @param <T>
	 *            The type of the return object required.
	 * @param <C extends Connection> The type of the connections to use when
	 *        trying to find the objects.
	 * @param type
	 *            the type of the return object required.
	 * @param connectionType
	 *            the type of the connections to use when trying to find the
	 *            objects.
	 * @param role
	 *            the assumed role of the object in the connection. Given a
	 *            connection, the object can be retrieved through the role.
	 * @param input
	 *            the input on which the plugin should work
	 * @return a collection of objects as returned by the plugins.
	 */
	public <T, C extends Connection> T tryToFindOrConstructFirstObject(Class<T> type, Class<C> connectionType,
			String role, Object... input) throws ConnectionCannotBeObtained;

	/**
	 * Returns the first object of the given type as can be found through the
	 * connections of the other given type. If no objects can be found, it
	 * constructs as an object of the given type using a plugin available to the
	 * framework to do so. This plugins should be able to execute in a child of
	 * the given context and accept, in any order, exactly the input provided.
	 * Furthermore, the returned object should have the right label assigned to
	 * it in the plugin definition. Any other objects returned by the plugin,
	 * not being the requested type are added to the provided objects of the
	 * framework. Also, listeners are notified where applicable. If no plugins
	 * exist, or if these plugins fail, a ConnectionDoesntExistException is
	 * thrown.
	 * 
	 * @param <T>
	 *            The type of the return object required.
	 * @param <C extends Connection> The type of the connections to use when
	 *        trying to find the objects.
	 * @param type
	 *            the type of the return object required.
	 * @param name
	 *            the name of the plugin to use.
	 * @param connectionType
	 *            the type of the connections to use when trying to find the
	 *            objects.
	 * @param role
	 *            the assumed role of the object in the connection. Given a
	 *            connection, the object can be retrieved through the role.
	 * @param input
	 *            the input on which the plugin should work
	 * @return a collection of objects as returned by the plugins.
	 */
	public <T, C extends Connection> T tryToFindOrConstructFirstNamedObject(Class<T> type, String name,
			Class<C> connectionType, String role, Object... input) throws ConnectionCannotBeObtained;

}"
PluginContext.java,context,"package org.processmining.framework.plugin;

import java.util.List;
import java.util.concurrent.Executor;

import org.processmining.framework.connections.Connection;
import org.processmining.framework.plugin.events.Logger;
import org.processmining.framework.plugin.events.Logger.MessageLevel;
import org.processmining.framework.plugin.events.PluginLifeCycleEventListener;
import org.processmining.framework.plugin.events.ProgressEventListener;
import org.processmining.framework.plugin.impl.FieldNotSetException;
import org.processmining.framework.plugin.impl.FieldSetException;
import org.processmining.framework.util.Pair;

public interface PluginContext extends GlobalContext, ObjectConstructor {

	/**
	 * Returns a new plugin context instance, which can be used to invoke other
	 * plugins.
	 * 
	 * @return the new plugin context instance
	 */
	PluginContext createChildContext(String label);

	/* === Getters ==================================================== */

	/**
	 * Returns the progress object corresponding to this context
	 * 
	 * @return the progress object corresponding to this context
	 */
	Progress getProgress();

	/**
	 * Returns the list of registered progress listeners
	 * 
	 * @return the list of registered progress listeners
	 */
	ProgressEventListener.ListenerList getProgressEventListeners();

	/**
	 * Returns the list of registered plugin life cycle listeners.
	 * 
	 * @return the list of registered plugin life cycle listeners.
	 */
	PluginLifeCycleEventListener.List getPluginLifeCycleEventListeners();

	/**
	 * Each PluginContext should carry an ID. This ID is unique within this
	 * plugin context's global context.
	 * 
	 * @return the ID of this context
	 */
	PluginContextID getID();

	/**
	 * Returns the label of this context.
	 * 
	 * @return
	 */
	String getLabel();

	/**
	 * Return the plugin descriptor and method index of the plugin which is
	 * invoked in this context. This descriptor is set by the
	 * PluginDescriptor.invoke() method and will not be set yet before
	 * PluginManager.invoke() is called.
	 * 
	 * @return the descriptor of the plugin which is invoked in this context If
	 *         the plugin is not set yet, a pair of (null,-1) is returned
	 */
	Pair<PluginDescriptor, Integer> getPluginDescriptor();

	/**
	 * Returns the context which created this context or null if it has no
	 * parent.
	 * 
	 * @return
	 */
	PluginContext getParentContext();

	/**
	 * Returns a list of all child contexts which have been created with
	 * createChildContext().
	 * 
	 * @return
	 */
	List<PluginContext> getChildContexts();

	/**
	 * This method returns the PluginExecutionResult of the plugin which is
	 * invoked in this context. This future result is set by
	 * PluginManager.invoke() and will not be available (will be null) until the
	 * invoke() method is called.
	 * 
	 * @return The PluginExecutionResult that represents the result of this
	 *         plugin invocation
	 * @throws FieldNotSetException
	 *             If the future is not know to this context
	 */
	PluginExecutionResult getResult();

	/**
	 * This method should only be used by a plugin, in the body of that plugin.
	 * That is the only location, where it is guaranteed that each result object
	 * in getResults() can safely be cast to a ProMFuture.
	 * 
	 * @param i
	 * @return
	 */
	ProMFuture<?> getFutureResult(int i);

	/**
	 * Returns an executor which can be used to execute plugins in child
	 * contexts.
	 * 
	 * @return
	 */
	Executor getExecutor();

	/**
	 * Returns true if this is a distant child of context, i.e. true if
	 * getParent.getID().equals(context.getID()) ||
	 * getParent().isDistantChildOf(context);
	 * 
	 * @param context
	 * @return
	 */
	boolean isDistantChildOf(PluginContext context);

	/*
	 * === Setters: should only be called by the framework!
	 * ===============================
	 */

	void setFuture(PluginExecutionResult resultToBe);

	void setPluginDescriptor(PluginDescriptor descriptor, int methodIndex) throws FieldSetException,
			RecursiveCallException;

	boolean hasPluginDescriptorInPath(PluginDescriptor descriptor, int methodIndex);

	/**
	 * The provided String is provided to the context for information. It can
	 * for example signal a state change of a plugin. Note that some contexts
	 * can completely ignore this message.
	 * 
	 * @param message
	 *            the message to log
	 * @param level
	 *            the message level
	 */
	void log(String message, MessageLevel level);

	/**
	 * Same as calling log(message, MessageLevel.NORMAL);
	 * 
	 * @param message
	 *            The message
	 */
	void log(String message);

	/**
	 * The provided Exception is provided to the context. It signals the context
	 * about an error in the plugin, that specifically lead to abnormal
	 * termination. The plugin signaling the exception is no longer executing!
	 * 
	 * @param exception
	 *            the exception thrown
	 */
	void log(Throwable exception);

	/**
	 * Returns the list of logging listeners registered to this context.
	 * 
	 * @return
	 */
	Logger.ListenerList getLoggingListeners();

	/**
	 * Returns the root plugin context. This is an instance of PluginContext of
	 * which all other contexts are distant childs.
	 * 
	 * @return
	 */
	PluginContext getRootContext();

	/**
	 * Delete this child from this context.
	 * 
	 * @param child
	 * @returns true if this child was a child of the context and has now been
	 *          deleted. false otherwise
	 */
	boolean deleteChild(PluginContext child);

	/**
	 * Registers the given connection in the global context. The implementation
	 * is
	 * 
	 * addConnection(this,c);
	 * 
	 * @param c
	 */
	<T extends Connection> T addConnection(T c);

	void clear();
}
"
PluginContextID.java,context,"package org.processmining.framework.plugin;

/**
 * Represents an ID of a plugin context.
 * 
 * @author bfvdonge
 * 
 */
public interface PluginContextID extends Comparable<PluginContextID> {

	/**
	 * PluginContextID are used in Collections, so this method has to be
	 * implemented in all its subclasses.
	 * 
	 * @return
	 */
	public boolean equals(Object o);

	/**
	 * PluginContextID are used in HashMaps, so this method has to be
	 * implemented in all its subclasses.
	 * 
	 * @return
	 */
	public int hashCode();

}
"
PluginDescriptor.java,context,"package org.processmining.framework.plugin;

import java.lang.annotation.Annotation;
import java.net.URL;
import java.util.List;
import java.util.Set;

import javax.swing.ImageIcon;

import org.processmining.framework.packages.PackageDescriptor;

public interface PluginDescriptor extends Comparable<PluginDescriptor> {

	/**
	 * Check if this plugin carries the given annotation. Implementing classes
	 * can return false at their discretion, i.e. they are not required to
	 * return true for all annotations carried by the plugin.
	 * 
	 * @param annotationClass
	 * @return
	 */
	boolean hasAnnotation(Class<? extends Annotation> annotationClass);

	/**
	 * Check if the method at the given index carries the given annotation.
	 * Implementing classes can return false at their discretion, i.e. they are
	 * not required to return true for all annotations carried by the plugin.
	 * 
	 * @param annotationClass
	 * @return
	 */
	boolean hasAnnotation(Class<? extends Annotation> annotationClass, int methodIndex);

	/**
	 * Return the annotation of the given class carried by this plugin. Note
	 * that hasAnnotationClass(annotationClass) is assumed.
	 * 
	 * This method should not be used to access any annotation elements carried
	 * by Plugin.class. Implementing classes are allows to return null when
	 * called with Plugin.class.
	 * 
	 * @param <T>
	 * @param annotationClass
	 * @return
	 */
	<T extends Annotation> T getAnnotation(Class<T> annotationClass);

	/**
	 * Return the annotation of the method at the given index. Note that
	 * hasAnnotationClass(annotationClass, methodIndex) is assumed.
	 * 
	 * This method should not be used to access any annotation elements carried
	 * by Plugin.class. Implementing classes are allows to return null when
	 * called with Plugin.class.
	 * 
	 * @param <T>
	 * @param annotationClass
	 * @param methodIndex
	 * @return
	 */
	<T extends Annotation> T getAnnotation(Class<T> annotationClass, int methodIndex);

	/**
	 * Return the package where the plug-in resides.
	 * 
	 * @return
	 */
	PackageDescriptor getPackage();

	/**
	 * Return the name of the plugin. This name is not unique within ProM.
	 * 
	 * @return
	 */
	String getName();

	/**
	 * return hashcode
	 * 
	 * @return
	 */
	int hashCode();

	/**
	 * return equality of plugins. The ID is used for equality.
	 * 
	 * @param other
	 * @return
	 */
	boolean equals(Object other);

	/**
	 * Returns a String representation of the plugin
	 * 
	 * @return
	 */
	String toString();

	/**
	 * Return the number of methods in this plugin. There's always at least 1.
	 * 
	 * @return
	 */
	int getNumberOfMethods();

	/**
	 * Asynchronously invokes a method of this plugin. The methodIndex should
	 * refer to an existing method, i.e. 0 <= methodindex <
	 * getNumberOfMethods();
	 * 
	 * Note that the callers of this plugin should notify the lifeCycleListners
	 * of the given context of the creation of this plugin, i.e. they should
	 * call:
	 * <code>context.getParentContext().getPluginLifeCycleEventListeners().firePluginCreated(context);</code>
	 * 
	 * @param methodIndex
	 *            The index of the method to be invoked
	 * @param context
	 *            the context in which this plugin should be invoked. The plugin
	 *            may assume that this context is meant only for its execution.
	 * @param args
	 *            the objects to be passed to the plugin. These objects should
	 *            be in the right order. However, if <code>ProMFuture</code>
	 *            objects are provided, the plugin will synchronize on them.
	 *            This syncrhonization is performed in a fast-fail fashion, i.e.
	 *            the first future that results in an exception during execution
	 *            will result in an exception while invoking this plugin. This
	 *            exception is caught and the context is signaled about it.
	 * @return a PluginExecutionResult holding pointers to the future outcome of
	 *         this invokation. If synchrounous execution is required, the
	 *         calling method should synchronize on this result
	 */
	PluginExecutionResult invoke(int methodIndex, PluginContext context, Object... args);

	/**
	 * returns the types of the objects returned if this plugin is invoked, in
	 * the order in which they are returned
	 * 
	 * @return
	 */
	List<Class<?>> getReturnTypes();

	/**
	 * returns the labels of the objects returned if this plugin is invoked, in
	 * the order in which they are returned. These are the labels provided by
	 * the plugin definition, not the labels of the objects resulting from a
	 * specific invokation, as these can be obtained through the
	 * <code>PluginExecutionResult</code> object.
	 * 
	 * @return
	 */
	List<String> getReturnNames();

	/**
	 * returns a list of size <code>getNumberOfMethods()</code>, such that
	 * element at index <code>i</code> of the list equals
	 * <code>getParameterTypes(i)</code>
	 * 
	 * @return
	 */
	List<List<Class<?>>> getParameterTypes();

	/**
	 * Returns a list of types that represent the required parameters of the
	 * method at the given index. In other words, the method at index
	 * <code>methodIndex</code> requires exectly the parameter types as provided
	 * in the returned list, in that order.
	 * 
	 * @param methodIndex
	 * @return
	 */
	List<Class<?>> getParameterTypes(int methodIndex);

	/**
	 * Returns a list of labels that represent the possible parameters of this
	 * plugin. Each method required a subset of these labels, while preserving
	 * their order.
	 * 
	 * @return
	 */
	List<String> getParameterNames();

	/**
	 * Returns a list of labels that represent the required parameters of the
	 * method at the given index. In other words, the method at index
	 * <code>methodIndex</code> requires exactly the parameter labels as
	 * provided in the returned list, in that order.
	 * 
	 * @param methodIndex
	 * @return
	 */
	List<String> getParameterNames(int methodIndex);

	/**
	 * Return the type of the parameter at index <code>parameterIndex</code> of
	 * the method at <code>methodIndex</code>.
	 * 
	 * @param methodIndex
	 *            <code>0 <= methodIndex < getNumberOfMethods()</code>
	 * @param parameterIndex
	 *            <code>0 <= parameterIndex < getParameterTypes().size()</code>
	 * @return may return null if the parameter is not used by the given method
	 */
	Class<?> getPluginParameterType(int methodIndex, int parameterIndex);

	/**
	 * Return the label of the parameter at index <code>parameterIndex</code> of
	 * the method at <code>methodIndex</code>.
	 * 
	 * @param methodIndex
	 *            <code>0 <= methodIndex < getNumberOfMethods()</code>
	 * @param parameterIndex
	 *            <code>0 <= parameterIndex < getParameterTypes(methodIndex).size()</code>
	 * @return may return null if the parameter is not used by the given method
	 */
	String getPluginParameterName(int methodIndex, int parameterIndex);

	/**
	 * returns the ID of this Plugin. Provided that the code of a plugin does
	 * not change, these IDs are persistent between executions of ProM.
	 * 
	 * @return
	 */
	PluginDescriptorID getID();

	/**
	 * Returns the context type required by the method at index methodIndex.
	 * 
	 * @param methodIndex
	 *            <code>0 <= methodIndex < getNumberOfMethods()</code>
	 * @return
	 */
	Class<? extends PluginContext> getContextType(int methodIndex);

	/**
	 * Returns a list of types that can be accepted for the parameter at index
	 * <code>globalParameterIndex</code>. The parameter index is global, i.e.
	 * not method specific. Instead, for each type <code>t</code> in the set
	 * returned by this method it is guaranteed that there is at least one
	 * method (suppose at index <code>i</code>), such that
	 * <code>getParameterType(i, getIndexInMethod(i, globalParameterIndex)) == t</code>
	 * 
	 * @param globalParameterIndex
	 *            <code>0 <= globalParameterIndex < getParameterNames().size()</code>
	 * @return
	 */
	Set<Class<?>> getTypesAtParameterIndex(int globalParameterIndex);

	/**
	 * Returns the index of the method parameter of the given method in the list
	 * of global parameters. Each method of a plugin requires a subset of the
	 * global set of parameters that the plugin defines. This method can be used
	 * to map the index of each method parameter to the index of the global
	 * parameter.
	 * 
	 * @param methodIndex
	 *            <code>0 <= methodIndex < getNumberOfMethods()</code>
	 * @param methodParameterIndex
	 *            <code>0 <= methodParameterIndex < getParameterNames(methodIndex).size()</code>
	 * @return <code>0 <= return < getParameterNames().size()</code>
	 */
	int getIndexInParameterNames(int methodIndex, int methodParameterIndex);

	/**
	 * Returns the index of the global parameter to the index of that parameter
	 * in the given method. Each method of a plugin requires a subset of the
	 * global set of parameters that the plugin defines. This method can be used
	 * to map the index of each global parameter to the index of the method
	 * parameter. Note that if the given method does not require the global
	 * parameter, -1 is returned.
	 * 
	 * @param methodIndex
	 *            <code>0 <= methodIndex < getNumberOfMethods()</code>
	 * @param globalParameterIndex
	 *            <code>0 <= globalParameterIndex < getParameterNames().size()</code>
	 * @return <code>-1 <= return < getParameterNames(methodIndex).size()</code>
	 */
	int getIndexInMethod(int methodIndex, int globalParameterIndex);

	/**
	 * Return the label of the given method, if specified. If no label was
	 * specified, the name of the plugin is returned.
	 * 
	 * @param methodIndex
	 * @return
	 */
	String getMethodLabel(int methodIndex);

	/**
	 * Compares this plugin with another plugins. Uses the
	 * <code>getName().toLowerCase()</code> for comparing. Only if names are
	 * equal, then the IDs are used for comparison. Comparison should be
	 * name-based between different implementing classes.
	 */
	int compareTo(PluginDescriptor plugin);

	/**
	 * Returns true if this plugin can be used by the end-users. If this is set
	 * to false, such a plugin should not be presented to the end user by any
	 * context.
	 * 
	 * @return
	 */
	boolean isUserAccessible();

	/**
	 * Returns whether the plugin handles termination itself.
	 * 
	 * @return
	 */
	boolean handlesCancel();

	/**
	 * Returns the index in the result array of the most significant result for
	 * this plugin
	 * 
	 * @return the index in the result array of the most significant result. If
	 *         no results are returned by this plugin, anything can be returned.
	 */
	int getMostSignificantResult();

	/**
	 * Return the help / description of the plugin.
	 * 
	 * @return
	 */
	String getHelp();

	/**
	 * Return the help / description of the given method, if specified.
	 * 
	 * @param methodIndex
	 * @return
	 */
	String getMethodHelp(int methodIndex);
	
	
	/**
	 * Return the set of keywords.
	 * 
	 * @return a set of keywords
	 */
	String[] getKeywords();
	
	/**
	 * Return the set of categories.
	 * 
	 * @return a set of categories
	 */
	String[] getCategories();

	/**
	 * Return whether this plug-in meets the quality threshold.
	 * 
	 * @return whether this plug-in meets the quality threshold
	 */
	boolean meetsQualityThreshold();
	/**
	 * Return whether this plug-in meets the level threshold.
	 * 
	 * @return whether this plug-in meets the level threshold
	 */
	boolean meetsLevelThreshold();
	
	public ImageIcon getIcon();
	
	public URL getURL();

}
"
PluginDescriptorID.java,context,"package org.processmining.framework.plugin;

/**
 * This interface provides an ID for each plugin. These IDs are persistent
 * between executions of ProM, provided that no code changes are made to the
 * plugin in question.
 * 
 * @author bfvdonge
 * 
 */
public interface PluginDescriptorID extends Comparable<PluginDescriptorID> {

	/**
	 * ProvidedObjectIDs are used in Collections, so this method has to be
	 * implemented in all its subclasses.
	 * 
	 * @return
	 */
	public boolean equals(Object o);

	/**
	 * ProvidedObjectIDs are used in HashMaps, so this method has to be
	 * implemented in all its subclasses.
	 * 
	 * @return
	 */
	public int hashCode();

}
"
PluginExecutionResult.java,context,"package org.processmining.framework.plugin;

import java.util.concurrent.CancellationException;
import java.util.concurrent.ExecutionException;

import org.processmining.framework.providedobjects.ProvidedObjectID;

/**
 * This class represents the result of a plugin execution. It can be used to
 * obtain all details after executing a plugin.
 * 
 * Typically, plugins are executed a-synchronously, but by calling synchronize()
 * on this object, the current thread is suspended untill all results are in (or
 * exceptions are thrown)
 * 
 * @author bfvdonge
 * 
 */
public interface PluginExecutionResult {

	/**
	 * Returns the size of this result, i.e. how many objects were returned by
	 * the plugin
	 * 
	 * @return
	 */
	public int getSize();

	/**
	 * Synchronizes on any futures that might still exist in the result. If no
	 * futures exist, this method does terminate normally
	 * 
	 * @throws CancellationException
	 * @throws ExecutionException
	 * @throws InterruptedException
	 */
	public void synchronize() throws CancellationException, ExecutionException, InterruptedException;

	/**
	 * returns the results of this plugin in an array. If synchronize() was
	 * called, this method returns the actual objects. Otherwise, it might
	 * return ProMFutures on the actual objects (or any combination thereof).
	 * 
	 * @return
	 */
	public Object[] getResults();

	/**
	 * returns the result at the given index, casted to the given returntype. If
	 * synchronize() was called, this method returns the actual object.
	 * Otherwise, it might return a ProMFuture<T> on the actual object.
	 * 
	 * Note that 0<= resultIndex < getSize()
	 * 
	 * @param <T>
	 * @param resultIndex
	 * @return
	 */
	public <T> T getResult(int resultIndex) throws ClassCastException;

	/**
	 * This method returns the names of the results
	 * 
	 * @return
	 */
	public String[] getResultNames();

	/**
	 * this method returns the name of the result at the given index.
	 * 
	 * Note that 0<= resultIndex < getSize()
	 * 
	 * @param resultIndex
	 * @return
	 */
	public String getResultName(int resultIndex);

	/**
	 * Tells this result under which provided object ID the object at index i is
	 * known to the framework
	 * 
	 * @param i
	 *            index of the object
	 * @param id
	 *            the id of the provided object refering to the objet at index i
	 */
	void setProvidedObjectID(int i, ProvidedObjectID id);

	/**
	 * Returns the ProvidedObjectID under which the object at index i is known
	 * to the framework's ProvidedObject manager
	 * 
	 * @param i
	 *            index of the object
	 */
	ProvidedObjectID getProvidedObjectID(int i);

	/**
	 * Returns the type of the object at index i, as declared by the plugin
	 * 
	 * @param i
	 * @return
	 */
	public <T> Class<? super T> getType(int i);

	/**
	 * Returns the plugin used to generate this result
	 * 
	 * @return
	 */
	public PluginDescriptor getPlugin();

}
"
PluginManager.java,context,"package org.processmining.framework.plugin;

import java.lang.annotation.Annotation;
import java.net.URL;
import java.util.Collection;
import java.util.EventListener;
import java.util.Set;
import java.util.SortedSet;

import org.processmining.framework.packages.PackageDescriptor;
import org.processmining.framework.util.Pair;

/**
 * The plugin manager manages plugins. It loads plugins from URLs and provides
 * access to them through search methods.
 * 
 * @author bfvdonge
 * 
 */
public interface PluginManager {

	/**
	 * Constant to denote the file extension for class files.
	 */
	static final String CLASS_EXTENSION = "".class"";

	/**
	 * Constant to denote the file extension for macro files.
	 */
	static final String MCR_EXTENSION = "".mcr"";

	/**
	 * Constant to denote the file extension for jar files.
	 */
	static final String JAR_EXTENSION = "".jar"";

	/**
	 * Constant to denote the file protocol to be used in URLs provided to this
	 * plugin manager.
	 */
	static final String FILE_PROTOCOL = ""file"";

	/**
	 * This interface describes an error listener for the plugin manager. The method
	 * error should be called by a plugin manager while registering packages and
	 * scanning for plugins.
	 * 
	 * @author bfvdonge
	 * 
	 */
	interface PluginManagerListener extends EventListener {
		/**
		 * Listen for errors which occur while registering packages and scanning for
		 * plugins.
		 * 
		 * @param source
		 *            The URL which was being registered while this error occurred
		 * @param t
		 *            The error which occurred
		 * @param className
		 *            The class name of the class which was being registered, may be
		 *            null
		 */
		void error(URL source, Throwable t, String className);

		/**
		 * Listen for plugins that are registered to the manager. Every time a
		 * PluginDescriptor is added to the manager, an event is generated.
		 * 
		 * @param plugin
		 */
		void newPlugin(PluginDescriptor plugin, Collection<Class<?>> newTypes);
	}

	/**
	 * Adds a listener to the plugin manager.
	 * 
	 * @param listener
	 *            the listener to add.
	 */
	void addListener(PluginManagerListener listener);

	/**
	 * Removes the listener from the plugin manager.
	 * 
	 * @param listener
	 *            the listener to remove.
	 */
	void removeListener(PluginManagerListener listener);

	/**
	 * registers a URL to this plugin manager. If the URL uses the
	 * <code>FILE_PROTOCOl</code> protocol and denotes a directory, then this folder
	 * is recursively scanned for files with the <code>CLASS_EXTENSION</code>
	 * extension.
	 * 
	 * Otherwise, the URL is assumed to point to a jar file, of which the classes
	 * are scanned.
	 * 
	 * Each class file is scanned for classes and/or methods annotated with the
	 * <code>Plugin</code> annotation. If a class is annotated with this annotation,
	 * then its methods are scanned for the <code>PluginVariant</code> annotation.
	 * 
	 * For each plugin found, a <code>PluginDescriptor</code> object is
	 * instantiated. These plugin descriptors can later be used to invoke plugins.
	 * 
	 * @param url
	 *            The URL to register
	 * @param pack
	 *            The package that corresponds to the URL
	 */
	void register(URL url, PackageDescriptor pack);

	/**
	 * registers a URL to this plugin manager. If the URL uses the
	 * <code>FILE_PROTOCOl</code> protocol and denotes a directory, then this folder
	 * is recursively scanned for files with the <code>CLASS_EXTENSION</code>
	 * extension.
	 * 
	 * Otherwise, the URL is assumed to point to a jar file, of which the classes
	 * are scanned.
	 * 
	 * Each class file is scanned for classes and/or methods annotated with the
	 * <code>Plugin</code> annotation. If a class is annotated with this annotation,
	 * then its methods are scanned for the <code>PluginVariant</code> annotation.
	 * 
	 * For each plugin found, a <code>PluginDescriptor</code> object is
	 * instantiated. These plugin descriptors can later be used to invoke plugins.
	 * 
	 * @param url
	 *            The URL to register
	 * @param pack
	 *            The package that corresponds to the URL
	 * @param loader
	 *            The class loader used to load the jar files.
	 */
	void register(URL url, PackageDescriptor pack, ClassLoader loader);

	/**
	 * This method retuns a collection of <code>Pair</code>s of <code>Integer</code>
	 * and <code>PluginParameterBinding</code> objects, such that:
	 * <p>
	 * The method belonging to the plugin in the pluginParameterBinding carries the
	 * given annotation. If no specific annotation is required, the method should be
	 * called with <code>Plugin.class</code>. Note that the annotation required has
	 * to be on the same level as the <code>Plugin</code> annotation, i.e. either on
	 * a method or a class
	 * <p>
	 * When invoked, the PluginParameterBinding returns an array of objects, of
	 * which the object at the index given by the integer in the pair is of the
	 * required result type, i.e.
	 * <code>resultType.isAssignableFrom(p.getPlugin().getReturnTypes()[i])</code>
	 * If no specific return type is required, use <code>Object.class</code> for
	 * this parameter.
	 * <p>
	 * The PluginParameterBinding can be executed in a <code>PluginContext</code> of
	 * the given type.
	 * <p>
	 * If <code>totalMatch</code> is true, then the PluginParameterBinding binds all
	 * parameters of the plugin with all arguments. Otherwise, the
	 * PluginParameterBinding only requires a subset of the given arguments and is
	 * therefore not directly executable on the given set of arguments.
	 * <p>
	 * If <code>orderedParameters</code> is true, then the PluginParameterBinding
	 * binds the given arguments in the given order, i.e. no arguments are
	 * reordered.
	 * <p>
	 * If <code>mustBeUserVisible</code> is true, then the plugin must have the
	 * <code>isUserVisible</code> flag set to true.
	 * <p>
	 * The PluginParameterBinding can be executed on arguments of the given types.
	 * The list of arguments can be empty, in which case no arguments are required
	 * to invoke the PluginParameterBinding. Note that only types of arguments are
	 * required, not the values. For checking whether arguments can be assigned to
	 * parameters of the Plugin, the <code>isParameterAssignable</code> method is
	 * used. Any <code>ProMFuture</code>s should be unwrapped.
	 * 
	 * @param annotation
	 *            The annotation that should be present on the plugin (use
	 *            <code>Plugin.class</code> if none is required).
	 * @param resultType
	 *            The required result type (use <code>Object.class</code> if no
	 *            specific type is required).
	 * @param contextType
	 *            The context type in which this plugin should be executable. Note
	 *            that this type should be the contextType of the context from which
	 *            the find is called, or a supertype thereof.
	 * @param totalMatch
	 *            Whether or not all arguments should be used to execute this
	 *            plugin.
	 * @param orderedParameters
	 *            Whether or not the arguments are given in the right order.
	 * @param mustBeUserVisible
	 *            Whether or not all returned plugins should be user visible.
	 * @param args
	 *            The types of the arguments provided to the plugin. Can be empty.
	 * @return A collection of pluginparameterbindings. They are executable if
	 *         totalMatch is true.
	 */
	Set<Pair<Integer, PluginParameterBinding>> find(Class<? extends Annotation> annotation, Class<?> resultType,
			Class<? extends PluginContext> contextType, boolean totalMatch, boolean orderedParameters,
			boolean mustBeUserVisible, Class<?>... args);

	/**
	 * This method retuns a collection of <code>Pair</code>s of <code>Integer</code>
	 * and <code>PluginParameterBinding</code> objects, such that:
	 * <p>
	 * The method belonging to the plugin in the pluginParameterBinding carries the
	 * given annotation. If no specific annotation is required, the method should be
	 * called with <code>Plugin.class</code>. Note that the annotation required has
	 * to be on the same level as the <code>Plugin</code> annotation, i.e. either on
	 * a method or a class
	 * <p>
	 * When invoked, the PluginParameterBinding returns an array of objects, of
	 * which the object at the index given by the integer in the pair is of the
	 * required result type as specified in the input list, i.e. for all
	 * <code>i</code>
	 * <code>resultTypes[i].isAssignableFrom(p.getPlugin().getReturnTypes()[i])</code>
	 * If no specific return type is required, use the other <code>find</code>
	 * method.
	 * <p>
	 * The PluginParameterBinding can be executed in a <code>PluginContext</code> of
	 * the given type.
	 * <p>
	 * If <code>totalMatch</code> is true, then the PluginParameterBinding binds all
	 * parameters of the plugin with all arguments. Otherwise, the
	 * PluginParameterBinding only requires a subset of the given arguments and is
	 * therefore not directly executable on the given set of arguments.
	 * <p>
	 * If <code>orderedParameters</code> is true, then the PluginParameterBinding
	 * binds the given arguments in the given order, i.e. no arguments are
	 * reordered.
	 * <p>
	 * If <code>mustBeUserVisible</code> is true, then the plugin must have the
	 * <code>isUserVisible</code> flag set to true.
	 * <p>
	 * The PluginParameterBinding can be executed on arguments of the given types.
	 * The list of arguments can be empty, in which case no arguments are required
	 * to invoke the PluginParameterBinding. Note that only types of arguments are
	 * required, not the values. For checking whether arguments can be assigned to
	 * parameters of the Plugin, the <code>isParameterAssignable</code> method is
	 * used. Any <code>ProMFuture</code>s should be unwrapped.
	 * 
	 * @param annotation
	 *            The annotation that should be present on the plugin (use
	 *            <code>Plugin.class</code> if none is required).
	 * @param resultTypes
	 *            The exact, sorted list of required result types. If not specific
	 *            type is requested, this find method should not be used.
	 * @param contextType
	 *            The context type in which this plugin should be executable. Note
	 *            that this type should be the contextType of the context from which
	 *            the find is called, or a supertype thereof.
	 * @param totalMatch
	 *            Whether or not all arguments should be used to execute this
	 *            plugin.
	 * @param orderedParameters
	 *            Whether or not the arguments are given in the right order.
	 * @param mustBeUserVisible
	 *            Whether or not all returned plugins should be user visible.
	 * @param args
	 *            The types of the arguments provided to the plugin. Can be empty.
	 * @return A collection of pluginparameterbindings. They are executable if
	 *         totalMatch is true.
	 */
	public Set<Pair<Integer, PluginParameterBinding>> find(Class<? extends Annotation> annotation,
			Class<?>[] resultTypes, Class<? extends PluginContext> contextType, boolean totalMatch,
			boolean orderedParameters, boolean mustBeUserVisible, Class<?>... parameters);

	/**
	 * Find the plugins resulting in the given type. The result are pairs of
	 * integers and plugins, such that for each pair (i,p) holds that
	 * resultType.isAssignableFrom(p.getReturnTypes()[i])
	 * 
	 * @param resultType
	 *            Can be null. if null, then any type is considered.
	 * @param mustBeUserVisible
	 *            Whether or not all returned plugins should be user visible.
	 * @return A collection of pairs of integers and plugins, such that for each
	 *         pair (i,p) holds that
	 *         resultType.isAssignableFrom(p.getReturnTypes()[i])
	 */
	Set<Pair<Integer, PluginDescriptor>> getPluginsResultingIn(Class<? extends Object> resultType,
			Class<? extends PluginContext> contextType, boolean mustBeUserVisible);

	/**
	 * Returns executable PluginParameterBindings, which can be invoked in the given
	 * context on the given parameter types. Note that the PluginParameterBindings
	 * are executable.
	 * 
	 * @param contextType
	 *            The type of the context in which the binding is to be invoked.
	 * @param mustBeUserVisible
	 *            Whether or not the plugin should be user visible.
	 * @param parameters
	 *            The types of the arguments passed to the plugins. They are
	 *            accepted by the plugin in the order in which they are provided.
	 * 
	 * @return a list of executable bindings
	 */
	Set<PluginParameterBinding> getPluginsAcceptingOrdered(Class<? extends PluginContext> contextType,
			boolean mustBeUserVisible, Class<?>... parameters);

	/**
	 * Returns PluginParameterBindings, which can be invoked in the given context on
	 * the given parameter types. Note that the PluginParameterBindings are not
	 * necessarily executable. However, they accept all given arguments as
	 * parameters.
	 * 
	 * @param contextType
	 *            The type of the context in which the binding is to be invoked.
	 * @param mustBeUserVisible
	 *            Whether or not the plugin should be user visible.
	 * @param parameters
	 *            The types of the arguments passed to the plugins. They are
	 *            accepted by the returned plugins, but not necessarily in this
	 *            order.
	 * @return a list of bindings
	 */
	Set<PluginParameterBinding> getPluginsAcceptingAtLeast(Class<? extends PluginContext> contextType,
			boolean mustBeUserVisible, Class<?>... parameters);

	/**
	 * Returns executable PluginParameterBindings, which can be invoked in the given
	 * context on the given parameter types. Note that the PluginParameterBindings
	 * are executable.
	 * 
	 * @param contextType
	 *            The type of the context in which the binding is to be invoked.
	 * @param mustBeUserVisible
	 *            Whether or not the plugin should be user visible.
	 * @param parameters
	 *            The types of the arguments passed to the plugins. They are
	 *            accepted by the returned plugins, but not necessarily in this
	 *            order.
	 * @return a list of executable bindings
	 */
	Set<PluginParameterBinding> getPluginsAcceptingInAnyOrder(Class<? extends PluginContext> contextType,
			boolean mustBeUserVisible, Class<?>... parameters);

	/**
	 * Returns a PluginDescriptor with the given id. Note that plugin IDs are
	 * persistent between runs.
	 * 
	 * @param id
	 *            the id of the plugin to get
	 * @return the plugin with the given id.
	 */
	PluginDescriptor getPlugin(PluginDescriptorID id);

	/**
	 * Returns a PluginDescriptor of which the toString() of its id equals the given
	 * id. Note that plugin IDs are persistent between runs.
	 * 
	 * @param id
	 *            the String representation of the id of the plugin to get
	 * @return the plugin with an id of which the String representation equals the
	 *         given id.
	 */
	PluginDescriptor getPlugin(String id);

	/**
	 * Returns all plugin descriptors
	 * 
	 * @return all plugin descriptors known to the plugin manager.
	 */
	SortedSet<PluginDescriptor> getAllPlugins();

	/**
	 * Returns all plugin descriptors known to the plugin manager. If set, only
	 * those plugins which are user visible are returned.
	 * 
	 * @param mustBeVisible
	 *            wether or not the returned plugins should be user visible.
	 * @return the plugin descriptors.
	 */
	SortedSet<PluginDescriptor> getAllPlugins(boolean mustBeVisible);

	/**
	 * Returns true if the instance type can be cast to the requested type, or if
	 * the requested type is an array and the instance type can be cast to the
	 * component type of the requested type.
	 * 
	 * @param instanceType
	 *            the type that has to be cast to the requested type.
	 * @param requestedType
	 *            the requested type
	 * @return true if a cast can be made, i.e. if an object of type instanceType
	 *         can be assigned to a parameter of type requestedType of a plugin.
	 */
	boolean isParameterAssignable(Class<?> instanceType, Class<?> requestedType);

	/**
	 * Returns the set of types that is known to the plugin manager. Basically, this
	 * set contains all types that are ever used as a parameter or a return type of
	 * a plugin.
	 * 
	 * @return a set of types.
	 */
	Set<Class<?>> getKnownObjectTypes();

	/**
	 * Returns all known classes annotated with a certain annotationType. Not all of
	 * these classes are plugins! Note that only classes are available that carry
	 * the @KeepInProMCache annotation
	 * 
	 * @param annotationType
	 *            the type of annotation to be found
	 * @return a (possibly empty) set of classes (not null)
	 */
	Set<Class<?>> getKnownClassesAnnotatedWith(Class<? extends Annotation> annotationType);

}"
PluginParameterBinding.java,context,"package org.processmining.framework.plugin;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import org.processmining.framework.util.ArrayUtils;

/**
 * This class represents a binding between a method of a plugin and a set of
 * parameters. The semantics of this object are as follows.
 * 
 * First, the {@code PluginParameterBinding.Factory.tryToBind()} should be used
 * to construct a list of PluginParameterBindings. This method is called with a
 * variable array of parameter types, such that for each returned binding, the
 * <code>invoke()</code> method can be called with a variable array of
 * instantiations of these types, in that order.
 * 
 * Any reordering that needs to be done (if <code>tryToBind()</code> was called
 * with <code>orderedParameters == false</code>) is handled by the binding.
 * 
 * A PluginParameterBinding is only guaranteed to be executable, if the factory
 * method was called with <code>mustBeTotal</code> set to true.
 * 
 * @author bfvdonge
 * 
 */
public class PluginParameterBinding implements Comparable<PluginParameterBinding> {

	/**
	 * Factory for instantiating PluginParameterBindings binding plugins with a
	 * given input.
	 * 
	 * @author bfvdonge
	 * 
	 */
	public static class Factory {

		private Factory() {
		}

		/**
		 * This method instantiates binding objects binding the method and index
		 * <code>methodIndex</code> of the given plugin to the given set of
		 * parameter types, if possible. If no binding is possible, an empty
		 * list is returned.
		 * 
		 * If a total binding is requested (indicated by
		 * <code>mustBeTotal == true</code>), then the returned binding assigns
		 * objects from the given parameters to all inputParameters of the
		 * plugin method.
		 * 
		 * If no total binding is required, the resulting bindings is not
		 * necessarily executable, as the method bound might require more input.
		 * However, all provided parameterTypes are bound to a parameter.
		 * 
		 * Using the flag <code>orderedParameters</code> the user can request
		 * bindings that consider the given parameters, in the given order only,
		 * i.e. no reordering is done. Any binding <code>b</code> returned with
		 * <code>orderedParameters == true</code> will satisfy the property that
		 * <code>b.getBinding()[i] == i</code> for all <code>i</code>.
		 * 
		 * @param plugin
		 *            the plugin for which to try to bind the parameters
		 * @param mustBeTotal
		 *            indicating whether the resulting binding should be total
		 * @param orderedParameters
		 *            whether or not the parameters are ordered.
		 * @param parameterTypes
		 *            the available types to be distributed over the parameters.
		 *            Note that if one of the objects is a Object[] then, this
		 *            array will be kept as one. Multiple objects of type T,
		 *            might end up in an array of type S super T, i.e. they can
		 *            be bound into one S[] to be passed to a single element of
		 *            plugin.getTypes()
		 * @return A list of length 0 if no binding exists, or a list of length
		 *         1 if a binding exists. Note that this may change in the
		 *         future to lists of length n.
		 */
		public static List<PluginParameterBinding> tryToBind(PluginManager manager, PluginDescriptor plugin,
				int methodIndex, boolean mustBeTotal, boolean orderedParameters, Class<?>... parameterTypes) {

			List<PluginParameterBinding> result = new ArrayList<PluginParameterBinding>();

			if (mustBeTotal && (parameterTypes.length < plugin.getParameterTypes(methodIndex).size())) {
				// Quick check. the result is empty if it should be total, but their
				// are less provided parameters than required.
				return result;
			}
			if (!mustBeTotal && (parameterTypes.length > 0) && (plugin.getParameterTypes(methodIndex).size() <= 1)) {
				// Quick check. A partial mapping to one type is not possible, when
				// having
				// to assign all parameters
				return result;
			}
			if (orderedParameters && (parameterTypes.length != plugin.getParameterTypes(methodIndex).size())) {
				// can't do this, parameters.size should match required params

				return result;
			}

			// We are dealing with multiple parameters, and we are sure that
			// there are more parameters than types if the mapping needs to be
			// total.
			if ((parameterTypes.length == plugin.getParameterTypes(methodIndex).size())
					&& ((parameterTypes.length == 1) || orderedParameters)) {
				// if ordered, or only 1 to match
				int[] list = new int[parameterTypes.length];
				for (int i = 0; i < parameterTypes.length; i++) {
					// This single parameter matches the required type
					Class<?> parType = plugin.getParameterTypes(methodIndex).get(i);
					//				if (parType.isAssignableFrom(parameters.get(i))
					//						|| (parType.isArray() && parType.getComponentType().isAssignableFrom(parameters.get(i)))) {
					if (manager.isParameterAssignable(parameterTypes[i], parType)) {
						list[i] = i;
					} else {
						return result;
					}

				}
				PluginParameterBinding binding = new PluginParameterBinding(plugin, methodIndex, true, list);
				result.add(binding);

				return result;
			}

			boolean[] fullyUsed = new boolean[plugin.getParameterNames(methodIndex).size()];
			boolean[] used = new boolean[plugin.getParameterNames(methodIndex).size()];
			Arrays.fill(fullyUsed, false);
			Arrays.fill(used, false);

			int[] list = new int[parameterTypes.length];
			for (int i = 0; i < parameterTypes.length; i++) {
				Class<?> par = parameterTypes[i];
				boolean done = false;
				int matchingIndex = -1;
				Class<?> parType = null;
				// First try to match to an unused input parameter
				for (int j = 0; (j < plugin.getParameterNames(methodIndex).size()) && !done; j++) {
					if (used[j]) {
						continue;
					}
					parType = plugin.getParameterTypes(methodIndex).get(j);
					boolean match = manager.isParameterAssignable(par, parType);
					if (match) {
						matchingIndex = j;
						done = true;
					}
				}
				// Then, to a used, but not fully used parameter
				for (int j = 0; (j < plugin.getParameterNames(methodIndex).size()) && !done; j++) {
					if (fullyUsed[j]) {
						continue;
					}
					parType = plugin.getParameterTypes(methodIndex).get(j);
					boolean match = manager.isParameterAssignable(par, parType);
					if (match) {
						matchingIndex = j;
						done = true;
					}
				}

				if (done) {
					assert ((matchingIndex >= 0) && (parType != null));
					list[i] = matchingIndex;
					used[matchingIndex] = true;
					fullyUsed[matchingIndex] = !parType.isArray();
				} else {
					// Could not assign this parameter
					return result;
				}
				// }
			}
			boolean complete = true;
			for (int i = 0; (i < used.length) && complete; i++) {
				complete &= used[i];
			}

			if (mustBeTotal == complete) {
				PluginParameterBinding binding = new PluginParameterBinding(plugin, methodIndex, complete, list);
				result.add(binding);
			}

			return result;
		}

	}

	private final PluginDescriptor plugin;
	private final int methodIndex;
	private final boolean isComplete;

	// Binding represents the index of the parameter to which
	// an object should be bound
	private final int[] binding;

	/**
	 * Constructs a binding on the given plugin, method and binding.
	 * 
	 * @param plugin
	 * @param methodIndex
	 * @param isComplete
	 * @param binding
	 */
	private PluginParameterBinding(PluginDescriptor plugin, int methodIndex, boolean isComplete, int[] binding) {
		this.plugin = plugin;
		this.methodIndex = methodIndex;
		this.isComplete = isComplete;
		this.binding = binding;

	}

	/**
	 * Invokes the method of the plugin referenced by this binding on the given
	 * parameterObjects. It should be noted that the number of given parameter
	 * object should be the same as the number of parameter types provided to
	 * the <code>tryToBind()</code> method of the factory. Furthermore, the
	 * types of these parameters should be right, i.e. each object should be of
	 * the right type, or should be a <code>ProMFuture</code> on that type.
	 * 
	 * In this method, the given parameters are first re-ordered according to
	 * the given binding and then
	 * <code>getPlugin().invoke(getMethodIndex(), context, ...)</code> is
	 * called, on the newly ordered parameters.
	 * 
	 * No checks are done if this plugin is executable or not on the given
	 * input, it's up to the plugin to handle this
	 * 
	 * @param context
	 *            Note that the plugin should be executable in this context.
	 *            However, since PluginContext's should be kept uniformly typed
	 *            within one instance of ProM, no checks are done here.
	 * @param parameterObjects
	 * @return
	 */
	public PluginExecutionResult invoke(PluginContext context, Object... parameterObjects) {
		Object[] args = prepareArguments(parameterObjects);
		return plugin.invoke(methodIndex, context, args);
	}

	/**
	 * Sorts the parameters according the ordering specified in the binding
	 * array. Produces arrays if multiple objects are bound to the same
	 * parameter.
	 * 
	 * @param parameterObjects
	 * @return
	 */
	private Object[] prepareArguments(Object... parameterObjects) {
		Object[] args = new Object[plugin.getParameterNames(methodIndex).size()];
		Arrays.fill(args, null);
		for (int i = 0; i < parameterObjects.length; i++) {
			int index = binding[i];
			if (index < 0) {
				continue;
			}
			if (!plugin.getParameterTypes(methodIndex).get(index).isArray()) {
				// Single parameter
				args[index] = parameterObjects[i];
				continue;
			}
			// Array Parameter (there might be more added to this array).
			Object[] arg;
			if (args[index] == null) {
				arg = new Object[0];
			} else {
				arg = (Object[]) args[index];
			}
			Object[] newArg = ArrayUtils.copyOf(arg, arg.length + 1);
			newArg[arg.length] = parameterObjects[i];
			args[index] = newArg;
		}
		return args;
	}

	/**
	 * Returns the Plugin which is bound by this binding.
	 * 
	 * @return
	 */
	public PluginDescriptor getPlugin() {
		return plugin;
	}

	/**
	 * This method returns an array of integers, of which the length corresponds
	 * to the length of the list of parameters types provided to the
	 * PluginParameterBinding factory. For each parameter type, this array
	 * indicates to which parameter of the plugin it is bound.
	 * 
	 * For each element <code>x</code> of this array is holds that
	 * <code>0 <= x < getPlugin().getParameterNames(getMethodIndex())</code>
	 * 
	 * If the same parameter index is provided for different parameters (i.e.
	 * <code>getBinding()[x] == getBinding()[y]</code> with <code>x != y</code>,
	 * then this impliest that the parameter is an array type, to which multiple
	 * objects can be connected. In other words, this implies that
	 * 
	 * <code>getPlugin().getParameterType(getMethodIndex(),getBinding()[x]).isArray() == true</code>
	 * 
	 * @return
	 */
	public int[] getBinding() {
		return binding;
	}

	/**
	 * Equality of bindings is based on the binding, plugin and complete status.
	 */
	public boolean equals(Object o) {
		if (!(o instanceof PluginParameterBinding)) {
			return false;
		}
		PluginParameterBinding b = (PluginParameterBinding) o;
		return (isComplete == b.isComplete) && plugin.equals(b.plugin) && (methodIndex == b.methodIndex)
				&& Arrays.equals(b.binding, binding);
	}

	/**
	 * Returns a hashcode based on the binding, plugin and complete status
	 */
	public int hashCode() {
		int hash = 7;
		hash = 31 * hash + Arrays.hashCode(binding);
		hash = 31 * hash + plugin.hashCode();
		hash = 31 * hash + methodIndex;
		return 31 * hash + (isComplete ? 13 : 17);

	}

	/**
	 * Returns the method index of the method which is bound by this binding.
	 * 
	 * When this binding is invoked, this method inside the plugin provided by
	 * getPlugin() is invoked.
	 * 
	 * @return
	 */
	public int getMethodIndex() {
		return methodIndex;
	}

	public int compareTo(PluginParameterBinding other) {
		if (other == this) {
			return 0;
		}
		int c = plugin.compareTo(other.plugin);
		if (c == 0) {
			c = methodIndex - other.methodIndex;
		}
		if (c == 0) {
			return Arrays.toString(binding).compareTo(Arrays.toString(other.binding));
		}
		return c;
	}

}"
Progress.java,context,"package org.processmining.framework.plugin;

/**
 * Interface for progress indicator
 * 
 * @author bfvdonge
 * 
 */
public interface Progress {

	void setMinimum(int value);

	void setMaximum(int value);

	void setValue(int value);

	void setCaption(String message);

	String getCaption();

	int getValue();

	void inc();

	void setIndeterminate(boolean makeIndeterminate);

	boolean isIndeterminate();

	int getMinimum();

	int getMaximum();

	boolean isCancelled();

	void cancel();
}
"
ProMCanceller.java,context,"package org.processmining.framework.plugin;

/**
 * Interface that can be used by visualizations to receive a notification from
 * the framework when they are removed. {@link #isCancelled()} will return true
 * in this case.
 * 
 * @author F. Mannhardt, S.J.J Leemans
 *
 */
public interface ProMCanceller {

	/**
	 * {@link ProMCanceller} that never returns true for {@link #isCancelled()}
	 */
	public final static ProMCanceller NEVER_CANCEL = new ProMCanceller() {

		public boolean isCancelled() {
			return false;
		}
	};

	boolean isCancelled();

}
"
ProMFuture.java,context,"package org.processmining.framework.plugin;

import java.util.concurrent.CancellationException;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;

import javax.swing.SwingWorker;

import org.processmining.framework.plugin.events.FutureListener;
import org.processmining.framework.plugin.events.NameChangeListener;

/**
 * Class to represent a future on an object.
 * 
 * @author bfvdonge
 * 
 * @param <T>
 */
public abstract class ProMFuture<T> implements Future<T> {

	private final Class<?> classType;
	private final SwingWorker<T, Void> worker;
	private String label;
	private final NameChangeListener.ListenerList nameChangeListeners = new NameChangeListener.ListenerList();
	private final FutureListener.ListenerList futureListeners = new FutureListener.ListenerList();

	/**
	 * Instantiates a ProMFuture object of the given type and with the given
	 * label.
	 * 
	 * A SwingWorker is instantiated by the constructor. This SwingWorker is
	 * provided through the <code>getRunnable()</code> method and once executed,
	 * it will execute the <code>doInBackground()</code> method of this
	 * ProMFuture.
	 * 
	 * When finished, the <code>done()</code> method is invoked, after which any
	 * Future listeners are notified that this future is ready.
	 * 
	 * @param resultClass
	 *            Any type that extends T. However, no subtype of ProMFuture can
	 *            be provided.
	 * @param label
	 */
	public ProMFuture(Class<? extends T> resultClass, String label) {
		if (ProMFuture.class.isAssignableFrom(resultClass)) {
			// Cannot put a future inside a future.
			throw new RuntimeException(""Cannot put a future in a future"");
		}
		this.classType = resultClass;
		this.label = label;
		this.worker = new SwingWorker<T, Void>() {
			@Override
			protected T doInBackground() throws Exception {
				return ProMFuture.this.doInBackground();
			}

			@Override
			protected void done() {
				// invoke the setLabel() on getLabel() after finishing execution.
				// this is necessary to fire name-changed events to any 
				// listeners registered after the last call to setLabel();
				ProMFuture.this.setLabel(ProMFuture.this.getLabel());

				ProMFuture.this.done();
				ProMFuture.this.getFutureListeners().fireFutureReady(ProMFuture.this);
			}
		};
	}

	/**
	 * This method is called by the runnable of this future as soon as the
	 * computation of the result is ready, but before any listeners are notified
	 * of the completion.
	 * 
	 * Any overriding implementation can use the get() method to return the
	 * object computed, as this method is guaranteed not to throw exceptions
	 * when done() is reached.
	 */
	protected void done() {
		// Default empty implementation
	}

	/**
	 * Returns the Runnable representing the execution that needs to be
	 * performed to produce the result of this future.
	 * 
	 * @return
	 */
	public Runnable getRunnable() {
		return worker;
	}

	/**
	 * The return type of this future.
	 * 
	 * @return
	 */
	public Class<?> getReturnType() {
		return classType;
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see java.util.concurrent.Future#get()
	 */
	public boolean cancel(boolean mayInterruptIfRunning) {
		return worker.cancel(mayInterruptIfRunning);
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see java.util.concurrent.Future#get()
	 */
	public T get() throws InterruptedException, ExecutionException, CancellationException {
		return worker.get();
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see java.util.concurrent.Future#get(long, java.util.concurrent.TimeUnit)
	 */
	public T get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException,
			CancellationException {
		return worker.get(timeout, unit);
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see java.util.concurrent.Future#isCancelled()
	 */
	public boolean isCancelled() {
		return worker.isCancelled();
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see java.util.concurrent.Future#isDone()
	 */
	public boolean isDone() {
		return worker.isDone();
	}

	/**
	 * This method should be implemented by all subclasses of ProMFuture. Here,
	 * the object of type T is computed and returned.
	 * 
	 * @return
	 * @throws Exception
	 *             This exception should be any exception thrown by the logic of
	 *             the underlying method. Note that ""wrapper""-Exceptions such as
	 *             InvocationTargetException and ExecutionException should be
	 *             unwrapped.
	 */
	protected abstract T doInBackground() throws Exception;

	/**
	 * Return a string representation of this future.
	 */
	public String toString() {
		if (isCancelled()) {
			return (""Cancelled calculation of "" + getLabel());
		}
		return (isDone() ? ""Processing: "" : """") + getLabel();
	}

	/**
	 * returns the label of this future
	 * 
	 * @return
	 */
	public String getLabel() {
		return label;
	}

	/**
	 * Sets the label of this future to the given label and fires name change
	 * events in any registered name change listeners.
	 * 
	 * @param label
	 */
	public void setLabel(String label) {
		this.label = label;
		nameChangeListeners.fireNameChanged(label);
	}

	/**
	 * Returns a ListenerList containing the registered name change listeners
	 * 
	 * @return
	 */
	public NameChangeListener.ListenerList getNameChangeListeners() {
		return nameChangeListeners;
	}

	/**
	 * Returns a ListenerList containing the registered future listeners
	 * 
	 * @return
	 */
	public FutureListener.ListenerList getFutureListeners() {
		return futureListeners;
	}

}
"
RecursiveCallException.java,context,"package org.processmining.framework.plugin;

public class RecursiveCallException extends Exception {

	private static final long serialVersionUID = -1731740485590676086L;

	public RecursiveCallException(PluginContext context, PluginDescriptor plugin, int methodIndex) {
		super(""A recursive call to method "" + methodIndex + "" of plugin "" + plugin.getName()
				+ "" was discrovered when creating context "" + context.getID() + ""."");
	}
}
"
ProMID.java,context,"package org.processmining.framework;

import java.util.UUID;

public interface ProMID extends Comparable<ProMID> {

	/**
	 * ProMID are used in Collections, so this method has to be implemented in
	 * all its subclasses.
	 * 
	 * @return
	 */
	public boolean equals(Object o);

	/**
	 * ProMID are used in HashMaps, so this method has to be implemented in all
	 * its subclasses.
	 * 
	 * @return
	 */
	public int hashCode();

	/**
	 * Determines equality between this ProMID and any given object. Basically
	 * checks for equality using the toString() methods of both objects.
	 * 
	 * @param o
	 *            the object to compare the string representation with
	 * @return true if the toString() of this provided object ID equals the
	 *         toString() of the given object parameter.
	 */
	public boolean equalsIgnoreType(Object o);

	/**
	 * Returns a UUID that is used for this object.
	 * 
	 * @return
	 */
	public UUID getUUID();

}
"
ContextAwareObject.java,context,"package org.processmining.framework.providedobjects;

import org.processmining.framework.connections.ConnectionManager;
import org.processmining.framework.plugin.PluginManager;

/**
 * If an object implements this interface, then this object should use transient
 * fields to store pointers to the three managers.
 * 
 * Upon deserialization of the object by the ProM framework, the three methods
 * in this interface are called before the object is used and added to the
 * framework as a provided object.
 * 
 * Using this interface, objects can instantiate themselves as listeners on the
 * relevant parts of the framework that would otherwise only be available upon
 * instantiation from a PluginContext.
 * 
 * @author bfvdonge
 * 
 */
public interface ContextAwareObject {

	public void setManagers(ConnectionManager connectionManager, PluginManager pluginManager,
			ProvidedObjectManager providedObjectManager);
}
"
ProvidedObjectIDImpl.java,context,"package org.processmining.framework.providedobjects.impl;

import java.util.UUID;

import org.processmining.framework.ProMID;
import org.processmining.framework.providedobjects.ProvidedObjectID;

public class ProvidedObjectIDImpl implements ProvidedObjectID {

	private final UUID id = UUID.randomUUID();

	public String toString() {
		return id.toString();
	}

	public int hashCode() {
		return id.hashCode();
	}

	public boolean equals(Object o) {
		if (!(o instanceof ProvidedObjectIDImpl)) {
			return false;
		} else {
			return ((ProvidedObjectIDImpl) o).id.equals(id);
		}
	}

	public boolean equalsIgnoreType(Object o) {
		return toString().equals(o.toString());
	}

	public int compareTo(ProMID o) {
		return o.getUUID().compareTo(id);
	}

	public UUID getUUID() {
		return id;
	}
}
"
ProvidedObjectImpl.java,context,"package org.processmining.framework.providedobjects.impl;

import java.util.concurrent.CancellationException;
import java.util.concurrent.ExecutionException;

import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.ProMFuture;
import org.processmining.framework.plugin.events.FutureListener;
import org.processmining.framework.plugin.events.NameChangeListener;
import org.processmining.framework.providedobjects.ProvidedObject;
import org.processmining.framework.providedobjects.ProvidedObjectDeletedException;
import org.processmining.framework.providedobjects.ProvidedObjectID;
import org.processmining.framework.providedobjects.ProvidedObjectManager;

public class ProvidedObjectImpl implements ProvidedObject, NameChangeListener, FutureListener {

	private final ProvidedObjectID id;
	private Object object;
	private boolean deleted = false;
	private final ProvidedObjectManager manager;
	private String label;
	private final Class<?> type;

	public <T> ProvidedObjectImpl(String label, ProvidedObjectID id, T object, Class<? super T> type,
			ProvidedObjectManager manager) throws NullPointerException {
		this.manager = manager;
		this.id = id;
		this.type = type;
		if (object == null) {
			throw new NullPointerException(""Null cannot be provided as an object"");
		}
		try {
			setObject(object, false);
		} catch (ProvidedObjectDeletedException e) {
			assert (false);
		}
		this.label = label;
	}

	public void deleteObject() {
		deleted = true;
		// unregister as a name-change listener on the old object
		unregisterFromFuture();
		object = null;
		// Notify all listeners to the deleted object
		manager.getProvidedObjectLifeCylceListeners().fireProvidedObjectDeleted(getID());
	}

	private void unregisterFromFuture() {
		if (object instanceof ProMFuture<?>) {
			((ProMFuture<?>) object).getNameChangeListeners().remove(this);
			((ProMFuture<?>) object).getFutureListeners().remove(this);
		}
	}

	public ProvidedObjectID getID() {
		return id;
	}

	public Object getObject() throws ProvidedObjectDeletedException {
		return getObject(true);
	}

	public Object getObject(boolean waitIfFuture) throws ProvidedObjectDeletedException {
		if (deleted) {
			throw new ProvidedObjectDeletedException(""Object "" + getLabel() + "" has been deleted."");
		}
		if (waitIfFuture && (object instanceof ProMFuture<?>)) {
			try {
				return ((ProMFuture<?>) object).get();
			} catch (Exception e) {
				// This is a listener on object and will receive a message
				// from ProMFuture resulting in a delete.
				setObject(null);
			}
		}
		return object;
	}

	public void setObject(Object newObject) throws ProvidedObjectDeletedException {
		setObject(newObject, true);
	}

	private void setObject(Object newObject, boolean signalChange) throws ProvidedObjectDeletedException {
		if (deleted) {
			throw new ProvidedObjectDeletedException(""Object "" + getLabel() + "" has been deleted."");
		}
		// unregister as a name-change listener on the old object
		unregisterFromFuture();
		if (newObject == null) {
			deleteObject();
			return;
		}
		object = newObject;
		synchronized (object) {
			if (object instanceof ProMFuture<?>) {
				// register as a name-change listener on the new object
				((ProMFuture<?>) object).getNameChangeListeners().add(this);
				// To make sure that no name changed are missed:
				label = (((ProMFuture<?>) object).getLabel());
				((ProMFuture<?>) object).getFutureListeners().add(this);
			}
		}
		if (signalChange) {
			// Notify the listeners of the manager
			manager.getProvidedObjectLifeCylceListeners().fireProvidedObjectObjectChanged(id);
		}
	}

	public String toString() {

		return getLabel() + "": "" + (deleted ? "" DELETED"" : object.toString());
	}

	public String getLabel() {
		return label;
	}

	public int hashCode() {
		return id.hashCode();
	}

	public boolean equals(Object o) {
		if (o instanceof ProvidedObject) {
			return id.equals(((ProvidedObject) o).getID());
		} else {
			return false;
		}
	}

	public synchronized void nameChanged(String newName) {
		label = newName;
		manager.getProvidedObjectLifeCylceListeners().fireProvidedObjectNameChanged(getID());
	}

	public void setLabel(String label) throws ProvidedObjectDeletedException {
		if (isDeleted()) {
			throw new ProvidedObjectDeletedException(""Provided Object with ID "" + getID() + "" was deleted before."");
		}
		nameChanged(label);
	}

	public synchronized void pluginCancelled(PluginContext context) {
		// if the plugin was cancelled, then delete this
		// providedObject
		try {
			setObject(null);
		} catch (ProvidedObjectDeletedException e) {
			// Don't care
		}
	}

	public boolean isDeleted() {
		return deleted;
	}

	public Class<? extends Object> getType() throws ProvidedObjectDeletedException {
		if (isDeleted()) {
			throw new ProvidedObjectDeletedException(""Provided Object with ID "" + getID() + "" was deleted before."");
		}
		return type;
	}

	public synchronized void futureReady(ProMFuture<? extends Object> future) {
		try {
			try {
				if (!deleted) {
					Object tmpObject = ((ProMFuture<?>) object).get();
					setObject(tmpObject, false);
					if (tmpObject != null) {
						// if tmpObject == null, then this is deleted by
						// the setObject method;
						manager.getProvidedObjectLifeCylceListeners().fireProvidedObjectFutureReady(getID());
					}
				}
			} catch (CancellationException e) {
				setObject(null);
			} catch (InterruptedException e) {
				setObject(null);
			} catch (ExecutionException e) {
				setObject(null);
			}
		} catch (ProvidedObjectDeletedException e) {
			// Ignore;

		}
	}
}
"
ProvidedObjectManagerImpl.java,context,"package org.processmining.framework.providedobjects.impl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;

import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.PluginExecutionResult;
import org.processmining.framework.plugin.ProMFuture;
import org.processmining.framework.plugin.events.ProvidedObjectLifeCycleListener;
import org.processmining.framework.providedobjects.ProvidedObject;
import org.processmining.framework.providedobjects.ProvidedObjectDeletedException;
import org.processmining.framework.providedobjects.ProvidedObjectID;
import org.processmining.framework.providedobjects.ProvidedObjectManager;
import org.processmining.framework.providedobjects.SubstitutionType;

public class ProvidedObjectManagerImpl implements ProvidedObjectManager {

	private final ProvidedObjectLifeCycleListener.ListenerList providedObjectLifeCycleListeners = new ProvidedObjectLifeCycleListener.ListenerList();
	private final HashMap<ProvidedObjectID, ProvidedObjectImpl> localProvidedObjects;
	private final List<ProvidedObjectID> ids;

	private boolean enabled = true;

	public ProvidedObjectManagerImpl() {
		localProvidedObjects = new HashMap<ProvidedObjectID, ProvidedObjectImpl>();
		ids = new ArrayList<ProvidedObjectID>();
	}

	public ProvidedObjectLifeCycleListener.ListenerList getProvidedObjectLifeCylceListeners() {
		return providedObjectLifeCycleListeners;
	}

	@SuppressWarnings(""unchecked"")
	public <T> ProvidedObjectID createProvidedObject(String label, T object, PluginContext context) {
		Class<?> realType;
		if (object instanceof ProMFuture<?>) {
			realType = ((ProMFuture<?>) object).getReturnType();
		} else {
			realType = object.getClass();
		}
		if (realType.isAnnotationPresent(SubstitutionType.class)) {
			Class<?> declaredType = realType.getAnnotation(SubstitutionType.class).substitutedType();
			if (declaredType.isAssignableFrom(realType)) {
				realType = declaredType;
			}
		}
		return createProvidedObject(label, object, (Class<? super T>) realType, context);
	}

	public <T> ProvidedObjectID createProvidedObject(String label, T object, Class<? super T> type,
			PluginContext context) {

		// construct a new ProvidedObject
		ProvidedObjectImpl po = new ProvidedObjectImpl(label, new ProvidedObjectIDImpl(), object, type, this);

		if (enabled) {
			// add it to the list of maintained PO's
			localProvidedObjects.put(po.getID(), po);
			ids.add(po.getID());
			providedObjectLifeCycleListeners.fireProvidedObjectCreated(po.getID(), context);
			if (!(object instanceof ProMFuture<?>)) {
				providedObjectLifeCycleListeners.fireProvidedObjectFutureReady(po.getID());
			} else {
				try {
					po.setLabel(((ProMFuture<?>) object).toString());
				} catch (ProvidedObjectDeletedException e) {
					assert (false);
				}
			}
		}
		return po.getID();

	}

	public List<ProvidedObjectID> createProvidedObjects(PluginContext context) {
		List<ProvidedObjectID> newIds = new ArrayList<ProvidedObjectID>();
		PluginExecutionResult result = context.getResult();
		for (int i = 0; i < result.getSize(); i++) {
			ProvidedObjectID id = createProvidedObject(result.getResultName(i), result.getResult(i), result.getType(i),
					context);
			newIds.add(id);
			//			ids.add(id);
			result.setProvidedObjectID(i, id);
		}
		return newIds;
	}

	private ProvidedObjectImpl getProvidedObject(ProvidedObjectID id) throws ProvidedObjectDeletedException {
		ProvidedObjectImpl po = localProvidedObjects.get(id);
		if (po == null) {
			throw new ProvidedObjectDeletedException(""ProvidedObject with ID "" + id + "" is not known to the manager."");
		}
		return po;
	}

	public Object getProvidedObjectObject(ProvidedObjectID id, boolean waitIfFuture)
			throws ProvidedObjectDeletedException {
		ProvidedObject po = getProvidedObject(id);
		return po.getObject(waitIfFuture);
	}

	public String getProvidedObjectLabel(ProvidedObjectID id) throws ProvidedObjectDeletedException {
		ProvidedObject po = getProvidedObject(id);
		return po.getLabel();
	}

	public Class<? extends Object> getProvidedObjectType(ProvidedObjectID id) throws ProvidedObjectDeletedException {
		ProvidedObject po = getProvidedObject(id);
		return po.getType();
	}

	public void changeProvidedObjectObject(ProvidedObjectID id, Object newObject) throws ProvidedObjectDeletedException {
		ProvidedObject po = getProvidedObject(id);
		po.setObject(newObject);
	}

	public void deleteProvidedObject(ProvidedObjectID id) throws ProvidedObjectDeletedException {
		ProvidedObjectImpl po = getProvidedObject(id);
		localProvidedObjects.remove(id);
		ids.remove(id);
		po.deleteObject();
	}

	public List<ProvidedObjectID> getProvidedObjects() {
		return Collections.unmodifiableList(ids);
	}

	public void relabelProvidedObject(ProvidedObjectID id, String label) throws ProvidedObjectDeletedException {
		getProvidedObject(id).setLabel(label);
	}

	public void providedObjectNameChanged(ProvidedObjectID objectID) {
		// Ignore
	}

	public void providedObjectObjectChanged(ProvidedObjectID objectID) {
		// Ignore
	}

	public void setEnabled(boolean enabled) {
		this.enabled = enabled;
	}

	public boolean isEnabled() {
		return enabled;
	}
	
	public void clear() {
		localProvidedObjects.clear();
		ids.clear();
		providedObjectLifeCycleListeners.removeAll();
	}
	
	
}
"
ProvidedObject.java,context,"package org.processmining.framework.providedobjects;

public interface ProvidedObject {

	/**
	 * Returns the ID of this Provided Object
	 * 
	 * @return
	 */
	ProvidedObjectID getID();

	/**
	 * Returns the label of this provided object
	 * 
	 * @return
	 */
	String getLabel();

	/**
	 * Sets the label of this provided object to the new label.
	 * 
	 * @param label
	 *            the new label of the object
	 * @throws ProvidedObjectDeletedException
	 *             If the object was removed from memory because there were no
	 *             useful references to it anymore
	 */
	void setLabel(String label) throws ProvidedObjectDeletedException;

	/**
	 * Returns the object stored in this provided object. If the object is not
	 * an instance of ProMFuture, then the object itself is returned. Otherwise,
	 * it depends on the parameter whether the ProMFuture is returned, or the
	 * calling thread is blocked until the future finished (or is cancelled)
	 * 
	 * @param waitIfFuture
	 *            if set to false, the returned object might be an instance of
	 *            ProMFuture. Otherwise not.
	 * @return
	 * @throws ProvidedObjectDeletedException
	 *             If the object was removed from memory because there were no
	 *             useful references to it anymore
	 */
	Object getObject(boolean waitIfFuture) throws ProvidedObjectDeletedException;

	/**
	 * Same as calling getObject(true);
	 * 
	 * @return
	 * @throws ProvidedObjectDeletedException
	 *             If the object was removed from memory because there were no
	 *             useful references to it anymore
	 */
	Object getObject() throws ProvidedObjectDeletedException;

	/**
	 * Changes the content of this provided object by replacing the original
	 * object with the new object. This can only be done if the current object
	 * has not been deleted yet.
	 * 
	 * @param object
	 * @throws ProvidedObjectDeletedException
	 *             If the object was removed from memory because there were no
	 *             useful references to it anymore
	 */
	void setObject(Object object) throws ProvidedObjectDeletedException;

	/**
	 * Returns whether or not this object has been deleted. Note that if this
	 * method returns false, no ProvidedObjectDeletedExceptions are thrown in
	 * subsequent, synchronized calls to this provided object.
	 * 
	 * @return
	 */
	boolean isDeleted();

	/**
	 * Signals the provided object to delete itself. After calling this method,
	 * isDeleted() will return true and where applicable,
	 * ProvidedObjectDeletedExceptions will be thrown.
	 */
	void deleteObject();

	/**
	 * Returns the type of the object contained in this Provided Object. If the
	 * internal object is a ProMFuture, then the result type of the future is
	 * returned, i.e. ProMFuture.class is never returned by this method.
	 * 
	 * @return
	 * @throws ProvidedObjectDeletedException
	 *             If the object was removed from memory because there were no
	 *             useful references to it anymore
	 */
	Class<?> getType() throws ProvidedObjectDeletedException;

}
"
ProvidedObjectDeletedException.java,context,"package org.processmining.framework.providedobjects;

public class ProvidedObjectDeletedException extends Exception {

	/**
	 * 
	 */
	private static final long serialVersionUID = -4591364700388792910L;

	public ProvidedObjectDeletedException(String name) {
		super(name);
	}

}
"
ProvidedObjectID.java,context,"package org.processmining.framework.providedobjects;

import org.processmining.framework.ProMID;

public interface ProvidedObjectID extends ProMID {

}
"
ProvidedObjectManager.java,context,"package org.processmining.framework.providedobjects;

import java.util.List;

import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.events.ProvidedObjectLifeCycleListener;

public interface ProvidedObjectManager {

	ProvidedObjectLifeCycleListener.ListenerList getProvidedObjectLifeCylceListeners();

	/**
	 * This method creates a new providedObjectID. The context passed to this
	 * method should refer to the PluginContext of which the ProMFuture object
	 * is the result, i.e. this.getProvidedObjectObject(createProvidedObject(
	 * String name, PluginContext context)) = context.getFutureResult(); The
	 * object will be wrapped in a ProMFuture, and a new childContext is created
	 * for this ProMFuture
	 * 
	 * @param name
	 *            The label of the providedObject identified by the returned
	 *            ProvidedObjectID (can be retrieved with
	 *            getProvidedObjectLabel()
	 * @param object
	 *            the object to be wrapped in a new ProMFuture.
	 * @param type
	 *            the type of the object,
	 * @return a globally new id, identifying the providedObject
	 */
	<T> ProvidedObjectID createProvidedObject(String name, T object, Class<? super T> type, PluginContext context);

	/**
	 * This method creates a new providedObjectID. The context passed to this
	 * method should refer to the PluginContext of which the ProMFuture object
	 * is the result, i.e. this.getProvidedObjectObject(createProvidedObject(
	 * String name, PluginContext context)) = context.getFutureResult(); The
	 * object will be wrapped in a ProMFuture, and a new childContext is created
	 * for this ProMFuture
	 * 
	 * Note that no type is provided with this method. Instead, the framework
	 * will use the type of the given object, or if an @SubstitutionType
	 * annotation was used on the object's class definition, the substitution
	 * type is used.
	 * 
	 * @param name
	 *            The label of the providedObject identified by the returned
	 *            ProvidedObjectID (can be retrieved with
	 *            getProvidedObjectLabel()
	 * @param object
	 *            the object to be wrapped in a new ProMFuture.
	 * 
	 * @return a globally new id, identifying the providedObject
	 */
	<T> ProvidedObjectID createProvidedObject(String name, T object, PluginContext context);

	/**
	 * This method creates a list of new providedObjectIDs for each object in
	 * the PluginExecutionResult of the context.
	 * 
	 * @param context
	 *            The context of which this providedObject will be the result
	 * @return a list of globally new ids, identifying the providedObjects
	 */
	List<ProvidedObjectID> createProvidedObjects(PluginContext context);

	/**
	 * returns the provided object identified by this ID. Do not use this method
	 * if not necessary, as the providedObject might not exist in memory
	 * locally.
	 * 
	 * @param id
	 * @param waitIfFuture
	 *            TODO
	 * @return
	 * @throws ProvidedObjectDeletedException
	 */
	Object getProvidedObjectObject(ProvidedObjectID id, boolean waitIfFuture) throws ProvidedObjectDeletedException;

	String getProvidedObjectLabel(ProvidedObjectID id) throws ProvidedObjectDeletedException;

	Class<?> getProvidedObjectType(ProvidedObjectID id) throws ProvidedObjectDeletedException;

	void changeProvidedObjectObject(ProvidedObjectID id, Object newObject) throws ProvidedObjectDeletedException;

	void deleteProvidedObject(ProvidedObjectID id) throws ProvidedObjectDeletedException;

	/**
	 * Returns all provided Object IDs known to the framework. The list is
	 * ordered in order of Arrival, i.e. the first objectID added to the
	 * framework is returned first.
	 * 
	 * @return
	 */
	List<ProvidedObjectID> getProvidedObjects();

	void relabelProvidedObject(ProvidedObjectID id, String label) throws ProvidedObjectDeletedException;

	void setEnabled(boolean enabled);

	boolean isEnabled();

	void clear();
	
}
"
SubstitutionType.java,context,"package org.processmining.framework.providedobjects;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface SubstitutionType {
	Class<?> substitutedType();
}
"
Service.java,context,"package org.processmining.framework.util.socket;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.net.ServerSocket;
import java.net.Socket;
import java.net.SocketTimeoutException;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.Executor;

import org.processmining.framework.plugin.events.Logger.MessageLevel;

/**
 * This is a wrapper for a server socket. It has an arbitrary number of
 * registered ServiceHandler-s. Whenever a client connects to the service, all
 * registered handlers are notified. Each handler can further communucate with
 * the client.
 * 
 * @author christian
 * 
 */

public class Service {

	protected ServerSocket serverSocket; // server socket
	private final int port; // port for the server socket
	protected List<ServiceHandler> handlers = new ArrayList<ServiceHandler>(); // registered handlers

	/**
	 * The only constructor, which simply sets a port to be used by the server
	 * socket. Note that the constructor does not open the server socket.
	 * 
	 * @param port
	 *            for the server socket.
	 */
	public Service(int port) {
		super();
		this.port = port;
		serverSocket = null;
	}

	/**
	 * Registers a new handler. From this moment, the handler will be notified
	 * about new client connections.
	 * 
	 * @param handler
	 *            to be registered.
	 */
	public void addServiceHandler(ServiceHandler handler) {
		handlers.add(handler);
	}

	/**
	 * Unregister the handler. From this moment, the handler will not longer be
	 * notified about new client connections.
	 * 
	 * @param handler
	 *            to be unregistered.
	 */
	public void removeServiceHandler(ServiceHandler handler) {
		handlers.remove(handler);
	}

	/**
	 * Opens the server socked on the given port. Periodically notifies the
	 * environment that the service is alive. Notifies all registered handlers
	 * about every new client connection. It keeps on listening on the socket
	 * until the environment is canceled, upon which the socket is closed.
	 * 
	 * @param environment
	 *            is the environment of this service.
	 * @param executor
	 *            enables notification of handlers in a new thread.
	 * @throws IOException
	 */
	public void start(ServiceEnvironment environment, Executor executor) throws IOException {
		serverSocket = new ServerSocket(getPort());

		while (!environment.isCancelled()) {
			try {
				environment.stillAlive();
				// wait for and handle incoming connections
				serverSocket.setSoTimeout(500);
				Socket clientSocket = serverSocket.accept();
				handleConnection(clientSocket, environment, executor);
			} catch (SocketTimeoutException e) {
				// environment.log(""No Connection Accepted"", MessageLevel.DEBUG);
				continue;
			} catch (IOException e) {
				// abort and give up
				environment.log(""Operational Support Server Failed: "" + e.getMessage(), MessageLevel.ERROR);
				serverSocket.close();
				throw e;
			}
		}
		serverSocket.close();

		environment.log(""Operational Support Server Finished"", MessageLevel.DEBUG);
	}

	/**
	 * Notifies all registered handlers about every new client connection.
	 * 
	 * @param socket
	 *            is the client socket.
	 * @param environment
	 *            is the environment of this service.
	 * @param executor
	 *            enables notification of handlers in a new thread.
	 */
	protected void handleConnection(Socket socket, ServiceEnvironment environment, Executor executor) {
		ConnectionHandlerRunnable handler = new ConnectionHandlerRunnable(socket, environment);
		executor.execute(handler);
	}

	/**
	 * Get the server port.
	 * 
	 * @return the port.
	 */
	public int getPort() {
		return port;
	}

	/**
	 * A simple class that enables notification of ServiceHandler-s in a new
	 * thread.
	 * 
	 * @author christian
	 * 
	 */
	protected class ConnectionHandlerRunnable implements Runnable {

		protected Socket clientSocket;
		private final ServiceEnvironment environment;

		public ConnectionHandlerRunnable(Socket aSocket, ServiceEnvironment environment) {
			clientSocket = aSocket;
			this.environment = environment;
		}

		/**
		 * Notifies all registered handlers about a new client connection in a
		 * new thread.
		 */
		public void run() {
			try {
				BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));
				PrintWriter out = new PrintWriter(clientSocket.getOutputStream(), true);
				for (ServiceHandler handler : handlers) {
					handler.handleRequest(environment, in, out);
				}
			} catch (IOException e) {
				// abort and give up

				environment.log(""Fatal error handling connection,"", MessageLevel.ERROR);
				environment.log(""failed with IO Exception:"", MessageLevel.ERROR);
				environment.log(e);
			} finally {
				// clean up connection
				try {
					if (clientSocket != null) {
						clientSocket.close();
					}
				} catch (IOException ie) { /* this one's forsaken.. */
				}
			}
		}
	}

}
"
ServiceEnvironment.java,context,"package org.processmining.framework.util.socket;

import org.processmining.framework.plugin.events.Logger.MessageLevel;

/**
 * This interface represents a service environment. It allows communication
 * between a service and its environment.
 * 
 * @author Maja Pesic
 */

public interface ServiceEnvironment {

	/**
	 * Provides the information about the state of the environment. A service
	 * uses this method to decide when to close its socket.
	 * 
	 * @return true - if the socket should be closed false - if the service
	 *         should continue listening on the socket.
	 */
	public boolean isCancelled();

	/**
	 * A service uses this method to log messages in the environment.
	 * 
	 * @param message
	 *            is the message that should be logged
	 * @param level
	 *            is the type of message
	 */
	public void log(String message, MessageLevel level);

	/**
	 * A service uses this method to log messages in the environment.
	 * 
	 * @param message
	 *            is the message that should be logged
	 */
	public void log(String message);

	/**
	 * A service uses this method to log occurrence of an exception in the
	 * environment.
	 * 
	 * @param t
	 *            is the exception that occurred and should be logged
	 */
	public void log(Throwable t);

	/**
	 * While listening on its socket, a service will regularly invoke this
	 * method. This method periodically signals to the environment that the
	 * service is still listening to its socket.
	 */
	public void stillAlive();

	/**
	 * A service uses this method to signal that it has been canceled (i.e., the
	 * socket is closed).
	 */
	public void cancel();

}
"
ServiceHandler.java,context,"package org.processmining.framework.util.socket;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;

/**
 * This interface enables a service to respond to newly connected clients. If a
 * class wants to be informed about and/or respond to new requests of a service,
 * then this class should implement this interface and it should be added as a
 * handler to the service.
 * 
 * @author christian
 */

public interface ServiceHandler {
	/**
	 * Invoked whenever a client connects to the service.
	 * 
	 * @param environment
	 *            is the registered environment of the service. A handler can
	 *            use this parameter to, for example, log messages.
	 * @param in
	 *            is the buffer from which the client's request can be read.
	 * @param out
	 *            is the buffer where a possible response to the client can be
	 *            written.
	 * @throws IOException
	 */
	public void handleRequest(ServiceEnvironment environment, BufferedReader in, PrintWriter out) throws IOException;
}
"
SortedMultiSet.java,context,"package org.processmining.framework.util.collection;

import java.util.Comparator;
import java.util.SortedSet;

public interface SortedMultiSet<T> extends MultiSet<T> {

	Comparator<? super T> comparator();

	/**
	 * returns an unmodifiable set of unique objects in the multiset.
	 * 
	 * @return an unmodifiable set of unique objects in the multiset.
	 */
	SortedSet<T> baseSet();

}
"
TreeMultiSet.java,context,"package org.processmining.framework.util.collection;

import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.SortedSet;
import java.util.TreeMap;
import java.util.TreeSet;

public class TreeMultiSet<T> extends AbstractMultiSet<T, TreeMap<T, Integer>> implements SortedMultiSet<T> {

	private Comparator<? super T> comparator;

	/**
	 * Constructs a new multiset, such that all elements of the given collection
	 * are added as many times as they are returned by the iterator of that
	 * collection.
	 * 
	 * All elements inserted into the multiset must implement the Comparable
	 * interface. Furthermore, all such elements must be mutually comparable:
	 * e1.compareTo(e2) must not throw a ClassCastException for any elements e1
	 * and e2 in the set.
	 * 
	 * @param collection
	 *            Representing the objects that should be put in a multiset
	 */
	public TreeMultiSet(Collection<T> collection) {
		this((Comparator<T>) null);
		addAll(collection);
	}

	/**
	 * Constructs a new multiset, such that all elements of the given collection
	 * are added as many times as they are in the given array.
	 * 
	 * All elements inserted into the multiset must implement the Comparable
	 * interface. Furthermore, all such elements must be mutually comparable:
	 * e1.compareTo(e2) must not throw a ClassCastException for any elements e1
	 * and e2 in the set.
	 * 
	 * @param collection
	 *            Representing the objects that should be put in a multiset
	 */
	public TreeMultiSet(T... collection) {
		this((Comparator<T>) null);
		for (T par : collection) {
			add(par);
		}
	}

	/**
	 * Constructs a new, empty multiset, such that all elements of the given
	 * collection are added as many times as they are returned by the iterator
	 * of that collection.
	 * 
	 * All elements inserted into the multiset must implement the Comparable
	 * interface. Furthermore, all such elements must be mutually comparable:
	 * e1.compareTo(e2) must not throw a ClassCastException for any elements e1
	 * and e2 in the set.
	 * 
	 */
	public TreeMultiSet() {
		this((Comparator<T>) null);
	}

	/**
	 * Constructs a new multiset, such that all elements of the given collection
	 * are added as many times as they are returned by the iterator of that
	 * collection.
	 * 
	 * @param comp
	 *            A comparator providing sorting on the elements of the multiset
	 * @param collection
	 *            Representing the objects that should be put in a multiset
	 */
	public TreeMultiSet(Collection<T> collection, Comparator<? super T> comp) {
		this(comp);
		addAll(collection);
	}

	/**
	 * Constructs a new multiset, such that all elements of the given collection
	 * are added as many times as they are in the given array.
	 * 
	 * @param comp
	 *            A comparator providing sorting on the elements of the multiset
	 * @param collection
	 *            Representing the objects that should be put in a multiset
	 */
	public TreeMultiSet(Comparator<? super T> comp, T... collection) {
		this(comp);
		for (T par : collection) {
			add(par);
		}
	}

	/**
	 * Constructs a new, empty multiset, such that all elements of the given
	 * collection are added as many times as they are returned by the iterator
	 * of that collection.
	 * 
	 * @param comp
	 *            A comparator providing sorting on the elements of the multiset
	 */
	public TreeMultiSet(Comparator<? super T> comp) {
		size = 0;
		TreeMap<T, Integer> newMap = new TreeMap<T, Integer>(comp);
		comparator = newMap.comparator();
		map = newMap;
	}

	<S> MultiSet<S> newMultiSet(Collection<S> collection) {
		return new TreeMultiSet<S>(collection);
	}

	MultiSet<T> newMultiSet() {
		return new TreeMultiSet<T>();
	}

	public Comparator<? super T> comparator() {
		return comparator;
	}

	/**
	 * returns an unmodifiable set of unique objects in the multiset.
	 * 
	 * @return an unmodifiable set of unique objects in the multiset.
	 */
	public SortedSet<T> baseSet() {
		// JAVA 5 CODE:
		SortedSet<T> set = new TreeSet<T>(comparator);
		set.addAll(map.keySet());
		// JAVA 6 CODE:
		// SortedSet<T> set = map.navigableKeySet());
		return Collections.unmodifiableSortedSet(set);
	}
}
"
WeakKeyValueMap.java,context,"package org.processmining.framework.util.collection;

import java.lang.ref.WeakReference;
import java.util.AbstractMap;
import java.util.Collection;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import java.util.WeakHashMap;

public class WeakKeyValueMap<K, V> extends AbstractMap<K, V> {

	private final Map<K, WeakReference<V>> map;

	public WeakKeyValueMap(int initialCapacity, float loadFactor) {
		map = new WeakHashMap<K, WeakReference<V>>(initialCapacity, loadFactor);
	}

	public WeakKeyValueMap(int initialCapacity) {
		map = new WeakHashMap<K, WeakReference<V>>(initialCapacity);
	}

	public WeakKeyValueMap() {
		map = new WeakHashMap<K, WeakReference<V>>();

	}

	public WeakKeyValueMap(Map<? extends K, ? extends V> m) {
		this();
		putAll(m);
	}

	public void clear() {
		map.clear();
	}

	public boolean containsKey(Object key) {
		return map.containsKey(key);
	}

	public boolean containsValue(Object value) {
		for (WeakReference<V> w : map.values()) {
			if (value.equals(w.get())) {
				return true;
			}
		}
		return false;
	}

	public Set<java.util.Map.Entry<K, V>> entrySet() {
		Set<java.util.Map.Entry<K, V>> set = new HashSet<java.util.Map.Entry<K, V>>();
		for (java.util.Map.Entry<K, WeakReference<V>> entry : map.entrySet()) {
			set.add(new SimpleEntry<K, V>(entry.getKey(), entry.getValue().get()));
		}
		return set;
	}

	public V get(Object key) {
		WeakReference<V> val = map.get(key);
		return val == null ? null : val.get();
	}

	public boolean isEmpty() {
		return map.isEmpty();
	}

	public Set<K> keySet() {
		return map.keySet();
	}

	public V put(K key, V value) {
		V val = get(key);
		map.put(key, new WeakReference<V>(value));
		return val;
	}

	public void putAll(Map<? extends K, ? extends V> m) {
		for (Map.Entry<? extends K, ? extends V> entry : m.entrySet()) {
			put(entry.getKey(), entry.getValue());
		}
	}

	public V remove(Object key) {
		return map.remove(key).get();
	}

	public int size() {
		return map.size();
	}

	public Collection<V> values() {
		Set<V> set = new HashSet<V>();
		for (WeakReference<V> val : map.values()) {
			set.add(val.get());
		}
		return set;
	}

}
"
XMonitoredInputStream.java,context,"/*
 * OpenXES
 * 
 * The reference implementation of the XES meta-model for event 
 * log data management.
 * 
 * Copyright (c) 2008 Christian W. Guenther (christian@deckfour.org)
 * 
 * 
 * LICENSE:
 * 
 * This code is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 3
 * of the License, or (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA
 * 
 * EXEMPTION:
 * 
 * The use of this software can also be conditionally licensed for
 * other programs, which do not satisfy the specified conditions. This
 * requires an exemption from the general license, which may be
 * granted on a per-case basis.
 * 
 * If you want to license the use of this software with a program
 * incompatible with the LGPL, please contact the author for an
 * exemption at the following email address: 
 * christian@deckfour.org
 * 
 */
package org.processmining.framework.util.progress;

import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;

import javax.swing.JProgressBar;

/**
 * This class implements an input stream which can provide
 * a progress listener with feedback about how much of the
 * data in the stream has already been read.
 * 
 * This is a useful utility for reading XML-based data,
 * while still providing feedback about expected progress.
 * 
 * @author Christian W. Guenther (christian@deckfour.org)
 *
 */
public class XMonitoredInputStream extends InputStream {
	
	/**
	 * The number of steps to be used for progress expression.
	 */
	protected int stepNumber = 1000;
	/**
	 * Number of bytes per step.
	 */
	protected long stepSize;
	/**
	 * The last step which has been notified about.
	 */
	protected int lastStep;
	/**
	 * Number of bytes read so far.
	 */
	protected long bytesRead = 0;
	/**
	 * Wrapped, monitored input stream.
	 */
	protected InputStream stream;
	/**
	 * Progress listener which is being notified.
	 */
	protected XProgressListener progressListener;
	
	/**
	 * Creates a new monitored input stream.
	 * 
	 * @param file The file to be read from.
	 * @param progressListener Progress listener to be notified.
	 */
	public XMonitoredInputStream(File file, XProgressListener progressListener) throws FileNotFoundException {
		this(new BufferedInputStream(new FileInputStream(file)), file.length(), progressListener);
	}
	
	/**
	 * Creates a new monitored input stream.
	 * 
	 * @param stream Monitored, wrapped lower-level input stream.
	 * @param size Number of bytes to be read from the stream.
	 * @param progressBar Progress bar to be updated.
	 */
	public XMonitoredInputStream(InputStream stream, long size, JProgressBar progressBar) {
		this(stream, size, new XProgressBarListener(progressBar), 1000);
	}
	
	/**
	 * Creates a new monitored input stream.
	 * 
	 * @param stream Monitored, wrapped lower-level input stream.
	 * @param size Number of bytes to be read from the stream.
	 * @param progressListener Progress listener to be notified.
	 */
	public XMonitoredInputStream(InputStream stream, long size, XProgressListener progressListener) {
		this(stream, size, progressListener, 1000);
	}
	
	/**
	 * Creates a new monitored input stream.
	 * 
	 * @param stream Monitored, wrapped lower-level input stream.
	 * @param size Number of bytes to be read from the stream.
	 * @param progressListener Progress listener to be notified.
	 * @param stepNumber Number of steps used to express progress.
	 */
	public XMonitoredInputStream(InputStream stream, long size, XProgressListener progressListener, int stepNumber) {
		this.progressListener = progressListener;
		this.stream = stream;
		this.stepNumber = stepNumber;
		// avoid potential divide by 0 when stepsize == 0
		this.stepSize = Math.max(size / stepNumber, 1);
		this.lastStep = 0;
		this.bytesRead = 0;
	}
	
	/**
	 * This method is called by the actual input stream method
	 * to provide feedback about the number of read bytes.
	 * 
	 * Notifies the attached progress listener if appropriate.
	 * 
	 * @param readBytes The number of read bytes in this call.
	 */
	protected void update(long readBytes) throws IOException {
		if (progressListener.isAborted()) {
			throw new IOException(""Reading Cancelled by ProgressListener"");
		}
		this.bytesRead += readBytes;
		int step = (int)(bytesRead / stepSize);
		if(step > lastStep) {
			lastStep = step;
			progressListener.updateProgress(step, stepNumber);
		}
	}
	
	/**
	 * Returns the number of steps so far.
	 * 
	 * @return Number of steps.
	 */
	public int getStepNumber() {
		return stepNumber;
	}
	
	/* (non-Javadoc)
	 * @see java.io.InputStream#read()
	 */
	@Override
	public int read() throws IOException {
		int result = stream.read();
		update(1);
		return result;
	}

	/* (non-Javadoc)
	 * @see java.io.InputStream#read(byte[], int, int)
	 */
	@Override
	public int read(byte[] b, int off, int len) throws IOException {
		int result = stream.read(b, off, len);
		update(result);
		return result;
	}

	/* (non-Javadoc)
	 * @see java.io.InputStream#read(byte[])
	 */
	@Override
	public int read(byte[] b) throws IOException {
		int result = stream.read(b);
		update(result);
		return result;
	}

	/* (non-Javadoc)
	 * @see java.io.InputStream#skip(long)
	 */
	@Override
	public long skip(long n) throws IOException {
		long result = stream.skip(n);
		update(result);
		return result;
	}
	
	

}
"
XProgressBarListener.java,context,"/*
 * OpenXES
 * 
 * The reference implementation of the XES meta-model for event 
 * log data management.
 * 
 * Copyright (c) 2008 Christian W. Guenther (christian@deckfour.org)
 * 
 * 
 * LICENSE:
 * 
 * This code is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 3
 * of the License, or (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA
 * 
 * EXEMPTION:
 * 
 * The use of this software can also be conditionally licensed for
 * other programs, which do not satisfy the specified conditions. This
 * requires an exemption from the general license, which may be
 * granted on a per-case basis.
 * 
 * If you want to license the use of this software with a program
 * incompatible with the LGPL, please contact the author for an
 * exemption at the following email address: 
 * christian@deckfour.org
 * 
 */
package org.processmining.framework.util.progress;

import javax.swing.JProgressBar;

/**
 * This class implements a progress listener for controlling
 * an attached Swing progress bar. The progress bar will then reflect
 * the progress as received by this listener.
 * 
 * @author Christian W. Guenther (christian@deckfour.org)
 *
 */
public class XProgressBarListener implements XProgressListener {

	/**
	 * Controlled progress bar.
	 */
	protected JProgressBar progressBar;
	/**
	 * Start value to use in progress bar.
	 * When the progress listener begins, this will be
	 * the displayed value on the progress bar.
	 */
	protected int startValue;
	/**
	 * Stop value to use in progress bar.
	 * When the progress listener is completed, this will
	 * be the displayed value on the progress bar.
	 */
	protected int stopValue;
	
	/**
	 * Creates a new progress bar listener with the specified progress
	 * bar for display. The progress bar will accurately and completely
	 * reflect the progress, as received by this listener.
	 * 
	 * @param progressBar Progress bar to display progress.
	 */
	public XProgressBarListener(JProgressBar progressBar) {
		this(progressBar, progressBar.getMinimum(), progressBar.getMaximum());
	}
	
	/**
	 * Creates a new progress bar listener with the specified progress
	 * bar for display. Allows the specification of start and stop values
	 * for the progress bar, so that this listener may control only part
	 * of a more higher-level progress (e.g., the loading of one from
	 * a number of files).
	 * 
	 * @param progressBar Progress bar to display progress.
	 * @param startValue When the progress listener begins, this will be
	 * the displayed value on the progress bar.
	 * @param stopValue When the progress listener is completed, this will
	 * be the displayed value on the progress bar.
	 */
	public XProgressBarListener(JProgressBar progressBar, int startValue, int stopValue) {
		this.progressBar = progressBar;
		this.startValue = startValue;
		this.stopValue = stopValue;
	}
	
	/* (non-Javadoc)
	 * @see org.deckfour.xes.util.MonitoredInputStream.ProgressListener#updateProgress(int, int)
	 */
	public void updateProgress(int progress, int maxProgress) {
		int increment = (int)((double)(stopValue - startValue) * ((double)maxProgress / (double)progress));
		progressBar.setValue(startValue + increment);
	}

	/**
	 * Checks whether the monitored process has been canceled.
	 */
	public boolean isAborted() {
		return false;
	}

}
"
XProgressListener.java,context,"/*
 * OpenXES
 * 
 * The reference implementation of the XES meta-model for event 
 * log data management.
 * 
 * Copyright (c) 2008 Christian W. Guenther (christian@deckfour.org)
 * 
 * 
 * LICENSE:
 * 
 * This code is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 3
 * of the License, or (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA
 * 
 * EXEMPTION:
 * 
 * The use of this software can also be conditionally licensed for
 * other programs, which do not satisfy the specified conditions. This
 * requires an exemption from the general license, which may be
 * granted on a per-case basis.
 * 
 * If you want to license the use of this software with a program
 * incompatible with the LGPL, please contact the author for an
 * exemption at the following email address: 
 * christian@deckfour.org
 * 
 */
package org.processmining.framework.util.progress;

/**
 * Interface for listening for progress on
 * an unspecified process.
 * 
 * A progress listener can abort the monitored
 * process. Abortion is specified by using the
 * <code>isAborted()</code> method, which should
 * be queried periodically by the using party.
 * 
 * @author Christian W. Guenther (christian@deckfour.org)
 *
 */
public interface XProgressListener {

	/**
	 * Notifies the listener about progress being made.
	 * 
	 * @param progress Current progress step achieved.
	 * @param maxProgress Maximal progress steps available.
	 */
	public void updateProgress(int progress, int maxProgress);
	
	/**
	 * Checks whether the monitored process has been canceled.
	 */
	public boolean isAborted();
	
}
"
AbstractMultiSet.java,framework,"package org.processmining.framework.util.collection;

import java.util.AbstractCollection;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.NoSuchElementException;
import java.util.Set;

import org.processmining.framework.util.Cast;

/**
 * This class implements a mutliset. The implementation is synchronized.
 * 
 * @author bfvdonge
 * 
 * @param <T>
 *            the type of the objects in this multiset.
 */
public abstract class AbstractMultiSet<T, M extends Map<T, Integer>> extends AbstractCollection<T> implements
		MultiSet<T> {

	protected M map;
	protected int size;
	private int hashCode;
	private boolean hashValid = false;

	private static final long serialVersionUID = -6521454214767452945L;

	abstract <S> MultiSet<S> newMultiSet(Collection<S> collection);

	abstract MultiSet<T> newMultiSet();

	/**
	 * Keeps all elements of the given collection in this multiset. Multicities
	 * are taken into account, i.e. as many of the same objects are kept as
	 * returned by the collections iterator.
	 * 
	 * @return true if the multiset changed from calling this method.
	 */
	@Override
	public boolean retainAll(Collection<?> c) {
		hashValid = false;
		return retainAll(newMultiSet(c));
	}

	/**
	 * adds one object to the multiset. If the object was not contained before,
	 * then it now has one occerrence, otherwise, the number of occurrences is
	 * increased.
	 * 
	 * @return true, since the collection is always modified.
	 */
	@Override
	public boolean add(T par) {
		add(par, 1);
		hashValid = false;
		return true;
	}

	/**
	 * Keeps all elements of the given collection in this multiset.
	 * Multiplicities are taken into account.
	 * 
	 * @return true if the multiset changed from calling this method.
	 */
	public boolean retainAll(MultiSet<?> c) {
		boolean changed = false;
		Iterator<T> it = map.keySet().iterator();
		while (it.hasNext()) {
			T key = it.next();
			
			Integer occToRetain = c.occurrences(key);
			Integer occInThis = occurrences(key);
			if (occInThis >= occToRetain) {
				// keep occToRetain
				size -= (occInThis - occToRetain);
				if (occToRetain == 0) {
					it.remove();
				} else {
					map.put(key, occToRetain);
				}
				changed = true;
				hashValid = false;
			}
		}
		return changed;
	}

	/**
	 * Adds the given object to the multiset, as many times as indicated by the
	 * given weight parameter.
	 * 
	 * @param par
	 *            the object to add
	 * @param weight
	 *            the number of times to add it
	 * @return the new number of occurrences of the object (>0)
	 */
	public Integer add(T par, Integer weight) {
		if (weight == 0) {
			return weight;
		}
		hashValid = false;
		long newSize = (long) size + (long) weight;
		if (newSize > Integer.MAX_VALUE) {
			size = Integer.MAX_VALUE;
		} else {
			size = (int) newSize;
		}
		if (!map.containsKey(par)) {
			assert (weight > 0);
			map.put(par, weight);
			return weight;
		} else {
			long num = (long) map.get(par) + (long) weight;
			if (num > Integer.MAX_VALUE) {
				num = Integer.MAX_VALUE;
			}
			if (num == 0) {
				map.remove(par);
			} else {
				assert (num > 0);
				map.put(par, (int) num);
			}
			return (int) num;
		}
	}

	/**
	 * Adds the given collection to this multiset. If the given collection is
	 * not a multiset, then the implementation is diverted to
	 * abstractcollection.
	 * 
	 * @param collection
	 *            the collection to add
	 * @return true if the multiset changed due to this method call.
	 */
	@Override
	public boolean addAll(Collection<? extends T> collection) {
		if (collection.isEmpty()) {
			return false;
		}
		hashValid = false;
		if (collection instanceof MultiSet<?>) {
			MultiSet<? extends T> mset = Cast.<MultiSet<? extends T>>cast(collection);
			for (T key : mset.baseSet()) {
				add(key, mset.occurrences(key));
			}
		} else {
			for (T key : collection) {
				add(key);
			}
		}
		return true;
	}

	/**
	 * Converts this multiset to a list, such that each element occurs as often
	 * as returned by the iterator of the multiset (its number of occurrences).
	 * 
	 * @return a list of objects as returned by the iterator
	 */
	public List<T> toList() {
		List<T> list = new ArrayList<T>(size);
		for (T occ : this) {
			list.add(occ);
		}
		return list;
	}

	/**
	 * returns true if this multiset is less or equal to the given multiset,
	 * i.e. all objects in this multiset should be contained in the given set
	 * and the number of occurrences in the given set is at least the number of
	 * occurrences in this multiset.
	 * 
	 * @param multiSet
	 *            the multiset to test
	 * @return true if the given multiset is less or equal.
	 */
	public boolean isLessOrEqual(MultiSet<T> multiSet) {
		for (T element : baseSet()) {
			if (multiSet.occurrences(element) < occurrences(element)) {
				return false;
			}
		}
		return true;
	}

	protected boolean containsAtLeast(T element, int occ) {
		return occurrences(element) >= occ;
	}

	/**
	 * returns true if the multisets are equal, i.e. if they contain the same
	 * objects with the same number of occurrences.
	 */
	@Override
	public boolean equals(Object o) {
		if (o instanceof AbstractMultiSet<?, ?>) {
			return map.equals(((AbstractMultiSet<?, ?>) o).map);
		}
		return false;
	}

	/**
	 * returns the size of the multiset, i.e. the sum over the multiplicities of
	 * all contained objects.
	 */
	@Override
	public int size() {
		return size;
	}

	/**
	 * returns a string representing this multiset. The string contains, between
	 * brackets, pairs of objects and their multiplicities.
	 */
	@Override
	public String toString() {
		String s = ""["";
		for (Map.Entry<T, Integer> entry : map.entrySet()) {
			if (!s.equals(""["")) {
				s += "" "";
			}
			s += ""("" + entry.getKey() + "","" + entry.getValue() + "")"";
		}
		return s + ""]"";
	}

	/**
	 * returns a hashCode for this multiset.
	 */
	@Override
	public int hashCode() {
		if (!hashValid) {
			hashCode = map.hashCode();
			hashValid = true;
		}
		return hashCode;

	}

	/**
	 * returns the number of occurrences of the given object in this multiset.
	 * 
	 * @param source
	 *            the object to get the occurrences for
	 * @return the number of occurrences, 0 if the object does not occur.
	 */
	public Integer occurrences(Object source) {
		return (map.keySet().contains(source) ? map.get(source) : 0);
	}

	/**
	 * returns an iterator over the elements of the multiset. Note that if an
	 * object appears n times in the multiset, it is returned n times by the
	 * iterator.
	 * 
	 * For an iterator over unique elements of the multiset, use the toSet()
	 * method.
	 */
	@Override
	public Iterator<T> iterator() {
		return new MultiSetIterator<T, M>(this);
	}

	/**
	 * returns an unmodifiable set of unique objects in the multiset.
	 * 
	 * @return an unmodifiable set of unique objects in the multiset.
	 */
	public Set<T> baseSet() {
		return Collections.unmodifiableSet(map.keySet());
	}

	/**
	 * checks whether the number of occurrences of the given object is greater
	 * or equal to 1.
	 */
	@Override
	public boolean contains(Object o) {
		return map.containsKey(o);
	}

	/**
	 * Checks whether the number of occurrences of elements in the given
	 * collection is at most what is specified in this collection, i.e., this
	 * method returns (new MultiSet(c)).isLessOrEqual(this)
	 */
	@SuppressWarnings(""unchecked"")
	@Override
	public boolean containsAll(Collection<?> c) {
		MultiSet set;
		if (c instanceof MultiSet) {
			set = (MultiSet) c;
		} else {
			set = newMultiSet(c);
		}
		return set.isLessOrEqual(this);
	}

	/**
	 * removes the given object from this multiset, if it is in there. Only one
	 * occurrence is removed, i.e. contains(o) can still be true after calling
	 * remove(o)
	 */
	@SuppressWarnings(""unchecked"")
	@Override
	public boolean remove(Object o) {
		if (occurrences(o) == 0) {
			return false;
		} else {
			hashValid = false;
			// removing 1 occurrence
			size--;
			Integer occ = map.get(o);
			if (occ == 1) {
				map.remove(o);
				return true;
			} else {
				// since o is in this multiset, it can safely
				// be cast to T
				map.put((T) o, occ - 1);
				return true;
			}
		}
	}

	/**
	 * removes the elements in the given multiset from this multiset.
	 * 
	 * @param mset
	 *            the multiset of elements needing to be removed.
	 * @return a new multiset where the occurrences are the occurrences in this
	 *         multiset, minus the occurrences in the given multiset
	 */
	@Override
	public boolean removeAll(Collection<?> collection) {
		if (collection instanceof AbstractMultiSet<?, ?>) {
			return !removeAllMultiSet(Cast.<AbstractMultiSet<?, ?>>cast(collection), newMultiSet()).isEmpty();
		} else {
			boolean b = false;
			for (Object o : collection) {
				b |= remove(o);
			}
			return b;
		}
	}

	protected <S extends MultiSet<T>> S removeAllMultiSet(AbstractMultiSet<?, ?> mset, S removed) {
		for (Map.Entry<?, Integer> entry : mset.map.entrySet()) {
			if (!map.containsKey(entry.getKey())) {
				continue;
			}
			// Since map.containsKey(entry.getKey()), this is a safe cast
			T key = Cast.<T>cast(entry.getKey());
			Integer val = map.get(key);
			// What's the minimum of the amount I have and the amount I have to remove
			Integer toRemove = Math.min(entry.getValue(), val);
			removed.add(key, toRemove);

			size -= toRemove;
			if (val - toRemove == 0) {
				map.remove(key);
			} else {
				assert (val - toRemove > 0);
				map.put(key, val - toRemove);
			}
		}
		hashValid = false;
		return removed;
	}

	public String toHTMLString(boolean includeHTMLTags) {

		String s = (includeHTMLTags ? ""<html>"" : """") + ""["";
		for (Map.Entry<T, Integer> entry : map.entrySet()) {
			if (!s.endsWith(""["")) {
				s += "","";
			}
			s += entry.getKey();
			if (entry.getValue() > 1) {
				s += ""<sup>"" + entry.getValue() + ""</sup>"";
			}
		}
		return s + ""]"" + (includeHTMLTags ? ""</html>"" : """");
	}

	@Override
	public void clear() {
		map.clear();
		hashValid = false;
		size = 0;
	}

	@Override
	public boolean isEmpty() {
		return size == 0;
	}

}

/**
 * Provides an iterator over a MultiSet. This iterator returns objects as many
 * times as they are contained in the multiset.
 * 
 * @author bfvdonge
 * 
 * @param <T>
 */
class MultiSetIterator<T, M extends Map<T, Integer>> implements Iterator<T> {

	private final AbstractMultiSet<T, M> multiset;
	private final Iterator<Map.Entry<T, Integer>> iterator;
	private Entry<T, Integer> currentEntry = null;
	private Integer toGiveCount = 0;
	private boolean removed = false;

	public MultiSetIterator(AbstractMultiSet<T, M> multiset) {
		this.multiset = multiset;
		this.iterator = multiset.map.entrySet().iterator();
	}

	public boolean hasNext() {
		// No next object, if toGiveCount ==0 and iterator has no next object
		return !((toGiveCount == 0) && !iterator.hasNext());
	}

	public T next() throws NoSuchElementException {
		if (!hasNext()) {
			throw new NoSuchElementException();
		}
		if (toGiveCount == 0) {
			this.currentEntry = iterator.next();
			this.toGiveCount = currentEntry.getValue();
		}
		// reduce the toGiveCount by 1.
		toGiveCount--;
		removed = false;
		return currentEntry.getKey();
	}

	public void remove() {
		if (removed) {
			throw new IllegalStateException();
		}
		int val = currentEntry.getValue();
		if (val > 1) {
			currentEntry.setValue(val - 1);
		} else {
			iterator.remove();
		}
		multiset.size--;
		removed = true;
	}

}
"
AbstractImportPlugin.java,framework,"package org.processmining.framework.abstractplugins;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.InputStream;
import java.net.URI;
import java.net.URL;

import javax.swing.filechooser.FileFilter;

import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.PluginVariant;

/**
 * Note that implementing classes of this baseclass should carry the
 * UIImportPlugin annotation
 * 
 * Subclasses of AbstractImportPlugin should use the @Plugin Annotation as
 * follows:
 * 
 * @Plugin( name = ""{any name}"", parameterLabels={""Filename""}, returnLabels = {
 *          {The right return labels} }, returnTypes = { {The right return
 *          classes} })
 * 
 * 
 * @author bfvdonge
 * 
 */
public abstract class AbstractImportPlugin implements ImportPlugin {

	private File file = null;

	/*
	 * (non-Javadoc)
	 * 
	 * @see org.processmining.plugins.abstractplugins.ImportPlugin#getFile()
	 */
	public File getFile() {
		return file;
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see
	 * org.processmining.plugins.abstractplugins.ImportPlugin#importFile(org
	 * .processmining.framework.plugin.PluginContext, java.lang.String)
	 */
	@PluginVariant(requiredParameterLabels = { 0 })
	public Object importFile(PluginContext context, String filename) throws Exception {
		file = new File(filename);
		return importFromStream(context, new FileInputStream(file), filename, file.length());
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see
	 * org.processmining.plugins.abstractplugins.ImportPlugin#importFile(org
	 * .processmining.framework.plugin.PluginContext, java.net.URI)
	 */
	@PluginVariant(requiredParameterLabels = { 0 })
	public Object importFile(PluginContext context, URI uri) throws Exception {
		return importFromStream(context, uri.toURL().openStream(), uri.toString(), 0);
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see
	 * org.processmining.plugins.abstractplugins.ImportPlugin#importFile(org
	 * .processmining.framework.plugin.PluginContext, java.net.URL)
	 */
	@PluginVariant(requiredParameterLabels = { 0 })
	public Object importFile(PluginContext context, URL url) throws Exception {
		file = new File(url.toURI());
		return importFromStream(context, url.openStream(), url.toString(), 0);
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see
	 * org.processmining.plugins.abstractplugins.ImportPlugin#importFile(org
	 * .processmining.framework.plugin.PluginContext, java.io.File)
	 */
	@PluginVariant(requiredParameterLabels = { 0 })
	public Object importFile(PluginContext context, File f) throws Exception {
		file = f;
		InputStream stream = getInputStream(f);
		return importFromStream(context, stream, file.getName(), file.length());
	}

	/**
	 * This method returns an inputStream for a file. Note that the default
	 * implementation returns ""new FileInputStream(file);""
	 * 
	 * @param file
	 * @return
	 * @throws FileNotFoundException
	 */
	protected InputStream getInputStream(File file) throws Exception {
		return new FileInputStream(file);
	}

	/**
	 * This method is called by all plugin variants to do the actual importing.
	 * 
	 * @param context
	 * @param input
	 * @param filename
	 * @param fileSizeInBytes
	 * @return
	 * @throws Exception
	 */
	protected abstract Object importFromStream(PluginContext context, InputStream input, String filename,
			long fileSizeInBytes) throws Exception;

}

class ZipFilter extends FileFilter {

	private final FileFilter parent;

	public ZipFilter(FileFilter parent) {
		this.parent = parent;
	}

	public boolean accept(File f) {
		return (f.getAbsolutePath().endsWith("".zip"") || parent.accept(f));
	}

	public String getDescription() {
		return parent.getDescription();
	}

}"
ImportPlugin.java,framework,"package org.processmining.framework.abstractplugins;

import java.io.File;
import java.net.URI;
import java.net.URL;

import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.PluginVariant;

/**
 * This interface should be implemented by plugins that serve as input plugins.
 * 
 * Such a plugin should have the @Plugin annotation on the class level and does
 * not have to define any variants, as these are defined in the interface.
 * 
 * @author bfvdonge
 * 
 */

public interface ImportPlugin {

	/**
	 * Returns the File object this plugin was instantiated with.
	 * 
	 * @return
	 */
	public File getFile();

	@PluginVariant(requiredParameterLabels = { 0 })
	public Object importFile(PluginContext context, String filename) throws Exception;

	@PluginVariant(requiredParameterLabels = { 0 })
	public Object importFile(PluginContext context, URI uri) throws Exception;

	@PluginVariant(requiredParameterLabels = { 0 })
	public Object importFile(PluginContext context, URL url) throws Exception;

	@PluginVariant(requiredParameterLabels = { 0 })
	public Object importFile(PluginContext context, File f) throws Exception;

}"
AlphanumComparator.java,framework,"package org.processmining.framework.util.collection;

/*
 * The Alphanum Algorithm is an improved sorting algorithm for strings
 * containing numbers. Instead of sorting numbers in ASCII order like a standard
 * sort, this algorithm sorts numbers in numeric order.
 * 
 * The Alphanum Algorithm is discussed at http://www.DaveKoelle.com
 * 
 * 
 * This library is free software; you can redistribute it and/or modify it under
 * the terms of the GNU Lesser General Public License as published by the Free
 * Software Foundation; either version 2.1 of the License, or any later version.
 * 
 * This library is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
 * details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
 */

import java.util.Comparator;

/**
 * This is an updated version with enhancements made by Daniel Migowski, Andre
 * Bogus, and David Koelle
 * 
 * To convert to use Templates (Java 1.5+): - Change ""implements Comparator"" to
 * ""implements Comparator<String>"" - Change ""compare(Object o1, Object o2)"" to
 * ""compare(String s1, String s2)"" - Remove the type checking and casting in
 * compare().
 * 
 * To use this class: Use the static ""sort"" method from the
 * java.util.Collections class: Collections.sort(your list, new
 * AlphanumComparator());
 */
public class AlphanumComparator implements Comparator<String> {
	private final boolean isDigit(char ch) {
		return ch >= 48 && ch <= 57;
	}

	/**
	 * Length of string is passed in for improved efficiency (only need to
	 * calculate it once)
	 **/
	private final String getChunk(String s, int slength, int marker) {
		StringBuilder chunk = new StringBuilder();
		char c = s.charAt(marker);
		chunk.append(c);
		marker++;
		if (isDigit(c)) {
			while (marker < slength) {
				c = s.charAt(marker);
				if (!isDigit(c))
					break;
				chunk.append(c);
				marker++;
			}
		} else {
			while (marker < slength) {
				c = s.charAt(marker);
				if (isDigit(c))
					break;
				chunk.append(c);
				marker++;
			}
		}
		return chunk.toString();
	}

	public int compare(String s1, String s2) {
		int thisMarker = 0;
		int thatMarker = 0;
		int s1Length = s1.length();
		int s2Length = s2.length();

		while (thisMarker < s1Length && thatMarker < s2Length) {
			String thisChunk = getChunk(s1, s1Length, thisMarker);
			thisMarker += thisChunk.length();

			String thatChunk = getChunk(s2, s2Length, thatMarker);
			thatMarker += thatChunk.length();

			// If both chunks contain numeric characters, sort them numerically
			int result = 0;
			if (isDigit(thisChunk.charAt(0)) && isDigit(thatChunk.charAt(0))) {
				// Simple chunk comparison by length.
				int thisChunkLength = thisChunk.length();
				result = thisChunkLength - thatChunk.length();
				// If equal, the first different number counts
				if (result == 0) {
					for (int i = 0; i < thisChunkLength; i++) {
						result = thisChunk.charAt(i) - thatChunk.charAt(i);
						if (result != 0) {
							return result;
						}
					}
				}
			} else {
				result = thisChunk.compareTo(thatChunk);
			}

			if (result != 0)
				return result;
		}

		return s1Length - s2Length;
	}
}
"
AuthoredType.java,framework,"package org.processmining.framework.annotations;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Retention(RetentionPolicy.RUNTIME)
@Target( { ElementType.TYPE })
public @interface AuthoredType {

	public final static String TUE = ""Eindhoven University of Technology"";

	/**
	 * Specifies the user-readable type for this class
	 * 
	 * @return
	 */
	String typeName();

	/**
	 * Specifies the affiliation of the author
	 * 
	 * @return
	 */
	String affiliation();

	/**
	 * specifies the e-mail address of the author
	 * 
	 * @return
	 */
	String email();

	/**
	 * Specifies the name of the author
	 * 
	 * @return
	 */
	String author();

	/**
	 * Specifies the website of the author (note that this should be URL style,
	 * i.e. with http://)
	 * 
	 * @return
	 */
	String website() default ""http://www.processmining.org"";

}
"
Icon.java,framework,"package org.processmining.framework.annotations;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Retention(RetentionPolicy.RUNTIME)
@Target( { ElementType.TYPE })
public @interface Icon {

	/**
	 * Specifies the relative path to the icon to be loaded if this type has to
	 * be represented by an Icon
	 * 
	 * @return
	 */
	public String icon();
}
"
TestMethod.java,framework,"package org.processmining.framework.annotations;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * By adding this annotation to a method, the method is flagged as a test method
 * for ProM. A hudson server should, on each commit, find all methods annotated
 * with this annotation and exectute it.
 * 
 * The method should not require parameters and should be declared static. The
 * return type of the method should be: <code>String</code>.
 * 
 * The string returned by this method is compared to either the string defined
 * in the output field, or with the contents of the file indicated by
 * filename().
 * 
 * If both filename and output are specified, then only output is used and the
 * file is ignored.
 * 
 * @author bfvdonge
 * 
 */
@Retention(RetentionPolicy.RUNTIME)
@Target({ ElementType.METHOD })
public @interface TestMethod {

	String filename() default """";

	String output() default """";
	
	boolean returnSystemOut() default false;

}
"
AddJarsForPackageRunnable.java,framework,"package org.processmining.framework.boot;

import java.io.File;
import java.net.MalformedURLException;
import java.net.URL;
import java.util.ArrayList;
import java.util.List;

import org.processmining.framework.boot.Boot.Level;
import org.processmining.framework.packages.PackageDescriptor;
import org.processmining.framework.plugin.PluginManager;
import org.processmining.framework.util.PathHacker;

/**
 * Threaded implementation of the addJarsForPackage method
 * 
 * @author berti
 *
 */
public class AddJarsForPackageRunnable extends Thread {
	PackageDescriptor pack;
	Level verbose;
	PluginManager plugins;
	
	public AddJarsForPackageRunnable(PackageDescriptor pack, Level verbose, PluginManager plugins) {
		this.pack = pack;
		this.verbose = verbose;
		this.plugins = plugins;
	}
	
	/**
	 * Entry point for thread
	 */
	public void run() {
		if (verbose == Level.ALL) {
			System.out.println(""Scanning package: "" + pack);
		}
		File dir = pack.getLocalPackageDirectory();
		if (!dir.exists() || !dir.isDirectory() || !dir.canRead()) {
			if (verbose == Level.ALL) {
				System.out.println(""  Error: package directory does not exist: "" + dir);
			}
			return;
		}
		// First, recusively iterate subfolders, where no scanning for plugins is necessary
		// this ensures all requires libraries are known when scanning for plugins
		for (File f : dir.listFiles()) {
			// Scan for jars. Only jars in the root of the package will be scanned for
			// plugins and other annotations.
			if (f.isDirectory()) {
				Boot.addJarsFromPackageDirectory(f, verbose, plugins);
				try {
					Boot.addURLToClasspath(f.toURI().toURL());
				} catch (MalformedURLException e) {
				}
			}
		}
		
		// Now scan the jar files in the package root folder.
		for (File f : dir.listFiles()) {
			if (f.getAbsolutePath().endsWith(PluginManager.JAR_EXTENSION)) {
				URL url;
				try {
					url = f.toURI().toURL();
					if (verbose == Level.ALL) {
						System.out.println(""  scanning for plugins: "" + url);
					}
					Boot.addURLToClasspath(url);
					if (f.getAbsolutePath().endsWith(PluginManager.JAR_EXTENSION)) {
						plugins.register(url, pack);
					}
				} catch (MalformedURLException e) {
					e.printStackTrace();
				}
			}
		}
		
		List<Thread> subthreads = new ArrayList<Thread>();
		PathHacker.addLibraryPathFromDirectory(pack.getLocalPackageDirectory());
		try {
			PathHacker.addJar(pack.getLocalPackageDirectory().toURI().toURL());
			for (File f : pack.getLocalPackageDirectory().listFiles()) {
				if (f.isDirectory()) {
					PathHackerRunnable runnable = new PathHackerRunnable(pack, verbose, plugins, f);
					subthreads.add(runnable);
					subthreads.get(subthreads.size()-1).start();
				}
			}
		} catch (MalformedURLException e) {
			assert (false);
		}
				
		for (Thread t : subthreads) {
			try {
				t.join();
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}
	}
}
"
Boot.java,framework,"package org.processmining.framework.boot;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.lang.reflect.Method;
import java.net.HttpURLConnection;
import java.net.MalformedURLException;
import java.net.URL;
import java.net.URLClassLoader;
import java.net.URLConnection;
import java.util.ArrayList;
import java.util.List;
import java.util.Properties;
import java.util.prefs.Preferences;

import org.processmining.framework.packages.PackageDescriptor;
import org.processmining.framework.packages.PackageManager;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.PluginManager;
import org.processmining.framework.plugin.annotations.Bootable;
import org.processmining.framework.plugin.annotations.PluginLevel;
import org.processmining.framework.plugin.annotations.PluginQuality;
import org.processmining.framework.plugin.impl.PluginManagerImpl;
import org.processmining.framework.util.CommandLineArgumentList;
import org.processmining.framework.util.OsUtil;
import org.processmining.framework.util.PathHacker;

public class Boot {

	public static enum Level {
		NONE, ERROR, ALL

	}

	public static String PROM_VERSION;
	public static String RELEASE_PACKAGE;
	public static String LIB_FOLDER;
	public static String IMAGES_FOLDER;
	public static String PROM_USER_FOLDER;
	public static String MACRO_FOLDER;
	public static String PACKAGE_FOLDER;
	public static String WORKSPACE_FOLDER;
	public static PluginQuality PLUGIN_QUALITY_THRESHOLD;
	public static PluginLevel PLUGIN_LEVEL_THRESHOLD;
	public static Level VERBOSE;
	public static URL DEFAULT_REPOSITORY;
	public static int OPENXES_SHADOW_SIZE;
	public static int CONNECT_TIMEOUT;
	public static int READ_TIMEOUT;

	public static boolean HIDE_OLD_PACKAGES;
	public static boolean CHECK_PACKAGES;

	public static String AUTO_UPDATE;

	public final static String LAST_RELEASE_AUTOINSTALLED_KEY = ""last_release_autoinstalled"";
	public static final String LAST_RELEASE_PACKAGE_KEY = ""last_release_package_installed"";
	public final static String TRACKING_BY_GA_ALLOWED = ""tracking_by_GA_allowed"";

	/**
	 * Versions of ProM.Lite should have a PROM_VERSION in the ini file that
	 * identifies the specific version. This should be prefixed by the
	 * LITE_PREFIX
	 */
	public static final String LITE_PREFIX = "".Lite"";

	static {

		/*
		 * Preset defaults, just in case something fails down th eroad.
		 */
		PROM_VERSION = """";
		RELEASE_PACKAGE = ""RunnerUpPackages"";
		VERBOSE = Level.NONE;
		LIB_FOLDER = ""lib"";
		IMAGES_FOLDER = ""images"";
		MACRO_FOLDER = ""macros"";
		try {
			DEFAULT_REPOSITORY = new URL(""http://www.promtools.org/prom6/packages/packages.xml"");
		} catch (MalformedURLException e1) {
			e1.printStackTrace();
		}
		PROM_USER_FOLDER = System.getProperty(""user.home"", """") + File.separator + "".ProM"";
		PACKAGE_FOLDER = PROM_USER_FOLDER + File.separator + ""packages"";
		WORKSPACE_FOLDER = PROM_USER_FOLDER + File.separator + ""workspace"";
		HIDE_OLD_PACKAGES = false;
		CHECK_PACKAGES = false;
		PLUGIN_QUALITY_THRESHOLD = PluginQuality.VeryPoor;
		PLUGIN_LEVEL_THRESHOLD = PluginLevel.Local;
		CONNECT_TIMEOUT = 100;
		READ_TIMEOUT = 1000;

		Properties ini = new Properties();
		FileInputStream is;
		try {
			is = new FileInputStream(""ProM.ini"");

			try {
				ini.load(is);
				is.close();

				if (!ini.containsKey(""PROM_VERSION"") || !ini.containsKey(""RELEASE_PACKAGE"")) {
					throw new RuntimeException(""Error while reading ProM.ini file, missing required""
							+ "" keys PROM_VERSION and or RELEASE_PACKAGE . Exiting ProM."");
				}

				PROM_VERSION = ini.getProperty(""PROM_VERSION"");
				if (!PROM_VERSION.contains(""."")) {
					PROM_VERSION = """";
				}

				RELEASE_PACKAGE = ini.getProperty(""RELEASE_PACKAGE"");

				//		OPENXES_SHADOW_SIZE = Integer.parseInt(ini.getProperty(""OPENXES_SHADOW_SIZE"", ""4""));
				//		NikeFS2FileAccessMonitor.instance(OPENXES_SHADOW_SIZE);

				CONNECT_TIMEOUT = Integer.parseInt(ini.getProperty(""CONNECT_TIMEOUT"", ""100""));
				READ_TIMEOUT = Integer.parseInt(ini.getProperty(""READ_TIMEOUT"", ""1000""));

				try {
					VERBOSE = Level.valueOf(ini.getProperty(""VERBOSE"", Level.ALL.name()));
				} catch (IllegalArgumentException e) {
					if (e.getMessage().toLowerCase().endsWith("".true"")) {
						VERBOSE = Level.ALL;
					} else if (e.getMessage().toLowerCase().endsWith("".false"")) {
						VERBOSE = Level.NONE;
					} else {
						throw e;
					}
				}

				LIB_FOLDER = ini.getProperty(""LIB_FOLDER"", ""lib"").replace(""/"", File.separator);
				PathHacker.addLibraryPathFromDirectory(new File(""."" + File.separator + LIB_FOLDER));

				IMAGES_FOLDER = LIB_FOLDER + File.separator
						+ ini.getProperty(""IMAGES_FOLDER"", ""images"").replace(""/"", File.separator);
				PathHacker.addLibraryPathFromDirectory(new File(""."" + File.separator + IMAGES_FOLDER));

				MACRO_FOLDER = LIB_FOLDER + File.separator
						+ ini.getProperty(""MACRO_FOLDER"", ""macros"").replace(""/"", File.separator);
				PathHacker.addLibraryPathFromDirectory(new File(""."" + File.separator + MACRO_FOLDER));

				String defaultRepository = ""http://www.promtools.org/prom6/packages""
						+ PROM_VERSION.replaceAll(""\\."", """") + ""/packages.xml"";
				String repository = getBestRepository(ini.getProperty(""PACKAGE_URL"", defaultRepository).split("" ""),
						defaultRepository);

				try {
					DEFAULT_REPOSITORY = new URL(repository);
				} catch (MalformedURLException e) {
					try {
						DEFAULT_REPOSITORY = new URL(defaultRepository);
					} catch (MalformedURLException e1) {
						assert (false);
					}
				}

				String prom_user_folder = ini.getProperty(""PROM_USER_FOLDER"", """").replace(""/"", File.separator);
				if (prom_user_folder.equals("""")) {
					PROM_USER_FOLDER = System.getProperty(""user.home"", """") + File.separator + "".ProM""
							+ PROM_VERSION.replaceAll(""\\."", """");
				} else {
					PROM_USER_FOLDER = prom_user_folder;
				}

				PACKAGE_FOLDER = PROM_USER_FOLDER + File.separator
						+ ini.getProperty(""PACKAGE_FOLDER"", ""packages"").replace(""/"", File.separator);

				WORKSPACE_FOLDER = PROM_USER_FOLDER + File.separator
						+ ini.getProperty(""WORKSPACE_FOLDER"", ""workspace"").replace(""/"", File.separator);

				HIDE_OLD_PACKAGES = new Boolean(ini.getProperty(""HIDE_OLD_PACKAGES"", ""false""));
				CHECK_PACKAGES = new Boolean(ini.getProperty(""CHECK_PACKAGES"", ""false""));
				AUTO_UPDATE = new String(ini.getProperty(""AUTO_UPDATE"", ""never""));

				PLUGIN_QUALITY_THRESHOLD = PluginQuality.VeryPoor;
				String threshold = ini.getProperty(""PLUGIN_QUALITY_THRESHOLD"", PLUGIN_QUALITY_THRESHOLD.getName());
				for (PluginQuality quality : PluginQuality.values()) {
					if (quality.getName().equals(threshold)) {
						PLUGIN_QUALITY_THRESHOLD = quality;
						break;
					}
				}

				PLUGIN_LEVEL_THRESHOLD = PluginLevel.Local;
				threshold = ini.getProperty(""PLUGIN_LEVEL_THRESHOLD"", PLUGIN_LEVEL_THRESHOLD.getName());
				for (PluginLevel level : PluginLevel.values()) {
					if (level.getName().equals(threshold)) {
						PLUGIN_LEVEL_THRESHOLD = level;
						break;
					}
				}

				if (VERBOSE == Level.ALL) {
					System.out.println(""Plug-in level threshold set to "" + PLUGIN_LEVEL_THRESHOLD.getName());
					System.out.println(""Plug-in quality threshold set to "" + PLUGIN_QUALITY_THRESHOLD.getName());
					System.out.println(""Ini file processed"");
				}
			} catch (IOException e) {
				//					throw new RuntimeException(""Error while reading ProM.ini file. Exiting ProM."", e);
				if (VERBOSE != Level.NONE) {
					System.err.println(""Error while reading ProM.ini file.\n"" + e + ""\nReverting to default settings."");
				}
			}
		} catch (FileNotFoundException e) {
			//				throw new RuntimeException(""ProM.ini file not found. Exiting ProM."", e);
			if (VERBOSE != Level.NONE) {
				System.err.println(""ProM.ini file not found.\n"" + e + ""\nReverting to default settings."");
			}
		}

	}

	/*
	 * Gets the best repository from a list of repositories, where best means
	 * the one that responds fastest. To measure the latter, we read only the
	 * first character from the stream, and measure the wall-clock time this
	 * took. If no repository can be returned, the default repository is
	 * returned.
	 */
	public static String getBestRepository(String[] repositories, String defaultRepository) {
		/*
		 * The best repository so far.
		 */
		String bestRepository = defaultRepository;
		/*
		 * If no repositories are provided, use only the default repository.
		 */
		if (repositories.length == 0) {
			repositories = new String[] { defaultRepository };
		}
		/*
		 * If there is only a single repository, that one has to be the best
		 * one.
		 */
		if (repositories.length == 1) {
			bestRepository = repositories[0];
		} else {
			/*
			 * Multiple repositories. Try to get them to respond, and use the
			 * one that responds the fastest.
			 */
			bestRepository = null;
			long bestTime = 0;
			/*
			 * Have a 'dry run' with i = -1, which actually connects to the
			 * first repository.
			 */
			for (int i = -1; i < repositories.length; i++) {
				try {
					/*
					 * Setup a connection...
					 */
					URL url = new URL(repositories[i < 0 ? 0 : i]);
					URLConnection conn = url.openConnection();
					if (conn instanceof HttpURLConnection) {
						HttpURLConnection httpCon = (HttpURLConnection) conn;
						if (Boot.CONNECT_TIMEOUT > 0) {
							httpCon.setConnectTimeout(Boot.CONNECT_TIMEOUT);
						}
						if (Boot.READ_TIMEOUT > 0) {
							httpCon.setReadTimeout(Boot.READ_TIMEOUT);
						}
					}
					/*
					 * ...and a stream.
					 */
					InputStream stream = conn.getInputStream();
					/*
					 * Try to read some first characters on the stream.
					 */
					long time = -System.nanoTime();
					for (int j = 0; j < 10; j++) {
						stream.read();
					}
					time += System.nanoTime();
					/*
					 * Do not weigh this time too much, to take setup times into account.
					 */
					time /= 1000;
					/*
					 * Try to read some additional characters on the stream.
					 */
					time -= System.nanoTime();
					for (int j = 0; j < 1000; j++) {
						stream.read();
					}
					time += System.nanoTime();
					/*
					 * Stream can now be closed.
					 */
					stream.close();
					/*
					 * If not a dry run, see whether this repository is better.
					 */
					if (i >= 0) {
						System.out.println(""[Boot] Repository "" + repositories[i] + "" took "" + time + "" nanoseconds."");
						/*
						 * Update the best repository and the best time, if
						 * needed.
						 */
						if (bestRepository == null || time < bestTime) {
							bestRepository = repositories[i];
							bestTime = time;
							System.out.println(""[Boot] New best repository "" + repositories[i]);
						}
					}
				} catch (MalformedURLException e) {
					System.err.println(""[Boot] URL error with repository "" + repositories[i < 0 ? 0 : i] + "": "" + e.getMessage());
				} catch (IOException e) {
					System.err.println(""[Boot] I/O error with repository "" + repositories[i < 0 ? 0 : 1] + "": "" + e.getMessage());
				}
			}
			/*
			 * Fail safe: If no repository was found, use the default one.
			 */
			if (bestRepository == null) {
				bestRepository = defaultRepository;
			}
		}
		/*
		 * Return the best repository found.
		 */
		return bestRepository;
	}

	public static boolean isLatestReleaseInstalled() {
		return Preferences.userNodeForPackage(Boot.class).get(LAST_RELEASE_AUTOINSTALLED_KEY, """").equals(PROM_VERSION)
				&& Preferences.userNodeForPackage(Boot.class).get(LAST_RELEASE_PACKAGE_KEY, """").equals(RELEASE_PACKAGE);
	}

	public static void setReleaseInstalled(String version, String releasePackage) {
		Preferences.userNodeForPackage(Boot.class).put(LAST_RELEASE_AUTOINSTALLED_KEY, version);
		Preferences.userNodeForPackage(Boot.class).put(LAST_RELEASE_PACKAGE_KEY, releasePackage);
	}

	public static void setLatestReleaseInstalled() {
		setReleaseInstalled(PROM_VERSION, RELEASE_PACKAGE);
	}

	public static boolean isTrackingByGAAllowed() {
		return Preferences.userNodeForPackage(Boot.class).get(TRACKING_BY_GA_ALLOWED, ""false"").equals(""true"");
	}

	public static void boot(Class<?> bootClass, Class<? extends PluginContext> pluginContextClass, String... args)
			throws Exception {
		long start = System.currentTimeMillis();
		// First instantiate the package manager
		PackageManager packages = PackageManager.getInstance();
		// Then the plugin manager, as it listens to the package manager
		PluginManagerImpl.initialize(pluginContextClass);
		PluginManager plugins = PluginManagerImpl.getInstance();

		OsUtil.setWorkingDirectoryAtStartup();

		long startPackages = System.currentTimeMillis();
		packages.initialize(VERBOSE);
		if (VERBOSE == Level.ALL) {
			System.out.println("">>> Scanning for packages took "" + (System.currentTimeMillis() - startPackages)
					/ 1000.0 + "" seconds"");
		}

		long startPlugins = System.currentTimeMillis();
		URLClassLoader sysloader = (URLClassLoader) ClassLoader.getSystemClassLoader();
		URL[] defaultURLs = sysloader.getURLs();

		//	new URLClassLoader(new URL[] { packages.getPackagesDirectory().toURL() });

		if (VERBOSE == Level.ALL) {
			for (URL def : defaultURLs) {
				System.out.println(""known jar file: "" + def);
			}
			System.out.println(""Loading plugins from packages."");
		}

		/**
		 * (berti) Made ""addJarsForPackage"" method as thread to use parallelism
		 */
		List<Thread> loadingThreadsPackage = new ArrayList<Thread>();
		for (PackageDescriptor pack : packages.getEnabledPackages()) {
			if (VERBOSE == Level.ALL) {
				System.out.println(""Processing Package: "" + pack.getName());
			}
			//addJarsForPackage(pack, VERBOSE, plugins);
			AddJarsForPackageRunnable addJarsForPackage = new AddJarsForPackageRunnable(pack, VERBOSE, plugins);
			loadingThreadsPackage.add(addJarsForPackage);
			loadingThreadsPackage.get(loadingThreadsPackage.size() - 1).start();
		}

		// wait for each thread to finish the job before continuing
		for (Thread t : loadingThreadsPackage) {
			t.join();
		}

		if (VERBOSE == Level.ALL) {
			System.out.println(""Loading from: classpath"");
		}

		File f = new File(""."" + File.separator + LIB_FOLDER);
		String libPath = f.getCanonicalPath();
		addURLToClasspath(f.toURI().toURL());
		for (URL url : defaultURLs) {
			if (VERBOSE == Level.ALL) {
				System.out.println(""Processing url: "" + url);
			}
			if (!(new File(url.toURI()).getCanonicalPath().startsWith(libPath))) {
				if (VERBOSE == Level.ALL) {
					System.out.println(""Scanning for plugins: "" + url);
				}
				plugins.register(url, null);
			} else {
				if (VERBOSE == Level.ALL) {
					System.out.println(""Skipping: "" + url.getFile() + "" while scanning for plugins."");
				}
			}
		}

		//		for (URL url : sysloader.getURLs()) {
		//			System.err.println(""URL = "" + url);
		//		}

		if (VERBOSE == Level.ALL) {
			System.out.println("">>> Scanning for plugins took "" + (System.currentTimeMillis() - startPlugins) / 1000.0
					+ "" seconds"");
		}

		boot(bootClass, args);

		if (VERBOSE == Level.ALL) {
			System.out.println("">>> Total startup took "" + (System.currentTimeMillis() - start) / 1000.0 + "" seconds"");
		}
	}

	/*
	 * (non-Javadoc) * @see
	 * org.processmining.framework.plugin.PluginManager#boot(java.lang.Class,
	 * java.lang.String[])
	 */
	public static Object boot(Class<?> bootClass, String... args) throws Exception {
		Method bootMethod = null;

		for (Method method : bootClass.getMethods()) {
			if (method.isAnnotationPresent(Bootable.class)) {
				if (bootMethod == null) {
					bootMethod = method;
				} else {
					throw new IllegalArgumentException(""Cannot have more than one @Bootable method in a class"");
				}
			}
		}
		if (bootMethod == null) {
			throw new IllegalArgumentException(""No @Bootable annotation found: "" + bootClass.getName());
		}

		CommandLineArgumentList argList = new CommandLineArgumentList();
		for (String arg : args) {
			argList.add(arg);
		}

		return bootMethod.invoke(bootMethod.getDeclaringClass().newInstance(), argList);
	}

	public static void addJarsForPackage(PackageDescriptor pack, Boot.Level verbose, PluginManager plugins) {
		if (verbose == Level.ALL) {
			System.out.println(""Scanning package: "" + pack);
		}
		File dir = pack.getLocalPackageDirectory();
		if (!dir.exists() || !dir.isDirectory() || !dir.canRead()) {
			if (verbose == Level.ALL) {
				System.out.println(""  Error: package directory does not exist: "" + dir);
			}
			return;
		}
		// First, recusively iterate subfolders, where no scanning for plugins is necessary
		// this ensures all requires libraries are known when scanning for plugins
		for (File f : dir.listFiles()) {
			// Scan for jars. Only jars in the root of the package will be scanned for
			// plugins and other annotations.
			if (f.isDirectory()) {
				addJarsFromPackageDirectory(f, verbose, plugins);
				try {
					addURLToClasspath(f.toURI().toURL());
				} catch (MalformedURLException e) {
				}
			}
		}
		// Now scan the jar files in the package root folder.
		for (File f : dir.listFiles()) {
			if (f.getAbsolutePath().endsWith(PluginManager.JAR_EXTENSION)) {
				URL url;
				try {
					url = f.toURI().toURL();
					if (verbose == Level.ALL) {
						System.out.println(""  scanning for plugins: "" + url);
					}
					addURLToClasspath(url);
					if (f.getAbsolutePath().endsWith(PluginManager.JAR_EXTENSION)) {
						plugins.register(url, pack);
					}
				} catch (MalformedURLException e) {
					e.printStackTrace();
				}
			}

		}
		PathHacker.addLibraryPathFromDirectory(pack.getLocalPackageDirectory());
		try {
			PathHacker.addJar(pack.getLocalPackageDirectory().toURI().toURL());
			for (File f : pack.getLocalPackageDirectory().listFiles()) {
				if (f.isDirectory()) {
					PathHacker.addJar(f.toURI().toURL());
				}
			}
		} catch (MalformedURLException e) {
			assert (false);
		}

	}

	/**
	 * Scan for jars and add them to the classpath.
	 * 
	 * @param dir
	 *            the folder (or jar file) to scan
	 * @param verbose
	 *            true if output required
	 * @param plugins
	 *            the plugin manager
	 * @param scanClasses
	 *            If true, then all classes are scanned for annotations and for
	 *            plugins. This property recusively propagates to sub-folders.
	 */
	static void addJarsFromPackageDirectory(File dir, Boot.Level verbose, PluginManager plugins) {

		for (File f : dir.listFiles()) {
			if (f.isDirectory()) {
				addJarsFromPackageDirectory(f, verbose, plugins);
			}
		}
		for (File f : dir.listFiles()) {
			if (f.getAbsolutePath().endsWith(PluginManager.JAR_EXTENSION)) {
				try {
					URL url = f.toURI().toURL();
					if (verbose == Level.ALL) {
						System.out.println(""  adding to classpath: "" + url);
					}
					addURLToClasspath(url);
				} catch (MalformedURLException e) {
					e.printStackTrace();

				}
			}
		}
	}

	static void addURLToClasspath(URL url) {
		try {
			URLClassLoader sysloader = (URLClassLoader) ClassLoader.getSystemClassLoader();
			Method method = URLClassLoader.class.getDeclaredMethod(""addURL"", new Class<?>[] { URL.class });

			method.setAccessible(true);
			method.invoke(sysloader, new Object[] { url });
		} catch (Throwable t) {
			t.printStackTrace();
		}
	}
}
"
PathHackerRunnable.java,framework,"package org.processmining.framework.boot;

import java.io.File;
import java.net.MalformedURLException;

import org.processmining.framework.boot.Boot.Level;
import org.processmining.framework.packages.PackageDescriptor;
import org.processmining.framework.plugin.PluginManager;
import org.processmining.framework.util.PathHacker;

/**
 * Threaded executions of PathHacker addJar
 * 
 * @author berti
 *
 */
public class PathHackerRunnable extends Thread {
	PackageDescriptor pack;
	Level verbose;
	PluginManager plugins;
	File f;
	
	public PathHackerRunnable(PackageDescriptor pack, Level verbose, PluginManager plugins, File f) {
		this.pack = pack;
		this.verbose = verbose;
		this.plugins = plugins;
		this.f = f;
	}
	
	/**
	 * Entry point for thread
	 */
	public void run() {
		//System.out.println(""pathHacker ""+f.toURI());
		try {
			PathHacker.addJar(f.toURI().toURL());
		} catch (MalformedURLException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
}
"
BreadthFirstExpandCollection.java,framework,"package org.processmining.framework.util.search;

import java.util.Collection;

public class BreadthFirstExpandCollection<N> extends DepthFirstExpandCollection<N> {

	public void add(Collection<? extends N> newElements) {
		stack.addAll(0, newElements);
	}

}
"
ComparablePair.java,framework,"package org.processmining.framework.util.collection;

import org.processmining.framework.util.Pair;

public class ComparablePair<F extends Comparable<? super F>, S extends Comparable<? super S>> extends Pair<F, S>
		implements Comparable<ComparablePair<F, S>> {

	public ComparablePair(F first, S second) {
		super(first, second);
	}

	public <T extends Comparable<? super T>> int compareTo(T x, T y) {
		if (x == null) {
			return y == null ? 0 : -1;
		} else {
			return x.compareTo(y);
		}
	}

	public int compareTo(ComparablePair<F, S> other) {
		if (other == null) {
			return 1;
		}
		int result = compareTo(first, other.first);
		return result == 0 ? compareTo(second, other.second) : result;
	}

}
"
ConnectionDoesntExistMessage.java,framework,"package org.processmining.framework.connections.annotations;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Retention(RetentionPolicy.RUNTIME)
@Target({ ElementType.TYPE })
public @interface ConnectionDoesntExistMessage {

	public String message() default """";
}
"
ConnectionObjectFactory.java,framework,"package org.processmining.framework.connections.annotations;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * Annotation used on plugins to signal that they can construct a Connection on
 * objects.
 * 
 * The type of connection produced is given by the return type of the plugin, of
 * which there should be only 1, which is assignable from Connection.class.
 * 
 * To avoid lifelocks such a plugin should not request any connection on its
 * inputs. If no connection can be made, <code>null</code> should be returned.
 * 
 * @author bfvdonge
 * 
 */
@Retention(RetentionPolicy.RUNTIME)
@Target( { ElementType.METHOD, ElementType.TYPE })
public @interface ConnectionObjectFactory {

}
"
Connection.java,framework,"package org.processmining.framework.connections;

import java.util.Collection;
import java.util.Set;

import org.processmining.framework.annotations.AuthoredType;
import org.processmining.framework.annotations.Icon;
import org.processmining.framework.util.collection.MultiSet;

/**
 * A connection describes a relation between objects. The connection keeps a
 * number of weak references between the objects in the relation. Each object
 * should have a label describing the role of the object in the relation. These
 * roles are unique
 * 
 * Note that for all implementations of Connection, it is essential to consider
 * memory consumption. Connections are kept in the framework for as long as the
 * isRemoved() method returns false, hence this method should return true at the
 * earliest occasion.
 * 
 * All implementations of this class should carry the following annotations:
 * @KeepInProMCache
 * @ConnectionAnnotation
 * @ConnectionDoesntExistMessage(message = ""Message for case that connection Doesn't Exist"")
 * 
 * @author bfvdonge
 * 
 */
@AuthoredType(typeName = ""Connection"", affiliation = AuthoredType.TUE, author = ""B.F. van Dongen"", email = ""b.f.v.dongen@tue.nl"")
@Icon(icon = ""resourcetype_connection_30x35.png"")
public interface Connection {

	/**
	 * Return the label of the connection
	 * 
	 * @return
	 */
	public String getLabel();

	/**
	 * Return the ID of the connection.
	 * 
	 * @return
	 */
	public ConnectionID getID();

	/**
	 * Return true if all objects given as parameter are contained in the
	 * connection. Multiplicities are taken into account, however order is
	 * abstracted from
	 * 
	 * @param objects
	 *            the objects to check for
	 * @return
	 */
	public boolean containsObjects(Object... objects);

	/**
	 * Return true if all objects given as parameter are contained in the
	 * connection. Multiplicities are taken into account, i.e. each object
	 * should occur as often as it is returned by the iterator of the given
	 * collection however order is abstracted from
	 * 
	 * @param objects
	 *            the objects as a collection
	 * @return
	 */
	public boolean containsObjects(Collection<?> objects);

	/**
	 * Return true if one of the objects connected by this connection no longer
	 * exists, i.e. it is collected by the garbage collector.
	 * 
	 * @return
	 */
	public boolean isRemoved();

	/**
	 * Return all objects contained in this connection, without their labels.
	 * 
	 * By contract, this method should always return the same set of objects
	 * after the connections was created, i.e. connections may only be changed
	 * by changing the contents of the objects, but not by changing the
	 * pointers.
	 * 
	 * @return
	 */
	public MultiSet<Object> getObjects();

	/**
	 * Return the roles of all objects in this connection
	 * 
	 * @return
	 */
	public Set<String> getRoles();

	/**
	 * Return the object with the given role in this connection The type of the
	 * returned object is T. However, no checks have to be performed to see if
	 * the cast can be made. It is up to the calling method to ensure this cast
	 * is safe.
	 * 
	 * @param <T>
	 *            The type of object that should be returned.
	 * @param role
	 *            the role the returned object has to have
	 * @return the object attached to this role (not null).
	 */
	public <T> T getObjectWithRole(String role);

	/**
	 * Removes the connection. After calling this method, isRemoved()returns
	 * true;
	 */
	public void remove();

	/**
	 * sets the label of the connection to the new name
	 * 
	 * @param name
	 */
	public void setLabel(String name);

	/**
	 * This method should be called as soon as the connection is changed, for
	 * example if the label changed, or if the contents of one of the connected
	 * objects changes.
	 * 
	 * By calling this method, the connection manager should be notified.
	 */
	public void updated();

	/**
	 * Sets the manager for the connection. This method is called by the
	 * connection manager as soon as this connection is added to that manager. A
	 * connection should keep a reference to the manager only in a transient
	 * field.
	 * 
	 * @param manager
	 */
	void setManager(ConnectionManager manager);

}
"
ConnectionAnnotation.java,framework,"package org.processmining.framework.connections;

import java.lang.annotation.ElementType;
import java.lang.annotation.Inherited;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * This annotation is used by the framework to scan for all implementations if
 * Connection.
 * 
 * @author bfvdonge
 * 
 */
@Retention(RetentionPolicy.RUNTIME)
@Target({ ElementType.TYPE })
@Inherited
public @interface ConnectionAnnotation {

}
"
ConnectionCannotBeObtained.java,framework,"package org.processmining.framework.connections;

import org.processmining.framework.connections.annotations.ConnectionDoesntExistMessage;

/**
 * Exception thrown by the connectionmanager if a requested connection does not
 * exist.
 * 
 * @author bfvdonge
 * 
 */
public class ConnectionCannotBeObtained extends Exception {

	private final Class<? extends Object> connectionType;

	/**
	 * Constructor with message and cause
	 * 
	 * @param reason
	 *            The reason of throwing this exception
	 * @param ex
	 *            the cause of this exception
	 */
	public ConnectionCannotBeObtained(String reason, ConnectionCannotBeObtained ex) {
		this(reason + "" \n "" + ex.getMessage(), ex.connectionType);
	}

	/**
	 * Constructor with reason, connection type and objects. The message is set
	 * to: ""No known connection of type + connectionType + "" between "" +
	 * Arrays.toString(objects) + "" ["" + reason + ""]"";
	 * 
	 * @param reason
	 *            The reason of throwing this exception
	 * @param connectionType
	 *            The requested connection type
	 * @param objects
	 *            the objects on which a connection was requested
	 */
	public ConnectionCannotBeObtained(String reason, Class<?> connectionType, Object... objects) {
		super(""No connection of type "" + connectionType.getSimpleName() + 
//				"" can be obtained for objects: "" + Arrays.toString(objects) + 
				""\n The reason given is: "" + reason + ""\n ""
				+ getDoesntExistMessage(connectionType))
				;
		this.connectionType = connectionType;
	}

	/**
	 * 
	 */
	private static final long serialVersionUID = 224232280740635702L;

	private static String getDoesntExistMessage(Class<?> connectionType) {
		if (connectionType == null) {
			return """";
		}
		String s = """";
		ConnectionDoesntExistMessage message = connectionType.getAnnotation(ConnectionDoesntExistMessage.class);
		if (message != null) {
			s = message.message();
		}
		if ((connectionType != Connection.class) && (connectionType.getSuperclass() != null)
				&& (Connection.class.isAssignableFrom(connectionType.getSuperclass()))) {
			s = getDoesntExistMessage(connectionType.getSuperclass()) + "" \n "" + s;
		}
		for (Class<?> sup : connectionType.getInterfaces()) {
			if (Connection.class.isAssignableFrom(sup)) {
				s = getDoesntExistMessage(connectionType.getSuperclass()) + "" \n "" + s;
			}
		}
		return s;

	}

}
"
ConnectionID.java,framework,"package org.processmining.framework.connections;

import org.processmining.framework.ProMID;

/**
 * ID of a connection. Need not to be persistent over serialization.
 * 
 * @author bfvdonge
 * 
 */
public interface ConnectionID extends ProMID {


}
"
ConnectionManager.java,framework,"package org.processmining.framework.connections;

import java.util.Collection;

import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.events.ConnectionObjectListener;

public interface ConnectionManager {

	/**
	 * Returns a collection of connections between the objects specified, such
	 * that the type of the connection is assignable from the given
	 * connectionType (unless the parameter equals null).
	 * 
	 * If no connections satisfying these criteria exist and the required type
	 * is specified and no required name is specified, then the global context
	 * searches for all available plugins with a ConnectionObjectFactory
	 * annotation, which can be executed in a child of the given PluginContext
	 * and accept the given objects as input
	 * 
	 * If such plugins exist, the first of these plugins is selected and invoked
	 * on the given objects. The result is obtained from the plugin and a new
	 * connection is registered of the right type. This connection is then
	 * returned.
	 * 
	 * @param <T>
	 *            the type of the requested connection.
	 * @param connectionType
	 *            The type of the object requested. This type can be null, in
	 *            which case all types are considered.
	 * @param context
	 *            The context which requests the connection. If a plugin is
	 *            invoked to create a connection, a child context of this
	 *            context is instantiated
	 * @param objects
	 *            the objects which should be connected by the requested
	 *            connection. There might be more objects involved in the
	 *            connection
	 * @return A collection of connections of the requested type T. If no
	 *         connection exists, an exception is thrown, hence the collection
	 *         is never empty.
	 * @throws ConnectionCannotBeObtained
	 *             if the requested connection does not exist and cannot be
	 *             produced in the given context.
	 */
	<T extends Connection> Collection<T> getConnections(Class<T> connectionType, PluginContext context,
			Object... objects) throws ConnectionCannotBeObtained;

	/**
	 * Returns a connection between the objects specified, such that the type of
	 * the connection is assignable from the given connectionType (unless the
	 * parameter equals null).
	 * 
	 * If no connections satisfying these criteria exist and the required type
	 * is specified and no required name is specified, then the global context
	 * searches for all available plugins with a ConnectionObjectFactory
	 * annotation, which can be executed in a child of the given PluginContext
	 * and accept the given objects as input
	 * 
	 * If such plugins exist, the first of these plugins is selected and invoked
	 * on the given objects. The result is obtained from the plugin and a new
	 * connection is registered of the right type. This connection is then
	 * returned.
	 * 
	 * @param <T>
	 *            the type of the requested connection.
	 * @param connectionType
	 *            The type of the object requested. This type can be null, in
	 *            which case all types are considered.
	 * @param context
	 *            The context which requests the connection. If a plugin is
	 *            invoked to create a connection, a child context of this
	 *            context is instantiated
	 * @param objects
	 *            the objects which should be connected by the requested
	 *            connection. There might be more objects involved in the
	 *            connection
	 * @return A connection of the requested type T. If no connection exists, an
	 *         exception is thrown, hence null is never returned.
	 * @throws ConnectionCannotBeObtained
	 *             if the requested connection does not exist and cannot be
	 *             produced in the given context.
	 */
	<T extends Connection> T getFirstConnection(Class<T> connectionType, PluginContext context, Object... objects)
			throws ConnectionCannotBeObtained;

	/**
	 * Returns the connection with the given ID.
	 * 
	 * @param id
	 *            the connection ID
	 * @return the connection with the given ID
	 */
	Connection getConnection(ConnectionID id) throws ConnectionCannotBeObtained;

	/**
	 * Returns the list of registered connectionObject listeners
	 * 
	 * @return the list of registered connectionObject listeners
	 */
	ConnectionObjectListener.ListenerList getConnectionListeners();

	/**
	 * Returns a collection of connection IDs registered to this global context.
	 * 
	 * @return the ids of the registered connections
	 */
	Collection<ConnectionID> getConnectionIDs();

	/**
	 * Adds the given connection to the framework.
	 * 
	 * @param connection
	 *            The connection to be registered
	 * @return the given parameter connection
	 */
	<T extends Connection> T addConnection(T connection);

	/**
	 * Returns whether connections are enabled. If not, then connecitons will not be added.
	 * @return whether connections are enabled
	 */
	boolean isEnabled();

	/**
	 * Sets whether connections are enabled.
	 * @param isEnabled whether connections should be enabled
	 */
	void setEnabled(boolean isEnabled);

	void clear();
}
"
DynamicConnection.java,framework,"package org.processmining.framework.connections;

/**
 * Tagger interface to indicate that a connection will change after
 * instantiation. Since the actual objects involved in the connection are not
 * allowed to change, these changes should be limited to the contents of the
 * connection itself.
 * 
 * The main use for this interface is in serialization, where DynamicConnections
 * are only serialized when ProM is closed.
 * 
 * @author bfvdonge
 * 
 */
public interface DynamicConnection {

}
"
AbstractConnection.java,framework,"package org.processmining.framework.connections.impl;

import java.lang.ref.WeakReference;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Objects;
import java.util.Set;

import org.processmining.framework.connections.Connection;
import org.processmining.framework.connections.ConnectionAnnotation;
import org.processmining.framework.connections.ConnectionID;
import org.processmining.framework.connections.ConnectionManager;
import org.processmining.framework.connections.annotations.ConnectionDoesntExistMessage;
import org.processmining.framework.plugin.annotations.KeepInProMCache;
import org.processmining.framework.util.collection.HashMultiSet;
import org.processmining.framework.util.collection.MultiSet;

/**
 * Note that for all implementations of Connection, it is essential to consider
 * memory consumption. Connections are kept in the framework for as long as the
 * isRemoved() method returns false, hence this method should return true at the
 * earliest occasion.
 * 
 * The AbstractConnection keeps weak references to the objects added through the
 * put methods. As soon as one of these objects is collected by the garbage
 * collector, then this connection becomes removed. Therefore, it is essential
 * that subclasses of the AbstractConnection do not keep pointers to these
 * objects, or at least only keep weak references.
 * 
 * This class is annotated with @ConnectionAnnotation. Therefore, none of the
 * implementing classes have to do so explicitly.
 * 
 * @author bfvdonge
 * 
 */
@KeepInProMCache
@ConnectionAnnotation
@ConnectionDoesntExistMessage(message = ""Connection Doesn't Exist"")
public abstract class AbstractConnection implements Connection {

	private final Map<String, WeakReference<?>> mapping;
	private static final long serialVersionUID = -9049359040527952685L;

	private String label;

	private final ConnectionID id;
	protected transient ConnectionManager manager = null;

	protected AbstractConnection(String label) {
		if (label == null) {
			throw new NullPointerException(""Connection label should not be NULL"");
		}
		this.label = label;
		id = new ConnectionIDImpl();
		mapping = new HashMap<String, WeakReference<?>>();
	}

	public void setManager(ConnectionManager manager) {
		this.manager = manager;
	}

	public String getLabel() {
		return label;
	}

	public boolean containsObjects(Object... objects) {
		return containsObjects(Arrays.asList(objects));
	}

	public boolean containsObjects(Collection<?> objects) {
		Collection<WeakReference<?>> references = new ArrayList<WeakReference<?>>(mapping.values());

		for (Object o : objects) {
			boolean found = false;
			Iterator<WeakReference<?>> it = references.iterator();
			while (!found && it.hasNext()) {
				Object referenced = it.next().get();
				if (o.getClass().isArray() && referenced.getClass().isArray()) {
					// We are dealing with an array type
					if (Arrays.equals((Object[]) o, (Object[]) referenced)) {
						// Found a match for this object.
						found = true;
					}
				} else {
					if (referenced.equals(o)) {
						// Found a match for this object.
						found = true;
					}
				}
				if (found) {
					it.remove();
				}
			}
			if (!found) {
				return false;
			}
		}
		return true;
	}

	public boolean isRemoved() {
//		System.gc(); // By doing this, object are removed earlier from the workspace.
		for (Map.Entry<String, WeakReference<?>> t : mapping.entrySet()) {
			Object o = t.getValue().get();
//			System.out.println(""[AbstractionConnection] isRemoved "" + this.getClass().getName() + ""@"" + t.getKey() + "": "" + o);			
			if (o == null) {
				return true;
			}
		}
		return false;
	}

	public String toString() {
		return ""Connection labelled "" + label + "", connecting "" + super.toString();
	}

	@Override
	public int hashCode() {
		return Objects.hashCode(id);
	}

	public MultiSet<Object> getObjects() {
		MultiSet<Object> result = new HashMultiSet<Object>();
		for (Map.Entry<String, WeakReference<?>> t : mapping.entrySet()) {
			Object o = t.getValue().get();
			if (o != null) {
				result.add(o);
			} else {
				return new HashMultiSet<Object>();
			}
		}
		return result;
	}

	@Override
	public boolean equals(Object o) {
		if (this == o) {
			return true;
		}
		if (o == null) {
			return false;
		}
		if (!(o instanceof AbstractConnection)) {
			return false;
		}
		AbstractConnection a = (AbstractConnection) o;
		if (id == null) {
			if (a.id != null) {
				return false;
			}
		} else if (!id.equals(a.id)) {
			return false;
		}
		return true;
	}

	public ConnectionID getID() {
		return id;
	}

	@SuppressWarnings(""unchecked"")
	public <T> T getObjectWithRole(String role) {
		assert (get(role) != null);
		return (T) get(role);
	}

	public Set<String> getRoles() {
		return mapping.keySet();
	}

	protected <T> WeakReference<T> put(String role, T o) {
		WeakReference<T> ref = new WeakReference<T>(o);
		mapping.put(role, ref);
		return ref;
	}

	protected void remove(String role) {
		mapping.remove(role);
	}

	protected Object get(String role) {
		return mapping.get(role).get();
	}

	protected Map<String, WeakReference<?>> getMapping() {
		return mapping;
	}

	/**
	 * Removes the connection. After calling this method, isRemoved()returns
	 * true;
	 */
	public void remove() {
		for (Map.Entry<String, WeakReference<?>> t : mapping.entrySet()) {
			t.getValue().clear();
		}
	}

	/**
	 * sets the label of the connection to the new name
	 * 
	 * @param name
	 */
	public void setLabel(String name) {
		if (name == null) {
			throw new NullPointerException(""Connection label should not be NULL"");
		}
		boolean changed = name.equals(label);
		this.label = name;
		if (changed) {
			updated();
		}
	}

	public void updated() {
		if (manager != null) {
			manager.getConnectionListeners().fireConnectionUpdated(id);
		}
	}

	private Object readResolve() {
		manager = null;
		return this;
	}
}
"
AbstractStrongReferencingConnection.java,framework,"package org.processmining.framework.connections.impl;

import java.lang.ref.WeakReference;
import java.util.Collection;
import java.util.HashSet;
import java.util.Map;

public abstract class AbstractStrongReferencingConnection extends AbstractConnection {

	// Keep a strong reference to some objects, as these
	// would otherwise fault the connection.
	// When checking for removal, these objects are ignored, i.e. the connection
	// is considered to be removed if any of the weak references has been nullified.
	private final Collection<Object> objectReferences = new HashSet<Object>();

	public AbstractStrongReferencingConnection(String label) {
		super(label);
	}

	protected <T> WeakReference<T> putStrong(String role, T o) {
		objectReferences.add(o);
		return super.put(role, o);
	}

	@Override
	public boolean isRemoved() {
		for (Map.Entry<String, WeakReference<?>> t : getMapping().entrySet()) {
			Object o = t.getValue().get();
			if (objectReferences.contains(o)) {
				// Skip the objects to which Hard links need to be kept.
				continue;
			}
			if (o == null) {
				return true;
			}
		}
		return false;
	}

}"
ConnectionIDImpl.java,framework,"package org.processmining.framework.connections.impl;

import java.util.UUID;

import org.processmining.framework.ProMID;
import org.processmining.framework.connections.ConnectionID;

public class ConnectionIDImpl implements ConnectionID {

	private final UUID id = UUID.randomUUID();

	public String toString() {
		return id.toString();
	}

	public int hashCode() {
		return id.hashCode();
	}

	public boolean equals(Object o) {
		if (!(o instanceof ConnectionIDImpl)) {
			return false;
		} else {
			return ((ConnectionIDImpl) o).id.equals(id);
		}
	}

	public boolean equalsIgnoreType(Object o) {
		return toString().equals(o.toString());
	}

	public int compareTo(ProMID o) {
		return o.getUUID().compareTo(id);
	}

	public UUID getUUID() {
		return id;
	}

}
"
ConnectionManagerImpl.java,framework,"package org.processmining.framework.connections.impl;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;

import org.processmining.framework.connections.Connection;
import org.processmining.framework.connections.ConnectionCannotBeObtained;
import org.processmining.framework.connections.ConnectionID;
import org.processmining.framework.connections.ConnectionManager;
import org.processmining.framework.connections.annotations.ConnectionObjectFactory;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.PluginExecutionResult;
import org.processmining.framework.plugin.PluginManager;
import org.processmining.framework.plugin.PluginParameterBinding;
import org.processmining.framework.plugin.events.ConnectionObjectListener;
import org.processmining.framework.plugin.events.Logger.MessageLevel;
import org.processmining.framework.util.Pair;

public class ConnectionManagerImpl implements ConnectionManager {

	private final Map<ConnectionID, Connection> connections = new HashMap<ConnectionID, Connection>();
	private final ConnectionObjectListener.ListenerList connectionListeners = new ConnectionObjectListener.ListenerList();
	private final PluginManager pluginManager;
	private boolean isEnabled = true;

	public ConnectionManagerImpl(PluginManager pluginManager) {
		this.pluginManager = pluginManager;

	}

	/**
	 * Returns the list of registered connectionObject listeners
	 * 
	 * @return the list of registered connectionObject listeners
	 */
	public ConnectionObjectListener.ListenerList getConnectionListeners() {
		return connectionListeners;
	}

	public boolean isEnabled() {
		return isEnabled;
	}

	public void setEnabled(boolean isEnabled) {
		this.isEnabled = isEnabled;
	}

	public void clear() {
		connections.clear();
	}
	
	public <T extends Connection> T addConnection(T connection) {
		if (isEnabled) {
			synchronized (connections) {
				connections.put(connection.getID(), connection);
				connection.setManager(this);
				connectionListeners.fireConnectionCreated(connection.getID());
			}
		}
		return connection;
	}

	public Connection getConnection(ConnectionID id) throws ConnectionCannotBeObtained {
		Connection c = connections.get(id);
		synchronized (connections) {
			if (c == null || c.isRemoved()) {
				connections.remove(c);
				connectionListeners.fireConnectionDeleted(id);
				if (c != null)
					throw new ConnectionCannotBeObtained(""Objects were deleted"", c.getClass());
				else
					throw new ConnectionCannotBeObtained(""Objects were deleted"", Object.class);
			}
			return c;
		}
	}

	public <T extends Connection> T getFirstConnection(Class<T> connectionType, PluginContext context,
			Object... objects) throws ConnectionCannotBeObtained {
		return getConnections(true, connectionType, context, objects).iterator().next();
	}

	public <T extends Connection> Collection<T> getConnections(Class<T> connectionType, PluginContext context,
			Object... objects) throws ConnectionCannotBeObtained {
		return getConnections(false, connectionType, context, objects);
	}

	@SuppressWarnings(""unchecked"")
	private <T extends Connection> Collection<T> getConnections(boolean stopAtFirst, Class<T> connectionType,
			PluginContext context, Object... objects) throws ConnectionCannotBeObtained {
		List<T> available = new ArrayList<T>(1);
		//System.gc();
		synchronized (connections) {
			Iterator<Map.Entry<ConnectionID, Connection>> it = connections.entrySet().iterator();
			while (it.hasNext()) {
				Entry<ConnectionID, Connection> entry = it.next();
				Connection c = entry.getValue();
				if (c.isRemoved()) {
					it.remove();
					connectionListeners.fireConnectionDeleted(c.getID());
					continue;
				}
				if (((connectionType == null) || connectionType.isAssignableFrom(c.getClass()))
						&& c.containsObjects(objects)) {
					context.log(""Connection found: "" + c, MessageLevel.DEBUG);
					available.add((T) c);
					if (stopAtFirst) {
						return available;
					}
				}
			}
		}
		if (!available.isEmpty()) {
			return available;
		}
		if ((connectionType == null) || (objects.length <= 1)) {
			throw new ConnectionCannotBeObtained(""No plugin available to create connection"", connectionType, objects);

		}
		Class<?>[] types = new Class<?>[objects.length];
		for (int i = 0; i < objects.length; i++) {
			types[i] = objects[i].getClass();
		}

		Collection<Pair<Integer, PluginParameterBinding>> plugins = pluginManager.find(ConnectionObjectFactory.class,
				connectionType, context.getClass(), true, false, false, types);
		if (plugins.isEmpty()) {
			throw new ConnectionCannotBeObtained(""No plugin available to create connection"", connectionType, objects);
		}
		PluginContext c2 = context.createChildContext(""Creating connection of Type "" + connectionType);
		Pair<Integer, PluginParameterBinding> pair = plugins.iterator().next();
		PluginParameterBinding binding = pair.getSecond();
		try {

			PluginExecutionResult pluginResult = binding.invoke(c2, objects);
			pluginResult.synchronize();
			T connectionObject = pluginResult.<T>getResult(pair.getFirst());

			if (connectionObject == null) {
				throw new ConnectionCannotBeObtained(""Factory plugin returned null."", connectionType, objects);
			}
			available.add(addConnection(connectionObject));
			context.log(""Added connection: "" + connectionObject, MessageLevel.DEBUG);
			return available;
		} catch (Exception e) {
			throw new ConnectionCannotBeObtained(e.getMessage(), connectionType, objects);
		} finally {
			c2.getParentContext().deleteChild(c2);
		}
	}

	public Collection<ConnectionID> getConnectionIDs() {
		return connections.keySet();
	}

}
"
DepthFirstExpandCollection.java,framework,"package org.processmining.framework.util.search;

import java.util.Collection;
import java.util.Stack;

public class DepthFirstExpandCollection<N> implements ExpandCollection<N> {

	protected Stack<N> stack = new Stack<N>();

	public void add(Collection<? extends N> newElements) {
		stack.addAll(newElements);
	}

	public N pop() {
		return stack.pop();
	}

	public boolean isEmpty() {
		return stack.isEmpty();
	}

}
"
ExpandCollection.java,framework,"package org.processmining.framework.util.search;

import java.util.Collection;

/**
 * 
 * @author bfvdonge
 * 
 * @param <N>
 */
public interface ExpandCollection<N> {

	/**
	 * Gets and removes the first element to be expanded by the node expander.
	 * 
	 * Implementing classes may assume that isEmpty() returns false before any
	 * call to pop, i.e. the first line of the implementation can be:
	 * <code>assert (!isEmpty())</code>
	 * 
	 * @return the first element to be investigated by the searcher.
	 */
	public N pop();

	/**
	 * Adds the given elements to the collection. Note that implementing classes
	 * may safely assume that the calling thread owns the monitor, i.e. there is
	 * no need to synchronize on the collection retained by this
	 * expandcollection and removals are allowed. Furthermore, the implementing
	 * class may decide not to include any of the given newElements if it
	 * decides that they are not to be investigated further.
	 * 
	 * @param newElements
	 *            the nodes to expand further
	 */
	public void add(Collection<? extends N> newElements);

	/**
	 * Checks whether or not the collection retained by this ExpandCollection is
	 * empty. If this method returns false, a call to pop() can be made.
	 * 
	 * @return
	 */
	public boolean isEmpty();

}
"
HashMultiSet.java,framework,"package org.processmining.framework.util.collection;

import java.util.Collection;
import java.util.HashMap;
import java.util.Map;

public class HashMultiSet<T> extends AbstractMultiSet<T, Map<T, Integer>> {

	/**
	 * Constructs a new multiset, such that all elements of the given collection
	 * are added as many times as they are returned by the iterator of that
	 * collection.
	 * 
	 * @param collection
	 *            Representing the objects that should be put in a multiset
	 */
	public HashMultiSet(Collection<? extends T> collection) {
		this();
		addAll(collection);
	}

	/**
	 * Constructs a new multiset, such that all elements of the given collection
	 * are added as many times as they are in the given array.
	 * 
	 * @param collection
	 *            Representing the objects that should be put in a multiset
	 */
	public HashMultiSet(T[] collection) {
		this();
		for (T par : collection) {
			add(par);
		}
	}

	/**
	 * Constructs a new, empty multiset, such that all elements of the given
	 * collection are added as many times as they are returned by the iterator
	 * of that collection.
	 */
	public HashMultiSet() {
		size = 0;
		map = new HashMap<T, Integer>();
	}

	<S> MultiSet<S> newMultiSet(Collection<S> collection) {
		return new HashMultiSet<S>(collection);
	}

	MultiSet<T> newMultiSet() {
		return new HashMultiSet<T>();
	}
}
"
LinkedHashMultiSet.java,framework,"package org.processmining.framework.util.collection;

import java.util.Collection;
import java.util.LinkedHashMap;

public class LinkedHashMultiSet<T> extends HashMultiSet<T> {

	/**
	 * Constructs a new multiset, such that all elements of the given collection
	 * are added as many times as they are returned by the iterator of that
	 * collection.
	 * 
	 * @param collection
	 *            Representing the objects that should be put in a multiset
	 */
	public LinkedHashMultiSet(Collection<? extends T> collection) {
		this();
		addAll(collection);
	}

	/**
	 * Constructs a new multiset, such that all elements of the given collection
	 * are added as many times as they are in the given array.
	 * 
	 * @param collection
	 *            Representing the objects that should be put in a multiset
	 */
	public LinkedHashMultiSet(T... collection) {
		this();
		for (T par : collection) {
			add(par);
		}
	}

	/**
	 * Constructs a new, empty multiset, such that all elements of the given
	 * collection are added as many times as they are returned by the iterator
	 * of that collection.
	 */
	public LinkedHashMultiSet() {
		size = 0;
		map = new LinkedHashMap<T, Integer>();
	}

}
"
MultiSet.java,framework,"package org.processmining.framework.util.collection;

import java.util.Collection;
import java.util.List;
import java.util.Set;

import org.processmining.framework.util.HTMLToString;

/**
 * This class implements a mutliset. The implementation is synchronized.
 * 
 * @author bfvdonge
 * 
 * @param <T>
 *            the type of the objects in this multiset.
 */
public interface MultiSet<T> extends Collection<T>, HTMLToString {

	/**
	 * Adds the given object to the multiset, as many times as indicated by the
	 * given weight parameter.
	 * 
	 * @param par
	 *            the object to add
	 * @param weight
	 *            the number of times to add it
	 * @return the new number of occurrences of the object (>0)
	 */
	public Integer add(T par, Integer weight);

	/**
	 * Converts this multiset to a list, such that each element occurs as often
	 * as returned by the iterator of the multiset (its number of occurrences).
	 * 
	 * @return a list of objects as returned by the iterator
	 */
	public List<T> toList();

	/**
	 * returns true if this multiset is less or equal to the given multiset,
	 * i.e. all objects in this multiset should be contained in the given set
	 * and the number of occurrences in the given set is at least the number of
	 * occurrences in this multiset.
	 * 
	 * @param multiSet
	 *            the multiset to test
	 * @return true if the given multiset is less or equal.
	 */
	public boolean isLessOrEqual(MultiSet<T> multiSet);

	/**
	 * returns the number of occurrences of the given object in this multiset.
	 * 
	 * @param source
	 *            the object to get the occurrences for
	 * @return the number of occurrences, 0 if the object does not occur.
	 */
	public Integer occurrences(Object source);

	/**
	 * returns an unmodifiable set of unique objects in the multiset.
	 * 
	 * @return an unmodifiable set of unique objects in the multiset.
	 */
	public Set<T> baseSet();

}
"
MultiThreadedSearcher.java,framework,"package org.processmining.framework.util.search;

import java.rmi.server.UID;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Executor;

import javax.swing.SwingWorker;

import org.processmining.framework.plugin.Progress;

/**
 * This class implements a multi-threaded search algorithm.
 * 
 * Internally, each instance of this class keeps a stack of objects of type N,
 * representing the nodes in the tree. Each thread pops an element off the stack
 * and asks the registered NodeExpander<N> to expand it. If the node turns out
 * to be a leaf, the expander is asked to process the leaf.
 * 
 * The use of this class is as follows (in pseudo-code):
 * 
 * <code>
 * Collection<N> initialSearchNodes;
 * Collection<N> resultCollection;
 * NodeExpander<N> expander = new NodeExpander<N>();
 * MultiThreadedSearcher<N> searcher = new MultiThreadedSearcher<N>(expander, BREADTHFIRST);
 * searcher.addInitialNodes(initialSearchNodes);
 * 
 * searcher.startSearch(executor, progress, resultCollection); 
 * </code>
 * 
 * Note that if you use this code from a plugin, you can also use:
 * 
 * <code>
 * searcher.startSearch(context.getExecutor(), context.getProgress(), resultCollection);
 * </code>
 * 
 * The progress object given to the startSearch method is only used for
 * cancellation checks, i.e. progress is never incremented.
 * 
 * @author bfvdonge
 * 
 * @param <N>
 */
public class MultiThreadedSearcher<N> {

	/**
	 * Constant representing a DEPTH-FIRST search.
	 */
	public final static int DEPTHFIRST = 0;

	/**
	 * Constant representing a BREADTH-FIRST search.
	 */
	public final static int BREADTHFIRST = 1;

	private final NodeExpander<N> expander;
	private final int threads;
	private Map<MultiThreadedSearchWorker<N>, Boolean> waiting;
	private final ExpandCollection<N> stack;

	/**
	 * Instantiates a searcher. The searcher will use as many threads as
	 * specified. Furthermore, the given expander is used for the expansion of
	 * search nodes and the processing of leaf nodes.
	 * 
	 * The searchtype can be either DEPTHFIRST, or BREADTHFIRST. In the first
	 * case, new nodes produced by the expand method of the expander are added
	 * to the bottom of the stack, whereas in the latter case, the new nodes are
	 * pushed to the top of the stack.
	 * 
	 * @param numberOfThreads
	 *            specifies the number of threads to use. If unsure how to set
	 *            this value, use the other constructor without this parameter
	 * @param expander
	 *            The expander that will be used to expand each search node and
	 *            process the leafs of the search tree
	 * @param searchType
	 *            the type of search, either DEPTHFIRST or BREADTHFIRST
	 */
	public MultiThreadedSearcher(int numberOfThreads, NodeExpander<N> expander, int searchType) {
		this.threads = numberOfThreads;
		this.expander = expander;
		if (searchType == DEPTHFIRST) {
			this.stack = new DepthFirstExpandCollection<N>();
		} else if (searchType == BREADTHFIRST) {
			this.stack = new BreadthFirstExpandCollection<N>();
		} else {
			throw new IllegalArgumentException(""Wrong search type specified."");
		}
	}

	/**
	 * Instantiates a searcher. The searcher will use as many threads as the
	 * virtual machine reports to have CPUs. Furthermore, the given expander is
	 * used for the expansion of search nodes and the processing of leaf nodes.
	 * 
	 * The searchtype can be either DEPTHFIRST, or BREADTHFIRST. In the first
	 * case, new nodes produced by the expand method of the expander are added
	 * to the bottom of the stack, whereas in the latter case, the new nodes are
	 * pushed to the top of the stack.
	 * 
	 * By default, as many threads are used as there are CPUs reported by
	 * <code>Runtime.getRuntime().availableProcessors()</code>
	 * 
	 * @param expander
	 *            The expander that will be used to expand each search node and
	 *            process the leafs of the search tree
	 * @param searchType
	 *            the type of search, either DEPTHFIRST or BREADTHFIRST
	 */
	public MultiThreadedSearcher(NodeExpander<N> expander, int searchType) {
		this(Runtime.getRuntime().availableProcessors(), expander, searchType);
	}

	/**
	 * Instantiates a searcher. The searcher will use as many threads as
	 * specified. Furthermore, the given expander is used for the expansion of
	 * search nodes and the processing of leaf nodes and the given
	 * expandCollection to store nodes that need to be expanded further.
	 * 
	 * @param numberOfThreads
	 *            specifies the number of threads to use. If unsure how to set
	 *            this value, use the other constructor without this parameter
	 * @param expander
	 *            The expander that will be used to expand each search node and
	 *            process the leafs of the search tree
	 * @param expandCollection
	 *            the collection to store nodes that need to be expanded
	 */
	public MultiThreadedSearcher(int numberOfThreads, NodeExpander<N> expander, ExpandCollection<N> expandCollection) {
		this.threads = numberOfThreads;
		this.expander = expander;
		this.stack = expandCollection;
	}

	/**
	 * Instantiates a searcher. The searcher will use as many threads as
	 * specified. Furthermore, the given expander is used for the expansion of
	 * search nodes and the processing of leaf nodes and the given
	 * expandCollection to store nodes that need to be expanded further.
	 * 
	 * By default, as many threads are used as there are CPUs reported by
	 * <code>Runtime.getRuntime().availableProcessors()</code>
	 * 
	 * @param expander
	 *            The expander that will be used to expand each search node and
	 *            process the leafs of the search tree
	 * @param expandCollection
	 *            the collection to store nodes that need to be expanded
	 */
	public MultiThreadedSearcher(NodeExpander<N> expander, ExpandCollection<N> expandCollection) {
		this(Runtime.getRuntime().availableProcessors(), expander, expandCollection);
	}

	/**
	 * Sets the initial nodes of the search tree. Note that you can provide an
	 * empty collection, in which case the search returns immediately, without
	 * calling any methods in the expander.
	 * 
	 * @param initialNodes
	 *            the collection of initial nodes.
	 */
	public void addInitialNodes(Collection<N> initialNodes) {
		synchronized (stack) {
			stack.add(initialNodes);
		}
	}

	/**
	 * Sets the initial nodes of the search tree. Note that you don't have to
	 * provide any nodes, in which case the search returns immediately, without
	 * calling any methods in the expander.
	 * 
	 * @param initialNodes
	 *            zero or more initial nodes.
	 */
	public void addInitialNodes(N... initialNodes) {
		synchronized (stack) {
			stack.add(Arrays.asList(initialNodes));
		}
	}

	/**
	 * A call to this method initiates the search. The calling thread is
	 * suspended until the search is completed, or the progress was canceled.
	 * The resultCollection given to this method is passes through to the
	 * processLeaf method of the NodeExpander, i.e. no changes to this
	 * collection are made by the searcher.
	 * 
	 * @param executor
	 *            The executor in which the searcher can schedule it's threads.
	 *            If called from a plugin, use context.getExector() to pass to
	 *            this method.
	 * @param progress
	 *            The progress which is polled for cancellation. Note that no
	 *            other changes are made to the progress. If changes are
	 *            necessary, this has to be handled by the NodeExpander. If
	 *            called from a plugin, use context.getProgress() to pass to
	 *            this method.
	 * @param resultCollection
	 *            The collection in which the final result is stored by the
	 *            processLeaf method of the node expander. Note that the
	 *            searcher does not change this collection in any way, nor does
	 *            it handle any necessary synchronization.
	 * @throws InterruptedException
	 *             If one of the threads was interupted;
	 * @throws ExecutionException
	 *             If one of the threads threw an exception;
	 */
	public void startSearch(final Executor executor, final Progress progress, final Collection<N> resultCollection)
			throws InterruptedException, ExecutionException {

		// Set the number of waiting threads to 0;
		waiting = new HashMap<MultiThreadedSearchWorker<N>, Boolean>();

		MultiThreadedSearchWorker<N> worker = null;

		// Syncrhonize on the object ""waiting"" to make sure that first all
		// workers are registered to this map, before any of them accesses it.
		synchronized (waiting) {
			for (int i = 0; i < threads; i++) {
				worker = new MultiThreadedSearchWorker<N>(this, progress, resultCollection);
				waiting.put(worker, false);
			}
		}

		for (MultiThreadedSearchWorker<N> w : waiting.keySet()) {
			executor.execute(w);
		}

		// Just synchronize on the last worker. It stops only when all workers are finished.
		worker.get();

	}

	NodeExpander<N> getExpander() {
		return expander;
	}

	ExpandCollection<N> getStack() {
		return stack;
	}

	boolean setWaiting(MultiThreadedSearchWorker<N> worker, Boolean state) {
		synchronized (waiting) {
			waiting.put(worker, state);
			return !waiting.containsValue(false);
		}
	}
}

class MultiThreadedSearchWorker<N> extends SwingWorker<Object, Void> {

	private final MultiThreadedSearcher<N> owner;
	private final Progress progress;

	private final Collection<N> resultCollection;

	private final ExpandCollection<N> stack;
	private final UID id = new UID();

	public MultiThreadedSearchWorker(MultiThreadedSearcher<N> owner, Progress progress, Collection<N> resultCollection) {
		this.owner = owner;
		this.progress = progress;
		this.resultCollection = resultCollection;
		this.stack = owner.getStack();
	}

	public int hashCode() {
		return id.hashCode();
	}

	@SuppressWarnings(""unchecked"")
	public boolean equals(Object o) {
		if (o instanceof MultiThreadedSearchWorker) {
			return id.equals(((MultiThreadedSearchWorker) o).id);
		}
		return false;
	}

	@Override
	protected Object doInBackground() throws Exception {
		while (!progress.isCancelled()) {
			// First get the node to expand
			N toExpand = getNodeToExpand(progress);
			if (toExpand == null) {
				// Cancellation occurred, or the search is finished.
				// stop execution
				synchronized (stack) {
					stack.notifyAll();
				}
				break /* while */;
			}

			// Ask the expander for new nodes. Note that this call does not 
			// synchronize on stack, hence multiple of these calls can be 
			// processed in parallel.
			Collection<N> expandFurther = owner.getExpander().expandNode(toExpand, progress, resultCollection);

			// Let the searcher process the newly found nodes. Note that this is
			// synchronized as it requires to change the stack.
			processNewNodes(toExpand, expandFurther, resultCollection, progress);
		}
		// all threads are done, so quit.
		return null;
	}

	private N getNodeToExpand(Progress progress) throws InterruptedException {
		synchronized (stack) {
			while (!progress.isCancelled()) {
				if (stack.isEmpty()) {
					// Notify the searcher that we enter the waiting state
					if (owner.setWaiting(this, true)) {
						// All threads are waiting for the stack and this is the last
						// that will start waiting. Hence, there is nothing to do anymore.
						// Stop the execution by returning null.
						return null;
					} else {
						// Let's sleep until stack is filled again.
						stack.wait();
						continue;
					}
				} else {
					// Notify the searcher that we leave the waiting state
					owner.setWaiting(this, false);
					// get the node to expand.
					N toExpand = stack.pop();
					stack.notifyAll();
					return toExpand;
				}
			}
		}
		// In case of a cancellation, throw an exception;
		owner.setWaiting(this, true);
		return null;
	}

	private void processNewNodes(N toExpand, Collection<N> expandFurther, final Collection<N> resultCollection,
			Progress progress) {
		synchronized (stack) {
			if (!expandFurther.isEmpty()) {
				// There are tuples that need to be expanded further.
				stack.add(expandFurther);
			} else {
				synchronized (resultCollection) {
					owner.getExpander().processLeaf(toExpand, progress, resultCollection);
				}
			}
			// notify threads waiting on stack
			stack.notifyAll();
		}

	}

}
"
NodeExpander.java,framework,"package org.processmining.framework.util.search;

import java.util.Collection;

import org.processmining.framework.plugin.Progress;

/**
 * This class is used by the MultiThreadedSearcher to handle callbacks. Each
 * time the searcher considers a node, it asks the registered expander to expand
 * the node. If a node cannot be expanded, then a call to processLeaf is made.
 * The expander should not process any leafs from within the expandNode method.
 * 
 * @author bfvdonge
 * 
 * @param <N>
 */
public interface NodeExpander<N> {

	/**
	 * This method is called by the searcher when a node in the search tree has
	 * to be considered for expansion. The node to expand is given as a
	 * parameter and the method should return a collection of nodes representing
	 * the children of this node. If the node turns out to be a leaf, an empty
	 * collection has to be returned.
	 * 
	 * @param toExpand
	 *            The node to expand.
	 * @param progress
	 *            The progress indicator provided to the searcher in which this
	 *            expander is registered. The expander may increment the
	 *            progress, but it should check for cancellation, especially
	 *            when doing long computations.
	 * @param unmodifiableResultCollection
	 *            the leafs of the search space that have been added to the
	 *            resultCollection by the processLeaf method. Note that any
	 *            access to this collection should be synchronized and this
	 *            collection should not be modified in this method. However the
	 *            provided collection is modifiable, as for synchronization
	 *            purposes, the actual resultCollection is provided.
	 * @return A collection of child nodes, or an empty collection if this node
	 *         turns out to be a leaf.
	 */
	public Collection<N> expandNode(N toExpand, Progress progress, Collection<N> unmodifiableResultCollection);

	/**
	 * This method is called by the searcher to which this expander is
	 * registered each time a leaf was encountered. The provided
	 * resultCollection was specified in the startSearch method of the searcher
	 * and can be used to store this result. A typical implementation is:
	 * 
	 * <code>
	 * synchronized(resultCollection) {
	 *     resultCollection.add(leaf);
	 * }
	 * </code>
	 * 
	 * However, more advanced implementations are possible.
	 * 
	 * Finally, note that calls to this method are not thread-safe, i.e. the
	 * implementing class should take care of synchronization on the
	 * resultCollection if necessary (as in the example above).
	 * 
	 * @param leaf
	 *            The node that was found to be a leaf by the expandNode method
	 *            (i.e. the expandNode method returned and empty collection)
	 * @param progress
	 *            The progress indicator provided to the searcher in which this
	 *            expander is registered. The expander may increment the
	 *            progress, but it should check for cancellation, especially
	 *            when doing long computations.
	 * @param resultCollection
	 *            The collection to which to add the leaf node. More advanced
	 *            computations are allowed here, i.e. the resultCollection can
	 *            be changed. Note however that this requires syncrhonization on
	 *            the collection, as calls to this method are not thread-safe.
	 */
	public void processLeaf(N leaf, Progress progress, Collection<N> resultCollection);

}
"
CommandLineInterface.java,framework,"package org.processmining.framework.packages;

import jargs.gnu.CmdLineParser;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.SortedSet;

import org.processmining.framework.boot.Boot.Level;
import org.processmining.framework.util.AutoHelpCommandLineParser;
import org.processmining.framework.util.Pair;

public class CommandLineInterface {

	private final PackageManager manager;

	public CommandLineInterface(PackageManager manager) {
		this.manager = manager;
	}

	public int run(String[] args) {
		AutoHelpCommandLineParser.Command[] commands = { new UpdateCommand(manager),
				new InstallOrRemoveCommand(manager), new ListCommand(manager) };
		AutoHelpCommandLineParser parser = new AutoHelpCommandLineParser(""java ""
				+ PackageManager.class.getCanonicalName(), commands);

		CmdLineParser.Option helpOption = parser.addHelp(parser.addBooleanOption('h', ""help""),
				""Print this help message and exit"");

		try {
			parser.parse(args);
		} catch (CmdLineParser.OptionException e) {
			System.err.println(e.getMessage());
			parser.printUsage();
			return 1;
		}

		if ((parser.getRemainingArgs().length == 0) || (Boolean) parser.getOptionValue(helpOption, Boolean.FALSE)) {
			parser.printUsage();
			return 0;
		}

		int exitcode;
		try {
			manager.initialize(Level.ALL);
			exitcode = parser.runCommand();
		} catch (Throwable e) {
			e.printStackTrace();
			return 1;
		}

		if (exitcode == -1) {
			parser.printUsage();
			return 1;
		}
		return exitcode;
	}

}

class UpdateCommand extends AutoHelpCommandLineParser.Command {

	private final PackageManager manager;

	public UpdateCommand(PackageManager manager) {
		super(""update"", ""Retrieve the latest package definitions from all repositories"");
		this.manager = manager;
	}

	@Override
	public int run(List<String> args) throws Exception {
		System.out.println(""Updating..."");
		manager.update(true, Level.ALL);
		System.out.println(""Done."");
		return 0;
	}

}

class InstallOrRemoveCommand extends AutoHelpCommandLineParser.Command {

	private final PackageManager manager;

	public InstallOrRemoveCommand(PackageManager manager) {
		super(""change"",
				""Install the packages preceded by +, remove packages preceded by x (example: change +packageA:1.0 xpackageB)"");
		this.manager = manager;
	}

	@Override
	public int run(List<String> args) throws Exception {
		List<PackageDescriptor> toInstall = new ArrayList<PackageDescriptor>();
		List<PackageDescriptor> toRemove = new ArrayList<PackageDescriptor>();

		Set<PackageDescriptor> all = new HashSet<PackageDescriptor>(manager.getInstalledPackages());
		all.addAll(manager.getAvailablePackages());
		Map<String, SortedSet<PackageDescriptor>> map = PackageManager.getPackageMap(all);

		for (String packageNameAndAction : args) {
			if ((packageNameAndAction.length() > 1)
					&& ((packageNameAndAction.charAt(0) == 'x') || (packageNameAndAction.charAt(0) == '+'))) {
				Pair<String, PackageVersion> packageName = parse(packageNameAndAction.substring(1));
				boolean install = packageNameAndAction.charAt(0) == '+';
				Set<PackageDescriptor> versions = map.get(packageName.getFirst());
				PackageDescriptor p = null;

				if ((versions != null) && !versions.isEmpty()) {
					if (packageName.getSecond() == null) {
						// take latest version if no version was given
						p = versions.toArray(new PackageDescriptor[0])[versions.size() - 1];
					} else {
						for (PackageDescriptor v : versions) {
							if (v.getVersion().equals(packageName.getSecond())) {
								p = v;
								break;
							}
						}
					}
				}

				if (p == null) {
					System.out.println(""Could not find package "" + packageNameAndAction.substring(1)
							+ "" in the list of available packages, skipping."");
				} else {
					System.out.println(""Selected "" + p + "" for "" + (install ? ""installation"" : ""removal"") + ""..."");
					if (install) {
						toInstall.add(p);
					} else {
						toRemove.add(p);
					}
				}
			} else {
				System.out
						.println(""Invalid package specification (please use + or - to indicate installation or removal), skipping."");
			}
		}

		if (toInstall.isEmpty() && toRemove.isEmpty()) {
			System.out.println(""Nothing to install or remove."");
		} else {
			System.out.println(""Starting installation..."");
			manager.install(toInstall);
			manager.uninstall(toRemove);
			PackageStateReport report = manager.getLatestReport();

			System.out.print(report);
			System.out.println(report.hasErrors() ? ""Installation is NOT performed."" : ""Installation done."");
		}
		return 0;
	}

	private Pair<String, PackageVersion> parse(String name) {
		int hyphen = name.indexOf(':');

		if (hyphen >= 0) {
			return new Pair<String, PackageVersion>(name.substring(0, hyphen), new PackageVersion(
					name.substring(hyphen + 1)));
		} else {
			return new Pair<String, PackageVersion>(name, null);
		}
	}
}

class ListCommand extends AutoHelpCommandLineParser.Command {

	private final PackageManager manager;

	public ListCommand(PackageManager manager) {
		super(""list"", ""List all known packages and their status (A=available,I=installed,B=broken,+=has update)"");
		this.manager = manager;
	}

	@Override
	public int run(List<String> args) throws Exception {
		Set<PackageDescriptor> installed = manager.getInstalledPackages();
		Collection<PackageDescriptor> enabled = manager.getEnabledPackages();

		Set<PackageDescriptor> all = new HashSet<PackageDescriptor>(manager.getInstalledPackages());
		all.addAll(manager.getAvailablePackages());

		for (Map.Entry<String, SortedSet<PackageDescriptor>> item : PackageManager.getPackageMap(all).entrySet()) {
			PackageDescriptor installedPackage = null;
			PackageVersion highestVersion = null;
			boolean isEnabled = false;
			String versions = """";

			for (PackageDescriptor pack : item.getValue()) {
				if (installed.contains(pack)) {
					installedPackage = pack;
				}
				if (enabled.contains(pack)) {
					isEnabled = true;
				}
				if (versions.length() > 0) {
					versions += "", "";
				}
				versions += pack.getVersion();
				highestVersion = pack.getVersion();
			}

			if (installedPackage == null) {
				System.out.println(""A  "" + item.getKey() + "" ["" + versions + ""]"");
			} else if (isEnabled) {
				System.out.println(""I"" + (installedPackage.getVersion().lessThan(highestVersion) ? ""+"" : "" "") + "" ""
						+ installedPackage + "" ["" + versions + ""]"");
			} else {
				System.out.println(""B"" + (installedPackage.getVersion().lessThan(highestVersion) ? ""+"" : "" "") + "" ""
						+ installedPackage + "" ["" + versions + ""]"");
			}
		}
		return 0;
	}
}
"
PackageManagerListener.java,framework,"package org.processmining.framework.packages.events;

import java.io.File;
import java.net.URL;
import java.util.EventListener;

import org.processmining.framework.packages.PackageDescriptor;
import org.processmining.framework.plugin.events.ProMEventListenerList;

public interface PackageManagerListener extends EventListener {

	public class ListenerList extends ProMEventListenerList<PackageManagerListener> {
		public void fireSessionStart() {
			for (PackageManagerListener listener : getListeners()) {
				listener.sessionStart();
			}
		}

		public void fireSessionComplete(boolean error) {
			for (PackageManagerListener listener : getListeners()) {
				listener.sessionComplete(error);
			}
		}

		public void fireStartDownload(String packageName, URL url, PackageDescriptor pack) {
			for (PackageManagerListener listener : getListeners()) {
				listener.startDownload(packageName, url, pack);
			}
		}

		public void fireStartInstall(String packageName, File folder, PackageDescriptor pack) {
			for (PackageManagerListener listener : getListeners()) {
				listener.startInstall(packageName, folder, pack);
			}
		}

		public void fireFinishedInstall(String packageName, File folder, PackageDescriptor pack) {
			for (PackageManagerListener listener : getListeners()) {
				listener.finishedInstall(packageName, folder, pack);
			}
		}

		public void fireException(String exception) {
			for (PackageManagerListener listener : getListeners()) {
				listener.exception(exception);
			}
		}

		public void fireException(Throwable t) {
			for (PackageManagerListener listener : getListeners()) {
				listener.exception(t);
			}
		}
	}

	public void sessionStart();

	public void exception(Throwable t);

	public void exception(String exception);

	public void startDownload(String packageName, URL url, PackageDescriptor pack);

	public void startInstall(String packageName, File folder, PackageDescriptor pack);

	public void finishedInstall(String packageName, File folder, PackageDescriptor pack);

	public void sessionComplete(boolean error);

}
"
CancelledException.java,framework,"package org.processmining.framework.packages.impl;

import org.xml.sax.SAXException;

public class CancelledException extends SAXException {

	/**
	 * 
	 */
	private static final long serialVersionUID = -1288614934031744810L;

}
"
PackageConfigPerister.java,framework,"package org.processmining.framework.packages.impl;

import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStream;
import java.io.Writer;
import java.net.MalformedURLException;
import java.net.URL;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import javax.xml.parsers.ParserConfigurationException;
import javax.xml.parsers.SAXParser;
import javax.xml.parsers.SAXParserFactory;

import org.processmining.framework.boot.Boot;
import org.processmining.framework.packages.PackageDescriptor;
import org.processmining.framework.packages.PackageDescriptor.OS;
import org.processmining.framework.packages.PackageManager;
import org.processmining.framework.packages.PackageManager.Canceller;
import org.processmining.framework.packages.PackageSet;
import org.processmining.framework.packages.Repository;
import org.xml.sax.Attributes;
import org.xml.sax.SAXException;
import org.xml.sax.helpers.DefaultHandler;

public class PackageConfigPerister {

	private static final String nl = System.getProperty(""line.separator"");

	private PackageConfigPerister() {
	}

	public static void read(File f, Set<Repository> repositories, PackageSet available, PackageSet installed,
			Canceller canceller) throws ParserConfigurationException, SAXException, IOException {
		InputStream is = new BufferedInputStream(new FileInputStream(f));
		try {
			read(is, repositories, available, installed, canceller);
		} finally {
			is.close();
		}
	}

	public static void read(InputStream is, Set<Repository> repositories, PackageSet available, PackageSet installed,
			Canceller canceller) throws ParserConfigurationException, SAXException, IOException {
		BufferedInputStream bis = new BufferedInputStream(is);
		ConfigHandler handler = new ConfigHandler(repositories, available, installed, canceller);
		SAXParserFactory parserFactory = SAXParserFactory.newInstance();

		parserFactory.setNamespaceAware(false);
		parserFactory.setValidating(false);
		try {
			// Some old JAXP versions may throw the UnsupportedOperation Exception in the next call.
			parserFactory.setSchema(null);
		} catch (UnsupportedOperationException ex) {
			// Ignore.
		}

		SAXParser parser = parserFactory.newSAXParser();
		parser.parse(bis, handler);
		bis.close();
	}

	public static Set<PackageDescriptor> listRepository(InputStream is, Canceller canceller)
			throws ParserConfigurationException, SAXException, IOException {
		Set<Repository> repos = new HashSet<Repository>();
		PackageSet available = new PackageSet();
		PackageSet installed = new PackageSet();

		read(is, repos, available, installed, canceller);
		return available;
	}

	static private class ConfigHandler extends DefaultHandler {

		private static final String PACKAGES = ""packages"";
		private static final String URL_ATTR = ""url"";
		private static final String VERSION_ATTR = ""version"";
		private static final String NAME_ATTR = ""name"";
		private static final String DEPENDENCY = ""dependency"";
		private static final String PACKAGE = ""package"";
		private static final String REPOSITORY = ""repository"";
		private static final String CONFLICT = ""conflict"";
		private static final String DESCRIPTION_ATTR = ""desc"";
		private static final String ORGANISATION_ATTR = ""org"";
		private static final String AUTHOR_ATTR = ""author"";
		private static final String AUTO_ATTR = ""auto"";
		private static final String LICENSE_ATTR = ""license"";
		private static final Object INSTALLED = ""installed-packages"";
		private static final String HAS_PLUGINS_ATTR = ""hasPlugins"";
		private static final String OS_ATTR = ""os"";
		private static final String MAINTAINER_ATTR = ""maintainer"";

		private static final String LOGO_URL_ATTR = ""logo"";
		private static final String KEYWORDS_ATTR = ""keywords"";

		private Repository curRepo = null;
		private String curPackageName = null;
		private String curPackageVersion = null;
		private final List<String> dependencies = new ArrayList<String>();
		private final List<String> conflicts = new ArrayList<String>();
		private String curPackageURL;
		private String curLogoURL;
		private String curPackageDesc;
		private String curPackageOrg;
		private String curPackageAuthor;
		private String curPackageLicense;
		private String curPackageAutoInstalled;
		private String curPackageHasPlugins;
		private boolean insideInstalled = false;

		private final Set<Repository> repositories;
		private final Set<PackageDescriptor> available;
		private final Set<PackageDescriptor> installed;
		private final Canceller canceller;
		private String curPackageOS;
		private String curPackageMaintainer;
		private String curKeywords;
		private URL contextURL;
		
		public ConfigHandler(Set<Repository> repositories, Set<PackageDescriptor> available,
				Set<PackageDescriptor> installed, Canceller canceller) {
			this.available = available;
			this.installed = installed;
			this.repositories = repositories;
			this.canceller = canceller;
			
			/*
			 * Set a context for the URLs. This allows us to use relative URLs in the repositories.
			 */
			String repository = Boot.DEFAULT_REPOSITORY.toString();
			int lastPathSeparator = repository.lastIndexOf(""/"");
			String context = repository.substring(0, lastPathSeparator + 1);
			try {
				this.contextURL = new URL(context);
			} catch (MalformedURLException e) {
				try {
					this.contextURL = new URL(""http://www.promtools.org/prom6/packages/"");
				} catch (MalformedURLException e2) {
					assert(false);
				}
			}
			System.out.println(""[PackageConfigPerister] Context URL set to "" + this.contextURL);
		}

		@Override
		public void startElement(String uri, String local, String qName, Attributes attributes) throws SAXException {
			if ((canceller != null) && canceller.isCancelled()) {
				throw new CancelledException();
			}
			qName = qName.toLowerCase();

			if ((curRepo == null) && (curPackageName == null)) {
				if (qName.equals(INSTALLED)) {
					insideInstalled = true;
				} else if (!insideInstalled && qName.equals(REPOSITORY)) {
					String url = attributes.getValue(URL_ATTR);

					if ((url != null) && (url.trim().length() > 0)) {
						try {
							/*
							 * Use the context for URLs.
							 */
							curRepo = new Repository(new URL(contextURL, url.trim()));
						} catch (MalformedURLException e) {
							System.err.println(""Invalid URL for repository, skipping: "" + url);
						}
					}
				} else if (qName.equals(PACKAGE)) {
					String name = attributes.getValue(NAME_ATTR);
					String version = attributes.getValue(VERSION_ATTR);
					String url = attributes.getValue(URL_ATTR);
					String logo = attributes.getValue(LOGO_URL_ATTR);
					String desc = attributes.getValue(DESCRIPTION_ATTR);
					String org = attributes.getValue(ORGANISATION_ATTR);
					String license = attributes.getValue(LICENSE_ATTR);
					String author = attributes.getValue(AUTHOR_ATTR);
					String auto = attributes.getValue(AUTO_ATTR);
					String hasPlugins = attributes.getValue(HAS_PLUGINS_ATTR);
					String os = attributes.getValue(OS_ATTR);
					String maintainer = attributes.getValue(MAINTAINER_ATTR);
					String keywords = attributes.getValue(KEYWORDS_ATTR);

					if ((name != null) && (name.trim().length() > 0) && //
							(version != null) && (version.trim().length() > 0) && //
							(os != null) && (os.trim().length() > 0) && //
							(url != null) && (url.trim().length() > 0)) {
						curPackageName = name;
						curPackageVersion = version;
						try {
							/*
							 * Use the context for URLs.
							 */
							curPackageURL = new URL(contextURL, url).toString();
						} catch (MalformedURLException e) {
							/*
							 * Use of context not possible. As before.
							 */
							curPackageURL = url;
						}
						curPackageOS = os;
						if (logo != null) {
							try {
								/*
								 * Use the context for logo URLs.
								 */
								curLogoURL = new URL(contextURL, logo).toString();
							} catch (MalformedURLException e) {
								/*
								 * Use of context not possible. As before.
								 */
								curLogoURL = """";
							}
						} else {
							curLogoURL = """";
						}
						curPackageDesc = desc == null ? """" : desc;
						curPackageOrg = org == null ? """" : org;
						curPackageLicense = license == null ? """" : license;
						curPackageAuthor = author == null ? """" : author;
						curPackageMaintainer = maintainer == null ? author : maintainer;
						curPackageAutoInstalled = auto == null ? """" : auto;
						curPackageHasPlugins = hasPlugins == null ? """" : hasPlugins;
						curKeywords = keywords == null ? """" : keywords;
						dependencies.clear();
						conflicts.clear();
					}
				}
			} else if ((curPackageName != null) && qName.equals(DEPENDENCY)) {
				String name = attributes.getValue(NAME_ATTR);

				if ((name != null) && (name.trim().length() > 0)) {
					dependencies.add(name);
				}
			} else if ((curPackageName != null) && qName.equals(CONFLICT)) {
				String name = attributes.getValue(NAME_ATTR);

				if ((name != null) && (name.trim().length() > 0)) {
					conflicts.add(name);
				}
			}
		}

		@Override
		public void endElement(String uri, String local, String qName) throws SAXException {
			if ((canceller != null) && canceller.isCancelled()) {
				throw new CancelledException();
			}
			qName = qName.toLowerCase();

			if (qName.equals(INSTALLED)) {
				insideInstalled = false;
			} else if ((curRepo != null) && qName.equals(REPOSITORY)) {
				repositories.add(curRepo);
				curRepo = null;
			} else if ((curPackageName != null) && qName.equals(PACKAGE)) {
				OS os = OS.fromString(curPackageOS);
				if (os.isUsable()) {
					PackageDescriptor pack = new PackageDescriptor(curPackageName, curPackageVersion, os,
							curPackageDesc, curPackageOrg, curPackageAuthor, curPackageMaintainer, curPackageLicense,
							curPackageURL, curLogoURL,  curKeywords, ""true"".equals(curPackageAutoInstalled), !""false""
									.equals(curPackageHasPlugins), dependencies, conflicts);
					if (insideInstalled) {
						installed.add(pack);
					} else {
						if (Boot.HIDE_OLD_PACKAGES) {
							// Suggested by Massimiliano de Leoni
							PackageDescriptor foundPack = null;
							for (PackageDescriptor availablePack : available) {
								if (availablePack.getName().equals(pack.getName())) {
									foundPack = availablePack;
									break;
								}
							}
							if (foundPack != null) {
								if (foundPack.getVersion().lessThan(pack.getVersion())) {
									available.remove(foundPack);
									available.add(pack);
								} else {
									// Skip, pack is dominated by foundPack.
								}
							} else {
								available.add(pack);
							}
						} else {
							available.add(pack);
						}
					}
				}
				curPackageName = null;
			}
		}
	}

	public static void write(File config, Set<Repository> repositories, Set<PackageDescriptor> available,
			Set<PackageDescriptor> installed) throws IOException {
		Writer writer = new FileWriter(config);

		// TODO properly escape all raw strings

		writer.write(""<?xml version=\""1.0\"" encoding=\""iso-8859-1\""?>"" + nl);
		writer.write(""<"" + ConfigHandler.PACKAGES + "">"" + nl);
		for (Repository repo : repositories) {
			writer.write(""  <"" + ConfigHandler.REPOSITORY + "" "" + ConfigHandler.URL_ATTR + ""=\"""" + repo.getURL() + ""\""""
					+ "" />"" + nl);
		}
		for (PackageDescriptor pack : available) {
			/*
			 * Do not write to local repo if known to be unavailable.
			 */
			if (PackageManager.getInstance().isAvailable(pack)) {
				writePackage(pack, writer);
			}
		}
		writer.write(""  <"" + ConfigHandler.INSTALLED + "">"" + nl);
		for (PackageDescriptor pack : installed) {
			writePackage(pack, writer);
		}
		writer.write(""  </"" + ConfigHandler.INSTALLED + "">"" + nl);

		writer.write(""</"" + ConfigHandler.PACKAGES + "">"" + nl);
		writer.close();
	}

	private static void writePackage(PackageDescriptor pack, Writer writer) throws IOException {
		writer.write(""  <"" + ConfigHandler.PACKAGE + //
				"" "" + ConfigHandler.NAME_ATTR + ""=\"""" + pack.getName() + ""\"""" + //
				"" "" + ConfigHandler.VERSION_ATTR + ""=\"""" + pack.getVersion() + ""\"""" + //
				"" "" + ConfigHandler.OS_ATTR + ""=\"""" + pack.getOS().getName() + ""\"""" + //
				"" "" + ConfigHandler.URL_ATTR + ""=\"""" + pack.getURL() + ""\"""" + //
				"" "" + ConfigHandler.DESCRIPTION_ATTR + ""=\"""" + pack.getDescription() + ""\"""" + //
				"" "" + ConfigHandler.ORGANISATION_ATTR + ""=\"""" + pack.getOrganisation() + ""\"""" + //
				"" "" + ConfigHandler.AUTO_ATTR + ""=\"""" + (pack.getAutoInstalled() ? ""true"" : ""false"") + ""\"""" + //
				"" "" + ConfigHandler.HAS_PLUGINS_ATTR + ""=\"""" + (pack.hasPlugins() ? ""true"" : ""false"") + ""\"""" + //
				"" "" + ConfigHandler.LICENSE_ATTR + ""=\"""" + pack.getLicense() + ""\"""" + //
				"" "" + ConfigHandler.AUTHOR_ATTR + ""=\"""" + pack.getAuthor() + ""\"""" + //
				"" "" + ConfigHandler.MAINTAINER_ATTR + ""=\"""" + pack.getMaintainer() + ""\"""" + //
				"" "" + ConfigHandler.LOGO_URL_ATTR + ""=\"""" + pack.getLogoURL() + ""\"""" + //
				"" "" + ConfigHandler.KEYWORDS_ATTR + ""=\"""" + pack.getKeywords() + ""\"""" + //
				"">"" + nl);
		for (String dep : pack.getDependencies()) {
			writer.write(""    <"" + ConfigHandler.DEPENDENCY + "" "" + ConfigHandler.NAME_ATTR + ""=\"""" + dep + ""\""""
					+ "" />"" + nl);
		}
		for (String confl : pack.getConflicts()) {
			writer.write(""    <"" + ConfigHandler.CONFLICT + "" "" + ConfigHandler.NAME_ATTR + ""=\"""" + confl + ""\""""
					+ "" />"" + nl);
		}
		writer.write(""  </"" + ConfigHandler.PACKAGE + "">"" + nl);
	}
}
"
PackageDescriptor.java,framework,"package org.processmining.framework.packages;

import java.io.File;
import java.util.Collections;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Set;

import org.processmining.framework.util.OsUtil;

public class PackageDescriptor implements Comparable<PackageDescriptor> {

	public static enum OS {
		WIN64(""win64"", OsUtil.isRunningWindows() && OsUtil.is64Bit()), //
		WIN32(""win32"", OsUtil.isRunningWindows() && OsUtil.is32Bit()), //
		LIN32(""linux32"", OsUtil.isRunningLinux() && OsUtil.is32Bit()), //
		LIN64(""linux64"", OsUtil.isRunningLinux() && OsUtil.is64Bit()), //
		MAC(""mac"", OsUtil.isRunningMacOsX()), //
		ALL(""all"", true);

		private final String name;
		private final boolean usable;

		private OS(String name, boolean usable) {
			this.name = name;
			this.usable = usable;
		}

		public String getName() {
			return name;
		}

		public static OS fromString(String curPackageOS) {
			for (OS os : OS.values()) {
				if (os.name.equals(curPackageOS)) {
					return os;
				}
			}
			return ALL;
		}

		public boolean isUsable() {
			return usable;
		}
	}

	private final String name;
	private final PackageVersion version;
	private final String description;
	private final String organisation;
	private final String author;
	private final String license;
	private final String url;
	private final boolean autoInstalled;
	private final boolean hasPlugins;
	private final Set<String> dependencies;
	private final Set<String> conflicts;
	private boolean broken;
	private final String logoUrl;
	private final OS os;
	private final String maintainer;
	private final String keywords;

	public PackageDescriptor(String name, String version, OS os, String description, String organisation,
			String author, String maintainer, String license, String url, String logoUrl, String keywords,
			boolean autoInstalled, boolean hasPlugins, List<String> dependencies, List<String> conflicts) {
		this.name = name;
		this.os = os;
		this.maintainer = maintainer;
		this.logoUrl = logoUrl;
		this.autoInstalled = autoInstalled;
		this.hasPlugins = hasPlugins;
		this.version = new PackageVersion(version);
		this.description = description;
		this.organisation = organisation;
		this.author = author;
		this.license = license;
		this.url = url;
		this.keywords = keywords;
		this.dependencies = Collections.unmodifiableSet(new HashSet<String>(dependencies));
		this.conflicts = Collections.unmodifiableSet(new HashSet<String>(conflicts));
		broken = false;
	}

	@Override
	public String toString() {
		return name + ""-"" + version;
	}

	@Override
	public boolean equals(Object other) {
		if (!(other instanceof PackageDescriptor)) {
			return false;
		}
		return name.equals(((PackageDescriptor) other).name) && //
				version.equals(((PackageDescriptor) other).version) && //
				os.equals(((PackageDescriptor) other).os);
	}

	@Override
	public int hashCode() {
		return name.hashCode() * 37 + version.hashCode();
	}

	public String getName() {
		return name;
	}

	public PackageVersion getVersion() {
		return version;
	}

	public String getURL() {
		return url;
	}

	public String getLogoURL() {
		return logoUrl;
	}

	public Set<String> getDependencies() {
		return dependencies;
	}

	public Set<String> getConflicts() {
		return conflicts;
	}

	public File getLocalPackageDirectory() {
		return new File(PackageManager.getInstance().getPackagesDirectory(), makeFilename(name + ""-"" + version));
	}

	private static String makeFilename(String filename) {
		return filename.toLowerCase().replaceAll(""[^a-zA-Z0-9-.]"", ""_"");
	}

	public void setHasBrokenDependencies() {
		broken = true;
	}

	public boolean hasBrokenDependencies() {
		return broken;
	}

	public String getDescription() {
		return description;
	}

	public String getOrganisation() {
		return organisation;
	}

	public String getAuthor() {
		return author;
	}

	public String getLicense() {
		return license;
	}

	public OS getOS() {
		return os;
	}

	public String getMaintainer() {
		return maintainer;
	}

	public String getKeywords() {
		return keywords;
	}

	public boolean getAutoInstalled() {
		return autoInstalled;
	}

	public boolean hasPlugins() {
		return hasPlugins;
	}

	public String toHTML() {
		StringBuffer buffer = new StringBuffer();

		buffer.append(""<HTML><TABLE>"");
		buffer.append(""<TR><TD>Package:</TD><TD>"" + description + ""</TD></TR>"");
		buffer.append(""<TR><TD>Version:</TD><TD>"" + version + ""</TD></TR>"");
		buffer.append(""<TR><TD>Organisation:</TD><TD>"" + organisation + ""</TD></TR>"");
		buffer.append(""<TR><TD>Author(s):</TD><TD>"" + author + ""</TD></TR>"");
		buffer.append(""<TR><TD>Maintained by:</TD><TD>"" + maintainer + ""</TD></TR>"");
		buffer.append(""<TR><TD>License:</TD><TD>"" + license + ""</TD></TR>"");

		buffer.append(""<TR><TD>Dependencies:</TD>"");
		if (dependencies.isEmpty()) {
			buffer.append(""<TD>none</TD></TR>"");
		} else {
			for (Iterator<String> it = dependencies.iterator(); it.hasNext();) {
				buffer.append(""<TD>"" + it.next() + ""</TD></TR>"");
				if (it.hasNext()) {
					buffer.append(""<TR><TD> </TD>"");
				}
			}
		}
		buffer.append(""<TR><TD>Conflicts:</TD>"");
		if (conflicts.isEmpty()) {
			buffer.append(""<TD>none</TD></TR>"");
		} else {
			for (Iterator<String> it = conflicts.iterator(); it.hasNext();) {
				buffer.append(""<TD>"" + it.next() + ""</TD></TR>"");
				if (it.hasNext()) {
					buffer.append(""<TR><TD> </TD>"");
				}
			}
		}

		buffer.append(""</TABLE></HTML>"");

		return buffer.toString();
	}

	public int compareTo(PackageDescriptor pack) {
		if (pack.name.equals(name)) {
			if (version.equals(pack.version)) {
				return os.compareTo(pack.os);
			}
			return -version.compareTo(pack.version);
		}
		return name.compareTo(pack.name);
	}
}
"
PackageManager.java,framework,"package org.processmining.framework.packages;

import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.HttpURLConnection;
import java.net.MalformedURLException;
import java.net.URL;
import java.net.URLConnection;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.SortedSet;
import java.util.TreeSet;
import java.util.prefs.BackingStoreException;
import java.util.prefs.Preferences;

import javax.xml.parsers.ParserConfigurationException;

import org.apache.commons.compress.archivers.zip.ZipArchiveEntry;
import org.apache.commons.compress.archivers.zip.ZipFile;
import org.processmining.framework.boot.Boot;
import org.processmining.framework.boot.Boot.Level;
import org.processmining.framework.packages.events.PackageManagerListener;
import org.processmining.framework.packages.impl.CancelledException;
import org.processmining.framework.packages.impl.PackageConfigPerister;
import org.processmining.framework.plugin.impl.PluginCacheEntry;
import org.processmining.framework.plugin.impl.PluginManagerImpl;
import org.processmining.framework.util.OsUtil;
import org.xml.sax.SAXException;

/*
 * Package manager goals: - Packages are completely independent from plugins and
 * are simply a distribution mechanism - Easy to provide a package as a single
 * zip or jar file, with an xml description file - Easy addition of custom
 * repositories - Transparent caching of packages - Transparent use in
 * development - Should be possible to depend on / resolve packages in an Ant
 * script - Should be easy to develop a package in Eclipse - Versions need to be
 * managed and version conflicts need to be resolved - Handles (possibly
 * transitive and circular) dependencies - Cleaning out all files from the
 * package directory of packages which are de-installed
 * 
 * @author peter
 */
public class PackageManager {
	private final static String DO_AUTO_UPDATES = ""do_auto_updates"";
	private static final String LITE_VERSION_INSTALLED = ""lite_version_installed"";

	public static interface Canceller {
		public boolean isCancelled();
	}

	private static final String TEMP_INSTALL_DIR_POSTFIX = ""-temp-install-dir"";
	private static final String CONFIG_XML = ""packages.xml"";

	private static final String nl = System.getProperty(""line.separator"");

	private static final int UNIX_OWNER_EXECUTABLE_BIT = 64;

	private static PackageManager instance = null;
	private final Set<Repository> repositories = new HashSet<Repository>();
	private final PackageSet installed = new PackageSet();
	private final PackageSet available = new PackageSet();

	/*
	 * Maps every package descriptor to whether it is still available. This map
	 * acts as a cache to prevent us from have to access the URL over and over
	 * again.
	 * 
	 * This map is also used by PackageConfigPersiter when writing the packages
	 * to the local repo again. As a result, packages that are known to be
	 * unavailable will not be written back to the local repo.
	 */
	private Map<PackageDescriptor, Boolean> availability;
	
	/**
	 * Checks whether a package is still available. This prevents the user from
	 * installing or updating a package that cannot be installed anymore.
	 * 
	 * @param descriptor
	 *            The descriptor of the package.
	 * @return Whether the URL of the package descriptor can be opened
	 *         successfully.
	 */
	public boolean isAvailable(PackageDescriptor descriptor) {
		if (!Boot.CHECK_PACKAGES) {
			return true;
		}
		/*
		 * First check the cache.
		 */
		if (availability.containsKey(descriptor)) {
			/*
			 * In cache, return cached result.
			 */
			return availability.get(descriptor);
		}
		/*
		 * Not in cache, check whether URL still exists.
		 */
		InputStream is = null;
		try {
			URL url = new URL(descriptor.getURL());
			URLConnection conn = url.openConnection();
			if (conn instanceof HttpURLConnection) {
				HttpURLConnection httpCon = (HttpURLConnection) conn;
				if (Boot.CONNECT_TIMEOUT > 0) {
					httpCon.setConnectTimeout(Boot.CONNECT_TIMEOUT);
				}
				if (Boot.READ_TIMEOUT > 0) {
					httpCon.setReadTimeout(Boot.READ_TIMEOUT);
				}
				//					httpCon.connect();
			}

			is = conn.getInputStream();
		} catch (Exception e) {
			/*
			 * Something's wrong with this URL. Mark it as unavailable.
			 */
			System.err.println(""Package found in local repository, but not in global repository: "" + descriptor);
			availability.put(descriptor, false);
			return false;
		} finally {
			try {
				is.close();
			} catch (Exception e) {
			}
		}
		//		System.out.println(""Package available: ""+ descriptor);
		/*
		 * All fine, still available. Mark it as such.
		 */
		availability.put(descriptor, true);
		return true;
	}

	private PackageManager() {
		availability = new HashMap<PackageDescriptor, Boolean>();
	}

	private final PackageManagerListener.ListenerList listeners = new PackageManagerListener.ListenerList();
	private PackageStateReport report = null;
	private Canceller canceller = null;
	private boolean doAutoUpdate = false;
	private Preferences preferences = Preferences.userNodeForPackage(getClass());

	public static PackageManager getInstance() {
		if (instance == null) {
			instance = new PackageManager();
		}
		return instance;
	}

	public static void main(String[] args) {
		System.exit(new CommandLineInterface(getInstance()).run(args));
	}

	private File getConfigFile() {
		return new File(OsUtil.getProMPackageDirectory(), CONFIG_XML);
	}

	public void addListener(PackageManagerListener listener) {
		listeners.add(listener);
	}

	public void removeListener(PackageManagerListener listener) {
		listeners.remove(listener);
	}

	public File getPackagesDirectory() {
		return new File(Boot.PACKAGE_FOLDER);
	}

	public void initialize(Boot.Level verbose) {

		doAutoUpdate = Boolean.parseBoolean(preferences.get(DO_AUTO_UPDATES, Boolean.FALSE.toString()));

		String liteVersion = preferences.get(LITE_VERSION_INSTALLED, ""UNKNOWN"");
		if (Boot.PROM_VERSION.startsWith(Boot.LITE_PREFIX) && !liteVersion.equals(Boot.PROM_VERSION)) {
			preferences.put(LITE_VERSION_INSTALLED, Boot.PROM_VERSION);
			if (verbose == Level.ALL) {
				System.out.println("">>> New ProM-Lite installation found."");
				System.out.println("">>> Clearing package cache."");
			}
			try {
				cleanPackageCache();
			} catch (BackingStoreException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}

		getPackagesDirectory().mkdirs();
		File config = getConfigFile();

		if (verbose == Level.ALL) {
			System.out.println("">>> Loading packages from "" + config.getAbsolutePath());
		}

		try {
			writeDefaultConfigIfNeeded(config);

			repositories.clear();
			available.clear();
			installed.clear();
			PackageConfigPerister.read(config, repositories, available, installed, canceller);
			resolveAllConflicts(verbose);

		} catch (Exception e) {
			listeners.fireException(e);
		}
	}

	private void scanRepositories(Boot.Level verbose) throws ParserConfigurationException, SAXException, IOException {

		final Comparator<Repository> comp = new Comparator<Repository>() {

			public int compare(Repository o1, Repository o2) {
				return o1.getURL().toString().compareTo(o2.getURL().toString());
			}
		};

		Set<Repository> read = new TreeSet<Repository>(comp);
		Set<Repository> toRead = new TreeSet<Repository>(comp);
		toRead.addAll(repositories);

		toRead.add(new Repository(Boot.DEFAULT_REPOSITORY));
		while (!toRead.isEmpty()) {
			for (Repository rep : toRead) {
				URL packages = rep.getURL();
				if (verbose == Level.ALL) {
					System.out.println("">>> Loading packages from "" + packages);
				}
				URLConnection conn = packages.openConnection();
				if (conn instanceof HttpURLConnection) {
					HttpURLConnection httpCon = (HttpURLConnection) conn;
					if (Boot.CONNECT_TIMEOUT > 0) {
						httpCon.setConnectTimeout(Boot.CONNECT_TIMEOUT);
					}
					if (Boot.READ_TIMEOUT > 0) {
						httpCon.setReadTimeout(Boot.READ_TIMEOUT);
					}
					//					httpCon.connect();
				}
				long time = -System.currentTimeMillis();
				try {
					PackageConfigPerister.read(conn.getInputStream(), repositories, available, installed, canceller);
					time += System.currentTimeMillis();
					if (Boot.VERBOSE == Level.ALL) {
						System.out.println(""Read package in "" + time + "" milliseconds."");
					}
				} catch (FileNotFoundException e) {
					// did not find the file for some package
					time += System.currentTimeMillis();
					if (Boot.VERBOSE != Level.NONE) {
						System.err.println(""Failed to read package (file not found)."");
					}
				} catch (IOException e) {
					time += System.currentTimeMillis();
					if (Boot.VERBOSE != Level.NONE) {
						System.err.println(""Failed to read package in "" + time + "" milliseconds."");
					}
				}
			}
			read.addAll(toRead);
			toRead.clear();
			toRead.addAll(repositories);
			toRead.removeAll(read);
		}

	}

	private void writeDefaultConfigIfNeeded(File config) throws IOException {
		config.createNewFile();
		if (config.length() == 0) {
			PackageConfigPerister
					.write(config,
							new HashSet<Repository>(Arrays.asList(new Repository[] { new Repository(
									Boot.DEFAULT_REPOSITORY) })), new HashSet<PackageDescriptor>(),
							new HashSet<PackageDescriptor>());
		}
	}

	private void resolveAllConflicts(Boot.Level verbose) throws UnknownPackageException {
		boolean ok;

		do {
			ok = true;

			Map<String, PackageDescriptor> enabled = new HashMap<String, PackageDescriptor>();
			for (PackageDescriptor pack : getEnabledPackages()) {
				enabled.put(pack.getName(), pack);
			}
			for (PackageDescriptor pack : enabled.values()) {
				for (String dep : pack.getDependencies()) {
					PackageDescriptor p = enabled.get(dep);

					if (p == null) {
						pack.setHasBrokenDependencies();
						ok = false;

						if (verbose == Level.ALL) {
							System.out.println(""     deactivating: "" + pack + "" (missing at least "" + dep + "")"");
						}
						break;
					}
				}
				for (String conf : pack.getConflicts()) {
					PackageDescriptor p = enabled.get(conf);

					if (p != null) {
						pack.setHasBrokenDependencies();
						ok = false;

						if (verbose == Level.ALL) {
							System.out
									.println(""     deactivating: "" + pack + "" (conflicts with at least "" + conf + "")"");
						}
						break;
					}
				}
			}
		} while (!ok);
	}

	public String toString() {
		StringBuffer result = new StringBuffer();
		Set<PackageDescriptor> allPackages = new HashSet<PackageDescriptor>();

		for (Repository repo : repositories) {
			result.append(""Repository: "" + repo.getURL() + nl);
		}

		allPackages.addAll(installed);
		allPackages.addAll(available);
		for (PackageDescriptor pack : allPackages) {
			String status;

			if (installed.contains(pack)) {
				if (!pack.hasBrokenDependencies()) {
					status = ""I"";
				} else {
					status = ""M"";
				}
				boolean hasUpgrade = false;
				if (available.contains(pack)) {
					for (PackageDescriptor p : available) {
						if (p.equals(pack)) {
							hasUpgrade = pack.getVersion().lessThan(p.getVersion());
							break;
						}
					}
				}
				status += hasUpgrade ? ""+"" : "" "";
			} else {
				status = ""A "";
			}
			result.append(status + "" "" + pack);
			result.append(nl);
			if (!pack.getDependencies().isEmpty()) {
				result.append(""      (depends on: "" + pack.getDependencies() + "")"" + nl);
			}
			if (!pack.getConflicts().isEmpty()) {
				result.append(""      (conflicts with: "" + pack.getConflicts() + "")"" + nl);
			}
		}
		return result.toString();
	}

	public Set<Repository> getRepositories() {
		return Collections.unmodifiableSet(repositories);
	}

	//	public void addRepository(Repository repository) {
	//		repositories.add(repository);
	//		save();
	//	}

	public void removeRepository(Repository repository) {
		repositories.remove(repository);
		save();
	}

	public Set<PackageDescriptor> getInstalledPackages() {
		return Collections.unmodifiableSet(installed);
	}

	public Set<PackageDescriptor> getAvailablePackages() {
		return Collections.unmodifiableSet(available);
	}

	public Collection<PackageDescriptor> getEnabledPackages() throws UnknownPackageException {
		List<PackageDescriptor> result = new ArrayList<PackageDescriptor>();

		Set<PackageDescriptor> broken = new HashSet<PackageDescriptor>();

		Set<PackageDescriptor> installed = new HashSet<PackageDescriptor>(this.installed);

		/*
		 * During every iteration we should be able to add at least one package
		 * to the result set. Hence, we should need at most as many iterations
		 * as we have packages to add. If after this number if iterations some
		 * packages have not yet been added, there should be a cyclic dependency
		 * somewhere between the remaining packages.
		 * 
		 * Initialize the number of iterations we have still left.
		 */
		int iterationsLeft = installed.size();

		/*
		 * Iterate as long as needed.
		 */
		while (!installed.isEmpty() && iterationsLeft > 0) {
			Set<String> requiredPackages = new HashSet<String>();

			Iterator<PackageDescriptor> it = installed.iterator();
			while (it.hasNext()) {
				PackageDescriptor pack = it.next();
				if (pack.hasBrokenDependencies()) {
					broken.add(pack);
					it.remove();
				} else {

					if (getPackageMap(result).keySet().containsAll(pack.getDependencies())) {
						result.add(pack);
						it.remove();
					} else {
						// remember all packages that have been required
						requiredPackages.addAll(pack.getDependencies());
					}
				}
			}

			// after this iteration check whether we have any chance to resolve
			// the remaining dependencies: if not, throw an exception
			Set<String> listedPackages = new HashSet<String>(getPackageMap(this.installed).keySet());
			requiredPackages.removeAll(listedPackages);
			if (!requiredPackages.isEmpty()) {
				for (String required : requiredPackages) {
					System.out.println(""Cannot find required package: "" + required);
				}
				throw new UnknownPackageException(requiredPackages.toString());
			}
			/*
			 * One less iteration left.
			 */
			iterationsLeft--;
		}

		if (installed.isEmpty()) {
			if (Boot.VERBOSE == Level.ALL) {
				System.out.println("">>> All dependencies have been resolved"");
			}
		} else {
			if (Boot.VERBOSE != Level.NONE) {
				System.err.println("">>> The dependencies for the following packages have not been resolved:"");
				for (PackageDescriptor pack : installed) {
					System.err.println("">>>     "" + pack + "" "" + pack.getDependencies());
				}
			}
		}

		return result;
	}

	private void save() {
		try {
			PackageConfigPerister.write(getConfigFile(), repositories, available, installed);
		} catch (IOException e) {
			listeners.fireException(e);
			return;
		}
	}

	public void update(boolean autoInstall, Boot.Level verbose) throws CancelledException, UnknownPackageTypeException {

		try {
			scanRepositories(verbose);
		} catch (Exception e) {
			// continue with known repositories
			e.printStackTrace();
		}
		Map<String, SortedSet<PackageDescriptor>> map = PackageManager.getPackageMap(available);

		Set<PackageDescriptor> packs = new HashSet<PackageDescriptor>();

		// TODO allow clients to monitor progress and report errors

		//		for (Repository repository : repositories) {
		//			if ((canceller != null) && canceller.isCancelled()) {
		//				return;
		//			}
		//			System.out.println(""Updating: "" + repository);
		//			try {
		//				InputStream is = repository.getURL().openStream();
		//
		//				try {
		//					packs.addAll(PackageConfigPerister.listRepository(is, canceller));
		//				} catch (ParserConfigurationException e) {
		//					listeners.fireException(e);
		//					throw new CancelledException();
		//				} catch (CancelledException e) {
		//					throw e;
		//				} catch (SAXException e) {
		//					listeners.fireException(e);
		//					throw new CancelledException();
		//				} finally {
		//					is.close();
		//				}
		//			} catch (IOException e) {
		//				listeners.fireException(e);
		//				throw new CancelledException();
		//			}
		//			System.out.println(""Done updating: "" + repository);
		//		}
		//
		//		available.clear();
		//		available.addAll(packs);

		if (autoInstall) {
			List<PackageDescriptor> toRemove = new ArrayList<PackageDescriptor>();
			List<PackageDescriptor> toInstall = new ArrayList<PackageDescriptor>();
			for (PackageDescriptor pack : packs) {
				PackageDescriptor inst = findInstalledVersion(pack);
				if ((inst != null) && inst.getVersion().lessThan(pack.getVersion())) {
					// package was already installed, but new version is available.
					// old version remains, just in case this is required by some
					// existing plugins.
					System.out.println(""Found new version of installed package: "" + pack.getName());
					toInstall.add(pack);
					toRemove.add(inst);
				} else if ((inst == null) && pack.hasPlugins()) {
					// Install all available packages that carry plugins.
					System.out.println(""Found new package which contains plugins: "" + pack.getName());
					toInstall.add(pack);
					for (String dep : pack.getDependencies()) {
						if (!containsPackage(installed, dep)) {
							SortedSet<PackageDescriptor> packages = map.get(dep);
							if ((packages == null) || packages.isEmpty()) {
								toInstall.remove(pack);
								continue;
							}
							boolean found = false;
							for (PackageDescriptor p : packages) {
								toInstall.add(p);
								found = true;
								break;
							}
							if (!found) {
								toInstall.remove(pack);
							}

						}
					}
				}
			}
			if (!toInstall.isEmpty()) {
				System.out.println(""Installing packages: "" + toInstall.toString());
				install(toInstall);
				uninstall(toRemove);
				// execute does a save, no need to do that twice.
			} else {
				save();
			}
		} else {
			save();
		}
	}

	public PackageDescriptor findInstalledVersion(PackageDescriptor pack) {
		for (PackageDescriptor p : installed) {
			if (p.getName().equals(pack.getName())) {
				return p;
			}
		}
		return null;
	}

	public PackageDescriptor[] findOrInstallPackages(String... packageNames) throws UnknownPackageTypeException,
			UnknownPackageException, CancelledException {

		if (doAutoUpdate) {
			update(false, Level.NONE);
		}

		PackageDescriptor[] result = new PackageDescriptor[packageNames.length];
		List<PackageDescriptor> toInstall = new ArrayList<PackageDescriptor>(result.length);

		// First, consider all available packages
		Map<String, SortedSet<PackageDescriptor>> map = PackageManager.getPackageMap(available);

		// Check for each package if it might be installed
		for (int i = 0; i < packageNames.length; i++) {
			SortedSet<PackageDescriptor> packages = map.get(packageNames[i]);
			if ((packages == null) || packages.isEmpty()) {
				// No package is available with the name: names[i]
				throw new UnknownPackageException(packageNames[i]);
			}

			// Use the first available package for this name.
			// If there are more, they are sorted by 
			// version, latest version first.
			result[i] = packages.first();
			if (!doAutoUpdate) {
				// See if any of the versions is installed. If not,
				// install the latest
				for (PackageDescriptor d : packages) {
					if (installed.contains(d)) {
						result[i] = d;
						break;
					}
				}
			}
			if (!installed.contains(result[i])) {
				toInstall.add(result[i]);
			}

		}
		if (!toInstall.isEmpty()) {
			// Install some packages that were available, but not installed
			install(toInstall);
		}

		return result;
	}

	public void install(List<PackageDescriptor> toInstall) throws UnknownPackageTypeException, CancelledException {
		if ((canceller != null) && canceller.isCancelled()) {
			throw new CancelledException();
		}
		boolean exception = false;
		try {
			listeners.fireSessionStart();
			Set<PackageDescriptor> toAdd = new HashSet<PackageDescriptor>(toInstall);

			Map<String, SortedSet<PackageDescriptor>> map = PackageManager.getPackageMap(available);

			// TODO: rewrite these statements to take care of versions.
			//			// These need to be added
			//			toAdd.removeAll(getInstalledPackages());
			//			// No need to install packages that need to be removed anyway
			//			toAdd.removeAll(toRemove);

			Set<PackageDescriptor> newState = new HashSet<PackageDescriptor>(getInstalledPackages());
			newState.addAll(toAdd);

			checkConsistency(newState);
			boolean error = false;
			do {
				HashSet<String> extra = new HashSet<String>();
				for (Map.Entry<PackageDescriptor, Set<String>> item : report.getMissingDependencies().entrySet()) {
					extra.addAll(item.getValue());
				}
				if (!extra.isEmpty()) {
					for (String s : extra) {
						if (!map.containsKey(s) || map.get(s) == null) {
							// package required that is not available, break.
							error = true;
							System.err.println(""[PackageManager] Package "" + s + "" is not available."");
						} else {
							PackageDescriptor first = map.get(s).first();
							toAdd.add(first);
							newState.add(first);
						}
					}
					checkConsistency(newState);
				}
			} while (!error && !report.getMissingDependencies().isEmpty());

			HashSet<PackageDescriptor> toRemove = new HashSet<PackageDescriptor>();
			while (!error && !report.getPackagesWithMultipleVersions().isEmpty()) {
				// Resolved all dependencies, now check for multiple versions.
				for (Map.Entry<String, SortedSet<PackageDescriptor>> item : report.getPackagesWithMultipleVersions()
						.entrySet()) {
					Iterator<PackageDescriptor> it = item.getValue().iterator();
					it.next();
					while (it.hasNext()) {
						PackageDescriptor p = it.next();
						newState.remove(p);
						toRemove.add(p);
					}
				}
				checkConsistency(newState);
			}

			if (!report.hasErrors()) {
				for (PackageDescriptor pack : toAdd) {
					installPackage(pack);
				}

				installed.clear();
				installed.addAll(newState);

				uninstall(toRemove);

				save();

			}

		} catch (UnknownPackageTypeException e) {
			exception = true;
			throw e;
		} catch (CancelledException e) {
			exception = true;
			throw e;
		} finally {

			// Before propagating the error, make sure to signal the listeners of this error.
			listeners.fireSessionComplete(exception);
		}

	}

	public void uninstall(Collection<PackageDescriptor> toRemove) throws CancelledException {
		if ((canceller != null) && canceller.isCancelled()) {
			throw new CancelledException();
		}

		Set<PackageDescriptor> newState = new HashSet<PackageDescriptor>(getInstalledPackages());
		newState.removeAll(toRemove);

		checkConsistency(newState);
		boolean error = false;
		do {
			// All packages that now have broken dependencies should also be uninstalled
			newState.removeAll(report.getMissingDependencies().keySet());
			checkConsistency(newState);
		} while (!error && !report.getMissingDependencies().isEmpty());

		if (!report.hasErrors()) {

			removePackages(newState);

			installed.clear();
			installed.addAll(newState);

			save();

		}

	}

	public void setCanceller(Canceller canceller) {
		this.canceller = canceller;

	}

	public PackageStateReport getLatestReport() {
		synchronized (report) {
			return report;
		}
	}

	public void checkConsistency() {
		checkConsistency(getInstalledPackages());
	}

	private void checkConsistency(Set<PackageDescriptor> packages) {
		Map<String, SortedSet<PackageDescriptor>> multipleVersions = new HashMap<String, SortedSet<PackageDescriptor>>();
		Map<PackageDescriptor, Set<String>> missing = new HashMap<PackageDescriptor, Set<String>>();
		Map<PackageDescriptor, Set<String>> conflicts = new HashMap<PackageDescriptor, Set<String>>();

		// check whether at most one version of each package is installed
		for (Map.Entry<String, SortedSet<PackageDescriptor>> item : getPackageMap(packages).entrySet()) {
			if (item.getValue().size() > 1) {
				SortedSet<PackageDescriptor> versions = multipleVersions.get(item.getKey());

				if (versions == null) {
					versions = new TreeSet<PackageDescriptor>();
					multipleVersions.put(item.getKey(), versions);
				}
				versions.addAll(item.getValue());
			}
		}

		// check whether all dependencies are satisfied
		for (PackageDescriptor pack : packages) {
			for (String dep : pack.getDependencies()) {
				if (!containsPackage(packages, dep)) {
					Set<String> misses = missing.get(pack);

					if (misses == null) {
						misses = new HashSet<String>();
						missing.put(pack, misses);
					}
					misses.add(dep);
				}
			}
		}

		// check whether all conflicts are satisfied
		for (PackageDescriptor pack : packages) {
			for (String conf : pack.getConflicts()) {
				if (containsPackage(packages, conf)) {
					Set<String> conflictsWith = conflicts.get(pack);

					if (conflictsWith == null) {
						conflictsWith = new HashSet<String>();
						conflicts.put(pack, conflictsWith);
					}
					conflictsWith.add(conf);
				}
			}
		}

		report = new PackageStateReport(multipleVersions, missing, conflicts);
	}

	private boolean containsPackage(Set<PackageDescriptor> packages, String dep) {
		for (PackageDescriptor pack : packages) {
			if (dep.equals(pack.getName())) {
				return true;
			}
		}
		return false;
	}

	public static Map<String, SortedSet<PackageDescriptor>> getPackageMap(Collection<PackageDescriptor> packages) {
		Map<String, SortedSet<PackageDescriptor>> result = new HashMap<String, SortedSet<PackageDescriptor>>();

		for (PackageDescriptor pack : packages) {
			SortedSet<PackageDescriptor> list = result.get(pack.getName());

			if (list == null) {
				list = new TreeSet<PackageDescriptor>();
				result.put(pack.getName(), list);
			}
			list.add(pack);
		}
		return result;
	}

	private void installPackage(PackageDescriptor pack) throws UnknownPackageTypeException, CancelledException {
		File packageDir = pack.getLocalPackageDirectory();
		File tempDir = new File(packageDir.getAbsolutePath() + TEMP_INSTALL_DIR_POSTFIX);
		URL url;
		try {
			url = new URL(pack.getURL());
		} catch (MalformedURLException e) {
			listeners.fireException(e);
			return;
		}

		recursivelyDeleteDir(tempDir);
		recursivelyDeleteDir(packageDir);

		tempDir.mkdirs();
		packageDir.mkdirs();

		if (url.toString().toLowerCase().endsWith("".jar"")) {
			installJar(url, packageDir, pack.getName() + ""-"" + pack.getVersion(), pack);
		} else if (url.toString().toLowerCase().endsWith("".zip"")) {
			installZip(url, tempDir, packageDir, pack.getName() + ""-"" + pack.getVersion(), pack);
		} else {
			throw new UnknownPackageTypeException(pack);
		}
		if (PluginManagerImpl.getInstance() != null) {
			Boot.addJarsForPackage(pack, Level.ALL, PluginManagerImpl.getInstance());
		}
		recursivelyDeleteDir(tempDir);
	}

	private void removePackages(Collection<PackageDescriptor> toKeep) throws CancelledException {
		if ((canceller != null) && canceller.isCancelled()) {
			throw new CancelledException();
		}
		File packageDir = getPackagesDirectory();
		File[] files = packageDir.listFiles();
		Set<File> installations = new HashSet<File>();

		for (PackageDescriptor pack : toKeep) {
			if ((canceller != null) && canceller.isCancelled()) {
				throw new CancelledException();
			}
			installations.add(pack.getLocalPackageDirectory());
		}

		if (files != null) {
			for (File file : files) {
				if (!file.isDirectory()) {
					file.delete();
				} else if (!installations.contains(file)) {
					recursivelyDeleteDir(file);
				}
			}
		}
	}

	/*
	 * private Set<PackageDescriptor>
	 * findReverseDependenciesInInstalled(PackageDescriptor pack) { return
	 * findReverseDependencies(pack, installed); }
	 * 
	 * private Set<PackageDescriptor>
	 * findDependenciesInAvailable(PackageDescriptor pack,
	 * Set<PackageVersionRange> missing) { return findDependencies(pack,
	 * missing, available); }
	 * 
	 * private static Set<PackageDescriptor> findDependencies(PackageDescriptor
	 * pack, Set<PackageVersionRange> missing, Set<PackageDescriptor> packages)
	 * { Set<PackageDescriptor> result = new HashSet<PackageDescriptor>();
	 * Set<PackageVersionRange> todo = new HashSet<PackageVersionRange>();
	 * Set<PackageVersionRange> done = new HashSet<PackageVersionRange>();
	 * 
	 * while (!todo.isEmpty()) { PackageVersionRange dep =
	 * todo.iterator().next(); boolean found = false;
	 * 
	 * todo.remove(dep); done.add(dep);
	 * 
	 * for (PackageDescriptor p : packages) { if (dep.isSatisfiedBy(p)) {
	 * result.add(p); found = true; for (PackageVersionRange r :
	 * p.getDependencies()) { if (!done.contains(r)) { todo.add(r); } } break; }
	 * } if (!found) { missing.add(dep); } } return result; }
	 * 
	 * private static Set<PackageDescriptor>
	 * findReverseDependencies(PackageDescriptor pack, Set<PackageDescriptor>
	 * packages) { Set<PackageDescriptor> result = new
	 * HashSet<PackageDescriptor>();
	 * 
	 * for (PackageDescriptor p : packages) { Set<PackageVersionRange> missing =
	 * new HashSet<PackageVersionRange>(); Set<PackageDescriptor> deps =
	 * findDependencies(p, missing, packages);
	 * 
	 * if (deps.contains(pack)) { result.add(p); } } return result; }
	 */

	private void installZip(URL source, File temp, File unzipTo, String name, PackageDescriptor pack)
			throws CancelledException {
		File sourceZipFile = new File(temp, "".package.zip"");

		// download zip file

		listeners.fireStartDownload(name, source, pack);
		OutputStream out = null;
		try {
			out = new BufferedOutputStream(new FileOutputStream(sourceZipFile));
			copyInputStream(source.openStream(), out);
		} catch (Exception e) {
			listeners.fireException(e);
			throw new CancelledException();
		} finally {
			if (out != null) {
				try {
					out.close();
				} catch (IOException e) {
					throw new CancelledException();
				}
			}

		}

		listeners.fireStartInstall(name, unzipTo, pack);

		try {
			// extract zip file
			ZipFile zipFile = new ZipFile(sourceZipFile);
			Enumeration<?> zipFileEntries = zipFile.getEntries();

			while (zipFileEntries.hasMoreElements()) {
				ZipArchiveEntry entry = (ZipArchiveEntry) zipFileEntries.nextElement();
				File destFile = new File(unzipTo, entry.getName());

				if (entry.isDirectory()) {
					destFile.mkdirs();
				} else {
					destFile.getParentFile().mkdirs();

					OutputStream o = new FileOutputStream(destFile);
					try {
						copyInputStream(zipFile.getInputStream(entry), o);
					} finally {
						o.close();
					}

					//Only for non-windows operating systems: Check if the executable bit was set in the zip-archive,
					//if so, set it on the file system too. (Only checks and sets the owner executable bit.)
					if (!OsUtil.isRunningWindows()
							&& (entry.getUnixMode() & UNIX_OWNER_EXECUTABLE_BIT) == UNIX_OWNER_EXECUTABLE_BIT) {
						destFile.setExecutable(true);
					}
				}

			}
			zipFile.close();
		} catch (Exception e) {
			listeners.fireException(e);
			throw new CancelledException();
		}
		listeners.fireFinishedInstall(name, unzipTo, pack);
	}

	private void installJar(URL source, File dest, String name, PackageDescriptor pack) throws CancelledException {
		InputStream in = null;
		try {
			in = source.openStream();

			OutputStream out = null;
			File outFile = new File(dest, name + "".jar"");
			try {
				out = new FileOutputStream(outFile);
			} catch (FileNotFoundException e) {
				listeners.fireException(e);
				return;
			} finally {
				if (out != null) {
					out.close();
				}
			}
			listeners.fireStartDownload(name, source, pack);
			copyInputStream(in, out);
			listeners.fireStartInstall(name, outFile, pack);

			in.close();
			listeners.fireFinishedInstall(name, outFile, pack);
		} catch (IOException e) {
			listeners.fireException(e);
			throw new CancelledException();
		}
	}

	private void recursivelyDeleteDir(File dir) {
		if (dir.isDirectory()) {
			for (String child : dir.list()) {
				recursivelyDeleteDir(new File(dir, child));
			}
		}
		dir.delete();
	}

	private void copyInputStream(InputStream in, OutputStream out) throws IOException, CancelledException {
		try {
			byte[] buffer = new byte[1024];
			int len;

			while ((len = in.read(buffer)) >= 0) {
				if ((canceller != null) && canceller.isCancelled()) {
					throw new CancelledException();
				}
				out.write(buffer, 0, len);
			}
		} finally {
			try {
				in.close();
			} finally {
				out.close();
			}
		}
	}

	public PackageManagerListener.ListenerList getListeners() {
		return listeners;
	}

	@Deprecated
	public boolean doAutoUpdate() {
		return doAutoUpdate;
	}

	@Deprecated
	public void setAutoUpdate(boolean doAutoUpdate) {
		this.doAutoUpdate = doAutoUpdate;
		this.preferences.put(DO_AUTO_UPDATES, Boolean.toString(doAutoUpdate));

	}

	/**
	 * Cleans the package cache in the registry. This is automatically done for
	 * ProM-Lite the first time when a new version of ProM-Lite is booted.
	 * 
	 * @throws BackingStoreException
	 */
	public void cleanPackageCache() throws BackingStoreException {
		PluginCacheEntry.clearSettingsCache();

	}
}
"
PackageSet.java,framework,"package org.processmining.framework.packages;

import java.util.HashSet;

import org.processmining.framework.packages.PackageDescriptor.OS;

public class PackageSet extends HashSet<PackageDescriptor> {

	private static final long serialVersionUID = -5010658216636461231L;

	public boolean add(PackageDescriptor e) {
		if (e.getOS() == OS.WIN64) {
			// check for removal of Win32 version
			for (PackageDescriptor pack : this) {
				if (pack.getName().equals(e.getName()) && //
						pack.getVersion().equals(e.getVersion()) && //
						pack.getOS() == OS.WIN32) {
					remove(pack);
					break;
				}
			}
		} else {
			if (e.getOS() == OS.WIN32) {
				// Check if Win64 version already in the set
				for (PackageDescriptor pack : this) {
					if (pack.getName().equals(e.getName()) && //
							pack.getVersion().equals(e.getVersion()) && //
							pack.getOS() == OS.WIN64) {
						// win64 version already available. Don't add 32 bit version.
						return false;
					}
				}
			}
		}
		return super.add(e);
	}
}
"
PackageStateReport.java,framework,"package org.processmining.framework.packages;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.SortedSet;

public class PackageStateReport {

	private final Map<PackageDescriptor, Set<String>> missing;
	private final Map<PackageDescriptor, Set<String>> conflicts;
	private final Map<String, SortedSet<PackageDescriptor>> multipleVersions;

	public PackageStateReport(Map<String, SortedSet<PackageDescriptor>> multipleVersions,
			Map<PackageDescriptor, Set<String>> missing, Map<PackageDescriptor, Set<String>> conflicts) {
		this.multipleVersions = multipleVersions;
		this.conflicts = conflicts;
		this.missing = missing;
	}

	public Map<PackageDescriptor, Set<String>> getMissingDependencies() {
		return missing;
	}

	public Map<PackageDescriptor, Set<String>> getConflictingPackages() {
		return conflicts;
	}

	public Map<String, SortedSet<PackageDescriptor>> getPackagesWithMultipleVersions() {
		return multipleVersions;
	}

	public String toString() {
		List<String> lines = new ArrayList<String>();

		for (Map.Entry<String, SortedSet<PackageDescriptor>> item : getPackagesWithMultipleVersions().entrySet()) {
			lines.add(""Package "" + item.getKey() + "" has or will have multiple versions installed:"");
			for (PackageDescriptor p : item.getValue()) {
				lines.add(""  "" + p);
			}
		}
		for (Map.Entry<PackageDescriptor, Set<String>> item : getMissingDependencies().entrySet()) {
			lines.add(""Package "" + item.getKey() + "" depends on packages which are and will not be installed:"");
			for (String dep : item.getValue()) {
				lines.add(""  "" + dep);
			}
		}
		for (Map.Entry<PackageDescriptor, Set<String>> item : getConflictingPackages().entrySet()) {
			lines.add(""Package "" + item.getKey() + "" conflicts with packages which are or will be installed:"");
			for (String confl : item.getValue()) {
				lines.add(""  "" + confl);
			}
		}

		StringBuffer result = new StringBuffer();
		for (String s : lines) {
			result.append(s);
			result.append(System.getProperty(""line.separator""));
		}
		return result.toString();
	}

	public boolean hasErrors() {
		return !getConflictingPackages().isEmpty() || !getMissingDependencies().isEmpty()
				|| !getPackagesWithMultipleVersions().isEmpty();
	}
}
"
PackageVersion.java,framework,"package org.processmining.framework.packages;

import java.util.ArrayList;
import java.util.List;

public class PackageVersion implements Comparable<PackageVersion> {

	private final List<Integer> version;

	public PackageVersion(String version) {
		this.version = parse(version);
	}

	private List<Integer> parse(String v) {
		List<Integer> result = new ArrayList<Integer>();
		String[] components = v.split(""[^0-9]"");

		for (String c : components) {
			if (c.length() > 0) {
				result.add(Integer.parseInt(c));
			}
		}
		return result;
	}

	public boolean equals(Object o) {
		if (!(o instanceof PackageVersion)) {
			return false;
		}
		return version.equals(((PackageVersion) o).version);
	}

	public int hashCode() {
		return version.hashCode();
	}

	public String toString() {
		String result = new String();

		for (Integer i : version) {
			if (result.length() > 0) {
				result += '.';
			}
			result += i;
		}
		return result;
	}

	public boolean lessOrEqual(PackageVersion v) {
		return compareTo(v) <= 0;
	}

	public boolean lessThan(PackageVersion v) {
		return compareTo(v) < 0;
	}

	public int compareTo(PackageVersion v) {
		for (int i = 0; i < version.size(); i++) {
			if (i < v.version.size()) {
				int self = version.get(i);
				int other = v.version.get(i);

				if (self < other) {
					return -1;
				} else if (self > other) {
					return 1;
				}
			} else {
				return 1;
			}
		}
		return version.size() == v.version.size() ? 0 : -1;
	}
}
"
Repository.java,framework,"package org.processmining.framework.packages;

import java.net.URL;

public class Repository {

	private final URL url;

	public Repository(URL url) {
		this.url = url;
	}

	public URL getURL() {
		return url;
	}

	public String toString() {
		return ""Repository("" + getURL().toString() + "")"";
	}

	public boolean equals(Object other) {
		if (!(other instanceof Repository)) {
			return false;
		}
		return ((Repository) other).getURL().equals(url);
	}

	public int hashCode() {
		return url.hashCode();
	}
}
"
UnknownPackageException.java,framework,"package org.processmining.framework.packages;

public class UnknownPackageException extends Exception {

	/**
	 * 
	 */
	private static final long serialVersionUID = 1037754203430229972L;
	private final String name;

	public UnknownPackageException(String name) {
		super(""Unknow package: "" + name);
		this.name = name;
	}

	public String getName() {
		return name;
	}
}
"
UnknownPackageTypeException.java,framework,"package org.processmining.framework.packages;

public class UnknownPackageTypeException extends Exception {

	private static final long serialVersionUID = -7248277354439798414L;
	private final PackageDescriptor pack;

	public UnknownPackageTypeException(PackageDescriptor pack) {
		super(""Unknow package file type: "" + pack.getURL());
		this.pack = pack;
	}

	public PackageDescriptor getPack() {
		return pack;
	}
}
"
Bootable.java,framework,"package org.processmining.framework.plugin.annotations;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface Bootable {
}
"
CLI.java,framework,"package org.processmining.framework.plugin.annotations;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface CLI {
	String functionName();
}
"
KeepInProMCache.java,framework,"package org.processmining.framework.plugin.annotations;

import java.lang.annotation.ElementType;
import java.lang.annotation.Inherited;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * Annotation that is used as a base annotation for all classes that need to be
 * kept in cache by the ProM framework. When a class carries this annotation,
 * the ProM PluginManager will scan the class during first boot and store the
 * class in the cache for future reference.
 * 
 * This allows ProM to build a mapping from annotations to annotated classes
 * during boot.
 * 
 * @author bfvdonge
 * 
 */

@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Inherited
public @interface KeepInProMCache {

}
"
Plugin.java,framework,"package org.processmining.framework.plugin.annotations;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Retention(RetentionPolicy.RUNTIME)
@Target({ ElementType.METHOD, ElementType.TYPE })
public @interface Plugin {

	/**
	 * Returns the name identifying this plugin in a human readable way.
	 * 
	 * @return
	 */
	String name();

	/**
	 * Returns an Array of strings, such that each String is an initial label
	 * for a returned object. Plugins can change this label during execution.
	 * 
	 * The length of the array should be the same as the length of the
	 * returnTypes array.
	 * 
	 * @return
	 */
	String[] returnLabels();

	/**
	 * Returns an Array of Class objects, such that each class object represents
	 * the type of the returned object at that index, i.e. the plugin should
	 * return as many objects as the length of this array, and each object
	 * should be of the type given in this array.
	 * 
	 * @return
	 */
	Class<?>[] returnTypes();

	/**
	 * Returns the labels of the parameters for this plugin.
	 * 
	 * If the Plugin annotation is used on a method, then the number of elements
	 * in this array should correspond to the number of parameters that the
	 * method requires, not counting the first parameter of type PluginContext.
	 * 
	 * If the plugin annotation is used on a class, then each variant should
	 * indicate which subset of parameters it requires. Each parameter should
	 * appear in at least one variant.
	 * 
	 * Note that the types of the parameters are not specified in the
	 * annotation. Instead they are derived from the method definitions that
	 * contain the logic of this plugin. Parameters can be overloaded, i.e. the
	 * same parameter can have multiple types.
	 * 
	 * @return
	 */
	String[] parameterLabels();

	/**
	 * Returns the help / description for this plugin.
	 * 
	 * @return Empty string as default
	 */
	String help() default """";

	/**
	 * Signals the framework to make this plugin user-accessible. If a plugin is
	 * not user-accessible, it does not show up in any UI
	 * 
	 * @return Defaults to true.
	 */
	boolean userAccessible() default true;

	/**
	 * Returns the index + 1 in the result array of the most significant result
	 * for this plugin, i.e. if the first element in the array is the most
	 * significant, then the value of this parameter should be 1.
	 * 
	 * If the plugin does not return anything interesting itself, but considers
	 * one of it's inputs to be the most significant one, then a negative value
	 * should be returned. I.e. if the first parameter is the most significant
	 * result, a value of -1 has to be returned. Note that this parameter should
	 * always be included in all variants
	 * 
	 * @return the index in the result array of the most significant result. If
	 *         no results are returned by this plugin, anything can be returned.
	 *         Defaults to 1
	 * 
	 */
	int mostSignificantResult() default 1;

	/**
	 * Whether this plugin handles cancel itself. If this is true, the plug-in
	 * will not be killed but is allowed to terminate itself by monitoring
	 * isCancelled.
	 * 
	 * @return
	 */
	boolean handlesCancel() default false;

	/**
	 * Categories define the 'type' of functionality the plugin provides.
	 */
	PluginCategory[] categories() default { PluginCategory.Analytics };

	/**
	 * Keywords / tags for the plugin (extra description)
	 */
	String[] keywords() default {};
	
	/**
	 * Indication of quality for plug-in.
	 * @return
	 */
	PluginQuality quality() default PluginQuality.VeryPoor;
	/**
	 * Indication of level for plug-in.
	 * @return
	 */
	PluginLevel level() default PluginLevel.NightlyBuild;
	
	String icon() default """";
	String url() default """";
}
"
PluginCategory.java,framework,"package org.processmining.framework.plugin.annotations;

/**
 * Plugin Category
 * 
 * @author mleemans
 * 
 *         Possible categories specifying the 'type' of functionality the plugin
 *         provides.
 */
public enum PluginCategory {
	Discovery( //
			""Discovery"", //
			""Discovery plugin constructs a model from a given event log"", //
			""action_filter_discovery_20x20.png""), //
	ConformanceChecking( //
			""Conformance Checking"", //
			""Conformance checking plugin check conformance between a given a model and a given event log"", //
			""action_filter_conformance_20x20.png""), //
	Enhancement( //
			""Enhancement"", //
			""Enhancement plugin enhances a given model using a given log"", //
			""action_filter_enhancement_20x20.png""), //
	Filtering( //
			""Filtering"", //
			""Filtering plugin filters or clusters a given log"", //
			""action_filter_filtering_20x20.png""), //
	Analytics( //
			""Analytics"", //
			""Analytic plugin provides additional analysis for a given log"", //
			""action_filter_analytics_20x20.png"");

	private final String name;
	private final String description;
	private final String imageFilterFilename;

	private PluginCategory(String name, String description, String imageFilterFilename) {
		this.name = name;
		this.description = description;
		this.imageFilterFilename = imageFilterFilename;
	}

	public String getName() {
		return name;
	}

	public String getDescription() {
		return description;
	}

	public String getImageFilterFilename() {
		return imageFilterFilename;
	}

}
"
PluginLevel.java,framework,"package org.processmining.framework.plugin.annotations;

public enum PluginLevel {
	Local( //
			""Local"", //
			1), //
	NightlyBuild( //
			""NightlyBuild"", //
			2), //
	Regular( //
			""Regular"", //
			3), //
	PeerReviewed( //
			""PeerReviewed"", //
			4), //
	BulletProof( //
			""BulletProof"", //
			5);

	private final String name;
	private final int value;

	private PluginLevel(String name, int value) {
		this.name = name;
		this.value = value;
	}

	public String getName() {
		return name;
	}

	public int getValue() {
		return value;
	}

}
"
PluginQuality.java,framework,"package org.processmining.framework.plugin.annotations;

public enum PluginQuality {
	VeryPoor( //
			""VeryPoor"", //
			0), //
	Poor( //
			""Poor"", //
			1), //
	Fair( //
			""Fair"", //
			2), //
	Good( //
			""Good"", //
			3), //
	VeryGood( //
			""VeryGood"", //
			4);

	private final String name;
	private final int value;

	private PluginQuality(String name, int value) {
		this.name = name;
		this.value = value;
	}

	public String getName() {
		return name;
	}

	public int getValue() {
		return value;
	}
}
"
PluginVariant.java,framework,"package org.processmining.framework.plugin.annotations;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface PluginVariant {

	/**
	 * Each plugin variant specifies the required parameter labels in this
	 * Array. The array should be at most as long as the parameterLabels array
	 * of the Plugin annotation. Furthermore, all elements of the array should
	 * be indices in the parametersLabels array of the Plugin annotation and the
	 * elements should be ordered.
	 * 
	 * @return
	 */
	int[] requiredParameterLabels();

	/**
	 * This String represents the label of the plugin variant. This label is
	 * used to identify different variants of the same plugin, specifically when
	 * multiple variants accept the same parameters of the same types.
	 */
	String variantLabel() default """";

	/**
	 * Returns the help / description for this plugin variant.
	 * 
	 * @return Empty string as default
	 */
	String help() default """";

}
"
ConnectionObjectListener.java,framework,"package org.processmining.framework.plugin.events;

import java.util.EventListener;

import org.processmining.framework.connections.ConnectionID;

public interface ConnectionObjectListener extends EventListener {

	public class ListenerList extends ProMEventListenerList<ConnectionObjectListener> {
		public void fireConnectionCreated(ConnectionID connectionID) {
			for (ConnectionObjectListener listener : getListeners()) {
				listener.connectionCreated(connectionID);
			}
		}

		public void fireConnectionDeleted(ConnectionID id) {
			for (ConnectionObjectListener listener : getListeners()) {
				listener.connectionDeleted(id);
			}
		}

		public void fireConnectionUpdated(ConnectionID id) {
			for (ConnectionObjectListener listener : getListeners()) {
				listener.connectionUpdated(id);
			}
		}
	}

	/**
	 * This method signals the creation of a connection with the given ID. For
	 * access to the actual connection, the connectionManager should be used.
	 * 
	 * @param connectionID
	 */
	public void connectionCreated(ConnectionID connectionID);

	/**
	 * This method signals the deletion of a connection with the given ID. For
	 * access to the actual connection, the connectionManager should be used.
	 * 
	 * @param connectionID
	 */
	public void connectionDeleted(ConnectionID connectionID);

	/**
	 * This method signals that the connection with the given ID was updated.
	 * For access to the actual connection, the connectionManager should be
	 * used.
	 * 
	 * Be aware, that the actual pointers to the objects connected by the
	 * Connection with the given ID are not changed. Furthermore, it is wise not
	 * to update connections too often.
	 * 
	 * @param connectionID
	 */
	public void connectionUpdated(ConnectionID connectionID);

}
"
FutureListener.java,framework,"package org.processmining.framework.plugin.events;

import java.util.EventListener;

import org.processmining.framework.plugin.ProMFuture;

public interface FutureListener extends EventListener {

	public class ListenerList extends ProMEventListenerList<FutureListener> {
		public void fireFutureReady(ProMFuture<? extends Object> future) {
			for (FutureListener listener : getListeners()) {
				listener.futureReady(future);
			}
		}
	}

	public void futureReady(ProMFuture<? extends Object> future);

}
"
Logger.java,framework,"package org.processmining.framework.plugin.events;

import java.util.EventListener;

import org.processmining.framework.plugin.PluginContextID;

public interface Logger extends EventListener {

	public enum MessageLevel {
		/**
		 * Normal message level, for information during runtime
		 */
		NORMAL("" "", ""Normal""),
		/**
		 * Warning message level, for warning messages during runtime
		 */
		WARNING(""W"", ""Warning""),
		/**
		 * Error message level, for error information during ruintime. Use in
		 * case error can be recovered from, i.e. not in case of exception
		 * handling.
		 */
		ERROR(""E"", ""Error""),
		/**
		 * All TEST messages are omitted in the release version.
		 */
		TEST(""T"", ""Test""),
		/**
		 * All DEBUG messages are omitted in the release version.
		 */
		DEBUG(""D"", ""Debug"");

		private final String shortName;
		private final String longName;

		MessageLevel(String shortName, String longName) {
			this.shortName = shortName;
			this.longName = longName;
		}

		public String getShortName() {
			return shortName;
		}

		public String getLongName() {
			return longName;
		}
	}

	public class ListenerList extends ProMEventListenerList<Logger> {

		public void fireLog(String message, PluginContextID contextID, MessageLevel messageLevel) {
			for (Logger listener : getListeners()) {
				listener.log(message, contextID, messageLevel);
			}
		}

		public void fireLog(Throwable t, PluginContextID contextID) {
			for (Logger listener : getListeners()) {
				listener.log(t, contextID);
			}
		}
	}

	public void log(String message, PluginContextID contextID, MessageLevel messageLevel);

	public void log(Throwable t, PluginContextID contextID);

}
"
NameChangeListener.java,framework,"package org.processmining.framework.plugin.events;

import java.util.EventListener;

public interface NameChangeListener extends EventListener {

	public class ListenerList extends ProMEventListenerList<NameChangeListener> {
		public void fireNameChanged(String newName) {
			for (NameChangeListener listener : getListeners()) {
				listener.nameChanged(newName);
			}
		}
	}

	public void nameChanged(String newName);
}
"
PluginLifeCycleEventListener.java,framework,"package org.processmining.framework.plugin.events;

import java.util.EventListener;

import org.processmining.framework.plugin.PluginContext;

public interface PluginLifeCycleEventListener extends EventListener {

	/**
	 * This method is invoked on a parent context, if a child context of that
	 * parent is created.
	 * 
	 * @param context
	 *            the new Child context
	 */
	public void pluginCreated(PluginContext context);

	/**
	 * This method is invoked on a context, if it is started
	 * 
	 * @param context
	 *            the context
	 */
	public void pluginStarted(PluginContext context);

	/**
	 * This method is invoked on a context, if it is suspended
	 * 
	 * @param context
	 *            the context
	 */
	public void pluginSuspended(PluginContext context);

	/**
	 * This method is invoked on a context, if it is resumed
	 * 
	 * @param context
	 *            the context
	 */
	public void pluginResumed(PluginContext context);

	/**
	 * This method is invoked on a context, if it is completed
	 * 
	 * @param context
	 *            the context
	 */
	public void pluginCompleted(PluginContext context);

	/**
	 * This method is invoked on a context, if it is cancelled
	 * 
	 * @param context
	 *            the context
	 */
	public void pluginCancelled(PluginContext context);

	/**
	 * This method is invoked on a context, if it throws an exception
	 * 
	 * @param context
	 *            the context
	 */
	public void pluginTerminatedWithError(PluginContext context, Throwable t);

	/**
	 * This method is invoked on a context, if it's future was set.
	 * 
	 * @param context
	 *            the context
	 */
	public void pluginFutureCreated(PluginContext context);

	/**
	 * This method is invoked on a context, if it's deleted from its parent
	 * 
	 * @param context
	 *            the context
	 */
	public void pluginDeleted(PluginContext context);

	public class List extends ProMEventListenerList<PluginLifeCycleEventListener> {
		public void firePluginCreated(PluginContext context) {
			for (PluginLifeCycleEventListener listener : getListeners()) {
				listener.pluginCreated(context);
			}
		}

		public void firePluginStarted(PluginContext context) {
			for (PluginLifeCycleEventListener listener : getListeners()) {
				listener.pluginStarted(context);
			}
		}

		public void firePluginSuspended(PluginContext context) {
			for (PluginLifeCycleEventListener listener : getListeners()) {
				listener.pluginSuspended(context);
			}
		}

		public void firePluginResumed(PluginContext context) {
			for (PluginLifeCycleEventListener listener : getListeners()) {
				listener.pluginResumed(context);
			}
		}

		public void firePluginCompleted(PluginContext context) {
			for (PluginLifeCycleEventListener listener : getListeners()) {
				listener.pluginCompleted(context);
			}
		}

		public void firePluginCancelled(PluginContext context) {
			for (PluginLifeCycleEventListener listener : getListeners()) {
				listener.pluginCancelled(context);
			}
		}

		public void firePluginTerminatedWithError(PluginContext context, Throwable t) {
			for (PluginLifeCycleEventListener listener : getListeners()) {
				listener.pluginTerminatedWithError(context, t);
			}
		}

		public void firePluginFutureCreated(PluginContext context) {
			for (PluginLifeCycleEventListener listener : getListeners()) {
				listener.pluginFutureCreated(context);
			}
		}

		public void firePluginDeleted(PluginContext context) {
			for (PluginLifeCycleEventListener listener : getListeners()) {
				listener.pluginDeleted(context);
			}
		}
	}
}"
ProgressEventListener.java,framework,"package org.processmining.framework.plugin.events;

import java.util.EventListener;

public interface ProgressEventListener extends EventListener {

	void changeProgressCaption(String newCaption);

	void changeProgress(int progress);

	void changeProgressBounds(int lowBo, int upBo);

	void changeProgressIndeterminate(boolean indeterminate);

	public class ListenerList extends ProMEventListenerList<ProgressEventListener> {
		public void fireProgressCaptionChanged(String newCaption) {
			for (ProgressEventListener listener : getListeners()) {
				listener.changeProgressCaption(newCaption);
			}
		}

		public void fireProgressChanged(int progress) {
			for (ProgressEventListener listener : getListeners()) {
				listener.changeProgress(progress);
			}
		}

		public void fireProgressBoundsChanged(int lowBo, int upBo) {
			for (ProgressEventListener listener : getListeners()) {
				listener.changeProgressBounds(lowBo, upBo);
			}
		}

		public void fireProgressIndeterminateChanged(boolean indeterminate) {
			for (ProgressEventListener listener : getListeners()) {
				listener.changeProgressIndeterminate(indeterminate);
			}
		}
	}
}"
ProMEventListenerList.java,framework,"package org.processmining.framework.plugin.events;

import java.lang.ref.WeakReference;
import java.util.ArrayList;
import java.util.EventListener;
import java.util.Iterator;
import java.util.List;

public class ProMEventListenerList<T extends EventListener> {

	private final List<WeakReference<T>> listeners = new ArrayList<WeakReference<T>>(2);

	public void add(T listener) {
		synchronized (listeners) {
			listeners.add(new WeakReference<T>(listener));
		}
	}

	public int getListenerCount() {
		return listeners.size();
	}

	protected List<T> getListeners() {
		List<T> result = new ArrayList<T>();
		Iterator<WeakReference<T>> it = listeners.iterator();
		while (it.hasNext()) {
			T object = it.next().get();
			if (object != null) {
				result.add(object);
			} else {
				it.remove();
			}
		}
		return result;
	}

	public void remove(T listener) {
		while (listeners.contains(listener)) {
			listeners.remove(listener);
		}
	}

	public String toString() {
		return listeners.toString();
	}

	public void removeAll() {
		listeners.clear();
	}

}"
ProvidedObjectLifeCycleListener.java,framework,"package org.processmining.framework.plugin.events;

import java.util.EventListener;

import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.providedobjects.ProvidedObjectID;

public interface ProvidedObjectLifeCycleListener extends EventListener {

	public void providedObjectCreated(ProvidedObjectID objectID, PluginContext context);

	public void providedObjectFutureReady(ProvidedObjectID objectID);

	public void providedObjectNameChanged(ProvidedObjectID objectID);

	public void providedObjectObjectChanged(ProvidedObjectID objectID);

	public void providedObjectDeleted(ProvidedObjectID objectID);

	public class ListenerList extends ProMEventListenerList<ProvidedObjectLifeCycleListener> {
		public void fireProvidedObjectCreated(ProvidedObjectID objectID, PluginContext context) {
			for (ProvidedObjectLifeCycleListener listener : getListeners()) {
				listener.providedObjectCreated(objectID, context);
			}
		}

		public void fireProvidedObjectNameChanged(ProvidedObjectID objectID) {
			for (ProvidedObjectLifeCycleListener listener : getListeners()) {
				listener.providedObjectNameChanged(objectID);
			}
		}

		public void fireProvidedObjectObjectChanged(ProvidedObjectID objectID) {
			for (ProvidedObjectLifeCycleListener listener : getListeners()) {
				listener.providedObjectObjectChanged(objectID);
			}
		}

		public void fireProvidedObjectDeleted(ProvidedObjectID objectID) {
			for (ProvidedObjectLifeCycleListener listener : getListeners()) {
				listener.providedObjectDeleted(objectID);
			}
		}

		public void fireProvidedObjectFutureReady(ProvidedObjectID objectID) {
			for (ProvidedObjectLifeCycleListener listener : getListeners()) {
				listener.providedObjectFutureReady(objectID);
			}
		}
	}
}
"
GlobalContext.java,framework,"package org.processmining.framework.plugin;

import org.processmining.framework.connections.ConnectionManager;
import org.processmining.framework.providedobjects.ProvidedObjectManager;

/**
 * Any implementation should maintain a referencte to a single plugin context.
 * This plugin context is then used create children, in which plugins are
 * executed.
 * 
 * @author bfvdonge
 * 
 */
public interface GlobalContext {

	/**
	 * Returns the plugin manager. The plugin manager can be used to query for
	 * plugins which are registered in ProM.
	 * 
	 * @return the plugin manager
	 */
	PluginManager getPluginManager();

	/**
	 * Returns the providedObject manager. The providedObject manager can be
	 * used to query for providedObjects which are registered in ProM. The
	 * manager should be a ProvidedObjectListener on all PluginInstanceContexts
	 * created by createRootInstanceContext.
	 * 
	 * @return the providedObject manager
	 */
	ProvidedObjectManager getProvidedObjectManager();

	/**
	 * Returns the connection manager. The connection manager can be used to
	 * query for connections which are registered in ProM.
	 * 
	 * @return the connection manager
	 */

	ConnectionManager getConnectionManager();

	/**
	 * The GlobalContext implementation should create IDs for all PluginContexts
	 * instantiated for it.
	 * 
	 * @return
	 */
	PluginContextID createNewPluginContextID();

	/**
	 * This method invokes the specified plugin in a context which is a child of
	 * the main plugin context maintained by this globalContext. No results are
	 * provided to the method calling this method and the plugin is executed
	 * some time in the future, as decided by the implementing class.
	 * 
	 * @param plugin
	 *            The plugin that should be invoked by the framework
	 * @param index
	 *            The index of the plugin method that should be invoked.
	 * @param objects
	 *            The objects to serve as input as accepted by the method at
	 *            index of the plugin
	 */
	void invokePlugin(PluginDescriptor plugin, int index, Object... objects);

	/**
	 * This method invokes the specified binding in a context which is a child
	 * of the main plugin context maintained by this globalContext. No results
	 * are provided to the method calling this method and the plugin is executed
	 * some time in the future, as decided by the implementing class.
	 * 
	 * @param binding
	 *            The binding that should be invoked by the framework
	 * @param objects
	 *            The objects to serve as input as accepted by the given
	 *            binding.
	 */
	void invokeBinding(PluginParameterBinding binding, Object... objects);

	/**
	 * Returns the specific type of the PluginContext. This type is used to
	 * instantiate new contexts in which to invoke plugins.
	 * 
	 * @return the type of PluginContext provided by this global context
	 */
	Class<? extends PluginContext> getPluginContextType();

}
"
AbstractGlobalContext.java,framework,"package org.processmining.framework.plugin.impl;

import org.processmining.framework.connections.ConnectionManager;
import org.processmining.framework.connections.impl.ConnectionManagerImpl;
import org.processmining.framework.plugin.GlobalContext;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.PluginContextID;
import org.processmining.framework.plugin.PluginDescriptor;
import org.processmining.framework.plugin.PluginManager;
import org.processmining.framework.plugin.PluginParameterBinding;
import org.processmining.framework.plugin.events.Logger;
import org.processmining.framework.providedobjects.ProvidedObjectManager;
import org.processmining.framework.providedobjects.impl.ProvidedObjectManagerImpl;

/**
 * Since this context should maintain a link to a single plugin context, and
 * PluginContextImpl is abstract, this context is also abstract.
 * 
 * @author bfvdonge
 * 
 */
public abstract class AbstractGlobalContext implements GlobalContext {

	private final ProvidedObjectManager providedObjectManager = new ProvidedObjectManagerImpl();
	private final ConnectionManager connectionManager = new ConnectionManagerImpl(PluginManagerImpl.getInstance());
	protected final Logger.ListenerList loggingEventListeners = new Logger.ListenerList();

	public PluginManager getPluginManager() {
		return PluginManagerImpl.getInstance();
	}

	public ConnectionManager getConnectionManager() {
		return connectionManager;
	}

	public ProvidedObjectManager getProvidedObjectManager() {
		return providedObjectManager;
	}

	public PluginContextID createNewPluginContextID() {
		return new PluginContextIDImpl();
	}

	public void invokeBinding(PluginParameterBinding binding, Object... objects) {

		PluginContext c2 = getMainPluginContext().createChildContext(binding.getPlugin().getName());

		try {
			// Create a new providedObject, by passing the future to the
			// providedObjectManager;
			getMainPluginContext().getPluginLifeCycleEventListeners().firePluginCreated(c2);
			binding.invoke(c2, objects);
			getProvidedObjectManager().createProvidedObjects(c2);

		} catch (IllegalArgumentException e) {
			getMainPluginContext().log(e);
			return;
		} finally {
			c2.getParentContext().deleteChild(c2);
		}

		// Since the result is still being calculated, we can only
		// use the defaultResultName for the providedObject.

	}

	public void invokePlugin(PluginDescriptor plugin, int index, Object... objects) {
		PluginContext c2 = getMainPluginContext().createChildContext(plugin.getName());

		try {
			// Create a new providedObject, by passing the future to the
			// providedObjectManager;
			getMainPluginContext().getPluginLifeCycleEventListeners().firePluginCreated(c2);
			plugin.invoke(index, c2, objects);
			getProvidedObjectManager().createProvidedObjects(c2);

		} catch (IllegalArgumentException e) {
			getMainPluginContext().log(e);
			return;
		} finally {
			c2.getParentContext().deleteChild(c2);
		}

		// Since the result is still being calculated, we can only
		// use the defaultResultName for the providedObject.

	}

	protected abstract PluginContext getMainPluginContext();

	public abstract Class<? extends PluginContext> getPluginContextType();

}
"
AbstractPluginContext.java,framework,"package org.processmining.framework.plugin.impl;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashSet;
import java.util.Set;
import java.util.SortedSet;
import java.util.TreeSet;
import java.util.concurrent.CancellationException;
import java.util.concurrent.ExecutionException;

import org.processmining.framework.connections.Connection;
import org.processmining.framework.connections.ConnectionCannotBeObtained;
import org.processmining.framework.connections.ConnectionManager;
import org.processmining.framework.plugin.GlobalContext;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.PluginContextID;
import org.processmining.framework.plugin.PluginDescriptor;
import org.processmining.framework.plugin.PluginExecutionResult;
import org.processmining.framework.plugin.PluginManager;
import org.processmining.framework.plugin.PluginParameterBinding;
import org.processmining.framework.plugin.ProMFuture;
import org.processmining.framework.plugin.Progress;
import org.processmining.framework.plugin.RecursiveCallException;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.events.Logger;
import org.processmining.framework.plugin.events.Logger.MessageLevel;
import org.processmining.framework.plugin.events.PluginLifeCycleEventListener;
import org.processmining.framework.plugin.events.ProgressEventListener;
import org.processmining.framework.providedobjects.ProvidedObjectManager;
import org.processmining.framework.util.Cast;
import org.processmining.framework.util.Pair;

public abstract class AbstractPluginContext implements PluginContext {

	private final GlobalContext context;
	private final PluginContext parentPluginContext;

	private final PluginLifeCycleEventListener.List lifeCycleEventListeners = new PluginLifeCycleEventListener.List();
	private final ProgressEventListener.ListenerList progressEventListeners = new ProgressEventListener.ListenerList();
	private final Logger.ListenerList loggers = new Logger.ListenerList();

	protected Progress progress;
	private PluginDescriptor descriptor;
	private final java.util.List<PluginContext> childContexts = new ArrayList<PluginContext>(0);
	private PluginExecutionResult futures = null;
	private final PluginContextID id;
	private String label = """";
	private int methodIndex = -1;

	/**
	 * Create a new root plugin instance context.
	 * 
	 * @param context
	 *            the global context in which this instance context is used
	 */
	public AbstractPluginContext(GlobalContext context, String label) {
		assert (context != null);
		this.context = context;
		id = context.createNewPluginContextID();
		this.label = label;
		parentPluginContext = null;
		progress = new ProgressBarImpl(this);
	}

	protected AbstractPluginContext(AbstractPluginContext context, String label) {
		assert (context != null);
		this.context = context.getGlobalContext();
		id = this.context.createNewPluginContextID();
		this.label = label;
		parentPluginContext = context;
		progress = new ProgressBarImpl(this);
	}

	public Pair<PluginDescriptor, Integer> getPluginDescriptor() {
		return new Pair<PluginDescriptor, Integer>(descriptor, methodIndex);
	}

	public GlobalContext getGlobalContext() {
		return context;
	}

	public PluginLifeCycleEventListener.List getPluginLifeCycleEventListeners() {
		return lifeCycleEventListeners;
	}

	public ProgressEventListener.ListenerList getProgressEventListeners() {
		return progressEventListeners;
	}

	public Progress getProgress() {
		return progress;
	}

	public PluginContextID getID() {
		return id;
	}

	public ConnectionManager getConnectionManager() {
		return context.getConnectionManager();
	}

	public String getLabel() {
		return label;
	}

	public boolean hasPluginDescriptorInPath(PluginDescriptor plugin, int methodIndex) {
		return ((methodIndex == this.methodIndex) && (plugin == descriptor))
				|| (getParentContext() == null ? false : getParentContext().hasPluginDescriptorInPath(plugin,
						methodIndex));
	}

	public void setPluginDescriptor(PluginDescriptor descriptor, int methodIndex) throws FieldSetException,
			RecursiveCallException {
		if ((getParentContext() != null) && getParentContext().hasPluginDescriptorInPath(descriptor, methodIndex)) {
			throw new RecursiveCallException(this, descriptor, methodIndex);
		}
		if (this.descriptor == null) {
			this.methodIndex = methodIndex;
			this.descriptor = descriptor;
		} else {
			throw new FieldSetException(""descriptor"",
					""Use getGlobalContext().createInstanceContext() to create a new instance context"");
		}
	}

	public PluginContext createChildContext(String label) {
		PluginContext context = createTypedChildContext(label);
		childContexts.add(context);
		return context;
	}

	public java.util.List<PluginContext> getChildContexts() {
		return Collections.unmodifiableList(childContexts);
	}

	public PluginContext getParentContext() {
		return parentPluginContext;
	}

	protected abstract PluginContext createTypedChildContext(String label);

	/**
	 * This method returns the PluginExecutionResult of the plugin which is
	 * invoked in this context. This future result is set by
	 * PluginManager.invoke() and will not be available (will be null) until the
	 * invoke() method is called.
	 * 
	 * @return The PluginExecutionResult that represents the result of this
	 *         plugin invocation
	 * @throws FieldNotSetException
	 *             If the future is not know to this context
	 */
	public PluginExecutionResult getResult() {
		return futures;
	}

	public ProMFuture<?> getFutureResult(int i) {
		assert (futures != null);
		Object o = futures.getResult(i);
		assert (o instanceof ProMFuture<?>);
		// Note that if this cast cannot be performed,
		// an exception should be thrown. This method should
		// only be called from the body of a plugin
		return futures.<ProMFuture<?>>getResult(i);
	}

	public void setFuture(PluginExecutionResult futureToBe) {
		assert (futures == null);
		futures = futureToBe;
	}

	public boolean equals(Object o) {
		if (o instanceof PluginContext) {
			return ((PluginContext) o).getID().equals(id);
		}
		return false;

	}

	public String toString() {
		return getID() + "": "" + getLabel();
	}

	public boolean isDistantChildOf(PluginContext context) {
		if (getParentContext() == null) {
			return false;
		}
		return getParentContext().getID().equals(context.getID()) || getParentContext().isDistantChildOf(context);
	}

	/**
	 * The provided String is provided to the context for information. It can
	 * for example signal a state change of a plugin. Note that some contexts
	 * can completely ignore this message.
	 * 
	 * @param message
	 *            the message to log
	 * @param level
	 *            the message level
	 */
	public void log(String message, MessageLevel level) {
		loggers.fireLog(message, id, level);
	}

	/**
	 * Same as calling log(message, MessageLevel.NORMAL);
	 * 
	 * @param message
	 *            The message
	 */
	public void log(String message) {
		loggers.fireLog(message, id, MessageLevel.NORMAL);
	}

	/**
	 * The provided Exception is provided to the context. It signals the context
	 * about an error in the plugin, that specifically lead to abnormal
	 * termination. The plugin signaling the exception is no longer executing!
	 * 
	 * @param exception
	 *            the exception thrown
	 */
	public void log(Throwable exception) {
		loggers.fireLog(exception, id);
		System.err.println(""-------- The following exception was logged by the framework: "");
		System.err.println(""         The exception was probalby handled properly. "");
		exception.printStackTrace();
		System.err.println(""--------------------------------------------------------------"");
		
	}

	/**
	 * Returns the plugin manager. The plugin manager can be used to query for
	 * plugins which are registered in ProM.
	 * 
	 * @return the plugin manager
	 */
	public PluginManager getPluginManager() {
		return context.getPluginManager();
	}

	/**
	 * Returns the providedObject manager. The providedObject manager can be
	 * used to query for providedObjects which are registered in ProM. The
	 * manager should be a ProvidedObjectListener on all PluginInstanceContexts
	 * created by createRootInstanceContext.
	 * 
	 * @return the providedObject manager
	 */
	public ProvidedObjectManager getProvidedObjectManager() {
		return context.getProvidedObjectManager();
	}

	/**
	 * The GlobalContext implementation should create IDs for all PluginContexts
	 * instantiated for it.
	 * 
	 * @return
	 */
	public PluginContextID createNewPluginContextID() {
		return context.createNewPluginContextID();
	}

	/**
	 * This method invokes the specified plugin in a context which is a child of
	 * the main plugin context maintained by this globalContext;
	 * 
	 * @param plugin
	 * @param objects
	 *            The objects to serve as input. Note that all elements should
	 *            implement Object, or be a ProMFuture<?>.
	 */
	public void invokePlugin(PluginDescriptor plugin, int index, Object... objects) {
		context.invokePlugin(plugin, index, objects);
	}

	public void invokeBinding(PluginParameterBinding binding, Object... objects) {
		context.invokeBinding(binding, objects);
	}

	public Logger.ListenerList getLoggingListeners() {
		return loggers;
	}

	public PluginContext getRootContext() {
		if (parentPluginContext == null) {
			return this;
		} else {
			return parentPluginContext.getRootContext();
		}
	}

	public boolean deleteChild(PluginContext child) {
		if (childContexts.contains(child)) {
			childContexts.remove(child);
			for (PluginContext context : new ArrayList<PluginContext>(child.getChildContexts())) {
				child.deleteChild(context);
			}
			child.getPluginLifeCycleEventListeners().firePluginDeleted(child);
			return true;
		}
		return false;
	}

	public <T extends Connection> T addConnection(T c) {
		return getConnectionManager().addConnection(c);
	}

	public Class<? extends PluginContext> getPluginContextType() {
		return this.getClass();
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @seeorg.processmining.framework.util.ObjectConstructorInterface#
	 * tryToFindOrConstructAllObjects(java.lang.Class,
	 * org.processmining.framework.plugin.PluginContext, java.lang.Class,
	 * java.lang.String, java.lang.Object)
	 */
	public <T, C extends Connection> Collection<T> tryToFindOrConstructAllObjects(Class<T> type,
			Class<C> connectionType, String role, Object... input) throws ConnectionCannotBeObtained {
		return findOrConstructAllObjects(false, type, null, connectionType, role, input);
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @seeorg.processmining.framework.util.ObjectConstructorInterface#
	 * tryToFindOrConstructFirstObject(java.lang.Class,
	 * org.processmining.framework.plugin.PluginContext, java.lang.Class,
	 * java.lang.String, java.lang.Object)
	 */
	public <T, C extends Connection> T tryToFindOrConstructFirstObject(Class<T> type, Class<C> connectionType,
			String role, Object... input) throws ConnectionCannotBeObtained {
		return findOrConstructAllObjects(true, type, null, connectionType, role, input).iterator().next();
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @seeorg.processmining.framework.util.ObjectConstructorInterface#
	 * tryToFindOrConstructFirstNamedObject(java.lang.Class, java.lang.String,
	 * org.processmining.framework.plugin.PluginContext, java.lang.Class,
	 * java.lang.String,
	 * 
	 * java.lang.Object)
	 */
	public <T, C extends Connection> T tryToFindOrConstructFirstNamedObject(Class<T> type, String name,
			Class<C> connectionType, String role, Object... input) throws ConnectionCannotBeObtained {
		return findOrConstructAllObjects(true, type, name, connectionType, role, input).iterator().next();
	}

	private <T, C extends Connection> Collection<T> constructAllObjects(boolean stopAtFirst, Class<T> type,
			String name, Object... input) throws CancellationException, InterruptedException, ExecutionException {
		Class<?>[] types;
		if (input != null) {
			types = new Class<?>[input.length];
			for (int i = 0; i < input.length; i++) {
				types[i] = input[i].getClass();
			}
		} else {
			types = new Class<?>[0];
			input = new Object[0];
		}

		// Find available plugins
		Set<Pair<Integer, PluginParameterBinding>> set = getPluginManager().find(Plugin.class, type,
				getPluginContextType(), true, false, false, types);

		if (set.isEmpty()) {
			throw new RuntimeException(""No plugin available to build this type of object: "" + type.toString());
		}

		// Filter on the given name, if given.
		if (name != null) {
			Set<Pair<Integer, PluginParameterBinding>> filteredSet = new HashSet<Pair<Integer, PluginParameterBinding>>();
			for (Pair<Integer, PluginParameterBinding> pair : set) {
				if (name.equals(pair.getSecond().getPlugin().getName())) {
					filteredSet.add(pair);
				}
			}
			set.clear();
			set.addAll(filteredSet);
		}

		if (set.isEmpty()) {
			throw new RuntimeException(""No named plugin available to build this type of object: "" + name + "", ""
					+ type.toString());
		}

		SortedSet<Pair<Integer, PluginParameterBinding>> plugins = new TreeSet<Pair<Integer, PluginParameterBinding>>(
				new Comparator<Pair<Integer, PluginParameterBinding>>() {

					public int compare(Pair<Integer, PluginParameterBinding> arg0,
							Pair<Integer, PluginParameterBinding> arg1) {
						int c = arg0.getSecond().getPlugin().getReturnNames().size()
								- arg1.getSecond().getPlugin().getReturnNames().size();
						if (c == 0) {
							c = arg0.getSecond().compareTo(arg1.getSecond());
						}
						if (c == 0) {
							c = arg0.getFirst() - arg1.getFirst();
						}
						return c;
					}

				});
		plugins.addAll(set);

		Collection<T> result = new ArrayList<T>(stopAtFirst ? 1 : plugins.size());

		// get the first available plugin
		ExecutionException ex = null;
		for (Pair<Integer, PluginParameterBinding> pair : plugins) {
			PluginParameterBinding binding = pair.getSecond();
			// create a context to execute this plugin in
			PluginContext child = createChildContext(""Computing: "" + type.toString());
			getPluginLifeCycleEventListeners().firePluginCreated(child);

			// Invoke the binding
			PluginExecutionResult pluginResult = binding.invoke(child, input);

			// synchronize on the required result and continue
			try {
				pluginResult.synchronize();

				// get all results and pass them to the framework as provided objects
				getProvidedObjectManager().createProvidedObjects(child);
				result.add(pluginResult.<T>getResult(pair.getFirst()));
				if (stopAtFirst) {
					break;
				}
			} catch (ExecutionException e) {
				// Try next plugin if stop at first, otherwise rethrow
				ex = e;
			} finally {
				child.getParentContext().deleteChild(child);
			}
		}
		if (result.isEmpty()) {
			assert (ex != null);
			throw ex;
		}
		return result;
	}

	private <T, C extends Connection> Collection<T> findOrConstructAllObjects(boolean stopAtFirst, Class<T> type,
			String name, Class<C> connectionType, String role, Object... input) throws ConnectionCannotBeObtained {

		Collection<T> accepted = new ArrayList<T>();
		try {
			for (C conn : getConnectionManager().getConnections(connectionType, this, input)) {
				Object object = conn.getObjectWithRole(role);
				if (type.isAssignableFrom(object.getClass())) {
					accepted.add(Cast.<T>cast(object));
				}
			}
		} catch (Exception e) {
			// Don't care, let's try to construct later
		}
		if (!accepted.isEmpty()) {
			return accepted;
		}
		try {
			return constructAllObjects(stopAtFirst, type, name, input);
		} catch (Exception e) {
			throw new ConnectionCannotBeObtained(e.getMessage(), connectionType);
		}
	}

	public void clear() {
		getProvidedObjectManager().clear();
		getConnectionManager().clear();
	}
}"
AbstractPluginDescriptor.java,framework,"package org.processmining.framework.plugin.impl;

import java.lang.reflect.Array;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.concurrent.CancellationException;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;

import javax.swing.JOptionPane;

import org.processmining.framework.boot.Boot;
import org.processmining.framework.plugin.InSufficientResultException;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.PluginDescriptor;
import org.processmining.framework.plugin.PluginExecutionResult;
import org.processmining.framework.plugin.ProMFuture;
import org.processmining.framework.plugin.RecursiveCallException;
import org.processmining.framework.plugin.events.Logger.MessageLevel;
import org.processmining.framework.util.GoogleAnalyticsUtil;

public abstract class AbstractPluginDescriptor implements PluginDescriptor {

	@SuppressWarnings( { ""unchecked"" })
	private Object[] prepareAndWaitForArgs(PluginContext context, int methodIndex, List<Class<?>> parameterTypes,
			Object... args) throws CancellationException, InterruptedException, ExecutionException, FieldSetException,
			RecursiveCallException {
		Object[] result = new Object[args.length + 1];
		// copy the args to result
		System.arraycopy(args, 0, result, 1, args.length);
		boolean[] done = new boolean[result.length];
		Arrays.fill(done, false);
		boolean timeoutOccurred = false;
		do {
			timeoutOccurred = false;
			for (int i = 1; i < result.length; i++) {
				if (done[i]) {
					continue;
				}
				if (result[i] == null) {
					throw new IllegalArgumentException(""Cannot pass <null> as a parameter to a plugin"");
				}
				if ((result[i] instanceof ProMFuture)) {
					// synchronize on this get() method
					// any exception is forwarded.
					try {
						// try to get the result within 100 millisecond
						result[i] = ((ProMFuture) result[i]).get(100L, TimeUnit.MILLISECONDS);
						done[i] = true;
					} catch (TimeoutException e) {
						// A timeout exception occurred, no big deal,
						// just wait longer
						timeoutOccurred = true;
					}
				}
				if (result[i] instanceof Object[]) {
					// This array can contain a combination of rightly typed
					// objects, or futures on
					// rightly types objects, or futures on other arrays.
					Object[] array = (Object[]) result[i];
					boolean futureLeft = false;
					for (int j = 0; j < array.length; j++) {
						if (array[j] instanceof ProMFuture) {
							try {
								// try to get the result within 1 second
								array[j] = ((ProMFuture) array[j]).get(100L, TimeUnit.MILLISECONDS);
							} catch (TimeoutException e) {
								// A timeout exception occurred, no big deal,
								// just wait longer
								timeoutOccurred = true;
								futureLeft |= true;
							}
						}
					}
					if (!futureLeft) {
						List<Object> list = new ArrayList<Object>();
						for (int j = 0; j < array.length; j++) {
							if (array[j].getClass().isArray()) {
								for (int k = 0; k < ((Object[]) array[j]).length; k++) {
									list.add(((Object[]) array[j])[k]);
								}
							} else {
								list.add(array[j]);
							}
						}

						result[i] = list.toArray((Object[]) Array.newInstance(parameterTypes.get(i - 1)
								.getComponentType(), 0));
						done[i] = true;
					}

				}
			}
			if (timeoutOccurred) {
				// At least one of my input objects is not ready yet
				// try again in 2 seconds.
				Thread.sleep(2000);
			}
		} while (timeoutOccurred);

		context.setPluginDescriptor(this, methodIndex);
		result[0] = context;

		return result;
	}
	

	public PluginExecutionResult invoke(final int methodIndex, final PluginContext context, final Object... args) {

		ProMFuture<?>[] futures = new ProMFuture[Math.max(1, getReturnTypes().size())];

		Class<?> returnType;
		String name;
		final PluginExecutionResultImpl lock;
		if (getReturnTypes().size() == 0) {
			returnType = void.class;
			name = ""nothing"";
			lock = new PluginExecutionResultImpl(new Class<?>[] { returnType }, new String[0], this);
		} else {
			returnType = getReturnTypes().get(0);
			name = getReturnNames().get(0);
			lock = new PluginExecutionResultImpl(getReturnTypes().toArray(new Class<?>[0]), getReturnNames().toArray(
					new String[0]), this);
		}

		futures[0] = new ProMFuture<Object>(returnType, name) {

			@Override
			protected Object doInBackground() throws Exception {
				context.getPluginLifeCycleEventListeners().firePluginStarted(context);
				synchronized (lock) {
					// First, do a get on all Future objects in the args list

					Object[] allArgs = prepareAndWaitForArgs(context, methodIndex, getParameterTypes(methodIndex), args);

					// copy the result back into parameters, i.e. all futures
					// are unwrapped at this point and arrays are correctly typed.
					Object[] parameters = new Object[allArgs.length - 1];
					System.arraycopy(allArgs, 1, parameters, 0, parameters.length);
					lock.setInput(parameters);

					// All objects are available, now any exceptions
					// are forwarded, so start the computation of
					// this plugin
					try {
						if (Boot.isTrackingByGAAllowed()) {
							System.out.println(""[AbstractPluginDescriptor] Using GoogleAnalytics"");
							(new GoogleAnalyticsUtil()).runPluginEvent(getName(), getPackage() != null ? getPackage().getName() : null);
						}
						System.out.println(""Start plug-in "" + getName());
						long time = -System.currentTimeMillis();
						Object[] result = execute(context, methodIndex, allArgs);
						time += System.currentTimeMillis();
						System.out.println(""End plug-in "" + getName() + "", took "" + time + "" milliseconds"");

						if ((result == null) && !getReturnType().equals(void.class)) {
							throw new InSufficientResultException(getName(), lock.getExpectedSize(), 0);
						} else if (result.length < lock.getExpectedSize()) {
							throw new InSufficientResultException(getName(), lock.getExpectedSize(), result.length);
						} else if (result.length > lock.getExpectedSize()) {
							context.log(""Plugin "" + getName() + "" produced "" + result.length + "" results, while ""
									+ lock.getExpectedSize() + "" results were declared. Extra results are ignored."",
									MessageLevel.WARNING);
						}

						lock.setResult(result);
						lock.notifyAll();
						Object object = lock.getObject(0);
						return object;
					} catch (Exception ex) {
						if (ex.getCause() instanceof Exception) {
							ex = (Exception) ex.getCause();
						}
						lock.setException(ex);
						lock.notifyAll();
						//						context.getPluginLifeCycleEventListeners().firePluginTerminatedWithError(context, ex);
						//						context.log(ex);
						throw ex;
					}
				}
			}

			@Override
			protected void done() {
				if (context != null) {
					if (isCancelled()) {
						context.getPluginLifeCycleEventListeners().firePluginCancelled(context);
					} else {
						try {
							get();
							context.getPluginLifeCycleEventListeners().firePluginCompleted(context);
						} catch (Exception e) {
							JOptionPane.showMessageDialog(null, ""Exception happened: ""+e.getMessage());
							context.getPluginLifeCycleEventListeners().firePluginTerminatedWithError(context, e);
							context.log(e);
						}
					}

				}

			}
		};

		for (int i = 1; i < getReturnTypes().size(); i++) {
			final int j = i;
			returnType = getReturnTypes().get(i);
			name = getReturnNames().get(i);

			futures[i] = new ProMFuture<Object>(returnType, name) {
				@Override
				protected Object doInBackground() throws Exception {
					synchronized (lock) {
						while ((lock.getObject(j) instanceof ProMFuture<?>) && (lock.getException() == null)) {
							lock.wait();
						}
						Object object = lock.getObject(j);
						if ((object != null) && (lock.getException() == null)) {
							return object;
						}
						throw (lock.getException());
					}

				}
			};
		}

		lock.setResult(futures);

		context.setFuture(lock);
		context.getPluginLifeCycleEventListeners().firePluginFutureCreated(context);
		assert (context.getParentContext() != null);
		for (int i = 0; i < futures.length; i++) {
			context.getParentContext().getExecutor().execute(futures[i].getRunnable());
		}

		return lock;
	}

	/**
	 * In this method, the pluginDescriptor should do the actual work of
	 * concstructing the result. Note that no objects passed in the allArgs
	 * argument are futures anymore.
	 * 
	 * @param context
	 * @param methodIndex
	 * @param allArgs
	 * @return
	 * @throws Exception
	 */
	protected abstract Object[] execute(PluginContext context, int methodIndex, Object... allArgs) throws Exception;

}
"
DependsOnUnknownException.java,framework,"package org.processmining.framework.plugin.impl;

/**
 * thrown by the constructor of a plugindescritor if it depends on a plugin not
 * yet in the system.
 * 
 * @author bfvdonge
 * 
 */
public class DependsOnUnknownException extends Exception {

	public DependsOnUnknownException(String message) {
		super(message);
	}

	private static final long serialVersionUID = 4219323628021104089L;

}
"
FieldNotSetException.java,framework,"package org.processmining.framework.plugin.impl;

public class FieldNotSetException extends Exception {

	private static final long serialVersionUID = 6942427887070071817L;

	public FieldNotSetException(String fieldName, String message) {
		super(""Field "" + fieldName + "" was not yet set. "" + message);
	}
}
"
FieldSetException.java,framework,"package org.processmining.framework.plugin.impl;

public class FieldSetException extends Exception {

	private static final long serialVersionUID = 1024657629198603241L;

	public FieldSetException(String fieldName, String message) {
		super(""Field "" + fieldName + "" was already set. "" + message);
	}
}
"
PluginCacheEntry.java,framework,"package org.processmining.framework.plugin.impl;

import java.io.File;
import java.net.URI;
import java.net.URISyntaxException;
import java.net.URL;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Set;
import java.util.TreeSet;
import java.util.prefs.BackingStoreException;
import java.util.prefs.Preferences;

import org.processmining.framework.boot.Boot;
import org.processmining.framework.boot.Boot.Level;
import org.processmining.framework.packages.PackageDescriptor;

public class PluginCacheEntry {

	//	private byte[] buffer = new byte[2 * 1024 * 1024];

	private static final String CURRENT_VERSION = ""currentversion"";

	private static final String FILE_PROTOCOL = ""file"";

	private static final Set<String> STANDARD_JRE_DIRS = new HashSet<String>(
			Arrays.asList(new String[] { ""jdk"", ""jre"", }));
	private static final String STANDARD_JRE_LIB_DIR = ""lib"";
	private static final String STANDARD_JRE_EXT_DIR = ""ext"";
	private static final Set<String> STANDARD_JAR_FILES = new HashSet<String>(Arrays.asList(new String[] {
			""resources.jar"", ""rt.jar"", ""jsse.jar"", ""jce.jar"", ""charsets.jar"", ""dnsns.jar"", ""localedata.jar"",
			""qtjava.jar"", ""sunjce_provider.jar"", ""sunmscapi.jar"", ""sunpkcs11.jar"" }));

	private final URL url;
	private boolean inCache;
	private Set<String> classNames;
	private String key;
	private Boot.Level verbose;

	private final PackageDescriptor packageDescriptor;

	private final String jarName;

	private static Preferences PACKAGECACHE = initCache();

	//	private static MessageDigest digest;
	//
	//	static {
	//		try {
	//			digest = MessageDigest.getInstance(""MD5"");
	//		} catch (NoSuchAlgorithmException e) {
	//			// no MD5 available, so we cannot reliably detect whether the JAR is
	//			// cached or not
	//			digest = null;
	//		}
	//	}

	/**
	 * Deprecated. Use the version with the package descriptor for a
	 * significantly faster cache lookup
	 * 
	 * @param url
	 * @param verbose
	 */
	@Deprecated
	public PluginCacheEntry(URL url, Boot.Level verbose) {
		this(url, verbose, null);
	}

	private static Preferences initCache() {
		return Preferences.userNodeForPackage(PluginCacheEntry.class).parent().node(""_plugincache"");
	}

	public PluginCacheEntry(URL url, Boot.Level verbose, PackageDescriptor packageDescriptor) {
		this.url = url;
		this.verbose = verbose;
		this.packageDescriptor = packageDescriptor;
		this.jarName = packageDescriptor == null ? url.toString().substring(url.toString().lastIndexOf('/') + 1)
				.toLowerCase() : packageDescriptor.getName().toLowerCase();
		reset();

		try {
			init();
		} catch (Throwable e) {
			System.err.println(""Error caching JAR file: "" + e.getMessage());
			reset();
		}
	}

	public String getKey() {
		return key;
	}

	private void reset() {
		inCache = false;
		classNames = new HashSet<String>();
		key = null;
	}

	public boolean isInCache() {
		return inCache;
	}

	public Set<String> getCachedClassNames() {
		return classNames;
	}

	public void removeFromCache() {
		if (key != null) {
			getSettings().remove(key);
		}
	}

	private void init() throws URISyntaxException {
		if (!url.getProtocol().equals(FILE_PROTOCOL)) {
			return;
		}

		if (isStandardJar()) {
			inCache = true;
			return;
		}

		if (packageDescriptor == null) {
			//			if (digest == null) {
			//				return;
			//			}
			key = createFileBasedKey(new File(url.toURI()));
			if (key == null) {
				return;
			}
		} else {
			key = createPackageBasedKey();
		}

		String names = getSettings().get(key, null);

		if (names == null) {
			return;
		}

		if (verbose == Level.ALL) {
			System.out.println(""Plugins found in cache. "");
		}

		try {
			int subkeys = Integer.parseInt(names);
			for (int i = 0; i < subkeys; i++) {
				parseKey(key + ""-"" + i);
			}

		} catch (NumberFormatException e) {
			parseKey(key);
		}
		inCache = true;
	}

	private String createPackageBasedKey() {
		assert packageDescriptor != null;
		String key;
		key = packageDescriptor.getName();
		key += "" "";
		key += packageDescriptor.getVersion();
		return key.toLowerCase();
	}

	private String createFileBasedKey(File file) {
		//		InputStream is = null;
		//		try {
		long modified = file.lastModified();

		key = Long.toHexString(modified);

		//			int numRead = 0;
		//
		//			is = url.openStream();
		//			while ((numRead = is.read(buffer)) > 0) {
		//				digest.update(buffer, 0, numRead);
		//			}

		//		} catch (IOException e) {
		//			return null;
		//		} finally {
		//			if (is != null) {
		//				try {
		//					is.close();
		//				} catch (IOException e) {
		//
		//				}
		//			}
		//		}

		//		key = """";
		//		for (byte b : digest.digest()) {
		//			// append the signed byte as an unsigned hex number
		//			key += Integer.toString(0xFF & b, 16);
		//		}

		// No need to put the jarName in the key anymore.
		//		key += "" "" + new File(new URI(url.toString())).getName();
		//		if (key.length() > 80) {
		//			// make sure they is not too long for the preferences API
		//			key = key.substring(0, 80);
		//		}
		return key;
	}

	private void parseKey(String key) {
		String names = getSettings().get(key, null);

		//System.out.println(""  -> FOUND IN CACHE"");
		for (String className : names.split(""/"")) {
			if (className.length() > 0) {
				//System.out.println(""     - "" + className);
				classNames.add(className);
			}
		}
	}

	private boolean isStandardJar() throws URISyntaxException {
		try {
			File file = new File(new URI(url.toString()));
			String filename = file.getName().toLowerCase();

			if (STANDARD_JAR_FILES.contains(filename)) {
				String libDir = file.getParentFile().getName().toLowerCase();
				String jreDir = removeNonAlphaChars(file.getParentFile().getParentFile().getName().toLowerCase());

				if (libDir.equals(STANDARD_JRE_EXT_DIR)) {
					libDir = file.getParentFile().getParentFile().getName().toLowerCase();
					jreDir = removeNonAlphaChars(file.getParentFile().getParentFile().getParentFile().getName()
							.toLowerCase());
				}
				if (libDir.equals(STANDARD_JRE_LIB_DIR)) {
					return STANDARD_JRE_DIRS.contains(jreDir);
				}
			}
		} catch (NullPointerException e) {
			// probably the file doesn't have enough parent paths
		}
		return false;
	}

	private String removeNonAlphaChars(String s) {
		String result = """";

		for (int i = 0; i < s.length(); i++) {
			if (('a' <= s.charAt(i)) && (s.charAt(i) <= 'z')) {
				result += s.substring(i, i + 1);
			}
		}
		return result;
	}

	public void update(List<String> classes) {
		if (key != null) {
			String newKey = key;
			//			if (packageDescriptor == null) {
			//				newKey = createKey();
			//				if (newKey == null) {
			//					return;
			//				}
			//			} else {
			//				newKey = createPackageBasedKey();
			//			}

			if (verbose == Level.ALL) {
				System.out.println(""UPDATING CACHE: "" + key);
			}

			// updating. Remove the previpous version if present and add the new classes

			String previous = getSettings().get(CURRENT_VERSION, null);
			if (previous != null) {
				TreeSet<String> installed = new TreeSet<>(Arrays.asList(previous.split(""/"")));
				Iterator<String> it = installed.iterator();
				if (installed.size() >= 5) {
					// already keeping 5 versions alive. Remove one if
					// current not already present.
					if (!installed.contains(newKey)) {
						String toRemove = it.next();
						getSettings().remove(toRemove);

					}
				}
				previous = newKey;
				while (it.hasNext()) {
					previous += '/';
					previous += it.next();
				}
				getSettings().put(CURRENT_VERSION, previous);

			} else {
				getSettings().put(CURRENT_VERSION, newKey);
			}

			classNames.clear();
			for (String name : classes) {
				if ((name != null) && (name.length() > 0)) {
					classNames.add(name);
				}
			}

			StringBuffer value = new StringBuffer("""");
			for (String name : classNames) {
				if (verbose == Level.ALL) {
					System.out.println(""               : "" + name);
				}
				value.append(name);
				value.append(""/"");
			}

			if (value.length() > Preferences.MAX_VALUE_LENGTH) {
				int subkeys = (value.length() / Preferences.MAX_VALUE_LENGTH) + 1;
				getSettings().put(key, """" + subkeys);
				for (int i = 0; i < subkeys; i++) {
					getSettings().put(
							key + ""-"" + i,
							value.substring(i * Preferences.MAX_VALUE_LENGTH,
									Math.min((i + 1) * Preferences.MAX_VALUE_LENGTH, value.length())));
				}
			} else {

				getSettings().put(key, value.toString());
			}
		}
	}

	/**
	 * If a package descriptor is given, we use that to build the cache. The
	 * version number is increased automatically now with every build/release,
	 * hence we can use that to determine the cache.
	 * 
	 * @return
	 */
	private Preferences getSettings() {

		//		String className = getClass().getName();
		//		int pkgEndIndex = className.lastIndexOf('.');
		//		if (pkgEndIndex < 0) {
		//			className = ""/<unnamed>"";
		//		} else {
		//			String packageName = className.substring(0, pkgEndIndex);
		//			className = ""/"" + packageName.replace('.', '/');
		//		}
		if (packageDescriptor == null) {
			//			return Preferences.userRoot().node(className + ""/_jarfiles/"" + jarName);
			return PACKAGECACHE.node(""_jarfiles/"" + jarName);

		} else {
			return PACKAGECACHE.node(jarName);
			//			return Preferences.userRoot().node(className + '/' + jarName);
		}
	}

	/**
	 * Clear the cache here.
	 * 
	 * @return
	 */
	public static void clearSettingsCache() throws BackingStoreException {
		Preferences node = Preferences.userNodeForPackage(PluginCacheEntry.class);
		node.removeNode();
		node.flush();
		PACKAGECACHE.removeNode();
		PACKAGECACHE.flush();
		PACKAGECACHE = initCache();
	}

}
"
PluginContextIDImpl.java,framework,"package org.processmining.framework.plugin.impl;

import java.util.UUID;

import org.processmining.framework.plugin.PluginContextID;

public class PluginContextIDImpl implements PluginContextID {

	private final UUID id = UUID.randomUUID();

	public String toString() {
		return id.toString();
	}

	public int hashCode() {
		return id.hashCode();
	}

	public boolean equals(Object o) {
		if (!(o instanceof PluginContextIDImpl)) {
			return false;
		} else {
			return ((PluginContextIDImpl) o).id.equals(id);
		}
	}

	public int compareTo(PluginContextID o) {
		if (!(o instanceof PluginContextIDImpl)) {
			// Nasty implementation and not likely to be necessary,
			// as the ProvidedObjectManager should take care of not
			// using different object as ID.
			return PluginContextIDImpl.class.getName().compareTo(o.getClass().getName());
		} else {
			return ((PluginContextIDImpl) o).id.compareTo(id);
		}
	}
}
"
PluginDescriptorIDImpl.java,framework,"package org.processmining.framework.plugin.impl;

import java.lang.reflect.Method;

import org.processmining.framework.plugin.PluginDescriptorID;

public class PluginDescriptorIDImpl implements PluginDescriptorID {

	private final String id;

	public PluginDescriptorIDImpl(Method pluginMethod) {
		String temp = pluginMethod.toGenericString();
		int index = temp.indexOf("" throws "");
		if (index >= 0) {
			temp = temp.substring(0, index);
		}
		id = temp;
	}

	public PluginDescriptorIDImpl(Class<?> pluginClass) {
		id = pluginClass.getName();
	}

//	public PluginDescriptorIDImpl(MacroPluginDescriptorImpl macroPluginDescriptorImpl) {
//		id = macroPluginDescriptorImpl.getFileName();
//	}

	public String toString() {
		return id;
	}

	public int hashCode() {
		return id.hashCode();
	}

	public boolean equals(Object o) {
		if (!(o instanceof PluginDescriptorIDImpl)) {
			return false;
		} else {
			return ((PluginDescriptorIDImpl) o).id.equals(id);
		}
	}

	public int compareTo(PluginDescriptorID o) {
		if (!(o instanceof PluginDescriptorIDImpl)) {
			// Nasty implementation and not likely to be necessary,
			// as the ProvidedObjectManager should take care of not
			// using different object as ID.
			return PluginDescriptorIDImpl.class.getName().compareTo(o.getClass().getName());
		} else {
			return ((PluginDescriptorIDImpl) o).id.compareTo(id);
		}
	}
}
"
PluginDescriptorImpl.java,framework,"package org.processmining.framework.plugin.impl;

import java.io.IOException;
import java.io.InputStream;
import java.lang.annotation.Annotation;
import java.lang.reflect.AnnotatedElement;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.net.URL;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import javax.imageio.ImageIO;
import javax.swing.ImageIcon;

import org.processmining.framework.boot.Boot;
import org.processmining.framework.packages.PackageDescriptor;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.PluginDescriptor;
import org.processmining.framework.plugin.PluginDescriptorID;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginCategory;
import org.processmining.framework.plugin.annotations.PluginLevel;
import org.processmining.framework.plugin.annotations.PluginQuality;
import org.processmining.framework.plugin.annotations.PluginVariant;

public class PluginDescriptorImpl extends AbstractPluginDescriptor {

	private final AnnotatedElement annotatedElement;
	// This list contains either Class<? extends Object> or
	// Class<? extends Object[]>
	private final PluginDescriptorID id;
	private final List<List<Class<?>>> parameterTypes;
	private List<String> parameterNames;
	private final List<Class<?>> returnTypes;
	private final List<Method> methods;
	private final List<String> returnNames;
	private final String name;
	//	public Class<? extends PluginContext> contextType = null;
	private final Class<?> declaringClass;
	private final PackageDescriptor pack;

	private String help;
	private String[] keywords;
	private PluginCategory[] categories;
	private PluginQuality quality;
	private PluginLevel level;
	private ImageIcon icon;
	private URL url;

	private final static Map<String, ImageIcon> icons = new HashMap<String, ImageIcon>();
	private final static Map<String, URL> urls = new HashMap<String, URL>();

	PluginDescriptorImpl(Method method, PackageDescriptor pack) throws Exception {
		assert (method != null);
		assert (method.isAnnotationPresent(Plugin.class));
		this.pack = pack;
		id = new PluginDescriptorIDImpl(method);
		parameterTypes = new ArrayList<List<Class<?>>>(1);
		ArrayList<Class<?>> list = new ArrayList<Class<?>>(method.getParameterTypes().length - 1);
		parameterTypes.add(list);
		declaringClass = method.getDeclaringClass();

		for (Class<?> par : method.getParameterTypes()) {
			if (!PluginContext.class.isAssignableFrom(par)) {
				list.add(par);
			}
		}
		methods = new ArrayList<Method>(1);
		methods.add(method);

		annotatedElement = method;
		name = method.getAnnotation(Plugin.class).name();
		help = method.getAnnotation(Plugin.class).help();
		keywords = method.getAnnotation(Plugin.class).keywords();
		categories = method.getAnnotation(Plugin.class).categories();
		quality = method.getAnnotation(Plugin.class).quality();
		level = method.getAnnotation(Plugin.class).level();

		String iconString = method.getAnnotation(Plugin.class).icon();
		if (icons.containsKey(iconString)) {
			icon = icons.get(iconString);
		} else {
			icon = iconString.isEmpty() ? null : new ImageIcon(new URL(iconString));
			if (icon != null) {
				System.out.println(""[PluginDescriptorImpl] Found icon at "" + iconString);
			} else {
				System.out.println(""[PluginDescriptorImpl] Found no icon at "" + iconString);
			}
			icons.put(iconString, icon);
		}

		String urlString = method.getAnnotation(Plugin.class).url();
		if (urls.containsKey(urlString)) {
			url = urls.get(urlString);
		} else {
			url = urlString.isEmpty() ? null : new URL(urlString);
			urls.put(urlString, url);
		}

		//		System.out.println(""PluginDescriptorImpl,\"""" + name + ""\"",\"""" + (pack == null ? """" : pack.getName()) + ""\"""");

		parameterNames = Arrays.asList(getAnnotation(Plugin.class).parameterLabels());
		if (parameterNames.size() == 0) {
			parameterNames = new ArrayList<String>(parameterTypes.size());
			for (Class<?> par : list) {
				parameterNames.add(par.getSimpleName());
			}
		}

		returnTypes = Arrays.asList(getAnnotation(Plugin.class).returnTypes());
		assert (getAnnotation(Plugin.class).returnLabels().length == returnTypes.size());
		returnNames = Arrays.asList(getAnnotation(Plugin.class).returnLabels());
	}

	PluginDescriptorImpl(Class<?> type, Class<? extends PluginContext> acceptedContext, PackageDescriptor pack)
			throws Exception {
		assert (type != null);
		assert (type.isAnnotationPresent(Plugin.class));

		this.pack = pack;
		id = new PluginDescriptorIDImpl(type);
		annotatedElement = type;
		declaringClass = type;
		methods = new ArrayList<Method>();

		String[] pls = getAnnotation(Plugin.class).parameterLabels();

		int max = -1;
		for (Method method : type.getMethods()) {
			if (method.isAnnotationPresent(PluginVariant.class)) {
				if (method.getParameterTypes()[0].isAssignableFrom(acceptedContext)) {
					methods.add(method);
				}

				int[] requiredPar = method.getAnnotation(PluginVariant.class).requiredParameterLabels();
				for (int i : requiredPar) {
					if (i > max) {
						max = i;
					}
				}
			}
		}
		max++;

		parameterTypes = new ArrayList<List<Class<?>>>(methods.size());

		for (Method method : methods) {
			int[] requiredPar = method.getAnnotation(PluginVariant.class).requiredParameterLabels();
			ArrayList<Class<?>> list = new ArrayList<Class<?>>(method.getParameterTypes().length - 1);
			for (int i = 0; i < requiredPar.length; i++) {
				list.add(method.getParameterTypes()[i + 1]);
			}
			parameterTypes.add(list);
		}

		name = type.getAnnotation(Plugin.class).name();
		help = type.getAnnotation(Plugin.class).help();
		keywords = type.getAnnotation(Plugin.class).keywords();
		categories = type.getAnnotation(Plugin.class).categories();
		quality = type.getAnnotation(Plugin.class).quality();
		level = type.getAnnotation(Plugin.class).level();
		//		System.out.println(""PluginDescriptorImpl,\"""" + name + ""\"",\"""" + (pack == null ? """" : pack.getName()) + ""\"""");

		String iconString = type.getAnnotation(Plugin.class).icon();
		if (icons.containsKey(iconString)) {
			icon = icons.get(iconString);
		} else {
			/*
			 * Read the icon from a lib/images folder.
			 */
			InputStream url = Thread.currentThread().getContextClassLoader()
					.getResourceAsStream(""images/"" + iconString);
			if (url == null) {
				icon = null;
			} else {
				try {
					icon = new ImageIcon(ImageIO.read(url));
				} catch (IOException e) {
					icon = null;
				}
			}

			//			icon = iconString.isEmpty() ? null : new ImageIcon(new URL(iconString));
			if (icon != null) {
				System.out.println(""[PluginDescriptorImpl] Found icon at "" + iconString);
			} else {
				System.out.println(""[PluginDescriptorImpl] Found no icon at "" + iconString);
			}
			icons.put(iconString, icon);
		}

		String urlString = type.getAnnotation(Plugin.class).url();
		if (urls.containsKey(urlString)) {
			url = urls.get(urlString);
		} else {
			url = urlString.isEmpty() ? null : new URL(urlString);
			urls.put(urlString, url);
		}

		// There are either no parameters, or all parameters are required at least once
		// in all variants, ignoring the specific context.
		//
		if ((pls.length > 0) && (pls.length < max)) {
			String message = ""Plugin "" + name
					+ "" could not be added as a plugin. There is at lease one declared parameter type,""
					+ "" which is not used by any of the plugin's variants."";
			throw new AssertionError(message);
		}

		parameterNames = Arrays.asList(pls);

		returnTypes = Arrays.asList(type.getAnnotation(Plugin.class).returnTypes());
		assert (getAnnotation(Plugin.class).returnLabels().length == returnTypes.size());
		returnNames = Arrays.asList(type.getAnnotation(Plugin.class).returnLabels());
	}

	PluginDescriptorImpl(String className, String name, Class<?>[] parTypes, PackageDescriptor pack) throws Exception {
		this(Class.forName(className).getMethod(name, parTypes), pack);
	}

	public PackageDescriptor getPackage() {
		return pack;
	}

	public int getMostSignificantResult() {
		return getAnnotation(Plugin.class).mostSignificantResult();
	}

	AnnotatedElement getAnnotatedElement() {
		return annotatedElement;
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see
	 * org.processmining.framework.plugin.PluginDescriptor#hasAnnotation(java
	 * .lang.Class)
	 */
	public boolean hasAnnotation(Class<? extends Annotation> annotationClass) {
		return getAnnotatedElement().isAnnotationPresent(annotationClass);
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see
	 * org.processmining.framework.plugin.PluginDescriptor#getAnnotation(java
	 * .lang.Class)
	 */
	public <T extends Annotation> T getAnnotation(Class<T> annotationClass) {
		return getAnnotatedElement().getAnnotation(annotationClass);
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see org.processmining.framework.plugin.PluginDescriptor#getName()
	 */
	public String getName() {
		return name;
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see org.processmining.framework.plugin.PluginDescriptor#hashCode()
	 */
	@Override
	public int hashCode() {
		return id.hashCode();
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see
	 * org.processmining.framework.plugin.PluginDescriptor#equals(java.lang.
	 * Object)
	 */
	@Override
	public boolean equals(Object other) {
		if (!(other instanceof PluginDescriptorImpl)) {
			return false;
		}
		PluginDescriptorImpl otherDesc = (PluginDescriptorImpl) other;
		return id.equals(otherDesc.id);

		// note: this does not compare whether the plugins have been loaded by
		// the same class loader
		// return getMethod().getDeclaringClass().getName().equals(
		// otherDesc.getMethod().getDeclaringClass().getName())
		// && getMethod().getName()
		// .equals(otherDesc.getMethod().getName());
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see org.processmining.framework.plugin.PluginDescriptor#toString()
	 */
	@Override
	public String toString() {
		return getName();
	}

	protected Object[] execute(PluginContext context, int methodIndex, Object... allArgs) throws Exception {
		Method method = getMethod(methodIndex);
		if (returnTypes.size() > 1) { // method.getReturnType().isArray())
			// {
			Object[] result;
			if ((method.getModifiers() & Modifier.STATIC) == Modifier.STATIC) {
				result = (Object[]) method.invoke(null, allArgs);
			} else {
				result = (Object[]) method.invoke(declaringClass.newInstance(), allArgs);
			}

			return result;
		} else {
			Object result;
			if ((method.getModifiers() & Modifier.STATIC) == Modifier.STATIC) {
				result = method.invoke(null, allArgs);
			} else {
				result = method.invoke(declaringClass.newInstance(), allArgs);
			}

			return new Object[] { result };
		}
	}

	protected Method findMethod(Object[] allArgs) {
		for (Method m : ((Class<?>) annotatedElement).getMethods()) {
			if (m.isAnnotationPresent(PluginVariant.class)) {
				boolean match = (m.getParameterTypes().length == allArgs.length);
				for (int i = 0; (i < allArgs.length) && match; i++) {
					Class<?> type = m.getParameterTypes()[i];
					if (type.isArray()) {
						if (allArgs[i].getClass().isArray()) {
							for (Object o : (Object[]) allArgs[i]) {
								match &= type.getComponentType().isAssignableFrom(o.getClass());
							}
						} else {
							match = false;
						}
					} else {
						match &= type.isAssignableFrom(allArgs[i].getClass());
					}
				}
				if (match) {
					return m;
				}
			}
		}
		return null;
	}

	/**
	 * returns the labels of the objects returned if this plugin is invoked, in
	 * the order in which they are returned
	 * 
	 * @return
	 */
	public List<Class<? extends Object>> getReturnTypes() {
		return Collections.unmodifiableList(returnTypes);
	}

	public List<Class<?>> getParameterTypes(int methodIndex) {
		return Collections.unmodifiableList(getParameterTypes().get(methodIndex));
	}

	public Class<?> getPluginParameterType(int methodIndex, int parameterIndex) {
		if (methods.get(methodIndex).isAnnotationPresent(PluginVariant.class)) {
			int[] req = methods.get(methodIndex).getAnnotation(PluginVariant.class).requiredParameterLabels();
			for (int j = 0; j < req.length; j++) {
				if (req[j] == parameterIndex) {
					return parameterTypes.get(methodIndex).get(j);
				}
			}
			return null;
		} else {
			return parameterTypes.get(methodIndex).get(parameterIndex);
		}
	}

	public List<List<Class<?>>> getParameterTypes() {
		return Collections.unmodifiableList(parameterTypes);
	}

	public List<String> getParameterNames() {
		return Collections.unmodifiableList(parameterNames);
	}

	public Set<Class<?>> getTypesAtParameterIndex(int index) {
		HashSet<Class<?>> result = new HashSet<Class<?>>();
		for (int j = 0; j < methods.size(); j++) {
			Class<?> name = getPluginParameterType(j, index);
			if (name != null) {
				result.add(name);
			}
		}

		return result;
	}

	/**
	 * Return the number of methods in this plugin.
	 * 
	 * @return
	 */
	public int getNumberOfMethods() {
		return methods.size();
	}

	public List<String> getParameterNames(int methodIndex) {
		if (methods.get(methodIndex).isAnnotationPresent(PluginVariant.class)) {
			ArrayList<String> list = new ArrayList<String>();
			int[] req = methods.get(methodIndex).getAnnotation(PluginVariant.class).requiredParameterLabels();
			for (int i : req) {
				list.add(parameterNames.get(i));
			}
			return Collections.unmodifiableList(list);
		} else {
			return Collections.unmodifiableList(parameterNames);
		}
	}

	public String getPluginParameterName(int methodIndex, int parameterIndex) {
		if (methods.get(methodIndex).isAnnotationPresent(PluginVariant.class)) {
			int[] req = methods.get(methodIndex).getAnnotation(PluginVariant.class).requiredParameterLabels();
			for (int j = 0; j < req.length; j++) {
				if (req[j] == parameterIndex) {
					return parameterNames.get(parameterIndex);
				}
			}
			return null;
		} else {
			return parameterNames.get(parameterIndex);
		}
	}

	/**
	 * returns the types of the objects returned if this plugin is invoked, in
	 * the order in which they are returned
	 * 
	 * @return
	 */
	public List<String> getReturnNames() {
		return Collections.unmodifiableList(returnNames);
	}

	public PluginDescriptorID getID() {
		return id;
	}

	@SuppressWarnings(""unchecked"")
	public Class<? extends PluginContext> getContextType(int methodIndex) {
		return (Class<? extends PluginContext>) methods.get(methodIndex).getParameterTypes()[0];
	}

	public int compareTo(PluginDescriptor plugin) {
		if (plugin.equals(this)) {
			return 0;
		}

		int c = getName().toLowerCase().compareTo(plugin.getName().toLowerCase());
		if (c == 0) {
			c = id.compareTo(plugin.getID());
		}
		return c;
	}

	Method getMethod(int i) {
		return methods.get(i);
	}

	public int getIndexInParameterNames(int methodIndex, int methodParameterIndex) {
		if (methods.get(methodIndex).isAnnotationPresent(PluginVariant.class)) {
			int[] req = methods.get(methodIndex).getAnnotation(PluginVariant.class).requiredParameterLabels();
			return req[methodParameterIndex];
		} else {
			return methodParameterIndex;
		}
	}

	public int getIndexInMethod(int methodIndex, int parameterIndex) {
		if (methods.get(methodIndex).isAnnotationPresent(PluginVariant.class)) {
			int[] req = methods.get(methodIndex).getAnnotation(PluginVariant.class).requiredParameterLabels();
			for (int i = 0; i < req.length; i++) {
				if (req[i] == parameterIndex) {
					return i;
				}
			}
			return -1;
		} else {
			return parameterIndex;
		}
	}

	public String getMethodLabel(int methodIndex) {
		if (methods.get(methodIndex).isAnnotationPresent(PluginVariant.class)
				&& !methods.get(methodIndex).getAnnotation(PluginVariant.class).variantLabel().equals("""")) {
			return methods.get(methodIndex).getAnnotation(PluginVariant.class).variantLabel();
		} else {
			return name;
		}
	}

	public boolean isUserAccessible() {
		return getAnnotation(Plugin.class).userAccessible();
	}

	public boolean handlesCancel() {
		return getAnnotation(Plugin.class).handlesCancel();
	}

	public <T extends Annotation> T getAnnotation(Class<T> annotationClass, int methodIndex) {
		return getMethod(methodIndex).getAnnotation(annotationClass);
	}

	public boolean hasAnnotation(Class<? extends Annotation> annotationClass, int methodIndex) {
		return getMethod(methodIndex).getAnnotation(annotationClass) != null;
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see org.processmining.framework.plugin.PluginDescriptor#getName()
	 */
	public String getHelp() {
		return help;
	}

	public String getMethodHelp(int methodIndex) {
		if (methods.get(methodIndex).isAnnotationPresent(PluginVariant.class)
				&& !methods.get(methodIndex).getAnnotation(PluginVariant.class).help().equals("""")) {
			return methods.get(methodIndex).getAnnotation(PluginVariant.class).help();
		} else {
			return name;
		}
	}

	public String[] getKeywords() {
		return this.keywords;
	}

	public String[] getCategories() {
		String[] categoryLabels = new String[this.categories.length];
		for (int i = 0; i < this.categories.length; i++) {
			categoryLabels[i] = this.categories[i].getName();//.getName();
		}
		return categoryLabels;
	}

	public boolean meetsQualityThreshold() {
		return Boot.PLUGIN_QUALITY_THRESHOLD.getValue() <= quality.getValue();
	}

	public boolean meetsLevelThreshold() {
		return Boot.PLUGIN_LEVEL_THRESHOLD.getValue() <= level.getValue();
	}

	public ImageIcon getIcon() {
		return icon;
	}

	public URL getURL() {
		return url;
	}
}
"
PluginExecutionResultImpl.java,framework,"package org.processmining.framework.plugin.impl;

import java.util.Arrays;
import java.util.concurrent.CancellationException;
import java.util.concurrent.ExecutionException;

import org.processmining.framework.plugin.IncorrectReturnTypeException;
import org.processmining.framework.plugin.PluginDescriptor;
import org.processmining.framework.plugin.PluginExecutionResult;
import org.processmining.framework.plugin.ProMFuture;
import org.processmining.framework.plugin.events.NameChangeListener;
import org.processmining.framework.providedobjects.ProvidedObjectID;
import org.processmining.framework.util.Cast;

public class PluginExecutionResultImpl implements PluginExecutionResult {

	private Object[] objects;
	private Exception exception = null;
	private final Class<?>[] returnTypes;
	private final String pluginName;
	private final String[] returnNames;
	private final ProvidedObjectID[] ids;
	private Object[] parameters;
	private final PluginDescriptor plugin;

	public PluginExecutionResultImpl(Class<?>[] returnTypes, String[] returnNames, PluginDescriptor plugin) {
		this.returnNames = returnNames;
		this.plugin = plugin;
		pluginName = plugin.getName();
		objects = new Object[returnTypes.length];
		ids = new ProvidedObjectID[returnTypes.length];
		this.returnTypes = returnTypes;
		Arrays.fill(objects, null);
		Arrays.fill(ids, null);
	}

	public int getSize() {
		return returnNames.length;
	}

	void setResult(Object[] objects) throws IncorrectReturnTypeException {
		this.objects = objects;
		for (int i = 0; i < returnTypes.length; i++) {
			if (!returnTypes[i].equals(void.class)) {
				if (objects[i] == null) {
					continue;
				}
				Class<?> type = objects[i].getClass();
				if (objects[i] instanceof ProMFuture<?>) {
					type = Cast.<ProMFuture<?>>cast(objects[i]).getReturnType();
				}
				if (!returnTypes[i].isAssignableFrom(type)) {
					throw new IncorrectReturnTypeException(pluginName, i, returnTypes[i], objects[i].getClass());
				}
				if (objects[i] instanceof ProMFuture<?>) {
					final int index = i;
					((ProMFuture<?>) objects[i]).getNameChangeListeners().add(new NameChangeListener() {

						public void nameChanged(String newName) {
							returnNames[index] = newName;
						}
					});
				}
			}
		}
	}

	Object getObject(int resultIndex) {
		return objects[resultIndex];
	}

	void setException(Exception t) {
		exception = t;
	}

	Exception getException() {
		return exception;
	}

	@SuppressWarnings(""unchecked"")
	public <T> T getResult(int resultIndex) throws ClassCastException {
		return (T) getObject(resultIndex);
	}

	public String getResultName(int resultIndex) {
		synchronized (objects) {
			if (getObject(resultIndex) instanceof ProMFuture<?>) {
				return Cast.<ProMFuture<?>>cast(getObject(resultIndex)).getLabel();
			} else {
				return returnNames[resultIndex];
			}
		}
	}

	public String[] getResultNames() {
		return returnNames;
	}

	public Object[] getResults() {
		return objects;
	}

	public void synchronize() throws CancellationException, ExecutionException, InterruptedException {
		for (int i = 0; i < objects.length; i++) {
			if (objects[i] instanceof ProMFuture<?>) {
				Object o = Cast.<ProMFuture<?>>cast(objects[i]).get();
				synchronized (objects) {
					objects[i] = o;
				}
			}
		}
	}

	int getExpectedSize() {
		return objects.length;
	}

	public void setProvidedObjectID(int i, ProvidedObjectID id) {
		ids[i] = id;
	}

	public ProvidedObjectID getProvidedObjectID(int i) {
		return ids[i];
	}

	public void setInput(Object[] parameters) {
		this.parameters = parameters;
	}

	public Object[] getParameters() {
		return parameters;
	}

	@SuppressWarnings(""unchecked"")
	public <T> Class<? super T> getType(int i) {
		return (Class<? super T>) returnTypes[i];
	}

	public PluginDescriptor getPlugin() {
		return plugin;
	}

}
"
PluginManagerImpl.java,framework,"package org.processmining.framework.plugin.impl;

import java.io.File;
import java.io.FileFilter;
import java.io.IOException;
import java.io.InputStream;
import java.lang.annotation.Annotation;
import java.lang.reflect.AnnotatedElement;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.net.MalformedURLException;
import java.net.URISyntaxException;
import java.net.URL;
import java.net.URLClassLoader;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Queue;
import java.util.Set;
import java.util.SortedSet;
import java.util.TreeSet;
import java.util.jar.JarEntry;
import java.util.jar.JarInputStream;

import javax.swing.event.EventListenerList;

import org.processmining.framework.boot.Boot;
import org.processmining.framework.boot.Boot.Level;
import org.processmining.framework.packages.PackageDescriptor;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.PluginDescriptor;
import org.processmining.framework.plugin.PluginDescriptorID;
import org.processmining.framework.plugin.PluginManager;
import org.processmining.framework.plugin.PluginParameterBinding;
import org.processmining.framework.plugin.annotations.Bootable;
import org.processmining.framework.plugin.annotations.KeepInProMCache;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.framework.util.Pair;
import org.processmining.framework.util.collection.ComparablePair;

public final class PluginManagerImpl implements PluginManager {

	private static final char PACKAGE_SEPARATOR = '.';
	private static final char URL_SEPARATOR = '/';
	private static final char INNER_CLASS_MARKER = '$';

	private static PluginManagerImpl pluginManager;

	private final Set<Class<?>> knownObjectTypes = new HashSet<Class<?>>();

	private final Map<PluginDescriptorID, PluginDescriptor> plugins = new HashMap<PluginDescriptorID, PluginDescriptor>();
	private final Map<Class<? extends Annotation>, Set<PluginDescriptor>> annotation2plugins = new HashMap<Class<? extends Annotation>, Set<PluginDescriptor>>();
	private final EventListenerList pluginManagerListeners = new EventListenerList();
	private final Class<? extends PluginContext> pluginContextType;

	private final Map<Class<? extends Annotation>, Set<Class<?>>> annotatedClasses = new HashMap<Class<? extends Annotation>, Set<Class<?>>>();

	private PluginManagerImpl(Class<? extends PluginContext> pluginContextType) {
		this.pluginContextType = pluginContextType;
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see
	 * org.processmining.framework.plugin.PluginManager#addErrorListener(org
	 * .processmining.framework.plugin.PluginManagerImpl.ErrorListener)
	 */
	public void addListener(PluginManagerListener listener) {
		pluginManagerListeners.add(PluginManagerListener.class, listener);
	}

	public Set<Class<?>> getKnownClassesAnnotatedWith(Class<? extends Annotation> annotationType) {
		Set<Class<?>> set = annotatedClasses.get(annotationType);
		if (set == null) {
			return Collections.emptySet();
		} else {
			return Collections.unmodifiableSet(set);
		}
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see
	 * org.processmining.framework.plugin.PluginManager#removeErrorListener(
	 * org.processmining.framework.plugin.PluginManagerImpl.ErrorListener)
	 */
	public void removeListener(PluginManagerListener listener) {
		pluginManagerListeners.remove(PluginManagerListener.class, listener);
	}

	protected void fireError(URL url, Throwable t, String className) {
		for (PluginManagerListener listener : pluginManagerListeners.getListeners(PluginManagerListener.class)) {
			listener.error(url, t, className);
		}

	}

	protected void firePluginAdded(PluginDescriptor plugin, Collection<Class<?>> types) {
		for (PluginManagerListener listener : pluginManagerListeners.getListeners(PluginManagerListener.class)) {
			listener.newPlugin(plugin, types);
		}
	}

	public static void initialize(Class<? extends PluginContext> pluginContextType) {
		if (pluginManager == null) {
			pluginManager = new PluginManagerImpl(pluginContextType);
		}
	}

	public static PluginManager getInstance() {
		return pluginManager;
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see
	 * org.processmining.framework.plugin.PluginManager#register(java.net.URL)
	 */
	public void register(URL url, PackageDescriptor pack) {
		URLClassLoader loader = new URLClassLoader(new URL[] { url });
		register(url, pack, loader);
	}

	public void register(URL url, PackageDescriptor pack, ClassLoader loader) {
		if (url.getProtocol().equals(FILE_PROTOCOL)) {
			try {
				File file = new File(url.toURI());

				if (file.isDirectory()) {
					scanDirectory(file, pack, loader);
					return;
				}
				//				if (file.getAbsolutePath().endsWith(PluginManager.MCR_EXTENSION)) {
				//					try {
				//						loadClassFromMacro(url.toURI(), pack);
				//					} catch (DependsOnUnknownException e) {
				//						// Can't add this URL.
				//					}
				//				}
				if (file.getAbsolutePath().endsWith(JAR_EXTENSION)) {
					scanUrl(url, pack, loader);
				}
			} catch (URISyntaxException e) {
				fireError(url, e, null);
			}
		} else {
			scanUrl(url, pack, loader);
		}
	}

	private void scanDirectory(File file, PackageDescriptor pack, ClassLoader loader) {
		try {
			URL url = file.toURI().toURL();

			Queue<File> todo = new LinkedList<File>();
			FileFilter filter = new FileFilter() {
				public boolean accept(File pathname) {
					return pathname.isDirectory() || pathname.getPath().endsWith(CLASS_EXTENSION)
							|| pathname.getPath().endsWith(MCR_EXTENSION) || pathname.getPath().endsWith(JAR_EXTENSION);

				}
			};

			todo.add(file);
			while (!todo.isEmpty()) {
				File dir = todo.remove();

				for (File f : dir.listFiles(filter)) {
					if (f.isDirectory()) {
						todo.add(f);
					} else {
						if (f.getAbsolutePath().endsWith(CLASS_EXTENSION)) {
							loadClassFromFile(loader, url,
									makeRelativePath(file.getAbsolutePath(), f.getAbsolutePath()), pack);
							//						} else if (f.getAbsolutePath().endsWith(MCR_EXTENSION)) {
							//							try {
							//								loadClassFromMacro(f.toURI(), pack);
							//							} catch (DependsOnUnknownException e) {
							//								todo.add(dir);
							//							}
						} else if (f.getAbsolutePath().endsWith(JAR_EXTENSION)) {
							scanUrl(f.toURI().toURL(), pack, loader);
						}
					}
				}
			}
		} catch (MalformedURLException e) {
			fireError(null, e, null);
		}
	}

	private String makeRelativePath(String root, String absolutePath) {
		String relative = absolutePath;

		if (relative.startsWith(root)) {
			relative = relative.substring(root.length());
			if (relative.startsWith(File.separator)) {
				relative = relative.substring(File.separator.length());
			}
		}
		return relative;
	}

	private void scanUrl(URL url, PackageDescriptor pack, ClassLoader loader) {

		PluginCacheEntry cached = new PluginCacheEntry(url, Boot.VERBOSE, pack);

		if (cached.isInCache()) {
			for (String className : cached.getCachedClassNames()) {
				loadClass(loader, url, className, pack);
			}
		} else {
			try {
				InputStream is = url.openStream();
				JarInputStream jis = new JarInputStream(is);
				JarEntry je;
				List<String> loadedClasses = new ArrayList<String>();

				while ((je = jis.getNextJarEntry()) != null) {
					if (!je.isDirectory() && je.getName().endsWith(CLASS_EXTENSION)) {
						String loadedClass = loadClassFromFile(loader, url, je.getName(), pack);
						if (loadedClass != null) {
							loadedClasses.add(loadedClass);
						}
					}
				}
				jis.close();
				is.close();

				cached.update(loadedClasses);
			} catch (IOException e) {
				fireError(url, e, null);
			}
		}
	}

	private String loadClassFromFile(ClassLoader loader, URL url, String classFilename, PackageDescriptor pack) {
		if (classFilename.indexOf(INNER_CLASS_MARKER) >= 0) {
			// we're not going to load inner classes
			return null;
		}
		return loadClass(loader, url,
				classFilename.substring(0, classFilename.length() - CLASS_EXTENSION.length())
						.replace(URL_SEPARATOR, PACKAGE_SEPARATOR).replace(File.separatorChar, PACKAGE_SEPARATOR),
				pack);
	}

	//	private String loadClassFromMacro(URI macroFile, PackageDescriptor pack) throws DependsOnUnknownException {
	//		MacroPluginDescriptorImpl plugin = null;
	//		try {
	//			plugin = new MacroPluginDescriptorImpl(new File(macroFile), this, pack);
	//			addPlugin(plugin);
	//		} catch (DOMException e) {
	//			e.printStackTrace();
	//		} catch (IOException e) {
	//			e.printStackTrace();
	//		} catch (SAXException e) {
	//			e.printStackTrace();
	//		} catch (ParserConfigurationException e) {
	//			e.printStackTrace();
	//		} catch (ClassNotFoundException e) {
	//			e.printStackTrace();
	//		} catch (DependsOnUnknownException e) {
	//			throw e;
	//		}
	//		return plugin == null ? null : plugin.getFileName();
	//	}

	/**
	 * Returns the name of the class, if it is annotated, or if any of its
	 * methods carries a plugin annotation!
	 * 
	 * @param loader
	 * @param url
	 * @param className
	 * @return
	 */
	private String loadClass(ClassLoader loader, URL url, String className, PackageDescriptor pack) {
		boolean isAnnotated = false;

		if ((className == null) || className.trim().equals("""") || className.startsWith(""bin-test-instrument"") || className.equals(loader.getClass().getName())) {
			return null;
		}

		className = className.trim();
		try {
			Class<?> pluginClass = Class.forName(className, false, loader);
			//isAnnotated = (pluginClass.getAnnotations().length > 0);

			// register all annotated classes
			if (pluginClass.isAnnotationPresent(KeepInProMCache.class)
					&& !Modifier.isAbstract(pluginClass.getModifiers())) {
				Annotation[] annotations = pluginClass.getAnnotations();
				isAnnotated = true;
				for (int i = 0; i < annotations.length; i++) {
					Set<Class<?>> set = annotatedClasses.get(annotations[i].annotationType());
					if (set == null) {
						set = new HashSet<Class<?>>();
						annotatedClasses.put(annotations[i].annotationType(), set);
					}
					set.add(pluginClass);
				}
			}

			Method[] methods = pluginClass.getMethods();
			// Check if plugin annotation is present
			if (pluginClass.isAnnotationPresent(Plugin.class) && isGoodPlugin(pluginClass, methods)) {
				PluginDescriptorImpl pl = new PluginDescriptorImpl(pluginClass, pluginContextType, pack);
				addPlugin(pl);
				isAnnotated = true;
			}

			for (Method method : methods) {
				if (method.isAnnotationPresent(Plugin.class) && isGoodPlugin(method)) {
					try {
						PluginDescriptorImpl pl = new PluginDescriptorImpl(method, pack);
						addPlugin(pl);
						isAnnotated = true;
					} catch (Exception e) {
						fireError(url, e, className);
						if (Boot.VERBOSE != Level.NONE) {
							System.err.println(""ERROR while adding plugin: "" + url + "":"" + e.getMessage());
						}
					}
				}
			}
		} catch (Throwable t) {
			fireError(url, t, className);
			if (Boot.VERBOSE != Level.NONE) {
				System.err.println(""ERROR while scanning for plugins at: "" + url + "":"");
				System.err.println(""   in file :"" + className);
				System.err.println(""   "" + t.getMessage());
				//t.printStackTrace();
			}
		}
		if (isAnnotated && !className.startsWith(""org.processmining."")) {
			System.err.println(""INFO class "" + className + "" contains plug-ins."");
		}
		return isAnnotated ? className : null;
	}

	private void addPlugin(PluginDescriptorImpl pl) {
		PluginDescriptorImpl old = (PluginDescriptorImpl) plugins.put(pl.getID(), pl);

		/*
		 * HV 20181130
		 * Sometimes, ProM seems to freeze when started after having updated or installed packages.
		 * However, instead of freezing it seems to be in a busy wait due to an endless loop related
		 * to the annotation2plunis variable. Somehow, it loops endlessly over a set in this map.
		 * Apparently, this set is corrupted somehow. Possibly, the code below is not reentrant.
		 * Therefore, I've added the synchronized on the variable.
		 */
		synchronized (annotation2plugins) {
			if (old != null) {
				if (Boot.VERBOSE == Level.ALL) {
					System.out.println(""Found new version of plugin: "" + pl.getName() + "" ....overwriting."");
				}
				for (Annotation annotation : old.getAnnotatedElement().getAnnotations()) {
					annotation2plugins.get(annotation.annotationType()).remove(old);
				}
			}

			for (Annotation annotation : pl.getAnnotatedElement().getAnnotations()) {
				Set<PluginDescriptor> pls = annotation2plugins.get(annotation.annotationType());
				if (pls == null) {
					pls = new TreeSet<PluginDescriptor>();
					annotation2plugins.put(annotation.annotationType(), pls);
				}
				pls.add(pl);

			}
		}
		checkTypesAfterAdd(pl);

	}

	//	private void addPlugin(MacroPluginDescriptorImpl pl) {
	//		PluginDescriptor old = plugins.put(pl.getID(), pl);
	//
	//		if (old != null) {
	//			if (Boot.VERBOSE == Level.ALL) {
	//				System.out.println(""Found new version of plugin: "" + pl.getName() + "" ....overwriting."");
	//			}
	//			annotation2plugins.get(Plugin.class).remove(old);
	//		}
	//
	//		Set<PluginDescriptor> pls = annotation2plugins.get(Plugin.class);
	//		if (pls == null) {
	//			pls = new TreeSet<PluginDescriptor>();
	//			annotation2plugins.put(Plugin.class, pls);
	//		}
	//		pls.add(pl);
	//
	//		checkTypesAfterAdd(pl);
	//	}

	private void checkTypesAfterAdd(PluginDescriptor pl) {
		HashSet<Class<?>> newTypes = new HashSet<Class<?>>();
		for (List<Class<?>> parTypes : pl.getParameterTypes()) {
			newTypes.addAll(addKnownObjectTypes(parTypes));
		}
		newTypes.addAll(addKnownObjectTypes(pl.getReturnTypes()));

		firePluginAdded(pl, newTypes);
	}

	private Collection<Class<?>> addKnownObjectTypes(Collection<Class<?>> types) {
		List<Class<?>> newTypes = new ArrayList<Class<?>>();
		for (Class<?> type : types) {
			if (type.isArray()) {
				if (knownObjectTypes.add(type.getComponentType())) {
					newTypes.add(type.getComponentType());
				}
			}
			if (knownObjectTypes.add(type)) {
				newTypes.add(type);
			}
		}
		return newTypes;
	}

	private boolean isGoodPlugin(Class<?> type, Method[] methods) {
		try {
			if (!isRightlyAnnotated(type)) {
				return false;
			}
			String[] names = type.getAnnotation(Plugin.class).parameterLabels();
			Class<?>[] returnTypes = type.getAnnotation(Plugin.class).returnTypes();

			// Check if there is at least one method annotated with PluginVariant
			List<Method> pluginMethods = new ArrayList<Method>(methods.length);
			for (Method m : methods) {
				if (m.isAnnotationPresent(PluginVariant.class)) {
					pluginMethods.add(m);
				}
			}

			// Check if for all methods, the requiredTypes are set Correctly
			Iterator<Method> it = pluginMethods.iterator();
			loop: while (it.hasNext()) {
				Method m = it.next();
				int[] required = m.getAnnotation(PluginVariant.class).requiredParameterLabels();
				Set<Integer> set = new HashSet<Integer>();
				for (int i : required) {
					set.add(i);
					if ((i < 0) || (i >= names.length)) {
						if (Boot.VERBOSE != Level.NONE) {
							System.err.println(""Method "" + m.toString()
									+ "" could not be added as a plugin. At least one required parameter is not a valid index.""
									+ ""There is no parameterlabel at index "" + i);
						}
						it.remove();
						continue loop;
					}
				}
				if (set.size() != required.length) {
					if (Boot.VERBOSE != Level.NONE) {
						System.err.println(""Method "" + m.toString()
								+ "" could not be added as a plugin. Some required indices are duplicated."");
					}
					it.remove();
				}
			}

			// Check for corresponding contexts at first indes
			it = pluginMethods.iterator();
			loop: while (it.hasNext()) {
				Method m = it.next();
				if (!isCorrectPluginContextType(m)) {
					if (Boot.VERBOSE != Level.NONE) {
						System.err.println(""Method "" + m.toString()
								+ "" could not be added as a plugin. The context should be asked as first parameter and should be a the same, or a superclass of ""
								+ pluginContextType.getName() + ""."");
					}
					it.remove();
					continue loop;
				}
			}

			it = pluginMethods.iterator();
			loop: while (it.hasNext()) {
				Method m = it.next();
				if ((returnTypes.length > 1) && !Object[].class.isAssignableFrom(m.getReturnType())
						&& !Object.class.equals(m.getReturnType())) {
					if (Boot.VERBOSE != Level.NONE) {
						System.err.println(""Method "" + m.toString()
								+ "" could not be added as a plugin. The plugin should return an array of objects as specified in the context."");
					}
					it.remove();
					continue loop;
				}
			}

			if (pluginMethods.isEmpty()) {
				if (Boot.VERBOSE != Level.NONE) {
					System.err.println(""Plugin "" + type.toString()
							+ "" could not be added as a plugin. At least one variant has to be specified."");
				}
				return false;
			}

			return true;

		} catch (NoClassDefFoundError e) {
			// required class not on classpath, cannot load as plugin
			return false;
		}
	}

	private boolean isCorrectPluginContextType(Method method) {
		if (method.getParameterTypes().length == 0) {
			return false;
		}
		if (!PluginContext.class.isAssignableFrom(method.getParameterTypes()[0])) {
			return false;
		}
		if (!method.getParameterTypes()[0].isAssignableFrom(pluginContextType)) {
			return false;
		}
		return true;
	}

	private boolean isRightlyAnnotated(AnnotatedElement element) {
		if (element.getAnnotation(Plugin.class).returnLabels().length != element.getAnnotation(Plugin.class)
				.returnTypes().length) {
			if (Boot.VERBOSE != Level.NONE) {
				System.err.println(""Plugin "" + element.toString() + "" could not be added as a plugin, the number of ""
						+ ""return types and return labels do not match."");
			}
			return false;
		}
		return true;
	}

	private boolean isGoodPlugin(Method method) throws NoClassDefFoundError {
		try {
			if (!isRightlyAnnotated(method)) {
				return false;
			}

			if ((method.getAnnotation(Plugin.class).parameterLabels().length != 0)
					&& (method.getAnnotation(Plugin.class).parameterLabels().length != method.getParameterTypes().length
							- 1)) {
				if (Boot.VERBOSE != Level.NONE) {
					System.err.println(""Plugin "" + method.toString() + "" could not be added as a plugin, the number of""
							+ "" parameter labels does not match the number of parameters."");
				}
				return false;
			}

			//		if (void.class.equals(method.getReturnType())) {
			//			System.err.println(""Method "" + method.toGenericString()
			//					+ "" could not be added as a plugin, as the resultType is void."");
			//			return false;
			//		}

			Class<?>[] returnTypes = method.getAnnotation(Plugin.class).returnTypes();
			if ((returnTypes.length > 1) && !Object[].class.isAssignableFrom(method.getReturnType())
					&& !Object.class.equals(method.getReturnType())) {
				if (Boot.VERBOSE != Level.NONE) {
					System.err.println(""Method "" + method.toString()
							+ "" could not be added as a plugin. The plugin should return an ""
							+ ""array of objects as specified in the context."");
				}
				return false;
			}

			Class<?>[] pars = method.getParameterTypes();
			if (!isCorrectPluginContextType(method)) {
				if (!method.isAnnotationPresent(Bootable.class)) {
					if (Boot.VERBOSE != Level.NONE) {
						System.err.println(""Method "" + method.toGenericString()
								+ "" could not be added as a plugin, the first parameter has to be a ""
								+ ""PluginContext and assignable from "" + pluginContextType.getName() + ""."");
					}
				}
				return false;
			}
			for (int i = 1; i < pars.length; i++) {
				Class<?> type = pars[i];
				if (PluginContext.class.isAssignableFrom(type)) {
					if (Boot.VERBOSE != Level.NONE) {
						System.err.println(""Method "" + method.toGenericString()
								+ "" could not be added as a plugin, only one context can be requested."");
					}
					return false;
				}
			}
			for (int i = 0; i < pars.length; i++) {
				if (pars[i].getTypeParameters().length > 0) {
					if (Boot.VERBOSE != Level.NONE) {
						System.err.println(""Method "" + method.toGenericString()
								+ "" could not be added as a plugin, as one of the parameters ""
								+ ""is derived from a Type using Generics"");
					}
					return false;
				}
			}
			return true;
		} catch (NoClassDefFoundError e) {
			// required class not on classpath, cannot load as plugin
			return false;
		}
	}

	public Set<Pair<Integer, PluginParameterBinding>> find(Class<? extends Annotation> annotation, Class<?> resultType,
			Class<? extends PluginContext> contextType, boolean totalMatch, boolean orderedParameters,
			boolean mustBeUserVisible, Class<?>... parameters) {

		Set<Pair<Integer, PluginParameterBinding>> result = new TreeSet<Pair<Integer, PluginParameterBinding>>();
		Set<PluginDescriptor> pls = annotation2plugins.get(annotation);
		if (pls == null) {
			return result;
		}
		for (PluginDescriptor plugin : pls) {
			if (mustBeUserVisible && (!plugin.meetsQualityThreshold() || !plugin.meetsLevelThreshold())) {
				/*
				 * Plug-in does not meet some required threshold to do so.
				 * Ignore it.
				 */
				continue;
			}
			if (!mustBeUserVisible || plugin.isUserAccessible()) {
				int i = (resultType == null ? 0 : plugin.getReturnTypes().indexOf(resultType));
				if (i < 0) {
					// Check for returned subtypes of the requested type
					i = checkIfRequestedReturnTypeIsPresent(plugin, resultType);
				}
				if (i >= 0) {
					for (int j = 0; j < plugin.getParameterTypes().size(); j++) {
						if (!plugin.getContextType(j).isAssignableFrom(contextType)) {
							// Check context types
							continue;
						}

						List<PluginParameterBinding> list = PluginParameterBinding.Factory.tryToBind(this, plugin, j,
								totalMatch, orderedParameters, parameters);
						for (PluginParameterBinding binding : list) {

							result.add(new ComparablePair<Integer, PluginParameterBinding>(i, binding));
							//							// Quit the loop since only one binding is to be
							//							// found.
							//							j = plugin.getParameterTypes().size();
						}
					}
				}
			}
		}
		return result;
	}

	public Set<Pair<Integer, PluginParameterBinding>> find(Class<? extends Annotation> annotation,
			Class<?>[] resultTypes, Class<? extends PluginContext> contextType, boolean totalMatch,
			boolean orderedParameters, boolean mustBeUserVisible, Class<?>... parameters) {

		if (resultTypes == null || resultTypes.length == 0) {
			throw new UnsupportedOperationException(
					""Cannot find plugins with empty or null list of return types using the find method with list input."");
		}

		Set<Pair<Integer, PluginParameterBinding>> result = new TreeSet<Pair<Integer, PluginParameterBinding>>();
		Set<PluginDescriptor> pls = annotation2plugins.get(annotation);
		if (pls == null) {
			return result;
		}
		for (PluginDescriptor plugin : pls) {
			if (mustBeUserVisible && (!plugin.meetsQualityThreshold() || !plugin.meetsLevelThreshold())) {
				/*
				 * Plug-in does not meet some required threshold to do so.
				 * Ignore it.
				 */
				continue;
			}
			if (!mustBeUserVisible || plugin.isUserAccessible()) {
				List<Class<?>> returnTypes = plugin.getReturnTypes();
				int[] indices = new int[resultTypes.length];
				boolean ok = returnTypes.size() == indices.length;

				for (int r = 0; ok && r < resultTypes.length; r++) {
					Class<?> resultType = resultTypes[r];
					// check if return type at index r is the right type
					ok &= isParameterAssignable(returnTypes.get(r), resultTypes[r]);
				}
				if (ok) {
					for (int j = 0; j < plugin.getParameterTypes().size(); j++) {
						if (!plugin.getContextType(j).isAssignableFrom(contextType)) {
							// Check context types
							continue;
						}

						List<PluginParameterBinding> list = PluginParameterBinding.Factory.tryToBind(this, plugin, j,
								totalMatch, orderedParameters, parameters);
						for (PluginParameterBinding binding : list) {

							for (int r = 0; r < resultTypes.length; r++) {
								result.add(new ComparablePair<Integer, PluginParameterBinding>(r, binding));
							}
							//							// Quit the loop since only one binding is to be
							//							// found.
							//							j = plugin.getParameterTypes().size();
						}
					}
				}
			}
		}
		return result;
	}

	private int checkIfRequestedReturnTypeIsPresent(PluginDescriptor plugin, Class<?> resultType) {
		for (int i = 0; i < plugin.getReturnTypes().size(); i++) {
			if (isParameterAssignable(plugin.getReturnTypes().get(i), resultType)) {
				return i;
			}
		}

		return -1;
	}

	public Collection<PluginDescriptor> find(String pluginName) {
		List<PluginDescriptor> result = new ArrayList<PluginDescriptor>();
		for (PluginDescriptor plugin : plugins.values()) {
			if (plugin.getName().equals(pluginName)) {
				result.add(plugin);
			}
		}
		return result;
	}

	public PluginDescriptor getPlugin(PluginDescriptorID id) {
		return plugins.get(id);
	}

	public PluginDescriptor getPlugin(String id) {
		for (Map.Entry<PluginDescriptorID, PluginDescriptor> entry : plugins.entrySet()) {
			if (entry.getKey().toString().equals(id)) {
				return entry.getValue();
			}
		}
		return null;
	}

	public Set<PluginParameterBinding> getPluginsAcceptingAtLeast(Class<? extends PluginContext> contextType,
			boolean mustBeUserVisible, Class<?>... parameters) {
		Set<PluginParameterBinding> result = new TreeSet<PluginParameterBinding>();
		for (Pair<Integer, PluginParameterBinding> pair : find(Plugin.class, (Class<?>) null, contextType, false, false,
				mustBeUserVisible, parameters)) {
			result.add(pair.getSecond());
		}
		return result;
	}

	public Set<PluginParameterBinding> getPluginsAcceptingInAnyOrder(Class<? extends PluginContext> contextType,
			boolean mustBeUserVisible, Class<?>... parameters) {
		Set<PluginParameterBinding> result = new TreeSet<PluginParameterBinding>();
		for (Pair<Integer, PluginParameterBinding> pair : find(Plugin.class, (Class<?>) null, contextType, true, false,
				mustBeUserVisible, parameters)) {
			result.add(pair.getSecond());
		}
		return result;
	}

	public Set<PluginParameterBinding> getPluginsAcceptingOrdered(Class<? extends PluginContext> contextType,
			boolean mustBeUserVisible, Class<?>... parameters) {
		Set<PluginParameterBinding> result = new TreeSet<PluginParameterBinding>();
		for (Pair<Integer, PluginParameterBinding> pair : find(Plugin.class, (Class<?>) null, contextType, true, true,
				mustBeUserVisible, parameters)) {
			result.add(pair.getSecond());
		}
		return result;
	}

	public Set<Pair<Integer, PluginDescriptor>> getPluginsResultingIn(Class<?> resultType,
			Class<? extends PluginContext> contextType, boolean mustBeUserVisible) {
		Set<Pair<Integer, PluginDescriptor>> result = new TreeSet<Pair<Integer, PluginDescriptor>>();
		for (Pair<Integer, PluginParameterBinding> pair : find(Plugin.class, resultType, contextType, false, false,
				mustBeUserVisible)) {
			result.add(new ComparablePair<Integer, PluginDescriptor>(pair.getFirst(), pair.getSecond().getPlugin()));
		}
		for (Pair<Integer, PluginParameterBinding> pair : find(Plugin.class, resultType, contextType, true, false,
				mustBeUserVisible)) {
			result.add(new ComparablePair<Integer, PluginDescriptor>(pair.getFirst(), pair.getSecond().getPlugin()));
		}
		return result;
	}

	private SortedSet<PluginDescriptor> getAllPluginsSorted(boolean canBeUserVisible, boolean mustBeUserVisible) {
		SortedSet<PluginDescriptor> result = new TreeSet<PluginDescriptor>();
		for (PluginDescriptor plugin : plugins.values()) {
			boolean visible = plugin.isUserAccessible();
			if (mustBeUserVisible && (!plugin.meetsQualityThreshold() || !plugin.meetsLevelThreshold())) {
				/*
				 * Plug-in can be user visible (that is, should end up in the
				 * GUI), but does not meet some required threshold. Ignore it.
				 */
				continue;
			}
			// Do not include, if:
			// mustBeUserVisible AND NOT visible, OR
			// visible AND NOT canBeUserVisible
			if (!((mustBeUserVisible && !visible) || (!canBeUserVisible && visible))) {
				result.add(plugin);
			}
		}
		return Collections.unmodifiableSortedSet(result);
	}

	public SortedSet<PluginDescriptor> getAllPlugins() {
		return getAllPluginsSorted(true, false);
	}

	public SortedSet<PluginDescriptor> getAllPlugins(boolean mustBeVisible) {
		return getAllPluginsSorted(mustBeVisible, mustBeVisible);
	}

	public boolean isParameterAssignable(Class<?> instanceType, Class<?> requestedType) {
		if (requestedType.isAssignableFrom(instanceType)) {
			return true;
		}
		if (requestedType.isArray() && requestedType.getComponentType().isAssignableFrom(instanceType)) {
			return true;
		}
		return false;
	}

	public Set<Class<?>> getKnownObjectTypes() {
		return Collections.unmodifiableSet(knownObjectTypes);
	}

}"
ProgressBarImpl.java,framework,"package org.processmining.framework.plugin.impl;

import java.util.ArrayList;
import java.util.List;

import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.PluginExecutionResult;
import org.processmining.framework.plugin.ProMFuture;
import org.processmining.framework.plugin.Progress;

public class ProgressBarImpl implements Progress {

	private int value = 0;
	private int min = 0;
	private int max = 1;
	private boolean indeterminate = true;
	private String message = """";

	private static final long serialVersionUID = -3950799546173352932L;
	private final PluginContext context;
	private boolean canceled = false;

	public ProgressBarImpl(PluginContext context) {
		this.context = context;
	}

	public void setCaption(String message) {
		this.message = message;
		context.getProgressEventListeners().fireProgressCaptionChanged(message);
	}

	public void inc() {
		context.getProgressEventListeners().fireProgressChanged(++value);
		// Thread.yield();
	}

	public void setMinimum(int value) {
		min = value;
		context.getProgressEventListeners().fireProgressBoundsChanged(min, max);
	}

	public void setMaximum(int value) {
		max = value;
		context.getProgressEventListeners().fireProgressBoundsChanged(min, max);
	}

	public void setValue(int value) {
		this.value = value;
		context.getProgressEventListeners().fireProgressChanged(value);
		// Thread.yield();
	}

	public int getValue() {
		return value;
	}

	public void setIndeterminate(boolean makeIndeterminate) {
		indeterminate = makeIndeterminate;
		context.getProgressEventListeners().fireProgressIndeterminateChanged(makeIndeterminate);
	}

	public String getCaption() {
		return message;
	}

	public boolean isIndeterminate() {
		return indeterminate;
	}

	public int getMaximum() {
		return max;
	}

	public int getMinimum() {
		return min;
	}

	public boolean isCancelled() {
		PluginExecutionResult results = context.getResult();
		// [HV] To be safe, check the following:
		if (results == null) {
			return false;
		}
		for (int i = 0; !canceled && (i < results.getSize()); i++) {
			try {
				Object o = results.getResult(i);
				if (o instanceof ProMFuture<?>) {
					return results.<ProMFuture<?>>getResult(i).isCancelled();
				}
			} catch (Exception e) {
				// cancel on fail;
				return true;
			}
		}
		return canceled;
	}

	public void cancel() {
		canceled = true;
		// BVD: Cancel all children too!
		List<PluginContext> children = new ArrayList<>(context.getChildContexts());
		for (PluginContext child : children) {
			if (child != null && child.getProgress() != null) {
				child.getProgress().cancel();
			}
		}
		// Now cancel ProMFutures
		PluginExecutionResult results = context.getResult();
		for (int i = 0; i < results.getSize(); i++) {
			Object o = results.getResult(i);
			if (o instanceof ProMFuture<?>) {
				results.<ProMFuture<?>>getResult(i).cancel(true);
			}
		}
	}

}
"
IncorrectReturnTypeException.java,framework,"package org.processmining.framework.plugin;

/**
 * Thrown when a plugin returns an object of the wrong type.
 * 
 * @author bfvdonge
 * 
 */
public class IncorrectReturnTypeException extends RuntimeException {

	private static final long serialVersionUID = 8553687837509819311L;

	public IncorrectReturnTypeException(String plugin, int index, Class<?> expected, Class<?> returned) {
		super(""Plugin "" + plugin + "" produced the wrong type of result at index "" + index + "": Expected: "" + expected
				+ "", but received: "" + (returned == null ? ""nothing"" : returned) + ""."");
	}
}
"
InSufficientResultException.java,framework,"package org.processmining.framework.plugin;

/**
 * Thrown when a plugin returns less results than declared.
 * 
 * @author bfvdonge
 * 
 */
public class InSufficientResultException extends RuntimeException {

	private static final long serialVersionUID = -1416206990218147728L;

	public InSufficientResultException(String plugin, int expected, int returned) {
		super(""Plugin "" + plugin + "" produced "" + returned + "" results, while "" + expected + "" results were declared."");
	}

}
"
ObjectConstructor.java,framework,"package org.processmining.framework.plugin;

import java.util.Collection;

import org.processmining.framework.connections.Connection;
import org.processmining.framework.connections.ConnectionCannotBeObtained;

public interface ObjectConstructor {

	/**
	 * Finds as many objects of the given type as can be found through the
	 * connections of the other given type. If no objects can be found, it
	 * constructs as many objects of the given type as there are plugins
	 * available to the framework to do so. These plugins should be able to
	 * execute in a child of the given context and accept, in any order, exactly
	 * the input provided. Any other objects returned by the plugin, not being
	 * the requested type are added to the provided objects of the framework.
	 * Also, listeners are notified where applicable. If no plugings exist, or
	 * if these plugins fail, a ConnectionDoesntExistException is thrown.
	 * 
	 * @param <T>
	 *            The type of the return object required.
	 * @param <C extends Connection> The type of the connections to use when
	 *        trying to find the objects.
	 * @param type
	 *            the type of the return object required.
	 * @param connectionType
	 *            the type of the connections to use when trying to find the
	 *            objects.
	 * @param role
	 *            the assumed role of the object in the connection. Given a
	 *            connection, the object can be retrieved through the role.
	 * @param input
	 *            the input on which the plugin should work
	 * @return a collection of objects as found or returned by the plugins.
	 */
	public <T, C extends Connection> Collection<T> tryToFindOrConstructAllObjects(Class<T> type,
			Class<C> connectionType, String role, Object... input) throws ConnectionCannotBeObtained;

	/**
	 * Returns the first object of the given type as can be found through the
	 * connections of the other given type. If no objects can be found, it
	 * constructs as an object of the given type using a plugin available to the
	 * framework to do so. This plugins should be able to execute in a child of
	 * the given context and accept, in any order, exactly the input provided.
	 * Any other objects returned by the plugin, not being the requested type
	 * are added to the provided objects of the framework. Also, listeners are
	 * notified where applicable. If no plugins exist, or if these plugins fail,
	 * a ConnectionDoesntExistException is thrown.
	 * 
	 * @param <T>
	 *            The type of the return object required.
	 * @param <C extends Connection> The type of the connections to use when
	 *        trying to find the objects.
	 * @param type
	 *            the type of the return object required.
	 * @param connectionType
	 *            the type of the connections to use when trying to find the
	 *            objects.
	 * @param role
	 *            the assumed role of the object in the connection. Given a
	 *            connection, the object can be retrieved through the role.
	 * @param input
	 *            the input on which the plugin should work
	 * @return a collection of objects as returned by the plugins.
	 */
	public <T, C extends Connection> T tryToFindOrConstructFirstObject(Class<T> type, Class<C> connectionType,
			String role, Object... input) throws ConnectionCannotBeObtained;

	/**
	 * Returns the first object of the given type as can be found through the
	 * connections of the other given type. If no objects can be found, it
	 * constructs as an object of the given type using a plugin available to the
	 * framework to do so. This plugins should be able to execute in a child of
	 * the given context and accept, in any order, exactly the input provided.
	 * Furthermore, the returned object should have the right label assigned to
	 * it in the plugin definition. Any other objects returned by the plugin,
	 * not being the requested type are added to the provided objects of the
	 * framework. Also, listeners are notified where applicable. If no plugins
	 * exist, or if these plugins fail, a ConnectionDoesntExistException is
	 * thrown.
	 * 
	 * @param <T>
	 *            The type of the return object required.
	 * @param <C extends Connection> The type of the connections to use when
	 *        trying to find the objects.
	 * @param type
	 *            the type of the return object required.
	 * @param name
	 *            the name of the plugin to use.
	 * @param connectionType
	 *            the type of the connections to use when trying to find the
	 *            objects.
	 * @param role
	 *            the assumed role of the object in the connection. Given a
	 *            connection, the object can be retrieved through the role.
	 * @param input
	 *            the input on which the plugin should work
	 * @return a collection of objects as returned by the plugins.
	 */
	public <T, C extends Connection> T tryToFindOrConstructFirstNamedObject(Class<T> type, String name,
			Class<C> connectionType, String role, Object... input) throws ConnectionCannotBeObtained;

}"
PluginContext.java,framework,"package org.processmining.framework.plugin;

import java.util.List;
import java.util.concurrent.Executor;

import org.processmining.framework.connections.Connection;
import org.processmining.framework.plugin.events.Logger;
import org.processmining.framework.plugin.events.Logger.MessageLevel;
import org.processmining.framework.plugin.events.PluginLifeCycleEventListener;
import org.processmining.framework.plugin.events.ProgressEventListener;
import org.processmining.framework.plugin.impl.FieldNotSetException;
import org.processmining.framework.plugin.impl.FieldSetException;
import org.processmining.framework.util.Pair;

public interface PluginContext extends GlobalContext, ObjectConstructor {

	/**
	 * Returns a new plugin context instance, which can be used to invoke other
	 * plugins.
	 * 
	 * @return the new plugin context instance
	 */
	PluginContext createChildContext(String label);

	/* === Getters ==================================================== */

	/**
	 * Returns the progress object corresponding to this context
	 * 
	 * @return the progress object corresponding to this context
	 */
	Progress getProgress();

	/**
	 * Returns the list of registered progress listeners
	 * 
	 * @return the list of registered progress listeners
	 */
	ProgressEventListener.ListenerList getProgressEventListeners();

	/**
	 * Returns the list of registered plugin life cycle listeners.
	 * 
	 * @return the list of registered plugin life cycle listeners.
	 */
	PluginLifeCycleEventListener.List getPluginLifeCycleEventListeners();

	/**
	 * Each PluginContext should carry an ID. This ID is unique within this
	 * plugin context's global context.
	 * 
	 * @return the ID of this context
	 */
	PluginContextID getID();

	/**
	 * Returns the label of this context.
	 * 
	 * @return
	 */
	String getLabel();

	/**
	 * Return the plugin descriptor and method index of the plugin which is
	 * invoked in this context. This descriptor is set by the
	 * PluginDescriptor.invoke() method and will not be set yet before
	 * PluginManager.invoke() is called.
	 * 
	 * @return the descriptor of the plugin which is invoked in this context If
	 *         the plugin is not set yet, a pair of (null,-1) is returned
	 */
	Pair<PluginDescriptor, Integer> getPluginDescriptor();

	/**
	 * Returns the context which created this context or null if it has no
	 * parent.
	 * 
	 * @return
	 */
	PluginContext getParentContext();

	/**
	 * Returns a list of all child contexts which have been created with
	 * createChildContext().
	 * 
	 * @return
	 */
	List<PluginContext> getChildContexts();

	/**
	 * This method returns the PluginExecutionResult of the plugin which is
	 * invoked in this context. This future result is set by
	 * PluginManager.invoke() and will not be available (will be null) until the
	 * invoke() method is called.
	 * 
	 * @return The PluginExecutionResult that represents the result of this
	 *         plugin invocation
	 * @throws FieldNotSetException
	 *             If the future is not know to this context
	 */
	PluginExecutionResult getResult();

	/**
	 * This method should only be used by a plugin, in the body of that plugin.
	 * That is the only location, where it is guaranteed that each result object
	 * in getResults() can safely be cast to a ProMFuture.
	 * 
	 * @param i
	 * @return
	 */
	ProMFuture<?> getFutureResult(int i);

	/**
	 * Returns an executor which can be used to execute plugins in child
	 * contexts.
	 * 
	 * @return
	 */
	Executor getExecutor();

	/**
	 * Returns true if this is a distant child of context, i.e. true if
	 * getParent.getID().equals(context.getID()) ||
	 * getParent().isDistantChildOf(context);
	 * 
	 * @param context
	 * @return
	 */
	boolean isDistantChildOf(PluginContext context);

	/*
	 * === Setters: should only be called by the framework!
	 * ===============================
	 */

	void setFuture(PluginExecutionResult resultToBe);

	void setPluginDescriptor(PluginDescriptor descriptor, int methodIndex) throws FieldSetException,
			RecursiveCallException;

	boolean hasPluginDescriptorInPath(PluginDescriptor descriptor, int methodIndex);

	/**
	 * The provided String is provided to the context for information. It can
	 * for example signal a state change of a plugin. Note that some contexts
	 * can completely ignore this message.
	 * 
	 * @param message
	 *            the message to log
	 * @param level
	 *            the message level
	 */
	void log(String message, MessageLevel level);

	/**
	 * Same as calling log(message, MessageLevel.NORMAL);
	 * 
	 * @param message
	 *            The message
	 */
	void log(String message);

	/**
	 * The provided Exception is provided to the context. It signals the context
	 * about an error in the plugin, that specifically lead to abnormal
	 * termination. The plugin signaling the exception is no longer executing!
	 * 
	 * @param exception
	 *            the exception thrown
	 */
	void log(Throwable exception);

	/**
	 * Returns the list of logging listeners registered to this context.
	 * 
	 * @return
	 */
	Logger.ListenerList getLoggingListeners();

	/**
	 * Returns the root plugin context. This is an instance of PluginContext of
	 * which all other contexts are distant childs.
	 * 
	 * @return
	 */
	PluginContext getRootContext();

	/**
	 * Delete this child from this context.
	 * 
	 * @param child
	 * @returns true if this child was a child of the context and has now been
	 *          deleted. false otherwise
	 */
	boolean deleteChild(PluginContext child);

	/**
	 * Registers the given connection in the global context. The implementation
	 * is
	 * 
	 * addConnection(this,c);
	 * 
	 * @param c
	 */
	<T extends Connection> T addConnection(T c);

	void clear();
}
"
PluginContextID.java,framework,"package org.processmining.framework.plugin;

/**
 * Represents an ID of a plugin context.
 * 
 * @author bfvdonge
 * 
 */
public interface PluginContextID extends Comparable<PluginContextID> {

	/**
	 * PluginContextID are used in Collections, so this method has to be
	 * implemented in all its subclasses.
	 * 
	 * @return
	 */
	public boolean equals(Object o);

	/**
	 * PluginContextID are used in HashMaps, so this method has to be
	 * implemented in all its subclasses.
	 * 
	 * @return
	 */
	public int hashCode();

}
"
PluginDescriptor.java,framework,"package org.processmining.framework.plugin;

import java.lang.annotation.Annotation;
import java.net.URL;
import java.util.List;
import java.util.Set;

import javax.swing.ImageIcon;

import org.processmining.framework.packages.PackageDescriptor;

public interface PluginDescriptor extends Comparable<PluginDescriptor> {

	/**
	 * Check if this plugin carries the given annotation. Implementing classes
	 * can return false at their discretion, i.e. they are not required to
	 * return true for all annotations carried by the plugin.
	 * 
	 * @param annotationClass
	 * @return
	 */
	boolean hasAnnotation(Class<? extends Annotation> annotationClass);

	/**
	 * Check if the method at the given index carries the given annotation.
	 * Implementing classes can return false at their discretion, i.e. they are
	 * not required to return true for all annotations carried by the plugin.
	 * 
	 * @param annotationClass
	 * @return
	 */
	boolean hasAnnotation(Class<? extends Annotation> annotationClass, int methodIndex);

	/**
	 * Return the annotation of the given class carried by this plugin. Note
	 * that hasAnnotationClass(annotationClass) is assumed.
	 * 
	 * This method should not be used to access any annotation elements carried
	 * by Plugin.class. Implementing classes are allows to return null when
	 * called with Plugin.class.
	 * 
	 * @param <T>
	 * @param annotationClass
	 * @return
	 */
	<T extends Annotation> T getAnnotation(Class<T> annotationClass);

	/**
	 * Return the annotation of the method at the given index. Note that
	 * hasAnnotationClass(annotationClass, methodIndex) is assumed.
	 * 
	 * This method should not be used to access any annotation elements carried
	 * by Plugin.class. Implementing classes are allows to return null when
	 * called with Plugin.class.
	 * 
	 * @param <T>
	 * @param annotationClass
	 * @param methodIndex
	 * @return
	 */
	<T extends Annotation> T getAnnotation(Class<T> annotationClass, int methodIndex);

	/**
	 * Return the package where the plug-in resides.
	 * 
	 * @return
	 */
	PackageDescriptor getPackage();

	/**
	 * Return the name of the plugin. This name is not unique within ProM.
	 * 
	 * @return
	 */
	String getName();

	/**
	 * return hashcode
	 * 
	 * @return
	 */
	int hashCode();

	/**
	 * return equality of plugins. The ID is used for equality.
	 * 
	 * @param other
	 * @return
	 */
	boolean equals(Object other);

	/**
	 * Returns a String representation of the plugin
	 * 
	 * @return
	 */
	String toString();

	/**
	 * Return the number of methods in this plugin. There's always at least 1.
	 * 
	 * @return
	 */
	int getNumberOfMethods();

	/**
	 * Asynchronously invokes a method of this plugin. The methodIndex should
	 * refer to an existing method, i.e. 0 <= methodindex <
	 * getNumberOfMethods();
	 * 
	 * Note that the callers of this plugin should notify the lifeCycleListners
	 * of the given context of the creation of this plugin, i.e. they should
	 * call:
	 * <code>context.getParentContext().getPluginLifeCycleEventListeners().firePluginCreated(context);</code>
	 * 
	 * @param methodIndex
	 *            The index of the method to be invoked
	 * @param context
	 *            the context in which this plugin should be invoked. The plugin
	 *            may assume that this context is meant only for its execution.
	 * @param args
	 *            the objects to be passed to the plugin. These objects should
	 *            be in the right order. However, if <code>ProMFuture</code>
	 *            objects are provided, the plugin will synchronize on them.
	 *            This syncrhonization is performed in a fast-fail fashion, i.e.
	 *            the first future that results in an exception during execution
	 *            will result in an exception while invoking this plugin. This
	 *            exception is caught and the context is signaled about it.
	 * @return a PluginExecutionResult holding pointers to the future outcome of
	 *         this invokation. If synchrounous execution is required, the
	 *         calling method should synchronize on this result
	 */
	PluginExecutionResult invoke(int methodIndex, PluginContext context, Object... args);

	/**
	 * returns the types of the objects returned if this plugin is invoked, in
	 * the order in which they are returned
	 * 
	 * @return
	 */
	List<Class<?>> getReturnTypes();

	/**
	 * returns the labels of the objects returned if this plugin is invoked, in
	 * the order in which they are returned. These are the labels provided by
	 * the plugin definition, not the labels of the objects resulting from a
	 * specific invokation, as these can be obtained through the
	 * <code>PluginExecutionResult</code> object.
	 * 
	 * @return
	 */
	List<String> getReturnNames();

	/**
	 * returns a list of size <code>getNumberOfMethods()</code>, such that
	 * element at index <code>i</code> of the list equals
	 * <code>getParameterTypes(i)</code>
	 * 
	 * @return
	 */
	List<List<Class<?>>> getParameterTypes();

	/**
	 * Returns a list of types that represent the required parameters of the
	 * method at the given index. In other words, the method at index
	 * <code>methodIndex</code> requires exectly the parameter types as provided
	 * in the returned list, in that order.
	 * 
	 * @param methodIndex
	 * @return
	 */
	List<Class<?>> getParameterTypes(int methodIndex);

	/**
	 * Returns a list of labels that represent the possible parameters of this
	 * plugin. Each method required a subset of these labels, while preserving
	 * their order.
	 * 
	 * @return
	 */
	List<String> getParameterNames();

	/**
	 * Returns a list of labels that represent the required parameters of the
	 * method at the given index. In other words, the method at index
	 * <code>methodIndex</code> requires exactly the parameter labels as
	 * provided in the returned list, in that order.
	 * 
	 * @param methodIndex
	 * @return
	 */
	List<String> getParameterNames(int methodIndex);

	/**
	 * Return the type of the parameter at index <code>parameterIndex</code> of
	 * the method at <code>methodIndex</code>.
	 * 
	 * @param methodIndex
	 *            <code>0 <= methodIndex < getNumberOfMethods()</code>
	 * @param parameterIndex
	 *            <code>0 <= parameterIndex < getParameterTypes().size()</code>
	 * @return may return null if the parameter is not used by the given method
	 */
	Class<?> getPluginParameterType(int methodIndex, int parameterIndex);

	/**
	 * Return the label of the parameter at index <code>parameterIndex</code> of
	 * the method at <code>methodIndex</code>.
	 * 
	 * @param methodIndex
	 *            <code>0 <= methodIndex < getNumberOfMethods()</code>
	 * @param parameterIndex
	 *            <code>0 <= parameterIndex < getParameterTypes(methodIndex).size()</code>
	 * @return may return null if the parameter is not used by the given method
	 */
	String getPluginParameterName(int methodIndex, int parameterIndex);

	/**
	 * returns the ID of this Plugin. Provided that the code of a plugin does
	 * not change, these IDs are persistent between executions of ProM.
	 * 
	 * @return
	 */
	PluginDescriptorID getID();

	/**
	 * Returns the context type required by the method at index methodIndex.
	 * 
	 * @param methodIndex
	 *            <code>0 <= methodIndex < getNumberOfMethods()</code>
	 * @return
	 */
	Class<? extends PluginContext> getContextType(int methodIndex);

	/**
	 * Returns a list of types that can be accepted for the parameter at index
	 * <code>globalParameterIndex</code>. The parameter index is global, i.e.
	 * not method specific. Instead, for each type <code>t</code> in the set
	 * returned by this method it is guaranteed that there is at least one
	 * method (suppose at index <code>i</code>), such that
	 * <code>getParameterType(i, getIndexInMethod(i, globalParameterIndex)) == t</code>
	 * 
	 * @param globalParameterIndex
	 *            <code>0 <= globalParameterIndex < getParameterNames().size()</code>
	 * @return
	 */
	Set<Class<?>> getTypesAtParameterIndex(int globalParameterIndex);

	/**
	 * Returns the index of the method parameter of the given method in the list
	 * of global parameters. Each method of a plugin requires a subset of the
	 * global set of parameters that the plugin defines. This method can be used
	 * to map the index of each method parameter to the index of the global
	 * parameter.
	 * 
	 * @param methodIndex
	 *            <code>0 <= methodIndex < getNumberOfMethods()</code>
	 * @param methodParameterIndex
	 *            <code>0 <= methodParameterIndex < getParameterNames(methodIndex).size()</code>
	 * @return <code>0 <= return < getParameterNames().size()</code>
	 */
	int getIndexInParameterNames(int methodIndex, int methodParameterIndex);

	/**
	 * Returns the index of the global parameter to the index of that parameter
	 * in the given method. Each method of a plugin requires a subset of the
	 * global set of parameters that the plugin defines. This method can be used
	 * to map the index of each global parameter to the index of the method
	 * parameter. Note that if the given method does not require the global
	 * parameter, -1 is returned.
	 * 
	 * @param methodIndex
	 *            <code>0 <= methodIndex < getNumberOfMethods()</code>
	 * @param globalParameterIndex
	 *            <code>0 <= globalParameterIndex < getParameterNames().size()</code>
	 * @return <code>-1 <= return < getParameterNames(methodIndex).size()</code>
	 */
	int getIndexInMethod(int methodIndex, int globalParameterIndex);

	/**
	 * Return the label of the given method, if specified. If no label was
	 * specified, the name of the plugin is returned.
	 * 
	 * @param methodIndex
	 * @return
	 */
	String getMethodLabel(int methodIndex);

	/**
	 * Compares this plugin with another plugins. Uses the
	 * <code>getName().toLowerCase()</code> for comparing. Only if names are
	 * equal, then the IDs are used for comparison. Comparison should be
	 * name-based between different implementing classes.
	 */
	int compareTo(PluginDescriptor plugin);

	/**
	 * Returns true if this plugin can be used by the end-users. If this is set
	 * to false, such a plugin should not be presented to the end user by any
	 * context.
	 * 
	 * @return
	 */
	boolean isUserAccessible();

	/**
	 * Returns whether the plugin handles termination itself.
	 * 
	 * @return
	 */
	boolean handlesCancel();

	/**
	 * Returns the index in the result array of the most significant result for
	 * this plugin
	 * 
	 * @return the index in the result array of the most significant result. If
	 *         no results are returned by this plugin, anything can be returned.
	 */
	int getMostSignificantResult();

	/**
	 * Return the help / description of the plugin.
	 * 
	 * @return
	 */
	String getHelp();

	/**
	 * Return the help / description of the given method, if specified.
	 * 
	 * @param methodIndex
	 * @return
	 */
	String getMethodHelp(int methodIndex);
	
	
	/**
	 * Return the set of keywords.
	 * 
	 * @return a set of keywords
	 */
	String[] getKeywords();
	
	/**
	 * Return the set of categories.
	 * 
	 * @return a set of categories
	 */
	String[] getCategories();

	/**
	 * Return whether this plug-in meets the quality threshold.
	 * 
	 * @return whether this plug-in meets the quality threshold
	 */
	boolean meetsQualityThreshold();
	/**
	 * Return whether this plug-in meets the level threshold.
	 * 
	 * @return whether this plug-in meets the level threshold
	 */
	boolean meetsLevelThreshold();
	
	public ImageIcon getIcon();
	
	public URL getURL();

}
"
PluginDescriptorID.java,framework,"package org.processmining.framework.plugin;

/**
 * This interface provides an ID for each plugin. These IDs are persistent
 * between executions of ProM, provided that no code changes are made to the
 * plugin in question.
 * 
 * @author bfvdonge
 * 
 */
public interface PluginDescriptorID extends Comparable<PluginDescriptorID> {

	/**
	 * ProvidedObjectIDs are used in Collections, so this method has to be
	 * implemented in all its subclasses.
	 * 
	 * @return
	 */
	public boolean equals(Object o);

	/**
	 * ProvidedObjectIDs are used in HashMaps, so this method has to be
	 * implemented in all its subclasses.
	 * 
	 * @return
	 */
	public int hashCode();

}
"
PluginExecutionResult.java,framework,"package org.processmining.framework.plugin;

import java.util.concurrent.CancellationException;
import java.util.concurrent.ExecutionException;

import org.processmining.framework.providedobjects.ProvidedObjectID;

/**
 * This class represents the result of a plugin execution. It can be used to
 * obtain all details after executing a plugin.
 * 
 * Typically, plugins are executed a-synchronously, but by calling synchronize()
 * on this object, the current thread is suspended untill all results are in (or
 * exceptions are thrown)
 * 
 * @author bfvdonge
 * 
 */
public interface PluginExecutionResult {

	/**
	 * Returns the size of this result, i.e. how many objects were returned by
	 * the plugin
	 * 
	 * @return
	 */
	public int getSize();

	/**
	 * Synchronizes on any futures that might still exist in the result. If no
	 * futures exist, this method does terminate normally
	 * 
	 * @throws CancellationException
	 * @throws ExecutionException
	 * @throws InterruptedException
	 */
	public void synchronize() throws CancellationException, ExecutionException, InterruptedException;

	/**
	 * returns the results of this plugin in an array. If synchronize() was
	 * called, this method returns the actual objects. Otherwise, it might
	 * return ProMFutures on the actual objects (or any combination thereof).
	 * 
	 * @return
	 */
	public Object[] getResults();

	/**
	 * returns the result at the given index, casted to the given returntype. If
	 * synchronize() was called, this method returns the actual object.
	 * Otherwise, it might return a ProMFuture<T> on the actual object.
	 * 
	 * Note that 0<= resultIndex < getSize()
	 * 
	 * @param <T>
	 * @param resultIndex
	 * @return
	 */
	public <T> T getResult(int resultIndex) throws ClassCastException;

	/**
	 * This method returns the names of the results
	 * 
	 * @return
	 */
	public String[] getResultNames();

	/**
	 * this method returns the name of the result at the given index.
	 * 
	 * Note that 0<= resultIndex < getSize()
	 * 
	 * @param resultIndex
	 * @return
	 */
	public String getResultName(int resultIndex);

	/**
	 * Tells this result under which provided object ID the object at index i is
	 * known to the framework
	 * 
	 * @param i
	 *            index of the object
	 * @param id
	 *            the id of the provided object refering to the objet at index i
	 */
	void setProvidedObjectID(int i, ProvidedObjectID id);

	/**
	 * Returns the ProvidedObjectID under which the object at index i is known
	 * to the framework's ProvidedObject manager
	 * 
	 * @param i
	 *            index of the object
	 */
	ProvidedObjectID getProvidedObjectID(int i);

	/**
	 * Returns the type of the object at index i, as declared by the plugin
	 * 
	 * @param i
	 * @return
	 */
	public <T> Class<? super T> getType(int i);

	/**
	 * Returns the plugin used to generate this result
	 * 
	 * @return
	 */
	public PluginDescriptor getPlugin();

}
"
PluginManager.java,framework,"package org.processmining.framework.plugin;

import java.lang.annotation.Annotation;
import java.net.URL;
import java.util.Collection;
import java.util.EventListener;
import java.util.Set;
import java.util.SortedSet;

import org.processmining.framework.packages.PackageDescriptor;
import org.processmining.framework.util.Pair;

/**
 * The plugin manager manages plugins. It loads plugins from URLs and provides
 * access to them through search methods.
 * 
 * @author bfvdonge
 * 
 */
public interface PluginManager {

	/**
	 * Constant to denote the file extension for class files.
	 */
	static final String CLASS_EXTENSION = "".class"";

	/**
	 * Constant to denote the file extension for macro files.
	 */
	static final String MCR_EXTENSION = "".mcr"";

	/**
	 * Constant to denote the file extension for jar files.
	 */
	static final String JAR_EXTENSION = "".jar"";

	/**
	 * Constant to denote the file protocol to be used in URLs provided to this
	 * plugin manager.
	 */
	static final String FILE_PROTOCOL = ""file"";

	/**
	 * This interface describes an error listener for the plugin manager. The method
	 * error should be called by a plugin manager while registering packages and
	 * scanning for plugins.
	 * 
	 * @author bfvdonge
	 * 
	 */
	interface PluginManagerListener extends EventListener {
		/**
		 * Listen for errors which occur while registering packages and scanning for
		 * plugins.
		 * 
		 * @param source
		 *            The URL which was being registered while this error occurred
		 * @param t
		 *            The error which occurred
		 * @param className
		 *            The class name of the class which was being registered, may be
		 *            null
		 */
		void error(URL source, Throwable t, String className);

		/**
		 * Listen for plugins that are registered to the manager. Every time a
		 * PluginDescriptor is added to the manager, an event is generated.
		 * 
		 * @param plugin
		 */
		void newPlugin(PluginDescriptor plugin, Collection<Class<?>> newTypes);
	}

	/**
	 * Adds a listener to the plugin manager.
	 * 
	 * @param listener
	 *            the listener to add.
	 */
	void addListener(PluginManagerListener listener);

	/**
	 * Removes the listener from the plugin manager.
	 * 
	 * @param listener
	 *            the listener to remove.
	 */
	void removeListener(PluginManagerListener listener);

	/**
	 * registers a URL to this plugin manager. If the URL uses the
	 * <code>FILE_PROTOCOl</code> protocol and denotes a directory, then this folder
	 * is recursively scanned for files with the <code>CLASS_EXTENSION</code>
	 * extension.
	 * 
	 * Otherwise, the URL is assumed to point to a jar file, of which the classes
	 * are scanned.
	 * 
	 * Each class file is scanned for classes and/or methods annotated with the
	 * <code>Plugin</code> annotation. If a class is annotated with this annotation,
	 * then its methods are scanned for the <code>PluginVariant</code> annotation.
	 * 
	 * For each plugin found, a <code>PluginDescriptor</code> object is
	 * instantiated. These plugin descriptors can later be used to invoke plugins.
	 * 
	 * @param url
	 *            The URL to register
	 * @param pack
	 *            The package that corresponds to the URL
	 */
	void register(URL url, PackageDescriptor pack);

	/**
	 * registers a URL to this plugin manager. If the URL uses the
	 * <code>FILE_PROTOCOl</code> protocol and denotes a directory, then this folder
	 * is recursively scanned for files with the <code>CLASS_EXTENSION</code>
	 * extension.
	 * 
	 * Otherwise, the URL is assumed to point to a jar file, of which the classes
	 * are scanned.
	 * 
	 * Each class file is scanned for classes and/or methods annotated with the
	 * <code>Plugin</code> annotation. If a class is annotated with this annotation,
	 * then its methods are scanned for the <code>PluginVariant</code> annotation.
	 * 
	 * For each plugin found, a <code>PluginDescriptor</code> object is
	 * instantiated. These plugin descriptors can later be used to invoke plugins.
	 * 
	 * @param url
	 *            The URL to register
	 * @param pack
	 *            The package that corresponds to the URL
	 * @param loader
	 *            The class loader used to load the jar files.
	 */
	void register(URL url, PackageDescriptor pack, ClassLoader loader);

	/**
	 * This method retuns a collection of <code>Pair</code>s of <code>Integer</code>
	 * and <code>PluginParameterBinding</code> objects, such that:
	 * <p>
	 * The method belonging to the plugin in the pluginParameterBinding carries the
	 * given annotation. If no specific annotation is required, the method should be
	 * called with <code>Plugin.class</code>. Note that the annotation required has
	 * to be on the same level as the <code>Plugin</code> annotation, i.e. either on
	 * a method or a class
	 * <p>
	 * When invoked, the PluginParameterBinding returns an array of objects, of
	 * which the object at the index given by the integer in the pair is of the
	 * required result type, i.e.
	 * <code>resultType.isAssignableFrom(p.getPlugin().getReturnTypes()[i])</code>
	 * If no specific return type is required, use <code>Object.class</code> for
	 * this parameter.
	 * <p>
	 * The PluginParameterBinding can be executed in a <code>PluginContext</code> of
	 * the given type.
	 * <p>
	 * If <code>totalMatch</code> is true, then the PluginParameterBinding binds all
	 * parameters of the plugin with all arguments. Otherwise, the
	 * PluginParameterBinding only requires a subset of the given arguments and is
	 * therefore not directly executable on the given set of arguments.
	 * <p>
	 * If <code>orderedParameters</code> is true, then the PluginParameterBinding
	 * binds the given arguments in the given order, i.e. no arguments are
	 * reordered.
	 * <p>
	 * If <code>mustBeUserVisible</code> is true, then the plugin must have the
	 * <code>isUserVisible</code> flag set to true.
	 * <p>
	 * The PluginParameterBinding can be executed on arguments of the given types.
	 * The list of arguments can be empty, in which case no arguments are required
	 * to invoke the PluginParameterBinding. Note that only types of arguments are
	 * required, not the values. For checking whether arguments can be assigned to
	 * parameters of the Plugin, the <code>isParameterAssignable</code> method is
	 * used. Any <code>ProMFuture</code>s should be unwrapped.
	 * 
	 * @param annotation
	 *            The annotation that should be present on the plugin (use
	 *            <code>Plugin.class</code> if none is required).
	 * @param resultType
	 *            The required result type (use <code>Object.class</code> if no
	 *            specific type is required).
	 * @param contextType
	 *            The context type in which this plugin should be executable. Note
	 *            that this type should be the contextType of the context from which
	 *            the find is called, or a supertype thereof.
	 * @param totalMatch
	 *            Whether or not all arguments should be used to execute this
	 *            plugin.
	 * @param orderedParameters
	 *            Whether or not the arguments are given in the right order.
	 * @param mustBeUserVisible
	 *            Whether or not all returned plugins should be user visible.
	 * @param args
	 *            The types of the arguments provided to the plugin. Can be empty.
	 * @return A collection of pluginparameterbindings. They are executable if
	 *         totalMatch is true.
	 */
	Set<Pair<Integer, PluginParameterBinding>> find(Class<? extends Annotation> annotation, Class<?> resultType,
			Class<? extends PluginContext> contextType, boolean totalMatch, boolean orderedParameters,
			boolean mustBeUserVisible, Class<?>... args);

	/**
	 * This method retuns a collection of <code>Pair</code>s of <code>Integer</code>
	 * and <code>PluginParameterBinding</code> objects, such that:
	 * <p>
	 * The method belonging to the plugin in the pluginParameterBinding carries the
	 * given annotation. If no specific annotation is required, the method should be
	 * called with <code>Plugin.class</code>. Note that the annotation required has
	 * to be on the same level as the <code>Plugin</code> annotation, i.e. either on
	 * a method or a class
	 * <p>
	 * When invoked, the PluginParameterBinding returns an array of objects, of
	 * which the object at the index given by the integer in the pair is of the
	 * required result type as specified in the input list, i.e. for all
	 * <code>i</code>
	 * <code>resultTypes[i].isAssignableFrom(p.getPlugin().getReturnTypes()[i])</code>
	 * If no specific return type is required, use the other <code>find</code>
	 * method.
	 * <p>
	 * The PluginParameterBinding can be executed in a <code>PluginContext</code> of
	 * the given type.
	 * <p>
	 * If <code>totalMatch</code> is true, then the PluginParameterBinding binds all
	 * parameters of the plugin with all arguments. Otherwise, the
	 * PluginParameterBinding only requires a subset of the given arguments and is
	 * therefore not directly executable on the given set of arguments.
	 * <p>
	 * If <code>orderedParameters</code> is true, then the PluginParameterBinding
	 * binds the given arguments in the given order, i.e. no arguments are
	 * reordered.
	 * <p>
	 * If <code>mustBeUserVisible</code> is true, then the plugin must have the
	 * <code>isUserVisible</code> flag set to true.
	 * <p>
	 * The PluginParameterBinding can be executed on arguments of the given types.
	 * The list of arguments can be empty, in which case no arguments are required
	 * to invoke the PluginParameterBinding. Note that only types of arguments are
	 * required, not the values. For checking whether arguments can be assigned to
	 * parameters of the Plugin, the <code>isParameterAssignable</code> method is
	 * used. Any <code>ProMFuture</code>s should be unwrapped.
	 * 
	 * @param annotation
	 *            The annotation that should be present on the plugin (use
	 *            <code>Plugin.class</code> if none is required).
	 * @param resultTypes
	 *            The exact, sorted list of required result types. If not specific
	 *            type is requested, this find method should not be used.
	 * @param contextType
	 *            The context type in which this plugin should be executable. Note
	 *            that this type should be the contextType of the context from which
	 *            the find is called, or a supertype thereof.
	 * @param totalMatch
	 *            Whether or not all arguments should be used to execute this
	 *            plugin.
	 * @param orderedParameters
	 *            Whether or not the arguments are given in the right order.
	 * @param mustBeUserVisible
	 *            Whether or not all returned plugins should be user visible.
	 * @param args
	 *            The types of the arguments provided to the plugin. Can be empty.
	 * @return A collection of pluginparameterbindings. They are executable if
	 *         totalMatch is true.
	 */
	public Set<Pair<Integer, PluginParameterBinding>> find(Class<? extends Annotation> annotation,
			Class<?>[] resultTypes, Class<? extends PluginContext> contextType, boolean totalMatch,
			boolean orderedParameters, boolean mustBeUserVisible, Class<?>... parameters);

	/**
	 * Find the plugins resulting in the given type. The result are pairs of
	 * integers and plugins, such that for each pair (i,p) holds that
	 * resultType.isAssignableFrom(p.getReturnTypes()[i])
	 * 
	 * @param resultType
	 *            Can be null. if null, then any type is considered.
	 * @param mustBeUserVisible
	 *            Whether or not all returned plugins should be user visible.
	 * @return A collection of pairs of integers and plugins, such that for each
	 *         pair (i,p) holds that
	 *         resultType.isAssignableFrom(p.getReturnTypes()[i])
	 */
	Set<Pair<Integer, PluginDescriptor>> getPluginsResultingIn(Class<? extends Object> resultType,
			Class<? extends PluginContext> contextType, boolean mustBeUserVisible);

	/**
	 * Returns executable PluginParameterBindings, which can be invoked in the given
	 * context on the given parameter types. Note that the PluginParameterBindings
	 * are executable.
	 * 
	 * @param contextType
	 *            The type of the context in which the binding is to be invoked.
	 * @param mustBeUserVisible
	 *            Whether or not the plugin should be user visible.
	 * @param parameters
	 *            The types of the arguments passed to the plugins. They are
	 *            accepted by the plugin in the order in which they are provided.
	 * 
	 * @return a list of executable bindings
	 */
	Set<PluginParameterBinding> getPluginsAcceptingOrdered(Class<? extends PluginContext> contextType,
			boolean mustBeUserVisible, Class<?>... parameters);

	/**
	 * Returns PluginParameterBindings, which can be invoked in the given context on
	 * the given parameter types. Note that the PluginParameterBindings are not
	 * necessarily executable. However, they accept all given arguments as
	 * parameters.
	 * 
	 * @param contextType
	 *            The type of the context in which the binding is to be invoked.
	 * @param mustBeUserVisible
	 *            Whether or not the plugin should be user visible.
	 * @param parameters
	 *            The types of the arguments passed to the plugins. They are
	 *            accepted by the returned plugins, but not necessarily in this
	 *            order.
	 * @return a list of bindings
	 */
	Set<PluginParameterBinding> getPluginsAcceptingAtLeast(Class<? extends PluginContext> contextType,
			boolean mustBeUserVisible, Class<?>... parameters);

	/**
	 * Returns executable PluginParameterBindings, which can be invoked in the given
	 * context on the given parameter types. Note that the PluginParameterBindings
	 * are executable.
	 * 
	 * @param contextType
	 *            The type of the context in which the binding is to be invoked.
	 * @param mustBeUserVisible
	 *            Whether or not the plugin should be user visible.
	 * @param parameters
	 *            The types of the arguments passed to the plugins. They are
	 *            accepted by the returned plugins, but not necessarily in this
	 *            order.
	 * @return a list of executable bindings
	 */
	Set<PluginParameterBinding> getPluginsAcceptingInAnyOrder(Class<? extends PluginContext> contextType,
			boolean mustBeUserVisible, Class<?>... parameters);

	/**
	 * Returns a PluginDescriptor with the given id. Note that plugin IDs are
	 * persistent between runs.
	 * 
	 * @param id
	 *            the id of the plugin to get
	 * @return the plugin with the given id.
	 */
	PluginDescriptor getPlugin(PluginDescriptorID id);

	/**
	 * Returns a PluginDescriptor of which the toString() of its id equals the given
	 * id. Note that plugin IDs are persistent between runs.
	 * 
	 * @param id
	 *            the String representation of the id of the plugin to get
	 * @return the plugin with an id of which the String representation equals the
	 *         given id.
	 */
	PluginDescriptor getPlugin(String id);

	/**
	 * Returns all plugin descriptors
	 * 
	 * @return all plugin descriptors known to the plugin manager.
	 */
	SortedSet<PluginDescriptor> getAllPlugins();

	/**
	 * Returns all plugin descriptors known to the plugin manager. If set, only
	 * those plugins which are user visible are returned.
	 * 
	 * @param mustBeVisible
	 *            wether or not the returned plugins should be user visible.
	 * @return the plugin descriptors.
	 */
	SortedSet<PluginDescriptor> getAllPlugins(boolean mustBeVisible);

	/**
	 * Returns true if the instance type can be cast to the requested type, or if
	 * the requested type is an array and the instance type can be cast to the
	 * component type of the requested type.
	 * 
	 * @param instanceType
	 *            the type that has to be cast to the requested type.
	 * @param requestedType
	 *            the requested type
	 * @return true if a cast can be made, i.e. if an object of type instanceType
	 *         can be assigned to a parameter of type requestedType of a plugin.
	 */
	boolean isParameterAssignable(Class<?> instanceType, Class<?> requestedType);

	/**
	 * Returns the set of types that is known to the plugin manager. Basically, this
	 * set contains all types that are ever used as a parameter or a return type of
	 * a plugin.
	 * 
	 * @return a set of types.
	 */
	Set<Class<?>> getKnownObjectTypes();

	/**
	 * Returns all known classes annotated with a certain annotationType. Not all of
	 * these classes are plugins! Note that only classes are available that carry
	 * the @KeepInProMCache annotation
	 * 
	 * @param annotationType
	 *            the type of annotation to be found
	 * @return a (possibly empty) set of classes (not null)
	 */
	Set<Class<?>> getKnownClassesAnnotatedWith(Class<? extends Annotation> annotationType);

}"
PluginParameterBinding.java,framework,"package org.processmining.framework.plugin;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import org.processmining.framework.util.ArrayUtils;

/**
 * This class represents a binding between a method of a plugin and a set of
 * parameters. The semantics of this object are as follows.
 * 
 * First, the {@code PluginParameterBinding.Factory.tryToBind()} should be used
 * to construct a list of PluginParameterBindings. This method is called with a
 * variable array of parameter types, such that for each returned binding, the
 * <code>invoke()</code> method can be called with a variable array of
 * instantiations of these types, in that order.
 * 
 * Any reordering that needs to be done (if <code>tryToBind()</code> was called
 * with <code>orderedParameters == false</code>) is handled by the binding.
 * 
 * A PluginParameterBinding is only guaranteed to be executable, if the factory
 * method was called with <code>mustBeTotal</code> set to true.
 * 
 * @author bfvdonge
 * 
 */
public class PluginParameterBinding implements Comparable<PluginParameterBinding> {

	/**
	 * Factory for instantiating PluginParameterBindings binding plugins with a
	 * given input.
	 * 
	 * @author bfvdonge
	 * 
	 */
	public static class Factory {

		private Factory() {
		}

		/**
		 * This method instantiates binding objects binding the method and index
		 * <code>methodIndex</code> of the given plugin to the given set of
		 * parameter types, if possible. If no binding is possible, an empty
		 * list is returned.
		 * 
		 * If a total binding is requested (indicated by
		 * <code>mustBeTotal == true</code>), then the returned binding assigns
		 * objects from the given parameters to all inputParameters of the
		 * plugin method.
		 * 
		 * If no total binding is required, the resulting bindings is not
		 * necessarily executable, as the method bound might require more input.
		 * However, all provided parameterTypes are bound to a parameter.
		 * 
		 * Using the flag <code>orderedParameters</code> the user can request
		 * bindings that consider the given parameters, in the given order only,
		 * i.e. no reordering is done. Any binding <code>b</code> returned with
		 * <code>orderedParameters == true</code> will satisfy the property that
		 * <code>b.getBinding()[i] == i</code> for all <code>i</code>.
		 * 
		 * @param plugin
		 *            the plugin for which to try to bind the parameters
		 * @param mustBeTotal
		 *            indicating whether the resulting binding should be total
		 * @param orderedParameters
		 *            whether or not the parameters are ordered.
		 * @param parameterTypes
		 *            the available types to be distributed over the parameters.
		 *            Note that if one of the objects is a Object[] then, this
		 *            array will be kept as one. Multiple objects of type T,
		 *            might end up in an array of type S super T, i.e. they can
		 *            be bound into one S[] to be passed to a single element of
		 *            plugin.getTypes()
		 * @return A list of length 0 if no binding exists, or a list of length
		 *         1 if a binding exists. Note that this may change in the
		 *         future to lists of length n.
		 */
		public static List<PluginParameterBinding> tryToBind(PluginManager manager, PluginDescriptor plugin,
				int methodIndex, boolean mustBeTotal, boolean orderedParameters, Class<?>... parameterTypes) {

			List<PluginParameterBinding> result = new ArrayList<PluginParameterBinding>();

			if (mustBeTotal && (parameterTypes.length < plugin.getParameterTypes(methodIndex).size())) {
				// Quick check. the result is empty if it should be total, but their
				// are less provided parameters than required.
				return result;
			}
			if (!mustBeTotal && (parameterTypes.length > 0) && (plugin.getParameterTypes(methodIndex).size() <= 1)) {
				// Quick check. A partial mapping to one type is not possible, when
				// having
				// to assign all parameters
				return result;
			}
			if (orderedParameters && (parameterTypes.length != plugin.getParameterTypes(methodIndex).size())) {
				// can't do this, parameters.size should match required params

				return result;
			}

			// We are dealing with multiple parameters, and we are sure that
			// there are more parameters than types if the mapping needs to be
			// total.
			if ((parameterTypes.length == plugin.getParameterTypes(methodIndex).size())
					&& ((parameterTypes.length == 1) || orderedParameters)) {
				// if ordered, or only 1 to match
				int[] list = new int[parameterTypes.length];
				for (int i = 0; i < parameterTypes.length; i++) {
					// This single parameter matches the required type
					Class<?> parType = plugin.getParameterTypes(methodIndex).get(i);
					//				if (parType.isAssignableFrom(parameters.get(i))
					//						|| (parType.isArray() && parType.getComponentType().isAssignableFrom(parameters.get(i)))) {
					if (manager.isParameterAssignable(parameterTypes[i], parType)) {
						list[i] = i;
					} else {
						return result;
					}

				}
				PluginParameterBinding binding = new PluginParameterBinding(plugin, methodIndex, true, list);
				result.add(binding);

				return result;
			}

			boolean[] fullyUsed = new boolean[plugin.getParameterNames(methodIndex).size()];
			boolean[] used = new boolean[plugin.getParameterNames(methodIndex).size()];
			Arrays.fill(fullyUsed, false);
			Arrays.fill(used, false);

			int[] list = new int[parameterTypes.length];
			for (int i = 0; i < parameterTypes.length; i++) {
				Class<?> par = parameterTypes[i];
				boolean done = false;
				int matchingIndex = -1;
				Class<?> parType = null;
				// First try to match to an unused input parameter
				for (int j = 0; (j < plugin.getParameterNames(methodIndex).size()) && !done; j++) {
					if (used[j]) {
						continue;
					}
					parType = plugin.getParameterTypes(methodIndex).get(j);
					boolean match = manager.isParameterAssignable(par, parType);
					if (match) {
						matchingIndex = j;
						done = true;
					}
				}
				// Then, to a used, but not fully used parameter
				for (int j = 0; (j < plugin.getParameterNames(methodIndex).size()) && !done; j++) {
					if (fullyUsed[j]) {
						continue;
					}
					parType = plugin.getParameterTypes(methodIndex).get(j);
					boolean match = manager.isParameterAssignable(par, parType);
					if (match) {
						matchingIndex = j;
						done = true;
					}
				}

				if (done) {
					assert ((matchingIndex >= 0) && (parType != null));
					list[i] = matchingIndex;
					used[matchingIndex] = true;
					fullyUsed[matchingIndex] = !parType.isArray();
				} else {
					// Could not assign this parameter
					return result;
				}
				// }
			}
			boolean complete = true;
			for (int i = 0; (i < used.length) && complete; i++) {
				complete &= used[i];
			}

			if (mustBeTotal == complete) {
				PluginParameterBinding binding = new PluginParameterBinding(plugin, methodIndex, complete, list);
				result.add(binding);
			}

			return result;
		}

	}

	private final PluginDescriptor plugin;
	private final int methodIndex;
	private final boolean isComplete;

	// Binding represents the index of the parameter to which
	// an object should be bound
	private final int[] binding;

	/**
	 * Constructs a binding on the given plugin, method and binding.
	 * 
	 * @param plugin
	 * @param methodIndex
	 * @param isComplete
	 * @param binding
	 */
	private PluginParameterBinding(PluginDescriptor plugin, int methodIndex, boolean isComplete, int[] binding) {
		this.plugin = plugin;
		this.methodIndex = methodIndex;
		this.isComplete = isComplete;
		this.binding = binding;

	}

	/**
	 * Invokes the method of the plugin referenced by this binding on the given
	 * parameterObjects. It should be noted that the number of given parameter
	 * object should be the same as the number of parameter types provided to
	 * the <code>tryToBind()</code> method of the factory. Furthermore, the
	 * types of these parameters should be right, i.e. each object should be of
	 * the right type, or should be a <code>ProMFuture</code> on that type.
	 * 
	 * In this method, the given parameters are first re-ordered according to
	 * the given binding and then
	 * <code>getPlugin().invoke(getMethodIndex(), context, ...)</code> is
	 * called, on the newly ordered parameters.
	 * 
	 * No checks are done if this plugin is executable or not on the given
	 * input, it's up to the plugin to handle this
	 * 
	 * @param context
	 *            Note that the plugin should be executable in this context.
	 *            However, since PluginContext's should be kept uniformly typed
	 *            within one instance of ProM, no checks are done here.
	 * @param parameterObjects
	 * @return
	 */
	public PluginExecutionResult invoke(PluginContext context, Object... parameterObjects) {
		Object[] args = prepareArguments(parameterObjects);
		return plugin.invoke(methodIndex, context, args);
	}

	/**
	 * Sorts the parameters according the ordering specified in the binding
	 * array. Produces arrays if multiple objects are bound to the same
	 * parameter.
	 * 
	 * @param parameterObjects
	 * @return
	 */
	private Object[] prepareArguments(Object... parameterObjects) {
		Object[] args = new Object[plugin.getParameterNames(methodIndex).size()];
		Arrays.fill(args, null);
		for (int i = 0; i < parameterObjects.length; i++) {
			int index = binding[i];
			if (index < 0) {
				continue;
			}
			if (!plugin.getParameterTypes(methodIndex).get(index).isArray()) {
				// Single parameter
				args[index] = parameterObjects[i];
				continue;
			}
			// Array Parameter (there might be more added to this array).
			Object[] arg;
			if (args[index] == null) {
				arg = new Object[0];
			} else {
				arg = (Object[]) args[index];
			}
			Object[] newArg = ArrayUtils.copyOf(arg, arg.length + 1);
			newArg[arg.length] = parameterObjects[i];
			args[index] = newArg;
		}
		return args;
	}

	/**
	 * Returns the Plugin which is bound by this binding.
	 * 
	 * @return
	 */
	public PluginDescriptor getPlugin() {
		return plugin;
	}

	/**
	 * This method returns an array of integers, of which the length corresponds
	 * to the length of the list of parameters types provided to the
	 * PluginParameterBinding factory. For each parameter type, this array
	 * indicates to which parameter of the plugin it is bound.
	 * 
	 * For each element <code>x</code> of this array is holds that
	 * <code>0 <= x < getPlugin().getParameterNames(getMethodIndex())</code>
	 * 
	 * If the same parameter index is provided for different parameters (i.e.
	 * <code>getBinding()[x] == getBinding()[y]</code> with <code>x != y</code>,
	 * then this impliest that the parameter is an array type, to which multiple
	 * objects can be connected. In other words, this implies that
	 * 
	 * <code>getPlugin().getParameterType(getMethodIndex(),getBinding()[x]).isArray() == true</code>
	 * 
	 * @return
	 */
	public int[] getBinding() {
		return binding;
	}

	/**
	 * Equality of bindings is based on the binding, plugin and complete status.
	 */
	public boolean equals(Object o) {
		if (!(o instanceof PluginParameterBinding)) {
			return false;
		}
		PluginParameterBinding b = (PluginParameterBinding) o;
		return (isComplete == b.isComplete) && plugin.equals(b.plugin) && (methodIndex == b.methodIndex)
				&& Arrays.equals(b.binding, binding);
	}

	/**
	 * Returns a hashcode based on the binding, plugin and complete status
	 */
	public int hashCode() {
		int hash = 7;
		hash = 31 * hash + Arrays.hashCode(binding);
		hash = 31 * hash + plugin.hashCode();
		hash = 31 * hash + methodIndex;
		return 31 * hash + (isComplete ? 13 : 17);

	}

	/**
	 * Returns the method index of the method which is bound by this binding.
	 * 
	 * When this binding is invoked, this method inside the plugin provided by
	 * getPlugin() is invoked.
	 * 
	 * @return
	 */
	public int getMethodIndex() {
		return methodIndex;
	}

	public int compareTo(PluginParameterBinding other) {
		if (other == this) {
			return 0;
		}
		int c = plugin.compareTo(other.plugin);
		if (c == 0) {
			c = methodIndex - other.methodIndex;
		}
		if (c == 0) {
			return Arrays.toString(binding).compareTo(Arrays.toString(other.binding));
		}
		return c;
	}

}"
Progress.java,framework,"package org.processmining.framework.plugin;

/**
 * Interface for progress indicator
 * 
 * @author bfvdonge
 * 
 */
public interface Progress {

	void setMinimum(int value);

	void setMaximum(int value);

	void setValue(int value);

	void setCaption(String message);

	String getCaption();

	int getValue();

	void inc();

	void setIndeterminate(boolean makeIndeterminate);

	boolean isIndeterminate();

	int getMinimum();

	int getMaximum();

	boolean isCancelled();

	void cancel();
}
"
ProMCanceller.java,framework,"package org.processmining.framework.plugin;

/**
 * Interface that can be used by visualizations to receive a notification from
 * the framework when they are removed. {@link #isCancelled()} will return true
 * in this case.
 * 
 * @author F. Mannhardt, S.J.J Leemans
 *
 */
public interface ProMCanceller {

	/**
	 * {@link ProMCanceller} that never returns true for {@link #isCancelled()}
	 */
	public final static ProMCanceller NEVER_CANCEL = new ProMCanceller() {

		public boolean isCancelled() {
			return false;
		}
	};

	boolean isCancelled();

}
"
ProMFuture.java,framework,"package org.processmining.framework.plugin;

import java.util.concurrent.CancellationException;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;

import javax.swing.SwingWorker;

import org.processmining.framework.plugin.events.FutureListener;
import org.processmining.framework.plugin.events.NameChangeListener;

/**
 * Class to represent a future on an object.
 * 
 * @author bfvdonge
 * 
 * @param <T>
 */
public abstract class ProMFuture<T> implements Future<T> {

	private final Class<?> classType;
	private final SwingWorker<T, Void> worker;
	private String label;
	private final NameChangeListener.ListenerList nameChangeListeners = new NameChangeListener.ListenerList();
	private final FutureListener.ListenerList futureListeners = new FutureListener.ListenerList();

	/**
	 * Instantiates a ProMFuture object of the given type and with the given
	 * label.
	 * 
	 * A SwingWorker is instantiated by the constructor. This SwingWorker is
	 * provided through the <code>getRunnable()</code> method and once executed,
	 * it will execute the <code>doInBackground()</code> method of this
	 * ProMFuture.
	 * 
	 * When finished, the <code>done()</code> method is invoked, after which any
	 * Future listeners are notified that this future is ready.
	 * 
	 * @param resultClass
	 *            Any type that extends T. However, no subtype of ProMFuture can
	 *            be provided.
	 * @param label
	 */
	public ProMFuture(Class<? extends T> resultClass, String label) {
		if (ProMFuture.class.isAssignableFrom(resultClass)) {
			// Cannot put a future inside a future.
			throw new RuntimeException(""Cannot put a future in a future"");
		}
		this.classType = resultClass;
		this.label = label;
		this.worker = new SwingWorker<T, Void>() {
			@Override
			protected T doInBackground() throws Exception {
				return ProMFuture.this.doInBackground();
			}

			@Override
			protected void done() {
				// invoke the setLabel() on getLabel() after finishing execution.
				// this is necessary to fire name-changed events to any 
				// listeners registered after the last call to setLabel();
				ProMFuture.this.setLabel(ProMFuture.this.getLabel());

				ProMFuture.this.done();
				ProMFuture.this.getFutureListeners().fireFutureReady(ProMFuture.this);
			}
		};
	}

	/**
	 * This method is called by the runnable of this future as soon as the
	 * computation of the result is ready, but before any listeners are notified
	 * of the completion.
	 * 
	 * Any overriding implementation can use the get() method to return the
	 * object computed, as this method is guaranteed not to throw exceptions
	 * when done() is reached.
	 */
	protected void done() {
		// Default empty implementation
	}

	/**
	 * Returns the Runnable representing the execution that needs to be
	 * performed to produce the result of this future.
	 * 
	 * @return
	 */
	public Runnable getRunnable() {
		return worker;
	}

	/**
	 * The return type of this future.
	 * 
	 * @return
	 */
	public Class<?> getReturnType() {
		return classType;
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see java.util.concurrent.Future#get()
	 */
	public boolean cancel(boolean mayInterruptIfRunning) {
		return worker.cancel(mayInterruptIfRunning);
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see java.util.concurrent.Future#get()
	 */
	public T get() throws InterruptedException, ExecutionException, CancellationException {
		return worker.get();
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see java.util.concurrent.Future#get(long, java.util.concurrent.TimeUnit)
	 */
	public T get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException,
			CancellationException {
		return worker.get(timeout, unit);
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see java.util.concurrent.Future#isCancelled()
	 */
	public boolean isCancelled() {
		return worker.isCancelled();
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see java.util.concurrent.Future#isDone()
	 */
	public boolean isDone() {
		return worker.isDone();
	}

	/**
	 * This method should be implemented by all subclasses of ProMFuture. Here,
	 * the object of type T is computed and returned.
	 * 
	 * @return
	 * @throws Exception
	 *             This exception should be any exception thrown by the logic of
	 *             the underlying method. Note that ""wrapper""-Exceptions such as
	 *             InvocationTargetException and ExecutionException should be
	 *             unwrapped.
	 */
	protected abstract T doInBackground() throws Exception;

	/**
	 * Return a string representation of this future.
	 */
	public String toString() {
		if (isCancelled()) {
			return (""Cancelled calculation of "" + getLabel());
		}
		return (isDone() ? ""Processing: "" : """") + getLabel();
	}

	/**
	 * returns the label of this future
	 * 
	 * @return
	 */
	public String getLabel() {
		return label;
	}

	/**
	 * Sets the label of this future to the given label and fires name change
	 * events in any registered name change listeners.
	 * 
	 * @param label
	 */
	public void setLabel(String label) {
		this.label = label;
		nameChangeListeners.fireNameChanged(label);
	}

	/**
	 * Returns a ListenerList containing the registered name change listeners
	 * 
	 * @return
	 */
	public NameChangeListener.ListenerList getNameChangeListeners() {
		return nameChangeListeners;
	}

	/**
	 * Returns a ListenerList containing the registered future listeners
	 * 
	 * @return
	 */
	public FutureListener.ListenerList getFutureListeners() {
		return futureListeners;
	}

}
"
RecursiveCallException.java,framework,"package org.processmining.framework.plugin;

public class RecursiveCallException extends Exception {

	private static final long serialVersionUID = -1731740485590676086L;

	public RecursiveCallException(PluginContext context, PluginDescriptor plugin, int methodIndex) {
		super(""A recursive call to method "" + methodIndex + "" of plugin "" + plugin.getName()
				+ "" was discrovered when creating context "" + context.getID() + ""."");
	}
}
"
ProMID.java,framework,"package org.processmining.framework;

import java.util.UUID;

public interface ProMID extends Comparable<ProMID> {

	/**
	 * ProMID are used in Collections, so this method has to be implemented in
	 * all its subclasses.
	 * 
	 * @return
	 */
	public boolean equals(Object o);

	/**
	 * ProMID are used in HashMaps, so this method has to be implemented in all
	 * its subclasses.
	 * 
	 * @return
	 */
	public int hashCode();

	/**
	 * Determines equality between this ProMID and any given object. Basically
	 * checks for equality using the toString() methods of both objects.
	 * 
	 * @param o
	 *            the object to compare the string representation with
	 * @return true if the toString() of this provided object ID equals the
	 *         toString() of the given object parameter.
	 */
	public boolean equalsIgnoreType(Object o);

	/**
	 * Returns a UUID that is used for this object.
	 * 
	 * @return
	 */
	public UUID getUUID();

}
"
ContextAwareObject.java,framework,"package org.processmining.framework.providedobjects;

import org.processmining.framework.connections.ConnectionManager;
import org.processmining.framework.plugin.PluginManager;

/**
 * If an object implements this interface, then this object should use transient
 * fields to store pointers to the three managers.
 * 
 * Upon deserialization of the object by the ProM framework, the three methods
 * in this interface are called before the object is used and added to the
 * framework as a provided object.
 * 
 * Using this interface, objects can instantiate themselves as listeners on the
 * relevant parts of the framework that would otherwise only be available upon
 * instantiation from a PluginContext.
 * 
 * @author bfvdonge
 * 
 */
public interface ContextAwareObject {

	public void setManagers(ConnectionManager connectionManager, PluginManager pluginManager,
			ProvidedObjectManager providedObjectManager);
}
"
ProvidedObjectIDImpl.java,framework,"package org.processmining.framework.providedobjects.impl;

import java.util.UUID;

import org.processmining.framework.ProMID;
import org.processmining.framework.providedobjects.ProvidedObjectID;

public class ProvidedObjectIDImpl implements ProvidedObjectID {

	private final UUID id = UUID.randomUUID();

	public String toString() {
		return id.toString();
	}

	public int hashCode() {
		return id.hashCode();
	}

	public boolean equals(Object o) {
		if (!(o instanceof ProvidedObjectIDImpl)) {
			return false;
		} else {
			return ((ProvidedObjectIDImpl) o).id.equals(id);
		}
	}

	public boolean equalsIgnoreType(Object o) {
		return toString().equals(o.toString());
	}

	public int compareTo(ProMID o) {
		return o.getUUID().compareTo(id);
	}

	public UUID getUUID() {
		return id;
	}
}
"
ProvidedObjectImpl.java,framework,"package org.processmining.framework.providedobjects.impl;

import java.util.concurrent.CancellationException;
import java.util.concurrent.ExecutionException;

import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.ProMFuture;
import org.processmining.framework.plugin.events.FutureListener;
import org.processmining.framework.plugin.events.NameChangeListener;
import org.processmining.framework.providedobjects.ProvidedObject;
import org.processmining.framework.providedobjects.ProvidedObjectDeletedException;
import org.processmining.framework.providedobjects.ProvidedObjectID;
import org.processmining.framework.providedobjects.ProvidedObjectManager;

public class ProvidedObjectImpl implements ProvidedObject, NameChangeListener, FutureListener {

	private final ProvidedObjectID id;
	private Object object;
	private boolean deleted = false;
	private final ProvidedObjectManager manager;
	private String label;
	private final Class<?> type;

	public <T> ProvidedObjectImpl(String label, ProvidedObjectID id, T object, Class<? super T> type,
			ProvidedObjectManager manager) throws NullPointerException {
		this.manager = manager;
		this.id = id;
		this.type = type;
		if (object == null) {
			throw new NullPointerException(""Null cannot be provided as an object"");
		}
		try {
			setObject(object, false);
		} catch (ProvidedObjectDeletedException e) {
			assert (false);
		}
		this.label = label;
	}

	public void deleteObject() {
		deleted = true;
		// unregister as a name-change listener on the old object
		unregisterFromFuture();
		object = null;
		// Notify all listeners to the deleted object
		manager.getProvidedObjectLifeCylceListeners().fireProvidedObjectDeleted(getID());
	}

	private void unregisterFromFuture() {
		if (object instanceof ProMFuture<?>) {
			((ProMFuture<?>) object).getNameChangeListeners().remove(this);
			((ProMFuture<?>) object).getFutureListeners().remove(this);
		}
	}

	public ProvidedObjectID getID() {
		return id;
	}

	public Object getObject() throws ProvidedObjectDeletedException {
		return getObject(true);
	}

	public Object getObject(boolean waitIfFuture) throws ProvidedObjectDeletedException {
		if (deleted) {
			throw new ProvidedObjectDeletedException(""Object "" + getLabel() + "" has been deleted."");
		}
		if (waitIfFuture && (object instanceof ProMFuture<?>)) {
			try {
				return ((ProMFuture<?>) object).get();
			} catch (Exception e) {
				// This is a listener on object and will receive a message
				// from ProMFuture resulting in a delete.
				setObject(null);
			}
		}
		return object;
	}

	public void setObject(Object newObject) throws ProvidedObjectDeletedException {
		setObject(newObject, true);
	}

	private void setObject(Object newObject, boolean signalChange) throws ProvidedObjectDeletedException {
		if (deleted) {
			throw new ProvidedObjectDeletedException(""Object "" + getLabel() + "" has been deleted."");
		}
		// unregister as a name-change listener on the old object
		unregisterFromFuture();
		if (newObject == null) {
			deleteObject();
			return;
		}
		object = newObject;
		synchronized (object) {
			if (object instanceof ProMFuture<?>) {
				// register as a name-change listener on the new object
				((ProMFuture<?>) object).getNameChangeListeners().add(this);
				// To make sure that no name changed are missed:
				label = (((ProMFuture<?>) object).getLabel());
				((ProMFuture<?>) object).getFutureListeners().add(this);
			}
		}
		if (signalChange) {
			// Notify the listeners of the manager
			manager.getProvidedObjectLifeCylceListeners().fireProvidedObjectObjectChanged(id);
		}
	}

	public String toString() {

		return getLabel() + "": "" + (deleted ? "" DELETED"" : object.toString());
	}

	public String getLabel() {
		return label;
	}

	public int hashCode() {
		return id.hashCode();
	}

	public boolean equals(Object o) {
		if (o instanceof ProvidedObject) {
			return id.equals(((ProvidedObject) o).getID());
		} else {
			return false;
		}
	}

	public synchronized void nameChanged(String newName) {
		label = newName;
		manager.getProvidedObjectLifeCylceListeners().fireProvidedObjectNameChanged(getID());
	}

	public void setLabel(String label) throws ProvidedObjectDeletedException {
		if (isDeleted()) {
			throw new ProvidedObjectDeletedException(""Provided Object with ID "" + getID() + "" was deleted before."");
		}
		nameChanged(label);
	}

	public synchronized void pluginCancelled(PluginContext context) {
		// if the plugin was cancelled, then delete this
		// providedObject
		try {
			setObject(null);
		} catch (ProvidedObjectDeletedException e) {
			// Don't care
		}
	}

	public boolean isDeleted() {
		return deleted;
	}

	public Class<? extends Object> getType() throws ProvidedObjectDeletedException {
		if (isDeleted()) {
			throw new ProvidedObjectDeletedException(""Provided Object with ID "" + getID() + "" was deleted before."");
		}
		return type;
	}

	public synchronized void futureReady(ProMFuture<? extends Object> future) {
		try {
			try {
				if (!deleted) {
					Object tmpObject = ((ProMFuture<?>) object).get();
					setObject(tmpObject, false);
					if (tmpObject != null) {
						// if tmpObject == null, then this is deleted by
						// the setObject method;
						manager.getProvidedObjectLifeCylceListeners().fireProvidedObjectFutureReady(getID());
					}
				}
			} catch (CancellationException e) {
				setObject(null);
			} catch (InterruptedException e) {
				setObject(null);
			} catch (ExecutionException e) {
				setObject(null);
			}
		} catch (ProvidedObjectDeletedException e) {
			// Ignore;

		}
	}
}
"
ProvidedObjectManagerImpl.java,framework,"package org.processmining.framework.providedobjects.impl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;

import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.PluginExecutionResult;
import org.processmining.framework.plugin.ProMFuture;
import org.processmining.framework.plugin.events.ProvidedObjectLifeCycleListener;
import org.processmining.framework.providedobjects.ProvidedObject;
import org.processmining.framework.providedobjects.ProvidedObjectDeletedException;
import org.processmining.framework.providedobjects.ProvidedObjectID;
import org.processmining.framework.providedobjects.ProvidedObjectManager;
import org.processmining.framework.providedobjects.SubstitutionType;

public class ProvidedObjectManagerImpl implements ProvidedObjectManager {

	private final ProvidedObjectLifeCycleListener.ListenerList providedObjectLifeCycleListeners = new ProvidedObjectLifeCycleListener.ListenerList();
	private final HashMap<ProvidedObjectID, ProvidedObjectImpl> localProvidedObjects;
	private final List<ProvidedObjectID> ids;

	private boolean enabled = true;

	public ProvidedObjectManagerImpl() {
		localProvidedObjects = new HashMap<ProvidedObjectID, ProvidedObjectImpl>();
		ids = new ArrayList<ProvidedObjectID>();
	}

	public ProvidedObjectLifeCycleListener.ListenerList getProvidedObjectLifeCylceListeners() {
		return providedObjectLifeCycleListeners;
	}

	@SuppressWarnings(""unchecked"")
	public <T> ProvidedObjectID createProvidedObject(String label, T object, PluginContext context) {
		Class<?> realType;
		if (object instanceof ProMFuture<?>) {
			realType = ((ProMFuture<?>) object).getReturnType();
		} else {
			realType = object.getClass();
		}
		if (realType.isAnnotationPresent(SubstitutionType.class)) {
			Class<?> declaredType = realType.getAnnotation(SubstitutionType.class).substitutedType();
			if (declaredType.isAssignableFrom(realType)) {
				realType = declaredType;
			}
		}
		return createProvidedObject(label, object, (Class<? super T>) realType, context);
	}

	public <T> ProvidedObjectID createProvidedObject(String label, T object, Class<? super T> type,
			PluginContext context) {

		// construct a new ProvidedObject
		ProvidedObjectImpl po = new ProvidedObjectImpl(label, new ProvidedObjectIDImpl(), object, type, this);

		if (enabled) {
			// add it to the list of maintained PO's
			localProvidedObjects.put(po.getID(), po);
			ids.add(po.getID());
			providedObjectLifeCycleListeners.fireProvidedObjectCreated(po.getID(), context);
			if (!(object instanceof ProMFuture<?>)) {
				providedObjectLifeCycleListeners.fireProvidedObjectFutureReady(po.getID());
			} else {
				try {
					po.setLabel(((ProMFuture<?>) object).toString());
				} catch (ProvidedObjectDeletedException e) {
					assert (false);
				}
			}
		}
		return po.getID();

	}

	public List<ProvidedObjectID> createProvidedObjects(PluginContext context) {
		List<ProvidedObjectID> newIds = new ArrayList<ProvidedObjectID>();
		PluginExecutionResult result = context.getResult();
		for (int i = 0; i < result.getSize(); i++) {
			ProvidedObjectID id = createProvidedObject(result.getResultName(i), result.getResult(i), result.getType(i),
					context);
			newIds.add(id);
			//			ids.add(id);
			result.setProvidedObjectID(i, id);
		}
		return newIds;
	}

	private ProvidedObjectImpl getProvidedObject(ProvidedObjectID id) throws ProvidedObjectDeletedException {
		ProvidedObjectImpl po = localProvidedObjects.get(id);
		if (po == null) {
			throw new ProvidedObjectDeletedException(""ProvidedObject with ID "" + id + "" is not known to the manager."");
		}
		return po;
	}

	public Object getProvidedObjectObject(ProvidedObjectID id, boolean waitIfFuture)
			throws ProvidedObjectDeletedException {
		ProvidedObject po = getProvidedObject(id);
		return po.getObject(waitIfFuture);
	}

	public String getProvidedObjectLabel(ProvidedObjectID id) throws ProvidedObjectDeletedException {
		ProvidedObject po = getProvidedObject(id);
		return po.getLabel();
	}

	public Class<? extends Object> getProvidedObjectType(ProvidedObjectID id) throws ProvidedObjectDeletedException {
		ProvidedObject po = getProvidedObject(id);
		return po.getType();
	}

	public void changeProvidedObjectObject(ProvidedObjectID id, Object newObject) throws ProvidedObjectDeletedException {
		ProvidedObject po = getProvidedObject(id);
		po.setObject(newObject);
	}

	public void deleteProvidedObject(ProvidedObjectID id) throws ProvidedObjectDeletedException {
		ProvidedObjectImpl po = getProvidedObject(id);
		localProvidedObjects.remove(id);
		ids.remove(id);
		po.deleteObject();
	}

	public List<ProvidedObjectID> getProvidedObjects() {
		return Collections.unmodifiableList(ids);
	}

	public void relabelProvidedObject(ProvidedObjectID id, String label) throws ProvidedObjectDeletedException {
		getProvidedObject(id).setLabel(label);
	}

	public void providedObjectNameChanged(ProvidedObjectID objectID) {
		// Ignore
	}

	public void providedObjectObjectChanged(ProvidedObjectID objectID) {
		// Ignore
	}

	public void setEnabled(boolean enabled) {
		this.enabled = enabled;
	}

	public boolean isEnabled() {
		return enabled;
	}
	
	public void clear() {
		localProvidedObjects.clear();
		ids.clear();
		providedObjectLifeCycleListeners.removeAll();
	}
	
	
}
"
ProvidedObject.java,framework,"package org.processmining.framework.providedobjects;

public interface ProvidedObject {

	/**
	 * Returns the ID of this Provided Object
	 * 
	 * @return
	 */
	ProvidedObjectID getID();

	/**
	 * Returns the label of this provided object
	 * 
	 * @return
	 */
	String getLabel();

	/**
	 * Sets the label of this provided object to the new label.
	 * 
	 * @param label
	 *            the new label of the object
	 * @throws ProvidedObjectDeletedException
	 *             If the object was removed from memory because there were no
	 *             useful references to it anymore
	 */
	void setLabel(String label) throws ProvidedObjectDeletedException;

	/**
	 * Returns the object stored in this provided object. If the object is not
	 * an instance of ProMFuture, then the object itself is returned. Otherwise,
	 * it depends on the parameter whether the ProMFuture is returned, or the
	 * calling thread is blocked until the future finished (or is cancelled)
	 * 
	 * @param waitIfFuture
	 *            if set to false, the returned object might be an instance of
	 *            ProMFuture. Otherwise not.
	 * @return
	 * @throws ProvidedObjectDeletedException
	 *             If the object was removed from memory because there were no
	 *             useful references to it anymore
	 */
	Object getObject(boolean waitIfFuture) throws ProvidedObjectDeletedException;

	/**
	 * Same as calling getObject(true);
	 * 
	 * @return
	 * @throws ProvidedObjectDeletedException
	 *             If the object was removed from memory because there were no
	 *             useful references to it anymore
	 */
	Object getObject() throws ProvidedObjectDeletedException;

	/**
	 * Changes the content of this provided object by replacing the original
	 * object with the new object. This can only be done if the current object
	 * has not been deleted yet.
	 * 
	 * @param object
	 * @throws ProvidedObjectDeletedException
	 *             If the object was removed from memory because there were no
	 *             useful references to it anymore
	 */
	void setObject(Object object) throws ProvidedObjectDeletedException;

	/**
	 * Returns whether or not this object has been deleted. Note that if this
	 * method returns false, no ProvidedObjectDeletedExceptions are thrown in
	 * subsequent, synchronized calls to this provided object.
	 * 
	 * @return
	 */
	boolean isDeleted();

	/**
	 * Signals the provided object to delete itself. After calling this method,
	 * isDeleted() will return true and where applicable,
	 * ProvidedObjectDeletedExceptions will be thrown.
	 */
	void deleteObject();

	/**
	 * Returns the type of the object contained in this Provided Object. If the
	 * internal object is a ProMFuture, then the result type of the future is
	 * returned, i.e. ProMFuture.class is never returned by this method.
	 * 
	 * @return
	 * @throws ProvidedObjectDeletedException
	 *             If the object was removed from memory because there were no
	 *             useful references to it anymore
	 */
	Class<?> getType() throws ProvidedObjectDeletedException;

}
"
ProvidedObjectDeletedException.java,framework,"package org.processmining.framework.providedobjects;

public class ProvidedObjectDeletedException extends Exception {

	/**
	 * 
	 */
	private static final long serialVersionUID = -4591364700388792910L;

	public ProvidedObjectDeletedException(String name) {
		super(name);
	}

}
"
ProvidedObjectID.java,framework,"package org.processmining.framework.providedobjects;

import org.processmining.framework.ProMID;

public interface ProvidedObjectID extends ProMID {

}
"
ProvidedObjectManager.java,framework,"package org.processmining.framework.providedobjects;

import java.util.List;

import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.events.ProvidedObjectLifeCycleListener;

public interface ProvidedObjectManager {

	ProvidedObjectLifeCycleListener.ListenerList getProvidedObjectLifeCylceListeners();

	/**
	 * This method creates a new providedObjectID. The context passed to this
	 * method should refer to the PluginContext of which the ProMFuture object
	 * is the result, i.e. this.getProvidedObjectObject(createProvidedObject(
	 * String name, PluginContext context)) = context.getFutureResult(); The
	 * object will be wrapped in a ProMFuture, and a new childContext is created
	 * for this ProMFuture
	 * 
	 * @param name
	 *            The label of the providedObject identified by the returned
	 *            ProvidedObjectID (can be retrieved with
	 *            getProvidedObjectLabel()
	 * @param object
	 *            the object to be wrapped in a new ProMFuture.
	 * @param type
	 *            the type of the object,
	 * @return a globally new id, identifying the providedObject
	 */
	<T> ProvidedObjectID createProvidedObject(String name, T object, Class<? super T> type, PluginContext context);

	/**
	 * This method creates a new providedObjectID. The context passed to this
	 * method should refer to the PluginContext of which the ProMFuture object
	 * is the result, i.e. this.getProvidedObjectObject(createProvidedObject(
	 * String name, PluginContext context)) = context.getFutureResult(); The
	 * object will be wrapped in a ProMFuture, and a new childContext is created
	 * for this ProMFuture
	 * 
	 * Note that no type is provided with this method. Instead, the framework
	 * will use the type of the given object, or if an @SubstitutionType
	 * annotation was used on the object's class definition, the substitution
	 * type is used.
	 * 
	 * @param name
	 *            The label of the providedObject identified by the returned
	 *            ProvidedObjectID (can be retrieved with
	 *            getProvidedObjectLabel()
	 * @param object
	 *            the object to be wrapped in a new ProMFuture.
	 * 
	 * @return a globally new id, identifying the providedObject
	 */
	<T> ProvidedObjectID createProvidedObject(String name, T object, PluginContext context);

	/**
	 * This method creates a list of new providedObjectIDs for each object in
	 * the PluginExecutionResult of the context.
	 * 
	 * @param context
	 *            The context of which this providedObject will be the result
	 * @return a list of globally new ids, identifying the providedObjects
	 */
	List<ProvidedObjectID> createProvidedObjects(PluginContext context);

	/**
	 * returns the provided object identified by this ID. Do not use this method
	 * if not necessary, as the providedObject might not exist in memory
	 * locally.
	 * 
	 * @param id
	 * @param waitIfFuture
	 *            TODO
	 * @return
	 * @throws ProvidedObjectDeletedException
	 */
	Object getProvidedObjectObject(ProvidedObjectID id, boolean waitIfFuture) throws ProvidedObjectDeletedException;

	String getProvidedObjectLabel(ProvidedObjectID id) throws ProvidedObjectDeletedException;

	Class<?> getProvidedObjectType(ProvidedObjectID id) throws ProvidedObjectDeletedException;

	void changeProvidedObjectObject(ProvidedObjectID id, Object newObject) throws ProvidedObjectDeletedException;

	void deleteProvidedObject(ProvidedObjectID id) throws ProvidedObjectDeletedException;

	/**
	 * Returns all provided Object IDs known to the framework. The list is
	 * ordered in order of Arrival, i.e. the first objectID added to the
	 * framework is returned first.
	 * 
	 * @return
	 */
	List<ProvidedObjectID> getProvidedObjects();

	void relabelProvidedObject(ProvidedObjectID id, String label) throws ProvidedObjectDeletedException;

	void setEnabled(boolean enabled);

	boolean isEnabled();

	void clear();
	
}
"
SubstitutionType.java,framework,"package org.processmining.framework.providedobjects;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface SubstitutionType {
	Class<?> substitutedType();
}
"
Service.java,framework,"package org.processmining.framework.util.socket;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.net.ServerSocket;
import java.net.Socket;
import java.net.SocketTimeoutException;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.Executor;

import org.processmining.framework.plugin.events.Logger.MessageLevel;

/**
 * This is a wrapper for a server socket. It has an arbitrary number of
 * registered ServiceHandler-s. Whenever a client connects to the service, all
 * registered handlers are notified. Each handler can further communucate with
 * the client.
 * 
 * @author christian
 * 
 */

public class Service {

	protected ServerSocket serverSocket; // server socket
	private final int port; // port for the server socket
	protected List<ServiceHandler> handlers = new ArrayList<ServiceHandler>(); // registered handlers

	/**
	 * The only constructor, which simply sets a port to be used by the server
	 * socket. Note that the constructor does not open the server socket.
	 * 
	 * @param port
	 *            for the server socket.
	 */
	public Service(int port) {
		super();
		this.port = port;
		serverSocket = null;
	}

	/**
	 * Registers a new handler. From this moment, the handler will be notified
	 * about new client connections.
	 * 
	 * @param handler
	 *            to be registered.
	 */
	public void addServiceHandler(ServiceHandler handler) {
		handlers.add(handler);
	}

	/**
	 * Unregister the handler. From this moment, the handler will not longer be
	 * notified about new client connections.
	 * 
	 * @param handler
	 *            to be unregistered.
	 */
	public void removeServiceHandler(ServiceHandler handler) {
		handlers.remove(handler);
	}

	/**
	 * Opens the server socked on the given port. Periodically notifies the
	 * environment that the service is alive. Notifies all registered handlers
	 * about every new client connection. It keeps on listening on the socket
	 * until the environment is canceled, upon which the socket is closed.
	 * 
	 * @param environment
	 *            is the environment of this service.
	 * @param executor
	 *            enables notification of handlers in a new thread.
	 * @throws IOException
	 */
	public void start(ServiceEnvironment environment, Executor executor) throws IOException {
		serverSocket = new ServerSocket(getPort());

		while (!environment.isCancelled()) {
			try {
				environment.stillAlive();
				// wait for and handle incoming connections
				serverSocket.setSoTimeout(500);
				Socket clientSocket = serverSocket.accept();
				handleConnection(clientSocket, environment, executor);
			} catch (SocketTimeoutException e) {
				// environment.log(""No Connection Accepted"", MessageLevel.DEBUG);
				continue;
			} catch (IOException e) {
				// abort and give up
				environment.log(""Operational Support Server Failed: "" + e.getMessage(), MessageLevel.ERROR);
				serverSocket.close();
				throw e;
			}
		}
		serverSocket.close();

		environment.log(""Operational Support Server Finished"", MessageLevel.DEBUG);
	}

	/**
	 * Notifies all registered handlers about every new client connection.
	 * 
	 * @param socket
	 *            is the client socket.
	 * @param environment
	 *            is the environment of this service.
	 * @param executor
	 *            enables notification of handlers in a new thread.
	 */
	protected void handleConnection(Socket socket, ServiceEnvironment environment, Executor executor) {
		ConnectionHandlerRunnable handler = new ConnectionHandlerRunnable(socket, environment);
		executor.execute(handler);
	}

	/**
	 * Get the server port.
	 * 
	 * @return the port.
	 */
	public int getPort() {
		return port;
	}

	/**
	 * A simple class that enables notification of ServiceHandler-s in a new
	 * thread.
	 * 
	 * @author christian
	 * 
	 */
	protected class ConnectionHandlerRunnable implements Runnable {

		protected Socket clientSocket;
		private final ServiceEnvironment environment;

		public ConnectionHandlerRunnable(Socket aSocket, ServiceEnvironment environment) {
			clientSocket = aSocket;
			this.environment = environment;
		}

		/**
		 * Notifies all registered handlers about a new client connection in a
		 * new thread.
		 */
		public void run() {
			try {
				BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));
				PrintWriter out = new PrintWriter(clientSocket.getOutputStream(), true);
				for (ServiceHandler handler : handlers) {
					handler.handleRequest(environment, in, out);
				}
			} catch (IOException e) {
				// abort and give up

				environment.log(""Fatal error handling connection,"", MessageLevel.ERROR);
				environment.log(""failed with IO Exception:"", MessageLevel.ERROR);
				environment.log(e);
			} finally {
				// clean up connection
				try {
					if (clientSocket != null) {
						clientSocket.close();
					}
				} catch (IOException ie) { /* this one's forsaken.. */
				}
			}
		}
	}

}
"
ServiceEnvironment.java,framework,"package org.processmining.framework.util.socket;

import org.processmining.framework.plugin.events.Logger.MessageLevel;

/**
 * This interface represents a service environment. It allows communication
 * between a service and its environment.
 * 
 * @author Maja Pesic
 */

public interface ServiceEnvironment {

	/**
	 * Provides the information about the state of the environment. A service
	 * uses this method to decide when to close its socket.
	 * 
	 * @return true - if the socket should be closed false - if the service
	 *         should continue listening on the socket.
	 */
	public boolean isCancelled();

	/**
	 * A service uses this method to log messages in the environment.
	 * 
	 * @param message
	 *            is the message that should be logged
	 * @param level
	 *            is the type of message
	 */
	public void log(String message, MessageLevel level);

	/**
	 * A service uses this method to log messages in the environment.
	 * 
	 * @param message
	 *            is the message that should be logged
	 */
	public void log(String message);

	/**
	 * A service uses this method to log occurrence of an exception in the
	 * environment.
	 * 
	 * @param t
	 *            is the exception that occurred and should be logged
	 */
	public void log(Throwable t);

	/**
	 * While listening on its socket, a service will regularly invoke this
	 * method. This method periodically signals to the environment that the
	 * service is still listening to its socket.
	 */
	public void stillAlive();

	/**
	 * A service uses this method to signal that it has been canceled (i.e., the
	 * socket is closed).
	 */
	public void cancel();

}
"
ServiceHandler.java,framework,"package org.processmining.framework.util.socket;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;

/**
 * This interface enables a service to respond to newly connected clients. If a
 * class wants to be informed about and/or respond to new requests of a service,
 * then this class should implement this interface and it should be added as a
 * handler to the service.
 * 
 * @author christian
 */

public interface ServiceHandler {
	/**
	 * Invoked whenever a client connects to the service.
	 * 
	 * @param environment
	 *            is the registered environment of the service. A handler can
	 *            use this parameter to, for example, log messages.
	 * @param in
	 *            is the buffer from which the client's request can be read.
	 * @param out
	 *            is the buffer where a possible response to the client can be
	 *            written.
	 * @throws IOException
	 */
	public void handleRequest(ServiceEnvironment environment, BufferedReader in, PrintWriter out) throws IOException;
}
"
SortedMultiSet.java,framework,"package org.processmining.framework.util.collection;

import java.util.Comparator;
import java.util.SortedSet;

public interface SortedMultiSet<T> extends MultiSet<T> {

	Comparator<? super T> comparator();

	/**
	 * returns an unmodifiable set of unique objects in the multiset.
	 * 
	 * @return an unmodifiable set of unique objects in the multiset.
	 */
	SortedSet<T> baseSet();

}
"
TreeMultiSet.java,framework,"package org.processmining.framework.util.collection;

import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.SortedSet;
import java.util.TreeMap;
import java.util.TreeSet;

public class TreeMultiSet<T> extends AbstractMultiSet<T, TreeMap<T, Integer>> implements SortedMultiSet<T> {

	private Comparator<? super T> comparator;

	/**
	 * Constructs a new multiset, such that all elements of the given collection
	 * are added as many times as they are returned by the iterator of that
	 * collection.
	 * 
	 * All elements inserted into the multiset must implement the Comparable
	 * interface. Furthermore, all such elements must be mutually comparable:
	 * e1.compareTo(e2) must not throw a ClassCastException for any elements e1
	 * and e2 in the set.
	 * 
	 * @param collection
	 *            Representing the objects that should be put in a multiset
	 */
	public TreeMultiSet(Collection<T> collection) {
		this((Comparator<T>) null);
		addAll(collection);
	}

	/**
	 * Constructs a new multiset, such that all elements of the given collection
	 * are added as many times as they are in the given array.
	 * 
	 * All elements inserted into the multiset must implement the Comparable
	 * interface. Furthermore, all such elements must be mutually comparable:
	 * e1.compareTo(e2) must not throw a ClassCastException for any elements e1
	 * and e2 in the set.
	 * 
	 * @param collection
	 *            Representing the objects that should be put in a multiset
	 */
	public TreeMultiSet(T... collection) {
		this((Comparator<T>) null);
		for (T par : collection) {
			add(par);
		}
	}

	/**
	 * Constructs a new, empty multiset, such that all elements of the given
	 * collection are added as many times as they are returned by the iterator
	 * of that collection.
	 * 
	 * All elements inserted into the multiset must implement the Comparable
	 * interface. Furthermore, all such elements must be mutually comparable:
	 * e1.compareTo(e2) must not throw a ClassCastException for any elements e1
	 * and e2 in the set.
	 * 
	 */
	public TreeMultiSet() {
		this((Comparator<T>) null);
	}

	/**
	 * Constructs a new multiset, such that all elements of the given collection
	 * are added as many times as they are returned by the iterator of that
	 * collection.
	 * 
	 * @param comp
	 *            A comparator providing sorting on the elements of the multiset
	 * @param collection
	 *            Representing the objects that should be put in a multiset
	 */
	public TreeMultiSet(Collection<T> collection, Comparator<? super T> comp) {
		this(comp);
		addAll(collection);
	}

	/**
	 * Constructs a new multiset, such that all elements of the given collection
	 * are added as many times as they are in the given array.
	 * 
	 * @param comp
	 *            A comparator providing sorting on the elements of the multiset
	 * @param collection
	 *            Representing the objects that should be put in a multiset
	 */
	public TreeMultiSet(Comparator<? super T> comp, T... collection) {
		this(comp);
		for (T par : collection) {
			add(par);
		}
	}

	/**
	 * Constructs a new, empty multiset, such that all elements of the given
	 * collection are added as many times as they are returned by the iterator
	 * of that collection.
	 * 
	 * @param comp
	 *            A comparator providing sorting on the elements of the multiset
	 */
	public TreeMultiSet(Comparator<? super T> comp) {
		size = 0;
		TreeMap<T, Integer> newMap = new TreeMap<T, Integer>(comp);
		comparator = newMap.comparator();
		map = newMap;
	}

	<S> MultiSet<S> newMultiSet(Collection<S> collection) {
		return new TreeMultiSet<S>(collection);
	}

	MultiSet<T> newMultiSet() {
		return new TreeMultiSet<T>();
	}

	public Comparator<? super T> comparator() {
		return comparator;
	}

	/**
	 * returns an unmodifiable set of unique objects in the multiset.
	 * 
	 * @return an unmodifiable set of unique objects in the multiset.
	 */
	public SortedSet<T> baseSet() {
		// JAVA 5 CODE:
		SortedSet<T> set = new TreeSet<T>(comparator);
		set.addAll(map.keySet());
		// JAVA 6 CODE:
		// SortedSet<T> set = map.navigableKeySet());
		return Collections.unmodifiableSortedSet(set);
	}
}
"
WeakKeyValueMap.java,framework,"package org.processmining.framework.util.collection;

import java.lang.ref.WeakReference;
import java.util.AbstractMap;
import java.util.Collection;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import java.util.WeakHashMap;

public class WeakKeyValueMap<K, V> extends AbstractMap<K, V> {

	private final Map<K, WeakReference<V>> map;

	public WeakKeyValueMap(int initialCapacity, float loadFactor) {
		map = new WeakHashMap<K, WeakReference<V>>(initialCapacity, loadFactor);
	}

	public WeakKeyValueMap(int initialCapacity) {
		map = new WeakHashMap<K, WeakReference<V>>(initialCapacity);
	}

	public WeakKeyValueMap() {
		map = new WeakHashMap<K, WeakReference<V>>();

	}

	public WeakKeyValueMap(Map<? extends K, ? extends V> m) {
		this();
		putAll(m);
	}

	public void clear() {
		map.clear();
	}

	public boolean containsKey(Object key) {
		return map.containsKey(key);
	}

	public boolean containsValue(Object value) {
		for (WeakReference<V> w : map.values()) {
			if (value.equals(w.get())) {
				return true;
			}
		}
		return false;
	}

	public Set<java.util.Map.Entry<K, V>> entrySet() {
		Set<java.util.Map.Entry<K, V>> set = new HashSet<java.util.Map.Entry<K, V>>();
		for (java.util.Map.Entry<K, WeakReference<V>> entry : map.entrySet()) {
			set.add(new SimpleEntry<K, V>(entry.getKey(), entry.getValue().get()));
		}
		return set;
	}

	public V get(Object key) {
		WeakReference<V> val = map.get(key);
		return val == null ? null : val.get();
	}

	public boolean isEmpty() {
		return map.isEmpty();
	}

	public Set<K> keySet() {
		return map.keySet();
	}

	public V put(K key, V value) {
		V val = get(key);
		map.put(key, new WeakReference<V>(value));
		return val;
	}

	public void putAll(Map<? extends K, ? extends V> m) {
		for (Map.Entry<? extends K, ? extends V> entry : m.entrySet()) {
			put(entry.getKey(), entry.getValue());
		}
	}

	public V remove(Object key) {
		return map.remove(key).get();
	}

	public int size() {
		return map.size();
	}

	public Collection<V> values() {
		Set<V> set = new HashSet<V>();
		for (WeakReference<V> val : map.values()) {
			set.add(val.get());
		}
		return set;
	}

}
"
XMonitoredInputStream.java,framework,"/*
 * OpenXES
 * 
 * The reference implementation of the XES meta-model for event 
 * log data management.
 * 
 * Copyright (c) 2008 Christian W. Guenther (christian@deckfour.org)
 * 
 * 
 * LICENSE:
 * 
 * This code is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 3
 * of the License, or (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA
 * 
 * EXEMPTION:
 * 
 * The use of this software can also be conditionally licensed for
 * other programs, which do not satisfy the specified conditions. This
 * requires an exemption from the general license, which may be
 * granted on a per-case basis.
 * 
 * If you want to license the use of this software with a program
 * incompatible with the LGPL, please contact the author for an
 * exemption at the following email address: 
 * christian@deckfour.org
 * 
 */
package org.processmining.framework.util.progress;

import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;

import javax.swing.JProgressBar;

/**
 * This class implements an input stream which can provide
 * a progress listener with feedback about how much of the
 * data in the stream has already been read.
 * 
 * This is a useful utility for reading XML-based data,
 * while still providing feedback about expected progress.
 * 
 * @author Christian W. Guenther (christian@deckfour.org)
 *
 */
public class XMonitoredInputStream extends InputStream {
	
	/**
	 * The number of steps to be used for progress expression.
	 */
	protected int stepNumber = 1000;
	/**
	 * Number of bytes per step.
	 */
	protected long stepSize;
	/**
	 * The last step which has been notified about.
	 */
	protected int lastStep;
	/**
	 * Number of bytes read so far.
	 */
	protected long bytesRead = 0;
	/**
	 * Wrapped, monitored input stream.
	 */
	protected InputStream stream;
	/**
	 * Progress listener which is being notified.
	 */
	protected XProgressListener progressListener;
	
	/**
	 * Creates a new monitored input stream.
	 * 
	 * @param file The file to be read from.
	 * @param progressListener Progress listener to be notified.
	 */
	public XMonitoredInputStream(File file, XProgressListener progressListener) throws FileNotFoundException {
		this(new BufferedInputStream(new FileInputStream(file)), file.length(), progressListener);
	}
	
	/**
	 * Creates a new monitored input stream.
	 * 
	 * @param stream Monitored, wrapped lower-level input stream.
	 * @param size Number of bytes to be read from the stream.
	 * @param progressBar Progress bar to be updated.
	 */
	public XMonitoredInputStream(InputStream stream, long size, JProgressBar progressBar) {
		this(stream, size, new XProgressBarListener(progressBar), 1000);
	}
	
	/**
	 * Creates a new monitored input stream.
	 * 
	 * @param stream Monitored, wrapped lower-level input stream.
	 * @param size Number of bytes to be read from the stream.
	 * @param progressListener Progress listener to be notified.
	 */
	public XMonitoredInputStream(InputStream stream, long size, XProgressListener progressListener) {
		this(stream, size, progressListener, 1000);
	}
	
	/**
	 * Creates a new monitored input stream.
	 * 
	 * @param stream Monitored, wrapped lower-level input stream.
	 * @param size Number of bytes to be read from the stream.
	 * @param progressListener Progress listener to be notified.
	 * @param stepNumber Number of steps used to express progress.
	 */
	public XMonitoredInputStream(InputStream stream, long size, XProgressListener progressListener, int stepNumber) {
		this.progressListener = progressListener;
		this.stream = stream;
		this.stepNumber = stepNumber;
		// avoid potential divide by 0 when stepsize == 0
		this.stepSize = Math.max(size / stepNumber, 1);
		this.lastStep = 0;
		this.bytesRead = 0;
	}
	
	/**
	 * This method is called by the actual input stream method
	 * to provide feedback about the number of read bytes.
	 * 
	 * Notifies the attached progress listener if appropriate.
	 * 
	 * @param readBytes The number of read bytes in this call.
	 */
	protected void update(long readBytes) throws IOException {
		if (progressListener.isAborted()) {
			throw new IOException(""Reading Cancelled by ProgressListener"");
		}
		this.bytesRead += readBytes;
		int step = (int)(bytesRead / stepSize);
		if(step > lastStep) {
			lastStep = step;
			progressListener.updateProgress(step, stepNumber);
		}
	}
	
	/**
	 * Returns the number of steps so far.
	 * 
	 * @return Number of steps.
	 */
	public int getStepNumber() {
		return stepNumber;
	}
	
	/* (non-Javadoc)
	 * @see java.io.InputStream#read()
	 */
	@Override
	public int read() throws IOException {
		int result = stream.read();
		update(1);
		return result;
	}

	/* (non-Javadoc)
	 * @see java.io.InputStream#read(byte[], int, int)
	 */
	@Override
	public int read(byte[] b, int off, int len) throws IOException {
		int result = stream.read(b, off, len);
		update(result);
		return result;
	}

	/* (non-Javadoc)
	 * @see java.io.InputStream#read(byte[])
	 */
	@Override
	public int read(byte[] b) throws IOException {
		int result = stream.read(b);
		update(result);
		return result;
	}

	/* (non-Javadoc)
	 * @see java.io.InputStream#skip(long)
	 */
	@Override
	public long skip(long n) throws IOException {
		long result = stream.skip(n);
		update(result);
		return result;
	}
	
	

}
"
XProgressBarListener.java,framework,"/*
 * OpenXES
 * 
 * The reference implementation of the XES meta-model for event 
 * log data management.
 * 
 * Copyright (c) 2008 Christian W. Guenther (christian@deckfour.org)
 * 
 * 
 * LICENSE:
 * 
 * This code is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 3
 * of the License, or (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA
 * 
 * EXEMPTION:
 * 
 * The use of this software can also be conditionally licensed for
 * other programs, which do not satisfy the specified conditions. This
 * requires an exemption from the general license, which may be
 * granted on a per-case basis.
 * 
 * If you want to license the use of this software with a program
 * incompatible with the LGPL, please contact the author for an
 * exemption at the following email address: 
 * christian@deckfour.org
 * 
 */
package org.processmining.framework.util.progress;

import javax.swing.JProgressBar;

/**
 * This class implements a progress listener for controlling
 * an attached Swing progress bar. The progress bar will then reflect
 * the progress as received by this listener.
 * 
 * @author Christian W. Guenther (christian@deckfour.org)
 *
 */
public class XProgressBarListener implements XProgressListener {

	/**
	 * Controlled progress bar.
	 */
	protected JProgressBar progressBar;
	/**
	 * Start value to use in progress bar.
	 * When the progress listener begins, this will be
	 * the displayed value on the progress bar.
	 */
	protected int startValue;
	/**
	 * Stop value to use in progress bar.
	 * When the progress listener is completed, this will
	 * be the displayed value on the progress bar.
	 */
	protected int stopValue;
	
	/**
	 * Creates a new progress bar listener with the specified progress
	 * bar for display. The progress bar will accurately and completely
	 * reflect the progress, as received by this listener.
	 * 
	 * @param progressBar Progress bar to display progress.
	 */
	public XProgressBarListener(JProgressBar progressBar) {
		this(progressBar, progressBar.getMinimum(), progressBar.getMaximum());
	}
	
	/**
	 * Creates a new progress bar listener with the specified progress
	 * bar for display. Allows the specification of start and stop values
	 * for the progress bar, so that this listener may control only part
	 * of a more higher-level progress (e.g., the loading of one from
	 * a number of files).
	 * 
	 * @param progressBar Progress bar to display progress.
	 * @param startValue When the progress listener begins, this will be
	 * the displayed value on the progress bar.
	 * @param stopValue When the progress listener is completed, this will
	 * be the displayed value on the progress bar.
	 */
	public XProgressBarListener(JProgressBar progressBar, int startValue, int stopValue) {
		this.progressBar = progressBar;
		this.startValue = startValue;
		this.stopValue = stopValue;
	}
	
	/* (non-Javadoc)
	 * @see org.deckfour.xes.util.MonitoredInputStream.ProgressListener#updateProgress(int, int)
	 */
	public void updateProgress(int progress, int maxProgress) {
		int increment = (int)((double)(stopValue - startValue) * ((double)maxProgress / (double)progress));
		progressBar.setValue(startValue + increment);
	}

	/**
	 * Checks whether the monitored process has been canceled.
	 */
	public boolean isAborted() {
		return false;
	}

}
"
XProgressListener.java,framework,"/*
 * OpenXES
 * 
 * The reference implementation of the XES meta-model for event 
 * log data management.
 * 
 * Copyright (c) 2008 Christian W. Guenther (christian@deckfour.org)
 * 
 * 
 * LICENSE:
 * 
 * This code is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 3
 * of the License, or (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA
 * 
 * EXEMPTION:
 * 
 * The use of this software can also be conditionally licensed for
 * other programs, which do not satisfy the specified conditions. This
 * requires an exemption from the general license, which may be
 * granted on a per-case basis.
 * 
 * If you want to license the use of this software with a program
 * incompatible with the LGPL, please contact the author for an
 * exemption at the following email address: 
 * christian@deckfour.org
 * 
 */
package org.processmining.framework.util.progress;

/**
 * Interface for listening for progress on
 * an unspecified process.
 * 
 * A progress listener can abort the monitored
 * process. Abortion is specified by using the
 * <code>isAborted()</code> method, which should
 * be queried periodically by the using party.
 * 
 * @author Christian W. Guenther (christian@deckfour.org)
 *
 */
public interface XProgressListener {

	/**
	 * Notifies the listener about progress being made.
	 * 
	 * @param progress Current progress step achieved.
	 * @param maxProgress Maximal progress steps available.
	 */
	public void updateProgress(int progress, int maxProgress);
	
	/**
	 * Checks whether the monitored process has been canceled.
	 */
	public boolean isAborted();
	
}
"
ColourMap.java,graphviz,"package org.processmining.plugins.graphviz.colourMaps;

import java.awt.Color;

public abstract class ColourMap {
	public abstract Color colour(long weight, long maxWeight);

	public abstract Color colour(double value);

	@Deprecated
	public Color colour3(long weight, long min, long max) {
		if (max == min) {
			return colour(weight, weight);
		}
		return colour(weight - min, max - min);
	}

	public Color colour(long weight, long min, long max) {
		if (max == min) {
			return colour(weight, weight);
		}
		return colour(weight - min, max - min);
	}

	public Color colour(double weight, double min, double max) {
		if (max == min) {
			return colour(1);
		}
		double x = (weight - min) / (max-min);
		
		return colour(x);
	}

	public String colourString(long weight, long min, long max) {
		return toHexString(colour(weight, min, max));
	}

	public static String toHexString(Color colour) {
		return ""#"" + toHex(colour.getRed()) + toHex(colour.getGreen()) + toHex(colour.getBlue());
	}

	public static String toHex(int i) {
		String s = Integer.toHexString(i);
		if (s.length() == 2) {
			return s;
		} else {
			return ""0"" + s;
		}
	}
}
"
ColourMapBlackBody.java,graphviz,"package org.processmining.plugins.graphviz.colourMaps;

import java.awt.Color;

public class ColourMapBlackBody extends ColourMap {

	public Color colour(long weight, long maxWeight) {
		return ColourMaps.colourMapBlackBody(weight, maxWeight);
	}

	public Color colour(double value) {
		return ColourMaps.colourMapBlackBody(value);
	}

}
"
ColourMapBlue.java,graphviz,"package org.processmining.plugins.graphviz.colourMaps;

import java.awt.Color;


public class ColourMapBlue extends ColourMap {

	public Color colour(long weight, long maxWeight) {
		return ColourMaps.colourMapBlue(weight, maxWeight);
	}
	
	public Color colour(double value) {
		return ColourMaps.colourMapBlue(value);
	}
}
"
ColourMapFixed.java,graphviz,"package org.processmining.plugins.graphviz.colourMaps;

import java.awt.Color;

public class ColourMapFixed extends ColourMap {
	private Color colour;

	public ColourMapFixed(Color colour) {
		this.colour = colour;
	}

	public Color colour(long weight, long maxWeight) {
		return colour;
	}

	public Color colour(double value) {
		return colour;
	}
}
"
ColourMapFixedOpacity.java,graphviz,"package org.processmining.plugins.graphviz.colourMaps;

import java.awt.Color;

public class ColourMapFixedOpacity extends ColourMap {
	private final ColourMap base;
	private final int opacity;

	public ColourMapFixedOpacity(ColourMap base, float opacity) {
		this.base = base;
		this.opacity = (int) (opacity * 255);
	}

	public Color colour(long weight, long maxWeight) {
		Color colour = base.colour(weight, maxWeight);
		return new Color(colour.getRed(), colour.getGreen(), colour.getBlue(), opacity);
	}

	public Color colour(double value) {
		Color colour = base.colour(value);
		return new Color(colour.getRed(), colour.getGreen(), colour.getBlue(), opacity);
	}

}
"
ColourMapGreen.java,graphviz,"package org.processmining.plugins.graphviz.colourMaps;

import java.awt.Color;

public class ColourMapGreen extends ColourMap {

	public Color colour(long weight, long maxWeight) {
		return ColourMaps.colourMapGreen(weight, maxWeight);
	}

	public Color colour(double value) {
		return ColourMaps.colourMapGreen(value);
	}

}
"
ColourMapGreyBlack.java,graphviz,"package org.processmining.plugins.graphviz.colourMaps;

import java.awt.Color;

public class ColourMapGreyBlack extends ColourMap {

	public Color colour(long weight, long maxWeight) {
		return ColourMaps.colourMapGreyBlack(weight, maxWeight);
	}

	public Color colour(double value) {
		return ColourMaps.colourMapGreyBlack(value);
	}

}
"
ColourMapInterpolate.java,graphviz,"package org.processmining.plugins.graphviz.colourMaps;

import java.awt.Color;

/**
 * Interpolates a list of colours.
 * 
 * @author sander
 *
 */
public abstract class ColourMapInterpolate extends ColourMap {

	protected abstract float[][] getData();

	public Color colour(long weight, long maxWeight) {
		float x = weight / (float) maxWeight;
		return colour(x);
	}

	public Color colour(double x) {
		float[][] data = getData();
		int indexBelow = (int) Math.floor((data.length - 1) * x);
		int indexAbove = (int) Math.ceil((data.length - 1) * x);
		if (indexBelow == indexAbove) {
			return new Color(data[indexAbove][0], data[indexAbove][1], data[indexAbove][2]);
		}

		float r = interpolate(data[indexBelow][0], data[indexAbove][0], indexBelow, indexAbove, (data.length - 1) * x);
		float g = interpolate(data[indexBelow][1], data[indexAbove][1], indexBelow, indexAbove, (data.length - 1) * x);
		float b = interpolate(data[indexBelow][2], data[indexAbove][2], indexBelow, indexAbove, (data.length - 1) * x);
		return new Color(r, g, b);
	}

	public float interpolate(float fromY, float toY, float fromX, float toX, double X) {
		return (float) (fromY - ((fromY - toY) * (fromX - X) / (fromX - toX)));
	}
}
"
ColourMapLightBlue.java,graphviz,"package org.processmining.plugins.graphviz.colourMaps;

import java.awt.Color;

public class ColourMapLightBlue extends ColourMap {

	public Color colour(long weight, long maxWeight) {
		float x = weight / (float) maxWeight;

		x = (x * 0.25f) + 0.1f;
		return new Color(1 - x, 1 - x, 1);
	}
	
	public Color colour(double x) {
		x = (x * 0.25f) + 0.1f;
		return new Color((float) (1 - x), (float) (1 - x), 1);
	}

}
"
ColourMapOpacity.java,graphviz,"package org.processmining.plugins.graphviz.colourMaps;

import java.awt.Color;

public class ColourMapOpacity extends ColourMap {
	private final ColourMap base;

	public ColourMapOpacity(ColourMap base) {
		this.base = base;
	}

	public Color colour(long weight, long maxWeight) {
		float opacity = weight / (float) maxWeight;
		Color colour = base.colour(weight, maxWeight);
		return new Color(colour.getRed(), colour.getGreen(), colour.getBlue(), opacity);
	}

	public Color colour(double opacity) {
		Color colour = base.colour(opacity);
		return new Color(colour.getRed(), colour.getGreen(), colour.getBlue(), (float) opacity);
	}

}
"
ColourMapRed.java,graphviz,"package org.processmining.plugins.graphviz.colourMaps;

import java.awt.Color;

public class ColourMapRed extends ColourMap {
	
	public Color colour(long weight, long maxWeight) {
		return ColourMaps.colourMapRed(weight, maxWeight);
	}
	
	public Color colour(double value) {
		return ColourMaps.colourMapRed(value);
	}

}
"
ColourMaps.java,graphviz,"package org.processmining.plugins.graphviz.colourMaps;

import java.awt.Color;

public class ColourMaps {
	public static Color colourMapBlackBody(long weight, long maxWeight) {
		float x = weight / (float) maxWeight;

		/*
		 * //blue-yellow x = (x * (float) 0.5) + (float) 0.5; return new
		 * Color(x, x, 1-x);
		 */
		x = (x * (float) 0.75) + (float) 0.25;

		//black-body
		return new Color(Math.min(Math.max((1 - x) * 3, 0), 1),
				Math.min(Math.max((((1 - x) - 1 / (float) 3) * 3), 0), 1),
				Math.min(Math.max((((1 - x) - 2 / (float) 3) * 3), 0), 1));
	}

	public static Color colourMapBlackBody(double x) {
		/*
		 * //blue-yellow x = (x * (float) 0.5) + (float) 0.5; return new
		 * Color(x, x, 1-x);
		 */
		x = (x * (float) 0.75) + (float) 0.25;

		//black-body
		return new Color((float) (Math.min(Math.max((1 - x) * 3, 0), 1)),
				(float) (Math.min(Math.max((((1 - x) - 1 / 3) * 3), 0), 1)),
				(float) (Math.min(Math.max((((1 - x) - 2 / 3) * 3), 0), 1)));
	}

	public static Color colourMapRed(long weight, long maxWeight) {
		float x = weight / (float) maxWeight;

		x = (x * (float) 0.5) + (float) 0.5;
		return new Color(1, 1 - x, 1 - x);
	}

	public static Color colourMapRed(double x) {
		x = (x * 0.5) + 0.5;
		return new Color(1, (float) (1 - x), (float) (1 - x));
	}

	public static Color colourMapGreen(long weight, long maxWeight) {
		float x = weight / (float) maxWeight;

		x = (x * (float) 0.75) + (float) 0.25;
		return new Color(1 - x, 1, 1 - x);
	}

	public static Color colourMapGreen(double x) {
		x = (x * 0.75) + 0.25;
		return new Color((float) (1 - x), 1, (float) (1 - x));
	}

	public static Color colourMapBlue(long weight, long maxWeight) {
		float x = weight / (float) maxWeight;

		x = (x * (float) 0.75) + (float) 0.25;
		return new Color(1 - x, 1 - x, 1);
	}

	public static Color colourMapBlue(double x) {
		x = (x * 0.75) + 0.25;
		return new Color((float) (1 - x), (float) (1 - x), 1);
	}

	public static Color colourMapGreyBlack(long weight, long maxWeight) {
		float x = weight / (float) maxWeight;

		x = (x * (float) 0.6) + (float) 0.4;
		return new Color(1 - x, 1 - x, 1 - x);
	}

	public static Color colourMapGreyBlack(double x) {
		x = (x * 0.6) + 0.4;
		return new Color((float) (1 - x), (float) (1 - x), (float) (1 - x));
	}

	public static double getLuma(Color colour) {
		int R = colour.getRed();
		int G = colour.getGreen();
		int B = colour.getBlue();
		return 0.299 * R + 0.587 * G + 0.114 * B;
	}
}
"
ColourMapViridis.java,graphviz,"package org.processmining.plugins.graphviz.colourMaps;

public class ColourMapViridis extends ColourMapInterpolate {

	protected float[][] data = new float[][] { { 0.267004f, 0.004874f, 0.329415f }, { 0.268510f, 0.009605f, 0.335427f },
			{ 0.269944f, 0.014625f, 0.341379f }, { 0.271305f, 0.019942f, 0.347269f },
			{ 0.272594f, 0.025563f, 0.353093f }, { 0.273809f, 0.031497f, 0.358853f },
			{ 0.274952f, 0.037752f, 0.364543f }, { 0.276022f, 0.044167f, 0.370164f },
			{ 0.277018f, 0.050344f, 0.375715f }, { 0.277941f, 0.056324f, 0.381191f },
			{ 0.278791f, 0.062145f, 0.386592f }, { 0.279566f, 0.067836f, 0.391917f },
			{ 0.280267f, 0.073417f, 0.397163f }, { 0.280894f, 0.078907f, 0.402329f },
			{ 0.281446f, 0.084320f, 0.407414f }, { 0.281924f, 0.089666f, 0.412415f },
			{ 0.282327f, 0.094955f, 0.417331f }, { 0.282656f, 0.100196f, 0.422160f },
			{ 0.282910f, 0.105393f, 0.426902f }, { 0.283091f, 0.110553f, 0.431554f },
			{ 0.283197f, 0.115680f, 0.436115f }, { 0.283229f, 0.120777f, 0.440584f },
			{ 0.283187f, 0.125848f, 0.444960f }, { 0.283072f, 0.130895f, 0.449241f },
			{ 0.282884f, 0.135920f, 0.453427f }, { 0.282623f, 0.140926f, 0.457517f },
			{ 0.282290f, 0.145912f, 0.461510f }, { 0.281887f, 0.150881f, 0.465405f },
			{ 0.281412f, 0.155834f, 0.469201f }, { 0.280868f, 0.160771f, 0.472899f },
			{ 0.280255f, 0.165693f, 0.476498f }, { 0.279574f, 0.170599f, 0.479997f },
			{ 0.278826f, 0.175490f, 0.483397f }, { 0.278012f, 0.180367f, 0.486697f },
			{ 0.277134f, 0.185228f, 0.489898f }, { 0.276194f, 0.190074f, 0.493001f },
			{ 0.275191f, 0.194905f, 0.496005f }, { 0.274128f, 0.199721f, 0.498911f },
			{ 0.273006f, 0.204520f, 0.501721f }, { 0.271828f, 0.209303f, 0.504434f },
			{ 0.270595f, 0.214069f, 0.507052f }, { 0.269308f, 0.218818f, 0.509577f },
			{ 0.267968f, 0.223549f, 0.512008f }, { 0.266580f, 0.228262f, 0.514349f },
			{ 0.265145f, 0.232956f, 0.516599f }, { 0.263663f, 0.237631f, 0.518762f },
			{ 0.262138f, 0.242286f, 0.520837f }, { 0.260571f, 0.246922f, 0.522828f },
			{ 0.258965f, 0.251537f, 0.524736f }, { 0.257322f, 0.256130f, 0.526563f },
			{ 0.255645f, 0.260703f, 0.528312f }, { 0.253935f, 0.265254f, 0.529983f },
			{ 0.252194f, 0.269783f, 0.531579f }, { 0.250425f, 0.274290f, 0.533103f },
			{ 0.248629f, 0.278775f, 0.534556f }, { 0.246811f, 0.283237f, 0.535941f },
			{ 0.244972f, 0.287675f, 0.537260f }, { 0.243113f, 0.292092f, 0.538516f },
			{ 0.241237f, 0.296485f, 0.539709f }, { 0.239346f, 0.300855f, 0.540844f },
			{ 0.237441f, 0.305202f, 0.541921f }, { 0.235526f, 0.309527f, 0.542944f },
			{ 0.233603f, 0.313828f, 0.543914f }, { 0.231674f, 0.318106f, 0.544834f },
			{ 0.229739f, 0.322361f, 0.545706f }, { 0.227802f, 0.326594f, 0.546532f },
			{ 0.225863f, 0.330805f, 0.547314f }, { 0.223925f, 0.334994f, 0.548053f },
			{ 0.221989f, 0.339161f, 0.548752f }, { 0.220057f, 0.343307f, 0.549413f },
			{ 0.218130f, 0.347432f, 0.550038f }, { 0.216210f, 0.351535f, 0.550627f },
			{ 0.214298f, 0.355619f, 0.551184f }, { 0.212395f, 0.359683f, 0.551710f },
			{ 0.210503f, 0.363727f, 0.552206f }, { 0.208623f, 0.367752f, 0.552675f },
			{ 0.206756f, 0.371758f, 0.553117f }, { 0.204903f, 0.375746f, 0.553533f },
			{ 0.203063f, 0.379716f, 0.553925f }, { 0.201239f, 0.383670f, 0.554294f },
			{ 0.199430f, 0.387607f, 0.554642f }, { 0.197636f, 0.391528f, 0.554969f },
			{ 0.195860f, 0.395433f, 0.555276f }, { 0.194100f, 0.399323f, 0.555565f },
			{ 0.192357f, 0.403199f, 0.555836f }, { 0.190631f, 0.407061f, 0.556089f },
			{ 0.188923f, 0.410910f, 0.556326f }, { 0.187231f, 0.414746f, 0.556547f },
			{ 0.185556f, 0.418570f, 0.556753f }, { 0.183898f, 0.422383f, 0.556944f },
			{ 0.182256f, 0.426184f, 0.557120f }, { 0.180629f, 0.429975f, 0.557282f },
			{ 0.179019f, 0.433756f, 0.557430f }, { 0.177423f, 0.437527f, 0.557565f },
			{ 0.175841f, 0.441290f, 0.557685f }, { 0.174274f, 0.445044f, 0.557792f },
			{ 0.172719f, 0.448791f, 0.557885f }, { 0.171176f, 0.452530f, 0.557965f },
			{ 0.169646f, 0.456262f, 0.558030f }, { 0.168126f, 0.459988f, 0.558082f },
			{ 0.166617f, 0.463708f, 0.558119f }, { 0.165117f, 0.467423f, 0.558141f },
			{ 0.163625f, 0.471133f, 0.558148f }, { 0.162142f, 0.474838f, 0.558140f },
			{ 0.160665f, 0.478540f, 0.558115f }, { 0.159194f, 0.482237f, 0.558073f },
			{ 0.157729f, 0.485932f, 0.558013f }, { 0.156270f, 0.489624f, 0.557936f },
			{ 0.154815f, 0.493313f, 0.557840f }, { 0.153364f, 0.497000f, 0.557724f },
			{ 0.151918f, 0.500685f, 0.557587f }, { 0.150476f, 0.504369f, 0.557430f },
			{ 0.149039f, 0.508051f, 0.557250f }, { 0.147607f, 0.511733f, 0.557049f },
			{ 0.146180f, 0.515413f, 0.556823f }, { 0.144759f, 0.519093f, 0.556572f },
			{ 0.143343f, 0.522773f, 0.556295f }, { 0.141935f, 0.526453f, 0.555991f },
			{ 0.140536f, 0.530132f, 0.555659f }, { 0.139147f, 0.533812f, 0.555298f },
			{ 0.137770f, 0.537492f, 0.554906f }, { 0.136408f, 0.541173f, 0.554483f },
			{ 0.135066f, 0.544853f, 0.554029f }, { 0.133743f, 0.548535f, 0.553541f },
			{ 0.132444f, 0.552216f, 0.553018f }, { 0.131172f, 0.555899f, 0.552459f },
			{ 0.129933f, 0.559582f, 0.551864f }, { 0.128729f, 0.563265f, 0.551229f },
			{ 0.127568f, 0.566949f, 0.550556f }, { 0.126453f, 0.570633f, 0.549841f },
			{ 0.125394f, 0.574318f, 0.549086f }, { 0.124395f, 0.578002f, 0.548287f },
			{ 0.123463f, 0.581687f, 0.547445f }, { 0.122606f, 0.585371f, 0.546557f },
			{ 0.121831f, 0.589055f, 0.545623f }, { 0.121148f, 0.592739f, 0.544641f },
			{ 0.120565f, 0.596422f, 0.543611f }, { 0.120092f, 0.600104f, 0.542530f },
			{ 0.119738f, 0.603785f, 0.541400f }, { 0.119512f, 0.607464f, 0.540218f },
			{ 0.119423f, 0.611141f, 0.538982f }, { 0.119483f, 0.614817f, 0.537692f },
			{ 0.119699f, 0.618490f, 0.536347f }, { 0.120081f, 0.622161f, 0.534946f },
			{ 0.120638f, 0.625828f, 0.533488f }, { 0.121380f, 0.629492f, 0.531973f },
			{ 0.122312f, 0.633153f, 0.530398f }, { 0.123444f, 0.636809f, 0.528763f },
			{ 0.124780f, 0.640461f, 0.527068f }, { 0.126326f, 0.644107f, 0.525311f },
			{ 0.128087f, 0.647749f, 0.523491f }, { 0.130067f, 0.651384f, 0.521608f },
			{ 0.132268f, 0.655014f, 0.519661f }, { 0.134692f, 0.658636f, 0.517649f },
			{ 0.137339f, 0.662252f, 0.515571f }, { 0.140210f, 0.665859f, 0.513427f },
			{ 0.143303f, 0.669459f, 0.511215f }, { 0.146616f, 0.673050f, 0.508936f },
			{ 0.150148f, 0.676631f, 0.506589f }, { 0.153894f, 0.680203f, 0.504172f },
			{ 0.157851f, 0.683765f, 0.501686f }, { 0.162016f, 0.687316f, 0.499129f },
			{ 0.166383f, 0.690856f, 0.496502f }, { 0.170948f, 0.694384f, 0.493803f },
			{ 0.175707f, 0.697900f, 0.491033f }, { 0.180653f, 0.701402f, 0.488189f },
			{ 0.185783f, 0.704891f, 0.485273f }, { 0.191090f, 0.708366f, 0.482284f },
			{ 0.196571f, 0.711827f, 0.479221f }, { 0.202219f, 0.715272f, 0.476084f },
			{ 0.208030f, 0.718701f, 0.472873f }, { 0.214000f, 0.722114f, 0.469588f },
			{ 0.220124f, 0.725509f, 0.466226f }, { 0.226397f, 0.728888f, 0.462789f },
			{ 0.232815f, 0.732247f, 0.459277f }, { 0.239374f, 0.735588f, 0.455688f },
			{ 0.246070f, 0.738910f, 0.452024f }, { 0.252899f, 0.742211f, 0.448284f },
			{ 0.259857f, 0.745492f, 0.444467f }, { 0.266941f, 0.748751f, 0.440573f },
			{ 0.274149f, 0.751988f, 0.436601f }, { 0.281477f, 0.755203f, 0.432552f },
			{ 0.288921f, 0.758394f, 0.428426f }, { 0.296479f, 0.761561f, 0.424223f },
			{ 0.304148f, 0.764704f, 0.419943f }, { 0.311925f, 0.767822f, 0.415586f },
			{ 0.319809f, 0.770914f, 0.411152f }, { 0.327796f, 0.773980f, 0.406640f },
			{ 0.335885f, 0.777018f, 0.402049f }, { 0.344074f, 0.780029f, 0.397381f },
			{ 0.352360f, 0.783011f, 0.392636f }, { 0.360741f, 0.785964f, 0.387814f },
			{ 0.369214f, 0.788888f, 0.382914f }, { 0.377779f, 0.791781f, 0.377939f },
			{ 0.386433f, 0.794644f, 0.372886f }, { 0.395174f, 0.797475f, 0.367757f },
			{ 0.404001f, 0.800275f, 0.362552f }, { 0.412913f, 0.803041f, 0.357269f },
			{ 0.421908f, 0.805774f, 0.351910f }, { 0.430983f, 0.808473f, 0.346476f },
			{ 0.440137f, 0.811138f, 0.340967f }, { 0.449368f, 0.813768f, 0.335384f },
			{ 0.458674f, 0.816363f, 0.329727f }, { 0.468053f, 0.818921f, 0.323998f },
			{ 0.477504f, 0.821444f, 0.318195f }, { 0.487026f, 0.823929f, 0.312321f },
			{ 0.496615f, 0.826376f, 0.306377f }, { 0.506271f, 0.828786f, 0.300362f },
			{ 0.515992f, 0.831158f, 0.294279f }, { 0.525776f, 0.833491f, 0.288127f },
			{ 0.535621f, 0.835785f, 0.281908f }, { 0.545524f, 0.838039f, 0.275626f },
			{ 0.555484f, 0.840254f, 0.269281f }, { 0.565498f, 0.842430f, 0.262877f },
			{ 0.575563f, 0.844566f, 0.256415f }, { 0.585678f, 0.846661f, 0.249897f },
			{ 0.595839f, 0.848717f, 0.243329f }, { 0.606045f, 0.850733f, 0.236712f },
			{ 0.616293f, 0.852709f, 0.230052f }, { 0.626579f, 0.854645f, 0.223353f },
			{ 0.636902f, 0.856542f, 0.216620f }, { 0.647257f, 0.858400f, 0.209861f },
			{ 0.657642f, 0.860219f, 0.203082f }, { 0.668054f, 0.861999f, 0.196293f },
			{ 0.678489f, 0.863742f, 0.189503f }, { 0.688944f, 0.865448f, 0.182725f },
			{ 0.699415f, 0.867117f, 0.175971f }, { 0.709898f, 0.868751f, 0.169257f },
			{ 0.720391f, 0.870350f, 0.162603f }, { 0.730889f, 0.871916f, 0.156029f },
			{ 0.741388f, 0.873449f, 0.149561f }, { 0.751884f, 0.874951f, 0.143228f },
			{ 0.762373f, 0.876424f, 0.137064f }, { 0.772852f, 0.877868f, 0.131109f },
			{ 0.783315f, 0.879285f, 0.125405f }, { 0.793760f, 0.880678f, 0.120005f },
			{ 0.804182f, 0.882046f, 0.114965f }, { 0.814576f, 0.883393f, 0.110347f },
			{ 0.824940f, 0.884720f, 0.106217f }, { 0.835270f, 0.886029f, 0.102646f },
			{ 0.845561f, 0.887322f, 0.099702f }, { 0.855810f, 0.888601f, 0.097452f },
			{ 0.866013f, 0.889868f, 0.095953f }, { 0.876168f, 0.891125f, 0.095250f },
			{ 0.886271f, 0.892374f, 0.095374f }, { 0.896320f, 0.893616f, 0.096335f },
			{ 0.906311f, 0.894855f, 0.098125f }, { 0.916242f, 0.896091f, 0.100717f },
			{ 0.926106f, 0.897330f, 0.104071f }, { 0.935904f, 0.898570f, 0.108131f },
			{ 0.945636f, 0.899815f, 0.112838f }, { 0.955300f, 0.901065f, 0.118128f },
			{ 0.964894f, 0.902323f, 0.123941f }, { 0.974417f, 0.903590f, 0.130215f },
			{ 0.983868f, 0.904867f, 0.136897f }, { 0.993248f, 0.906157f, 0.143936f } };

	protected float[][] getData() {
		return data;
	}
}"
ColourMapWhiteRed.java,graphviz,"package org.processmining.plugins.graphviz.colourMaps;

import java.awt.Color;

public class ColourMapWhiteRed extends ColourMap {
	public Color colour(long weight, long maxWeight) {
		float x = weight / (float) maxWeight;
		return new Color(1, x, x);
	}

	public Color colour(double value) {
		return new Color(1, (float) value, (float) value);
	}
}
"
AbstractDotElement.java,graphviz,"package org.processmining.plugins.graphviz.dot;

import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.UUID;
import java.util.concurrent.CopyOnWriteArrayList;

import org.processmining.plugins.graphviz.visualisation.listeners.DotElementSelectionListener;

public abstract class AbstractDotElement implements DotElement {
	private final String id;
	private Map<String, String> optionsMap;
	private String label;

	private boolean selectable = false;
	private final List<DotElementSelectionListener> selectionListeners = new CopyOnWriteArrayList<>();
	private final List<MouseListener> mouseListeners = new CopyOnWriteArrayList<MouseListener>();

	public AbstractDotElement() {
		id = ""e"" + UUID.randomUUID().toString();
		label = """";
		optionsMap = new HashMap<>();
	}

	public String getId() {
		return id;
	}

	public String getLabel() {
		return label;
	}

	public void setLabel(String label) {
		this.label = label;
	}

	public String labelToString() {
		return escapeString(label);
	}
	
	protected String escapeString(String value) {
		if (value.length() > 2 && value.substring(0, 1).equals(""<"")
				&& value.substring(value.length() - 1, value.length()).equals("">"")) {
			return value;
		} else {
			String value2 = value.replace(""\"""", ""\\\"""");
			return ""\"""" + value2 + ""\"""";
		}
	}

	@Override
	public void setOption(String key, String value) {
		optionsMap.put(key, value);
	}
	
	@Override
	public String getOption(String key) {
		if (optionsMap.containsKey(key)) {
			return optionsMap.get(key);
		}
		return null;
	}
	
	@Override
	public Set<String> getOptionKeySet() {
		return Collections.unmodifiableSet(optionsMap.keySet());
	}

	public void addMouseListener(MouseListener l) {
		mouseListeners.add(l);
	}

	public void mouseClicked(MouseEvent e) {
		for (MouseListener l : mouseListeners) {
			l.mouseClicked(e);
		}
	}

	public void mouseEntered(MouseEvent e) {
		for (MouseListener l : mouseListeners) {
			l.mouseEntered(e);
		}
	}

	public void mouseExited(MouseEvent e) {
		for (MouseListener l : mouseListeners) {
			l.mouseExited(e);
		}
	}

	public void mousePressed(MouseEvent e) {
		for (MouseListener l : mouseListeners) {
			l.mousePressed(e);
		}
	}

	public void mouseReleased(MouseEvent e) {
		for (MouseListener l : mouseListeners) {
			l.mouseReleased(e);
		}
	}

	//selection stuff
	public void setSelectable(boolean selectable) {
		this.selectable = selectable;
	}

	public boolean isSelectable() {
		return selectable;
	}
	
	public void addSelectionListener(DotElementSelectionListener listener) {
		setSelectable(true);
		selectionListeners.add(listener);
	}
	
	public List<DotElementSelectionListener> getSelectionListeners() {
		return Collections.unmodifiableList(selectionListeners);	
	}
}
"
Dot.java,graphviz,"package org.processmining.plugins.graphviz.dot;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStream;

import org.apache.commons.io.IOUtils;

public class Dot extends DotCluster {

	public enum GraphDirection {
		topDown(""TD""), leftRight(""LR""), bottomTop(""BT""), rightLeft(""RL"");

		private final String name;

		private GraphDirection(String s) {
			name = s;
		}

		public String getName() {
			return name;
		}
	}

	private String stringValue = null;

	public Dot() {
		setOption(""rankdir"", ""TD"");
		setOption(""compound"", ""true"");
	}

	public String toString() {
		if (stringValue != null) {
			return stringValue;
		}

		StringBuilder result = new StringBuilder();
		result.append(""digraph G {\n"");

		appendOptions(result);

		contentToString(result);

		result.append(""}"");

		return result.toString();
	}

	public Dot(InputStream input) throws IOException {
		this.stringValue = IOUtils.toString(input, ""UTF-8"");
	}

	public void exportToFile(File file) throws IOException {
		BufferedWriter writer = null;
		try {
			writer = new BufferedWriter(new FileWriter(file));
			writer.write(toString());
		} finally {
			try {
				if (writer != null) {
					writer.close();
				}
			} catch (IOException e) {
				e.printStackTrace();
			}
		}
	}

	public GraphDirection getDirection() {
		String value = getOption(""rankdir"");
		for (GraphDirection dir : GraphDirection.values()) {
			if (dir.getName().equals(value)) {
				return dir;
			}
		}
		return GraphDirection.topDown;
	}

	public void setDirection(GraphDirection direction) {
		setOption(""rankdir"", direction.getName());
	}

	public void setStringValue(String stringValue) {
		this.stringValue = stringValue;
	}

	public boolean isKeepOrderingOfChildren() {
		return ""out"".equals(getGraphOption(""ordering""));
	}

	public void setKeepOrderingOfChildren(boolean keepOrderingOfChildren) {
		if (keepOrderingOfChildren) {
			setGraphOption(""ordering"", ""out"");
		} else {
			setGraphOption(""ordering"", """"); // graphviz default
		}
	}

}"
Dot2Image.java,graphviz,"package org.processmining.plugins.graphviz.dot;

import java.io.BufferedInputStream;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStreamWriter;
import java.io.PrintStream;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.List;
import java.util.Scanner;

import org.apache.commons.compress.utils.IOUtils;
import org.apache.commons.lang3.exception.ExceptionUtils;

public class Dot2Image {

	public static final int dotVersion = 8;

	public enum Type {
		png, pdf, svg
	}

	public enum Engine {
		dot, neato
	}

	public static InputStream dot2imageInputStream(Dot dot, Type type) {
		Engine engine;
		if (dot.getOption(""engine"") == ""neato"") {
			engine = Engine.neato;
		} else {
			engine = Engine.dot;
		}
		return dot2imageInputStream(dot.toString(), type, engine);
	}

	public static InputStream dot2imageInputStream(String dot, Type type) {
		return dot2imageInputStream(dot, type, Engine.dot);
	}

	public static InputStream dot2imageInputStream(Dot dot, Type type, Engine engine) {
		return dot2imageInputStream(dot.toString(), type, engine);
	}

	public static InputStream dot2imageInputStream(String dot, Type type, Engine engine) {
		File dotDirectory;
		try {
			dotDirectory = getDotDirectory();
		} catch (IOException e1) {
			e1.printStackTrace();
			throw new RuntimeException(""Graphviz-dot binary not found. \n"" + ExceptionUtils.getStackTrace(e1));
		}

		//detect the operating system and locate dot binary
		String os = System.getProperty(""os.name"").toLowerCase();
		File dotFile;
		if (os.indexOf(""win"") >= 0) {
			//windows
			dotFile = new File(dotDirectory, ""dot.exe"");
		} else if (os.indexOf(""mac"") >= 0) {
			//assume mac
			dotFile = new File(new File(dotDirectory, ""mac""), ""dot"");
			dotFile.setExecutable(true);
		} else if (System.getProperty(""os.arch"").contains(""64"")) {
			//assume linux 64 bit
			dotFile = new File(new File(dotDirectory, ""linux64""), ""dot"");
			dotFile.setExecutable(true);
		} else {
			//assume linux 32 bit
			dotFile = new File(new File(dotDirectory, ""linux32""), ""dot"");
			dotFile.setExecutable(true);
		}

		//		System.out.println(dotFile);

		if (!dotFile.exists() || !dotFile.canExecute()) {
			throw new RuntimeException(""Graphviz-dot binary not found. "" + dotFile.toString());
		}

		String args[];
		switch (engine) {
			case dot :
				args = new String[3];
				args[0] = dotFile.getAbsolutePath();
				args[1] = ""-T"" + type;
				args[2] = ""-q"";
				break;
			case neato :
				args = new String[5];
				args[0] = dotFile.getAbsolutePath();
				args[1] = ""-n"";
				args[2] = ""-Kneato"";
				args[3] = ""-T"" + type;
				args[4] = ""-q"";
				break;
			default :
				args = new String[3];
				args[0] = dotFile.getAbsolutePath();
				args[1] = ""-T"" + type;
				args[2] = ""-q"";
				break;

		}

		final ProcessBuilder pb = new ProcessBuilder(args);
		pb.redirectErrorStream(false);

		Process dotProcess = null;
		try {
			dotProcess = pb.start();
			BufferedWriter out2 = new BufferedWriter(new OutputStreamWriter(dotProcess.getOutputStream(), ""UTF-8""));
			out2.write(dot.toString());
			out2.flush();
			out2.close();
		} catch (IOException e) {
			e.printStackTrace();
			return null;
		}

		redirectIO(dotProcess.getErrorStream(), System.err);
		InputStream outputOfDot = new BufferedInputStream(dotProcess.getInputStream());

		return outputOfDot;
	}

	public static boolean dot2image(String dot, File file, Type type) {
		return dot2image(dot, file, type, Engine.dot);
	}

	public static boolean dot2image(String dot, File file, Type type, Engine engine) {
		try {
			InputStream inputStream = dot2imageInputStream(dot, type, engine);
			FileOutputStream outputStream = new FileOutputStream(file);
			IOUtils.copy(inputStream, outputStream);
			outputStream.flush();
			outputStream.close();
		} catch (IOException e) {
			e.printStackTrace();
			return false;
		}
		return true;
	}

	public static boolean dot2image(Dot dot, File file, Type type) {
		return dot2image(dot.toString(), file, type);
	}

	public static boolean dot2image(Dot dot, File file, Type type, Engine engine) {
		return dot2image(dot.toString(), file, type, engine);
	}

	private static List<String> dotFiles = new LinkedList<String>(Arrays.asList(""dot.exe"", ""cdt.dll"", ""cgraph.dll"",
			""config6"", ""dot.exe"", ""fontconfig_fix.dll"", ""fontconfig.dll"", ""freetype6.dll"", ""glut32.dll"", ""gvc.dll"",
			""gvplugin_core.dll"", ""gvplugin_dot_layout.dll"", ""gvplugin_gd.dll"", ""gvplugin_gdiplus.dll"",
			""gvplugin_neato_layout.dll"", ""gvplugin_pango.dll"", ""iconv.dll"", ""intl.dll"", ""jpeg62.dll"",
			""libatk-1.0-0.dll"", ""libcairo-2.dll"", ""libexpat-1.dll"", ""libexpat.dll"", ""libfontconfig-1.dll"",
			""libfreetype-6.dll"", ""libgdk_pixbuf-2.0-0.dll"", ""libgdk-win32-2.0-0.dll"", ""libgdkglext-win32-1.0-0.dll"",
			""libgio-2.0-0.dll"", ""libglib-2.0-0.dll"", ""libgmodule-2.0-0.dll"", ""libgobject-2.0-0.dll"",
			""libgthread-2.0-0.dll"", ""libgtk-win32-2.0-0.dll"", ""libgtkglext-win32-1.0-0.dll"", ""libltdl-3.dll"",
			""libpango-1.0-0.dll"", ""libpangocairo-1.0-0.dll"", ""libpangoft2-1.0-0.dll"", ""libpangowin32-1.0-0.dll"",
			""cdt.dll"", ""cgraph.dll"", ""config6"", ""dot.exe"", ""fontconfig_fix.dll"", ""fontconfig.dll"", ""freetype6.dll"",
			""glut32.dll"", ""gvc.dll"", ""gvplugin_core.dll"", ""gvplugin_dot_layout.dll"", ""gvplugin_gd.dll"",
			""gvplugin_gdiplus.dll"", ""gvplugin_neato_layout.dll"", ""gvplugin_pango.dll"", ""iconv.dll"", ""intl.dll"",
			""jpeg62.dll"", ""libatk-1.0-0.dll"", ""libcairo-2.dll"", ""libexpat-1.dll"", ""libexpat.dll"", ""libfontconfig-1.dll"",
			""libfreetype-6.dll"", ""libgdk_pixbuf-2.0-0.dll"", ""libgdk-win32-2.0-0.dll"", ""libgdkglext-win32-1.0-0.dll"",
			""libgio-2.0-0.dll"", ""libglib-2.0-0.dll"", ""libgmodule-2.0-0.dll"", ""libgobject-2.0-0.dll"",
			""libgthread-2.0-0.dll"", ""libgtk-win32-2.0-0.dll"", ""libgtkglext-win32-1.0-0.dll"", ""libltdl-3.dll"",
			""libpango-1.0-0.dll"", ""libpangocairo-1.0-0.dll"", ""libpangoft2-1.0-0.dll"", ""libpangowin32-1.0-0.dll"",
			""libpng12.dll"", ""libpng14-14.dll"", ""libxml2.dll"", ""ltdl.dll"", ""Pathplan.dll"", ""zlib1.dll"", ""libpng12.dll"",
			""libpng14-14.dll"", ""libxml2.dll"", ""ltdl.dll"", ""Pathplan.dll"", ""zlib1.dll"",
			//linux
			""linux32/dot"", ""linux64/dot"",
			//mac
			""mac/dot""));

	private static synchronized File getDotDirectory() throws IOException {
		File dotDirectory = new File(new File(System.getProperty(""java.io.tmpdir""), "".prom-graphviz""),
				""dotBinaries"" + dotVersion);
		if (!dotDirectory.exists()) {
			createDotDirectoryByCopying(dotDirectory);
		}

		for (String fileName : dotFiles) {
			File outputFile = new File(dotDirectory, fileName);
			if (!outputFile.exists()) {
				createDotDirectoryByCopying(dotDirectory);
				break;
			}
		}

		return dotDirectory;
	}

	private static void createDotDirectoryByCopying(File targetDirectory) throws IOException {
		System.out.println(""dot directory "" + targetDirectory + "" does not exist; create it and copy binaries to it"");
		targetDirectory.mkdirs();
		new File(targetDirectory, ""mac"").mkdir();
		new File(targetDirectory, ""linux32"").mkdir();
		new File(targetDirectory, ""linux64"").mkdir();

		//copy files to dot directory
		for (String fileName : dotFiles) {
			File outputFile = new File(targetDirectory, fileName);
			System.out.println(""copy "" + fileName);
			InputStream inputStream = Dot2Image.class
					.getResourceAsStream(""/org/processmining/plugins/graphviz/dot/binaries/"" + fileName);
			FileOutputStream outputStream = new FileOutputStream(outputFile);
			IOUtils.copy(inputStream, outputStream);
			outputFile.setExecutable(true);

			outputStream.flush();
			outputStream.close();
		}
	}

	private static void redirectIO(final InputStream src, final PrintStream dest) {
		new Thread(new Runnable() {
			public void run() {
				Scanner sc = new Scanner(src);
				while (sc.hasNextLine()) {
					dest.println(sc.nextLine());
				}
			}
		}).start();
	}
}
"
DotCluster.java,graphviz,"package org.processmining.plugins.graphviz.dot;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;

public class DotCluster extends DotNode {

	private final List<DotNode> nodes;
	private final List<DotEdge> edges;
	private final List<DotCluster> clusters;

	private final Map<String, String> graphOptionMap;
	private final Map<String, String> nodeOptionMap;
	private final Map<String, String> edgeOptionMap;

	protected DotCluster() {
		super("""", null);
		nodes = new ArrayList<DotNode>();
		edges = new ArrayList<DotEdge>();
		clusters = new ArrayList<DotCluster>();
		graphOptionMap = new HashMap<>();
		nodeOptionMap = new HashMap<>();
		edgeOptionMap = new HashMap<>();
	}

	/**
	 * 
	 * @return An unmodifiable list of all nodes in the graph (not in
	 *         sub-graphs).
	 */
	public List<DotNode> getNodes() {
		return Collections.unmodifiableList(nodes);
	}

	/**
	 * 
	 * @return An unmodifiable list of all nodes in this graph and all it's
	 *         sub-graphs.
	 */
	public List<DotNode> getNodesRecursive() {
		List<DotNode> result = new LinkedList<DotNode>();
		result.addAll(nodes);
		result.addAll(clusters);

		for (DotCluster cluster : clusters) {
			result.addAll(cluster.getNodesRecursive());
		}

		return Collections.unmodifiableList(result);
	}

	/**
	 * Add a new dot node to the graph with the given label.
	 * 
	 * @param label
	 * @return the new dot node.
	 */
	public DotNode addNode(String label) {
		return addNode(label, null);
	}

	/**
	 * Add a new dot node to the graph.
	 * 
	 * @param label
	 * @param options
	 *            A map of node options, which will not be copied.
	 * @return the new dot node.
	 */
	public DotNode addNode(String label, Map<String, String> options) {
		DotNode result = new DotNode(label, options);
		addNode(result);
		return result;
	}

	/**
	 * Add an existing dot node to the graph.
	 * 
	 * @param node
	 */
	public void addNode(DotNode node) {
		nodes.add(node);
	}

	/**
	 * Insert a new dot node to the graph.
	 * 
	 * @param index
	 *            The index at which the node is to be inserted.
	 * @param label
	 * @return the new dot node.
	 */
	public DotNode insertNode(int index, String label) {
		return insertNode(index, label, null);
	}

	/**
	 * Insert a new dot node to the graph.
	 * 
	 * @param index
	 *            The index at which the node is to be inserted.
	 * @param label
	 * @param options
	 *            A map of node options, which will not be copied.
	 * @return the new dot node.
	 */
	public DotNode insertNode(int index, String label, Map<String, String> options) {
		DotNode result = new DotNode(label, options);
		insertNode(index, result);
		return result;
	}

	/**
	 * Insert an existing node into the graph.
	 * 
	 * @param index
	 *            The index at which the node is to be inserted.
	 * @param node
	 */
	public void insertNode(int index, DotNode node) {
		nodes.add(index, node);
	}

	/**
	 * Remove all equivalent dot nodes from the graph.
	 * 
	 * @param node
	 */
	public void removeNode(DotNode node) {
		Iterator<DotNode> it = nodes.iterator();
		while (it.hasNext()) {
			if (node.equals(it.next())) {
				it.remove();
			}
		}
	}

	/**
	 * Set a default node option. It will be a default for all nodes in this
	 * graph.
	 * 
	 * @param option
	 * @param value
	 */
	public void setNodeOption(String option, String value) {
		nodeOptionMap.put(option, value);
	}

	/**
	 * Get a default node option.
	 * 
	 * @param option
	 * @return The value of that option, or null if it is not set.
	 */
	public String getNodeOption(String option) {
		if (nodeOptionMap.containsKey(option)) {
			return nodeOptionMap.get(option);
		}
		return null;
	}

	/**
	 * 
	 * @return An unmodifiable list of all default node options for this graph.
	 */
	public Set<String> getNodeOptionKeySet() {
		return Collections.unmodifiableSet(nodeOptionMap.keySet());
	}

	/**
	 * 
	 * @return An unmodifiable list of all edges in this graph (not in
	 *         sub-graphs).
	 */
	public List<DotEdge> getEdges() {
		return Collections.unmodifiableList(edges);
	}

	/**
	 * 
	 * @return An unmodifiable list of all edges in this graph and in all its
	 *         sub-graphs.
	 */
	public List<DotEdge> getEdgesRecursive() {
		List<DotEdge> result = new LinkedList<DotEdge>();
		result.addAll(edges);

		for (DotCluster cluster : clusters) {
			result.addAll(cluster.getEdgesRecursive());
		}

		return Collections.unmodifiableList(result);
	}

	/**
	 * Add an edge that connects source to target, with a default label.
	 * 
	 * @param source
	 * @param target
	 * @return
	 */
	public DotEdge addEdge(DotNode source, DotNode target) {
		return addEdge(source, target, """");
	}

	/**
	 * Add an edge that connects source to target, having a label, without
	 * further options set.
	 * 
	 * @param source
	 * @param target
	 * @param label
	 * @return
	 */
	public DotEdge addEdge(DotNode source, DotNode target, String label) {
		return addEdge(source, target, label, null);
	}

	/**
	 * Add an edge that connects source to target, having a label and using an
	 * options map. This options map is not copied.
	 * 
	 * @param source
	 * @param target
	 * @param label
	 * @param optionsMap
	 * @return
	 */
	public DotEdge addEdge(DotNode source, DotNode target, String label, Map<String, String> optionsMap) {
		DotEdge result = new DotEdge(source, target, label, optionsMap);
		addEdge(result);
		return result;
	}

	/**
	 * Add a previously defined dot edge.
	 * 
	 * @param edge
	 */
	public void addEdge(DotEdge edge) {
		edges.add(edge);
	}

	/**
	 * Remove all equivalent edges from the graph.
	 * 
	 * @param edge
	 */
	public void removeEdge(DotEdge edge) {
		Iterator<DotEdge> it = edges.iterator();
		while (it.hasNext()) {
			if (edge == it.next()) {
				it.remove();
			}
		}
	}

	/**
	 * 
	 * @param source
	 * @param target
	 * @return The first edge from source to target in the graph.
	 */
	public DotEdge getFirstEdge(DotNode source, DotNode target) {
		for (DotEdge edge : edges) {
			if (edge.getSource() == source && edge.getTarget() == target) {
				return edge;
			}
		}
		return null;
	}

	/**
	 * Sets a default edge option. This will be the default for all edges in
	 * this graph.
	 * 
	 * @param option
	 * @param value
	 */
	public void setEdgeOption(String option, String value) {
		edgeOptionMap.put(option, value);
	}

	/**
	 * 
	 * @param option
	 * @return The value of the option, or null if it does not exist.
	 */
	public String getEdgeOption(String option) {
		if (edgeOptionMap.containsKey(option)) {
			return edgeOptionMap.get(option);
		}
		return null;
	}

	/**
	 * 
	 * @return An unmodifiable set of all default edge options set for this
	 *         graph.
	 */
	public Set<String> getEdgeOptions() {
		return Collections.unmodifiableSet(edgeOptionMap.keySet());
	}

//	@Deprecated
//	public Set<String> getEdgeOptionKeySet() {
//		return getEdgeOptions();
//	}

	/**
	 * 
	 * @return An unmodifiable list of clusters in this graph (not in
	 *         sub-graphs).
	 */
	public List<DotCluster> getClusters() {
		return Collections.unmodifiableList(clusters);
	}

	/**
	 * Add a new cluster to the graph.
	 * 
	 * @return
	 */
	public DotCluster addCluster() {
		DotCluster cluster = new DotCluster();
		clusters.add(cluster);
		return cluster;
	}

	/**
	 * Removes all equivalent clusters from the graph (not from sub-graphs).
	 * 
	 * @param cluster
	 */
	public void removeCluster(DotCluster cluster) {
		Iterator<DotCluster> it = clusters.iterator();
		while (it.hasNext()) {
			if (cluster.equals(it.next())) {
				it.remove();
			}
		}
	}

	/**
	 * Sets a default option for sub-graphs of this graph.
	 * 
	 * @param option
	 * @param value
	 */
	public void setGraphOption(String option, String value) {
		graphOptionMap.put(option, value);
	}

	/**
	 * Gets a default option for sub-graphs of this graph.
	 * 
	 * @param option
	 * @return the value of the option, or null if it does not exist.
	 */
	public String getGraphOption(String option) {
		if (graphOptionMap.containsKey(option)) {
			return graphOptionMap.get(option);
		}
		return null;
	}

	/**
	 * 
	 * @return An unmodifiable set of graph options that are set on this graph.
	 */
	public Set<String> getGraphOptions() {
		return Collections.unmodifiableSet(graphOptionMap.keySet());
	}

//	@Deprecated
//	public Set<String> getGraphOptionKeySet() {
//		return Collections.unmodifiableSet(graphOptionMap.keySet());
//	}

	/**
	 * Get a string representation of this graph in the Dot-language.
	 */
	public String toString() {
		StringBuilder result = new StringBuilder();
		result.append(""subgraph \"""" + getId() + ""\""{\n"");

		result.append(""id=\"""" + getId() + ""\"";"");
		result.append(""label="" + labelToString() + "";"");

		appendOptions(result);

		contentToString(result);

		result.append(""}"");

		return result.toString();
	}

	protected void appendOptions(StringBuilder result) {
		for (String key : getOptionKeySet()) {
			/*
			 * HV, May 11, 2017
			 * Graph label may contain HTML code. Deal with that.
			 */
			if (key.equals(""label"")) {
				String label = getOption(key);
				if (label.startsWith(""<"") && label.endsWith("">"")) {
					// Label contains HTML code, copy as-is
					result.append(key + ""="" + label + "";\n"");
					continue;
				}
			} 
			result.append(key + ""=\"""" + getOption(key) + ""\"";\n"");
		}
		appendSpecialOptions(result, ""graph"", graphOptionMap);
		appendSpecialOptions(result, ""node"", nodeOptionMap);
		appendSpecialOptions(result, ""edge"", edgeOptionMap);
	}

	protected void appendSpecialOptions(StringBuilder result, String type, Map<String, String> optionMap) {
		Iterator<String> graphOptionIter = optionMap.keySet().iterator();
		if (graphOptionIter.hasNext()) {
			result.append(type);
			result.append(""["");
			while (graphOptionIter.hasNext()) {
				String key = graphOptionIter.next();
				result.append(key + ""="" + escapeString(optionMap.get(key)));
				if (graphOptionIter.hasNext()) {
					result.append(',');
				}
			}
			result.append(""];\n"");
		}
	}

	protected void contentToString(StringBuilder result) {
		for (DotNode node : nodes) {
			result.append(node);
			result.append(""\n"");
		}

		for (DotEdge edge : edges) {
			result.append(edge);
			result.append(""\n"");
		}

		for (DotCluster cluster : clusters) {
			result.append(cluster);
			result.append(""\n"");
		}
	}

	@Override
	public String getId() {
		return ""cluster_"" + super.getId();
	}

}
"
DotEdge.java,graphviz,"package org.processmining.plugins.graphviz.dot;

import java.util.Map;
import java.util.Map.Entry;

public class DotEdge extends AbstractDotElement {

	private DotNode source;
	private DotNode target;

	public DotEdge(DotNode source, DotNode target) {
		this.setSource(source);
		this.setTarget(target);
	}

	public DotEdge(DotNode source, DotNode target, String label, Map<String, String> optionsMap) {
		this.setSource(source);
		this.setTarget(target);
		this.setLabel(label);
		if (optionsMap != null) {
			for (Entry<String, String> e : optionsMap.entrySet()) {
				setOption(e.getKey(), e.getValue());
			}
		}
	}

	public DotNode getTarget() {
		return target;
	}

	public void setTarget(DotNode target) {
		this.target = target;
	}

	public DotNode getSource() {
		return source;
	}

	public void setSource(DotNode source) {
		this.source = source;
	}

	public String toString() {
		/**
		 * Dot does not support edges from/to clusters. I such edges are added,
		 * use an arbitrary node in the cluster as the target.
		 */
		DotNode localSource = source;
		DotNode localTarget = target;
		{
			if (localSource instanceof DotCluster && !((DotCluster) localSource).getNodes().isEmpty()) {
				localSource = ((DotCluster) localSource).getNodes().get(0);
			}
			if (localTarget instanceof DotCluster && !((DotCluster) localTarget).getNodes().isEmpty()) {
				localTarget = ((DotCluster) localTarget).getNodes().get(0);
			}
		}

		String result = ""\"""" + localSource.getId() + ""\"" -> \"""" + localTarget.getId() + ""\"" [label="" + labelToString()
				+ "" id=\"""" + getId() + ""\"""";

		for (String key : getOptionKeySet()) {
			result += "","" + key + ""="" + escapeString(getOption(key));
		}
		
		/**
		 * If the edges goes to/from a cluster, we need to set the lhead/ltail.
		 */
		if (localSource != source) {
			result += "",ltail="" + escapeString(source.getId());
		}
		if (localTarget != target) {
			result += "",lhead="" + escapeString(target.getId());
		}

		return result + ""];"";
	}
}
"
DotElement.java,graphviz,"package org.processmining.plugins.graphviz.dot;

import java.awt.event.MouseListener;
import java.util.List;
import java.util.Set;

import org.processmining.plugins.graphviz.visualisation.listeners.DotElementSelectionListener;

public interface DotElement extends MouseListener {

	public String getLabel();

	public void setLabel(String label);

	public void setOption(String key, String value);

	/**
	 * 
	 * @param key
	 * @return the value of the option if it was set, otherwise null.
	 */
	public String getOption(String key);

	/**
	 * 
	 * @return the set of options that is set (keys)
	 */
	public Set<String> getOptionKeySet();

	public String getId();

	//mouse listeners, gui stuff

	/**
	 * Please note that in the current implementation, only a click on a drawn
	 * pixel of an element is registered as a click (due to Bezier curves for
	 * edges and irregular shapes for nodes). Thus, only if a user clicks on the
	 * border or label of a node, the click is registered. The same holds for
	 * mouseEnter and mouseExit events: these are based on drawn pixels.
	 * 
	 * To avoid this problem, give each node a fill using
	 * node.setOption(""fillcolor"", ""#FFFFFF"") and node.setOption(""style"",
	 * ""filled"").
	 * 
	 * @param l
	 */
	public void addMouseListener(MouseListener l);

	//selection listeners

	/**
	 * Sets whether this node can be selected.
	 * 
	 * Please note that in the current implementation, only a click on a drawn
	 * pixel of an element is registered as a click (due to Bezier curves for
	 * edges and irregular shapes for nodes). Thus, only if a user clicks on the
	 * border or label of a node, the click is registered.
	 * 
	 * To avoid this problem, give each node a fill using
	 * node.setOption(""fillcolor"", ""#FFFFFF"") and node.setOption(""style"",
	 * ""filled"").
	 * 
	 * @param selectable
	 */
	public void setSelectable(boolean selectable);

	/**
	 * Please note that in the current implementation, only a click on a drawn
	 * pixel of an element is registered as a click (due to Bezier curves for
	 * edges and irregular shapes for nodes). Thus, only if a user clicks on the
	 * border or label of a node, the click is registered.
	 * 
	 * To avoid this problem, give each node a fill using
	 * node.setOption(""fillcolor"", ""#FFFFFF"") and node.setOption(""style"",
	 * ""filled"").
	 * 
	 * @return whether the element is selectable.
	 */
	public boolean isSelectable();

	/**
	 * Add a selection/deselection listener. Side-effect: enables selection of
	 * the element. Thread-safe.
	 * 
	 * Please note that in the current implementation, only a click on a drawn
	 * pixel of an element is registered as a click (due to Bezier curves for
	 * edges and irregular shapes for nodes). Thus, only if a user clicks on the
	 * border or label of a node, the click is registered.
	 * 
	 * To avoid this problem, give each node a fill using
	 * node.setOption(""fillcolor"", ""#FFFFFF"") and node.setOption(""style"",
	 * ""filled"").
	 * 
	 * @param listener
	 */
	public void addSelectionListener(DotElementSelectionListener listener);

	public List<DotElementSelectionListener> getSelectionListeners();
}
"
DotNode.java,graphviz,"package org.processmining.plugins.graphviz.dot;

import java.util.Map;
import java.util.Map.Entry;

public class DotNode extends AbstractDotElement {

	protected DotNode(String label, Map<String, String> optionsMap) {
		this.setLabel(label);
		if (optionsMap != null) {
			for (Entry<String, String> e : optionsMap.entrySet()) {
				setOption(e.getKey(), e.getValue());
			}
		}
	}

	public boolean equals(Object object) {
		if (!(object instanceof DotNode)) {
			return false;
		}
		return ((DotNode) object).getId().equals(getId());
	}

	public String toString() {
		String result = ""\"""" + getId() + ""\"" [label="" + labelToString() + "", id=\"""" + getId() + ""\"""";
		for (String key : getOptionKeySet()) {
			result += "","" + key + ""="" + escapeString(getOption(key));
		}
		return result + ""];"";
	}

}
"
DotEMFExportPlugin.java,graphviz,"package org.processmining.plugins.graphviz.dot.plugins;

import java.io.File;
import java.io.IOException;

import org.processmining.contexts.uitopia.annotations.UIExportPlugin;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginLevel;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.plugins.graphviz.dot.Dot;
import org.processmining.plugins.graphviz.visualisation.export.ExporterEMF;

/**
 * Exports a Dot object
 * 
 * @author F. Mannhardt
 *
 */
@Plugin(name = ""Export Dot as EMF"", returnLabels = {}, returnTypes = {}, level = PluginLevel.Regular, parameterLabels = {
		""Dot"", ""File"" }, userAccessible = true)
@UIExportPlugin(description = ""Export EMF"", extension = ""emf"")
public final class DotEMFExportPlugin extends DotImageExportPlugin {

	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""F. Mannhardt"", email = ""f.mannhardt@tue.nl"")
	@PluginVariant(requiredParameterLabels = { 0, 1 }, variantLabel = ""Export Dot as EMF"")
	public void exportAsEMF(PluginContext context, Dot dot, File file) throws IOException {
		export(dot, file, new ExporterEMF());
	}
}"
DotEPSExportPlugin.java,graphviz,"package org.processmining.plugins.graphviz.dot.plugins;

import java.io.File;
import java.io.IOException;

import org.processmining.contexts.uitopia.annotations.UIExportPlugin;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginLevel;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.plugins.graphviz.dot.Dot;
import org.processmining.plugins.graphviz.visualisation.export.ExporterEPS;

/**
 * Exports a Dot object
 * 
 * @author F. Mannhardt
 *
 */
@Plugin(name = ""Export Dot as EPS"", returnLabels = {}, returnTypes = {}, level = PluginLevel.Regular, parameterLabels = {
		""Dot"", ""File"" }, userAccessible = true)
@UIExportPlugin(description = ""Export EPS"", extension = ""eps"")
public final class DotEPSExportPlugin extends DotImageExportPlugin {

	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""F. Mannhardt"", email = ""f.mannhardt@tue.nl"")
	@PluginVariant(requiredParameterLabels = { 0, 1 }, variantLabel = ""Export Dot as EPS"")
	public void exportAsEPS(PluginContext context, Dot dot, File file) throws IOException {
		export(dot, file, new ExporterEPS());
	}
}"
DotExportPlugin.java,graphviz,"package org.processmining.plugins.graphviz.dot.plugins;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;

import org.processmining.contexts.uitopia.annotations.UIExportPlugin;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginLevel;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.plugins.graphviz.dot.Dot;

/**
 * Exports a Dot object
 * 
 * @author F. Mannhardt
 *
 */
@Plugin(name = ""Export Dot"", returnLabels = {}, returnTypes = {}, level = PluginLevel.Regular, parameterLabels = {
		""Dot"", ""File"" }, userAccessible = true)
@UIExportPlugin(description = ""Export Dot"", extension = ""dot"")
public final class DotExportPlugin {

	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""F. Mannhardt"", email = ""f.mannhardt@tue.nl"")
	@PluginVariant(requiredParameterLabels = { 0, 1 }, variantLabel = ""Export Dot File"")
	public void export(PluginContext context, Dot dot, File file) throws IOException {
		try (BufferedWriter fileWriter = new BufferedWriter(new FileWriter(file))) {
			fileWriter.write(dot.toString());
		}
	}
}"
DotImageExportPlugin.java,graphviz,"package org.processmining.plugins.graphviz.dot.plugins;

import java.awt.Dimension;
import java.io.File;
import java.io.IOException;

import org.processmining.plugins.graphviz.dot.Dot;
import org.processmining.plugins.graphviz.visualisation.DotPanel;
import org.processmining.plugins.graphviz.visualisation.export.Exporter;

public abstract class DotImageExportPlugin {

	protected void export(Dot dot, File file, Exporter exporter) throws IOException {
		DotPanel panel = new DotPanel(dot);
		panel.setSize(new Dimension((int) panel.getSVG().getWidth(), (int) panel.getSVG().getHeight()));
		try {
			exporter.export(panel, file);
		} catch (Exception e) {
			if (e instanceof IOException) {
				throw (IOException) e;
			} else {
				throw new IOException(""Cannot export Dot."", e);
			}
		}
	}

}
"
DotPDFExportPlugin.java,graphviz,"package org.processmining.plugins.graphviz.dot.plugins;

import java.io.File;
import java.io.IOException;

import org.processmining.contexts.uitopia.annotations.UIExportPlugin;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginLevel;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.plugins.graphviz.dot.Dot;
import org.processmining.plugins.graphviz.visualisation.export.ExporterPDF;

/**
 * Exports a Dot object
 * 
 * @author F. Mannhardt
 *
 */
@Plugin(name = ""Export Dot as PDF"", returnLabels = {}, returnTypes = {}, level = PluginLevel.Regular, parameterLabels = {
		""Dot"", ""File"" }, userAccessible = true)
@UIExportPlugin(description = ""Export PDF"", extension = ""pdf"")
public final class DotPDFExportPlugin extends DotImageExportPlugin {

	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""F. Mannhardt"", email = ""f.mannhardt@tue.nl"")
	@PluginVariant(requiredParameterLabels = { 0, 1 }, variantLabel = ""Export Dot as PDF"")
	public void exportAsPDF(PluginContext context, Dot dot, File file) throws IOException {
		export(dot, file, new ExporterPDF());
	}
	
}"
DotPNGExportPlugin.java,graphviz,"package org.processmining.plugins.graphviz.dot.plugins;

import java.io.File;
import java.io.IOException;

import org.processmining.contexts.uitopia.annotations.UIExportPlugin;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginLevel;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.plugins.graphviz.dot.Dot;
import org.processmining.plugins.graphviz.visualisation.export.ExporterPNG;

/**
 * Exports a Dot object
 * 
 * @author F. Mannhardt
 *
 */
@Plugin(name = ""Export Dot as PNG"", returnLabels = {}, returnTypes = {}, level = PluginLevel.Regular, parameterLabels = {
		""Dot"", ""File"" }, userAccessible = true)
@UIExportPlugin(description = ""Export PNG"", extension = ""png"")
public final class DotPNGExportPlugin extends DotImageExportPlugin {

	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""F. Mannhardt"", email = ""f.mannhardt@tue.nl"")
	@PluginVariant(requiredParameterLabels = { 0, 1 }, variantLabel = ""Export Dot as PNG"")
	public void exportAsPNG(PluginContext context, Dot dot, File file) throws IOException {
		export(dot, file, new ExporterPNG());
	}
}"
DotSVGExportPlugin.java,graphviz,"package org.processmining.plugins.graphviz.dot.plugins;

import java.io.File;
import java.io.IOException;

import org.processmining.contexts.uitopia.annotations.UIExportPlugin;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginLevel;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.plugins.graphviz.dot.Dot;
import org.processmining.plugins.graphviz.visualisation.export.ExporterSVG;

/**
 * Exports a Dot object
 * 
 * @author F. Mannhardt
 *
 */
@Plugin(name = ""Export Dot as SVG"", returnLabels = {}, returnTypes = {}, level = PluginLevel.Regular, parameterLabels = {
		""Dot"", ""File"" }, userAccessible = true)
@UIExportPlugin(description = ""Export SVG"", extension = ""svg"")
public final class DotSVGExportPlugin extends DotImageExportPlugin {

	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""F. Mannhardt"", email = ""f.mannhardt@tue.nl"")
	@PluginVariant(requiredParameterLabels = { 0, 1 }, variantLabel = ""Export Dot as SVG"")
	public void exportAsSVG(PluginContext context, Dot dot, File file) throws IOException {
		export(dot, file, new ExporterSVG());
	}
}"
DotPanel.java,graphviz,"package org.processmining.plugins.graphviz.visualisation;

import java.awt.Color;
import java.awt.Point;
import java.awt.event.ActionEvent;
import java.awt.event.InputEvent;
import java.awt.event.KeyEvent;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.geom.Point2D;
import java.io.IOException;
import java.io.InputStream;
import java.net.URI;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Set;
import java.util.concurrent.CopyOnWriteArrayList;

import javax.swing.AbstractAction;
import javax.swing.Action;
import javax.swing.KeyStroke;
import javax.swing.SwingUtilities;

import org.processmining.plugins.graphviz.colourMaps.ColourMap;
import org.processmining.plugins.graphviz.dot.Dot;
import org.processmining.plugins.graphviz.dot.Dot.GraphDirection;
import org.processmining.plugins.graphviz.dot.Dot2Image;
import org.processmining.plugins.graphviz.dot.Dot2Image.Type;
import org.processmining.plugins.graphviz.dot.DotEdge;
import org.processmining.plugins.graphviz.dot.DotElement;
import org.processmining.plugins.graphviz.dot.DotNode;
import org.processmining.plugins.graphviz.visualisation.export.Exporter;
import org.processmining.plugins.graphviz.visualisation.export.ExporterDot;
import org.processmining.plugins.graphviz.visualisation.listeners.DotElementSelectionListener;
import org.processmining.plugins.graphviz.visualisation.listeners.GraphChangedListener;
import org.processmining.plugins.graphviz.visualisation.listeners.GraphChangedListener.GraphChangedReason;
import org.processmining.plugins.graphviz.visualisation.listeners.MouseInElementsChangedListener;
import org.processmining.plugins.graphviz.visualisation.listeners.SelectionChangedListener;

import com.kitfox.svg.Group;
import com.kitfox.svg.RenderableElement;
import com.kitfox.svg.SVGDiagram;
import com.kitfox.svg.SVGElement;
import com.kitfox.svg.SVGElementException;
import com.kitfox.svg.SVGException;
import com.kitfox.svg.SVGUniverse;
import com.kitfox.svg.animation.AnimationElement;
import com.kitfox.svg.xml.StyleAttribute;

public class DotPanel extends NavigableSVGPanel {

	/**
	 * 
	 */
	private static final long serialVersionUID = -6201301504669783161L;

	private Action changeGraphDirection = new AbstractAction() {
		private static final long serialVersionUID = -38576326322179480L;

		public void actionPerformed(ActionEvent e) {
			GraphDirection newDirection;
			switch (dot.getDirection()) {
				case bottomTop :
					newDirection = GraphDirection.leftRight;
					break;
				case leftRight :
					newDirection = GraphDirection.rightLeft;
					break;
				case rightLeft :
					newDirection = GraphDirection.topDown;
					break;
				case topDown :
					newDirection = GraphDirection.bottomTop;
					break;
				default :
					newDirection = GraphDirection.bottomTop;
					break;
			}
			userSettings.setDirection(newDirection);
			changeDot(dot, true);
			graphChanged(GraphChangedReason.graphDirectionChanged, newDirection);
		}
	};

	private Action increaseAspectRatio = new AbstractAction() {
		private static final long serialVersionUID = 2323619233153604381L;

		public void actionPerformed(ActionEvent e) {
			userSettings.nodeSeparation = Math.min(userSettings.nodeSeparation + .05, 4);
			changeDot(dot, true);
			graphChanged(GraphChangedReason.nodeSeparationChanged, userSettings.nodeSeparation);
		}
	};

	private Action decreaseAspectRatio = new AbstractAction() {
		private static final long serialVersionUID = 1136135860512175161L;

		public void actionPerformed(ActionEvent e) {
			userSettings.nodeSeparation = Math.max(userSettings.nodeSeparation - 0.05, 0.02);
			changeDot(dot, true);
			graphChanged(GraphChangedReason.nodeSeparationChanged, userSettings.nodeSeparation);
		}
	};

	private Dot dot;
	private final DotPanelUserSettings userSettings;
	private HashMap<String, DotElement> id2element;
	private Set<DotElement> selectedElements;
	private Set<DotElement> mouseInElements;
	private final CopyOnWriteArrayList<SelectionChangedListener<DotElement>> selectionChangedListeners = new CopyOnWriteArrayList<>();
	private final CopyOnWriteArrayList<MouseInElementsChangedListener<DotElement>> mouseInElementsChangedListeners = new CopyOnWriteArrayList<>();
	private final CopyOnWriteArrayList<GraphChangedListener> graphChangedListeners = new CopyOnWriteArrayList<>();

	public DotPanel(Dot dot) {
		super(dot2svg(dot));
		this.dot = dot;
		prepareNodeSelection(dot);
		mouseInElements = new HashSet<>();
		userSettings = new DotPanelUserSettings(dot);

		//listen to ctrl+d for a change in graph layouting direction
		helperControlsShortcuts.add(""ctrl d"");
		helperControlsExplanations.add(""change graph direction"");
		getInputMap(WHEN_IN_FOCUSED_WINDOW).put(KeyStroke.getKeyStroke(KeyEvent.VK_D, InputEvent.CTRL_MASK),
				""changeGraphDirection"");
		getActionMap().put(""changeGraphDirection"", changeGraphDirection);

		//listen to ctrl+q for increasing aspect ratio
		helperControlsShortcuts.add(""ctrl q"");
		helperControlsExplanations.add(""increase graph node distance"");
		getInputMap(WHEN_IN_FOCUSED_WINDOW).put(KeyStroke.getKeyStroke(KeyEvent.VK_Q, InputEvent.CTRL_MASK),
				""increaseAspectRatio"");
		getActionMap().put(""increaseAspectRatio"", increaseAspectRatio);

		//listen to ctrl+w for decreasing aspect ratio
		helperControlsShortcuts.add(""ctrl w"");
		helperControlsExplanations.add(""decrease graph node distance"");
		getInputMap(WHEN_IN_FOCUSED_WINDOW).put(KeyStroke.getKeyStroke(KeyEvent.VK_W, InputEvent.CTRL_MASK),
				""decreaseAspectRatio"");
		getActionMap().put(""decreaseAspectRatio"", decreaseAspectRatio);

		//add mouse listeners
		final DotPanel this2 = this;
		addMouseListener(new MouseAdapter() {
			public void mousePressed(MouseEvent e) {
				e.setSource(this2);
				for (DotElement element : getElementsAtPoint(e.getPoint())) {
					element.mousePressed(e);
				}
			}
		});
	}

	@Override
	protected boolean processMouseClick(MouseEvent e) {
		boolean superChanged = super.processMouseClick(e);

		//pass clicks to elements and process selection changes, but not if the click was already catched.
		boolean selectionChange = false;
		Point point = e.getPoint();
		if (!superChanged) {
			e.setSource(this);
			for (DotElement element : getElementsAtPoint(point)) {
				element.mouseClicked(e);

				if (SwingUtilities.isLeftMouseButton(e)) {
					selectionChange = selectionChange || processSelection(element, e);
				}
			}

			if (SwingUtilities.isLeftMouseButton(e) && !selectionChange && !e.isControlDown()) {
				//the user did not click on anything clickable. Remove the selection.
				selectionChange = removeSelection();
			}

			if (selectionChange) {
				selectionChanged();
			}
		}

		return superChanged || selectionChange;
	};

	@Override
	protected boolean processMouseRelease(MouseEvent e) {
		boolean superChanged = super.processMouseRelease(e);

		//call mouseReleased on all elements under the mouse
		for (DotElement element : getElementsAtPoint(e.getPoint())) {
			element.mouseReleased(e);
		}

		return superChanged;
	}

	@Override
	protected boolean processMouseDrag(MouseEvent e) {
		boolean changed = super.processMouseDrag(e);

		//if we start dragging, we exit all elements
		changed |= exitAllElements(e);

		return changed;
	}

	@Override
	protected boolean processMouseMove(MouseEvent e) {
		boolean captured = super.processMouseMove(e);

		boolean changed = false;

		if (captured) {
			//something above us captured the mouse hover, so exit all dot elements
			changed = exitAllElements(e);
		} else {
			//process the mouseEnter and Exit of the dot elements
			Set<DotElement> newElements = getElementsAtPoint(e.getPoint());
			//exit
			for (DotElement element : mouseInElements) {
				if (!newElements.contains(element)) {
					element.mouseExited(e);
					changed = true;
				}
			}
			//enter
			for (DotElement element : newElements) {
				if (!mouseInElements.contains(element)) {
					element.mouseEntered(e);
					changed = true;
				}
			}
			mouseInElements = newElements;

			if (changed) {
				mouseInElementsChanged();
			}
		}

		return changed || captured;
	}

	@Override
	protected boolean processMouseExit(MouseEvent e) {
		boolean changed = super.processMouseExit(e);

		//exit the dot elements, as we are leaving the screen
		changed |= exitAllElements(e);

		return changed;
	}

	@Override
	public List<Exporter> getExporters() {
		List<Exporter> exporters = super.getExporters();
		exporters.add(new ExporterDot());
		return exporters;
	}

	/**
	 * Deselect all nodes; return whether the selection changed
	 * 
	 * @return
	 */
	private boolean removeSelection() {
		for (DotElement element : selectedElements) {
			for (DotElementSelectionListener listener : element.getSelectionListeners()) {
				listener.deselected(element, image);
			}
		}
		boolean result = !selectedElements.isEmpty();
		selectedElements.clear();
		return result;
	}

	private boolean processSelection(DotElement element, MouseEvent e) {
		if (element.isSelectable()) {
			if (e.isControlDown()) {
				//only change this element
				if (selectedElements.contains(element)) {
					//deselect element
					selectedElements.remove(element);
					for (DotElementSelectionListener listener : element.getSelectionListeners()) {
						listener.deselected(element, image);
					}
				} else {
					//select element
					selectedElements.add(element);
					for (DotElementSelectionListener listener : element.getSelectionListeners()) {
						listener.selected(element, image);
					}
				}
			} else {
				if (selectedElements.contains(element)) {
					//clicked on selected element without keypress
					if (selectedElements.size() > 1) {
						//deselect all other selected elements
						Iterator<DotElement> it = selectedElements.iterator();
						while (it.hasNext()) {
							DotElement selectedElement = it.next();
							if (selectedElement != element) {
								for (DotElementSelectionListener listener : selectedElement.getSelectionListeners()) {
									listener.deselected(selectedElement, image);
								}
								it.remove();
							}
						}
					} else {
						//only this element was selected, deselect it
						selectedElements.remove(element);
						for (DotElementSelectionListener a : element.getSelectionListeners()) {
							a.deselected(element, image);
						}
					}
				} else {
					//clicked on not selected element without keypress
					//deselect all selected elements
					Iterator<DotElement> it = selectedElements.iterator();
					while (it.hasNext()) {
						DotElement selectedElement = it.next();
						if (selectedElement != element) {
							for (DotElementSelectionListener listener : selectedElement.getSelectionListeners()) {
								listener.deselected(selectedElement, image);
							}
							it.remove();
						}
					}
					//select this element
					selectedElements.add(element);
					for (DotElementSelectionListener listener : element.getSelectionListeners()) {
						listener.selected(element, image);
					}
				}
			}
			return true;
		}
		return false;
	}

	@SuppressWarnings(""unchecked"")
	private Set<DotElement> getElementsAtPoint(Point pointUserCoordinates) {
		HashSet<DotElement> result = new HashSet<DotElement>();
		if (isInImage(pointUserCoordinates)) {
			Point2D pointImageCoordinates = transformUser2Image(pointUserCoordinates);
			try {
				//get the elements at the clicked position
				List<List<RenderableElement>> elements = image.pick(pointImageCoordinates, false, null);

				StyleAttribute classAttribute = new StyleAttribute(""class"");
				StyleAttribute idAttribute = new StyleAttribute(""id"");
				for (List<RenderableElement> path : elements) {
					for (RenderableElement element : path) {
						//RenderableElement element = path.iterator().next();
						if (element instanceof Group) {
							Group group = (Group) element;

							//get the class
							group.getPres(classAttribute);

							//get the id
							group.getPres(idAttribute);
							String id = idAttribute.getStringValue();

							if (classAttribute.getStringValue().equals(""node"")
									|| classAttribute.getStringValue().equals(""edge"")) {
								//we have found a node or edge
								DotElement dotElement = id2element.get(id);
								if (dotElement != null) {
									result.add(dotElement);
								}
							}
						}
					}
				}

			} catch (SVGException e1) {
				e1.printStackTrace();
			}
		}
		return result;
	}

	private boolean exitAllElements(MouseEvent e) {
		for (DotElement element : mouseInElements) {
			element.mouseExited(e);
		}
		boolean changed = !mouseInElements.isEmpty();
		mouseInElements.clear();
		if (changed) {
			mouseInElementsChanged();
		}
		return changed;
	}

	/**
	 * Sets a new image
	 * 
	 * @param dot
	 *            ; set dot to this
	 * @param resetView
	 *            ; whether reset the view to centered+fitting
	 */
	public void changeDot(Dot dot, boolean resetView) {
		userSettings.applyToDot(dot);
		SVGDiagram diagram = dot2svg(dot);
		changeDot(dot, diagram, resetView);
	}

	/**
	 * Sets a new precomputed image. Assumptions are made about the dot & the
	 * diagram, so do not provide arbitrary ones.
	 * 
	 * @param dot
	 *            ; set dot to this
	 * @param diagram
	 *            ; use this SVG image
	 * @param resetView
	 *            ; whether reset the view to centered+fitting
	 */
	public void changeDot(Dot dot, SVGDiagram diagram, boolean resetView) {
		prepareNodeSelection(dot);
		this.dot = dot;
		setImage(diagram, resetView);
	}

	private void prepareNodeSelection(Dot dot) {
		selectedElements = new HashSet<DotElement>();

		id2element = new HashMap<String, DotElement>();
		for (DotNode dotNode : dot.getNodesRecursive()) {
			id2element.put(dotNode.getId(), dotNode);
		}
		for (DotEdge dotEdge : dot.getEdgesRecursive()) {
			id2element.put(dotEdge.getId(), dotEdge);
		}
	}

	/*
	 * convert Dot into svg
	 */
	public static SVGDiagram dot2svg(Dot dot) {
		SVGUniverse universe = new SVGUniverse();

		InputStream stream = Dot2Image.dot2imageInputStream(dot, Type.svg);
		URI uri;
		try {
			uri = universe.loadSVG(stream, ""hoi"");
		} catch (IOException e) {
			return null;
		}

		SVGDiagram diagram = universe.getDiagram(uri);

		if (diagram == null) {
			throw new RuntimeException(""the dot-structure given is not valid\n"" + dot.toString());
		}
		return diagram;
	}

	/*
	 * select a dotElement
	 */
	public void select(DotElement element) {
		selectedElements.add(element);
		for (DotElementSelectionListener listener : element.getSelectionListeners()) {
			listener.selected(element, image);
		}
		selectionChanged();
	}

	/**
	 * 
	 * @param image
	 * @param element
	 * @return the svg element of a DotElement
	 */
	public static Group getSVGElementOf(SVGDiagram image, DotElement element) {
		SVGElement svgElement = image.getElement(element.getId());
		if (svgElement instanceof Group) {
			return (Group) svgElement;
		}
		return null;
	}

	/**
	 * Set a css-property of a DotElement; returns the old value or null.
	 * 
	 * @param image
	 * @param element
	 * @param attribute
	 * @param value
	 * @return
	 */
	public static String setCSSAttributeOf(SVGDiagram image, DotElement element, String attribute, String value) {
		Group group = getSVGElementOf(image, element);
		return setCSSAttributeOf(group, attribute, value);
	}

	public static String getAttributeOf(SVGElement element, String attribute) {
		try {
			if (element.hasAttribute(attribute, AnimationElement.AT_CSS)) {
				StyleAttribute sty = new StyleAttribute(attribute);
				element.getStyle(sty);
				return sty.getStringValue();
			}
			if (element.hasAttribute(attribute, AnimationElement.AT_XML)) {
				StyleAttribute sty = new StyleAttribute(attribute);
				element.getPres(sty);
				return sty.getStringValue();
			}
		} catch (SVGElementException e) {
			e.printStackTrace();
		} catch (SVGException e) {
			e.printStackTrace();
		}
		return null;
	}

	public static String setCSSAttributeOf(SVGElement element, String attribute, Color colour) {
		return setCSSAttributeOf(element, attribute, ColourMap.toHexString(colour));
	}

	/**
	 * Set a css-property of an SVG element; returns the old value or null
	 * providing null as value removes the attribute
	 * 
	 * @param element
	 * @param attribute
	 * @param value
	 * @return
	 */
	public static String setCSSAttributeOf(SVGElement element, String attribute, String value) {
		try {
			if (element.hasAttribute(attribute, AnimationElement.AT_CSS)) {
				StyleAttribute sty = new StyleAttribute(attribute);
				element.getStyle(sty);
				String oldValue = sty.getStringValue();
				if (value != null) {
					element.setAttribute(attribute, AnimationElement.AT_CSS, value);
				} else {
					element.removeAttribute(attribute, AnimationElement.AT_CSS);
				}
				return oldValue;
			} else {
				if (value != null) {
					element.addAttribute(attribute, AnimationElement.AT_CSS, value);
				}
			}
		} catch (SVGElementException e) {
			e.printStackTrace();
		} catch (SVGException e) {
			e.printStackTrace();
		}
		return null;
	}

	public Set<DotElement> getSelectedElements() {
		return Collections.unmodifiableSet(selectedElements);
	}

	public Set<DotElement> getMouseInElements() {
		return Collections.unmodifiableSet(mouseInElements);
	}

	public List<DotEdge> getEdges() {
		return dot.getEdgesRecursive();
	}

	public List<DotNode> getNodes() {
		return dot.getNodesRecursive();
	}

	public SVGDiagram getSVG() {
		return image;
	}

	public Dot getDot() {
		return dot;
	}

	public DotPanelUserSettings getUserSettings() {
		return userSettings;
	}

	//listeners
	private void graphChanged(GraphChangedReason reason, Object newState) {
		for (GraphChangedListener listener : graphChangedListeners) {
			listener.graphChanged(reason, newState);
		}
	}

	private void selectionChanged() {
		for (SelectionChangedListener<DotElement> listener : selectionChangedListeners) {
			listener.selectionChanged(Collections.unmodifiableSet(selectedElements));
		}
	}

	private void mouseInElementsChanged() {
		for (MouseInElementsChangedListener<DotElement> listener : mouseInElementsChangedListeners) {
			listener.mouseInElementsChanged(Collections.unmodifiableSet(mouseInElements));
		}
	}

	public void addSelectionChangedListener(SelectionChangedListener<DotElement> listener) {
		selectionChangedListeners.add(listener);
	}

	public void addGraphChangedListener(GraphChangedListener listener) {
		graphChangedListeners.add(listener);
	}

	public void addMouseInElementsChangedListener(MouseInElementsChangedListener<DotElement> listener) {
		mouseInElementsChangedListeners.add(listener);
	}

	/**
	 * Public method to change the graph direction. No listeners are called;
	 * that's your responsibility.
	 * 
	 * @param topdown
	 */
	public void setDirection(GraphDirection direction) {
		userSettings.setDirection(direction);
		changeDot(dot, true);
	}
}
"
DotPanelUserSettings.java,graphviz,"package org.processmining.plugins.graphviz.visualisation;

import java.util.Locale;

import org.processmining.plugins.graphviz.dot.Dot;
import org.processmining.plugins.graphviz.dot.Dot.GraphDirection;

/**
 * Keeps track of the user state, i.e. key presses.
 * 
 * @author sleemans
 *
 */

public class DotPanelUserSettings {
	public GraphDirection direction;
	public double nodeSeparation;
	
	public DotPanelUserSettings(Dot dot) {
		readFromDot(dot);
	}

	/**
	 * Applies the dot panel user settings to a Dot instance.
	 * 
	 * @param dot
	 */
	public void applyToDot(Dot dot) {
		dot.setDirection(direction);
		dot.setOption(""nodesep"", """" + String.format(Locale.ENGLISH, ""%.2f"", nodeSeparation));
		dot.setOption(""ranksep"", """" + String.format(Locale.ENGLISH, ""%.2f"", nodeSeparation * 2));
	}
	
	public void readFromDot(Dot dot) {
		direction = dot.getDirection();
		String nodeSep = dot.getOption(""nodesep"");
		if (nodeSep != null) {
			nodeSeparation = Double.valueOf(nodeSep);
		} else {
			nodeSeparation = 0.25;
		}
	}
	
	public void setDirection(GraphDirection direction) {
		this.direction = direction;
	}
	
	public String toString() {
		return ""d "" + direction + "", ns "" + nodeSeparation;
	}
}
"
DotVisualisation.java,graphviz,"package org.processmining.plugins.graphviz.visualisation;

import javax.swing.JComponent;

import org.processmining.contexts.uitopia.annotations.Visualizer;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginLevel;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.plugins.graphviz.dot.Dot;

@Plugin(name = ""Dot visualisation"", returnLabels = { ""Dot visualisation"" }, returnTypes = { JComponent.class }, parameterLabels = { ""Dot"" }, userAccessible = true, level = PluginLevel.Regular)
@Visualizer
public class DotVisualisation {

	@PluginVariant(requiredParameterLabels = { 0 })
	public JComponent visualize(PluginContext context, Dot dot) {

		return new DotPanel(dot);
	}
}
"
ExportDialog.java,graphviz,"package org.processmining.plugins.graphviz.visualisation.export;

import java.io.File;
import java.util.Arrays;
import java.util.prefs.Preferences;

import javax.swing.JFileChooser;
import javax.swing.JOptionPane;

import org.processmining.plugins.graphviz.visualisation.NavigableSVGPanel;

public class ExportDialog extends JFileChooser {
	private static final long serialVersionUID = -6928894765212379860L;
	private static final Preferences preferences = Preferences.userRoot().node(""org.processmining.graphviz"");

	@Deprecated
	public ExportDialog(NavigableSVGPanel parent, Exporter... exporters) {
		this(parent, Arrays.asList(exporters));
	}
	
	public ExportDialog(NavigableSVGPanel parent, Iterable<Exporter> exporters) {
		super(preferences.get(""lastUsedFolder"", new File(""."").getAbsolutePath()));
		setAcceptAllFileFilterUsed(false);
		//addChoosableFileFilter(new ExporterPDFfit());
		for (Exporter exporter: exporters) {
			addChoosableFileFilter(exporter);
		}

		try {
			int returnVal = showSaveDialog(parent);
			if (returnVal == JFileChooser.APPROVE_OPTION) {
				Exporter fileFilter = (Exporter) getFileFilter();
				File file = fileFilter.addExtension(getSelectedFile());

				fileFilter.export(parent, file);

				//save the path for later use
				preferences.put(""lastUsedFolder"", file.getParent());
			}
		} catch (Exception e) {
			JOptionPane.showConfirmDialog(this, e.getMessage(), ""Error while saving image"", JOptionPane.OK_OPTION);
		}
	}

	@Override
	public void approveSelection() {
		Exporter fileFilter = (Exporter) getFileFilter();
		File f = fileFilter.addExtension(getSelectedFile());
		if (f.exists() && getDialogType() == SAVE_DIALOG) {
			int result = JOptionPane.showConfirmDialog(this, ""The file already exists, do you want to overwrite it?"",
					""Existing file"", JOptionPane.YES_NO_OPTION);
			switch (result) {
				case JOptionPane.YES_OPTION :
					super.approveSelection();
					return;
				default :
					return;
			}
		}
		super.approveSelection();
	}

}
"
Exporter.java,graphviz,"package org.processmining.plugins.graphviz.visualisation.export;

import java.io.File;

import javax.swing.filechooser.FileFilter;

import org.processmining.plugins.graphviz.visualisation.NavigableSVGPanel;


public abstract class Exporter extends FileFilter {
	protected abstract String getExtension();

	public abstract void export(NavigableSVGPanel panel, File file) throws Exception;

	public String getDescription() {
		return getExtension();
	}
	
	public File addExtension(File file) {
		if (!file.getName().endsWith(""."" + getExtension())) {
			return new File(file + ""."" + getExtension());
		}
		return file;
	}

	@Override
	public boolean accept(final File file) {
		String extension = """";
		int i = file.getName().lastIndexOf('.');
		if (i >= 0) {
			extension = file.getName().substring(i + 1);
		}
		return file.isDirectory() || extension.toLowerCase().equals(getExtension());
	}
}
"
ExporterDot.java,graphviz,"package org.processmining.plugins.graphviz.visualisation.export;

import java.io.File;
import java.io.PrintWriter;

import org.processmining.plugins.graphviz.visualisation.DotPanel;
import org.processmining.plugins.graphviz.visualisation.NavigableSVGPanel;

public class ExporterDot extends Exporter {

	@Override
	public String getDescription() {
		return ""dot (graph structure)"";
	};
	
	protected String getExtension() {
		return ""dot"";
	}

	public void export(NavigableSVGPanel panel, File file) throws Exception {
		if (panel instanceof DotPanel) {
			PrintWriter writer = new PrintWriter(file);
			writer.print(((DotPanel) panel).getDot());
			writer.close();
		}
	}

}"
ExporterEMF.java,graphviz,"package org.processmining.plugins.graphviz.visualisation.export;

import java.awt.Dimension;
import java.io.File;
import java.util.Properties;

import org.freehep.graphics2d.VectorGraphics;
import org.freehep.graphicsio.emf.EMFGraphics2D;
import org.processmining.plugins.graphviz.visualisation.NavigableSVGPanel;

public class ExporterEMF extends Exporter {

	protected String getExtension() {
		return ""emf"";
	}

	public void export(NavigableSVGPanel panel, File file) throws Exception {

		double width = panel.getImage().getViewRect().getWidth();
		double height = panel.getImage().getViewRect().getHeight();

		VectorGraphics g = new EMFGraphics2D(file, new Dimension((int) Math.ceil(width), (int) Math.ceil(height)));
		Properties p = new Properties();
		g.setProperties(p);
		g.startExport();
		panel.print(g);
		g.endExport();
	}

}"
ExporterEPS.java,graphviz,"package org.processmining.plugins.graphviz.visualisation.export;

import java.awt.Dimension;
import java.io.File;
import java.util.Properties;

import org.freehep.graphics2d.VectorGraphics;
import org.freehep.graphicsio.ps.EPSGraphics2D;
import org.processmining.plugins.graphviz.visualisation.NavigableSVGPanel;

public class ExporterEPS extends Exporter {

	protected String getExtension() {
		return ""eps"";
	}

	public void export(NavigableSVGPanel panel, File file) throws Exception {

		double width = panel.getImage().getViewRect().getWidth();
		double height = panel.getImage().getViewRect().getHeight();

		Dimension dimension = new Dimension((int) Math.ceil(width), (int) Math.ceil(height));
		VectorGraphics g = new EPSGraphics2D(file, dimension);
		Properties p = new Properties(EPSGraphics2D.getDefaultProperties());
		p.setProperty(EPSGraphics2D.PAGE_SIZE, EPSGraphics2D.CUSTOM_PAGE_SIZE);
		p.setProperty(EPSGraphics2D.PAGE_MARGINS, ""0, 0, 0, 0"");
		p.put(EPSGraphics2D.CUSTOM_PAGE_SIZE, dimension.width + "", "" + dimension.height);
		g.setProperties(p);
		g.startExport();
		panel.print(g);
		g.endExport();
	}

}"
ExporterPDF.java,graphviz,"package org.processmining.plugins.graphviz.visualisation.export;

import java.awt.Graphics2D;
import java.io.File;
import java.io.FileOutputStream;

import org.processmining.plugins.graphviz.visualisation.NavigableSVGPanel;

import com.itextpdf.awt.PdfGraphics2D;
import com.itextpdf.text.Document;
import com.itextpdf.text.Rectangle;
import com.itextpdf.text.pdf.PdfContentByte;
import com.itextpdf.text.pdf.PdfWriter;

/**
 * Due to bugs in direct pdf export, first export to eps and then convert to
 * pdf.
 * 
 * @author sander
 *
 */

public class ExporterPDF extends Exporter {

	protected String getExtension() {
		return ""pdf"";
	}

	public void export(NavigableSVGPanel panel, File file) throws Exception {
		float width = (float) panel.getImage().getViewRect().getWidth();
		float height = (float) panel.getImage().getViewRect().getHeight();

		Document document = new Document(new Rectangle(width, height), 0, 0, 0, 0);
		PdfWriter writer = PdfWriter.getInstance(document, new FileOutputStream(file));
		document.open();
		PdfContentByte canvas = writer.getDirectContent();
		
		Graphics2D g = new PdfGraphics2D(canvas, width, height);
		panel.print(g);
		g.dispose();
		
		document.close();
	}

}
"
ExporterPNG.java,graphviz,"package org.processmining.plugins.graphviz.visualisation.export;

import java.awt.Graphics2D;
import java.awt.RenderingHints;
import java.awt.image.BufferedImage;
import java.io.File;

import javax.imageio.ImageIO;

import org.processmining.plugins.graphviz.visualisation.NavigableSVGPanel;

public class ExporterPNG extends Exporter {

	protected String getExtension() {
		return ""png"";
	}

	public void export(NavigableSVGPanel panel, File file) throws Exception {
		BufferedImage bi = new BufferedImage(Math.round(panel.getImage().getWidth()), Math.round(panel.getImage().getHeight()),
				BufferedImage.TYPE_INT_ARGB);
		Graphics2D g = bi.createGraphics();
		g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
		panel.print(g);
		ImageIO.write(bi, ""PNG"", file);
	}

}
"
ExporterSVG.java,graphviz,"package org.processmining.plugins.graphviz.visualisation.export;

import java.awt.Dimension;
import java.io.File;
import java.util.Properties;

import org.freehep.graphics2d.VectorGraphics;
import org.freehep.graphicsio.svg.SVGGraphics2D;
import org.processmining.plugins.graphviz.visualisation.NavigableSVGPanel;

public class ExporterSVG extends Exporter {

	protected String getExtension() {
		return ""svg"";
	}

	public void export(NavigableSVGPanel panel, File file) throws Exception {	
		double width = panel.getImage().getViewRect().getWidth();
		double height = panel.getImage().getViewRect().getHeight();
		
		Dimension dimension = new Dimension((int) Math.ceil(width), (int) Math.ceil(height));
		VectorGraphics g = new SVGGraphics2D(file, dimension);
		Properties p = new Properties(SVGGraphics2D.getDefaultProperties());
		g.setProperties(p);
		g.startExport();
		panel.print(g);
		g.endExport();
	}

}
"
DotElementSelectionListener.java,graphviz,"package org.processmining.plugins.graphviz.visualisation.listeners;

import org.processmining.plugins.graphviz.dot.DotElement;

import com.kitfox.svg.SVGDiagram;

public interface DotElementSelectionListener {
	public void selected(DotElement element, SVGDiagram image);
	public void deselected(DotElement element, SVGDiagram image);
}
"
ElementSelectionListener.java,graphviz,"package org.processmining.plugins.graphviz.visualisation.listeners;

@Deprecated
public interface ElementSelectionListener<E> {
	public void selected(E element);
	public void deselected(E element);
}
"
GraphChangedListener.java,graphviz,"package org.processmining.plugins.graphviz.visualisation.listeners;

public interface GraphChangedListener {
	
	public enum GraphChangedReason {
		graphDirectionChanged, nodeSeparationChanged 
	}
	
	public void graphChanged(GraphChangedReason reason, Object newState);
}
"
ImageTransformationChangedListener.java,graphviz,"package org.processmining.plugins.graphviz.visualisation.listeners;

import java.awt.geom.AffineTransform;

public interface ImageTransformationChangedListener {
	public void imageTransformationChanged(AffineTransform image2user, AffineTransform user2image);
}
"
MouseInElementsChangedListener.java,graphviz,"package org.processmining.plugins.graphviz.visualisation.listeners;

import java.util.Set;

public interface MouseInElementsChangedListener<E> {
	/**
	 * Called when the selection changes.
	 * @param selectedElements The new set of selected elements.
	 */
	public void mouseInElementsChanged(Set<E> mouseInElements);
}
"
SelectionChangedListener.java,graphviz,"package org.processmining.plugins.graphviz.visualisation.listeners;

import java.util.Set;

public interface SelectionChangedListener<E> {
	
	/**
	 * Called when the selection changes.
	 * @param selectedElements The new set of selected elements.
	 */
	public void selectionChanged(Set<E> selectedElements);
}
"
NavigableSVGPanel.java,graphviz,"package org.processmining.plugins.graphviz.visualisation;

import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.FontMetrics;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Point;
import java.awt.Polygon;
import java.awt.Rectangle;
import java.awt.RenderingHints;
import java.awt.Stroke;
import java.awt.event.ActionEvent;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.InputEvent;
import java.awt.event.KeyEvent;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.awt.event.MouseMotionListener;
import java.awt.event.MouseWheelEvent;
import java.awt.event.MouseWheelListener;
import java.awt.geom.AffineTransform;
import java.awt.geom.Arc2D;
import java.awt.geom.NoninvertibleTransformException;
import java.awt.geom.Point2D;
import java.awt.print.PageFormat;
import java.awt.print.Printable;
import java.awt.print.PrinterException;
import java.awt.print.PrinterJob;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import javax.swing.AbstractAction;
import javax.swing.Action;
import javax.swing.JComponent;
import javax.swing.JPanel;
import javax.swing.KeyStroke;
import javax.swing.SwingUtilities;

import org.processmining.plugins.graphviz.visualisation.export.ExportDialog;
import org.processmining.plugins.graphviz.visualisation.export.Exporter;
import org.processmining.plugins.graphviz.visualisation.export.ExporterEMF;
import org.processmining.plugins.graphviz.visualisation.export.ExporterEPS;
import org.processmining.plugins.graphviz.visualisation.export.ExporterPDF;
import org.processmining.plugins.graphviz.visualisation.export.ExporterPNG;
import org.processmining.plugins.graphviz.visualisation.export.ExporterSVG;
import org.processmining.plugins.graphviz.visualisation.listeners.ImageTransformationChangedListener;

import com.kitfox.svg.SVGDiagram;
import com.kitfox.svg.SVGException;

/**
 * A JPanel that displays an SVG image. Animation support is present, but not
 * complete, i.e. you'll need a subclass to perform animation. Controls are
 * included to ease implementation of subclasses.
 * 
 * @author sleemans
 *
 */
public class NavigableSVGPanel extends JPanel implements Printable {

	private static final long serialVersionUID = -3285916948952045282L;

	//state variables and constants
	protected SVGDiagram image;
	protected AffineTransform image2user = new AffineTransform();
	private AffineTransform user2image = new AffineTransform();
	private Point lastMousePosition;
	private Dimension lastPanelDimension = null;
	private boolean resetViewLater = false;

	protected boolean isDraggingImage = false;
	private final static double zoomIncrement = 1.8;

	//animation controls
	protected boolean isDraggingAnimation = false;
	protected boolean isDraggingTimeScale = false;
	private boolean wasPlayingBeforeDragging = false;
	protected Rectangle animationControls;
	protected Rectangle controlsPlayPause = new Rectangle();
	protected Rectangle controlsTimeScale = new Rectangle();
	private Rectangle controlsProgressLine = new Rectangle();
	private boolean animationControlsShowing = false;

	//navigation variables and constants
	private double navigationScale = 1.0;
	public final static double navigationImageWidthInPartOfPanel = 0.1;
	public final static Color navigationImageBorderColor = Color.black;
	public final static float dash1[] = { 10.0f };
	public final static BasicStroke navigationImageOutlineStroke = new BasicStroke(1.0f, BasicStroke.CAP_BUTT,
			BasicStroke.JOIN_MITER, 10.0f, dash1, 0.0f);

	//listeners
	private ImageTransformationChangedListener imageTransformationChangedListener = null;

	//helper controls variables and constants
	private Arc2D helperControlsArc = null;
	private boolean helperControlsShowing = false;
	public static final int helperControlsWidth = 350;
	public static final Font helperControlsFont = new Font(Font.MONOSPACED, Font.BOLD, 12);
	private static final Font helperControlsButtonFont = new Font(""TimesRoman"", Font.PLAIN, 20);
	private static final String helperControlsButtonString = ""?"";

	//help-popup
	protected List<String> helperControlsShortcuts = new ArrayList<>(
			Arrays.asList(""up/down"", ""left/right"", ""ctrl ="", ""ctrl -"", ""ctrl 0"", ""ctrl i"", ""ctrl p""));
	protected List<String> helperControlsExplanations = new ArrayList<>(Arrays.asList(""pan up/down"", ""pan left/right"",
			""zoom in"", ""zoom out"", ""reset zoom & pan"", ""save image"", ""print""));

	private Action zoomInAction = new AbstractAction() {
		private static final long serialVersionUID = 3863042569537144601L;

		public void actionPerformed(ActionEvent e) {
			//zoom in on the center of the panel
			try {
				zoomIn(new Point(getWidth() / 2, getHeight() / 2));
			} catch (NoninvertibleTransformException e1) {
				e1.printStackTrace();
			}
			updateTransformation();
			repaint();
		}
	};

	private Action zoomOutAction = new AbstractAction() {
		private static final long serialVersionUID = 7842478506942554961L;

		public void actionPerformed(ActionEvent e) {
			//zoom in of the center of the panel
			try {
				zoomOut(new Point(getWidth() / 2, getHeight() / 2));
			} catch (NoninvertibleTransformException e1) {
				e1.printStackTrace();
			}
			updateTransformation();
			repaint();
		}
	};

	private Action resetViewAction = new AbstractAction() {
		private static final long serialVersionUID = 1114226211978622533L;

		public void actionPerformed(ActionEvent e) {
			//reset the view
			try {
				resetView();
			} catch (NoninvertibleTransformException e1) {
				e1.printStackTrace();
			}
			updateTransformation();
			repaint();
		}
	};

	private Action walkAction = new AbstractAction() {
		private static final long serialVersionUID = 1114226211978622533L;

		public void actionPerformed(ActionEvent e) {
			String command = e.getActionCommand();
			if (command.equals(""DOWN"")) {
				image2user.translate(0, -10);
			} else if (command.equals(""UP"")) {
				image2user.translate(0, 10);
			} else if (command.equals(""LEFT"")) {
				image2user.translate(10, 0);
			} else if (command.equals(""RIGHT"")) {
				image2user.translate(-10, 0);
			}
			try {
				user2image = image2user.createInverse();
			} catch (NoninvertibleTransformException e1) {
				e1.printStackTrace();
			}
			updateTransformation();
			repaint();
		}
	};

	private Action printAction = new AbstractAction() {
		private static final long serialVersionUID = -7112953904402077397L;

		public void actionPerformed(ActionEvent e) {
			PrinterJob job = PrinterJob.getPrinterJob();
			job.setPrintable(NavigableSVGPanel.this);
			boolean ok = job.printDialog();
			if (ok) {
				try {
					job.print();
				} catch (PrinterException ex) {
					/* The job did not successfully complete */
				}
			}
		}
	};

	public NavigableSVGPanel(final SVGDiagram newImage) {
		setOpaque(false);
		setDoubleBuffered(true);
		setFocusable(true);
		setImage(newImage, false);
		setupListeners();
	}

	public void setupListeners() {
		//set up resize listener
		addComponentListener(new ComponentAdapter() {
			public void componentResized(ComponentEvent e) {
				try {
					if (image2user.isIdentity() || resetViewLater) {
						lastPanelDimension = new Dimension(getWidth(), getHeight());
						resetView();
					} else if (lastPanelDimension != null) {
						//on resizing, keep the center in center, and scale proportionally to the width.
						double zoom = lastPanelDimension.getWidth() / getWidth();
						user2image.translate(lastPanelDimension.getWidth() / 2.0, lastPanelDimension.getHeight() / 2.0);
						user2image.scale(zoom, zoom);
						lastPanelDimension = new Dimension(getWidth(), getHeight());
						user2image.translate(-lastPanelDimension.getWidth() / 2.0,
								-lastPanelDimension.getHeight() / 2.0);
						image2user = user2image.createInverse();
					} else {
						lastPanelDimension = new Dimension(getWidth(), getHeight());
					}
				} catch (NoninvertibleTransformException e1) {
					e1.printStackTrace();
				}
				updateTransformation();
				repaint();
			}
		});

		//set up mouse listener
		addMouseListener(new MouseListener() {
			public void mouseReleased(MouseEvent e) {
				processMouseRelease(e);
			}

			public void mousePressed(MouseEvent e) {
				processMousePress(e);
			}

			public void mouseExited(MouseEvent e) {
				processMouseExit(e);
			}

			public void mouseEntered(MouseEvent e) {

			}

			public void mouseClicked(MouseEvent e) {
				if (isFocusable()) {
					requestFocusInWindow();
				}
				processMouseClick(e);
			}
		});

		//set up drag listener
		addMouseMotionListener(new MouseMotionListener() {
			public void mouseDragged(MouseEvent e) {
				processMouseDrag(e);
			}

			public void mouseMoved(MouseEvent e) {
				processMouseMove(e);
			}
		});

		//set up scroll listener
		addMouseWheelListener(new MouseWheelListener() {
			public void mouseWheelMoved(MouseWheelEvent e) {
				Point p = e.getPoint();
				boolean zoomIn = (e.getWheelRotation() < 0);

				if (isInNavigation(p)) {
					//zoom navigation
					if (zoomIn) {
						zoomNavigation(1.2);
					} else {
						zoomNavigation(0.8);
					}
				} else {
					//zoom image
					try {
						if (zoomIn) {
							zoomIn(p);
						} else {
							zoomOut(p);
						}
						updateTransformation();
					} catch (NoninvertibleTransformException ex) {
						ex.printStackTrace();
					}
				}
				repaint();
			}
		});

		//listen to ctrl + to zoom in
		getInputMap(WHEN_IN_FOCUSED_WINDOW).put(KeyStroke.getKeyStroke(KeyEvent.VK_EQUALS, InputEvent.CTRL_MASK),
				""zoomIn""); // + key in English keyboards
		getInputMap(WHEN_IN_FOCUSED_WINDOW).put(KeyStroke.getKeyStroke(KeyEvent.VK_PLUS, InputEvent.CTRL_MASK),
				""zoomIn""); // + key in non-English keyboards
		getInputMap(WHEN_IN_FOCUSED_WINDOW).put(KeyStroke.getKeyStroke(KeyEvent.VK_ADD, InputEvent.CTRL_MASK),
				""zoomIn""); // + key on the numpad
		getActionMap().put(""zoomIn"", zoomInAction);

		//listen to ctrl - to zoom out
		getInputMap(WHEN_IN_FOCUSED_WINDOW).put(KeyStroke.getKeyStroke(KeyEvent.VK_MINUS, InputEvent.CTRL_MASK),
				""zoomOut""); // - key
		getInputMap(WHEN_IN_FOCUSED_WINDOW).put(KeyStroke.getKeyStroke(KeyEvent.VK_SUBTRACT, InputEvent.CTRL_MASK),
				""zoomOut""); // - key on the numpad
		getActionMap().put(""zoomOut"", zoomOutAction);

		//listen to arrow keys to walk around
		registerKeyboardAction(walkAction, ""DOWN"", KeyStroke.getKeyStroke(""DOWN""), JComponent.WHEN_IN_FOCUSED_WINDOW);
		registerKeyboardAction(walkAction, ""UP"", KeyStroke.getKeyStroke(""UP""), JComponent.WHEN_IN_FOCUSED_WINDOW);
		registerKeyboardAction(walkAction, ""LEFT"", KeyStroke.getKeyStroke(""LEFT""), JComponent.WHEN_IN_FOCUSED_WINDOW);
		registerKeyboardAction(walkAction, ""RIGHT"", KeyStroke.getKeyStroke(""RIGHT""), JComponent.WHEN_IN_FOCUSED_WINDOW);

		//listen to ctrl 0 to reset view
		getInputMap(WHEN_IN_FOCUSED_WINDOW).put(KeyStroke.getKeyStroke(KeyEvent.VK_0, InputEvent.CTRL_MASK),
				""viewReset""); // - key
		getActionMap().put(""viewReset"", resetViewAction);

		//listen to ctrl i to save image
		{
			getInputMap(WHEN_IN_FOCUSED_WINDOW).put(KeyStroke.getKeyStroke(KeyEvent.VK_I, InputEvent.CTRL_MASK),
					""saveAs""); // - key
			getActionMap().put(""saveAs"", new AbstractAction() {
				private static final long serialVersionUID = -4780600363000017631L;

				public void actionPerformed(ActionEvent arg0) {
					exportView();
				}
			});
		}

		//listen to ctrl p to print
		getInputMap(WHEN_IN_FOCUSED_WINDOW).put(KeyStroke.getKeyStroke(KeyEvent.VK_P, InputEvent.CTRL_MASK), ""print""); // - key
		getActionMap().put(""print"", printAction);
	}

	/**
	 * Paints the panel and its image at the current zoom level, location, and
	 * interpolation method dependent on the image scale.
	 * </p>
	 * 
	 * @param g
	 *            the <code>Graphics</code> context for painting
	 */
	protected void paintComponent(Graphics g) {
		if (!isPaintingForPrint()) {
			super.paintComponent(g); // Paints the background
		}

		Graphics2D g2 = (Graphics2D) g;

		if (image == null) {
			return;
		}

		//set anti-aliasing if desired
		g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);

		//set clipping mask to save a few cpu/gpu cycles
		if (!isPaintingForPrint()) {
			g2.setClip(0, 0, getWidth(), getHeight());
		} else {
			g2.setClip((int) Math.round(image.getViewRect().getX()), (int) Math.round(image.getViewRect().getY()),
					(int) Math.round(image.getViewRect().getWidth()),
					(int) Math.round(image.getViewRect().getHeight()));
		}

		//draw image
		if (!isPaintingForPrint()) {
			g2.transform(image2user);
		}
		paintImage(g2);
		if (!isPaintingForPrint()) {
			g2.transform(user2image);
		}

		//draw animation
		drawAnimation(g2);

		//Draw navigation image
		if (!isPaintingForPrint() && !isImageCompletelyInPanel()) {
			int width = (int) Math.round(getNavigationWidth());
			int height = (int) Math.round(getNavigationHeight());
			drawSVG(g2, image, 0, 0, width, height);
			g2.drawRect(0, 0, width, height);
			drawNavigationOutline(g2);
		}

		//draw helper controls
		if (!isPaintingForPrint()) {
			drawHelperControls(g2);
		}

		//draw animation controls
		if (!isPaintingForPrint()) {
			drawAnimationControls((Graphics2D) g);
		}
	}

	protected void paintImage(Graphics2D g) {
		try {
			image.render(g);
		} catch (SVGException e) {
			e.printStackTrace();
		}
	}

	/**
	 * Draw an svg image at the given coordinates and of the given size.
	 * 
	 * @param g
	 * @param image
	 * @param x
	 * @param y
	 * @param width
	 * @param height
	 */
	public static void drawSVG(Graphics2D g, SVGDiagram image, int x, int y, int width, int height) {

		double scaleX = width / image.getWidth();
		double scaleY = height / image.getHeight();

		g.translate(x, y);
		g.scale(scaleX, scaleY);

		try {
			image.render(g);
		} catch (SVGException e) {
			e.printStackTrace();
		}

		g.scale(1 / scaleX, 1 / scaleY);
		g.translate(-x, -y);
	}

	/**
	 * Draw the animation.
	 * 
	 * @param g
	 */
	protected void drawAnimation(Graphics2D g) {

	}

	/**
	 * Paints an outline over the navigation to denote what part of the main
	 * image is displayed.
	 * 
	 * @param g
	 * @param t
	 */
	private void drawNavigationOutline(Graphics2D g) {

		//get edges of panel in image coordinates
		Point2D.Double nw = new Point.Double(0, 0);
		user2image.transform(nw, nw);
		Point2D.Double se = new Point.Double(getWidth(), getHeight());
		user2image.transform(se, se);

		//transform to navigation coordinates
		Point2D nwNav = transformImageToNavigation(nw);
		Point2D seNav = transformImageToNavigation(se);

		int x = (int) Math.round(nwNav.getX());
		int y = (int) Math.round(nwNav.getY());
		int width = (int) Math.round(seNav.getX() - nwNav.getX());
		int height = (int) Math.round(seNav.getY() - nwNav.getY());

		if (x + width > getNavigationWidth()) {
			width = (int) Math.round(getNavigationWidth() - x);
		}
		if (y + height > getNavigationHeight()) {
			height = (int) Math.round(getNavigationHeight() - y);
		}
		Stroke backupStroke = g.getStroke();
		g.setColor(navigationImageBorderColor);
		g.setStroke(navigationImageOutlineStroke);
		g.drawRect(x, y, width, height);
		g.setStroke(backupStroke);

	}

	/**
	 * Draws the little help-question-mark in the right bottom corner and the
	 * help text that appears when hovering over it.
	 * 
	 * @param g
	 */
	private void drawHelperControls(Graphics g) {
		Color backupColour = g.getColor();
		Font backupFont = g.getFont();

		FontMetrics fm = getFontMetrics(helperControlsButtonFont);
		int width = fm.stringWidth(helperControlsButtonString);

		//draw the background arc
		if (helperControlsShowing) {
			g.setColor(new Color(0, 0, 0, 180));
		} else {
			g.setColor(new Color(0, 0, 0, 20));
		}
		helperControlsArc = new Arc2D.Float(Arc2D.PIE);
		helperControlsArc.setFrame(getWidth() - 25, getHeight() - 25, 50, 50);
		helperControlsArc.setAngleStart(90);
		helperControlsArc.setAngleExtent(90);
		g.fillArc(getWidth() - 25, getHeight() - 25, 50, 50, 90, 90);

		//draw the helper panel
		if (helperControlsShowing) {
			int x = getWidth() - (25 + helperControlsWidth);
			int y = getHeight() - (helperControlsShortcuts.size() * 20 - 10);

			//background
			g.setColor(new Color(0, 0, 0, 180));
			g.fillRoundRect(x - 15, y - 20, helperControlsWidth, helperControlsShortcuts.size() * 20 + 20, 10, 10);

			//text
			g.setColor(new Color(255, 255, 255, 220));
			g.setFont(helperControlsFont);
			for (int i = 0; i < helperControlsShortcuts.size(); i++) {
				g.drawString(String.format(""%-12s"", helperControlsShortcuts.get(i)) + "" ""
						+ helperControlsExplanations.get(i), x, y);
				y += 20;
			}
		}

		//draw the question mark
		if (helperControlsShowing) {
			g.setColor(new Color(255, 255, 255, 128));
		} else {
			g.setColor(new Color(0, 0, 0, 128));
		}
		g.setFont(helperControlsButtonFont);
		g.drawString(helperControlsButtonString, getWidth() - width - 3, getHeight() - 3);

		//revert colour and font
		g.setColor(backupColour);
		g.setFont(backupFont);
	}

	private void drawAnimationControls(Graphics2D g) {
		Color backupColour = g.getColor();

		int alpha = 20;
		if (!isAnimationEnabled()) {
			alpha = 0;
		} else if (animationControlsShowing) {
			alpha = 180;
		}

		g.setColor(new Color(0, 0, 0, alpha));
		int width = getWidth() - 100;
		int height = 50;
		int x = (getWidth() - width) / 2;
		int y = getHeight() - 2 * height;
		g.fillRoundRect(x, y, width, height, 10, 10);
		animationControls = new Rectangle(x, y, width, height);

		//play button
		g.setColor(new Color(255, 255, 255, alpha));
		controlsPlayPause.setBounds(x + 10, y + 10, 30, height);
		if (!isAnimationPlaying()) {
			//play button
			Polygon triangle = new Polygon();
			triangle.addPoint(x + 10, y + 10);
			triangle.addPoint(x + 10, y + height - 10);
			triangle.addPoint(x + 10 + 25, y + (height / 2));
			g.fillPolygon(triangle);
		} else {
			//pause button
			g.fillRoundRect(x + 10, y + 10, 10, height - 20, 5, 5);
			g.fillRoundRect(x + 25, y + 10, 10, height - 20, 5, 5);
		}

		//time scale control
		{
			int rightX = x + 50 + 30;
			int leftX = x + 50;
			int topY = y + (height / 3);
			int bottomY = y + (height / 3) * 2;

			if (animationControlsShowing) {
				//dynamic part
				{
					int x2 = (int) (leftX + getTimeScale() * (rightX - leftX));
					int y2 = (int) (bottomY + getTimeScale() * (topY - bottomY));

					//line
					g.drawLine(x2, bottomY + 5, x2, y2 - 5);

					//fill
					Polygon triangle = new Polygon();
					triangle.addPoint(x2, y2);
					triangle.addPoint(leftX, bottomY);
					triangle.addPoint(x2, bottomY);
					g.fillPolygon(triangle);
				}

				//outline
				{
					Polygon triangle = new Polygon();
					triangle.addPoint(rightX, topY);
					triangle.addPoint(leftX, bottomY);
					triangle.addPoint(rightX, bottomY);
					g.drawPolygon(triangle);
				}
			}

			controlsTimeScale.setBounds(leftX, y + 5, rightX - leftX, height - 10);
		}

		//progress line
		{
			int startLineX = x + 100;
			int endLineX = x + width - 20;
			int lineY = y + height / 2;

			if (animationControlsShowing) {
				g.drawLine(startLineX, lineY, endLineX, lineY);
				double progress = (getAnimationTime() - getAnimationMinimumTime())
						/ (getAnimationMaximumTime() - getAnimationMinimumTime());

				//draw the little oval that denotes where we are
				double ovalX = (startLineX + (endLineX - startLineX) * progress) - 5;
				double ovalY = lineY - 5;
				g.translate(ovalX, ovalY);
				g.fillOval(0, 0, 10, 10);
				g.translate(-ovalX, -ovalY);
			}

			getControlsProgressLine().setBounds(startLineX, y, endLineX - startLineX, height);
		}

		g.setColor(backupColour);
	}

	/**
	 * 
	 * @return The width of the navigation part in user coordinates.
	 */
	private double getNavigationWidth() {
		return getWidth() * navigationImageWidthInPartOfPanel * navigationScale;
	}

	/**
	 * 
	 * @return The height of the navigation part in user coordinates.
	 */
	private double getNavigationHeight() {
		return (getNavigationWidth() / image.getWidth()) * image.getHeight();
	}

	/**
	 * Transforms the given point in navigation coordinates to image coordinates
	 * 
	 * @param p
	 * @return
	 */
	public Point2D transformNavigationToImage(Point2D p) {
		double x = p.getX() * image.getWidth() / getNavigationWidth();
		double y = p.getY() * image.getHeight() / getNavigationHeight();

		return new Point2D.Double(x, y);
	}

	/**
	 * Transforms the given point in image coordinates to navigation coordinates
	 * 
	 * @param p
	 * @return
	 */
	public Point2D transformImageToNavigation(Point2D p) {
		double x = p.getX() * getNavigationWidth() / image.getWidth();
		double y = p.getY() * getNavigationHeight() / image.getHeight();

		return new Point2D.Double(x, y);
	}

	/**
	 * Returns whether a point (in user coordinates) is in the image and not in
	 * the navigation image.
	 * 
	 * @param pointInUserCoordinates
	 * @return
	 */
	public boolean isInImage(Point pointInUserCoordinates) {
		if (isInNavigation(pointInUserCoordinates)) {
			return false;
		}
		return getImageBoundingBoxInUserCoordinates().contains(pointInUserCoordinates);
	}

	/**
	 * Returns whether a point (in user coordinates) is in the navigation image.
	 * 
	 * @param pointInUserCoordinates
	 * @return
	 */
	public boolean isInNavigation(Point pointInUserCoordinates) {
		return (pointInUserCoordinates.x < getNavigationWidth() && pointInUserCoordinates.y < getNavigationHeight());
	}

	public boolean isInHelperControls(Point pointInUserCoordinates) {
		return helperControlsArc != null && helperControlsArc.contains(pointInUserCoordinates);
	}

	/**
	 * 
	 * @return The currently registered shortcuts, which are displayed when
	 *         hovering over the question mark in the lower right corner.
	 */
	public List<String> getHelperControlsShortcuts() {
		return helperControlsShortcuts;
	}

	/**
	 * Sets the shortcuts, displayed when hovering over the question mark in the
	 * lower right corner.
	 * 
	 * @param helperControlsShortcuts
	 */
	public void setHelperControlsShortcuts(List<String> helperControlsShortcuts) {
		this.helperControlsShortcuts = helperControlsShortcuts;
	}

	/**
	 * @return The currently registered shortcut explanations, which are
	 *         displayed when hovering over the question mark in the lower right
	 *         corner.
	 */
	public List<String> getHelperControlsExplanations() {
		return helperControlsExplanations;
	}

	/**
	 * Sets the shortcut explanations, displayed when hovering over the question
	 * mark in the lower right corner.
	 * 
	 * @param helperControlsExplanations
	 */
	public void setHelperControlsExplanations(List<String> helperControlsExplanations) {
		this.helperControlsExplanations = helperControlsExplanations;
	}

	/**
	 * 
	 * @return The currently displaying svg image.
	 */
	public SVGDiagram getImage() {
		return image;
	}

	/**
	 * 
	 * @return The bounding box of the image in user coordinates, truncated
	 *         (approximately) to the visible area.
	 */
	public Rectangle getVisibleImageBoundingBoxInUserCoordinates() {
		//transform point (0,0) to user coordinates
		Point2D.Double nw = new Point.Double(0, 0);
		user2image.transform(nw, nw);
		double x1 = Math.min(Math.max(0, nw.getX()), getWidth());
		double y1 = Math.min(Math.max(0, nw.getY()), getHeight());

		//transform the other corner to user coordinates
		Point2D se = new Point2D.Double(image.getWidth(), image.getHeight());
		user2image.transform(se, se);
		double x2 = Math.min((Math.max(0, se.getX())), getWidth());
		double y2 = Math.min((Math.max(0, se.getY())), getHeight());

		return new Rectangle((int) Math.min(x1, x2), (int) Math.min(y1, y2), (int) Math.abs(x2 - x1),
				(int) Math.abs(y2 - y1));
	}

	/**
	 * 
	 * @return the bounding box of the complete image in user coordinates
	 */
	public Rectangle getImageBoundingBoxInUserCoordinates() {
		//transform point (0,0) to user coordinates
		Point2D.Double nw = new Point.Double(0, 0);
		image2user.transform(nw, nw);
		double x1 = nw.getX();
		double y1 = nw.getY();

		//transform the other corner to user coordinates
		Point2D se = new Point2D.Double(image.getWidth(), image.getHeight());
		image2user.transform(se, se);
		double x2 = se.getX();
		double y2 = se.getY();

		return new Rectangle((int) Math.min(x1, x2), (int) Math.min(y1, y2), (int) Math.abs(x2 - x1),
				(int) Math.abs(y2 - y1));
	}

	/**
	 * Returns whether the image is completely visible in the panel
	 * 
	 * @param panState
	 * @param diagram
	 * @param panel
	 * @return
	 */
	public boolean isImageCompletelyInPanel() {
		//check the northwest corner
		Point2D.Double nw = new Point.Double(0, 0);
		image2user.transform(nw, nw);
		if (nw.getX() < 0 || nw.getY() < 0) {
			return false;
		}

		//check the southeast corner
		Point2D.Double se = new Point2D.Double(image.getWidth(), image.getHeight());
		image2user.transform(se, se);
		if (se.getX() > getWidth() || se.getY() > getHeight()) {
			return false;
		}

		return true;
	}

	/**
	 * <p>
	 * Sets an image for display in the panel.
	 * </p>
	 * 
	 * @param image
	 *            an image to be set in the panel
	 */
	public void setImage(SVGDiagram image, boolean resetView) {
		if (image == null) {
			System.out.println(""invalid dot given"");
			throw new NullPointerException(""invalid dot given"");
		}
		this.image = image;
		image.setDeviceViewport(new java.awt.Rectangle(0, 0, (int) image.getWidth(), (int) image.getHeight()));

		if (resetView) {
			try {
				resetView();
			} catch (NoninvertibleTransformException e) {
				e.printStackTrace();
			}
			updateTransformation();
		}

		repaint();
	}

	/**
	 * Scale and center the image just in the viewport.
	 * 
	 * @throws NoninvertibleTransformException
	 */
	public void resetView() throws NoninvertibleTransformException {
		if (getWidth() <= 0 || getHeight() <= 0) {
			resetViewLater = true;
			return;
		}
		resetViewLater = false;

		double scaleX = getWidth() / (double) image.getWidth();
		double scaleY = getHeight() / (double) image.getHeight();
		double scale = Math.min(scaleX, scaleY);

		double width = scale * image.getWidth();
		double height = scale * image.getHeight();

		double x = (getWidth() - width) / 2.0;
		double y = (getHeight() - height) / 2.0;

		image2user.setToIdentity();
		image2user.translate(x, y);
		image2user.scale(scale, scale);
		user2image = image2user.createInverse();

		//reset navigation image
		navigationScale = 1.0;
	}

	/**
	 * The user clicked within the navigation image and this part of the image
	 * is displayed in the panel. The clicked point of the image is centered in
	 * the panel.
	 * 
	 * @param pointInNavigationCoordinates
	 * @throws NoninvertibleTransformException
	 */
	public void centerImageAround(Point pointInNavigationCoordinates) throws NoninvertibleTransformException {
		//transform to image coordinates
		Point2D pImage = transformNavigationToImage(pointInNavigationCoordinates);

		//transform to user coordinates
		image2user.transform(pImage, pImage);

		//compute difference
		double dx = (getWidth() / 2.0 - pImage.getX()) / image2user.getScaleX();
		double dy = (getHeight() / 2.0 - pImage.getY()) / image2user.getScaleY();

		//and translate
		image2user.translate(dx, dy);
		user2image = image2user.createInverse();
	}

	/**
	 * Zoom in keeping the given point at its place
	 * 
	 * @param aroundInUserCoordinates
	 * @throws NoninvertibleTransformException
	 */
	private void zoomIn(Point2D aroundInUserCoordinates) throws NoninvertibleTransformException {
		user2image.translate(aroundInUserCoordinates.getX(), aroundInUserCoordinates.getY());
		user2image.scale(1 / zoomIncrement, 1 / zoomIncrement);
		user2image.translate(-aroundInUserCoordinates.getX(), -aroundInUserCoordinates.getY());
		image2user = user2image.createInverse();
	}

	/**
	 * Zoom out keeping the given point at its place
	 * 
	 * @param aroundInUserCoordinates
	 * @throws NoninvertibleTransformException
	 */
	private void zoomOut(Point2D aroundInUserCoordinates) throws NoninvertibleTransformException {
		user2image.translate(aroundInUserCoordinates.getX(), aroundInUserCoordinates.getY());
		user2image.scale(zoomIncrement, zoomIncrement);
		user2image.translate(-aroundInUserCoordinates.getX(), -aroundInUserCoordinates.getY());
		image2user = user2image.createInverse();
	}

	/**
	 * Process a mouse press.
	 * 
	 * @param e
	 * @return whether the press was handled and did something.
	 */
	protected boolean processMousePress(MouseEvent e) {
		Point point = e.getPoint();
		lastMousePosition = point;

		//process press in helper text
		if (SwingUtilities.isLeftMouseButton(e) && isInHelperControls(point)) {
			return true;
		}

		//process press in animation controls
		if (SwingUtilities.isLeftMouseButton(e) && isAnimationEnabled() && animationControls != null
				&& animationControls.contains(point)) {
			if (getControlsProgressLine().contains(point)) {
				//clicked in progress line area
				wasPlayingBeforeDragging = isAnimationPlaying();
			} else if (controlsPlayPause.contains(point)) {
				//clicked on play/pause button
				pauseResume();

				//repaint to make sure the button is changed
				repaint();
			} else if (controlsTimeScale.contains(point)) {
				//clicked in time scale
			}
			return true;
		}

		//process press in navigation
		if (SwingUtilities.isLeftMouseButton(e) && isInNavigation(point)) {
			//pressed in navigation
			try {
				centerImageAround(point);
			} catch (NoninvertibleTransformException e1) {
				e1.printStackTrace();
			}
			updateTransformation();
			repaint();
			return true;
		}

		//process press anywhere else (=> on the image)
		if (SwingUtilities.isLeftMouseButton(e)) {
			return true;
		}

		return false;
	}

	/**
	 * Process a mouse release
	 * 
	 * @param e
	 * @return whether the hover was handled and did something.
	 */
	protected boolean processMouseRelease(MouseEvent e) {
		if (isDraggingAnimation) {
			double progress = Math.max(0,
					Math.min(1, (e.getX() - getControlsProgressLine().x) / (getControlsProgressLine().width * 1.0)));
			seek(getAnimationMinimumTime() + progress * (getAnimationMaximumTime() - getAnimationMinimumTime()));
			if (wasPlayingBeforeDragging) {
				resume();
			} else {
				renderOneFrame();
				repaint();
			}
		}

		if (isDraggingImage) {
			renderOneFrame();
		}

		isDraggingImage = false;
		isDraggingAnimation = false;
		isDraggingTimeScale = false;

		return processMouseMove(e);
	}

	/**
	 * Process a mouse drag;
	 * 
	 * @param e
	 * @return whether the drag was handled and did something.
	 */
	protected boolean processMouseDrag(MouseEvent e) {
		if (!isDraggingImage && !isDraggingAnimation && !isDraggingTimeScale) {
			if (SwingUtilities.isLeftMouseButton(e) && isAnimationEnabled() && animationControls != null
					&& animationControls.contains(lastMousePosition)
					&& getControlsProgressLine().contains(lastMousePosition)) {
				isDraggingAnimation = true;
			} else if (SwingUtilities.isLeftMouseButton(e) && isAnimationEnabled() && animationControls != null
					&& animationControls.contains(lastMousePosition) && controlsTimeScale.contains(lastMousePosition)) {
				isDraggingTimeScale = true;
			} else if (SwingUtilities.isLeftMouseButton(e) && contains(e.getPoint())
					&& !animationControls.contains(lastMousePosition)) {
				isDraggingImage = true;
			}
		}

		if (isDraggingImage) {
			Point point = e.getPoint();
			if (lastMousePosition != null) {
				double dx = (point.x - lastMousePosition.x) / image2user.getScaleX();
				double dy = (point.y - lastMousePosition.y) / image2user.getScaleY();

				//pan with the difference in user coordinates between the last known mouse position and this one
				image2user.translate(dx, dy);
				try {
					user2image = image2user.createInverse();
				} catch (NoninvertibleTransformException e1) {
					e1.printStackTrace();
				}
			}
			lastMousePosition = point;
			updateTransformation();
			repaint();
			return true;
		} else if (isDraggingAnimation) {
			pause();

			double progress = Math.min(1,
					Math.max(0, (e.getX() - getControlsProgressLine().x) / (getControlsProgressLine().width * 1.0)));
			seek(getAnimationMinimumTime() + progress * (getAnimationMaximumTime() - getAnimationMinimumTime()));
			renderOneFrame();
			lastMousePosition = e.getPoint();
			return true;
		} else if (isDraggingTimeScale) {
			double progress = Math.min(1,
					Math.max(0, (e.getX() - controlsTimeScale.x) / (controlsTimeScale.width * 1.0)));
			setTimeScale(progress);
			lastMousePosition = e.getPoint();
			repaint();
			return true;
		}

		return false;
	}

	/**
	 * Process a mouse move. Captured = true implies that the hover was already
	 * processed (and we should hide everything related to hovering).
	 * 
	 * @param e
	 * @return whether the move is hovering something.
	 */
	protected boolean processMouseMove(MouseEvent e) {
		lastMousePosition = e.getPoint();
		if (!isDraggingImage && helperControlsArc != null && !helperControlsShowing
				&& isInHelperControls(e.getPoint())) {
			//we have to show the helper controls
			helperControlsShowing = true;
			animationControlsShowing = false;
			repaint();
			return true;
		} else if (!isDraggingImage && animationControls != null && !animationControlsShowing
				&& isInAnimationControls(e.getPoint())) {
			//we have to show the animation controls
			animationControlsShowing = true;
			helperControlsShowing = false;
			repaint();
			return true;
		} else {
			//hide things
			if (animationControlsShowing && !isInAnimationControls(e.getPoint())) {
				animationControlsShowing = false;
				repaint();
			}
			if (helperControlsShowing && !isInHelperControls(e.getPoint())) {
				helperControlsShowing = false;
				repaint();
			}
			return helperControlsShowing || animationControlsShowing || isInNavigation(e.getPoint());
		}
	}

	/**
	 * Process a mouse click
	 * 
	 * @param e
	 * @return whether the click was handled and did something.
	 */
	protected boolean processMouseClick(MouseEvent e) {
		if (SwingUtilities.isLeftMouseButton(e) && isAnimationEnabled() && animationControls != null
				&& animationControls.contains(lastMousePosition)
				&& getControlsProgressLine().contains(lastMousePosition)) {
			double progress = Math.max(0,
					Math.min(1, (e.getX() - getControlsProgressLine().x) / (getControlsProgressLine().width * 1.0)));
			seek(getAnimationMinimumTime() + progress * (getAnimationMaximumTime() - getAnimationMinimumTime()));
			if (wasPlayingBeforeDragging) {
				resume();
			} else {
				renderOneFrame();
				repaint();
			}
		}

		if (controlsTimeScale.contains(e.getPoint())) {
			double progress = Math.min(1,
					Math.max(0, (e.getX() - controlsTimeScale.x) / (controlsTimeScale.width * 1.0)));
			setTimeScale(progress);
			repaint();
		}

		return isInHelperControls(e.getPoint()) || isInAnimationControls(e.getPoint()) || isInNavigation(e.getPoint());
	}

	/**
	 * Process a mouse exit
	 * 
	 * @param e
	 * @return whether the exit was handled and did something.
	 */
	protected boolean processMouseExit(MouseEvent e) {
		if (helperControlsShowing) {
			helperControlsShowing = false;
			repaint();
		}
		if (animationControlsShowing) {
			animationControlsShowing = false;
			repaint();
		}
		if (isDraggingAnimation) {
			isDraggingAnimation = false;
			if (wasPlayingBeforeDragging) {
				resume();
			} else {
				renderOneFrame();
				repaint();
			}
		}
		if (isDraggingImage) {
			isDraggingImage = false;
		}
		if (isDraggingTimeScale) {
			isDraggingTimeScale = false;
		}
		return false;
	}

	/**
	 * Zoom the navigation
	 * 
	 * @param zoomFactor
	 */
	private void zoomNavigation(double zoomFactor) {
		navigationScale *= zoomFactor;
	}

	public void setImageTransformationChangedListener(ImageTransformationChangedListener listener) {
		this.imageTransformationChangedListener = listener;
	}

	private void updateTransformation() {
		if (imageTransformationChangedListener != null) {
			imageTransformationChangedListener.imageTransformationChanged(image2user, user2image);
		}
	}

	public Point2D transformUser2Image(Point2D p) {
		return user2image.transform(p, null);
	}

	public Point2D transformImage2User(Point2D p) {
		return image2user.transform(p, null);
	}

	/**
	 * Needs to be overridden by a subclass.
	 * 
	 * @return whether the animation is rendered and controls are displayed.
	 */
	public boolean isAnimationEnabled() {
		return false;
	}

	/**
	 * Needs to be overridden by a subclass.
	 * 
	 * @return whether the animation is currently playing (not paused)
	 */
	public boolean isAnimationPlaying() {
		return false;
	}

	/**
	 * Needs to be overridden by a subclass.
	 * 
	 * @return the time scale set, which is a 0 <= number <= 1.
	 */
	public double getTimeScale() {
		return 0.5;
	}

	/**
	 * Request the time scale to be set. Needs to be overridden by a subclass.
	 * 
	 * @param time
	 */
	public void setTimeScale(double time) {

	}

	/**
	 * Needs to be overridden by a subclass.
	 * 
	 * @return the current animation time.
	 */
	public double getAnimationTime() {
		return 0;
	}

	/**
	 * Needs to be overridden by a subclass.
	 * 
	 * @return the minimum animation time.
	 */
	public double getAnimationMinimumTime() {
		return 0;
	}

	/**
	 * Needs to be overridden by a subclass.
	 * 
	 * @return the maximum animation time.
	 */
	public double getAnimationMaximumTime() {
		return 0;
	}

	/**
	 * 
	 * @param p
	 * @return whether a point lies in the animation controls.
	 */
	protected boolean isInAnimationControls(Point p) {
		return isAnimationEnabled() && animationControls != null && animationControls.contains(p);
	}

	/**
	 * Request the next animation frame to be rendered at the given time. Needs
	 * to be overridden by a subclass.
	 * 
	 * @param time
	 */
	public void seek(double time) {

	}

	/**
	 * Request the animation to pause. Needs to be overridden by a subclass.
	 */
	public void pause() {

	}

	/**
	 * Resume the animation from pausing. Needs to be overridden by a subclass.
	 */
	public void resume() {

	}

	/**
	 * Request the animation to pause or resume. Needs to be overridden by a
	 * subclass.
	 * 
	 */
	public void pauseResume() {

	}

	/**
	 * Request one frame of the animation to be rendered. Needs to be overridden
	 * by a subclass.
	 * 
	 */
	public void renderOneFrame() {

	}

	public Rectangle getControlsProgressLine() {
		return controlsProgressLine;
	}

	public boolean isAnimationControlsShowing() {
		return animationControlsShowing;
	}

	/**
	 * 
	 * @return The list of exporters. Subclasses can override this to a relevant
	 *         list. Called everytime the user attempts to export the image.
	 */
	public List<Exporter> getExporters() {
		List<Exporter> exporters = new ArrayList<>();
		exporters.add(new ExporterPDF());
		exporters.add(new ExporterPNG());
		exporters.add(new ExporterSVG());
		exporters.add(new ExporterEPS());
		exporters.add(new ExporterEMF());
		return exporters;
	}

	/**
	 * Prompts the user for a file name and saves the view under that file name.
	 */
	public void exportView() {
		new ExportDialog(this, getExporters());
	}

	public int print(Graphics g, PageFormat pageFormat, int page) throws PrinterException {
		if (page > 0) {
			return NO_SUCH_PAGE;
		}

		Graphics2D g2d = (Graphics2D) g;

		double scaleX = pageFormat.getImageableWidth() / image.getWidth();
		double scaleY = pageFormat.getImageableHeight() / image.getHeight();

		if (scaleX < scaleY) {
			g2d.translate(pageFormat.getImageableWidth() / 2, pageFormat.getImageableHeight() / 2);
			g2d.rotate(Math.toRadians(-90));
			g2d.translate(pageFormat.getImageableHeight() / -2, pageFormat.getImageableWidth() / -2);
			g2d.translate(-pageFormat.getImageableX(), pageFormat.getImageableY());

			double scale = pageFormat.getImageableHeight() / image.getWidth();
			g2d.scale(scale, scale);
		} else {
			g2d.translate(pageFormat.getImageableX(), pageFormat.getImageableY());
			g2d.scale(scaleY, scaleY);
		}

		// Now we perform our rendering
		print(g2d);

		// tell the caller that this page is part
		// of the printed document
		return PAGE_EXISTS;
	}
}
"
AbstractLogModelConnection.java,log,"package org.processmining.models.connections;

import java.lang.ref.WeakReference;
import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import java.util.WeakHashMap;

import org.deckfour.xes.classification.XEventClass;
import org.deckfour.xes.classification.XEventClasses;
import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.model.XLog;
import org.processmining.framework.connections.impl.AbstractStrongReferencingConnection;
import org.processmining.framework.util.Pair;
import org.processmining.models.graphbased.directed.DirectedGraph;
import org.processmining.models.graphbased.directed.DirectedGraphEdge;
import org.processmining.models.graphbased.directed.DirectedGraphNode;

public abstract class AbstractLogModelConnection<N extends DirectedGraphNode, E extends DirectedGraphEdge<? extends N, ? extends N>>
		extends AbstractStrongReferencingConnection {

	public final static String LOG = ""Log"";
	public final static String MODEL = ""Model"";
	public final static String CLASSES = ""XEventClasses"";
	protected final Map<N, Set<XEventClass>> node2activity = new WeakHashMap<N, Set<XEventClass>>();
	private int minNodePerActivity = Integer.MAX_VALUE;
	private int maxNodePerActivity = Integer.MIN_VALUE;
	private int minActivityPerNode = Integer.MAX_VALUE;
	private int maxActivityPerNode = Integer.MIN_VALUE;
	private final Collection<WeakReference<N>> mappableNodes;
	
	private AbstractLogModelConnection(XLog log, XEventClasses classes, DirectedGraph<N, E> graph,
			Collection<? extends N> mappableNodes) {
		super(graph.getLabel() + "" generated from "" + XConceptExtension.instance().extractName(log));
		this.mappableNodes = new HashSet<WeakReference<N>>();
		for (N n : mappableNodes) {
			this.mappableNodes.add(new WeakReference<N>(n));
		}
		put(LOG, log);
		put(MODEL, graph);
		putStrong(CLASSES, classes);
	}

	protected AbstractLogModelConnection(XLog log, XEventClasses classes, DirectedGraph<N, E> graph,
			Collection<? extends N> mappableNodes,
			Collection<? extends Pair<? extends N, ? extends XEventClass>> relations) {
		this(log, classes, graph, mappableNodes);
		for (Pair<? extends N, ? extends XEventClass> pair : relations) {
			if (!node2activity.containsKey(pair.getFirst())) {
				node2activity.put(pair.getFirst(), new HashSet<XEventClass>());
			}
			node2activity.get(pair.getFirst()).add(pair.getSecond());
		}
		initialize(classes, graph);
	}

	protected AbstractLogModelConnection(XLog log, XEventClasses classes, DirectedGraph<N, E> graph,
			Collection<? extends N> mappableNodes, Map<? extends N, ? extends XEventClass> relations) {
		this(log, classes, graph, mappableNodes);
		for (Map.Entry<? extends N, ? extends XEventClass> pair : relations.entrySet()) {
			if (!node2activity.containsKey(pair.getKey())) {
				node2activity.put(pair.getKey(), new HashSet<XEventClass>());
			}
			node2activity.get(pair.getKey()).add(pair.getValue());

		}
		initialize(classes, graph);
	}

	private void initialize(XEventClasses classes, DirectedGraph<N, E> graph) {
		for (XEventClass clazz : classes.getClasses()) {
			Set<N> nodes = getNodesFor(clazz);
			minNodePerActivity = Math.min(minNodePerActivity, nodes.size());
			maxNodePerActivity = Math.max(maxNodePerActivity, nodes.size());
		}
		for (WeakReference<N> node : mappableNodes) {
			Set<XEventClass> events = getActivitiesFor(node.get());
			minActivityPerNode = Math.min(minActivityPerNode, events.size());
			maxActivityPerNode = Math.max(maxActivityPerNode, events.size());
		}
	}

	public Set<XEventClass> getActivitiesFor(N node) {
		Set<XEventClass> s = node2activity.get(node);
		return s == null ? Collections.<XEventClass>emptySet() : s;
	}

	public Set<N> getNodesFor(XEventClass clazz) {
		Set<N> s = new HashSet<N>();
		for (Map.Entry<N, Set<XEventClass>> entry : node2activity.entrySet()) {
			if (entry.getValue().contains(clazz)) {
				s.add(entry.getKey());
			}
		}
		return s;
	}

	public boolean isInjectionFromNodeToActivity() {
		return maxNodePerActivity <= 1;
	}

	public boolean isInjectionFromActivityToNode() {
		return maxActivityPerNode <= 1;
	}

	public boolean isSurjectionFromNodeToActivity() {
		return minNodePerActivity >= 1;
	}

	public boolean isSurjectionFromActivityToNode() {
		return minActivityPerNode >= 1;
	}

	public boolean isBijectionFromNodeToActivity() {
		return isInjectionFromNodeToActivity() && isSurjectionFromNodeToActivity();
	}

	public boolean isBijectionFromActivityToNode() {
		return isInjectionFromActivityToNode() && isSurjectionFromActivityToNode();
	}

	public Collection<N> getMappableNodes() {
		HashSet<N> set = new HashSet<N>();
		for (WeakReference<N> n : mappableNodes) {
			set.add(n.get());
		}
		return Collections.unmodifiableCollection(set);
	}

	public XEventClasses getEventClasses() {
		return (XEventClasses) get(CLASSES);
	}
}
"
HighFrequencyFilterAlgorithm.java,log,"package org.processmining.log.algorithms;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.log.parameters.HighFrequencyFilterParameters;
import org.processmining.log.parameters.LogFilterParameters;

public class HighFrequencyFilterAlgorithm implements LogFilterAlgorithm {

	private Map<Set<List<String>>, Integer> cache;

	public HighFrequencyFilterAlgorithm() {
		cache = new HashMap<Set<List<String>>, Integer>();
	}
	
	public XLog apply(PluginContext context, XLog log, LogFilterParameters parameters) {
		final Map<List<String>, Integer> traceOccurrenceMap = new HashMap<List<String>, Integer>();
		final Map<XTrace, List<String>> traceActivitiesMap = new HashMap<XTrace, List<String>>();
		XLog clonedLog = (XLog) log.clone();

		for (XTrace trace : clonedLog) {
			List<String> activities = new ArrayList<String>();
			for (XEvent event : trace) {
				activities.add(parameters.getClassifier().getClassIdentity(event));
			}
			traceActivitiesMap.put(trace, activities);
			if (traceOccurrenceMap.keySet().contains(activities)) {
				traceOccurrenceMap.put(activities, traceOccurrenceMap.get(activities) + 1);
			} else {
				traceOccurrenceMap.put(activities, 1);
			}
		}

		List<Integer> occurrences = new ArrayList<Integer>(traceOccurrenceMap.values());
		Collections.sort(occurrences);

//		SummaryStatistics statistics = new SummaryStatistics();
//		for (int occurrence : occurrences) {
//			for (int i = 0; i < occurrence; i++) {
//				statistics.addValue(occurrence);
//			}
//		}
//		int threshold = (int) Math.round(statistics.getMean() - 1.0 * statistics.getStandardDeviation());
		int threshold = ((100 - ((HighFrequencyFilterParameters) parameters).getFrequencyThreshold()) * clonedLog
				.size()) / 100;
		int sum = 0;
		int index = -1;
		while (sum < threshold) {
			sum += occurrences.get(++index);
		}
		/*
		 * The 'traces' occurrences[index]...occurrences[occurrences.size()-1]
		 * cover more than X% if the log, where X = parameters.getThreshold().
		 */
		threshold = occurrences.get(index);
		/*
		 * If we take all traces that occur at least as many times as threshold
		 * times, we cover at least X% of the log.
		 */
		if (threshold == occurrences.get(occurrences.size() - 1) + 1) {
			/*
			 * We're about to remove all traces. That seems to be undesirable.
			 */
			threshold--;
		}
		System.out.println(""Threshold = "" + threshold);

		Collection<XTrace> tracesToRemove = new HashSet<XTrace>();

		for (XTrace trace : clonedLog) {
			if (traceOccurrenceMap.get(traceActivitiesMap.get(trace)) >= threshold) {
				/*
				 * Trace occurs often enough. Filter it in.
				 */
			} else {
				/*
				 * Trace does not occur often enough by itself. Check whether it
				 * matches one that does.
				 */
				boolean retain = false;
				for (XTrace otherTrace : clonedLog) {
					if (traceOccurrenceMap.get(traceActivitiesMap.get(otherTrace)) >= threshold) {
						if (getTraceDistance(traceActivitiesMap.get(trace), traceActivitiesMap.get(otherTrace)) < ((HighFrequencyFilterParameters) parameters)
								.getDistanceThreshold()) {
							/*
							 * Yes, it matches one that does. Filter this trace
							 * in as well.
							 */
							retain = true;
							continue;
						}
					}
				}
				if (!retain) {
					/*
					 * This trace does not occur frequent enough, an dit does
					 * not match any other traces that does. Filter it out.
					 */
					tracesToRemove.add(trace);
				}
			}
		}

		clonedLog.removeAll(tracesToRemove);
		/*
		 * At least X% of the log is retained.
		 */

		return clonedLog;
	}

	private int getTraceDistance(List<String> activities1, List<String> activities2) {
		return getTraceDistance(activities1, activities2, 0, 0);
	}

	private int getTraceDistance(List<String> activities1, List<String> activities2, int index1, int index2) {
		int distance = 0;
		if (index1 >= activities1.size()) {
			distance = activities2.size() - index2;
		} else if (index2 >= activities2.size()) {
			distance = activities1.size() - index1;
		} else {
			Set<List<String>> activities = new HashSet<List<String>>();
			activities.add(activities1);
			activities.add(activities2);
			if (cache.containsKey(activities)) {
				distance = cache.get(activities);
			} else {
				if (activities1.get(index1).equals(activities2.get(index2))) {
					distance = getTraceDistance(activities1, activities2, index1 + 1, index2 + 1);
				} else {
					int distance1 = 1 + getTraceDistance(activities1, activities2, index1 + 1, index2);
					int distance2 = 1 + getTraceDistance(activities1, activities2, index1, index2 + 1);
					if (distance1 < distance2) {
						distance = distance1;
					} else {
						distance = distance2;
					}
				}
				cache.put(activities, distance);
			}
		}
		return distance;
	}
}
"
LogCentralityAlgorithm.java,log,"package org.processmining.log.algorithms;

import org.deckfour.xes.model.XLog;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.log.models.LogCentrality;
import org.processmining.log.parameters.LogCentralityParameters;

public class LogCentralityAlgorithm {

	public LogCentrality apply(PluginContext context, XLog log, LogCentrality centrality, LogCentralityParameters parameters) {
		context.getProgress().setMaximum(log.size());
		centrality.setClassifier(context, parameters);
		return centrality;
	}
}
"
LogCentralityFilterAlgorithm.java,log,"package org.processmining.log.algorithms;

import org.deckfour.xes.model.XLog;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.log.models.LogCentrality;
import org.processmining.log.parameters.LogCentralityFilterParameters;

public class LogCentralityFilterAlgorithm {

	public XLog apply(PluginContext context, LogCentrality centrality, LogCentralityFilterParameters parameters) {
		context.getProgress().setMaximum(centrality.size());
		return centrality.filter(context, parameters);
	}
}
"
LogCentralityVisualizerAlgorithm.java,log,"package org.processmining.log.algorithms;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;

import javax.swing.BorderFactory;
import javax.swing.Box;
import javax.swing.BoxLayout;
import javax.swing.JComponent;
import javax.swing.JLabel;
import javax.swing.JPanel;

import org.processmining.log.models.LogCentrality;
import org.processmining.log.parameters.LogCentralityFilterParameters;

import com.fluxicon.slickerbox.components.DistributionUI;
import com.fluxicon.slickerbox.components.RoundedPanel;

public class LogCentralityVisualizerAlgorithm {

	protected Color colorEnclosureBg = new Color(250, 250, 250, 105);
	protected Color colorTitleFg = new Color(20, 20, 20, 230);
	protected Color colorInfoBg = new Color(60, 60, 60, 160);
	protected Color colorInfoBgMouseOver = new Color(60, 60, 60, 240);
	protected Color colorInfoLabel = new Color(210, 210, 210);
	protected Color colorInfoValue = new Color(255, 255, 255);

	private int factor = 100;

	public JComponent apply(LogCentrality centrality, LogCentralityFilterParameters parameters) {
		double sumCentrality = 0.0;
		int j = ((parameters == null) ? centrality.getCentralities().size() : (parameters.getPercentage() * centrality
				.getCentralities().size()) / 100);
		if (j >= centrality.getCentralities().size()) {
			j = centrality.getCentralities().size() - 1;
		}
		while ((j < centrality.getCentralities().size() - 1)
				&& (centrality.getCentralities().get(j) == centrality.getCentralities().get(j + 1))) {
			j++;
		}
		int left, right;
		if (parameters == null || parameters.isFilterIn()) {
			left = 0;
			right = j;
		} else {
			left = j + 1;
			right = centrality.getCentralities().size() - 1;
			if (left > right) {
				left = right;
			}
		}
		int minCentrality = (int) Math.round(factor * centrality.getCentralities().get(left));
		int maxCentrality = (int) Math.round(factor * centrality.getCentralities().get(right));
		int[] centralityArray = new int[right + 1 - left];
		for (int k = left; k <= right; k++) {
			Double value = centrality.getCentralities().get(k);
			centralityArray[k - left] = (int) Math.round(factor * value);
			sumCentrality += value;
		}
		int meanCentrality = (int) Math.round(factor * sumCentrality / (right + 1 - left));
		JComponent[] components = new JComponent[4];
		JComponent panel = getDistributionPanel(""Trace happiness"", centralityArray, meanCentrality, components);
		((JLabel) components[0]).setText("""" + minCentrality / (double) factor);
		((JLabel) components[1]).setText("""" + meanCentrality / (double) factor);
		((JLabel) components[2]).setText("""" + maxCentrality / (double) factor);
		return panel;
	}

	private RoundedPanel getDistributionPanel(String title, int[] values, int meanValue, JComponent[] result) {

		// create distribution panel
		RoundedPanel instancePanel = new RoundedPanel(15, 0, 0);
		instancePanel.setBackground(colorEnclosureBg);
		instancePanel.setLayout(new BoxLayout(instancePanel, BoxLayout.Y_AXIS));
		instancePanel.add(getLeftAlignedHeader(title));
		instancePanel.add(Box.createVerticalStrut(6));
		if (values.length == 0) {
			return instancePanel;
		}
		RoundedPanel instanceDistPanel = new RoundedPanel(10, 0, 0);
		result[3] = instanceDistPanel;
		instanceDistPanel.setBackground(new Color(20, 20, 20));
		instanceDistPanel.setLayout(new BorderLayout());
		DistributionUI instanceDistUI = new DistributionUI(values);
		instanceDistPanel.add(instanceDistUI, BorderLayout.CENTER);
		JPanel keyPanel = new JPanel();
		keyPanel.setOpaque(false);
		keyPanel.setBorder(BorderFactory.createEmptyBorder());
		keyPanel.setLayout(new BoxLayout(keyPanel, BoxLayout.X_AXIS));
		result[0] = packInfo(keyPanel, ""Min"");
		keyPanel.add(Box.createHorizontalGlue());
		keyPanel.add(Box.createHorizontalGlue());
		keyPanel.add(Box.createHorizontalGlue());
		result[1] = packInfo(keyPanel, ""Mean"");
		keyPanel.add(Box.createHorizontalGlue());
		keyPanel.add(Box.createHorizontalGlue());
		keyPanel.add(Box.createHorizontalGlue());
		result[2] = packInfo(keyPanel, ""Max"");
		instancePanel.add(instanceDistPanel);
		instancePanel.add(Box.createVerticalStrut(4));
		instancePanel.add(keyPanel);
		return instancePanel;
	}

	private JLabel packInfo(JPanel panel, String name) {
		String value = ""Initializing ..."";

		RoundedPanel packed = new RoundedPanel(10, 0, 0);
		packed.setBackground(colorInfoBg);
		final RoundedPanel target = packed;
		packed.addMouseListener(new MouseListener() {
			public void mouseClicked(MouseEvent arg0) { /* ignore */
			}

			public void mouseEntered(MouseEvent arg0) {
				target.setBackground(colorInfoBgMouseOver);
				target.repaint();
			}

			public void mouseExited(MouseEvent arg0) {
				target.setBackground(colorInfoBg);
				target.repaint();
			}

			public void mousePressed(MouseEvent arg0) { /* ignore */
			}

			public void mouseReleased(MouseEvent arg0) { /* ignore */
			}
		});
		packed.setLayout(new BoxLayout(packed, BoxLayout.X_AXIS));
		JLabel nameLabel = new JLabel(name);
		nameLabel.setOpaque(false);
		nameLabel.setForeground(colorInfoLabel);
		nameLabel.setFont(nameLabel.getFont().deriveFont(12f));
		JLabel valueLabel = new JLabel(value);
		valueLabel.setOpaque(false);
		valueLabel.setForeground(colorInfoValue);
		valueLabel.setFont(valueLabel.getFont().deriveFont(14f));
		packed.add(Box.createHorizontalStrut(5));
		packed.add(nameLabel);
		packed.add(Box.createHorizontalGlue());
		packed.add(valueLabel);
		packed.add(Box.createHorizontalStrut(5));
		packed.revalidate();

		panel.add(packed);

		return valueLabel;
	}

	private JPanel getLeftAlignedHeader(String title) {
		JLabel hLabel = new JLabel(title);
		hLabel.setOpaque(false);
		hLabel.setForeground(colorTitleFg);
		hLabel.setFont(hLabel.getFont().deriveFont(15f));
		return alignLeft(hLabel);
	}

	private JPanel alignLeft(JComponent component) {
		JPanel hPanel = new JPanel();
		hPanel.setBorder(BorderFactory.createEmptyBorder());
		hPanel.setOpaque(false);
		hPanel.setLayout(new BoxLayout(hPanel, BoxLayout.X_AXIS));
		hPanel.add(component);
		hPanel.add(Box.createHorizontalGlue());
		return hPanel;
	}

}
"
LogCheckerAlgorithm.java,log,"package org.processmining.log.algorithms;

import org.deckfour.xes.model.XLog;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.log.logchecks.LogCheckType;
import org.processmining.log.models.LogCheckerReport;
import org.processmining.log.parameters.LogCheckerParameters;

public class LogCheckerAlgorithm {

	public LogCheckerReport apply(PluginContext context, final XLog log, final LogCheckerParameters parameters) {
		LogCheckerReport report = new LogCheckerReport();
		boolean allOk = true;
		for (LogCheckType logCheckType: parameters.getLogChecks()) {
			allOk = logCheckType.getLogCheck().check(context, log, report) && allOk;
		}
		if (allOk) {
			report.add(""<h2>No problems detected, congratulations!</h2>"");
		}
		return report;
	}
}
"
LogFilterAlgorithm.java,log,"package org.processmining.log.algorithms;

import org.deckfour.xes.model.XLog;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.log.parameters.LogFilterParameters;

public interface LogFilterAlgorithm {
	
	public XLog apply(PluginContext context, XLog log, LogFilterParameters parameters);

}
"
LogFrequencyAlgorithm.java,log,"package org.processmining.log.algorithms;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.log.models.LogFrequency;
import org.processmining.log.models.impl.LogFrequencyFactory;
import org.processmining.log.parameters.LogFrequencyParameters;

public class LogFrequencyAlgorithm {

	public LogFrequency apply(PluginContext context, XLog log, LogFrequencyParameters parameters) {
		LogFrequency frequency = LogFrequencyFactory.createLogFrequency(log);
		final Map<List<String>, Integer> traceOccurrenceMap = new HashMap<List<String>, Integer>();

		for (XTrace trace : log) {
			List<String> activities = new ArrayList<String>();
			for (XEvent event : trace) {
				activities.add(parameters.getClassifier().getClassIdentity(event));
			}
			if (traceOccurrenceMap.keySet().contains(activities)) {
				traceOccurrenceMap.put(activities, traceOccurrenceMap.get(activities) + 1);
			} else {
				traceOccurrenceMap.put(activities, 1);
			}
		}

		for (List<String> activities : traceOccurrenceMap.keySet()) {
			frequency.add(traceOccurrenceMap.get(activities));
		}
		return frequency;
	}
}
"
LogFrequencyArrayAlgorithm.java,log,"package org.processmining.log.algorithms;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XTrace;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.log.models.EventLogArray;
import org.processmining.log.models.LogFrequencyArray;
import org.processmining.log.models.impl.LogFrequencyFactory;
import org.processmining.log.parameters.LogFrequencyParameters;

public class LogFrequencyArrayAlgorithm {

	public LogFrequencyArray apply(PluginContext context, EventLogArray logs, LogFrequencyParameters parameters) {
		LogFrequencyArray frequencies = LogFrequencyFactory.createLogFrequencyArray(logs);
		for (int i = 0; i < logs.getSize(); i++) {
			frequencies.set(i);
			final Map<List<String>, Integer> traceOccurrenceMap = new HashMap<List<String>, Integer>();

			for (XTrace trace : logs.getLog(i)) {
				List<String> activities = new ArrayList<String>();
				for (XEvent event : trace) {
					activities.add(parameters.getClassifier().getClassIdentity(event));
				}
				if (traceOccurrenceMap.keySet().contains(activities)) {
					traceOccurrenceMap.put(activities, traceOccurrenceMap.get(activities) + 1);
				} else {
					traceOccurrenceMap.put(activities, 1);
				}
			}

			for (List<String> activities : traceOccurrenceMap.keySet()) {
				frequencies.add(traceOccurrenceMap.get(activities));
			}
		}
		return frequencies;
	}
}
"
LowFrequencyFilterAlgorithm.java,log,"package org.processmining.log.algorithms;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;

import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.log.parameters.LogFilterParameters;
import org.processmining.log.parameters.LowFrequencyFilterParameters;

public class LowFrequencyFilterAlgorithm implements LogFilterAlgorithm {

	public XLog apply(PluginContext context, XLog log, LogFilterParameters parameters) {
		final Map<List<String>, Integer> traceOccurrenceMap = new HashMap<List<String>, Integer>();
		final Map<XTrace, List<String>> traceActivitiesMap = new HashMap<XTrace, List<String>>();
		
		XLog clonedLog = (XLog) log.clone();
		
		for (XTrace trace : clonedLog) {
			List<String> activities = new ArrayList<String>();
			for (XEvent event : trace) {
				activities.add(parameters.getClassifier().getClassIdentity(event));
			}
			traceActivitiesMap.put(trace,  activities);
			if (traceOccurrenceMap.keySet().contains(activities)) {
				traceOccurrenceMap.put(activities, traceOccurrenceMap.get(activities) + 1);
			} else {
				traceOccurrenceMap.put(activities, 1);
			}
		}
		
		List<Integer> occurrences = new ArrayList<Integer>(traceOccurrenceMap.values());
		Collections.sort(occurrences);
		int threshold = (((LowFrequencyFilterParameters) parameters).getThreshold() * clonedLog.size()) / 100;
		int sum = 0;
		int index = -1;
		while (sum < threshold) {
			sum += occurrences.get(++index);
		}
		/*
		 * The low-frequency 'traces' (occurrences[0]...occurrences[index]) counted so far make up for X% of the log, 
		 * where X = parameters.getThreshold().
		 */
		threshold = (index == -1 ? 0 : occurrences.get(index)) + 1;
		/*
		 * If we take all traces that occur fewer than threshold times, we cover at least X% of the log.
		 */
		
		if (threshold == occurrences.get(occurrences.size() - 1) + 1) {
			/*
			 * We're about to remove all traces. That seems to be undesirable.
			 */
			threshold--;
		}
		
		Collection<XTrace> tracesToRemove = new HashSet<XTrace>();

		for (XTrace trace : clonedLog) {
			/*
			 * Trace does not occur often enough. Have it removed.
			 */
			if (traceOccurrenceMap.get(traceActivitiesMap.get(trace)) < threshold) {
				tracesToRemove.add(trace);
			}
		}
		
		/*
		 * tracesToRemove holds at least X% of the log.
		 */
		clonedLog.removeAll(tracesToRemove);
		
		return clonedLog;
	}

}
"
LowOccurrencesFilterAlgorithm.java,log,"package org.processmining.log.algorithms;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;

import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.log.parameters.LogFilterParameters;
import org.processmining.log.parameters.LowOccurrencesFilterParameters;

public class LowOccurrencesFilterAlgorithm implements LogFilterAlgorithm {

	public XLog apply(PluginContext context, XLog log, LogFilterParameters parameters) {
		final Map<List<String>, Integer> traceOccurrenceMap = new HashMap<List<String>, Integer>();
		final Map<XTrace, List<String>> traceActivitiesMap = new HashMap<XTrace, List<String>>();
		XLog clonedLog = (XLog) log.clone();

		for (XTrace trace : clonedLog) {
			List<String> activities = new ArrayList<String>();
			for (XEvent event : trace) {
				activities.add(parameters.getClassifier().getClassIdentity(event));
			}
			traceActivitiesMap.put(trace, activities);
			if (traceOccurrenceMap.keySet().contains(activities)) {
				traceOccurrenceMap.put(activities, traceOccurrenceMap.get(activities) + 1);
			} else {
				traceOccurrenceMap.put(activities, 1);
			}
		}

		Collection<XTrace> tracesToRemove = new HashSet<XTrace>();

		for (XTrace trace : clonedLog) {
			if (traceOccurrenceMap.get(traceActivitiesMap.get(trace)) < ((LowOccurrencesFilterParameters) parameters).getThreshold()) {
				/*
				 * Trace does not occur often enough. Have it removed.
				 */
				tracesToRemove.add(trace);
			}
		}

		clonedLog.removeAll(tracesToRemove);

		return clonedLog;
	}

}
"
MergeLogsAlgorithm.java,log,"package org.processmining.log.algorithms;

import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
import java.util.concurrent.TimeUnit;

import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.extension.std.XTimeExtension;
import org.deckfour.xes.factory.XFactoryRegistry;
import org.deckfour.xes.model.XAttribute;
import org.deckfour.xes.model.XAttributeContinuous;
import org.deckfour.xes.model.XAttributeDiscrete;
import org.deckfour.xes.model.XAttributeLiteral;
import org.deckfour.xes.model.XAttributeTimestamp;
import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.log.parameters.MergeLogsParameters;

public class MergeLogsAlgorithm {

	private final String STOPWORDS = ""a about above above across after afterwards again against ""
			+ ""all almost alone along already also although always am among amongst amoungst ""
			+ ""amount an and another any anyhow anyone anything anyway anywhere are around as at ""
			+ ""back be became because become becomes becoming been before beforehand behind being ""
			+ ""below beside besides between beyond bill both bottom but by call can cannot cant co ""
			+ ""con could couldnt cry de describe detail do done down due during each eg eight either ""
			+ ""eleven else elsewhere empty enough etc even ever every everyone everything everywhere ""
			+ ""except few fifteen fify fill find fire first five for former formerly forty found four ""
			+ ""from front full further get give go had has hasnt have he hence her here hereafter hereby ""
			+ ""herein hereupon hers herself him himself his how however hundred ie if in inc indeed ""
			+ ""interest into is it its itself keep last latter latterly least less ltd made many may me ""
			+ ""meanwhile might mill mine more moreover most mostly move much must my myself name namely ""
			+ ""neither never nevertheless next nine no nobody none noone nor not nothing now nowhere of off ""
			+ ""often on once one only onto or other others otherwise our ours ourselves out over own part ""
			+ ""per perhaps please put rather re same see seem seemed seeming seems serious several she should ""
			+ ""show side since sincere six sixty so some somehow someone something sometime sometimes ""
			+ ""somewhere still such system take ten than that the their them themselves then thence there ""
			+ ""thereafter thereby therefore therein thereupon these they thickv thin third this those though ""
			+ ""three through throughout thru thus to together too top toward towards twelve twenty two un ""
			+ ""under until up upon us very via was we well were what whatever when whence whenever where ""
			+ ""whereafter whereas whereby wherein whereupon wherever whether which while whither who whoever ""
			+ ""whole whom whose why will with within without would yet you your yours yourself yourselves the"";

	public XLog apply(PluginContext context, XLog mainLog, XLog subLog, MergeLogsParameters parameters) {
		XLog log = XFactoryRegistry.instance().currentDefault().createLog();
		DateFormat df = new SimpleDateFormat(parameters.getDateFormat());

		long time = -System.currentTimeMillis();

		for (XTrace mainTrace : mainLog) {
			boolean doApply = true;
			if (doApply && parameters.getTraceId() != null) {
				/*
				 * User has selected specific main trace. Filter in only the
				 * trace that has that id as concept:name.
				 */
				String id = XConceptExtension.instance().extractName(mainTrace);
				doApply = (id != null && id.equals(parameters.getTraceId()));
			}
			if (doApply && parameters.getFromDate() != null && parameters.getToDate() != null) {
				/*
				 * User has selected from date and to date. Filter in only those
				 * traces that occur entirely in that interval.
				 */
				doApply = isBetween(mainTrace, parameters.getFromDate(), parameters.getToDate());
			}
			if (doApply && parameters.getSpecificDate() != null) {
				/*
				 * User has selected a specific date. Only filter in those
				 * traces that have this exact date.
				 */
				doApply = false;
				for (XEvent event : mainTrace) {
					Date date = XTimeExtension.instance().extractTimestamp(event);
					if (date.equals(parameters.getSpecificDate())) {
						doApply = true;
						continue;
					}
				}
			}
			if (doApply && parameters.getRequiredWords() != null) {
				/*
				 * User has selected required words. Filter in those traces that
				 * match one of these words.
				 */
				doApply = false;
				Collection<String> required = new HashSet<String>(
						Arrays.asList(parameters.getRequiredWords().split("","")));
				for (XEvent event : mainTrace) {
					for (XAttribute attribute : event.getAttributes().values()) {
						if (attribute instanceof XAttributeLiteral) {
							String value = ((XAttributeLiteral) attribute).getValue();
							if (required.contains(value)) {
								doApply = true;
								continue;
							}
						} else if (attribute instanceof XAttributeDiscrete) {
							long value = ((XAttributeDiscrete) attribute).getValue();
							if (required.contains(String.valueOf(value))) {
								doApply = true;
								continue;
							}
						} else if (attribute instanceof XAttributeContinuous) {
							double value = ((XAttributeContinuous) attribute).getValue();
							if (required.contains(String.valueOf(value))) {
								doApply = true;
								continue;
							}
						} else if (attribute instanceof XAttributeTimestamp) {
							Date value = ((XAttributeTimestamp) attribute).getValue();
							if (required.contains(df.format(value))) {
								doApply = true;
								continue;
							}
						}
					}
					if (doApply) {
						continue;
					}
				}
			}
			if (doApply && parameters.getForbiddenWords() != null) {
				/*
				 * User has selected forbidden words. Filter out those traces
				 * that match one of these words.
				 */
				doApply = true;
				Collection<String> forbidden = new HashSet<String>(
						Arrays.asList(parameters.getForbiddenWords().split("","")));
				for (XEvent event : mainTrace) {
					for (XAttribute attribute : event.getAttributes().values()) {
						if (attribute instanceof XAttributeLiteral) {
							String value = ((XAttributeLiteral) attribute).getValue();
							if (forbidden.contains(value)) {
								doApply = false;
								continue;
							}
						} else if (attribute instanceof XAttributeDiscrete) {
							long value = ((XAttributeDiscrete) attribute).getValue();
							if (forbidden.contains(String.valueOf(value))) {
								doApply = false;
								continue;
							}
						} else if (attribute instanceof XAttributeContinuous) {
							double value = ((XAttributeContinuous) attribute).getValue();
							if (forbidden.contains(String.valueOf(value))) {
								doApply = false;
								continue;
							}
						} else if (attribute instanceof XAttributeTimestamp) {
							Date value = ((XAttributeTimestamp) attribute).getValue();
							if (forbidden.contains(df.format(value))) {
								doApply = false;
								continue;
							}
						}
					}
					if (!doApply) {
						continue;
					}
				}
			}
			if (doApply) {
				/*
				 * Main trace has passed all filters. Add it with all
				 * corresponding sub traces to the resulting log.
				 */
				apply(context, mainTrace, mainLog, subLog, log, parameters);
			}
		}

		time += System.currentTimeMillis();
		context.log(""Merging time :"" + convet_MS(time));
		return log;
	}

	private void apply(PluginContext context, XTrace mainTrace, XLog mainLog, XLog subLog, XLog log,
			MergeLogsParameters parameters) {
		for (XTrace subTrace : subLog) {
			if (isBetween(mainTrace, subTrace)) {
				boolean doApply = true;
				if (doApply && (checkMatch(mainTrace, subTrace) < parameters.getRelated())) {
					doApply = false;
				}
				if (doApply && (checkWordMatch(mainTrace, subTrace) < parameters.getMinMatches())) {
					doApply = false;
				}
				if (doApply) {
					XTrace trace = XFactoryRegistry.instance().currentDefault().createTrace(mainTrace.getAttributes());
					int mainCtr = 0;
					int subCtr = 0;
					while (mainCtr < mainTrace.size() && subCtr < subTrace.size()) {
						Date mainDate = XTimeExtension.instance().extractTimestamp(mainTrace.get(mainCtr));
						if (mainDate == null) {
							trace.add(mainTrace.get(mainCtr));
							mainCtr++;
						} else {
							Date subDate = XTimeExtension.instance().extractTimestamp(subTrace.get(subCtr));
							if (subDate == null) {
								trace.add(subTrace.get(subCtr));
								subCtr++;
							} else if (subDate.before(mainDate)) {
								trace.add(subTrace.get(subCtr));
								subCtr++;
							} else {
								trace.add(mainTrace.get(mainCtr));
								mainCtr++;
							}
						}
					}
					log.add(trace);
				}
			}
		}
	}

	private XTrace previousMainTrace = null;
	private Collection<String> mainWords = null;
	private Collection<String> stopWords = null;

	private int checkWordMatch(XTrace mainTrace, XTrace subTrace) {
		/*
		 * Build the stop words.
		 */
		if (stopWords == null) {
			stopWords = new HashSet<String>();
			stopWords.addAll(Arrays.asList(STOPWORDS.split("" "")));
		}
		/*
		 * Build (or reuse) the main words.
		 */
		if (mainTrace != previousMainTrace) {
			mainWords = new HashSet<String>();
			for (XEvent event : mainTrace) {
				for (XAttribute attribute : event.getAttributes().values()) {
					/*
					 * Exclude date/time from comparision.
					 */
					if (!(attribute instanceof XAttributeTimestamp)) {
						mainWords.addAll(Arrays.asList(attribute.toString().split("" "")));
					}
				}
			}
			mainWords.removeAll(stopWords);
			previousMainTrace = mainTrace;			
		}
		/*
		 * Build the sub words.
		 */
		Collection<String> subWords = new HashSet<String>();
		for (XEvent event : subTrace) {
			for (XAttribute attribute : event.getAttributes().values()) {
				/*
				 * Exclude date/time from comparision.
				 */
				if (!(attribute instanceof XAttributeTimestamp)) {
					subWords.addAll(Arrays.asList(attribute.toString().split("" "")));
				}
			}
		}
		subWords.removeAll(stopWords);
		/*
		 * Remove all words not in the main words.
		 */
		subWords.retainAll(mainWords);
		/*
		 * Return number of matching words.
		 */
		return subWords.size();
	}

	private int checkMatch(XTrace mainTrace, XTrace subTrace) {
		int match = 0;
		for (XEvent mainEvent : mainTrace) {
			for (XEvent subEvent : mainTrace) {
				match += checkMatch(mainEvent, subEvent);
			}
		}
		return match;
	}

	private int checkMatch(XEvent mainEvent, XEvent subEvent) {
		int match = 0;
		for (XAttribute mainAttribute : mainEvent.getAttributes().values()) {
			if (!(mainAttribute instanceof XAttributeTimestamp)) {
				for (XAttribute subAttribute : subEvent.getAttributes().values()) {
					if (mainAttribute.equals(subAttribute)) {
						match++;
					}
				}
			}
		}
		return match;
	}

	private boolean isBetween(XTrace trace, Date firstDate, Date lastDate) {
		Date firstTraceDate = getFirstDate(trace);
		if (firstTraceDate == null) {
			return false;
		}
		/*
		 * Update on June 6, 2016: the subtrace should start after the main trace
		 * has started, but not after it has started. 
		 * There is no requirement on when the subtrace ends.
		 */
		return (firstTraceDate.after(firstDate) && !firstTraceDate.after(lastDate));
	}

	private boolean isBetween(XTrace mainTrace, XTrace subTrace) {
		Date firstTraceDate = getFirstDate(mainTrace);
		Date lastTraceDate = getLastDate(mainTrace);
		if (firstTraceDate == null || lastTraceDate == null) {
			return false;
		}
		return isBetween(subTrace, firstTraceDate, lastTraceDate);
	}

	private Date getFirstDate(XTrace trace) {
		Date firstDate = null;
		for (XEvent event : trace) {
			Date date = XTimeExtension.instance().extractTimestamp(event);
			if (firstDate == null) {
				firstDate = date;
			} else if (date.before(firstDate)) {
				firstDate = date;
			}
		}
		return firstDate;
	}

	private Date getLastDate(XTrace trace) {
		Date lastDate = null;
		for (XEvent event : trace) {
			Date date = XTimeExtension.instance().extractTimestamp(event);
			if (lastDate == null) {
				lastDate = date;
			} else if (date.after(lastDate)) {
				lastDate = date;
			}
		}
		return lastDate;
	}

	private String convet_MS(long millis) {

		return String.format(""%d min, %d sec %d ms"", TimeUnit.MILLISECONDS.toMinutes(millis),
				TimeUnit.MILLISECONDS.toSeconds(millis)
						- TimeUnit.MINUTES.toSeconds(TimeUnit.MILLISECONDS.toMinutes(millis)),
				millis - TimeUnit.SECONDS.toMillis(TimeUnit.MILLISECONDS.toSeconds(millis)));
	}

}
"
SplitLogAlgorithm.java,log,"package org.processmining.log.algorithms;

import java.util.Arrays;
import java.util.Set;
import java.util.TreeSet;

import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.factory.XFactory;
import org.deckfour.xes.factory.XFactoryRegistry;
import org.deckfour.xes.model.XAttribute;
import org.deckfour.xes.model.XAttributeLiteral;
import org.deckfour.xes.model.XAttributeMap;
import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.log.parameters.SplitLogParameters;

public class SplitLogAlgorithm {

	public XLog apply(PluginContext context, XLog log, SplitLogParameters parameters) {

		XFactory factory = XFactoryRegistry.instance().currentDefault();

		XLog splittedLog = factory.createLog(log.getAttributes());
		splittedLog.getExtensions().addAll(log.getExtensions());
		splittedLog.getGlobalTraceAttributes().addAll(log.getGlobalTraceAttributes());
		splittedLog.getGlobalEventAttributes().addAll(log.getGlobalEventAttributes());
		splittedLog.getClassifiers().addAll(log.getClassifiers());

		for (XTrace trace : log) {
			Set<String> splitValues = new TreeSet<String>();
			for (XEvent event : trace) {
				if (event.getAttributes().containsKey(parameters.getKey())) {
					String value = event.getAttributes().get(parameters.getKey()).toString();
					if (value != null && !value.trim().isEmpty()) {
						splitValues.addAll(Arrays.asList(value.trim().split("" "")));
					}
				}
			}
			int ctr = 1;

			for (String splitValue : splitValues) {
				XTrace splittedTrace = factory.createTrace((XAttributeMap) trace.getAttributes().clone());
				XAttributeLiteral attr = factory.createAttributeLiteral(""oldname"",
						XConceptExtension.instance().extractName(trace), null);
				splittedTrace.getAttributes().put(""oldname"", attr);
				XConceptExtension.instance().assignName(splittedTrace,
						XConceptExtension.instance().extractName(trace) + ""-"" + ctr);
				ctr++;
				for (XEvent event : trace) {
					XAttribute attribute = event.getAttributes().get(parameters.getKey());
					String value = attribute == null ? null : attribute.toString();
					if (value == null || value.trim().isEmpty()
							|| Arrays.asList(value.trim().split("" "")).contains(splitValue)) {
						XEvent splittedEvent = factory.createEvent((XAttributeMap) event.getAttributes().clone());
						attr = factory.createAttributeLiteral(parameters.getKey(), splitValue, null);
						splittedEvent.getAttributes().put(parameters.getKey(), attr);
						splittedTrace.add(splittedEvent);
					}
				}
				splittedLog.add(splittedTrace);
			}
		}
		return splittedLog;
	}

	/*
	 * private CSVReader reader;
	 * 
	 * public ArrayList<ArrayList<String>> read(String file, final int index) {
	 * try {
	 * 
	 * reader = new CSVReader(new FileReader(file));
	 * 
	 * String[] nextLine; ArrayList<String> bucket = new ArrayList<String>();
	 * ArrayList<ArrayList<String>> container = new
	 * ArrayList<ArrayList<String>>(); ArrayList<ArrayList<ArrayList<String>>>
	 * super_container = new ArrayList<ArrayList<ArrayList<String>>>(); int
	 * counter = 0; String CaseID = null; while ((nextLine = reader.readNext())
	 * != null) { if (counter == 0) { CaseID = nextLine[0]; } String[] splitted
	 * = nextLine[index].trim().split("" ""); for (int i = 0; i < splitted.length;
	 * i++) { bucket = new ArrayList<String>(); bucket.add(nextLine[0]); if
	 * (!CaseID.equals(nextLine[0])) { super_container.add(container); container
	 * = new ArrayList<ArrayList<String>>(); counter = 0; } else { counter = 1;
	 * } for (int j = 0; j < index; j++) { bucket.add(nextLine[j]); }
	 * bucket.add(splitted[i]); if (index < nextLine.length - 1) { for (int j =
	 * index + 1; j < nextLine.length; j++) { bucket.add(nextLine[j]); } }
	 * container.add(bucket); }
	 * 
	 * } super_container.add(container); for (int i = 0; i <
	 * super_container.size(); i++) { Collections.sort(super_container.get(i),
	 * new Comparator<ArrayList<String>>() {
	 * 
	 * @Override public int compare(ArrayList<String> a, ArrayList<String> b) {
	 * // TODO Auto-generated method stub return a.get(index +
	 * 1).compareTo(b.get(index + 1)); } }); }
	 * 
	 * container = new ArrayList<ArrayList<String>>(); for (int i = 0; i <
	 * super_container.size(); i++) { int counter2 = 1; for (int j = 0; j <
	 * super_container.get(i).size(); j++) {
	 * 
	 * if (j + 1 < super_container.get(i).size() &&
	 * super_container.get(i).get(j).get(index + 1)
	 * .equals(super_container.get(i).get(j + 1).get(index + 1))) {
	 * super_container.get(i).get(j).set(0, super_container.get(i).get(j).get(0)
	 * + ""-"" + counter2); } else { if (j - 1 >= 0 &&
	 * super_container.get(i).get(j).get(index + 1)
	 * .equals(super_container.get(i).get(j - 1).get(index + 1))) {
	 * super_container.get(i).get(j).set(0, super_container.get(i).get(j).get(0)
	 * + ""-"" + counter2); counter2++; } else {
	 * super_container.get(i).get(j).set(0, super_container.get(i).get(j).get(0)
	 * + ""-"" + counter2); } }
	 * 
	 * }
	 * 
	 * } for (int i = 0; i < super_container.size(); i++) { for (int j = 0; j <
	 * super_container.get(i).size(); j++) {
	 * container.add(super_container.get(i).get(j)); } } return container;
	 * 
	 * } catch (FileNotFoundException e) {
	 * 
	 * } catch (IOException e) {
	 * 
	 * } return null; }
	 * 
	 * public void write(ArrayList<ArrayList<String>> sorted) { try { CSVWriter
	 * writer = new CSVWriter(new FileWriter(""./SplitFile.csv""), ',',
	 * CSVWriter.NO_QUOTE_CHARACTER);
	 * 
	 * for (int i = 0; i < sorted.size(); i++) { String[] entries = new
	 * String[sorted.get(i).size()]; for (int j = 0; j < sorted.get(i).size();
	 * j++) { entries[j] = sorted.get(i).get(j); } writer.writeNext(entries);
	 * 
	 * } System.out.println(""Written to the File Successfully""); writer.close();
	 * } catch (IOException e) { System.out.println(""File Name is Already There""
	 * ); } }
	 */
}
"
HighFrequencyFilterConnection.java,log,"package org.processmining.log.connections;

import org.deckfour.xes.model.XLog;
import org.processmining.framework.connections.impl.AbstractConnection;
import org.processmining.log.parameters.HighFrequencyFilterParameters;

public class HighFrequencyFilterConnection extends AbstractConnection {

	public final static String LOG = ""Log"";
	public final static String FILTEREDLOG = ""Filtered log"";

	private HighFrequencyFilterParameters parameters;

	public HighFrequencyFilterConnection(XLog log, XLog filteredLog,
			HighFrequencyFilterParameters parameters) {
		super(""High Frequency Filter Connection"");
		put(LOG, log);
		put(FILTEREDLOG, filteredLog);
		this.parameters = new HighFrequencyFilterParameters(parameters);
	}

	public HighFrequencyFilterParameters getParameters() {
		return parameters;
	}
}
"
LogCentralityConnection.java,log,"package org.processmining.log.connections;

import org.deckfour.xes.model.XLog;
import org.processmining.framework.connections.impl.AbstractConnection;
import org.processmining.log.models.LogCentrality;
import org.processmining.log.parameters.LogCentralityParameters;

public class LogCentralityConnection extends AbstractConnection {

	public final static String LOG = ""Log"";
	public final static String LOGCENTRALITY = ""Log Centrality"";

	private LogCentralityParameters parameters;

	public LogCentralityConnection(XLog log, LogCentrality logCentrality,
			LogCentralityParameters parameters) {
		super(""Log Centrality Connection"");
		put(LOG, log);
		put(LOGCENTRALITY, logCentrality);
		this.parameters = new LogCentralityParameters(parameters);
	}

	public LogCentralityParameters getParameters() {
		return parameters;
	}
}"
LogCentralityFilterConnection.java,log,"package org.processmining.log.connections;

import org.deckfour.xes.model.XLog;
import org.processmining.framework.connections.impl.AbstractConnection;
import org.processmining.log.models.LogCentrality;
import org.processmining.log.parameters.LogCentralityFilterParameters;

public class LogCentralityFilterConnection  extends AbstractConnection {

	public final static String LOG = ""Log"";
	public final static String LOGCENTRALITY = ""Log Centrality"";

	private LogCentralityFilterParameters parameters;

	public LogCentralityFilterConnection(XLog log, LogCentrality logCentrality,
			LogCentralityFilterParameters parameters) {
		super(""Log Centrality Filter Connection"");
		put(LOG, log);
		put(LOGCENTRALITY, logCentrality);
		this.parameters = new LogCentralityFilterParameters(parameters);
	}

	public LogCentralityFilterParameters getParameters() {
		return parameters;
	}
}"
LogFrequencyConnection.java,log,"package org.processmining.log.connections;

import org.deckfour.xes.model.XLog;
import org.processmining.framework.connections.impl.AbstractConnection;
import org.processmining.log.models.LogFrequency;
import org.processmining.log.parameters.LogFrequencyParameters;

public class LogFrequencyConnection extends AbstractConnection {

	public final static String LOG = ""Log"";
	public final static String LOGFREQUENCY = ""Log Frequency"";

	private LogFrequencyParameters parameters;

	public LogFrequencyConnection(XLog log, LogFrequency logFrequency,
			LogFrequencyParameters parameters) {
		super(""Log Frequency Connection"");
		put(LOG, log);
		put(LOGFREQUENCY, logFrequency);
		this.parameters = new LogFrequencyParameters(parameters);
	}

	public LogFrequencyParameters getParameters() {
		return parameters;
	}
}"
LowFrequencyFilterConnection.java,log,"package org.processmining.log.connections;

import org.deckfour.xes.model.XLog;
import org.processmining.framework.connections.impl.AbstractConnection;
import org.processmining.log.parameters.LowFrequencyFilterParameters;

public class LowFrequencyFilterConnection extends AbstractConnection {

	public final static String LOG = ""Log"";
	public final static String FILTEREDLOG = ""Filtered log"";

	private LowFrequencyFilterParameters parameters;

	public LowFrequencyFilterConnection(XLog log, XLog filteredLog,
			LowFrequencyFilterParameters parameters) {
		super(""Low Frequency Filter Connection"");
		put(LOG, log);
		put(FILTEREDLOG, filteredLog);
		this.parameters = new LowFrequencyFilterParameters(parameters);
	}

	public LowFrequencyFilterParameters getParameters() {
		return parameters;
	}
}
"
LowOccurrencesFilterConnection.java,log,"package org.processmining.log.connections;

import org.deckfour.xes.model.XLog;
import org.processmining.framework.connections.impl.AbstractConnection;
import org.processmining.log.parameters.LowOccurrencesFilterParameters;

public class LowOccurrencesFilterConnection extends AbstractConnection {

	public final static String LOG = ""Log"";
	public final static String FILTEREDLOG = ""Filtered log"";

	private LowOccurrencesFilterParameters parameters;

	public LowOccurrencesFilterConnection(XLog log, XLog filteredLog,
			 LowOccurrencesFilterParameters parameters) {
		super(""Low Occurrences Filter Connection"");
		put(LOG, log);
		put(FILTEREDLOG, filteredLog);
		this.parameters = new LowOccurrencesFilterParameters(parameters);
	}

	public  LowOccurrencesFilterParameters getParameters() {
		return parameters;
	}
}
"
AbstractCSVFile.java,log,"package org.processmining.log.csv;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.nio.file.Path;
import java.util.zip.GZIPInputStream;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;

import com.google.common.io.Files;

public abstract class AbstractCSVFile implements CSVFile {

	private final Path file;

	public AbstractCSVFile(Path file) {
		this.file = file;	
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see org.processmining.log.csvimport.ICSVFile#getFile()
	 */
	@Override
	public Path getFile() {
		return file;
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see org.processmining.log.csvimport.ICSVFile#getFilename()
	 */
	@Override
	public String getFilename() {
		return file.getFileName().toString();
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see org.processmining.log.csv.CSVFile#getInputStream()
	 */
	@Override
	public InputStream getInputStream() throws IOException {
		String ext = Files.getFileExtension(getFile().toFile().getName());
		if (ext.equalsIgnoreCase(""csv"") || ext.equalsIgnoreCase(""txt"")) {
			return new FileInputStream(getFile().toFile());
		} else if (ext.equalsIgnoreCase(""zip"")) {
			ZipInputStream zipInputStream = new ZipInputStream(new FileInputStream(getFile().toFile()));
			ZipEntry nextEntry = zipInputStream.getNextEntry();
			if (nextEntry == null) {
				throw new IOException(""ZIP files does not contain any files"");
			}
			return zipInputStream;
		} else if (ext.equalsIgnoreCase(""gz"")) {
			return new GZIPInputStream(new FileInputStream(getFile().toFile()));
		}
		throw new UnsupportedOperationException(""Unsupported file type "" + ext);
	}

}
"
CSVConfig.java,log,"package org.processmining.log.csv.config;

import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStreamReader;
import java.nio.charset.Charset;
import java.util.HashMap;
import java.util.Map;

import org.apache.commons.lang3.StringUtils;
import org.mozilla.universalchardet.UniversalDetector;
import org.processmining.log.csv.CSVFile;
import org.processmining.log.csvimport.exception.CSVConversionException;

/**
 * Configuration for the import of the CSV
 * 
 * @author F. Mannhardt
 *
 */
public final class CSVConfig {
	
	private static final int SEPARATOR_DETECTION_ROW_LIMIT = 10;
	
	private String charset = Charset.defaultCharset().name();
	private CSVSeperator separator = CSVSeperator.COMMA;
	private CSVQuoteCharacter quoteChar = CSVQuoteCharacter.DOUBLE_QUOTE;
	private CSVEscapeCharacter escapeChar = CSVEscapeCharacter.QUOTE;
	
	public CSVConfig() {
	}
	
	public CSVConfig(final CSVFile csvFile) throws CSVConversionException {
		try {
			charset = autoDetectCharset(csvFile);
			separator = autoDetectSeparator(csvFile, charset);
			quoteChar = autoDetectQuote(csvFile, charset);
		} catch (IOException e) {
			throw new CSVConversionException(""Could not auto-detect CSV import parameters."", e);
		}
	}
	
	private static String autoDetectCharset(final CSVFile csvFile) throws FileNotFoundException, IOException {

		final UniversalDetector detector = new UniversalDetector(null);
		
		try (FileInputStream fis = new FileInputStream(csvFile.getFile().toFile())) {
			byte[] buf = new byte[4096];
			int nread;
			while ((nread = fis.read(buf)) > 0 && !detector.isDone()) {
				detector.handleData(buf, 0, nread);
			}
			detector.dataEnd();
		}
		
		if (detector.getDetectedCharset() != null) {
			return detector.getDetectedCharset();
		} else {
			// Nothing detected, assume OS default
			return Charset.defaultCharset().name();
		}
	}

	private static CSVSeperator autoDetectSeparator(final CSVFile csvFile, String charset) throws FileNotFoundException, IOException {
		try (BufferedReader reader = new BufferedReader(new InputStreamReader(new FileInputStream(csvFile.getFile().toFile()), Charset.forName(charset)))) {
			Map<CSVSeperator, Integer> counter = new HashMap<>();
			for (int i = 0; i < SEPARATOR_DETECTION_ROW_LIMIT; i++) {
				String line = reader.readLine();
				if (line == null) {
					break;
				}
				updateCounter(counter, CSVSeperator.COMMA, "","", line);
				updateCounter(counter, CSVSeperator.TAB, ""\t"", line);
				updateCounter(counter, CSVSeperator.SEMICOLON, "";"", line);
			}
			// now check which are still fine
			for (CSVSeperator seperator : counter.keySet()) {
				if (counter.get(seperator) > 1) {
					return seperator;
				}
			}
			// if none of them was properly detected go with inconsistent ones
			for (CSVSeperator seperator : counter.keySet()) {
				if (counter.get(seperator) == -1) {
					return seperator;
				}
			}
		}
		
		// Fall back to default
		return CSVSeperator.COMMA;
	}

	private static void updateCounter(Map<CSVSeperator, Integer> counter, CSVSeperator separator, String token,
			String line) {
		// Remove all text in between quotes as it should be ignored for separator detection 
		String lineWithoutQuotes = removeTextInQuotes(line);
		int matchCount = StringUtils.countMatches(lineWithoutQuotes, token);
		if (counter.get(separator) == null) {
			counter.put(separator, matchCount);
		} else if (counter.get(separator) != matchCount) {
			// Inconsistent number of separator characters
			counter.put(separator, -1);
		}
	}

	private static String removeTextInQuotes(String line) {
		String internalLine = line;
		while (internalLine.contains(""\"""")) {
			int startIndex = internalLine.indexOf(""\"""");
			int endIndex = internalLine.substring(startIndex + 1, internalLine.length()).indexOf(""\"""");
			// now remove the in between part of the string and replace it with some placeholder text
			internalLine = internalLine.substring(0, startIndex) + ""placeholder""
					+ internalLine.substring(startIndex + 1 + endIndex + 1, internalLine.length());
		}
		return internalLine;
	}

	private static CSVQuoteCharacter autoDetectQuote(CSVFile csvFile, String charset) {
		//TODO implement
		return CSVQuoteCharacter.DOUBLE_QUOTE;
	}

	public String getCharset() {
		return charset;
	}

	public void setCharset(String charset) {
		this.charset = charset;
	}

	public CSVSeperator getSeparator() {
		return separator;
	}

	public void setSeparator(CSVSeperator separator) {
		this.separator = separator;
	}

	public CSVQuoteCharacter getQuoteChar() {
		return quoteChar;
	}

	public void setQuoteChar(CSVQuoteCharacter quoteChar) {
		this.quoteChar = quoteChar;
	}

	public CSVEscapeCharacter getEscapeChar() {
		return escapeChar;
	}

	public void setEscapeChar(CSVEscapeCharacter escapeChar) {
		this.escapeChar = escapeChar;
	}
	
}"
CSVEscapeCharacter.java,log,"package org.processmining.log.csv.config;

public enum CSVEscapeCharacter {
	
	QUOTE(""QUOTE (\"")"", '""');
	
	private final String description;
	private final char escapeChar;

	private CSVEscapeCharacter(String description, char escapeCharacter) {
		this.description = description;
		this.escapeChar = escapeCharacter;
	}

	public String toString() {
		return description;
	}

	public char getEscapeChar() {
		return escapeChar;
	}

}
"
CSVQuoteCharacter.java,log,"package org.processmining.log.csv.config;


public enum CSVQuoteCharacter {
	
	SINGLE_QUOTE(""QUOTE (')"", '\''),
	DOUBLE_QUOTE(""DOUBLE QUOTE (\"")"", '""'), 
	NONE(""NONE"", '\0');

	private final String description;
	private final char quoteChar;

	private CSVQuoteCharacter(String description, char quoteCharacter) {
		this.description = description;
		this.quoteChar = quoteCharacter;
	}

	public String toString() {
		return description;
	}

	public char getQuoteChar() {
		return quoteChar;
	}

}
"
CSVSeperator.java,log,"package org.processmining.log.csv.config;


public enum CSVSeperator {
	COMMA(""Comma (,)"", ','), 
	SEMICOLON(""Semicolon (;)"",';'),
	TAB(""Tab"", '\t'),
	WHITESPACE(""Whitespace"",' ');

	private final String description;
	private final char seperatorChar;

	private CSVSeperator(String description, char seperatorChar) {
		this.description = description;
		this.seperatorChar = seperatorChar;
	}

	public String toString() {
		return description;
	}

	public char getSeperatorChar() {
		return seperatorChar;
	}

}"
CSVFile.java,log,"package org.processmining.log.csv;

import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.nio.file.Path;

import org.processmining.log.csv.config.CSVConfig;

/**
 * Interface for a CSV file managed in the ProM environment. Example usage:
 * 
 * <pre>
 * CSVFile file; // get it from a plug-in
 * 
 * // Prepare config with auto guessing of encoding etc.
 * CSVConfig importConfig = new CSVConfig(csvFile);
 * 
 * // Read header
 * try {
 * 	String[] header = csvFile.readHeader(importConfig);
 * } catch (IOException e) {
 * 	// do someting
 * }
 * 
 * // Read content
 * try (ICSVReader reader = csvFile.createReader(importConfig)) {
 * 	while ((nextLine = reader.readNext()) != null) {
 * 		// do something
 * 	}
 * }
 * </pre>
 * 
 * @author F. Mannhardt
 * 
 */
public interface CSVFile {

	/**
	 * @return the complete path to the CSV file (including the file itself)
	 */
	Path getFile();

	/**
	 * @return the filename with extension
	 */
	String getFilename();

	/**
	 * @return input stream of this CSV file
	 * @throws FileNotFoundException
	 * @throws IOException
	 */
	InputStream getInputStream() throws FileNotFoundException, IOException;

	/**
	 * Returns the first row of the CSV file.
	 * 
	 * @param config
	 * @return
	 * @throws IOException
	 */
	String[] readHeader(CSVConfig config) throws IOException;

	/**
	 * Returns a new {@link ICSVReader} that can be used to read through the
	 * input stream. The caller is responsible for calling
	 * {@link ICSVReader#close()} on the reader.
	 * 
	 * @param config
	 * @return
	 * @throws IOException
	 */
	ICSVReader createReader(CSVConfig config) throws IOException;

	/**
	 * @return the CSV reader/writer interface used for this {@link CSVFile}
	 */
	ICSV getCSV();

}"
CSVFileReferenceOpenCSVImpl.java,log,"package org.processmining.log.csv;

import java.io.IOException;
import java.nio.file.Path;

import org.processmining.log.csv.config.CSVConfig;

/**
 * {@link CSVFile} implementation that holds a reference to a CSV file on disk.
 * The {@link CSVFileReferenceUnivocityImpl} is recommended!
 *
 * @author F. Mannhardt
 *
 */
public final class CSVFileReferenceOpenCSVImpl extends AbstractCSVFile {

	private final CSVOpenCSVImpl csv;

	public CSVFileReferenceOpenCSVImpl(Path file) {
		super(file);
		csv = new CSVOpenCSVImpl();
	}

	@Deprecated
	public CSVFileReferenceOpenCSVImpl(Path file, String filename, long fileSizeInBytes) {
		this(file);
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see
	 * org.processmining.log.csv.CSVFile#readHeader(org.processmining.log.csvimport
	 * .CSVImportConfig)
	 */
	@Override
	public String[] readHeader(CSVConfig importConfig) throws IOException {
		return createReader(importConfig).readNext();
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see
	 * org.processmining.log.csv.CSVFile#createReader(org.processmining.log.
	 * csv.CSVConfig)
	 */
	@Override
	public ICSVReader createReader(CSVConfig config) throws IOException {
		return csv.createReader(getInputStream(), config);
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see org.processmining.log.csv.CSVFile#getCSV()
	 */
	@Override
	public ICSV getCSV() {
		return csv;
	}

}
"
CSVFileReferenceUnivocityImpl.java,log,"package org.processmining.log.csv;

import java.io.IOException;
import java.nio.file.Path;

import org.processmining.log.csv.config.CSVConfig;

import com.univocity.parsers.common.TextParsingException;

/**
 * {@link CSVFile} implementation that holds a reference to a CSV file on disk.
 *
 * @author N. Tax
 *
 */
public final class CSVFileReferenceUnivocityImpl extends AbstractCSVFile {
	
	private final CSVUnivocityImpl csv;

	public CSVFileReferenceUnivocityImpl(Path file) {
		super(file);
		csv = new CSVUnivocityImpl();
	}
	
	@Deprecated
	public CSVFileReferenceUnivocityImpl(Path file, String filename, long fileSizeInBytes) {
		this(file);
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see
	 * org.processmining.log.csv.CSVFile#readHeader(org.processmining.log.csvimport
	 * .CSVImportConfig)
	 */
	@Override
	public String[] readHeader(CSVConfig importConfig) throws IOException {
		try {
			return createReader(importConfig).readNext();
		} catch (TextParsingException | IllegalStateException e) {
			// Wrap unchecked Univocity exceptions into a IOException for consistency
			throw new IOException(e);
		}
	}

	/* (non-Javadoc)
	 * @see org.processmining.log.csv.CSVFile#createReader(org.processmining.log.csv.CSVConfig)
	 */
	@Override
	public ICSVReader createReader(CSVConfig config) throws IOException {
		return csv.createReader(getInputStream(), config);
	}

	/* (non-Javadoc)
	 * @see org.processmining.log.csv.CSVFile#getCSV()
	 */
	@Override
	public ICSV getCSV() {
		return csv;
	}
	
}
"
CSVOpenCSVImpl.java,log,"package org.processmining.log.csv;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.UnsupportedEncodingException;

import org.processmining.log.csv.config.CSVConfig;

import au.com.bytecode.opencsv.CSVParser;
import au.com.bytecode.opencsv.CSVReader;
import au.com.bytecode.opencsv.CSVWriter;

public class CSVOpenCSVImpl implements ICSV {
	
	private static final int BUFFER_SIZE = 8192 * 4;

	private static CSVReader createCSVReader(InputStream is, CSVConfig importConfig)
			throws UnsupportedEncodingException {
		if (importConfig.getQuoteChar() == null) {
			return new CSVReader(new BufferedReader(new InputStreamReader(is, importConfig.getCharset()), BUFFER_SIZE),
					importConfig.getSeparator().getSeperatorChar(), CSVParser.DEFAULT_QUOTE_CHARACTER,
					CSVParser.DEFAULT_ESCAPE_CHARACTER, 0, false, false, true);
		} else {
			return new CSVReader(new BufferedReader(new InputStreamReader(is, importConfig.getCharset()), BUFFER_SIZE),
					importConfig.getSeparator().getSeperatorChar(), importConfig.getQuoteChar().getQuoteChar());
		}

	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see
	 * org.processmining.log.csv.CSVFile#createReader(org.processmining.log.
	 * csvimport.CSVImportConfig)
	 */
	@Override
	public ICSVReader createReader(InputStream is, CSVConfig importConfig) throws IOException {
		final CSVReader csvReader = createCSVReader(is, importConfig);
		return new ICSVReader() {

			/* (non-Javadoc)
			 * @see org.processmining.log.csv.AbstractCSVReader#readNext()
			 */
			public String[] readNext() throws IOException {
				return csvReader.readNext();
			}

			/* (non-Javadoc)
			 * @see org.processmining.log.csv.AbstractCSVReader#close()
			 */
			public void close() throws IOException {
				csvReader.close();
			}
			
		};
	}
	
	private static CSVWriter createCSVWriter(OutputStream os, CSVConfig importConfig)
			throws UnsupportedEncodingException {
		return new CSVWriter(new BufferedWriter(new OutputStreamWriter(os, importConfig.getCharset()), BUFFER_SIZE),
				importConfig.getSeparator().getSeperatorChar(), importConfig.getQuoteChar().getQuoteChar());
	}

	public ICSVWriter createWriter(OutputStream os, CSVConfig importConfig) throws IOException {
		final CSVWriter csvWriter = createCSVWriter(os, importConfig);
		return new ICSVWriter() {

			public void writeNext(String[] value) {
				csvWriter.writeNext(value, false);
			}

			public void close() throws IOException {
				csvWriter.close();
			}

			
		};
	}

}
"
CSVUnivocityImpl.java,log,"package org.processmining.log.csv;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.UnsupportedEncodingException;

import org.apache.commons.io.input.BOMInputStream;
import org.processmining.log.csv.config.CSVConfig;

import com.univocity.parsers.csv.CsvParser;
import com.univocity.parsers.csv.CsvParserSettings;
import com.univocity.parsers.csv.CsvWriter;
import com.univocity.parsers.csv.CsvWriterSettings;

public class CSVUnivocityImpl implements ICSV {
	
	private static final int MAX_CHARS_PER_COLUMN = 65536;
	
	private static final int BUFFER_SIZE = 8192 * 4;

	private static CsvParser createCSVReader(InputStream is, CSVConfig importConfig) throws UnsupportedEncodingException{
		CsvParserSettings settings = new CsvParserSettings();
		settings.setMaxCharsPerColumn(MAX_CHARS_PER_COLUMN);
		settings.setLineSeparatorDetectionEnabled(true);
		settings.getFormat().setDelimiter(importConfig.getSeparator().getSeperatorChar());
		settings.getFormat().setQuote(importConfig.getQuoteChar().getQuoteChar());
		settings.getFormat().setCharToEscapeQuoteEscaping(importConfig.getEscapeChar().getEscapeChar());
		CsvParser parser = new CsvParser(settings);
		BOMInputStream bomExcludingStream = new BOMInputStream(is); // exclude BOM byte for UTF-BOM encoded files as those mess up with pretty much everything
		parser.beginParsing(new BufferedReader(new InputStreamReader(bomExcludingStream, importConfig.getCharset()), BUFFER_SIZE));
		return parser;
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see
	 * org.processmining.log.csv.CSVFile#createReader(org.processmining.log.
	 * csvimport.CSVImportConfig)
	 */
	@Override
	public ICSVReader createReader(InputStream is, CSVConfig importConfig) throws IOException {
		final CsvParser csvReader = createCSVReader(is, importConfig);
		return new ICSVReader() {
			
			public String[] readNext() throws IOException {
				return csvReader.parseNext();
			}

			public void close() throws IOException {
				csvReader.stopParsing();
			}
			
		};
	}
	
	private static CsvWriter createCSVWriter(OutputStream os, CSVConfig importConfig) throws UnsupportedEncodingException {
		CsvWriterSettings settings = new CsvWriterSettings();
		settings.getFormat().setDelimiter(importConfig.getSeparator().getSeperatorChar());
		settings.getFormat().setQuote(importConfig.getQuoteChar().getQuoteChar());
		settings.getFormat().setCharToEscapeQuoteEscaping(importConfig.getEscapeChar().getEscapeChar());
		CsvWriter writer = new CsvWriter(new OutputStreamWriter(os, importConfig.getCharset()), settings);
		return writer;
	}

	/* (non-Javadoc)
	 * @see org.processmining.log.csv.CSVFile#createWriter(java.io.OutputStream, org.processmining.log.csvimport.config.CSVImportConfig)
	 */
	@Override
	public ICSVWriter createWriter(OutputStream os, CSVConfig config) throws IOException {
		final CsvWriter writer = createCSVWriter(os, config);
		return new ICSVWriter() {
			
			public void writeNext(String[] value) {
				writer.writeRow((Object[])value);
			}
			
			public void close() throws IOException {				
				writer.close();				
			}
		};
	}

}
"
ICSV.java,log,"package org.processmining.log.csv;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;

import org.processmining.log.csv.config.CSVConfig;

/**
 * Wrapper around some CSV parsing library.
 * 
 * @author F. Mannhardt
 *
 */
public interface ICSV {

	/**
	 * Returns a new {@link ICSVWriter} that can be used to write data to a new
	 * {@link OutputStream} in CSV format. The caller is responsible for calling
	 * {@link ICSVWriter#close()} on the writer.
	 * 
	 * @param os
	 * @param config
	 * @return
	 * @throws IOException
	 */
	ICSVWriter createWriter(OutputStream os, CSVConfig config) throws IOException;

	/**
	 * Returns a new {@link ICSVReader} that can be used to read data from the
	 * {@link InputStream} in CSV format. The caller is responsible for calling
	 * {@link ICSVReader#close()} on the writer.
	 * 
	 * @param os
	 * @param config
	 * @return
	 * @throws IOException
	 */
	ICSVReader createReader(InputStream is, CSVConfig config) throws IOException;

}
"
ICSVReader.java,log,"package org.processmining.log.csv;

import java.io.IOException;

/**
 * Reader of a CSV file
 * 
 * @author F. Mannhardt
 *
 */
public interface ICSVReader extends AutoCloseable {

	/**
	 * @return the next line or NULL in case of EOF
	 * @throws IOException
	 */
	String[] readNext() throws IOException;

	/* (non-Javadoc)
	 * @see java.lang.AutoCloseable#close()
	 */
	void close() throws IOException;

}
"
ICSVWriter.java,log,"package org.processmining.log.csv;

import java.io.IOException;

public interface ICSVWriter {

	void writeNext(String[] value);
	
	void close() throws IOException;
	
}
"
CSVViewer.java,log,"package org.processmining.log.csv.plugin;

import javax.swing.JComponent;

import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.contexts.uitopia.annotations.Visualizer;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginLevel;
import org.processmining.log.csv.CSVFile;
import org.processmining.log.csv.config.CSVConfig;
import org.processmining.log.csvimport.exception.CSVConversionException;

public class CSVViewer {

	@Plugin(name = ""View CSV"", level = PluginLevel.Regular, //
	parameterLabels = { ""CSV"" }, returnLabels = { ""XES Event Log"" }, // 
	returnTypes = { JComponent.class }, userAccessible = true)
	@Visualizer
	public JComponent viewCSV(final UIPluginContext context, final CSVFile csvFile) throws CSVConversionException {
		return new CSVViewerPanel(csvFile, new CSVConfig(csvFile));
	}

}
"
CSVViewerPanel.java,log,"package org.processmining.log.csv.plugin;

import java.awt.Font;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.io.IOException;
import java.nio.charset.Charset;
import java.util.List;

import javax.swing.BoxLayout;
import javax.swing.GroupLayout;
import javax.swing.GroupLayout.Alignment;
import javax.swing.GroupLayout.ParallelGroup;
import javax.swing.GroupLayout.SequentialGroup;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.SwingConstants;
import javax.swing.SwingWorker;

import org.processmining.framework.util.ui.widgets.ProMComboBox;
import org.processmining.framework.util.ui.widgets.helper.ProMUIHelper;
import org.processmining.log.csv.CSVFile;
import org.processmining.log.csv.ICSVReader;
import org.processmining.log.csv.config.CSVConfig;
import org.processmining.log.csv.config.CSVQuoteCharacter;
import org.processmining.log.csv.config.CSVSeperator;
import org.processmining.log.csvimport.ui.preview.CSVPreviewPanel;

import com.fluxicon.slickerbox.factory.SlickerFactory;

/**
 * CSV Viewer
 * 
 * @author F. Mannhardt
 *
 */
final class CSVViewerPanel extends JPanel {

	private static final long serialVersionUID = 2L;

	private static final int MAX_PREVIEW = 1000;
	private static final int COLUMN_WIDTH = 240;

	private final CSVFile csv;
	private final CSVConfig importConfig;

	private final ProMComboBox<String> charsetCbx;
	private final ProMComboBox<CSVSeperator> separatorField;
	private final ProMComboBox<CSVQuoteCharacter> quoteField;

	private final CSVPreviewPanel previewPanel;

	private SwingWorker<Void, String[]> worker;

	public CSVViewerPanel(final CSVFile csv, final CSVConfig importConfig) {
		super();
		this.importConfig = importConfig;
		this.csv = csv;
		this.previewPanel = new CSVPreviewPanel();

		setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));
		setOpaque(false);

		JLabel header = new JLabel(
				""<HTML><H2>Read-only CSV Viewer</H2>""
				+ ""<H3>This visualization is a read-only preview of the CSV file. Please use plug-in 'Convert CSV to XES' for conversion to XES</H3></HTML>"");
		header.setAlignmentX(CENTER_ALIGNMENT);

		add(header);

		JPanel topPanel = new JPanel();

		GroupLayout layout = new GroupLayout(topPanel);
		layout.setAutoCreateContainerGaps(true);
		layout.setAutoCreateGaps(true);

		topPanel.setOpaque(false);
		topPanel.setLayout(layout);

		JPanel charsetPanel = new JPanel();
		charsetPanel.setOpaque(false);
		charsetPanel.setLayout(new BoxLayout(charsetPanel, BoxLayout.Y_AXIS));
		charsetCbx = new ProMComboBox<>(Charset.availableCharsets().keySet());
		charsetCbx.setSelectedItem(importConfig.getCharset());
		charsetCbx.setPreferredSize(null);
		charsetCbx.setMinimumSize(null);
		JLabel charsetLabel = createLabel(""Charset"", ""Configure the character encoding that is used by the CSV file"");
		charsetLabel.setAlignmentX(LEFT_ALIGNMENT);
		charsetCbx.setAlignmentX(LEFT_ALIGNMENT);
		charsetPanel.add(charsetLabel);
		charsetPanel.add(charsetCbx);
		charsetCbx.addActionListener(new ActionListener() {

			public void actionPerformed(ActionEvent e) {
				importConfig.setCharset(charsetCbx.getSelectedItem().toString());
				refreshPreview();
			}
		});

		JPanel separatorPanel = new JPanel();
		separatorPanel.setOpaque(false);
		separatorPanel.setLayout(new BoxLayout(separatorPanel, BoxLayout.Y_AXIS));
		separatorField = new ProMComboBox<>(CSVSeperator.values());
		separatorField.setPreferredSize(null);
		separatorField.setMinimumSize(null);
		separatorField.setSelectedItem(importConfig.getSeparator());
		JLabel seperationLabel = createLabel(""Separator Character"",
				""Configure the character that is used by the CSV file to separate two fields"");
		seperationLabel.setAlignmentX(LEFT_ALIGNMENT);
		separatorField.setAlignmentX(LEFT_ALIGNMENT);
		separatorPanel.add(seperationLabel);
		separatorPanel.add(separatorField);
		separatorField.addActionListener(new ActionListener() {

			public void actionPerformed(ActionEvent e) {
				importConfig.setSeparator(((CSVSeperator) separatorField.getSelectedItem()));
				refreshPreview();
			}
		});

		JPanel quotePanel = new JPanel();
		quotePanel.setOpaque(false);
		quotePanel.setLayout(new BoxLayout(quotePanel, BoxLayout.Y_AXIS));
		quoteField = new ProMComboBox<>(CSVQuoteCharacter.values());
		quoteField.setPreferredSize(null);
		quoteField.setMinimumSize(null);
		quoteField.setSelectedItem(importConfig.getQuoteChar());
		JLabel quoteLabel = createLabel(
				""Quote Character"",
				""Configure the character that is used by the CSV file that is used to quote values if they contain the separator character or a newline"");
		quoteLabel.setAlignmentX(LEFT_ALIGNMENT);
		quoteField.setAlignmentX(LEFT_ALIGNMENT);
		quotePanel.add(quoteLabel);
		quotePanel.add(quoteField);
		quoteField.addActionListener(new ActionListener() {

			public void actionPerformed(ActionEvent e) {
				importConfig.setQuoteChar((CSVQuoteCharacter) quoteField.getSelectedItem());
				refreshPreview();
			}
		});		

		ParallelGroup verticalGroup = layout.createParallelGroup().addComponent(charsetPanel, Alignment.TRAILING)
				.addComponent(separatorPanel, Alignment.TRAILING).addComponent(quotePanel, Alignment.TRAILING);

		SequentialGroup horizontalGroup = layout.createSequentialGroup()
				.addComponent(charsetPanel, COLUMN_WIDTH, COLUMN_WIDTH, COLUMN_WIDTH)
				.addComponent(separatorPanel, COLUMN_WIDTH, COLUMN_WIDTH, COLUMN_WIDTH)
				.addComponent(quotePanel, COLUMN_WIDTH, COLUMN_WIDTH, COLUMN_WIDTH);

		layout.linkSize(SwingConstants.HORIZONTAL, separatorPanel, charsetPanel, quotePanel);

		layout.setAutoCreateContainerGaps(true);
		layout.setAutoCreateGaps(true);

		layout.setVerticalGroup(verticalGroup);
		layout.setHorizontalGroup(horizontalGroup);

		add(topPanel);
		add(previewPanel);
		refreshPreview();
	}

	private void refreshPreview() {

		if (worker != null) {
			worker.cancel(true);
		}

		previewPanel.clear();

		// Update Header
		try {
			previewPanel.setHeader(csv.readHeader(importConfig));
		} catch (IOException | ArrayIndexOutOfBoundsException e) {
			ProMUIHelper.showWarningMessage(this, ""Error parsing CSV "" + e.getMessage(), ""CSV Parsing Error"");
			return;
		}

		worker = new SwingWorker<Void, String[]>() {

			protected Void doInBackground() throws Exception {

				try (ICSVReader reader = csv.createReader(importConfig)) {
					// Skip header
					reader.readNext();
					String[] nextLine;
					int i = 0;
					while ((nextLine = reader.readNext()) != null && i < MAX_PREVIEW) {
						publish(nextLine);
						i++;
					}
				}

				return null;
			}

			protected void process(List<String[]> chunks) {
				for (String[] row : chunks) {
					previewPanel.addRow(row);
				}
			}

		};

		try {
			worker.execute();
		} catch (Exception e) {
			JOptionPane.showMessageDialog(this, ""Error parsing CSV "" + e.getMessage(), ""CSV Parsing Error"",
					JOptionPane.ERROR_MESSAGE);
		}
	}

	private static JLabel createLabel(String caption, String description) {
		JLabel eventLabel = SlickerFactory.instance().createLabel(
				""<HTML><B>"" + caption + ""</B><BR/><I>"" + description + ""</I></HTML>"");
		eventLabel.setFont(eventLabel.getFont().deriveFont(Font.PLAIN));
		return eventLabel;
	}

}"
CSVExportPlugin.java,log,"package org.processmining.log.csvexport;

import java.io.File;
import java.io.IOException;

import org.processmining.contexts.uitopia.annotations.UIExportPlugin;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginLevel;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.log.csv.CSVFile;

import com.google.common.io.Files;

/**
 * Exports a CSVFile
 * 
 * @author F. Mannhardt
 *
 */
@Plugin(name = ""Export CSV"", returnLabels = {}, returnTypes = {},
		level = PluginLevel.Regular, parameterLabels = { ""CSVFile"", ""File"" }, userAccessible = true)
@UIExportPlugin(description = ""Export CSV"", extension = ""csv"")
public final class CSVExportPlugin  {

	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""F. Mannhardt"", email = ""f.mannhardt@tue.nl"")
	@PluginVariant(requiredParameterLabels = { 0, 1 }, variantLabel = ""Export CSV File"")
	public void export(PluginContext context, CSVFile csvFile, File file) throws IOException {
		Files.copy(csvFile.getFile().toFile(), file);
	}
}
"
ExportLogCsv.java,log,"package org.processmining.log.csvexport;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;

import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.extension.std.XLifecycleExtension;
import org.deckfour.xes.factory.XFactory;
import org.deckfour.xes.factory.XFactoryRegistry;
import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.deckfour.xes.out.XSerializer;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.contexts.uitopia.annotations.UIExportPlugin;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginLevel;
import org.processmining.framework.plugin.annotations.PluginVariant;

@Plugin(name = ""Export Log to CSV File"", level= PluginLevel.PeerReviewed, parameterLabels = { ""Log"", ""File"" }, returnLabels = {}, returnTypes = {}, userAccessible = true)
@UIExportPlugin(description = ""CSV files"", extension = ""csv"")
public final class ExportLogCsv {
	
//TODO: Export plug-in cannot show any Dialog :(
	
/*	private class DateFormatPanel extends BorderPanel {

		private static final long serialVersionUID = -6547392010448275699L;
		private final ProMTextField dateFormatTextField;

		public DateFormatPanel() {
			super(0, 0);
			dateFormatTextField = new ProMTextField(""yyyy-MM-dd'T'HH:mm:ssZ"");
			add(dateFormatTextField);
		}	
		
		public String getDateFormat() {
			return dateFormatTextField.getText().trim();		
		}

		public InteractionResult getUserChoice(UIPluginContext context) {
			return context.showConfiguration(""Specify date format"", this);
		}

	}*/
	
	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""F. Mannhardt, M. de Leoni"", email = ""m.d.leoni@tue.nl"")
	@PluginVariant(requiredParameterLabels = { 0, 1 }, variantLabel = ""Export Log to CSV File"")
	public void export(UIPluginContext context, XLog log, File file) throws IOException {
		FileOutputStream out = new FileOutputStream(file);

		long instanceNumber=1;

		//final XLog result = XFactoryRegistry.instance().currentDefault().createLog(log.getAttributes());
		final XLifecycleExtension lfExt = XLifecycleExtension.instance();
		final XFactory factory=XFactoryRegistry.instance().currentDefault();
		final XConceptExtension cpExt=XConceptExtension.instance();
		final HashMap<String,List<Long>> map=new HashMap<String, List<Long>>();
		String activityName;
		
		for (XTrace trace : log) {
			map.clear();
			for (XEvent event : trace) {
				switch(lfExt.extractStandardTransition(event))
				{
					case START :
						activityName=cpExt.extractName(event);
						if (activityName!=null)
						{
							//event=factory.createEvent(e.getAttributes());
							if (cpExt.extractInstance(event)==null)
							{						
								List<Long> listInstances=map.get(activityName);
								if (listInstances==null)
								{
									listInstances=new LinkedList<Long>();
									map.put(activityName, listInstances);
								}
								cpExt.assignInstance(event, String.valueOf(instanceNumber));
								listInstances.add(instanceNumber++);
							}
						}
						break;					
					case COMPLETE :
						activityName=cpExt.extractName(event);
						if (activityName!=null)
						{
							event=factory.createEvent(event.getAttributes());							
							if (cpExt.extractInstance(event)==null)
							{
								List<Long> listInstances=map.get(activityName);
								if (listInstances==null || listInstances.isEmpty())									
									cpExt.assignInstance(event, String.valueOf(instanceNumber++));
								else
								{
									cpExt.assignInstance(event, String.valueOf(listInstances.remove(0)));
								}
							}
						}
						break;
					default :
						//event=null;
						break;
				}
				//copy.add(event);
			}
		}
		XSerializer logSerializer = new XesCsvSerializer(""yyyy/MM/dd HH:mm:ss.SSS"");
		logSerializer.serialize(log, out);
		out.close();	
	}
}
"
XesCsvSerializer.java,log,"package org.processmining.log.csvexport;

import java.io.IOException;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.ListIterator;
import java.util.Map;
import java.util.Set;

import org.apache.commons.lang3.time.FastDateFormat;
import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.extension.std.XLifecycleExtension;
import org.deckfour.xes.extension.std.XLifecycleExtension.StandardModel;
import org.deckfour.xes.extension.std.XTimeExtension;
import org.deckfour.xes.info.XAttributeInfo;
import org.deckfour.xes.info.XLogInfo;
import org.deckfour.xes.info.XLogInfoFactory;
import org.deckfour.xes.logging.XLogging;
import org.deckfour.xes.model.XAttribute;
import org.deckfour.xes.model.XAttributeTimestamp;
import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.deckfour.xes.out.XSerializer;
import org.processmining.log.utils.XUtils;

import au.com.bytecode.opencsv.CSVWriter;

/**
 * XES serialization to CSV including all trace/event attributes. The names of
 * trace attributes are prefixed with ""trace_"", those of event attributes are
 * prefixed with ""event_"".
 *
 * @author F. Mannhardt
 *
 */
public final class XesCsvSerializer implements XSerializer {

	private final FastDateFormat dateFormat;

	public XesCsvSerializer(String dateFormatString) {
		super();
		dateFormat = FastDateFormat.getInstance(dateFormatString);
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see org.deckfour.xes.out.XesSerializer#getDescription()
	 */
	public String getDescription() {
		return ""XES CSV Serialization"";
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see org.deckfour.xes.out.XesSerializer#getName()
	 */
	public String getName() {
		return ""XES CSV"";
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see org.deckfour.xes.out.XesSerializer#getAuthor()
	 */
	public String getAuthor() {
		return ""F. Mannhardt"";
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see org.deckfour.xes.out.XesSerializer#getSuffices()
	 */
	public String[] getSuffices() {
		return new String[] { ""csv"" };
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see
	 * org.deckfour.xes.out.XesSerializer#serialize(org.deckfour.xes.model.XLog,
	 * java.io.OutputStream)
	 */
	public void serialize(XLog log, OutputStream out) throws IOException {
		XLogging.log(""start serializing log to .csv"", XLogging.Importance.DEBUG);
		long start = System.currentTimeMillis();

		CSVWriter writer = new CSVWriter(new OutputStreamWriter(out, ""UTF-8""));
		Map<String, Integer> columnMap = new HashMap<String, Integer>();

		String[] header = compileHeader(log, columnMap);
		writer.writeNext(header);

		for (XTrace trace : log) {
			writer.writeAll(compileTrace(trace, columnMap, header.length));
		}

		writer.close();
		String duration = "" ("" + (System.currentTimeMillis() - start) + "" msec.)"";
		XLogging.log(""finished serializing log"" + duration, XLogging.Importance.DEBUG);
	}

	private List<String[]> compileTrace(XTrace trace, Map<String, Integer> columnMap, int rowLength) {
		List<String[]> traceList = new ArrayList<String[]>();
		String[] currentRow = null;
		Set<XEvent> convertedEvents = new HashSet<>();
		for (ListIterator<XEvent> iterator = trace.listIterator(); iterator.hasNext();) {
			XEvent event = iterator.next();
			if (!convertedEvents.contains(event)) {
				StandardModel lifecycle = XLifecycleExtension.instance().extractStandardTransition(event);
				if (lifecycle == null) {
					// treat as complete
					currentRow = compileEvent(trace, null, event, columnMap, rowLength, currentRow);
					convertedEvents.add(event);
				} else if (lifecycle == StandardModel.START) {
					XEvent completionEvent = null;
					if (lifecycle == StandardModel.START) {
						completionEvent = lookup(trace.listIterator(iterator.nextIndex()), event,
								StandardModel.COMPLETE);
					}
					currentRow = compileEvent(trace, event, completionEvent, columnMap, rowLength, currentRow);
					convertedEvents.add(event);
					if (completionEvent != null) {
						convertedEvents.add(completionEvent);
					}
				} else if (lifecycle == StandardModel.COMPLETE) {
					//XEvent startEvent = null;
					//MASSIMILIANO: Not sure what the aim: if lifecycle==COMPLETE, we are in this block. Hence, lifecycle cannot be
					//START. Therefore, we never enter the loop below.
					/*if (lifecycle == StandardModel.START) {
						startEvent = lookup(trace.listIterator(iterator.nextIndex()), event, StandardModel.START);
					}*/
					currentRow = compileEvent(trace, null, event, columnMap, rowLength, currentRow);
					convertedEvents.add(event);

					//MASSIMILIANO: I've removed the following part. I have the feeling that you're trying to map with some
					//start event following the complete. This would mean that the end event might be larger than the start event.
					/*convertedEvents.add(event);
					if (startEvent != null) {
						convertedEvents.add(startEvent);*/
				//}
				} else {
					// ignore we only export start and complete
				}
			traceList.add(currentRow);
			}
		}
		return traceList;
	}

	private XEvent lookup(ListIterator<XEvent> listIterator, XEvent event, StandardModel model) {
		XConceptExtension concept = XConceptExtension.instance();
		String eventInstance = concept.extractInstance(event);
		while (listIterator.hasNext()) {
			XEvent e = listIterator.next();
			if (eventInstance != null && eventInstance.equals(concept.extractInstance(e))) {
				StandardModel lifecycle = XLifecycleExtension.instance().extractStandardTransition(e);
				if (lifecycle == model) {
					return e;
				}
			}
		}
		return null;
	}

	private String[] compileEvent(XTrace trace, XEvent startEvent, XEvent completionEvent,
			Map<String, Integer> columnMap, int rowLength, String[] lastRow) {
		XEvent mainEvent = completionEvent != null ? completionEvent : startEvent;
		String[] row = new String[rowLength];
		row[0] = XConceptExtension.instance().extractName(trace);
		row[1] = XConceptExtension.instance().extractName(mainEvent);
		if (startEvent != null) {
			Date date = XTimeExtension.instance().extractTimestamp(startEvent);
			if (date != null) {
				row[2] = dateFormat.format(date);
			}
		} else {
			Date date = XTimeExtension.instance().extractTimestamp(completionEvent);
			if (date != null) {
				row[2] = dateFormat.format(date);
			}
		}
		if (completionEvent != null) {
			Date date = XTimeExtension.instance().extractTimestamp(completionEvent);
			if (date != null) {
				row[3] = dateFormat.format(date);
			}
		} else {
			Date date = XTimeExtension.instance().extractTimestamp(startEvent);
			if (date != null) {
				row[3] = dateFormat.format(date);
			}
		}

		for (XAttribute attr : trace.getAttributes().values()) {
			if (!XUtils.isStandardExtensionAttribute(attr) || attr.getKey().startsWith(""org:"")) {
				assert columnMap.containsKey(""trace_"" + attr.getKey()) : ""Column unkown "" + attr.getKey();
				row[columnMap.get(""trace_"" + attr.getKey())] = convertAttribute(attr);
			}
		}
		for (XAttribute attr : mainEvent.getAttributes().values()) {
			if (!XUtils.isStandardExtensionAttribute(attr) || attr.getKey().startsWith(""org:"")) {
				assert columnMap.containsKey(""event_"" + attr.getKey()) : ""Column unkown "" + attr.getKey();
				row[columnMap.get(""event_"" + attr.getKey())] = convertAttribute(attr);
			}
		}
		if (lastRow != null) {
			for (int i = 0; i < row.length; i++) {
				if (row[i] == null) {
					row[i] = lastRow[i];
				}
			}
		}
		return row;
	}

	private String[] compileHeader(XLog log, Map<String, Integer> columnMap) {
		XLogInfo logInfo = XLogInfoFactory.createLogInfo(log);

		List<String> headerList = new ArrayList<String>();
		headerList.add(""case"");
		headerList.add(""event"");
		headerList.add(""startTime"");
		headerList.add(""completeTime"");

		int i = headerList.size() - 1;
		XAttributeInfo traceAttributeInfo = logInfo.getTraceAttributeInfo();
		for (XAttribute attr : traceAttributeInfo.getAttributes()) {
			if (!XUtils.isStandardExtensionAttribute(attr) || attr.getKey().startsWith(""org:"")) {
				i++;
				headerList.add(attr.getKey());
				columnMap.put(""trace_"" + attr.getKey(), i);
			}
		}
		XAttributeInfo eventAttributeInfo = logInfo.getEventAttributeInfo();
		for (XAttribute attr : eventAttributeInfo.getAttributes() ) {
			if (!XUtils.isStandardExtensionAttribute(attr) || attr.getKey().startsWith(""org:"")) {
				i++;
				if (headerList.contains(attr.getKey())) {
					headerList.add(""event_"" + attr.getKey());
					columnMap.put(""event_"" + attr.getKey(), i);
				} else {
					headerList.add(attr.getKey());
					columnMap.put(""event_"" + attr.getKey(), i);
				}
			}
		}
		return headerList.toArray(new String[headerList.size()]);
	}

	/**
	 * Helper method, returns the String representation of the attribute
	 *
	 * @param attribute
	 *            The attributes to convert
	 */
	protected String convertAttribute(XAttribute attribute) {
		if (attribute instanceof XAttributeTimestamp) {
			Date timestamp = ((XAttributeTimestamp) attribute).getValue();
			return dateFormat.format(timestamp);
		} else {
			return attribute.toString();
		}
	}

	/**
	 * toString() defaults to getName().
	 */
	public String toString() {
		return this.getName();
	}

}
"
CSVConversionConfig.java,log,"package org.processmining.log.csvimport.config;

import java.io.IOException;
import java.text.DateFormat;
import java.text.DecimalFormat;
import java.text.Format;
import java.text.MessageFormat;
import java.text.ParsePosition;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Set;
import java.util.regex.Pattern;

import org.deckfour.xes.extension.XExtension;
import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.extension.std.XCostExtension;
import org.deckfour.xes.extension.std.XLifecycleExtension;
import org.deckfour.xes.extension.std.XOrganizationalExtension;
import org.deckfour.xes.extension.std.XTimeExtension;
import org.deckfour.xes.factory.XFactory;
import org.deckfour.xes.factory.XFactoryRegistry;
import org.deckfour.xes.model.XAttribute;
import org.processmining.log.csv.CSVFile;
import org.processmining.log.csv.ICSVReader;
import org.processmining.log.csv.config.CSVConfig;
import org.processmining.log.csvimport.exception.CSVConversionException;
import org.processmining.log.formats.StandardDateFormats;

import com.google.common.collect.ImmutableList;

/**
 * Configuration regarding the conversion of the CSV file.
 * 
 * @author F. Mannhardt
 * 
 */
public final class CSVConversionConfig {

	private static final int DATA_TYPE_FORMAT_AUTO_DETECT_NUM_LINES = 5000;

	private static final Set<String> CASE_COLUMN_IDS = new HashSet<String>() {
		private static final long serialVersionUID = 1113995381788343439L;
		{
			add(""case"");
			add(""trace"");
			add(""traceid"");
			add(""caseid"");
		}
	};

	private static final Set<String> EVENT_COLUMN_IDS = new HashSet<String>() {
		private static final long serialVersionUID = -4218883319932959922L;
		{
			add(""event"");
			add(""eventname"");
			add(""activity"");
			add(""eventid"");
			add(""activityid"");
			add(""task"");
			add(""action"");
			add(""actie"");
		}
	};

	private static final Set<String> START_TIME_COLUMN_IDS = new HashSet<String>() {
		private static final long serialVersionUID = 6419129336151793063L;
		{
			add(""starttime"");
			add(""startdate"");
			add(""datumtijdbegin"");
		}
	};

	private static final Set<String> COMPLETION_TIME_COLUMN_IDS = new HashSet<String>() {
		private static final long serialVersionUID = 6419129336151793063L;
		{
			add(""timecomplete"");
			add(""completetime"");
			add(""completiontime"");
			add(""time"");
			add(""date"");
			add(""enddate"");
			add(""endtime"");
			add(""timestamp"");
			add(""datetime"");
			add(""date"");
			add(""eventtime"");
			add(""eindtijd"");
			add(""tijd"");
			add(""datum"");
			add(""datumtijdeind"");
		}
	};

	public static final class ExtensionAttribute {

		public ExtensionAttribute(String key, XExtension extension) {
			this.key = key;
			this.extension = extension;
		}

		public XExtension extension;
		public String key;

		public String toString() {
			if (key != null) {
				return String.format(""%s (%s)"", key, extension.getName());
			} else {
				return """";
			}
		}

		public int hashCode() {
			final int prime = 31;
			int result = 1;
			result = prime * result + ((extension == null) ? 0 : extension.hashCode());
			result = prime * result + ((key == null) ? 0 : key.hashCode());
			return result;
		}

		public boolean equals(Object obj) {
			if (this == obj)
				return true;
			if (obj == null)
				return false;
			if (getClass() != obj.getClass())
				return false;
			ExtensionAttribute other = (ExtensionAttribute) obj;
			if (extension == null) {
				if (other.extension != null)
					return false;
			} else if (!extension.equals(other.extension))
				return false;
			if (key == null) {
				if (other.key != null)
					return false;
			} else if (!key.equals(other.key))
				return false;
			return true;
		}

	}

	public static final ExtensionAttribute NO_EXTENSION_ATTRIBUTE = new ExtensionAttribute(null, null);
	public static final ExtensionAttribute[] AVAILABLE_EVENT_EXTENSIONS_ATTRIBUTES;
	static {
		List<ExtensionAttribute> list = new ArrayList<>();
		list.add(NO_EXTENSION_ATTRIBUTE);
		addAttributesFromExtension(XConceptExtension.instance(), XConceptExtension.instance().getEventAttributes(),
				list);
		addAttributesFromExtension(XOrganizationalExtension.instance(),
				XOrganizationalExtension.instance().getEventAttributes(), list);
		addAttributesFromExtension(XTimeExtension.instance(), XTimeExtension.instance().getEventAttributes(), list);
		addAttributesFromExtension(XLifecycleExtension.instance(), XLifecycleExtension.instance().getEventAttributes(),
				list);
		addAttributesFromExtension(XCostExtension.instance(), XCostExtension.instance().getEventAttributes(), list);
		AVAILABLE_EVENT_EXTENSIONS_ATTRIBUTES = list.toArray(new ExtensionAttribute[list.size()]);
	}

	private static void addAttributesFromExtension(XExtension extension, Collection<XAttribute> attributes,
			List<ExtensionAttribute> list) {
		for (XAttribute attr : attributes) {
			list.add(new ExtensionAttribute(attr.getKey(), extension));
		}
	}

	public enum CSVErrorHandlingMode {
		ABORT_ON_ERROR(""Stop on Error""), OMIT_TRACE_ON_ERROR(""Omit Trace on Error""), OMIT_EVENT_ON_ERROR(
				""Omit Event on Error""), BEST_EFFORT(""Omit Attribute on Error"");

		private String desc;

		CSVErrorHandlingMode(String desc) {
			this.desc = desc;
		}

		@Override
		public String toString() {
			return desc;
		}
	}

	public enum CSVAttributeConversionMode {
		ADD_TO_COMPLETE(""Add attributes to complete event""), ADD_TO_BOTH(
				""Add attributes to both start and complete event"");

		private String desc;

		CSVAttributeConversionMode(String desc) {
			this.desc = desc;
		}

		@Override
		public String toString() {
			return desc;
		}
	}

	public enum CSVEmptyCellHandlingMode {
		DENSE(""Dense (Include empty cells)""), SPARSE(""Sparse (Exclude empty cells)"");

		private String desc;

		CSVEmptyCellHandlingMode(String desc) {
			this.desc = desc;
		}

		@Override
		public String toString() {
			return desc;
		}

	}

	public enum Datatype {
		LITERAL, DISCRETE, CONTINUOUS, TIME, BOOLEAN
	}

	public static final class CSVMapping {

		public static final String DEFAULT_DATE_PATTERN = """";
		public static final String DEFAULT_DISCRETE_PATTERN = """";
		public static final String DEFAULT_CONTINUOUS_PATTERN = """";
		public static final String DEFAULT_LITERAL_PATTERN = """";

		private Datatype dataType = Datatype.LITERAL;
		private String dataPattern = """";
		private DateFormat cachedDateFormat = null;
		private String traceAttributeName = """";
		private String eventAttributeName = """";
		private ExtensionAttribute eventExtensionAttribute = NO_EXTENSION_ATTRIBUTE;

		public Datatype getDataType() {
			return dataType;
		}

		public void setDataType(Datatype dataType) {
			this.dataType = dataType;
		}

		public String getPattern() {
			return dataPattern;
		}

		/**
		 * @return a format to parse the value, which might be NOT be thread safe
		 */
		public Format getFormat() {
			switch (getDataType()) {
				case BOOLEAN :
					return null;
				case CONTINUOUS :
					if (dataPattern.isEmpty()) {
						return null;
					} else {
						return new DecimalFormat(dataPattern);
					}
				case DISCRETE :
					if (dataPattern.isEmpty()) {
						return null;
					} else {
						DecimalFormat integerFormat = new DecimalFormat(dataPattern);
						integerFormat.setMaximumFractionDigits(0);
						integerFormat.setDecimalSeparatorAlwaysShown(false);
						integerFormat.setParseIntegerOnly(true);
						return integerFormat;
					}
				case LITERAL :
					if (dataPattern.isEmpty()) {
						return null;
					} else {
						return new MessageFormat(dataPattern);
					}
				case TIME :
					if (dataPattern.isEmpty()) {
						return null;
					} else {
						if (cachedDateFormat == null) {
							cachedDateFormat = new SimpleDateFormat(dataPattern);
						} 
						return cachedDateFormat; 
					}
			}
			throw new RuntimeException(""Unkown data type "" + getDataType());
		}

		public void setPattern(String dataPattern) {
			this.dataPattern = dataPattern;
			this.cachedDateFormat = null;
		}

		public String getTraceAttributeName() {
			return traceAttributeName;
		}

		public void setTraceAttributeName(String traceAttributeName) {
			this.traceAttributeName = traceAttributeName;
		}

		public String getEventAttributeName() {
			return eventAttributeName;
		}

		public void setEventAttributeName(String eventAttributeName) {
			this.eventAttributeName = eventAttributeName;
		}

		public void setEventExtensionAttribute(ExtensionAttribute extensionAttribute) {
			this.eventExtensionAttribute = extensionAttribute;
		}

		public ExtensionAttribute getEventExtensionAttribute() {
			return eventExtensionAttribute;
		}

	}

	// XFactory to use for conversion if XESConversionHandler is used
	private XFactory factory = XFactoryRegistry.instance().currentDefault();

	// Mapping to some of the XES standard extensions
	private List<String> caseColumns = Collections.emptyList();
	private List<String> eventNameColumns = Collections.emptyList();
	private String completionTimeColumn = null; // may be NULL
	private String startTimeColumn = null; // may be NULL

	// How to concatenate attributes built from multiple columns
	private String compositeAttributeSeparator = ""|"";

	// Data-type mapping
	private Map<String, CSVMapping> conversionMap = new HashMap<>();

	// Various ""expert"" configuration options	
	private CSVErrorHandlingMode errorHandlingMode = CSVErrorHandlingMode.OMIT_TRACE_ON_ERROR;
	private CSVEmptyCellHandlingMode emptyCellHandlingMode = CSVEmptyCellHandlingMode.SPARSE;
	private Set<String> treatAsEmptyValues = new HashSet<>();
	private boolean shouldAddStartEventAttributes = true;

	// Internal only
	private final CSVFile csvFile;
	private final CSVConfig csvConfig;

	public CSVConversionConfig(CSVFile csvFile, CSVConfig csvConfig) throws CSVConversionException {
		this.csvFile = csvFile;
		this.csvConfig = csvConfig;

		try {
			String[] headers = csvFile.readHeader(csvConfig);
			for (String columnHeader : headers) {
				CSVMapping mapping = new CSVMapping();
				if (!conversionMap.containsKey(columnHeader) && columnHeader != null) {
					// We do not support duplicate column names or empty column names!
					mapping.setEventAttributeName(columnHeader);
					conversionMap.put(columnHeader, mapping);
				} else {
					if (columnHeader == null) {
						throw new CSVConversionException(MessageFormat.format(
								""The CSV file contains two columns with an empty name! The CSV importer cannot handle such CSV files. Please rename the columns (i.e., the first line of the CSV file) such that columns have unique names."",
								columnHeader));
					} else {
						throw new CSVConversionException(MessageFormat.format(
								""The CSV file contains two columns with the same name: {0}! The CSV importer cannot handle such CSV files. Please rename the columns (i.e., the first line of the CSV file) such that columns have unique names."",
								columnHeader));
					}
				}
			}
		} catch (IOException e) {
			throw new CSVConversionException(""Could not read headers of CSV"", e);
		}

		// Standard settings for empty/NULL or N/A values
		treatAsEmptyValues.add("""");
		treatAsEmptyValues.add(""NULL"");
		treatAsEmptyValues.add(""null"");
		treatAsEmptyValues.add(""NOT_SET"");
		treatAsEmptyValues.add(""N/A"");
		treatAsEmptyValues.add(""n/a"");
	}

	public void autoDetect() throws CSVConversionException {
		try {
			String[] headers = csvFile.readHeader(csvConfig);
			//TODO put those auto detection methods in a new class
			autoDetectCaseColumn(headers);
			autoDetectEventColumn(headers);
			autoDetectCompletionTimeColumn(headers);
			autoDetectStartTimeColumn(headers);
			autoDetectDataTypes();
		} catch (IOException e) {
			throw new CSVConversionException(""Could not auto-detect column types."", e);
		}
	}

	private void autoDetectCaseColumn(String[] headers) {
		List<String> caseColumns = new ArrayList<>();
		for (int i = 0; i < headers.length; i++) {
			String header = headers[i];
			if (header != null && CASE_COLUMN_IDS.contains(header.toLowerCase(Locale.US).trim())) {
				caseColumns.add(header);
			}
		}
		setCaseColumns(caseColumns);
	}

	private void autoDetectEventColumn(String[] headers) {
		List<String> eventColumns = new ArrayList<>();
		for (int i = 0; i < headers.length; i++) {
			String header = headers[i];
			if (header != null && EVENT_COLUMN_IDS.contains(header.toLowerCase(Locale.US).trim())) {
				eventColumns.add(header);
			}
		}
		setEventNameColumns(eventColumns);
	}

	private void autoDetectCompletionTimeColumn(String[] headers) {
		for (int i = 0; i < headers.length; i++) {
			String header = headers[i];

			if (header != null && COMPLETION_TIME_COLUMN_IDS.contains(header.toLowerCase(Locale.US).trim())) {
				setCompletionTimeColumn(header);
				return;
			}
		}
	}

	private void autoDetectStartTimeColumn(String[] headers) {
		for (int i = 0; i < headers.length; i++) {
			String header = headers[i];
			if (header != null && START_TIME_COLUMN_IDS.contains(header.toLowerCase(Locale.US).trim())) {
				setStartTimeColumn(header);
				return;
			}
		}
	}

	public void autoDetectDataTypes() throws CSVConversionException {
		try (ICSVReader reader = csvFile.createReader(csvConfig)) {
			String[] header = reader.readNext();

			//TODO FM, can't this be done in a more streaming fashion?
			Map<String, List<String>> valuesPerColumn = new HashMap<>();
			for (String h : header) {
				if (h != null) {
					valuesPerColumn.put(h, new ArrayList<String>(DATA_TYPE_FORMAT_AUTO_DETECT_NUM_LINES));
				}
			}
			// now read some lines or so to guess the data type
			for (int i = 0; i < DATA_TYPE_FORMAT_AUTO_DETECT_NUM_LINES; i++) {
				String[] cells = reader.readNext();
				if (cells == null) {
					//TODO FM, shouldn't that be a return?
					break;
				}
				for (int j = 0; j < cells.length; j++) {
					if (header[j] != null) {
						List<String> values = valuesPerColumn.get(header[j]);
						values.add(cells[j]);
						valuesPerColumn.put(header[j], values);
					}
				}
			}
			// now we can guess the data type
			for (String column : header) {
				if (column != null) {
					List<String> values = valuesPerColumn.get(column);
					if (values != null) {
						DatatypeWithPattern inferred = inferDataType(values);
						getConversionMap().get(column).setDataType(inferred.getType());
						getConversionMap().get(column).setPattern(inferred.getPattern());
					}

				}
			}
		} catch (IOException e) {
			throw new CSVConversionException(""Could not auto-detect column types."", e);
		}
	}

	private static boolean isInteger(String s) {
		return isInteger(s, 10); // check for base-10 number (plus optional minus sign)
	}

	private static boolean isInteger(String s, int radix) {
		if (s.isEmpty())
			return false;
		for (int i = 0; i < s.length(); i++) {
			if (i == 0 && s.charAt(i) == '-') {
				if (s.length() == 1)
					return false;
				else
					continue;
			}
			if (Character.digit(s.charAt(i), radix) < 0)
				return false;
		}
		return true;
	}

	public interface DatatypeWithPattern {
		Datatype getType();

		String getPattern();
	}

	private DatatypeWithPattern inferDataType(List<String> values) {

		boolean allEmpty = true;
		for (String value : values) {
			if (value != null && !value.isEmpty()) {
				allEmpty = false;
				break;
			}
		}
		if (allEmpty)
			return new DatatypeWithPattern() {

				public Datatype getType() {
					return Datatype.LITERAL;
				}

				public String getPattern() {
					return """";
				}
			};

		boolean hasParsed = false;

		// check whether type is boolean
		boolean isBoolean = true;
		for (String value : values) {
			if (value == null || value.isEmpty() || treatAsEmptyValues.contains(value)) {
				continue;
			}
			hasParsed = true;
			//TODO what about mixed
			if (!(""J"".equalsIgnoreCase(value) || ""Y"".equalsIgnoreCase(value) || ""T"".equalsIgnoreCase(value)
					|| ""true"".equalsIgnoreCase(value) || ""false"".equalsIgnoreCase(value) || ""N"".equalsIgnoreCase(value)
					|| ""F"".equalsIgnoreCase(value))) {
				isBoolean = false;
				break;
			}
		}
		if (hasParsed && isBoolean)
			return new DatatypeWithPattern() {

				public Datatype getType() {
					return Datatype.BOOLEAN;
				}

				public String getPattern() {
					return """";
				}
			};

		// check whether type is discrete
		hasParsed = false;
		boolean isDiscrete = true;
		for (String value : values) {
			if (value == null || value.isEmpty() || treatAsEmptyValues.contains(value)) {
				continue;
			}
			hasParsed = true;
			if (!isInteger(value)) {
				isDiscrete = false;
				break;
			}
		}
		if (hasParsed && isDiscrete)
			return new DatatypeWithPattern() {

				public Datatype getType() {
					return Datatype.DISCRETE;
				}

				public String getPattern() {
					return """";
				}
			};

		// check whether type is continuous
		final Pattern CONTINUOUS_PATTERN = Pattern
				.compile(""((-)?[0-9]*\\.[0-9]+)|((-)?[0-9]+(\\.[0-9]+)?(e|E)\\+[0-9]+)"");
		hasParsed = false;
		boolean isContinuous = true;
		for (String value : values) {
			if (value == null || value.isEmpty() || treatAsEmptyValues.contains(value)) {
				continue;
			}
			hasParsed = true;
			if (!CONTINUOUS_PATTERN.matcher(value).matches()) {
				isContinuous = false;
				break;
			}
		}
		if (hasParsed && isContinuous)
			return new DatatypeWithPattern() {

				public Datatype getType() {
					return Datatype.CONTINUOUS;
				}

				public String getPattern() {
					return """";
				}
			};

		// check whether type is date
		boolean isConsistentDateFormat = true;
		// Millisecond fix for Java SimpleDateFormat in case of a date like this 14:08:09.100000 
		// where the milliseconds would be treated as 100000ms instead of 100ms
		// Only matche when at the end of the string to avoid capturing year values when using the '.' as separator
		final Pattern INVALID_MS_PATTERN = Pattern.compile(""(\\.[0-9]{3})[0-9]*$""); 
		for (SimpleDateFormat formatter : StandardDateFormats.getStandardDateFormats()) {
			if (canParseAllValues(values, isConsistentDateFormat, INVALID_MS_PATTERN, formatter)) {
				final String pattern = formatter.toPattern();
				return new DatatypeWithPattern() {

					public Datatype getType() {
						return Datatype.TIME;
					}

					public String getPattern() {
						return pattern;
					}
				};
			}
		}

		return new DatatypeWithPattern() {

			public Datatype getType() {
				return Datatype.LITERAL;
			}

			public String getPattern() {
				return """";
			}
		};
	}

	private boolean canParseAllValues(List<String> values, boolean isConsistentDateFormat,
			final Pattern INVALID_MS_PATTERN, DateFormat formatter) {
		boolean hasParsed = false;
		for (String value : values) {
			if (value == null || value.isEmpty() || treatAsEmptyValues.contains(value))
				continue;

			// Millisecond fix for Java SimpleDateFormat
			String fixedValue = INVALID_MS_PATTERN.matcher(value).replaceFirst(""$1"");

			ParsePosition pos = new ParsePosition(0);
			pos.setIndex(0);
			Date date = formatter.parse(fixedValue, pos);

			hasParsed = true;

			// check whether date is not parsable, or date format for parsing is inconsistent
			if (date == null) {
				return false;
			}

		}
		return hasParsed;
	}

	public XFactory getFactory() {
		return factory;
	}

	public void setFactory(XFactory factory) {
		this.factory = factory;
	}

	public List<String> getCaseColumns() {
		return ImmutableList.copyOf(caseColumns);
	}

	public void setCaseColumns(List<String> caseColumns) {
		// Remove old mapping
		for (String caseColumn : this.caseColumns) {
			getConversionMap().get(caseColumn).setTraceAttributeName("""");
		}
		// Set new mapping
		for (String caseColumn : caseColumns) {
			if (caseColumn != null) {
				getConversionMap().get(caseColumn).setTraceAttributeName(""concept:name"");
				getConversionMap().get(caseColumn).setDataType(Datatype.LITERAL);	
			} else {
				throw new NullPointerException(""Tried to set a column with NULL identifier as case column!"");
			}
		}
		this.caseColumns = caseColumns;
	}

	public List<String> getEventNameColumns() {
		return ImmutableList.copyOf(eventNameColumns);
	}

	public void setEventNameColumns(List<String> eventNameColumns) {
		// Remove old mapping
		for (String eventColumn : this.eventNameColumns) {
			getConversionMap().get(eventColumn).setEventExtensionAttribute(NO_EXTENSION_ATTRIBUTE);
			getConversionMap().get(eventColumn).setEventAttributeName(eventColumn);
		}
		// Set new mapping
		for (String eventColumn : eventNameColumns) {
			if (eventColumn != null) {
				getConversionMap().get(eventColumn)
						.setEventExtensionAttribute(new ExtensionAttribute(""concept:name"", XConceptExtension.instance()));
				getConversionMap().get(eventColumn).setEventAttributeName(""concept:name"");
				getConversionMap().get(eventColumn).setDataType(Datatype.LITERAL);
			} else {
				throw new NullPointerException(""Tried to set a column with NULL identifier as event column!"");
			}
		}
		this.eventNameColumns = eventNameColumns;
	}

	public String getCompletionTimeColumn() {
		return completionTimeColumn;
	}

	private ExtensionAttribute previousCompletionTimeExtension;
	private Datatype previousCompletionTimeDataType;

	public void setCompletionTimeColumn(String completionTimeColumn) {
		// Reset mapping for old column		
		if (this.completionTimeColumn != null && !this.completionTimeColumn.isEmpty()) {
			getConversionMap().get(this.completionTimeColumn).setDataType(previousCompletionTimeDataType);
			getConversionMap().get(this.completionTimeColumn).setEventExtensionAttribute(previousCompletionTimeExtension);
			getConversionMap().get(this.completionTimeColumn).setEventAttributeName(this.completionTimeColumn);
		}

		if (completionTimeColumn != null && !completionTimeColumn.isEmpty()) {
			CSVMapping mapping = getConversionMap().get(completionTimeColumn);
			previousCompletionTimeDataType = mapping.getDataType();
			mapping.setDataType(Datatype.TIME);
			previousCompletionTimeExtension = mapping.getEventExtensionAttribute();
			mapping.setEventExtensionAttribute(new ExtensionAttribute(""time:timestamp"", XTimeExtension.instance()));
			mapping.setEventAttributeName(""time:timestamp"");
		}
		this.completionTimeColumn = completionTimeColumn;
	}

	public String getStartTimeColumn() {
		return startTimeColumn;
	}

	private ExtensionAttribute previousStartTimeExtension;
	private Datatype previousStartTimeDataType;

	public void setStartTimeColumn(String startTimeColumn) {
		// Reset mapping for old column
		if (this.startTimeColumn != null && !this.startTimeColumn.isEmpty()) {
			getConversionMap().get(this.startTimeColumn).setDataType(previousStartTimeDataType);
			getConversionMap().get(this.startTimeColumn).setEventExtensionAttribute(previousStartTimeExtension);
			getConversionMap().get(this.startTimeColumn).setEventAttributeName(this.startTimeColumn);
		}

		if (startTimeColumn != null && !startTimeColumn.isEmpty()) {
			CSVMapping mapping = getConversionMap().get(startTimeColumn);
			previousStartTimeDataType = mapping.getDataType();
			mapping.setDataType(Datatype.TIME);
			previousStartTimeExtension = mapping.getEventExtensionAttribute();
			mapping.setEventExtensionAttribute(new ExtensionAttribute(""time:timestamp"", XTimeExtension.instance()));
			mapping.setEventAttributeName(""time:timestamp"");
		}
		this.startTimeColumn = startTimeColumn;
	}

	public String getCompositeAttributeSeparator() {
		return compositeAttributeSeparator;
	}

	public void setCompositeAttributeSeparator(String compositeAttributeSeparator) {
		this.compositeAttributeSeparator = compositeAttributeSeparator;
	}

	public CSVErrorHandlingMode getErrorHandlingMode() {
		return errorHandlingMode;
	}

	public void setErrorHandlingMode(CSVErrorHandlingMode errorHandlingMode) {
		this.errorHandlingMode = errorHandlingMode;
	}

	public Map<String, CSVMapping> getConversionMap() {
		return conversionMap;
	}

	public Set<String> getTreatAsEmptyValues() {
		return treatAsEmptyValues;
	}

	public CSVEmptyCellHandlingMode getEmptyCellHandlingMode() {
		return emptyCellHandlingMode;
	}

	public void setEmptyCellHandlingMode(CSVEmptyCellHandlingMode emptyCellHandlingMode) {
		this.emptyCellHandlingMode = emptyCellHandlingMode;
	}

	public boolean isShouldAddStartEventAttributes() {
		return shouldAddStartEventAttributes;
	}

	public void setShouldAddStartEventAttributes(boolean shouldAddStartEventAttributes) {
		this.shouldAddStartEventAttributes = shouldAddStartEventAttributes;
	}

}"
CSVConversion.java,log,"package org.processmining.log.csvimport;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.nio.file.Files;
import java.text.DateFormat;
import java.text.MessageFormat;
import java.text.ParseException;
import java.text.ParsePosition;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import java.util.regex.Pattern;

import org.deckfour.xes.factory.XFactory;
import org.deckfour.xes.model.XLog;
import org.processmining.framework.plugin.Progress;
import org.processmining.log.csv.CSVFile;
import org.processmining.log.csv.CSVFileReferenceOpenCSVImpl;
import org.processmining.log.csv.ICSVReader;
import org.processmining.log.csv.config.CSVConfig;
import org.processmining.log.csvimport.config.CSVConversionConfig;
import org.processmining.log.csvimport.config.CSVConversionConfig.CSVEmptyCellHandlingMode;
import org.processmining.log.csvimport.config.CSVConversionConfig.CSVErrorHandlingMode;
import org.processmining.log.csvimport.config.CSVConversionConfig.CSVMapping;
import org.processmining.log.csvimport.exception.CSVConversionConfigException;
import org.processmining.log.csvimport.exception.CSVConversionException;
import org.processmining.log.csvimport.exception.CSVSortException;
import org.processmining.log.csvimport.handler.CSVConversionHandler;
import org.processmining.log.csvimport.handler.XESConversionHandlerImpl;

import com.google.common.collect.ObjectArrays;
import com.google.common.collect.Ordering;
import com.google.common.primitives.Ints;
import com.ning.compress.lzf.LZFInputStream;

/**
 * Conversion from CSV to a structure like XES. Use
 * {@link #doConvertCSVToXES(ProgressListener, CSVFile, CSVConfig, CSVConversionConfig)}
 * to convert to XES, use
 * {@link #convertCSV(ProgressListener, CSVConfig, CSVConversionConfig, CSVFile, CSVConversionHandler)}
 * to use your own {@link CSVConversionHandler} for some other format.
 * <p>
 * Example usage:
 * <p>
 * 
 * <pre>
 * CSVFileReferenceUnivocityImpl csvFile = new CSVFileReferenceUnivocityImpl(getFile().toPath());
 * CSVConfig config = new CSVConfig(csvFile);
 * try (ICSVReader reader = csvFile.createReader(config)) {
 * 	CSVConversion conversion = new CSVConversion();
 * 	CSVConversionConfig conversionConfig = new CSVConversionConfig(csvFile, config);
 * 	conversionConfig.autoDetect();
 * 
 * 	conversionConfig.setCaseColumns(ImmutableList.of(&quot;case&quot;));
 * 	conversionConfig.setEventNameColumns(ImmutableList.of(&quot;event&quot;));
 * 	conversionConfig.setCompletionTimeColumn(&quot;time&quot;);
 * 	conversionConfig.setEmptyCellHandlingMode(CSVEmptyCellHandlingMode.SPARSE);
 * 	conversionConfig.setErrorHandlingMode(CSVErrorHandlingMode.ABORT_ON_ERROR);
 * 	Map&lt;String, CSVMapping&gt; conversionMap = conversionConfig.getConversionMap();
 * 	CSVMapping mapping = conversionMap.get(&quot;time&quot;);
 * 	mapping.setDataType(Datatype.TIME);
 * 	mapping.setPattern(&quot;yyyy/MM/dd&quot;);
 * 
 * 	ConversionResult&lt;XLog&gt; result = conversion.doConvertCSVToXES(new NoOpProgressListenerImpl(), csvFile, config,
 * 			conversionConfig);
 * 
 * 	XLog log = result.getResult();
 * }
 * </pre>
 * 
 * @author F. Mannhardt
 *
 */
public final class CSVConversion {

	private static final int PROGRESS_REPORT_WINDOW = 10000;

	public interface ConversionResult<R> {
		R getResult();

		boolean hasConversionErrors();

		String getConversionErrors();
	}

	public interface ProgressListener {
		Progress getProgress();

		void log(String message);
	}

	public static class NoOpProgressListenerImpl implements ProgressListener {

		public void log(String message) {
		}

		public Progress getProgress() {
			return new NoOpProgressImpl();
		}

	}

	public static class NoOpProgressImpl implements Progress {

		public void setValue(int value) {
		}

		public void setMinimum(int value) {
		}

		public void setMaximum(int value) {
		}

		public void setIndeterminate(boolean makeIndeterminate) {
		}

		public void setCaption(String message) {
		}

		public boolean isIndeterminate() {
			return false;
		}

		public boolean isCancelled() {
			return false;
		}

		public void inc() {
		}

		public int getValue() {
			return 0;
		}

		public int getMinimum() {
			return 0;
		}

		public int getMaximum() {
			return 0;
		}

		public String getCaption() {
			return """";
		}

		public void cancel() {
		}

	}

	/**
	 * Convert a {@link CSVFileReferenceOpenCSVImpl} into an {@link XLog} using
	 * the supplied configuration. Without progress information.
	 * 
	 * @param csvFile
	 * @param importConfig
	 * @param conversionConfig
	 * @return
	 * @throws CSVConversionException
	 * @throws CSVConversionConfigException
	 */
	public ConversionResult<XLog> doConvertCSVToXES(CSVFile csvFile, CSVConfig importConfig,
			CSVConversionConfig conversionConfig) throws CSVConversionException, CSVConversionConfigException {
		return doConvertCSVToXES(new NoOpProgressListenerImpl(), csvFile, importConfig, conversionConfig);
	}

	/**
	 * Convert a {@link CSVFileReferenceOpenCSVImpl} into an {@link XLog} using
	 * the supplied configuration.
	 * 
	 * @param progressListener
	 * @param csvFile
	 * @param importConfig
	 * @param conversionConfig
	 * @return
	 * @throws CSVConversionException
	 * @throws CSVConversionConfigException
	 */
	public ConversionResult<XLog> doConvertCSVToXES(final ProgressListener progressListener, CSVFile csvFile,
			CSVConfig importConfig, CSVConversionConfig conversionConfig)
			throws CSVConversionException, CSVConversionConfigException {
		return convertCSV(progressListener, importConfig, conversionConfig, csvFile,
				new XESConversionHandlerImpl(importConfig, conversionConfig));
	}

	/**
	 * Converts a {@link CSVFileReferenceOpenCSVImpl} into something determined
	 * by the supplied {@link CSVConversionHandler}. Use
	 * {@link #doConvertCSVToXES(ProgressListener, CSVFileReferenceOpenCSVImpl, CSVConfig, CSVConversionConfig)}
	 * in case you want to convert to an {@link XLog}.
	 * 
	 * @param progress
	 * @param importConfig
	 * @param conversionConfig
	 * @param csvFile
	 * @param conversionHandler
	 * @return
	 * @throws CSVConversionException
	 * @throws CSVConversionConfigException
	 */
	public <R> ConversionResult<R> convertCSV(ProgressListener progress, CSVConfig importConfig,
			CSVConversionConfig conversionConfig, CSVFile csvFile, final CSVConversionHandler<R> conversionHandler)
			throws CSVConversionException, CSVConversionConfigException {

		Progress p = progress.getProgress();

		p.setMinimum(0);
		p.setMaximum(1);
		p.setValue(0);
		p.setIndeterminate(true);

		long startCSVTime = System.currentTimeMillis();

		conversionHandler.startLog(csvFile);

		int[] caseColumnIndex = new int[conversionConfig.getCaseColumns().size()];
		int[] eventNameColumnIndex = new int[conversionConfig.getEventNameColumns().size()];
		int completionTimeColumnIndex = -1;
		int startTimeColumnIndex = -1;
		String[] header = null;

		final Map<String, Integer> headerMap = new HashMap<>();
		final Map<Integer, CSVMapping> columnMap = new HashMap<>();

		try {
			header = csvFile.readHeader(importConfig);
			for (int i = 0; i < header.length; i++) {
				String columnHeader = header[i];
				Integer oldIndex = headerMap.put(columnHeader, i);
				if (oldIndex != null) {
					throw new CSVConversionException(String.format(
							""Ambigous header in the CSV file: Two columns (%s, %s) have the same header %s. Please fix this in the CSV file!"",
							oldIndex, i, columnHeader));
				}
				CSVMapping columnMapping = conversionConfig.getConversionMap().get(columnHeader);
				columnMap.put(i, columnMapping);
			}

			for (int i = 0; i < conversionConfig.getCaseColumns().size(); i++) {
				caseColumnIndex[i] = headerMap.get(conversionConfig.getCaseColumns().get(i));
			}
			for (int i = 0; i < conversionConfig.getEventNameColumns().size(); i++) {
				eventNameColumnIndex[i] = headerMap.get(conversionConfig.getEventNameColumns().get(i));
			}
			if (conversionConfig.getCompletionTimeColumn() != null
					&& !conversionConfig.getCompletionTimeColumn().isEmpty()) {
				completionTimeColumnIndex = headerMap.get(conversionConfig.getCompletionTimeColumn());
			}
			if (conversionConfig.getStartTimeColumn() != null && !conversionConfig.getStartTimeColumn().isEmpty()) {
				startTimeColumnIndex = headerMap.get(conversionConfig.getStartTimeColumn());
			}
		} catch (IOException e) {
			throw new CSVConversionException(""Could not read first row of CSV file with header information"", e);
		}

		InputStream sortedCsvInputStream = null;
		File sortedFile = null;

		try {
			try {
				long startSortTime = System.currentTimeMillis();
				int maxMemory = (int) ((Runtime.getRuntime().maxMemory() * maxSortingMemory) / 1024 / 1024);
				progress.log(
						String.format(""Sorting CSV file (%.2f MB) by case and time using maximal %s MB of memory ..."",
								(getFileSizeInBytes(csvFile) / 1024 / 1024), maxMemory));
				Ordering<String[]> caseComparator = new StringBasedImportOrdering(caseColumnIndex);
				sortedFile = CSVSorter.sortCSV(csvFile, caseComparator, importConfig, maxMemory, header.length,
						progress);
				sortedCsvInputStream = new LZFInputStream(new FileInputStream(sortedFile));
				long endSortTime = System.currentTimeMillis();
				progress.log(
						String.format(""Finished sorting in %.2f seconds"", (endSortTime - startSortTime) / 1000.0d));
			} catch (IllegalArgumentException e) {
				throw new CSVSortException(""Could not sort CSV file"", e);
			} catch (IOException e) {
				throw new CSVSortException(""Could not sort CSV file"", e);
			}

			// The following code assumes that the file is sorted by cases and written to disk compressed with LZF
			progress.log(""Reading cases ..."");
			try (ICSVReader reader = csvFile.getCSV().createReader(sortedCsvInputStream, importConfig)) {

				int caseIndex = 0;
				int eventIndex = 0;
				int lineIndex = -1;
				String[] nextLine;
				String currentCaseId = null;

				while ((nextLine = reader.readNext()) != null && (caseIndex % 100 != 0 || !p.isCancelled())) {
					lineIndex++;

					final String newCaseID = readCompositeAttribute(caseColumnIndex, nextLine,
							conversionConfig.getCompositeAttributeSeparator());

					// Handle new traces
					if (!newCaseID.equals(currentCaseId)) {

						if (currentCaseId != null) {
							// Finished with current case
							conversionHandler.endTrace(currentCaseId);
						}

						// Update current case id to next case id
						currentCaseId = newCaseID;

						// Create new case
						conversionHandler.startTrace(currentCaseId);
						caseIndex++;

						if (caseIndex % PROGRESS_REPORT_WINDOW == 0) {
							progress.log(""Reading line "" + lineIndex + "", already "" + caseIndex + "" cases and ""
									+ eventIndex + "" events processed ..."");
						}

					}

					// Create new event

					// Read event name
					final String eventClass = readCompositeAttribute(eventNameColumnIndex, nextLine,
							conversionConfig.getCompositeAttributeSeparator());

					// Read time stamps
					Date completionTime = parseTime(conversionHandler, completionTimeColumnIndex, columnMap, lineIndex,
							nextLine);
					Date startTime = parseTime(conversionHandler, startTimeColumnIndex, columnMap, lineIndex, nextLine);

					conversionHandler.startEvent(eventClass, completionTime, startTime);

					for (int i = 0; i < nextLine.length; i++) {
						if (Ints.contains(eventNameColumnIndex, i) || Ints.contains(caseColumnIndex, i)
								|| i == completionTimeColumnIndex || i == startTimeColumnIndex) {
							// Is already mapped to a special column, do not include again
							continue;
						}

						final String name = header[i];
						final String value = nextLine[i];

						if (!(conversionConfig.getEmptyCellHandlingMode() == CSVEmptyCellHandlingMode.SPARSE
								&& (value == null || conversionConfig.getTreatAsEmptyValues().contains(value)
										|| value.isEmpty()))) {
							parseAttributes(progress, conversionConfig, conversionHandler, columnMap.get(i), lineIndex,
									i, name, nextLine);
						}
					}

					// Already sorted by time
					conversionHandler.endEvent();
					eventIndex++;
				}

				// Close last trace
				if (currentCaseId != null) { // at least one trace is present
					conversionHandler.endTrace(currentCaseId);	
				}				

			} catch (IOException e) {
				throw new CSVConversionException(""Error converting the CSV file to XES"", e);
			}
		} finally {
			if (sortedCsvInputStream != null) {
				try {
					sortedCsvInputStream.close();
				} catch (Exception e) {
					throw new CSVConversionException(""Error closing the CSV file"", e);
				}
			}
			if (sortedFile != null) {
				sortedFile.delete();
			}
		}
		commitFactoryIfNeeded(conversionConfig.getFactory());
		long endConvertTime = System.currentTimeMillis();
		progress.log(String.format(""Finished reading cases in %d seconds."", (endConvertTime - startCSVTime) / 1000));

		return new ConversionResult<R>() {

			public R getResult() {
				return conversionHandler.getResult();
			}

			public boolean hasConversionErrors() {
				return conversionHandler.hasConversionErrors();
			}

			public String getConversionErrors() {
				return conversionHandler.getConversionErrors();
			}
		};
	}

	/**
	 * Calls the XESLite commit method if available. Uses reflection to not
	 * introduce a dependency on XESLite.
	 * 
	 * @param factory
	 */
	private void commitFactoryIfNeeded(XFactory factory) {
		try {
			Method method = factory.getClass().getMethod(""commit"");
			if (method != null) {
				method.invoke(factory);
			}
		} catch (NoSuchMethodException | SecurityException | IllegalAccessException | IllegalArgumentException
				| InvocationTargetException e) {
		}
	}

	private <R> Date parseTime(final CSVConversionHandler<R> conversionHandler, int timeColumnIndex,
			final Map<Integer, CSVMapping> columnMap, int lineIndex, String[] nextLine) throws CSVConversionException {
		if (timeColumnIndex == -1) {
			return null;
		} else {
			String timeValue = nextLine[timeColumnIndex];
			try {
				return parseDate((DateFormat) columnMap.get(timeColumnIndex).getFormat(), timeValue);
			} catch (ParseException e) {
				conversionHandler.errorDetected(lineIndex, timeColumnIndex,
						columnMap.get(timeColumnIndex).getEventAttributeName(), timeValue, e);
				return null;
			}
		}
	}

	private static double getFileSizeInBytes(CSVFile csvFile) throws IOException {
		return Files.size(csvFile.getFile());
	}

	private <R> void parseAttributes(ProgressListener progress, CSVConversionConfig conversionConfig,
			CSVConversionHandler<R> conversionHandler, CSVMapping csvMapping, int lineIndex, int columnIndex,
			String name, String[] line) throws CSVConversionException {

		String value = line[columnIndex];
		if (name == null) // TODO: Nicer would be to create names like ""unknown-1"", ""unknown-2"", etc. instead of skipping the attribute
			return;
		if (csvMapping.getDataType() == null) {
			conversionHandler.startAttribute(name, value);
		} else {
			try {
				switch (csvMapping.getDataType()) {
					case BOOLEAN :
						boolean boolVal;
						if (""true"".equalsIgnoreCase(value) || ""J"".equalsIgnoreCase(value) || ""Y"".equalsIgnoreCase(value)
								|| ""T"".equalsIgnoreCase(value) || ""1"".equals(value)) {
							boolVal = true;
						} else if (""false"".equalsIgnoreCase(value) || ""N"".equalsIgnoreCase(value)
								|| ""F"".equalsIgnoreCase(value) || ""0"".equals(value)) {
							boolVal = false;
						} else {
							throw new ParseException(value + "" cannot be converted to a boolean"", 0);
						}
						conversionHandler.startAttribute(name, boolVal);
						break;
					case CONTINUOUS :
						if (csvMapping.getFormat() != null) {
							conversionHandler.startAttribute(name, (Double) csvMapping.getFormat().parseObject(value));
						} else {
							conversionHandler.startAttribute(name, Double.parseDouble(value));
						}
						break;
					case DISCRETE :
						if (csvMapping.getFormat() != null) {
							conversionHandler.startAttribute(name, (Integer) csvMapping.getFormat().parseObject(value));
						} else {
							conversionHandler.startAttribute(name, Long.parseLong(value));
						}
						break;
					case TIME :
						conversionHandler.startAttribute(name, parseDate((DateFormat) csvMapping.getFormat(), value));
						break;
					case LITERAL :
					default :
						if (csvMapping.getFormat() != null) {
							value = ((MessageFormat) csvMapping.getFormat())
									.format(ObjectArrays.concat(value, line), new StringBuffer(), null).toString();
						}
						conversionHandler.startAttribute(name, value);
						break;
				}
			} catch (NumberFormatException e) {
				conversionHandler.errorDetected(lineIndex, columnIndex, name, value, e);
				if (conversionConfig.getErrorHandlingMode() == CSVErrorHandlingMode.BEST_EFFORT) {
					conversionHandler.startAttribute(name, value);
				}
			} catch (ParseException e) {
				conversionHandler.errorDetected(lineIndex, columnIndex, name, value, e);
				if (conversionConfig.getErrorHandlingMode() == CSVErrorHandlingMode.BEST_EFFORT) {
					conversionHandler.startAttribute(name, value);
				}
			}
		}
		conversionHandler.endAttribute();
	}

	/**
	 * Concatenates multiple composite attributes to a String representation.
	 * 
	 * @param columnIndex
	 * @param line
	 * @param compositeSeparator
	 * @return the composite attributes concatenated or an empty String in case
	 *         no columns are selected
	 */
	private static String readCompositeAttribute(int[] columnIndex, String[] line, String compositeSeparator) {
		if (columnIndex.length == 0) {
			return """";
		}
		int size = 0;
		for (int index : columnIndex) {
			String cell = line[index];
			size += (cell == null ? 0 : cell.length());
		}
		StringBuilder sb = new StringBuilder(size + columnIndex.length);
		for (int index : columnIndex) {
			String cell = line[index];
			if (cell != null) {
				sb.append(cell);
			}
			sb.append(compositeSeparator);
		}
		return sb.substring(0, sb.length() - 1);
	}

	private static Pattern INVALID_MS_PATTERN = Pattern.compile(""(:[0-5][0-9]\\.[0-9]{3})[0-9]*$"");
	private double maxSortingMemory = 0.30;

	private static Date parseDate(DateFormat customDateFormat, String value) throws ParseException {

		if (value == null) {
			throw new ParseException(""Could not parse NULL timestamp!"", 0);
		}

		if (customDateFormat != null) {
			ParsePosition pos = new ParsePosition(0);
			Date date = customDateFormat.parse(value, pos);
			
			// Fix if there are more than 3 digits for ms for example 44.00.540000, do not return and
			// ensure string is formatted to 540 ms instead of 540000 ms
			if (date != null && !INVALID_MS_PATTERN.matcher(value).find()) {
				return date;
			} else {
				String fixedValue = INVALID_MS_PATTERN.matcher(value).replaceFirst(""$1"");
				pos.setIndex(0);
				date = customDateFormat.parse(fixedValue, pos);
				if (date != null) {
					return date;
				} else {
					String pattern = ""unkown"";
					if (customDateFormat instanceof SimpleDateFormat) {
						pattern = ((SimpleDateFormat) customDateFormat).toPattern();
					}
					throw new ParseException(""Could not parse "" + value + "" using pattern '"" + pattern + ""'"",
							pos.getErrorIndex());
				}
			}
		}

		throw new ParseException(""Could not parse "" + value, -1);
	}

	public double getMaxSortingMemory() {
		return maxSortingMemory;
	}

	public void setMaxSortingMemory(double maxSortingMemory) {
		this.maxSortingMemory = maxSortingMemory;
	}

}
"
CSVConversionCLI.java,log,"package org.processmining.log.csvimport;

import java.io.File;
import java.io.IOException;
import java.io.PrintStream;

import org.apache.commons.cli.CommandLine;
import org.apache.commons.cli.CommandLineParser;
import org.apache.commons.cli.HelpFormatter;
import org.apache.commons.cli.Option;
import org.apache.commons.cli.OptionBuilder;
import org.apache.commons.cli.Options;
import org.apache.commons.cli.ParseException;
import org.apache.commons.cli.PosixParser;
import org.deckfour.xes.model.XLog;
import org.processmining.log.csv.CSVFile;
import org.processmining.log.csv.CSVFileReferenceUnivocityImpl;
import org.processmining.log.csv.config.CSVConfig;
import org.processmining.log.csvimport.CSVConversion.ConversionResult;
import org.processmining.log.csvimport.CSVConversion.ProgressListener;
import org.processmining.log.csvimport.config.CSVConversionConfig;
import org.processmining.log.csvimport.exception.CSVConversionConfigException;
import org.processmining.log.csvimport.exception.CSVConversionException;
import org.processmining.log.utils.XUtils;

import com.google.common.collect.ImmutableList;

/**
 * CLI interface to the ProM XES conversion
 * 
 * @author F. Mannhardt
 *
 */
public final class CSVConversionCLI {

	private static final class ProgressListenerPrintStreamImpl extends CSVConversion.NoOpProgressListenerImpl {

		private final PrintStream out;

		public ProgressListenerPrintStreamImpl(PrintStream out) {
			this.out = out;
		}

		public void log(String message) {
			out.println(message);
		}

	}

	private static final Options OPTIONS = new Options();

	private static final Option HELP = OptionBuilder.withDescription(""help"").create('h');
	private static final Option XES = OptionBuilder.hasArg().withArgName(""filename"").create(""xes"");
	private static final Option TRACE = OptionBuilder.hasArg().withArgName(""traceColumn"").create(""trace"");
	private static final Option EVENT = OptionBuilder.hasArg().withArgName(""eventColumn"").create(""event"");
	private static final Option START = OptionBuilder.hasArg().withArgName(""startColumn"").create(""start"");
	private static final Option COMPLETE = OptionBuilder.hasArg().withArgName(""completionColumn"").create(""complete"");

	static {
		OPTIONS.addOption(HELP);
		OPTIONS.addOption(XES);
		OPTIONS.addOption(TRACE);
		OPTIONS.addOption(EVENT);
		OPTIONS.addOption(START);
		OPTIONS.addOption(COMPLETE);
	}

	public static void main(String[] args) {

		try {
			CommandLineParser parser = new PosixParser();
			CommandLine commandLine = parser.parse(OPTIONS, args);

			if (commandLine.hasOption(HELP.getOpt())) {
				printUsage();
				return;
			}

			if (commandLine.getArgs().length != 1) {
				printUsage();
				System.err.println(""Missing filename of the CSV file!"");
				return;
			}

			File logFile = new File(commandLine.getArgs()[0]);

			try {
				XLog log = parseCSV(logFile, commandLine);

				if (commandLine.hasOption(XES.getOpt())) {
					XUtils.saveLogGzip(log, new File(commandLine.getOptionValue(XES.getOpt())));
				} else {
					XUtils.saveLogGzip(log, new File(logFile.getAbsolutePath() + "".xes.gz""));
				}
			} catch (CSVConversionException | IOException e) {
				if (e.getMessage() != null) {
					System.err.println(e.getMessage());
				}
				e.printStackTrace();
			}

			System.out.println(""Log converted successfully!"");

		} catch (ParseException e) {
			printUsage();
			if (e.getMessage() != null) {
				System.err.println(e.getMessage());
			}
		}
		
		System.exit(0);

	}

	private static XLog parseCSV(File inputFile, CommandLine commandLine) throws CSVConversionException, CSVConversionConfigException {
		CSVConversion conversion = new CSVConversion();
		CSVFile csvFile = new CSVFileReferenceUnivocityImpl(inputFile.toPath());
		CSVConfig importConfig = new CSVConfig(csvFile);
		CSVConversionConfig conversionConfig = new CSVConversionConfig(csvFile, importConfig);
		conversionConfig.autoDetect();

		if (commandLine.hasOption(TRACE.getOpt())) {
			conversionConfig.setCaseColumns(ImmutableList.of(commandLine.getOptionValue(TRACE.getOpt())));
		}
		
		if (commandLine.hasOption(EVENT.getOpt())) {
			conversionConfig.setEventNameColumns(ImmutableList.of(commandLine.getOptionValue(EVENT.getOpt())));
		}
		
		if (commandLine.hasOption(START.getOpt())) {
			conversionConfig.setStartTimeColumn(commandLine.getOptionValue(START.getOpt()));
		}
		
		if (commandLine.hasOption(COMPLETE.getOpt())) {
			conversionConfig.setCompletionTimeColumn(commandLine.getOptionValue(COMPLETE.getOpt()));
		}
		
		ProgressListener cmdLineProgressListener = new ProgressListenerPrintStreamImpl(System.out);
		ConversionResult<XLog> result = conversion.doConvertCSVToXES(cmdLineProgressListener, csvFile, importConfig,
				conversionConfig);
		return result.getResult();
	}

	private static void printUsage() {
		HelpFormatter helpFormatter = new HelpFormatter();
		helpFormatter.printHelp(""mpe [CSVFILE]"", OPTIONS, true);
		return;
	}

}"
CSVConversionPlugin.java,log,"package org.processmining.log.csvimport;

import java.io.IOException;

import javax.swing.JOptionPane;

import org.deckfour.uitopia.api.event.TaskListener.InteractionResult;
import org.deckfour.xes.model.XLog;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.Progress;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginLevel;
import org.processmining.framework.plugin.events.Logger.MessageLevel;
import org.processmining.framework.util.ui.widgets.helper.ProMUIHelper;
import org.processmining.log.csv.CSVFile;
import org.processmining.log.csv.config.CSVConfig;
import org.processmining.log.csvimport.CSVConversion.ConversionResult;
import org.processmining.log.csvimport.CSVConversion.ProgressListener;
import org.processmining.log.csvimport.config.CSVConversionConfig;
import org.processmining.log.csvimport.exception.CSVConversionConfigException;
import org.processmining.log.csvimport.exception.CSVConversionException;
import org.processmining.log.csvimport.handler.XESConversionHandlerImpl;
import org.processmining.log.csvimport.ui.ConversionConfigUI;
import org.processmining.log.csvimport.ui.ExpertConfigUI;
import org.processmining.log.csvimport.ui.ImportConfigUI;

import com.google.common.base.Throwables;

/**
 * CSV to XES XLog conversion plug-in
 * 
 * @author F. Mannhardt
 * 
 */
public final class CSVConversionPlugin {

	@Plugin(name = ""Convert CSV to XES"", level = PluginLevel.PeerReviewed, parameterLabels = { ""CSV"" }, returnLabels = {
			""XES Event Log"" }, // 
			returnTypes = { XLog.class }, userAccessible = true, mostSignificantResult = 1, // 
			keywords = { ""CSV"", ""OpenXES"", ""Conversion"",
					""Import"" }, help = ""Converts the CSV file to a OpenXES XLog object."")
	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = "" F. Mannhardt, N. Tax, D.M.M. Schunselaar"", // 
			email = ""f.mannhardt@tue.nl, n.tax@tue.nl, d.m.m.schunselaar@vu.nl"", pack = ""Log"")
	public XLog convertCSVToXES(final UIPluginContext context, CSVFile csvFile) {

		InteractionResult result = InteractionResult.CONTINUE;

		try {
			CSVConfig importConfig = new CSVConfig(csvFile);
			CSVConversionConfig csvConversionConfig = null;

			int i = 0;
			wizardLoop: while (result != InteractionResult.FINISHED) {
				switch (i) {
					case 0 :
						result = queryImportConfig(context, csvFile, importConfig);
						try {
							csvConversionConfig = new CSVConversionConfig(csvFile, importConfig);
							csvConversionConfig.autoDetect();
						} catch (CSVConversionException e) {								
							// Due to the strange wizard framework, we cannot cancel this dialog. So show again. The only way to cancel is through the user.
							if (result != InteractionResult.CANCEL) {
								ProMUIHelper.showErrorMessage(context, e.getMessage(), ""CSV Conversion Failed"");
								continue wizardLoop;	
							}
						}
						break;
					case 1 :
						result = queryConversionConfig(context, csvFile, importConfig, csvConversionConfig);
						if (result == InteractionResult.NEXT || result == InteractionResult.CONTINUE) {
							boolean reconfigure = queryMissingConfiguration(context, csvConversionConfig);
							if (reconfigure) {
								// Show same dialog again
								continue wizardLoop;
							}
						}
						break;
					case 2 :
						result = queryExpertConfig(context, csvFile, importConfig, csvConversionConfig);
						break;
				}
				if (result == InteractionResult.NEXT || result == InteractionResult.CONTINUE) {
					i++;
				} else if (result == InteractionResult.PREV) {
					i--;
				} else if (result == InteractionResult.CANCEL) {
					return cancel(context);
				}
			}

			CSVConversion csvConversion = new CSVConversion();
			ConversionResult<XLog> conversionResult = doConvertCSVToXes(context, csvFile, importConfig,
					csvConversionConfig, csvConversion);
			if (conversionResult.hasConversionErrors()) {
				ProMUIHelper.showWarningMessage(context, conversionResult.getConversionErrors(),
						""Warning: Some issues have been detected during conversion"");
			}
			return conversionResult.getResult();
		} catch (CSVConversionException e) {
			Throwable rootCause = Throwables.getRootCause(e);
			String errorMessage;
			if (rootCause != null) {
				errorMessage = rootCause.getMessage();
			} else {
				errorMessage = e.toString();
			}
			String stackTrace = Throwables.getStackTraceAsString(e);
			ProMUIHelper.showErrorMessage(context, errorMessage + ""\n\nDebug information:\n"" + stackTrace,
					""CSV Conversion Failed"");
			return cancel(context);
		}

	}

	private boolean queryMissingConfiguration(final UIPluginContext context, CSVConversionConfig csvConversionConfig) {
		boolean noCase = csvConversionConfig.getCaseColumns().isEmpty();
		boolean noEvents = csvConversionConfig.getEventNameColumns().isEmpty();
		Object[] options = { ""Continue"", ""Reconfigure"" };
		String message;
		String title;
		if (noCase) {
			message = ""<HTML>You did not select a column containing the case identifier. This will result in an event log with a single trace.<BR/> ""
					+ ""Do you want to continue without case identifier or reconfigure the conversion?</HTML>"";
			title = ""Missing event column"";
		} else if (noEvents) {
			message = ""<HTML>You did not select a column containing the event name. This will result in an event log with unamed events.<BR/> ""
					+ ""Do you want to continue without event name or reconfigure the conversion?</HTML>"";
			title = ""Missing event column"";
		} else if (noEvents && noCase) {
			message = ""You did not select columns containing the case identifier and event name. This will result in an event log with a single trace and unnamed events. ""
					+ ""Do you want to continue or reconfigure the conversion?"";
			title = ""Missing case and event columns"";
		} else {
			return false;
		}
		int warningResult = JOptionPane.showOptionDialog(context.getGlobalContext().getUI(), message, title,
				JOptionPane.PLAIN_MESSAGE, JOptionPane.WARNING_MESSAGE, null, options, options[0]);
		return warningResult == 1; // reconfigure
	}

	private XLog cancel(final UIPluginContext context) {
		context.getFutureResult(0).cancel(false);
		return null;
	}

	public ConversionResult<XLog> doConvertCSVToXes(final PluginContext context, CSVFile csvFile,
			CSVConfig importConfig, CSVConversionConfig conversionConfig, CSVConversion csvConversion)
			throws CSVConversionConfigException, CSVConversionException {

		ProgressListener progressListener = new ProgressListener() {

			public Progress getProgress() {
				return context.getProgress();
			}

			public void log(String message) {
				context.log(message);

			}
		};

		XESConversionHandlerImpl xesHandler = new XESConversionHandlerImpl(importConfig, conversionConfig);
		final ConversionResult<XLog> conversionResult = csvConversion.convertCSV(progressListener, importConfig,
				conversionConfig, csvFile, xesHandler);
		final XLog convertedLog = conversionResult.getResult();

		if (xesHandler.hasConversionErrors()) {
			context.log(xesHandler.getConversionErrors(), MessageLevel.WARNING);
		}

		return new ConversionResult<XLog>() {

			public boolean hasConversionErrors() {
				return conversionResult.hasConversionErrors();
			}

			public XLog getResult() {
				return convertedLog;
			}

			public String getConversionErrors() {
				return conversionResult.getConversionErrors();
			}
		};

	}

	public static InteractionResult queryExpertConfig(UIPluginContext context, CSVFile csv, CSVConfig importConfig,
			CSVConversionConfig converionConfig) {
		ExpertConfigUI expertConfigUI = new ExpertConfigUI(csv, importConfig, converionConfig);
		return context.showWizard(""Configure Additional Conversion Settings"", false, true, expertConfigUI);
	}

	public static InteractionResult queryImportConfig(UIPluginContext context, CSVFile csv, CSVConfig importConfig) {
		ImportConfigUI importConfigUI = new ImportConfigUI(csv, importConfig);
		return context.showWizard(""Configure CSV Parser Settings"", true, false, importConfigUI);
	}

	public static InteractionResult queryConversionConfig(UIPluginContext context, CSVFile csv, CSVConfig importConfig,
			CSVConversionConfig conversionConfig) throws CSVConversionException {
		try (ConversionConfigUI conversionConfigUI = new ConversionConfigUI(csv, importConfig, conversionConfig)) {
			return context.showWizard(""Configure Conversion from CSV to XES"", false, false, conversionConfigUI);
		} catch (IOException e) {
			throw new CSVConversionConfigException(""Could not query conversion config."", e);
		}
	}

}
"
CSVImportPlugin.java,log,"package org.processmining.log.csvimport;

import java.io.InputStream;

import org.deckfour.xes.model.XLog;
import org.processmining.framework.abstractplugins.AbstractImportPlugin;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.log.csv.CSVFile;
import org.processmining.log.csv.CSVFileReferenceOpenCSVImpl;

/**
 * Converts a {@link CSVFile} to {@link XLog}.
 * 
 * @author F. Mannhardt
 *
 */
// Old OpenCSV parser
//@Plugin(name = ""Import a CSV file and convert it to XES"", parameterLabels = { ""Filename"" }, returnLabels = { ""Imported CSV File"" }, returnTypes = { CSVFile.class })
//@UIImportPlugin(description = ""CSV File (XES Conversion with Log package)"", extensions = { ""csv"", ""zip"", ""csv.gz"", ""txt"" })
@Deprecated
final class CSVImportPlugin extends AbstractImportPlugin {

	@Override
	protected CSVFile importFromStream(final PluginContext context, final InputStream input, final String filename,
			final long fileSizeInBytes) throws Exception {
		context.getFutureResult(0).setLabel(""Imported CSV: ""+filename);
		return new CSVFileReferenceOpenCSVImpl(getFile().toPath(), filename, fileSizeInBytes);
	}

}
"
CSVImportPluginUnivocity.java,log,"package org.processmining.log.csvimport;

import java.io.InputStream;

import org.deckfour.xes.model.XLog;
import org.processmining.contexts.uitopia.annotations.UIImportPlugin;
import org.processmining.framework.abstractplugins.AbstractImportPlugin;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginLevel;
import org.processmining.log.csv.CSVFile;
import org.processmining.log.csv.CSVFileReferenceUnivocityImpl;

/**
 * Converts a {@link CSVFile} to {@link XLog}.
 * 
 * @author N. Tax
 *
 */
@Plugin(name = ""Import a CSV file and convert it to XES"", level= PluginLevel.PeerReviewed, parameterLabels = { ""Filename"" }, returnLabels = { ""Imported CSV File"" }, returnTypes = { CSVFile.class })
@UIImportPlugin(description = ""CSV File (XES Conversion with Log package)"", extensions = { ""csv"", ""zip"", ""csv.gz"", ""txt"", ""rpt"" })
public final class CSVImportPluginUnivocity extends AbstractImportPlugin {

	@Override
	protected CSVFile importFromStream(final PluginContext context, final InputStream input, final String filename,
			final long fileSizeInBytes) throws Exception {
		context.getFutureResult(0).setLabel(""Imported CSV: ""+filename);
		return new CSVFileReferenceUnivocityImpl(getFile().toPath());
	}

}
"
CSVSorter.java,log,"package org.processmining.log.csvimport;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.nio.file.Files;
import java.text.MessageFormat;
import java.util.Comparator;
import java.util.Iterator;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;

import org.processmining.log.csv.CSVFile;
import org.processmining.log.csv.ICSVReader;
import org.processmining.log.csv.ICSVWriter;
import org.processmining.log.csv.config.CSVConfig;
import org.processmining.log.csvimport.CSVConversion.ProgressListener;
import org.processmining.log.csvimport.exception.CSVSortException;

import com.fasterxml.sort.DataReader;
import com.fasterxml.sort.DataReaderFactory;
import com.fasterxml.sort.DataWriter;
import com.fasterxml.sort.DataWriterFactory;
import com.fasterxml.sort.IteratingSorter;
import com.fasterxml.sort.SortConfig;
import com.fasterxml.sort.SortingState.Phase;
import com.fasterxml.sort.TempFileProvider;
import com.ning.compress.lzf.LZFInputStream;
import com.ning.compress.lzf.parallel.PLZFOutputStream;

/**
 * Sorts an {@link CSVFile}
 * 
 * @author F. Mannhardt
 * 
 */
final class CSVSorter {

	private static final class UncompressedCSVReaderWithoutHeader extends DataReader<String[]> {

		private static final int MAX_COLUMNS_FOR_ERROR_REPORTING = 32;
		private static final int MAX_FIELD_LENGTH_FOR_ERROR_REPORTING = 64;

		private final ICSVReader reader;
		private final int numColumns;
		private int currentRow = 1;

		private UncompressedCSVReaderWithoutHeader(CSVFile csvFile, CSVConfig importConfig, int numColumns)
				throws IOException {
			this.numColumns = numColumns;
			this.reader = csvFile.createReader(importConfig);
			// Skip header line
			this.reader.readNext();
		}

		public void close() throws IOException {
			reader.close();
		}

		public int estimateSizeInBytes(String[] val) {
			return estimateSize(val);
		}

		public String[] readNext() throws IOException {
			String[] val = reader.readNext();
			if (val != null && val.length != numColumns) {
				String offendingLine = safeToString(val);
				throw new IOException(
						MessageFormat
								.format(""The number of fields in rows of the CSV file is inconsistent. There should be {0} fields in each row according to the header, but there was a row with {1} fields in the CSV file! Row {2} is invalid: {3}"",
										numColumns, val.length, currentRow, offendingLine));
			}
			currentRow++;
			return val;
		}

		private String safeToString(String[] valueArray) {
			if (valueArray == null) {
				return ""NULL"";
			} else if (valueArray.length == 0) {
				return ""[]"";
			} else {
				StringBuilder sb = new StringBuilder();
				sb.append('[');
				for (int i = 0; i < valueArray.length; i++) {
					String value = valueArray[i];
					if (value != null) {
						if (value.length() < MAX_FIELD_LENGTH_FOR_ERROR_REPORTING) {
							sb.append(value);
						} else {
							sb.append(value.substring(0, MAX_FIELD_LENGTH_FOR_ERROR_REPORTING - 1));
						}
						if (i > MAX_COLUMNS_FOR_ERROR_REPORTING) {
							return sb.append(String.format(""[... omitted %s further columns]"", valueArray.length - i))
									.toString();
						}
						if (i < valueArray.length - 1) {
							sb.append("", "");
						}
					}
				}
				return sb.append(']').toString();
			}
		}
	}

	private static final class CompressedCSVDataWriterFactory extends DataWriterFactory<String[]> {

		private final CSVConfig importConfig;
		private final CSVFile csvFile;

		private CompressedCSVDataWriterFactory(CSVFile csvFile, CSVConfig importConfig) {
			this.csvFile = csvFile;
			this.importConfig = importConfig;
		}

		public DataWriter<String[]> constructWriter(OutputStream os) throws IOException {
			final ICSVWriter writer = csvFile.getCSV().createWriter(new PLZFOutputStream(os), importConfig);
			// Write Header
			return new DataWriter<String[]>() {

				public void close() throws IOException {
					writer.close(); // catch IllegalStateException
				}

				public void writeEntry(String[] val) throws IOException {
					writer.writeNext(val);
				}
			};
		}
	}

	private static final class CompressedCSVDataReaderFactory extends DataReaderFactory<String[]> {

		private final CSVConfig importConfig;
		private final CSVFile csvFile;

		private CompressedCSVDataReaderFactory(CSVFile csvFile, CSVConfig importConfig) {
			this.csvFile = csvFile;
			this.importConfig = importConfig;
		}

		public DataReader<String[]> constructReader(InputStream is) throws IOException {
			final ICSVReader reader = csvFile.getCSV().createReader(new LZFInputStream(is), importConfig);
			return new DataReader<String[]>() {

				public void close() throws IOException {
					reader.close();
				}

				public int estimateSizeInBytes(String[] item) {
					return estimateSize(item);
				}

				public String[] readNext() throws IOException {
					return reader.readNext();
				}
			};
		}
	}

	private CSVSorter() {
	}

	/**
	 * Sorts an {@link CSVFile} using only a configurable, limited amount of
	 * memory.
	 * 
	 * @param csvFile
	 * @param rowComparator
	 * @param importConfig
	 * @param maxMemory
	 * @param numOfColumnsInCSV
	 * @param progress
	 * @return a {@link File} containing the sorted CSV
	 * @throws CSVSortException
	 */
	public static File sortCSV(final CSVFile csvFile, final Comparator<String[]> rowComparator,
			final CSVConfig importConfig, final int maxMemory, final int numOfColumnsInCSV,
			final ProgressListener progress) throws CSVSortException {

		// Create Sorter
		final CompressedCSVDataReaderFactory dataReaderFactory = new CompressedCSVDataReaderFactory(csvFile,
				importConfig);
		final CompressedCSVDataWriterFactory dataWriterFactory = new CompressedCSVDataWriterFactory(csvFile,
				importConfig);
		final IteratingSorter<String[]> sorter = new IteratingSorter<>(new SortConfig().withMaxMemoryUsage(
				maxMemory * 1024l * 1024l).withTempFileProvider(new TempFileProvider() {

			public File provide() throws IOException {
				return Files.createTempFile(csvFile.getFilename() + ""-merge-sort"", "".lzf"").toFile();
			}
		}), dataReaderFactory, dataWriterFactory, rowComparator);

		ExecutorService executorService = Executors.newSingleThreadExecutor();
		Future<File> future = executorService.submit(new Callable<File>() {

			public File call() throws Exception {

				// Read uncompressed CSV
				DataReader<String[]> inputDataReader = new UncompressedCSVReaderWithoutHeader(csvFile, importConfig,
						numOfColumnsInCSV);
				try {
					Iterator<String[]> result = sorter.sort(inputDataReader);

					// Write sorted result to compressed file
					if (result != null) {
						File sortedCsvFile = Files.createTempFile(csvFile.getFilename() + ""-sorted"", "".lzf"").toFile();
						DataWriter<String[]> dataWriter = dataWriterFactory.constructWriter(new FileOutputStream(
								sortedCsvFile));
						try {
							while (result.hasNext()) {
								dataWriter.writeEntry(result.next());
							}
						} finally {
							try {
								dataWriter.close();
							} catch (IllegalStateException e) {
								// already closed - ignore here to propagate the real exception
							}
						}
						return sortedCsvFile;
					} else {
						throw new CSVSortException(""Could not sort file! Unkown error while sorting."");
					}

				} finally {
					sorter.close();
				}

			}
		});

		try {
			executorService.shutdown();
			int sortRound = -1;
			int preSortFiles = -1;
			while (!executorService.awaitTermination(100, TimeUnit.MILLISECONDS)) {
				if (progress.getProgress().isCancelled()) {
					progress.log(""Cancelling sorting, this might take a while ..."");
					sorter.cancel(new RuntimeException(""Cancelled""));
					throw new CSVSortException(""User cancelled sorting"");
				}
				if (sorter.getPhase() == Phase.PRE_SORTING) {
					if (sorter.getSortRound() != sortRound) {
						sortRound = sorter.getSortRound();
						progress.log(MessageFormat.format(""Pre-sorting finished segment {0} in memory ..."",
								sortRound + 1));
					}
					if (sorter.getNumberOfPreSortFiles() != preSortFiles) {
						preSortFiles = sorter.getNumberOfPreSortFiles();
						progress.log(MessageFormat.format(""Pre-sorting finished segment {0} ..."", preSortFiles + 1));
					}
				} else if (sorter.getPhase() == Phase.SORTING) {
					if (sorter.getSortRound() != sortRound) {
						sortRound = sorter.getSortRound();
						progress.log(MessageFormat.format(""Sorting finished round {0}/{1} ..."", sortRound + 1,
								sorter.getNumberOfSortRounds() + 1));
					}
				}
			}
			return future.get();
		} catch (InterruptedException e) {
			progress.log(""Cancelling sorting, this might take a while ..."");
			sorter.cancel();
			throw new CSVSortException(""Cancelled sorting"", e);
		} catch (ExecutionException e) {
			throw new CSVSortException(""Could not sort file."", e);
		}
	}

	private static int estimateSize(String[] item) {
		int size = 8 * ((item.length * 4 + 12) / 8);
		for (String s : item) {
			if (s != null) {
				size += 8 * ((((s.length()) * 4) + 45) / 8);
			}
		}
		return size;
	}

}
"
CSVConversionConfigException.java,log,"package org.processmining.log.csvimport.exception;


/**
 * @author F. Mannhardt
 *
 */
public class CSVConversionConfigException extends CSVConversionException {

	private static final long serialVersionUID = 4329858720296484283L;

	public CSVConversionConfigException() {
	}

	public CSVConversionConfigException(String message) {
		super(message);
	}

	public CSVConversionConfigException(Throwable cause) {
		super(cause);
	}

	public CSVConversionConfigException(String message, Throwable cause) {
		super(message, cause);
	}

	public CSVConversionConfigException(String message, Throwable cause, boolean enableSuppression,
			boolean writableStackTrace) {
		super(message, cause, enableSuppression, writableStackTrace);
	}

}
"
CSVConversionException.java,log,"package org.processmining.log.csvimport.exception;


/**
 * @author F. Mannhardt
 *
 */
public class CSVConversionException extends Exception {

	private static final long serialVersionUID = -4532347650248107292L;

	public CSVConversionException() {
		super();
	}

	public CSVConversionException(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace) {
		super(message, cause, enableSuppression, writableStackTrace);
	}

	public CSVConversionException(String message, Throwable cause) {
		super(message, cause);
	}

	public CSVConversionException(String message) {
		super(message);
	}

	public CSVConversionException(Throwable cause) {
		super(cause);
	}
	

}
"
CSVSortException.java,log,"package org.processmining.log.csvimport.exception;

/**
 * @author F. Mannhardt
 *
 */
public class CSVSortException extends CSVConversionException {

	private static final long serialVersionUID = 5352796938595731289L;

	public CSVSortException() {
	}

	public CSVSortException(String message) {
		super(message);
	}

	public CSVSortException(Throwable cause) {
		super(cause);
	}

	public CSVSortException(String message, Throwable cause) {
		super(message, cause);
	}

	public CSVSortException(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace) {
		super(message, cause, enableSuppression, writableStackTrace);
	}

}
"
CSVConversionHandler.java,log,"package org.processmining.log.csvimport.handler;

import java.util.Date;

import org.processmining.log.csv.CSVFile;
import org.processmining.log.csvimport.exception.CSVConversionException;

/**
 * Handler for the conversion following a visitor-like pattern.
 * 
 * @author F. Mannhardt
 *
 * @param <R>
 */
public interface CSVConversionHandler<R> {

	/**
	 * Called upon start parsing the {@link CSVFile}.
	 * 
	 * @param inputFile
	 */
	void startLog(CSVFile inputFile);

	/**
	 * Called when a new trace is encountered. Traces are assumed to be sorted
	 * by caseId, therefore, this is only called once per trace.
	 * 
	 * @param caseId
	 */
	void startTrace(String caseId);

	/**
	 * Called after a traces has been fully parsed.
	 * 
	 * @param caseId
	 */
	void endTrace(String caseId);

	/**
	 * Called when parsing a row, thereby creating an event.
	 * 
	 * @param eventClass
	 *            the name (class) of the event
	 * @param completionTime
	 *            the completion time possibly NULL
	 * @param startTime
	 *            the start time possibly NULL
	 */
	void startEvent(String eventClass, Date completionTime, Date startTime);

	/**
	 * Called when a string attribute is parsed
	 * 
	 * @param name
	 * @param value
	 */
	void startAttribute(String name, String value);

	/**
	 * Called when a long attribute is parsed
	 * 
	 * @param name
	 * @param value
	 */
	void startAttribute(String name, long value);

	/**
	 * Called when a double attribute is parsed
	 * 
	 * @param name
	 * @param value
	 */
	void startAttribute(String name, double value);

	/**
	 * Called when a date attribute is parsed
	 * 
	 * @param name
	 * @param value
	 */
	void startAttribute(String name, Date value);

	/**
	 * Called when a boolean attribute is parsed
	 * 
	 * @param name
	 * @param value
	 */
	void startAttribute(String name, boolean value);

	/**
	 * Called after the attribute has been parsed
	 */
	void endAttribute();

	/**
	 * Called when the full row (including all attributes) have been parsed.
	 */
	void endEvent();

	/**
	 * Detected an error in the conversion.
	 * 
	 * @param lineNumber
	 * @param columnIndex
	 * @param attributeName
	 * @param cellContent
	 * @param e
	 * @throws CSVConversionException
	 */
	void errorDetected(int lineNumber, int columnIndex, String attributeName, Object cellContent, Exception e) throws CSVConversionException;

	/**
	 * @return the result of the parse
	 */
	R getResult();

	/**
	 * @return whether any errors have been encountered during the conversion
	 */
	boolean hasConversionErrors();

	/**
	 * @return a descriptive String of the error
	 */
	String getConversionErrors();

}
"
XESConversionHandlerImpl.java,log,"package org.processmining.log.csvimport.handler;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.Date;
import java.util.List;

import org.deckfour.xes.extension.XExtension;
import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.extension.std.XLifecycleExtension;
import org.deckfour.xes.extension.std.XLifecycleExtension.StandardModel;
import org.deckfour.xes.extension.std.XTimeExtension;
import org.deckfour.xes.factory.XFactory;
import org.deckfour.xes.info.impl.XLogInfoImpl;
import org.deckfour.xes.model.XAttributable;
import org.deckfour.xes.model.XAttribute;
import org.deckfour.xes.model.XAttributeBoolean;
import org.deckfour.xes.model.XAttributeContinuous;
import org.deckfour.xes.model.XAttributeDiscrete;
import org.deckfour.xes.model.XAttributeLiteral;
import org.deckfour.xes.model.XAttributeTimestamp;
import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.processmining.log.csv.CSVFile;
import org.processmining.log.csv.config.CSVConfig;
import org.processmining.log.csvimport.config.CSVConversionConfig;
import org.processmining.log.csvimport.config.CSVConversionConfig.CSVErrorHandlingMode;
import org.processmining.log.csvimport.config.CSVConversionConfig.CSVMapping;
import org.processmining.log.csvimport.config.CSVConversionConfig.ExtensionAttribute;
import org.processmining.log.csvimport.exception.CSVConversionException;
import org.processmining.log.utils.XUtils;

import com.google.common.collect.Ordering;

/**
 * Handler that creates an XLog from a CSV
 * 
 * @author F. Mannhardt
 *
 */
public class XESConversionHandlerImpl implements CSVConversionHandler<XLog> {

	private static final int MAX_ERROR_LENGTH = 1 * 1024 * 1024;

	private static final Comparator<? super XEvent> TIME_COMPARATOR = new Comparator<XEvent>() {

		public int compare(XEvent o1, XEvent o2) {
			// assumes stable sorting so start events will be always before complete events
			Date time1 = XUtils.getTimestamp(o1);
			Date time2 = XUtils.getTimestamp(o2);
			return Ordering.natural() // use Date built-in comparator
					.nullsFirst() // null aware since some events might not have times
					.compare(time1, time2);
		}
	};

	private final XFactory factory;
	private final CSVConversionConfig conversionConfig;
	private final StringBuilder conversionErrors;

	private XLog log = null;

	private XTrace currentTrace = null;
	private List<XEvent> currentEvents = new ArrayList<>();

	private int instanceCounter = 0;

	private XEvent currentEvent = null;
	private XEvent currentStartEvent;

	private boolean errorDetected = false;

	public XESConversionHandlerImpl(CSVConfig importConfig, CSVConversionConfig conversionConfig) {
		this.conversionConfig = conversionConfig;
		this.factory = conversionConfig.getFactory();
		this.conversionErrors = new StringBuilder();
	}

	@Override
	public String getConversionErrors() {
		if (conversionErrors.length() >= MAX_ERROR_LENGTH) {
			return conversionErrors.toString()
					.concat(""... (multiple error messages have been omitted to avoid running out of memory)"");
		} else {
			return conversionErrors.toString();
		}
	}

	@Override
	public boolean hasConversionErrors() {
		return conversionErrors.length() != 0;
	}

	@Override
	public void startLog(CSVFile inputFile) {
		log = factory.createLog();
		if (conversionConfig.getEventNameColumns() != null) {
			log.getExtensions().add(XConceptExtension.instance());
			log.getClassifiers().add(XLogInfoImpl.NAME_CLASSIFIER);
		}
		if (conversionConfig.getCompletionTimeColumn() != null || conversionConfig.getStartTimeColumn() != null) {
			log.getExtensions().add(XTimeExtension.instance());
			log.getExtensions().add(XLifecycleExtension.instance());
			log.getClassifiers().add(XUtils.STANDARDCLASSIFIER);
		}
		assignName(factory, log, inputFile.getFilename());
	}

	@Override
	public void startTrace(String caseId) {
		currentEvents.clear();
		errorDetected = false;
		currentTrace = factory.createTrace();
		assignName(factory, currentTrace, caseId);
	}

	@Override
	public void endTrace(String caseId) {
		if (errorDetected && conversionConfig.getErrorHandlingMode() == CSVErrorHandlingMode.OMIT_TRACE_ON_ERROR) {
			// Skip the entire trace
			return;
		}
		sortEventsByTimestamp();
		currentTrace.addAll(currentEvents);
		log.add(currentTrace);
	}

	private void sortEventsByTimestamp() {
		Collections.sort(currentEvents, TIME_COMPARATOR);
	}

	@Override
	public void startEvent(String eventClass, Date completionTime, Date startTime) {
		if (conversionConfig.getErrorHandlingMode() == CSVErrorHandlingMode.OMIT_EVENT_ON_ERROR) {
			// Include the other events in that trace
			errorDetected = false;
		}

		currentEvent = factory.createEvent();
		if (eventClass != null) {
			assignName(factory, currentEvent, eventClass);
		}

		if (startTime == null && completionTime == null) {
			// Both times are unknown only create an event assuming it is the completion event
			assignLifecycleTransition(factory, currentEvent, XLifecycleExtension.StandardModel.COMPLETE);
		} else if (startTime != null && completionTime != null) {
			// Both start and complete are present
			String instance = String.valueOf((instanceCounter++));

			// Assign attribute for complete event (currentEvent)			
			assignTimestamp(factory, currentEvent, completionTime);
			assignInstance(factory, currentEvent, instance);
			assignLifecycleTransition(factory, currentEvent, XLifecycleExtension.StandardModel.COMPLETE);

			// Add additional start event
			currentStartEvent = factory.createEvent();
			if (eventClass != null) {
				assignName(factory, currentStartEvent, eventClass);
			}
			assignTimestamp(factory, currentStartEvent, startTime);
			assignInstance(factory, currentStartEvent, instance);
			assignLifecycleTransition(factory, currentStartEvent, XLifecycleExtension.StandardModel.START);

		} else {
			// Either start or complete are present
			if (completionTime != null) {
				// Only create Complete
				assignTimestamp(factory, currentEvent, completionTime);
				assignLifecycleTransition(factory, currentEvent, XLifecycleExtension.StandardModel.COMPLETE);
			} else if (startTime != null) {
				// Only create Start
				assignTimestamp(factory, currentEvent, startTime);
				assignLifecycleTransition(factory, currentEvent, XLifecycleExtension.StandardModel.START);
			} else {
				throw new IllegalStateException(
						""Both start and complete time are NULL. This should never be the case here!"");
			}
		}
	}

	@Override
	public void startAttribute(String name, String value) {
		if (!specialColumn(name)) {
			assignAttribute(currentEvent, createLiteral(name, value));
			if (isShouldAddStartEventAttributes() && currentStartEvent != null) {
				assignAttribute(currentStartEvent, createLiteral(name, value));
			}
		}
	}

	private XAttributeLiteral createLiteral(String name, String value) {
		return factory.createAttributeLiteral(getNameFromConfig(name), value, getExtensionFromConfig(name));
	}

	@Override
	public void startAttribute(String name, long value) {
		if (!specialColumn(name)) {
			assignAttribute(currentEvent, createDiscrete(name, value));
			if (isShouldAddStartEventAttributes() && currentStartEvent != null) {
				assignAttribute(currentStartEvent, createDiscrete(name, value));
			}
		}
	}

	private XAttributeDiscrete createDiscrete(String name, long value) {
		return factory.createAttributeDiscrete(getNameFromConfig(name), value, getExtensionFromConfig(name));
	}

	@Override
	public void startAttribute(String name, double value) {
		if (!specialColumn(name)) {
			assignAttribute(currentEvent, createContinuous(name, value));
			if (isShouldAddStartEventAttributes() && currentStartEvent != null) {
				assignAttribute(currentStartEvent, createContinuous(name, value));
			}
		}
	}

	private XAttributeContinuous createContinuous(String name, double value) {
		return factory.createAttributeContinuous(getNameFromConfig(name), value, getExtensionFromConfig(name));
	}

	@Override
	public void startAttribute(String name, Date value) {
		if (!specialColumn(name)) {
			assignAttribute(currentEvent, createDate(name, value));
			if (isShouldAddStartEventAttributes() && currentStartEvent != null) {
				assignAttribute(currentStartEvent, createDate(name, value));
			}
		}
	}

	private XAttributeTimestamp createDate(String name, Date value) {
		return factory.createAttributeTimestamp(getNameFromConfig(name), value, getExtensionFromConfig(name));
	}

	@Override
	public void startAttribute(String name, boolean value) {
		if (!specialColumn(name)) {
			assignAttribute(currentEvent, createBoolean(name, value));
			if (isShouldAddStartEventAttributes() && currentStartEvent != null) {
				assignAttribute(currentStartEvent, createBoolean(name, value));
			}
		}
	}

	private XAttributeBoolean createBoolean(String name, boolean value) {
		return factory.createAttributeBoolean(getNameFromConfig(name), value, getExtensionFromConfig(name));
	}

	private XExtension getExtensionFromConfig(String name) {
		ExtensionAttribute extensionAttribute = getExtensionAttribute(name);
		return extensionAttribute == null ? null : extensionAttribute.extension;
	}

	private String getNameFromConfig(String columnName) {
		CSVMapping csvMapping = getMapping(columnName);
		if (csvMapping.getEventExtensionAttribute() != null
				&& csvMapping.getEventExtensionAttribute() != CSVConversionConfig.NO_EXTENSION_ATTRIBUTE) {
			return csvMapping.getEventExtensionAttribute().key;
		} else if (csvMapping.getEventAttributeName() != null && !csvMapping.getEventAttributeName().isEmpty()) {
			return csvMapping.getEventAttributeName();
		} else {
			return columnName;
		}
	}

	private ExtensionAttribute getExtensionAttribute(String name) {
		return getMapping(name).getEventExtensionAttribute();
	}

	private CSVMapping getMapping(String name) {
		return conversionConfig.getConversionMap().get(name);
	}

	@Override
	public void endAttribute() {
		//No-op
	}

	@Override
	public void endEvent() {
		if (errorDetected && conversionConfig.getErrorHandlingMode() == CSVErrorHandlingMode.OMIT_EVENT_ON_ERROR) {
			// Do not include the event
			return;
		}
		// Add start event before complete event to guarantee order for events with same time-stamp
		if (currentStartEvent != null) {
			currentEvents.add(currentStartEvent);
			currentStartEvent = null;
		}
		currentEvents.add(currentEvent);
		currentEvent = null;
	}

	public XLog getResult() {
		return log;
	}

	private static void assignAttribute(XAttributable a, XAttribute value) {
		XUtils.putAttribute(a, value);
	}

	private static void assignLifecycleTransition(XFactory factory, XAttributable a, StandardModel lifecycle) {
		assignAttribute(a, factory.createAttributeLiteral(XLifecycleExtension.KEY_TRANSITION, lifecycle.getEncoding(),
				XLifecycleExtension.instance()));
	}

	private static void assignInstance(XFactory factory, XAttributable a, String value) {
		assignAttribute(a,
				factory.createAttributeLiteral(XConceptExtension.KEY_INSTANCE, value, XConceptExtension.instance()));
	}

	private static void assignTimestamp(XFactory factory, XAttributable a, Date value) {
		assignAttribute(a,
				factory.createAttributeTimestamp(XTimeExtension.KEY_TIMESTAMP, value, XTimeExtension.instance()));
	}

	private static void assignName(XFactory factory, XAttributable a, String value) {
		assignAttribute(a,
				factory.createAttributeLiteral(XConceptExtension.KEY_NAME, value, XConceptExtension.instance()));
	}

	@Override
	public void errorDetected(int lineNumber, int columnIndex, String attributeName, Object content, Exception e)
			throws CSVConversionException {
		CSVErrorHandlingMode errorMode = conversionConfig.getErrorHandlingMode();
		errorDetected = true;
		String columnInfo = String.format(""Attribute '%s' with column index %s "", attributeName, columnIndex);
		switch (errorMode) {
			case BEST_EFFORT :
				if (conversionErrors.length() < MAX_ERROR_LENGTH) {
					conversionErrors.append(""Line: "" + lineNumber + "", "" + columnInfo + ""\n"" + ""Skipping attribute ""
							+ nullSafeToString(content) + ""\nError: "" + e + ""\n\n"");
				}
				break;
			case OMIT_EVENT_ON_ERROR :
				if (conversionErrors.length() < MAX_ERROR_LENGTH) {
					conversionErrors.append(
							""Line: "" + lineNumber + "", "" + columnInfo + ""\n"" + ""Skipping event, could not convert ""
									+ nullSafeToString(content) + ""\nError: "" + e + ""\n\n"");
				}
				break;
			case OMIT_TRACE_ON_ERROR :
				if (conversionErrors.length() < MAX_ERROR_LENGTH) {
					conversionErrors.append(""Line: "" + lineNumber + "", "" + columnInfo + ""\n"" + ""Skipping trace ""
							+ XUtils.getConceptName(currentTrace) + "", could not convert "" + nullSafeToString(content)
							+ ""\nError: "" + e + ""\n\n"");
				}
				break;
			default :
			case ABORT_ON_ERROR :
				throw new CSVConversionException(
						""Error converting "" + content + "" at line "" + lineNumber + ""and column "" + columnIndex, e);
		}
	}

	private static String nullSafeToString(Object obj) {
		if (obj == null) {
			return ""NULL"";
		} else if (obj.getClass().isArray()) {
			return Arrays.toString((Object[]) obj);
		} else {
			return obj.toString();
		}
	}

	private boolean specialColumn(String columnName) {
		return columnName == null
				|| (XConceptExtension.KEY_NAME.equals(columnName) && !conversionConfig.getEventNameColumns().isEmpty())
				|| (XTimeExtension.KEY_TIMESTAMP.equals(columnName)
						&& conversionConfig.getCompletionTimeColumn() != null)
				|| (XConceptExtension.KEY_INSTANCE.equals(columnName) && conversionConfig.getStartTimeColumn() != null);
	}

	public boolean isShouldAddStartEventAttributes() {
		return conversionConfig.isShouldAddStartEventAttributes();
	}

}"
StringBasedImportOrdering.java,log,"package org.processmining.log.csvimport;

import com.google.common.collect.Ordering;

final class StringBasedImportOrdering extends Ordering<String[]> {

	private final int[] sortingIndices;

	public StringBasedImportOrdering(int[] sortingIndicies) {
		this.sortingIndices = sortingIndicies;
	}

	public int compare(String[] o1, String[] o2) {
		if (o1.length != o2.length) {
			throw new IllegalArgumentException(
					""Can only compare lines in a CSV file with the same number of columns!"");
		}
		// First compare on all the case columns
		for (int i = 0; i < sortingIndices.length; i++) {
			int index = sortingIndices[i];
			// We treat empty and NULL cells as the same as there is no concept of a NULL cell in CSV 
			String s1 = o1[index] == null ? """" : o1[index];
			String s2 = o2[index] == null ? """" : o2[index];
			int comp = s1.compareTo(s2);
			if (comp != 0) {
				// Case ID is different on current index
				return comp;
			}
		}
		// Keep ordering -> using a stable sort algorithm
		return 0;
	}

}"
ConversionConfigUI.java,log,"package org.processmining.log.csvimport.ui;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.AdjustmentEvent;
import java.awt.event.AdjustmentListener;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.io.IOException;
import java.text.SimpleDateFormat;
import java.util.List;

import javax.swing.DefaultComboBoxModel;
import javax.swing.GroupLayout;
import javax.swing.GroupLayout.Alignment;
import javax.swing.GroupLayout.ParallelGroup;
import javax.swing.GroupLayout.SequentialGroup;
import javax.swing.JButton;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.SwingWorker;
import javax.swing.Timer;
import javax.swing.event.ListDataEvent;
import javax.swing.event.ListDataListener;

import org.processmining.framework.util.ui.widgets.ProMComboBox;
import org.processmining.framework.util.ui.widgets.ProMListSortableWithComboBox;
import org.processmining.framework.util.ui.widgets.ProMTextField;
import org.processmining.framework.util.ui.widgets.helper.ProMUIHelper;
import org.processmining.log.csv.CSVFile;
import org.processmining.log.csv.ICSVReader;
import org.processmining.log.csv.config.CSVConfig;
import org.processmining.log.csvimport.config.CSVConversionConfig;
import org.processmining.log.csvimport.config.CSVConversionConfig.CSVMapping;
import org.processmining.log.csvimport.ui.preview.CSVPreviewFrame;

import com.fluxicon.slickerbox.components.SlickerButton;
import com.fluxicon.slickerbox.factory.SlickerFactory;
import com.google.common.collect.Lists;

/**
 * UI for the configuration of the actual conversion
 * 
 * @author F. Mannhardt
 *
 */
public final class ConversionConfigUI extends CSVConfigurationPanel implements AutoCloseable {

	private static final int COLUMN_WIDTH = 360;

	private final class ChangeListenerImpl implements ActionListener {

		public void actionPerformed(ActionEvent e) {
			updateSettings();
		}

		public void updateSettings() {
			try {
				conversionConfig.setCaseColumns(caseComboBox.getElements());
				conversionConfig.setEventNameColumns(eventComboBox.getElements());
				conversionConfig.setStartTimeColumn(startTimeColumnCbx.getSelectedItem().toString());
				conversionConfig.setCompletionTimeColumn(completionTimeColumnCbx.getSelectedItem().toString());

				if (conversionConfig.getStartTimeColumn().isEmpty()) {
					startTimeFormat.setText("""");
					startTimeFormat.setEnabled(false);
				} else {
					startTimeFormat.setEnabled(true);
					if (hasManipulatedStartTime) {
						CSVMapping mapping = conversionConfig.getConversionMap()
								.get(conversionConfig.getStartTimeColumn());
						mapping.setPattern(startTimeFormat.getText());
					} else {
						// use originally guess format 
						startTimeFormat.setText(conversionConfig.getConversionMap()
								.get(conversionConfig.getStartTimeColumn()).getPattern());
					}
				}

				if (conversionConfig.getCompletionTimeColumn().isEmpty()) {
					completionTimeFormat.setText("""");
					completionTimeFormat.setEnabled(false);
				} else {
					completionTimeFormat.setEnabled(true);
					if (hasManipulatedCompletionTime) {
						CSVMapping mapping = conversionConfig.getConversionMap()
								.get(conversionConfig.getCompletionTimeColumn());
						mapping.setPattern(completionTimeFormat.getText());
					} else {
						// use originally guess format 
						completionTimeFormat.setText(conversionConfig.getConversionMap()
								.get(conversionConfig.getCompletionTimeColumn()).getPattern());
					}
				}
			} catch (RuntimeException e) {
				ProMUIHelper.showErrorMessage(previewFrame, e.getMessage() != null ? e.getMessage() : e.toString(), ""Error updating configuration"", e);
			}

			previewFrame.refresh();
		}

	}

	private final class LoadCSVRecordsWorker extends SwingWorker<Void, String[]> {
		protected Void doInBackground() throws Exception {
			String[] oldLine = null;
			String[] nextLine;
			int i = 0;
			while ((nextLine = reader.readNext()) != null && i < maxLoad) {
				if (oldLine != null) {
					if (oldLine.length != nextLine.length) {
						throw new IllegalArgumentException(
								""CSV file has inconsistent number of columns, please check CSV config."");
					}
				}
				publish(nextLine);
				oldLine = nextLine;
				i++;
			}
			return null;
		}

		protected void process(List<String[]> chunks) {
			previewFrame.addRows(chunks);
			previewFrame.setTitle(String.format(""CSV Preview (%s rows - scroll down to load more)"",
					previewFrame.getPreviewTable().getModel().getRowCount()));
		}
	}

	private static final long serialVersionUID = 2L;

	private static final int ACTION_DELAY = 500;

	private final CSVConversionConfig conversionConfig;

	private final String[] headers;
	private final String[] headersInclEmpty;

	private final ProMListSortableWithComboBox<String> caseComboBox;
	private final ProMListSortableWithComboBox<String> eventComboBox;
	private final ProMComboBox<String> completionTimeColumnCbx;
	private final ProMComboBox<String> startTimeColumnCbx;

	private final ChangeListenerImpl changeListener;
	private final Timer updateTimer;

	private final ICSVReader reader;
	private final CSVPreviewFrame previewFrame;
	private int maxLoad = 1000;

	private ProMTextField completionTimeFormat;
	private ProMTextField startTimeFormat;

	private boolean hasManipulatedStartTime = false;
	private boolean hasManipulatedCompletionTime = false;

	public ConversionConfigUI(final CSVFile csv, final CSVConfig importConfig, CSVConversionConfig conversionConfig)
			throws IOException {
		this.conversionConfig = conversionConfig;

		reader = csv.createReader(importConfig);
		headers = reader.readNext();
		headersInclEmpty = Lists.asList("""", headers).toArray(new String[headers.length + 1]);
		changeListener = new ChangeListenerImpl();
		updateTimer = new Timer(ACTION_DELAY, new ActionListener() {

			public void actionPerformed(ActionEvent e) {
				changeListener.updateSettings();
			}
		});
		updateTimer.setRepeats(false);

		GroupLayout layout = new GroupLayout(this);
		setLayout(layout);
		setMaximumSize(new Dimension(COLUMN_WIDTH * 2, Short.MAX_VALUE));
		layout.setAutoCreateContainerGaps(true);
		layout.setAutoCreateGaps(true);

		JLabel standardAttributesLabel = SlickerFactory.instance()
				.createLabel(""<HTML><H2>Mapping to Standard XES Attributes</H2></HTML>"");
		JButton showPreviewButton = new SlickerButton(""Show Expert Configuration"");
		showPreviewButton.addActionListener(new ActionListener() {

			public void actionPerformed(ActionEvent e) {
				togglePreviewFrame();
			}
		});

		caseComboBox = new ProMListSortableWithComboBox<>(new DefaultComboBoxModel<>(headers));
		JLabel caseLabel = createLabel(""Case Column (Optional)"",
				""Groups events into traces, and is mapped to 'concept:name' of the trace. Select one or more columns, re-order by drag & drop."");
		for (String caseColumn : conversionConfig.getCaseColumns()) {
			caseComboBox.addElement(caseColumn);
		}
		caseComboBox.getSelectedItemsText().setText(""Selected case columns:"");
		caseComboBox.getListModel().addListDataListener(new ListDataListener() {

			public void intervalRemoved(ListDataEvent e) {
				changeListener.updateSettings();
			}

			public void intervalAdded(ListDataEvent e) {
				changeListener.updateSettings();
			}

			public void contentsChanged(ListDataEvent e) {
				changeListener.updateSettings();
			}
		});

		eventComboBox = new ProMListSortableWithComboBox<>(new DefaultComboBoxModel<>(headers));
		JLabel eventLabel = createLabel(""Event Column (Optional)"",
				""Mapped to 'concept:name' of the event. Select one or more columns, re-order by drag & drop."");
		for (String eventColumn : conversionConfig.getEventNameColumns()) {
			eventComboBox.addElement(eventColumn);
		}
		eventComboBox.getSelectedItemsText().setText(""Selected event columns:"");
		eventComboBox.getListModel().addListDataListener(new ListDataListener() {

			public void intervalRemoved(ListDataEvent e) {
				changeListener.updateSettings();
			}

			public void intervalAdded(ListDataEvent e) {
				changeListener.updateSettings();
			}

			public void contentsChanged(ListDataEvent e) {
				changeListener.updateSettings();
			}
		});

		completionTimeColumnCbx = new ProMComboBox<>(headersInclEmpty);
		completionTimeColumnCbx.setToolTipText(
				""Mapped to 'time:timestamp' of the main event that is created for each row in the CSV file."");
		JLabel completionTimeLabel = createLabel(""Completion Time (Optional)"", ""Mapped to 'time:timestamp'"");
		if (conversionConfig.getCompletionTimeColumn() != null) {
			completionTimeColumnCbx.setSelectedItem(conversionConfig.getCompletionTimeColumn());
		} else {
			completionTimeColumnCbx.setSelectedItem("""");
		}
		completionTimeColumnCbx.addActionListener(new ActionListener() {

			public void actionPerformed(ActionEvent e) {
				hasManipulatedCompletionTime = false;
				changeListener.updateSettings();
			}
		});

		completionTimeFormat = new ProMTextField("""",
				""Could not auto-detect the used date format. Please provide a SimpleDateFormat pattern!"");
		if (conversionConfig.getCompletionTimeColumn() != null
				&& !conversionConfig.getCompletionTimeColumn().isEmpty()) {
			completionTimeFormat.setText(
					conversionConfig.getConversionMap().get(conversionConfig.getCompletionTimeColumn()).getPattern());
		}
		completionTimeFormat.addKeyListener(new KeyAdapter() {

			public void keyPressed(KeyEvent e) {
				hasManipulatedCompletionTime = true;
				update();
			}

			private void update() {
				try {
					new SimpleDateFormat(completionTimeFormat.getText());
					updateTimer.restart();
					completionTimeFormat.getTextField().setForeground(Color.WHITE);
				} catch (IllegalArgumentException e) {
					completionTimeFormat.getTextField().setForeground(Color.RED);
				}
			}

		});

		startTimeColumnCbx = new ProMComboBox<>(headersInclEmpty);
		startTimeColumnCbx.setToolTipText(
				""<HTML>Mapped to 'time:timestamp' of an extra 'start' event that is created for each row in the CSV file. ""
						+ ""<BR/>In case your lifecycle events such as 'start' are already separate row in the CSV file, please leave this empty and use the 'Expert Mode' to configure an appropriate mapping.</HTML>"");
		JLabel startTimeLabel = createLabel(""Start Time (Optional)"",
				""Mapped to 'time:timestamp' of a separate start event"");
		if (conversionConfig.getStartTimeColumn() != null) {
			startTimeColumnCbx.setSelectedItem(conversionConfig.getStartTimeColumn());
		} else {
			startTimeColumnCbx.setSelectedItem("""");
		}
		startTimeColumnCbx.addActionListener(new ActionListener() {

			public void actionPerformed(ActionEvent e) {
				hasManipulatedStartTime = false;
				changeListener.updateSettings();
			}
		});

		startTimeFormat = new ProMTextField("""",
				""Could not auto-detect the used date format. Please provide a SimpleDateFormat pattern!"");
		if (conversionConfig.getStartTimeColumn() != null && !conversionConfig.getStartTimeColumn().isEmpty()) {
			startTimeFormat.setText(
					conversionConfig.getConversionMap().get(conversionConfig.getStartTimeColumn()).getPattern());
		}

		startTimeFormat.addKeyListener(new KeyAdapter() {

			public void keyPressed(KeyEvent e) {
				hasManipulatedStartTime = true;
				update();
			}

			private void update() {
				try {
					new SimpleDateFormat(startTimeFormat.getText());
					updateTimer.restart();
					startTimeFormat.getTextField().setForeground(Color.WHITE);
				} catch (IllegalArgumentException e) {
					startTimeFormat.getTextField().setForeground(Color.RED);
				}
			}

		});

		SequentialGroup verticalGroup = layout.createSequentialGroup();
		verticalGroup.addGroup(layout.createParallelGroup(Alignment.CENTER).addComponent(standardAttributesLabel)
				.addComponent(showPreviewButton));
		verticalGroup.addGroup(layout.createParallelGroup()
				.addGroup(layout.createSequentialGroup().addComponent(caseLabel).addComponent(caseComboBox))
				.addGroup(layout.createSequentialGroup().addComponent(eventLabel).addComponent(eventComboBox)));
		verticalGroup.addGroup(layout.createParallelGroup()
				.addGroup(layout.createSequentialGroup().addComponent(startTimeLabel).addComponent(startTimeColumnCbx)
						.addComponent(startTimeFormat))
				.addGroup(layout.createSequentialGroup().addComponent(completionTimeLabel)
						.addComponent(completionTimeColumnCbx).addComponent(completionTimeFormat)));

		ParallelGroup horizontalGroup = layout.createParallelGroup();
		horizontalGroup.addGroup(
				layout.createSequentialGroup().addComponent(standardAttributesLabel).addComponent(showPreviewButton));
		horizontalGroup.addGroup(layout.createSequentialGroup()
				.addGroup(layout.createParallelGroup().addComponent(caseLabel, COLUMN_WIDTH, COLUMN_WIDTH, COLUMN_WIDTH)
						.addComponent(caseComboBox, COLUMN_WIDTH, COLUMN_WIDTH, COLUMN_WIDTH))
				.addGroup(
						layout.createParallelGroup().addComponent(eventLabel, COLUMN_WIDTH, COLUMN_WIDTH, COLUMN_WIDTH)
								.addComponent(eventComboBox, COLUMN_WIDTH, COLUMN_WIDTH, COLUMN_WIDTH)));
		horizontalGroup.addGroup(layout.createSequentialGroup()
				.addGroup(layout.createParallelGroup()
						.addComponent(startTimeLabel, COLUMN_WIDTH, COLUMN_WIDTH, COLUMN_WIDTH)
						.addComponent(startTimeColumnCbx, COLUMN_WIDTH, COLUMN_WIDTH, COLUMN_WIDTH)
						.addComponent(startTimeFormat, COLUMN_WIDTH, COLUMN_WIDTH, COLUMN_WIDTH))
				.addGroup(layout.createParallelGroup()
						.addComponent(completionTimeLabel, COLUMN_WIDTH, COLUMN_WIDTH, COLUMN_WIDTH)
						.addComponent(completionTimeColumnCbx, COLUMN_WIDTH, COLUMN_WIDTH, COLUMN_WIDTH)
						.addComponent(completionTimeFormat, COLUMN_WIDTH, COLUMN_WIDTH, COLUMN_WIDTH)));

		layout.linkSize(eventLabel, caseLabel);
		layout.linkSize(completionTimeLabel, startTimeLabel);

		layout.setAutoCreateContainerGaps(true);
		layout.setAutoCreateGaps(true);

		layout.setVerticalGroup(verticalGroup);
		layout.setHorizontalGroup(horizontalGroup);

		previewFrame = new CSVPreviewFrame(headers, conversionConfig);
		previewFrame.setTitle(""Expert Configuration & Preview - Scroll down to load more rows"");
		previewFrame.getMainScrollPane().getVerticalScrollBar().addAdjustmentListener(new AdjustmentListener() {

			public void adjustmentValueChanged(AdjustmentEvent e) {
				int maximum = e.getAdjustable().getMaximum();
				int current = e.getValue();
				if (Math.abs(maximum - current) < 1000 && !e.getValueIsAdjusting()) {
					new LoadCSVRecordsWorker().execute();
				}
			}
		});

		changeListener.updateSettings();
	}

	private void togglePreviewFrame() {
		if (!previewFrame.isVisible()) {
			previewFrame.showFrame(this);
			try {
				// Update Content
				new LoadCSVRecordsWorker().execute();
			} catch (Exception e) {
				JOptionPane.showMessageDialog(this, ""Error parsing CSV "" + e.getMessage(), ""CSV Parsing Error"",
						JOptionPane.ERROR_MESSAGE);
			}
		} else {
			previewFrame.setVisible(false);
		}
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see javax.swing.JComponent#addNotify()
	 */
	@Override
	public void addNotify() {
		super.addNotify();
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see javax.swing.JComponent#removeNotify()
	 */
	@Override
	public void removeNotify() {
		super.removeNotify();
		changeListener.updateSettings();
		previewFrame.save();
		previewFrame.setVisible(false);
	}

	public CSVConversionConfig getConversionConfig() {
		return conversionConfig;
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see java.lang.AutoCloseable#close()
	 */
	public void close() {
		try {
			reader.close();
		} catch (IOException e) {
			JOptionPane.showMessageDialog(null, e.toString());
		}
	}

}
"
CSVConfigurationPanel.java,log,"package org.processmining.log.csvimport.ui;

import java.awt.Font;

import javax.swing.JLabel;
import javax.swing.JPanel;

import com.fluxicon.slickerbox.factory.SlickerFactory;

public class CSVConfigurationPanel extends JPanel {

	private static final long serialVersionUID = 6462901867808436259L;

	protected static JLabel createLabel(String caption, String description) {
		JLabel eventLabel = SlickerFactory.instance().createLabel(
				""<HTML><B>"" + caption + ""</B><BR/><I>"" + description + ""</I></HTML>"");
		eventLabel.setFont(eventLabel.getFont().deriveFont(Font.PLAIN));
		return eventLabel;
	}


}
"
ExpertConfigUI.java,log,"package org.processmining.log.csvimport.ui;

import java.awt.Dimension;
import java.awt.Font;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.lang.reflect.InvocationTargetException;
import java.util.Set;

import javax.swing.GroupLayout;
import javax.swing.GroupLayout.Alignment;
import javax.swing.GroupLayout.ParallelGroup;
import javax.swing.GroupLayout.SequentialGroup;
import javax.swing.JLabel;

import org.deckfour.xes.factory.XFactory;
import org.deckfour.xes.factory.XFactoryRegistry;
import org.processmining.framework.util.ui.widgets.ProMComboBox;
import org.processmining.log.csv.CSVFile;
import org.processmining.log.csv.config.CSVConfig;
import org.processmining.log.csvimport.config.CSVConversionConfig;
import org.processmining.log.csvimport.config.CSVConversionConfig.CSVAttributeConversionMode;
import org.processmining.log.csvimport.config.CSVConversionConfig.CSVEmptyCellHandlingMode;
import org.processmining.log.csvimport.config.CSVConversionConfig.CSVErrorHandlingMode;

import com.fluxicon.slickerbox.factory.SlickerFactory;
import com.google.common.base.Function;
import com.google.common.collect.Iterables;

public class ExpertConfigUI extends CSVConfigurationPanel {

	private static final long serialVersionUID = 7749368962812585099L;

	private static final int COLUMN_WIDTH = 360;

	private static final class XFactoryUI {

		private final XFactory factory;

		public XFactoryUI(XFactory factory) {
			super();
			this.factory = factory;
		}

		public XFactory getFactory() {
			return factory;
		}

		@Override
		public String toString() {
			return factory.getName();
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;
			result = prime * result + ((factory == null) ? 0 : factory.hashCode());
			return result;
		}

		@Override
		public boolean equals(Object obj) {
			if (this == obj)
				return true;
			if (obj == null)
				return false;
			if (!(obj instanceof XFactoryUI))
				return false;
			XFactoryUI other = (XFactoryUI) obj;
			if (factory == null) {
				if (other.factory != null)
					return false;
			} else if (!factory.equals(other.factory))
				return false;
			return true;
		}

	}

	private final ProMComboBox<XFactoryUI> xFactoryChoice;
	private final ProMComboBox<CSVEmptyCellHandlingMode> emptyCellHandlingModeCbx;
	private final ProMComboBox<CSVErrorHandlingMode> errorHandlingModeCbx;
	private final ProMComboBox<CSVAttributeConversionMode> attributeConversionModeCbx;

	public ExpertConfigUI(final CSVFile csv, final CSVConfig importConfig, final CSVConversionConfig conversionConfig) {
		super();
		GroupLayout layout = new GroupLayout(this);
		setLayout(layout);
		setMaximumSize(new Dimension(COLUMN_WIDTH * 2, Short.MAX_VALUE));

		JLabel conversionOptionsLabel = SlickerFactory.instance().createLabel(
				""Additional Conversion Options (Defaults are a good guess)"");
		conversionOptionsLabel.setFont(conversionOptionsLabel.getFont().deriveFont(Font.BOLD, 20));

		xFactoryChoice = new ProMComboBox<>(Iterables.transform(getAvailableXFactories(),
				new Function<XFactory, XFactoryUI>() {

					public XFactoryUI apply(XFactory factory) {
						return new XFactoryUI(factory);
					}

				}));
		xFactoryChoice.setSelectedItem(new XFactoryUI(conversionConfig.getFactory()));
		JLabel xFactoryLabel = createLabel(
				""XFactory"",
				""XFactory implementation that is used to create the log. Some implementations might be more memory efficient, consider changing this in case you import a huge log."");

		xFactoryChoice.addActionListener(new ActionListener() {

			public void actionPerformed(ActionEvent e) {
				conversionConfig.setFactory(((XFactoryUI) xFactoryChoice.getSelectedItem()).getFactory());
			}
		});

		errorHandlingModeCbx = new ProMComboBox<>(CSVErrorHandlingMode.values());
		errorHandlingModeCbx.setSelectedItem(conversionConfig.getErrorHandlingMode());
		JLabel errorHandlingModeLabel = createLabel(""Error Handling"",
				""Stop conversion upon malformed input or try to import as much as possible?"");
		errorHandlingModeCbx.addActionListener(new ActionListener() {

			public void actionPerformed(ActionEvent e) {
				conversionConfig.setErrorHandlingMode((CSVErrorHandlingMode) errorHandlingModeCbx.getSelectedItem());
			}
		});

		emptyCellHandlingModeCbx = new ProMComboBox<>(CSVEmptyCellHandlingMode.values());
		emptyCellHandlingModeCbx.setSelectedItem(conversionConfig.getEmptyCellHandlingMode());
		JLabel emptyCellHandlingModeLabel = createLabel(
				""Sparse / Dense Log"",
				""Exclude (sparse) or include (dense) empty cells in the conversion. This affects how empty cells in the CSV are handled. ""
						+ ""Some plug-ins require the log to be dense, i.e., all attributes are defined for each event. ""
						+ ""In other cases it might be more efficient or even required to only add attributes to events if the attributes actually contain data."");
		emptyCellHandlingModeCbx.addActionListener(new ActionListener() {

			public void actionPerformed(ActionEvent e) {
				conversionConfig.setEmptyCellHandlingMode((CSVEmptyCellHandlingMode) emptyCellHandlingModeCbx
						.getSelectedItem());
			}
		});

		attributeConversionModeCbx = new ProMComboBox<>(CSVAttributeConversionMode.values());
		attributeConversionModeCbx
				.setSelectedItem(conversionConfig.isShouldAddStartEventAttributes() ? CSVAttributeConversionMode.ADD_TO_BOTH
						: CSVAttributeConversionMode.ADD_TO_COMPLETE);
		JLabel attributeConversionModeLabel = createLabel(
				""Attribute Conversion Mode"",
				""Add attributes either to both start and complete events, or only to the complete event. ""
				+ ""This is only relevant if your log contains information on the 'start' and 'completion' of an activity."");
		attributeConversionModeCbx.addActionListener(new ActionListener() {

			public void actionPerformed(ActionEvent e) {
				conversionConfig.setShouldAddStartEventAttributes(attributeConversionModeCbx.getSelectedItem() == CSVAttributeConversionMode.ADD_TO_BOTH);
			}
		});

		SequentialGroup verticalGroup = layout.createSequentialGroup();
		verticalGroup.addGroup(layout
				.createParallelGroup()
				.addGroup(
						layout.createSequentialGroup().addComponent(errorHandlingModeLabel)
								.addComponent(errorHandlingModeCbx))
				.addGroup(
						layout.createSequentialGroup().addComponent(xFactoryLabel)
								.addComponent(xFactoryChoice)));
		verticalGroup.addGroup(layout
				.createParallelGroup()
				.addGroup(
						layout.createSequentialGroup().addComponent(emptyCellHandlingModeLabel)
							.addComponent(emptyCellHandlingModeCbx))
				.addGroup(layout.createSequentialGroup().addComponent(attributeConversionModeLabel).addComponent(attributeConversionModeCbx)));

		ParallelGroup horizontalGroup = layout.createParallelGroup();
		horizontalGroup.addGroup(layout
				.createSequentialGroup()
				.addGroup(
						layout.createParallelGroup()
								.addComponent(errorHandlingModeLabel, Alignment.LEADING, COLUMN_WIDTH, COLUMN_WIDTH,
										COLUMN_WIDTH)
								.addComponent(errorHandlingModeCbx, COLUMN_WIDTH, COLUMN_WIDTH, COLUMN_WIDTH))
				.addGroup(
						layout.createParallelGroup()
								.addComponent(xFactoryLabel, COLUMN_WIDTH, COLUMN_WIDTH, COLUMN_WIDTH)
								.addComponent(xFactoryChoice, COLUMN_WIDTH, COLUMN_WIDTH, COLUMN_WIDTH)));
		horizontalGroup.addGroup(layout
				.createSequentialGroup()
				.addGroup(
						layout.createParallelGroup()
								.addComponent(emptyCellHandlingModeLabel, Alignment.LEADING, COLUMN_WIDTH, COLUMN_WIDTH,
										COLUMN_WIDTH)
								.addComponent(emptyCellHandlingModeCbx, COLUMN_WIDTH, COLUMN_WIDTH, COLUMN_WIDTH))
				.addGroup(
						layout.createParallelGroup()
								.addComponent(attributeConversionModeLabel, COLUMN_WIDTH, COLUMN_WIDTH, COLUMN_WIDTH)
								.addComponent(attributeConversionModeCbx, COLUMN_WIDTH, COLUMN_WIDTH, COLUMN_WIDTH)));

		layout.linkSize(errorHandlingModeLabel, xFactoryLabel, emptyCellHandlingModeLabel, attributeConversionModeLabel);

		layout.setAutoCreateContainerGaps(true);
		layout.setAutoCreateGaps(true);

		layout.setVerticalGroup(verticalGroup);
		layout.setHorizontalGroup(horizontalGroup);
	}

	private Set<XFactory> getAvailableXFactories() {
		//Try to register XESLite Factories
		tryRegisterFactory(""org.xeslite.lite.factory.XFactoryLiteImpl"");
		tryRegisterFactory(""org.xeslite.external.XFactoryExternalStore$MapDBDiskImpl"");
		tryRegisterFactory(""org.xeslite.external.XFactoryExternalStore$MapDBDiskWithoutCacheImpl"");
		tryRegisterFactory(""org.xeslite.external.XFactoryExternalStore$MapDBDiskSequentialAccessImpl"");
		tryRegisterFactory(""org.xeslite.external.XFactoryExternalStore$InMemoryStoreImpl"");
		return XFactoryRegistry.instance().getAvailable();
	}

	/**
	 * Tries to load the class and call the 'register' method.
	 * 
	 * @param className
	 */
	private void tryRegisterFactory(String className) {
		try {
			getClass().getClassLoader().loadClass(className).getDeclaredMethod(""register"").invoke(null);
		} catch (ClassNotFoundException | NoSuchMethodException | SecurityException | IllegalAccessException
				| IllegalArgumentException | InvocationTargetException e) {
		}
	}

}
"
ImportConfigUI.java,log,"package org.processmining.log.csvimport.ui;

import java.awt.Dimension;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.io.IOException;
import java.nio.charset.Charset;
import java.util.List;

import javax.swing.Box;
import javax.swing.BoxLayout;
import javax.swing.GroupLayout;
import javax.swing.GroupLayout.Alignment;
import javax.swing.GroupLayout.ParallelGroup;
import javax.swing.GroupLayout.SequentialGroup;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.SwingConstants;
import javax.swing.SwingWorker;

import org.processmining.framework.util.ui.widgets.ProMComboBox;
import org.processmining.framework.util.ui.widgets.helper.ProMUIHelper;
import org.processmining.log.csv.CSVFile;
import org.processmining.log.csv.ICSVReader;
import org.processmining.log.csv.config.CSVConfig;
import org.processmining.log.csv.config.CSVQuoteCharacter;
import org.processmining.log.csv.config.CSVSeperator;
import org.processmining.log.csvimport.ui.preview.CSVPreviewPanel;

/**
 * UI for the import configuration (charset, separator, ..)
 * 
 * @author F. Mannhardt
 *
 */
public final class ImportConfigUI extends CSVConfigurationPanel {

	private static final long serialVersionUID = 2L;

	private static final int MAX_PREVIEW = 1000;
	private static final int COLUMN_WIDTH = 240;

	private final CSVFile csv;
	private final CSVConfig importConfig;

	private final ProMComboBox<String> charsetCbx;
	private final ProMComboBox<CSVSeperator> separatorField;
	private final ProMComboBox<CSVQuoteCharacter> quoteField;

	private final CSVPreviewPanel previewPanel;

	private SwingWorker<Void, String[]> worker;

	public ImportConfigUI(final CSVFile csv, final CSVConfig importConfig) {
		super();
		this.importConfig = importConfig;
		this.csv = csv;
		this.previewPanel = new CSVPreviewPanel();

		setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));
		setOpaque(false);		

		JLabel header = new JLabel(""<HTML><H2>CSV Parser: Settings</H2></HTML>"");
		header.setAlignmentX(CENTER_ALIGNMENT);
		
		add(header);

		add(Box.createVerticalStrut(10));

		JPanel topPanel = new JPanel();
		
		GroupLayout layout = new GroupLayout(topPanel);
		layout.setAutoCreateContainerGaps(true);
		layout.setAutoCreateGaps(true);

		topPanel.setOpaque(false);
		topPanel.setLayout(layout);
		
		JPanel charsetPanel = new JPanel();
		charsetPanel.setOpaque(false);
		charsetPanel.setLayout(new BoxLayout(charsetPanel, BoxLayout.Y_AXIS));
		charsetCbx = new ProMComboBox<>(Charset.availableCharsets().keySet());
		charsetCbx.setSelectedItem(importConfig.getCharset());
		charsetCbx.setPreferredSize(null);
		charsetCbx.setMinimumSize(null);
		JLabel charsetLabel = createLabel(""Charset"", 
				""Configure the character encoding that is used by the CSV file"");
		charsetLabel.setAlignmentX(LEFT_ALIGNMENT);
		charsetCbx.setAlignmentX(LEFT_ALIGNMENT);
		charsetPanel.add(charsetLabel);
		charsetPanel.add(charsetCbx);
		charsetCbx.addActionListener(new ActionListener() {

			public void actionPerformed(ActionEvent e) {
				importConfig.setCharset(charsetCbx.getSelectedItem().toString());
				refreshPreview();
			}
		});

		JPanel separatorPanel = new JPanel();
		separatorPanel.setOpaque(false);
		separatorPanel.setLayout(new BoxLayout(separatorPanel, BoxLayout.Y_AXIS));
		separatorField = new ProMComboBox<>(CSVSeperator.values());
		separatorField.setPreferredSize(null);
		separatorField.setMinimumSize(null);
		separatorField.setSelectedItem(importConfig.getSeparator());
		JLabel seperationLabel = createLabel(""Separator Character"", 
				""Configure the character that is used by the CSV file to separate two fields"");
		seperationLabel.setAlignmentX(LEFT_ALIGNMENT);
		separatorField.setAlignmentX(LEFT_ALIGNMENT);
		separatorPanel.add(seperationLabel);
		separatorPanel.add(separatorField);
		separatorField.addActionListener(new ActionListener() {

			public void actionPerformed(ActionEvent e) {
				importConfig.setSeparator(((CSVSeperator) separatorField.getSelectedItem()));
				refreshPreview();
			}
		});

		JPanel quotePanel = new JPanel();
		quotePanel.setOpaque(false);
		quotePanel.setLayout(new BoxLayout(quotePanel, BoxLayout.Y_AXIS));
		quoteField = new ProMComboBox<>(CSVQuoteCharacter.values());
		quoteField.setPreferredSize(null);
		quoteField.setMinimumSize(null);
		JLabel quoteLabel = createLabel(""Quote Character"", 
				""Configure the character that is used by the CSV file that is used to quote values if they contain the separator character or a newline"");
		quoteLabel.setAlignmentX(LEFT_ALIGNMENT);
		quoteField.setAlignmentX(LEFT_ALIGNMENT);
		quotePanel.add(quoteLabel);
		quotePanel.add(quoteField);
		quoteField.addActionListener(new ActionListener() {

			public void actionPerformed(ActionEvent e) {
				importConfig.setQuoteChar((CSVQuoteCharacter) quoteField.getSelectedItem());
				refreshPreview();
			}
		});
		quoteField.setSelectedItem(importConfig.getQuoteChar());

		ParallelGroup verticalGroup = layout.createParallelGroup()
				.addComponent(charsetPanel, Alignment.TRAILING)
				.addComponent(separatorPanel, Alignment.TRAILING)
				.addComponent(quotePanel, Alignment.TRAILING);

		SequentialGroup horizontalGroup = layout.createSequentialGroup()
				.addComponent(charsetPanel, COLUMN_WIDTH, COLUMN_WIDTH, COLUMN_WIDTH)
				.addComponent(separatorPanel, COLUMN_WIDTH, COLUMN_WIDTH, COLUMN_WIDTH )
				.addComponent(quotePanel, COLUMN_WIDTH, COLUMN_WIDTH, COLUMN_WIDTH);

		layout.linkSize(SwingConstants.HORIZONTAL, separatorPanel, charsetPanel, quotePanel);
		
		layout.setAutoCreateContainerGaps(true);
		layout.setAutoCreateGaps(true);

		layout.setVerticalGroup(verticalGroup);
		layout.setHorizontalGroup(horizontalGroup);
		
		add(topPanel);
		previewPanel.setMaximumSize(new Dimension(725, 350));
		add(previewPanel);
	}

	private void refreshPreview() {

		if (worker != null) {
			worker.cancel(true);
		}

		previewPanel.clear();

		// Update Header
		try {
			previewPanel.setHeader(csv.readHeader(importConfig));
		} catch (IOException | ArrayIndexOutOfBoundsException e) {
			ProMUIHelper.showWarningMessage(this, ""Error parsing CSV "" + e.getMessage(), ""CSV Parsing Error"");
			return;
		}

		worker = new SwingWorker<Void, String[]>() {

			protected Void doInBackground() throws Exception {

				try (ICSVReader reader = csv.createReader(importConfig)) {
					// Skip header
					reader.readNext();
					String[] nextLine;
					int i = 0;
					while ((nextLine = reader.readNext()) != null && i < MAX_PREVIEW) {
						publish(nextLine);
						i++;
					}
				}

				return null;
			}

			protected void process(List<String[]> chunks) {
				for (String[] row : chunks) {
					previewPanel.addRow(row);
				}
			}

		};

		try {
			worker.execute();
		} catch (Exception e) {
			JOptionPane.showMessageDialog(this, ""Error parsing CSV "" + e.getMessage(), ""CSV Parsing Error"",
					JOptionPane.ERROR_MESSAGE);
		}
	}

	public CSVConfig getImportConfig() {
		return importConfig;
	}

}"
CSVPreviewFrame.java,log,"package org.processmining.log.csvimport.ui.preview;

import java.awt.Component;
import java.awt.Dimension;
import java.awt.Frame;
import java.awt.GraphicsDevice;
import java.awt.GraphicsEnvironment;
import java.util.Enumeration;
import java.util.List;
import java.util.Vector;

import javax.swing.AbstractCellEditor;
import javax.swing.Box;
import javax.swing.BoxLayout;
import javax.swing.DefaultCellEditor;
import javax.swing.DefaultComboBoxModel;
import javax.swing.JComboBox;
import javax.swing.JComponent;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JTable;
import javax.swing.JTextField;
import javax.swing.ListSelectionModel;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ListSelectionEvent;
import javax.swing.event.TableColumnModelEvent;
import javax.swing.event.TableColumnModelListener;
import javax.swing.table.AbstractTableModel;
import javax.swing.table.DefaultTableModel;
import javax.swing.table.TableCellEditor;
import javax.swing.table.TableColumn;
import javax.swing.table.TableColumnModel;
import javax.swing.table.TableModel;

import org.processmining.framework.util.ui.widgets.ProMScrollPane;
import org.processmining.framework.util.ui.widgets.ProMTableWithoutPanel;
import org.processmining.log.csvimport.config.CSVConversionConfig;
import org.processmining.log.csvimport.config.CSVConversionConfig.CSVMapping;
import org.processmining.log.csvimport.config.CSVConversionConfig.Datatype;
import org.processmining.log.csvimport.config.CSVConversionConfig.ExtensionAttribute;

/**
 * Frame showing a part of the CSV file.
 * 
 * @author F. Mannhardt
 * 
 */
public final class CSVPreviewFrame extends JFrame {

	private final class MappingCellEditor extends AbstractCellEditor implements TableCellEditor {

		private static final long serialVersionUID = -8465152263165430372L;

		private TableCellEditor editor;

		public Object getCellEditorValue() {
			if (editor != null) {
				return editor.getCellEditorValue();
			}
			return null;
		}

		public Component getTableCellEditorComponent(JTable table, Object value, boolean isSelected, int row, int column) {
			if (value instanceof Datatype) {
				editor = new DefaultCellEditor(new JComboBox<>(new DefaultComboBoxModel<>(Datatype.values())));
			} else if (value instanceof String) {
				editor = new DefaultCellEditor(new JTextField());
			} else if (value instanceof ExtensionAttribute) {
				editor = new DefaultCellEditor(new JComboBox<ExtensionAttribute>(
						CSVConversionConfig.AVAILABLE_EVENT_EXTENSIONS_ATTRIBUTES));
			} else {
				throw new RuntimeException(""Unkown value type "" + value.getClass().getSimpleName());
			}
			return editor.getTableCellEditorComponent(table, value, isSelected, row, column);
		}
	}

	private final class BatchUpdateDefaultTableModel extends DefaultTableModel {

		private static final long serialVersionUID = 1L;

		private BatchUpdateDefaultTableModel(Vector<String> columnNames, int rowCount) {
			super(columnNames, rowCount);
		}

		@SuppressWarnings(""unchecked"")
		public void addRows(List<String[]> rowData) {
			int firstRow = dataVector.size();
			for (Object[] row : rowData) {
				dataVector.add(convertToVector(row));
			}
			int lastRow = dataVector.size() - 1;
			fireTableRowsInserted(firstRow, lastRow);
		}

	}

	public static class DataTypeTableModel extends AbstractTableModel {

		private static final long serialVersionUID = 1L;

		private final CSVConversionConfig conversionConfig;
		private final String[] header;

		public DataTypeTableModel(CSVConversionConfig conversionConfig, String[] header) {
			this.conversionConfig = conversionConfig;
			this.header = header;
		}

		public int getRowCount() {
			return 5;
		}

		public void setValueAt(Object aValue, int rowIndex, int columnIndex) {
			String columnHeader = header[columnIndex];
			CSVMapping csvMapping = conversionConfig.getConversionMap().get(columnHeader);
			switch (rowIndex) {
				case 0 :
					Datatype newType = (Datatype) aValue;
					if (csvMapping.getDataType() != newType) {
						csvMapping.setPattern("""");
						fireTableCellUpdated(1, columnIndex);
					}
					csvMapping.setDataType(newType);
					break;
				case 1 :
					csvMapping.setPattern((String) aValue);
					break;
				case 2 :
					csvMapping.setTraceAttributeName((String) aValue);
					break;
				case 3 :
					if (aValue != null) {
						ExtensionAttribute extAttr = (ExtensionAttribute) aValue;
						if (extAttr != CSVConversionConfig.NO_EXTENSION_ATTRIBUTE) {
							csvMapping.setEventExtensionAttribute(extAttr);
							csvMapping.setEventAttributeName(extAttr.key);
						} else {
							csvMapping.setEventExtensionAttribute(CSVConversionConfig.NO_EXTENSION_ATTRIBUTE);
							csvMapping.setEventAttributeName(nullSafe(columnHeader));
						}
					} else {
						csvMapping.setEventExtensionAttribute(null);
						csvMapping.setEventAttributeName(nullSafe(columnHeader));
					}
					fireTableCellUpdated(4, columnIndex);
					break;
				case 4 :
					csvMapping.setEventAttributeName((String) aValue);
					break;
				default :
					throw new IllegalStateException(""Could not find value at row "" + rowIndex + "" column ""
							+ columnIndex);
			}
			conversionConfig.getConversionMap().put(columnHeader, csvMapping);
		}

		private static String nullSafe(String s) {
			return s == null ? """" : s;
		}

		public Object getValueAt(int rowIndex, int columnIndex) {
			String columnHeader = header[columnIndex];
			CSVMapping csvMapping = conversionConfig.getConversionMap().get(columnHeader);
			switch (rowIndex) {
				case 0 :
					return csvMapping.getDataType();
				case 1 :
					return csvMapping.getPattern();
				case 2 :
					return csvMapping.getTraceAttributeName();
				case 3 :
					return csvMapping.getEventExtensionAttribute();
				case 4 :
					return csvMapping.getEventAttributeName();
			}
			throw new IllegalStateException(""Could not find value at row "" + rowIndex + "" column "" + columnIndex);
		}

		public int getColumnCount() {
			return header.length;
		}

		public String getColumnName(int column) {
			return nullSafe(header[column]);
		}

		public Class<?> getColumnClass(int columnIndex) {
			return super.getColumnClass(columnIndex);
		}

		public boolean isCellEditable(int rowIndex, int columnIndex) {
			return rowIndex == 2 ? false : true;
		}

	}

	private static final long serialVersionUID = 1L;

	private final BatchUpdateDefaultTableModel previewTableModel;
	private final JTable previewTable;
	private final JScrollPane mainScrollPane;

	private JTable datatypeTable;

	public CSVPreviewFrame() {
		this(null);
	}

	public CSVPreviewFrame(String[] header) {
		this(null, null);
	}

	@SuppressWarnings(""serial"")
	public CSVPreviewFrame(String[] header, CSVConversionConfig conversionConfig) {
		super();
		setTitle(""CSV Import: Preview of the Import"");
		getContentPane().setLayout(new BoxLayout(getContentPane(), BoxLayout.Y_AXIS));

		Vector<String> columnIds = prepareNullSafeColumnNames(header);
		previewTableModel = new BatchUpdateDefaultTableModel(columnIds, 0);
		previewTable = new ProMTableWithoutPanel(previewTableModel);
		previewTable.setAutoResizeMode(JTable.AUTO_RESIZE_OFF);
		Enumeration<TableColumn> columns = previewTable.getColumnModel().getColumns();
		while (columns.hasMoreElements()) {
			final TableColumn column = columns.nextElement();
			column.setPreferredWidth(130);
			column.setCellEditor(new DefaultCellEditor(new JTextField()) {

				protected void fireEditingStopped() {
					this.cancelCellEditing();
					super.fireEditingStopped();
				}

				protected void fireEditingCanceled() {
					super.fireEditingCanceled();
				}

			});
		}
		previewTable.getColumnModel().setColumnSelectionAllowed(false);
		previewTable.getTableHeader().setReorderingAllowed(false);

		mainScrollPane = new ProMScrollPane(previewTable);

		JPanel mainPanel = new JPanel();
		mainPanel.setLayout(new BoxLayout(mainPanel, BoxLayout.X_AXIS));

		JPanel rightPanel = new JPanel();
		rightPanel.setLayout(new BoxLayout(rightPanel, BoxLayout.Y_AXIS));

		if (conversionConfig != null) {
			TableModel dataModel = new DataTypeTableModel(conversionConfig, header);
			datatypeTable = new JTable(dataModel);
			datatypeTable.setTableHeader(null);
			datatypeTable.setDefaultEditor(Object.class, new MappingCellEditor());
			datatypeTable.setAutoResizeMode(JTable.AUTO_RESIZE_OFF);
			datatypeTable.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
			ProMScrollPane dataTypeScrollpane = new ProMScrollPane(datatypeTable) {

				public Dimension getPreferredSize() {
					Dimension preferredSize = super.getPreferredSize();
					preferredSize.height = datatypeTable.getPreferredSize().height;
					preferredSize.width = Short.MAX_VALUE;
					return preferredSize;
				}

				public Dimension getMaximumSize() {
					return getPreferredSize();
				}

			};
			dataTypeScrollpane.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_NEVER);
			getMainScrollPane().setHorizontalScrollBar(dataTypeScrollpane.getHorizontalScrollBar());

			previewTable.getColumnModel().addColumnModelListener(new TableColumnModelListener() {

				public void columnSelectionChanged(ListSelectionEvent e) {
				}

				public void columnRemoved(TableColumnModelEvent e) {
				}

				public void columnMoved(TableColumnModelEvent e) {
				}

				public void columnMarginChanged(ChangeEvent e) {
					final TableColumnModel tableColumnModel = previewTable.getColumnModel();
					TableColumnModel dataTypeColumnModel = datatypeTable.getColumnModel();
					for (int i = 0; i < tableColumnModel.getColumnCount(); i++) {
						int w = tableColumnModel.getColumn(i).getWidth();
						dataTypeColumnModel.getColumn(i).setMinWidth(w);
						dataTypeColumnModel.getColumn(i).setMaxWidth(w);
					}
					datatypeTable.doLayout();
					datatypeTable.repaint();
					repaint();
				}

				public void columnAdded(TableColumnModelEvent e) {
				}

			});

			JPanel leftPanel = new JPanel();
			leftPanel.setLayout(new BoxLayout(leftPanel, BoxLayout.Y_AXIS));
			JLabel dataType = new JLabel(""Data Type"");
			leftPanel.add(dataType);
			JLabel dataPattern = new JLabel(""Data Pattern"");
			dataPattern
					.setToolTipText(""<HTML>Pattern describing how to parse the value to the selected data type. </BR>""
							+ ""<ul><li>For 'DATE' this is a pattern parseable by SimpleDateFormat,</li> ""
							+ ""<li>for 'DISCRETE' and 'CONTINUOUS' this is a pattern parseable by DecimalFormat, ""
							+ ""<li>for 'LITERAL' this is parsed by MessageFormat whereby the first parameter {0} is the value in the column itself, and the following parameters {1}-{n} are the values in the other columns starting from the first column (including the selected column itself).<li>""
							+ ""<HTML>"");
			leftPanel.add(dataPattern);
			JLabel traceAttribute = new JLabel(""Trace Attribute"");
			traceAttribute.setToolTipText(""Attribute in the trace (Read-only)"");
			leftPanel.add(traceAttribute);
			JLabel extensionAttribute = new JLabel(""XES Extension"");
			extensionAttribute.setToolTipText(""XES extension that is attached to the attribute."");
			leftPanel.add(extensionAttribute);
			JLabel eventAttribute = new JLabel(""Event Attribute"");
			eventAttribute.setToolTipText(""Attribute name in the event"");
			leftPanel.add(eventAttribute);
			leftPanel.add(Box.createVerticalGlue());
			mainPanel.add(leftPanel);

			rightPanel.add(dataTypeScrollpane);
		}

		rightPanel.add(mainScrollPane);
		mainPanel.add(rightPanel);
		getContentPane().add(mainPanel);

		setDefaultCloseOperation(DISPOSE_ON_CLOSE);
		pack();
	}

	private Vector<String> prepareNullSafeColumnNames(String[] header) {
		Vector<String> columnIds = new Vector<String>();
		for (String obj: header) {
			if (obj == null) {
				columnIds.add("""");
			} else {
				columnIds.add(obj);	
			}				
		}
		return columnIds;
	}

	public void showFrame(JComponent parent) {
		GraphicsEnvironment ge = GraphicsEnvironment.getLocalGraphicsEnvironment();
		GraphicsDevice[] gs = ge.getScreenDevices();
		if (gs.length > 1) {
			for (int i = 0; i < gs.length; i++) {
				if (gs[i] != parent.getGraphicsConfiguration().getDevice()) {
					JFrame dummy = new JFrame(gs[i].getDefaultConfiguration());
					setLocationRelativeTo(dummy);
					setExtendedState(Frame.MAXIMIZED_BOTH);
					setAlwaysOnTop(false);
					dummy.dispose();
					break;
				}
			}
		} else {
			setLocationRelativeTo(parent);
			setAlwaysOnTop(false);
			setPreferredSize(new Dimension(800, 800));
		}
		setVisible(true);
	}

	public void addRow(String[] data) {
		previewTableModel.addRow(data);
	}

	public void addRows(List<String[]> rows) {
		previewTableModel.addRows(rows);
	}

	public void refresh() {
		if (datatypeTable != null) {
			datatypeTable.repaint();
		}
	}

	public JTable getPreviewTable() {
		return previewTable;
	}

	public JScrollPane getMainScrollPane() {
		return mainScrollPane;
	}

	public void save() {
		if (datatypeTable.isEditing()) {
			datatypeTable.getCellEditor().stopCellEditing();
		}
	}

}
"
CSVPreviewPanel.java,log,"package org.processmining.log.csvimport.ui.preview;

import java.util.Enumeration;
import java.util.List;
import java.util.Vector;

import javax.swing.BoxLayout;
import javax.swing.DefaultCellEditor;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JTable;
import javax.swing.JTextField;
import javax.swing.table.DefaultTableModel;
import javax.swing.table.TableColumn;

import org.processmining.framework.util.ui.widgets.ProMScrollPane;
import org.processmining.framework.util.ui.widgets.ProMTableWithoutPanel;

public final class CSVPreviewPanel extends JPanel {

	private static final long serialVersionUID = 3007836604602201962L;

	private final class BatchUpdateDefaultTableModel extends DefaultTableModel {

		private static final long serialVersionUID = -3423057642229809442L;

		private BatchUpdateDefaultTableModel(Object[] columnNames, int rowCount) {
			super(columnNames, rowCount);
		}

		@SuppressWarnings(""unchecked"")
		public void addRows(List<String[]> rowData) {
			int firstRow = dataVector.size();
			for (String[] row : rowData) {
				dataVector.add(convertToVector(row));
			}
			int lastRow = dataVector.size() - 1;
			fireTableRowsInserted(firstRow, lastRow);
		}
	}

	private final BatchUpdateDefaultTableModel previewTableModel;
	private final JTable previewTable;
	private final JScrollPane mainScrollPane;

	private JTable datatypeTable;

	public CSVPreviewPanel() {
		super();
		setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));
		setOpaque(false);
		
		previewTableModel = new BatchUpdateDefaultTableModel(null, 0);
		previewTable = new ProMTableWithoutPanel(previewTableModel);
		previewTable.setAutoResizeMode(JTable.AUTO_RESIZE_OFF);
		
		Enumeration<TableColumn> columns = previewTable.getColumnModel().getColumns();
		
		while (columns.hasMoreElements()) {
			final TableColumn column = columns.nextElement();
			column.setPreferredWidth(130);
			column.setCellEditor(new DefaultCellEditor(new JTextField()) {

				private static final long serialVersionUID = -2741181064062738008L;

				protected void fireEditingStopped() {
					this.cancelCellEditing();
					super.fireEditingStopped();
				}

				protected void fireEditingCanceled() {
					super.fireEditingCanceled();
				}

			});
		}
		previewTable.getColumnModel().setColumnSelectionAllowed(false);
		previewTable.getTableHeader().setReorderingAllowed(false);

		mainScrollPane = new ProMScrollPane(previewTable);
		
		add(mainScrollPane);
	}

	public void addRow(String[] data) {
		previewTableModel.addRow(data);
	}

	public void addRows(List<String[]> rows) {
		previewTableModel.addRows(rows);
	}

	public void setHeader(String[] header) {
		if (header == null) {
			previewTable.setTableHeader(null);
		} else {			
			Vector<String> columnIds = new Vector<String>();
			for (String obj: header) {
				if (obj == null) {
					columnIds.add("""");
				} else {
					columnIds.add(obj);	
				}				
			}
			previewTableModel.setColumnIdentifiers(columnIds);
		}
	}

	public void clear() {
		previewTableModel.getDataVector().clear();
		previewTable.repaint();
	}

	public void refresh() {
		if (datatypeTable != null) {
			datatypeTable.repaint();
		}
	}

	public JTable getPreviewTable() {
		return previewTable;
	}

	public JScrollPane getMainScrollPane() {
		return mainScrollPane;
	}

}
"
ClassifierPanel.java,log,"package org.processmining.log.dialogs;

import java.awt.Dimension;
import java.util.List;

import javax.swing.DefaultListModel;
import javax.swing.JPanel;
import javax.swing.ListSelectionModel;
import javax.swing.event.ListSelectionEvent;
import javax.swing.event.ListSelectionListener;

import org.deckfour.xes.classification.XEventClassifier;
import org.processmining.framework.util.ui.widgets.ProMList;
import org.processmining.log.parameters.ClassifierParameter;
import org.processmining.log.parameters.UpdateParameter;

import info.clearthought.layout.TableLayout;
import info.clearthought.layout.TableLayoutConstants;

public class ClassifierPanel extends JPanel {
	
	/**
	 * 
	 */
	private static final long serialVersionUID = -7242932924333294111L;

	public ClassifierPanel(List<XEventClassifier> classifiers, final ClassifierParameter classifierParameter) {
		this (classifiers, classifierParameter, null);
	}
	
	public ClassifierPanel(List<XEventClassifier> classifiers, final ClassifierParameter classifierParameter, final UpdateParameter updateParameter) {
		double size[][] = { { TableLayoutConstants.FILL }, { TableLayoutConstants.FILL } };
		setLayout(new TableLayout(size));

		setOpaque(false);
		
		DefaultListModel<XEventClassifier> listModel = new DefaultListModel<XEventClassifier>();
		for (XEventClassifier classifier: classifiers) {
			listModel.addElement(classifier);
		}
		final ProMList<XEventClassifier> list = new ProMList<XEventClassifier>(""Select classifier"", listModel);
		list.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
		final XEventClassifier defaultClassifier = classifierParameter.getClassifier();
		list.setSelection(defaultClassifier);
		classifierParameter.setClassifier(wrap(defaultClassifier));
		list.addListSelectionListener(new ListSelectionListener() {
			public void valueChanged(ListSelectionEvent e) {
				List<XEventClassifier> selected = list.getSelectedValuesList();
				if (selected.size() == 1) {
					classifierParameter.setClassifier(wrap(selected.get(0)));
					if (updateParameter != null) {
						updateParameter.update();
					}
				} else {
					/*
					 * Nothing selected. Revert to selection of default classifier.
					 */
					list.setSelection(defaultClassifier);
					classifierParameter.setClassifier(wrap(defaultClassifier));
					if (updateParameter != null) {
						updateParameter.update();
					}
				}
			}
		});
		list.setPreferredSize(new Dimension(100, 100));
		add(list, ""0, 0"");

	}
	
	private XEventClassifier wrap(XEventClassifier classifier) {
//		if (classifier instanceof StartEndClassifier) {
			return classifier;
//		}
//		return new StartEndClassifier(classifier);
	}

}
"
HighFrequencyFilterDialog.java,log,"package org.processmining.log.dialogs;

import info.clearthought.layout.TableLayout;
import info.clearthought.layout.TableLayoutConstants;

import javax.swing.JPanel;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;

import org.deckfour.xes.model.XLog;
import org.processmining.log.parameters.HighFrequencyFilterParameters;

import com.fluxicon.slickerbox.components.NiceSlider;
import com.fluxicon.slickerbox.components.NiceSlider.Orientation;
import com.fluxicon.slickerbox.factory.SlickerFactory;

public class HighFrequencyFilterDialog extends JPanel {

	/**
	 * 
	 */
	private static final long serialVersionUID = 5152781639823196889L;

	public HighFrequencyFilterDialog(XLog eventLog, final HighFrequencyFilterParameters parameters) {
		double size[][] = { { TableLayoutConstants.FILL }, { TableLayoutConstants.FILL, 30, 30 } };
		setLayout(new TableLayout(size));
		
		add(new ClassifierPanel(eventLog.getClassifiers(), parameters), ""0, 0"");

		final NiceSlider frequenceThresholdSlider = SlickerFactory.instance().createNiceIntegerSlider(""Frequency threshold"", 0, 100,
				parameters.getFrequencyThreshold(), Orientation.HORIZONTAL);
		frequenceThresholdSlider.addChangeListener(new ChangeListener() {

			public void stateChanged(ChangeEvent e) {
				parameters.setFrequencyThreshold(frequenceThresholdSlider.getSlider().getValue());
			}
		});
		add(frequenceThresholdSlider, ""0, 1"");

		final NiceSlider distanceThresholdSlider = SlickerFactory.instance().createNiceIntegerSlider(""Distance threshold"", 0, 100,
				parameters.getDistanceThreshold(), Orientation.HORIZONTAL);
		distanceThresholdSlider.addChangeListener(new ChangeListener() {

			public void stateChanged(ChangeEvent e) {
				parameters.setDistanceThreshold(distanceThresholdSlider.getSlider().getValue());
			}
		});
		add(distanceThresholdSlider, ""0, 2"");
	}

}
"
LogCentralityDialog.java,log,"package org.processmining.log.dialogs;

import info.clearthought.layout.TableLayout;
import info.clearthought.layout.TableLayoutConstants;

import java.awt.Dimension;
import java.util.List;

import javax.swing.DefaultListModel;
import javax.swing.JPanel;
import javax.swing.ListSelectionModel;
import javax.swing.event.ListSelectionEvent;
import javax.swing.event.ListSelectionListener;

import org.deckfour.xes.classification.XEventClassifier;
import org.deckfour.xes.model.XLog;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.framework.util.ui.widgets.ProMList;
import org.processmining.log.models.LogCentrality;
import org.processmining.log.parameters.LogCentralityParameters;

public class LogCentralityDialog extends JPanel{

	/**
	 * 
	 */
	private static final long serialVersionUID = 8634000584911454942L;

	public LogCentralityDialog(final UIPluginContext context, final XLog log, final LogCentrality centrality, final LogCentralityParameters parameters) {
		double size[][] = { { TableLayoutConstants.FILL }, { TableLayoutConstants.FILL } };
		setLayout(new TableLayout(size));

		DefaultListModel<XEventClassifier> listModel = new DefaultListModel<XEventClassifier>();
		for (XEventClassifier classifier: log.getClassifiers()) {
			listModel.addElement(classifier);
		}
		final ProMList<XEventClassifier> list = new ProMList<XEventClassifier>(""Select Happy Classifier"", listModel);
		list.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
		final XEventClassifier defaultClassifier = parameters.getClassifier();
		list.setSelection(defaultClassifier);
		list.addListSelectionListener(new ListSelectionListener() {
			public void valueChanged(ListSelectionEvent e) {
				List<XEventClassifier> selected = list.getSelectedValuesList();
				if (selected.size() == 1) {
					parameters.setClassifier(selected.get(0));
				} else {
					/*
					 * Nothing selected. Revert to selection of default classifier.
					 */
					list.setSelection(defaultClassifier);
					parameters.setClassifier(defaultClassifier);
				}
				centrality.setClassifier(context, parameters);
			}
		});
		list.setPreferredSize(new Dimension(100, 100));
		add(list, ""0, 0"");	
	}
}
"
LogCentralityFilterDialog.java,log,"package org.processmining.log.dialogs;

import info.clearthought.layout.TableLayout;
import info.clearthought.layout.TableLayoutConstants;

import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

import javax.swing.JCheckBox;
import javax.swing.JComponent;
import javax.swing.JPanel;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;

import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.log.algorithms.LogCentralityVisualizerAlgorithm;
import org.processmining.log.models.LogCentrality;
import org.processmining.log.parameters.LogCentralityFilterParameters;

import com.fluxicon.slickerbox.components.NiceSlider;
import com.fluxicon.slickerbox.components.NiceSlider.Orientation;
import com.fluxicon.slickerbox.factory.SlickerFactory;

public class LogCentralityFilterDialog extends JPanel{

	/**
	 * 
	 */
	private static final long serialVersionUID = 1184378045381402638L;

	private JComponent holder;
	
	public LogCentralityFilterDialog(final UIPluginContext context, final LogCentrality centrality, final LogCentralityFilterParameters parameters) {
		double size[][] = { { TableLayoutConstants.FILL }, { TableLayoutConstants.FILL, 30, 30 } };
		setLayout(new TableLayout(size));

		holder = new JPanel();
		add(holder, ""0, 0"");
		double holderSize[][] = { { TableLayoutConstants.FILL }, { TableLayoutConstants.FILL } };
		holder.setLayout(new TableLayout(holderSize));
		holder.add((new LogCentralityVisualizerAlgorithm()).apply(centrality, parameters), ""0, 0"");
		
		final NiceSlider percSlider = SlickerFactory.instance().createNiceIntegerSlider(""Select Happy Percentage"", 0, 100,  parameters.getPercentage(),
				Orientation.HORIZONTAL);
		percSlider.addChangeListener(new ChangeListener() {

			public void stateChanged(ChangeEvent e) {
				parameters.setPercentage(percSlider.getSlider().getValue());
				holder.removeAll();
				holder.add((new LogCentralityVisualizerAlgorithm()).apply(centrality, parameters), ""0, 0"");
				revalidate();
				repaint();
			}
		});
		add(percSlider, ""0, 1"");

		final JCheckBox filterInBox = SlickerFactory.instance().createCheckBox(""Select if Happy (otherwise unhappy)"",
				false);
		filterInBox.setSelected(parameters.isFilterIn());
		filterInBox.addActionListener(new ActionListener() {

			public void actionPerformed(ActionEvent e) {
				parameters.setFilterIn(filterInBox.isSelected());
				holder.removeAll();
				holder.add((new LogCentralityVisualizerAlgorithm()).apply(centrality, parameters), ""0, 0"");
				revalidate();
				repaint();
			}

		});
		filterInBox.setOpaque(false);
		add(filterInBox, ""0, 2"");
		
	}
}
"
LogFrequencyDialog.java,log,"package org.processmining.log.dialogs;

import info.clearthought.layout.TableLayout;
import info.clearthought.layout.TableLayoutConstants;

import javax.swing.JPanel;

import org.deckfour.xes.model.XLog;
import org.processmining.log.parameters.LogFrequencyParameters;

public class LogFrequencyDialog extends JPanel {

	/**
	 * 
	 */
	private static final long serialVersionUID = 2707936407167128579L;

	public LogFrequencyDialog(XLog eventLog, final LogFrequencyParameters parameters) {
		double size[][] = { { TableLayoutConstants.FILL }, { TableLayoutConstants.FILL, } };
		setLayout(new TableLayout(size));
		
		add(new ClassifierPanel(eventLog.getClassifiers(), parameters), ""0, 0"");

	}
}"
LowFrequencyFilterDialog.java,log,"package org.processmining.log.dialogs;

import info.clearthought.layout.TableLayout;
import info.clearthought.layout.TableLayoutConstants;

import javax.swing.JPanel;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;

import org.deckfour.xes.model.XLog;
import org.processmining.log.parameters.LowFrequencyFilterParameters;

import com.fluxicon.slickerbox.components.NiceSlider;
import com.fluxicon.slickerbox.components.NiceSlider.Orientation;
import com.fluxicon.slickerbox.factory.SlickerFactory;

public class LowFrequencyFilterDialog extends JPanel {

	/**
	 * 
	 */
	private static final long serialVersionUID = -1217093745565528989L;

	public LowFrequencyFilterDialog(XLog eventLog, final LowFrequencyFilterParameters parameters) {
		double size[][] = { { TableLayoutConstants.FILL }, { TableLayoutConstants.FILL, 30 } };
		setLayout(new TableLayout(size));
		
		add(new ClassifierPanel(eventLog.getClassifiers(), parameters), ""0, 0"");

		final NiceSlider thresholdSlider = SlickerFactory.instance().createNiceIntegerSlider(""Frequency threshold"", 0, 100,
				parameters.getThreshold(), Orientation.HORIZONTAL);
		thresholdSlider.addChangeListener(new ChangeListener() {

			public void stateChanged(ChangeEvent e) {
				parameters.setThreshold(thresholdSlider.getSlider().getValue());
			}
		});
		add(thresholdSlider, ""0, 1"");
	}
}
"
LowOccurrencesFilterDialog.java,log,"package org.processmining.log.dialogs;

import info.clearthought.layout.TableLayout;
import info.clearthought.layout.TableLayoutConstants;

import javax.swing.JPanel;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;

import org.deckfour.xes.model.XLog;
import org.processmining.log.parameters.LowOccurrencesFilterParameters;

import com.fluxicon.slickerbox.components.NiceSlider;
import com.fluxicon.slickerbox.components.NiceSlider.Orientation;
import com.fluxicon.slickerbox.factory.SlickerFactory;

public class LowOccurrencesFilterDialog extends JPanel {

	/**
	 * 
	 */
	private static final long serialVersionUID = 9093478331292093365L;

	public LowOccurrencesFilterDialog(XLog eventLog, final LowOccurrencesFilterParameters parameters) {
		double size[][] = { { TableLayoutConstants.FILL }, { TableLayoutConstants.FILL, 30 } };
		setLayout(new TableLayout(size));
		
		add(new ClassifierPanel(eventLog.getClassifiers(), parameters), ""0, 0"");

		final NiceSlider thresholdSlider = SlickerFactory.instance().createNiceIntegerSlider(""Occurrence threshold"", 0, 100,
				parameters.getThreshold(), Orientation.HORIZONTAL);
		thresholdSlider.addChangeListener(new ChangeListener() {

			public void stateChanged(ChangeEvent e) {
				parameters.setThreshold(thresholdSlider.getSlider().getValue());
			}
		});
		add(thresholdSlider, ""0, 1"");
	}
}
"
MergeLogsDialog.java,log,"package org.processmining.log.dialogs;

import java.awt.Dimension;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
import java.util.List;

import javax.swing.DefaultListModel;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.ListSelectionModel;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
import javax.swing.event.ListSelectionEvent;
import javax.swing.event.ListSelectionListener;

import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.processmining.framework.util.ui.widgets.ProMList;
import org.processmining.framework.util.ui.widgets.ProMTextField;
import org.processmining.log.parameters.MergeLogsParameters;
import org.processmining.log.utils.MergeLogsUtils;

import com.fluxicon.slickerbox.components.NiceSlider;
import com.fluxicon.slickerbox.components.NiceSlider.Orientation;
import com.fluxicon.slickerbox.factory.SlickerFactory;

import info.clearthought.layout.TableLayout;
import info.clearthought.layout.TableLayoutConstants;

public class MergeLogsDialog extends JPanel {

	/**
	 * 
	 */
	private static final long serialVersionUID = -5486690145975904628L;

	public MergeLogsDialog(final MergeLogsParameters parameters, final XLog log) {
		double size[][] = { { 100, 700 }, { 30, TableLayoutConstants.FILL, 30, 30, 30, 30, 30, 30, 30 } };
		setLayout(new TableLayout(size));
		int row = 0;
		DateFormat df;
		final Collection<String> ids = new HashSet<String>();
		for (XTrace trace : log) {
			String id = XConceptExtension.instance().extractName(trace);
			if (id != null) {
				ids.add(id);
			}
		}
		
		final ProMTextField idField = new ProMTextField(parameters.getTraceId());
		idField.addKeyListener(new KeyListener() {

			public void keyPressed(KeyEvent e) {
			}

			public void keyTyped(KeyEvent e) {
			}

			public void keyReleased(KeyEvent e) {
				String value = idField.getText().trim();
				if (value.isEmpty() || !ids.contains(value)) {
					value = null;
				} 
				parameters.setTraceId(value);
				idField.visualizeStatus(idField.getText().trim().isEmpty() || value != null);
			}
		});
		add(new JLabel(""Choose Trace ID""), ""0, "" + row);
		add(idField, ""1, "" + row);
		row++;

		DefaultListModel<String> listModel = new DefaultListModel<String>();
		listModel.addElement(parameters.getDateFormat());
		listModel.addElement(""MM/dd/yyyy HH:mm:ss"");
		listModel.addElement(""MM/dd/yyyy hh:mm"");
		listModel.addElement(""MM/dd/yyyy hh:mm:ss"");
		listModel.addElement(""MM/dd/yyyy"");
		listModel.addElement(""dd/MM/yyyy HH:mm"");
		listModel.addElement(""dd/MM/yyyy HH:mm:ss"");
		listModel.addElement(""dd/MM/yyyy hh:mm"");
		listModel.addElement(""dd/MM/yyyy hh:mm:ss"");
		listModel.addElement(""dd/MM/yyyy"");
		listModel.addElement(""dd-MMM-yyyy HH:mm"");
		listModel.addElement(""dd-MMM-yyyy HH:mm:ss"");
		listModel.addElement(""dd-MMM-yyyy hh:mm"");
		listModel.addElement(""dd-MMM-yyyy hh:mm:ss"");
		listModel.addElement(""dd-MMM-yyyy"");
		listModel.addElement(""MM/dd/yy HH:mm"");
		listModel.addElement(""MM/dd/yy HH:mm:ss"");
		listModel.addElement(""MM/dd/yy hh:mm"");
		listModel.addElement(""MM/dd/yy hh:mm:ss"");
		listModel.addElement(""MM/dd/yy"");
		listModel.addElement(""dd/MM/yy HH:mm"");
		listModel.addElement(""dd/MM/yy HH:mm:ss"");
		listModel.addElement(""dd/MM/yy hh:mm"");
		listModel.addElement(""dd/MM/yy hh:mm:ss"");
		listModel.addElement(""dd/MM/yy"");
		listModel.addElement(""dd-MMM-yy HH:mm"");
		listModel.addElement(""dd-MMM-yy HH:mm:ss"");
		listModel.addElement(""dd-MMM-yy hh:mm"");
		listModel.addElement(""dd-MMM-yy hh:mm:ss"");
		listModel.addElement(""dd-MMM-yy"");
		final ProMList<String> list = new ProMList<String>(""Select date format"", listModel);
		list.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
		final String defaultConfiguration = parameters.getDateFormat();
		list.setSelection(defaultConfiguration);
		list.addListSelectionListener(new ListSelectionListener() {
			public void valueChanged(ListSelectionEvent e) {
				List<String> selected = list.getSelectedValuesList();
				if (selected.size() == 1) {
					parameters.setDateFormat(selected.get(0));
				} else {
					/*
					 * Nothing selected. Revert to selection of default classifier.
					 */
					list.setSelection(defaultConfiguration);
					parameters.setDateFormat(defaultConfiguration);
				}
			}
		});
		list.setPreferredSize(new Dimension(10, 10));
		add(list, ""0, "" + row + "", 1, "" + row);
		row++;

		String fromDate = """";
		df = new SimpleDateFormat(parameters.getDateFormat());
		if (parameters.getFromDate() != null) {
			fromDate = df.format(parameters.getFromDate());
		}
		final ProMTextField fromField = new ProMTextField(fromDate);
		fromField.addKeyListener(new KeyListener() {

			public void keyPressed(KeyEvent e) {
			}

			public void keyTyped(KeyEvent e) {
			}

			public void keyReleased(KeyEvent e) {
				Date date = MergeLogsUtils.getDate(parameters, fromField.getText().trim());
				parameters.setFromDate(date);
				fromField.visualizeStatus(fromField.getText().trim().isEmpty() || date != null); 
			}
			
		});
		add(new JLabel(""From Date""), ""0, "" + row);
		add(fromField, ""1, "" + row);
		row++;

		String toDate = """";
		df = new SimpleDateFormat(parameters.getDateFormat());
		if (parameters.getToDate() != null) {
			toDate = df.format(parameters.getToDate());
		}
		final ProMTextField toField = new ProMTextField(toDate);
		toField.addKeyListener(new KeyListener() {

			public void keyPressed(KeyEvent e) {
			}

			public void keyTyped(KeyEvent e) {
			}

			public void keyReleased(KeyEvent e) {
				Date date = MergeLogsUtils.getDate(parameters, toField.getText().trim());
				parameters.setToDate(date);
				toField.visualizeStatus(toField.getText().trim().isEmpty() || date != null); 
			}
			
		});
		add(new JLabel(""To Date""), ""0, "" + row);
		add(toField, ""1, "" + row);
		row++;

		String specificDate = """";
		df = new SimpleDateFormat(parameters.getDateFormat());
		if (parameters.getSpecificDate() != null) {
			specificDate = df.format(parameters.getSpecificDate());
		}
		final ProMTextField specificField = new ProMTextField(specificDate);
		specificField.addKeyListener(new KeyListener() {

			public void keyPressed(KeyEvent e) {
			}

			public void keyTyped(KeyEvent e) {
			}

			public void keyReleased(KeyEvent e) {
				Date date = MergeLogsUtils.getDate(parameters, specificField.getText().trim());
				parameters.setSpecificDate(date);
				specificField.visualizeStatus(specificField.getText().trim().isEmpty() || date != null); 
			}
			
		});
		add(new JLabel(""Specific Date""), ""0, "" + row);
		add(specificField, ""1, "" + row);
		row++;

		final ProMTextField requiredField = new ProMTextField(parameters.getRequiredWords());
		requiredField.addKeyListener(new KeyListener() {

			public void keyPressed(KeyEvent e) {
			}

			public void keyTyped(KeyEvent e) {
			}

			public void keyReleased(KeyEvent e) {
				String value = requiredField.getText().trim();
				if (value.isEmpty()) {
					value = null;
				}
				parameters.setRequiredWords(requiredField.getText());
			}
			
		});
		add(new JLabel(""Required Words""), ""0, "" + row);
		add(requiredField, ""1, "" + row);
		row++;

		final ProMTextField forbiddenField = new ProMTextField(parameters.getForbiddenWords());
		forbiddenField.addKeyListener(new KeyListener() {

			public void keyPressed(KeyEvent e) {
			}

			public void keyTyped(KeyEvent e) {
			}

			public void keyReleased(KeyEvent e) {
				String value = forbiddenField.getText().trim();
				if (value.isEmpty()) {
					value = null;
				}
				parameters.setForbiddenWords(value);
			}
			
		});
		add(new JLabel(""Forbidden Words""), ""0, "" + row);
		add(forbiddenField, ""1, "" + row);
		row++;


		final NiceSlider clusterSlider = SlickerFactory.instance().createNiceIntegerSlider(""Set related"", 0, 100,
				parameters.getRelated(), Orientation.HORIZONTAL);
		clusterSlider.addChangeListener(new ChangeListener() {

			public void stateChanged(ChangeEvent e) {
				parameters.setRelated(clusterSlider.getSlider().getValue());
			}
		});
		add(clusterSlider, ""0, ""+ row + "", 1, "" + row);
		row++;


		final NiceSlider wordSlider = SlickerFactory.instance().createNiceIntegerSlider(""Set matching words"", 0, 100,
				parameters.getMinMatches(), Orientation.HORIZONTAL);
		clusterSlider.addChangeListener(new ChangeListener() {

			public void stateChanged(ChangeEvent e) {
				parameters.setMinMatches(wordSlider.getSlider().getValue());
			}
		});
		add(wordSlider, ""0, ""+ row + "", 1, "" + row);
		row++;

		
	}
	
}
"
MinerPanel.java,log,"package org.processmining.log.dialogs;

import java.awt.Dimension;
import java.util.List;

import javax.swing.DefaultListModel;
import javax.swing.JPanel;
import javax.swing.ListSelectionModel;
import javax.swing.event.ListSelectionEvent;
import javax.swing.event.ListSelectionListener;

import org.processmining.framework.util.ui.widgets.ProMList;
import org.processmining.log.parameters.MinerParameter;
import org.processmining.log.parameters.UpdateParameter;

import info.clearthought.layout.TableLayout;
import info.clearthought.layout.TableLayoutConstants;

public class MinerPanel extends JPanel {
	
	/**
	 * 
	 */
	private static final long serialVersionUID = 7656913719419272750L;

	public MinerPanel(List<String> miners, final MinerParameter minerParameter) {
		this(miners, minerParameter, null);
	}
	
	public MinerPanel(List<String> miners, final MinerParameter minerParameter, final UpdateParameter updateParameter) {
		double size[][] = { { TableLayoutConstants.FILL }, { TableLayoutConstants.FILL } };
		setLayout(new TableLayout(size));

		setOpaque(false);
		
		DefaultListModel<String> listModel = new DefaultListModel<String>();
		for (String miner: miners) {
			listModel.addElement(miner);
		}
		final ProMList<String> list = new ProMList<String>(""Select miner"", listModel);
		list.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
		final String defaultMiner = minerParameter.getMiner();
		list.setSelection(defaultMiner);
		list.addListSelectionListener(new ListSelectionListener() {
			public void valueChanged(ListSelectionEvent e) {
				List<String> selected = list.getSelectedValuesList();
				if (selected.size() == 1) {
					minerParameter.setMiner(selected.get(0));
					if (updateParameter != null) {
						updateParameter.update();
					}
				} else {
					/*
					 * Nothing selected. Revert to selection of default classifier.
					 */
					list.setSelection(defaultMiner);
					minerParameter.setMiner(defaultMiner);
					if (updateParameter != null) {
						updateParameter.update();
					}
				}
			}
		});
		list.setPreferredSize(new Dimension(100, 100));
		add(list, ""0, 0"");

	}

}
"
SplitLogDialog.java,log,"package org.processmining.log.dialogs;

import java.awt.Dimension;
import java.util.List;
import java.util.Set;
import java.util.TreeSet;

import javax.swing.DefaultListModel;
import javax.swing.JPanel;
import javax.swing.ListSelectionModel;
import javax.swing.event.ListSelectionEvent;
import javax.swing.event.ListSelectionListener;

import org.deckfour.xes.model.XAttribute;
import org.deckfour.xes.model.XAttributeLiteral;
import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.processmining.framework.util.ui.widgets.ProMList;
import org.processmining.log.parameters.SplitLogParameters;

import info.clearthought.layout.TableLayout;
import info.clearthought.layout.TableLayoutConstants;

public class SplitLogDialog extends JPanel{

	/**
	 * 
	 */
	private static final long serialVersionUID = -5028679044691450395L;

	public SplitLogDialog(final SplitLogParameters parameters, XLog log) {
		double size[][] = { { TableLayoutConstants.FILL }, { TableLayoutConstants.FILL } };
		setLayout(new TableLayout(size));
		DefaultListModel<String> listModel = new DefaultListModel<String>();
		Set<String> keys = new TreeSet<String>();
		for (XTrace trace : log) {
			for (XEvent event : trace) {
				for (XAttribute attribute : event.getAttributes().values()) {
					if (attribute instanceof XAttributeLiteral) {
						keys.add(attribute.getKey());
					}
				}
			}
		}
		for (String key : keys) {
			listModel.addElement(key);
		}
		final ProMList<String> list = new ProMList<String>(""Select attribute key"", listModel);
		list.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
		final String defaultKey = parameters.getKey();
		list.setSelection(defaultKey);
		list.addListSelectionListener(new ListSelectionListener() {
			public void valueChanged(ListSelectionEvent e) {
				List<String> selected = list.getSelectedValuesList();
				if (selected.size() == 1) {
					parameters.setKey(selected.get(0));
				} else {
					/*
					 * Nothing selected. Revert to selection of default key.
					 */
					list.setSelection(defaultKey);
					parameters.setKey(defaultKey);
				}
			}
		});
		list.setPreferredSize(new Dimension(10, 10));
		add(list, ""0, 0"");		
	}
}
"
FileFormat.java,log,"package org.processmining.log;

/**
 * @see LogFileFormat
 */
@Deprecated
public enum FileFormat {
	XES(""xes""), XES_GZ(""xes.gz""), MXML(""mxml""), MXML_GZ(""mxml.gz"");

	private String desc;

	private FileFormat(String desc) {
		this.desc = desc;
	}

	@Override
	public String toString() {
		return desc;
	}
}
"
FilterFactory.java,log,"package org.processmining.filtering.filter.factories;

import java.util.List;

import org.processmining.filtering.filter.implementations.FilterStackImpl;
import org.processmining.filtering.filter.implementations.MirrorFilterImpl;
import org.processmining.filtering.filter.interfaces.Filter;
import org.processmining.filtering.filter.interfaces.FilterStack;

public class FilterFactory {

	public static <T> Filter<T> mirrorFilter() {
		return new MirrorFilterImpl<T>();
	}

	public static <T> FilterStack<T> filterStack(List<Filter<T>> filters) {
		return new FilterStackImpl<T>(filters);
	}

}
"
FilterStackImpl.java,log,"package org.processmining.filtering.filter.implementations;

import java.util.ArrayList;
import java.util.List;

import org.processmining.filtering.filter.interfaces.Filter;
import org.processmining.filtering.filter.interfaces.FilterStack;

/**
 * @see FilterStack
 * 
 * @author S.J. van Zelst
 * 
 * @param <T>
 *            generic type on which this filter stack should be applied.
 */
public class FilterStackImpl<T> extends ArrayList<Filter<T>> implements FilterStack<T> {

	private static final long serialVersionUID = 6042187895669094422L;

	public FilterStackImpl(List<Filter<T>> filters) {
		this.addAll(filters);
	}

	@Override
	public T apply(T t) {
		T result = t;
		for (Filter<T> filter : this) {
			result = filter.apply(result);
		}
		return result;
	}
	
	@SuppressWarnings(""unchecked"")
	public FilterStack<T> clone() {
		FilterStackImpl<T> clone = null;
		clone = (FilterStackImpl<T>) super.clone();
		return clone;
	}
	

}
"
MirrorFilterImpl.java,log,"package org.processmining.filtering.filter.implementations;

import org.processmining.filtering.filter.interfaces.Filter;

/**
 * A mirror filter is a standard defined filter that (as the name suggests)
 * mirrors each element. Thus mirror function m : T -> T with m(t) = t.
 * 
 * @param <T>
 *            generic type on which this filter is applied.
 * 
 * @author S.J. van Zelst
 */
public class MirrorFilterImpl<T> implements Filter<T> {

	public T apply(T t) {
		return t;
	}

	@SuppressWarnings(""unchecked"")
	public Filter<T> clone() {
		Filter<T> clone = null;
		try  {
			clone = (MirrorFilterImpl<T>) super.clone();
		} catch (CloneNotSupportedException e) {
			e.printStackTrace();
		}
		return clone;
	}
}
"
Filter.java,log,"package org.processmining.filtering.filter.interfaces;

/**
 * A filter is in essence a ""function"" applied on some input. A filter could be
 * defined as a function f : T -> T. A filter is a cloneable object.
 * 
 * @param <T>
 *            generic type on which this filter is applied.
 */
public interface Filter<T> extends Cloneable {
	
	/**
	 * Apply this filter on some input.
	 * 
	 * @param t
	 *            input object of type T
	 * @return return object of type T
	 */
	public T apply(T t);

	/**
	 * Create this filter's clone.
	 * 
	 * @return clone of filter.
	 */
	public Filter<T> clone();
}
"
FilterStack.java,log,"package org.processmining.filtering.filter.interfaces;

import java.util.List;

/**
 * A Filter stack is (as the name suggests) a ""stack of filters"". It is in
 * essence a list of filters, all of the type f: T -> T. If we have a list of
 * filters L = <f0, f1, ..., fn> and we hand over object t of type T, the result
 * will be fn(fn-1(...f1(f0(t)))).
 * 
 * @param <T>
 *            generic type on which this filter is applied.
 */
public interface FilterStack<T> extends Filter<T>, List<Filter<T>> {
	
	public FilterStack<T> clone();

}"
FilterTestPlugin.java,log,"package org.processmining.filtering;
//
//import org.deckfour.xes.extension.std.XConceptExtension;
//import org.deckfour.xes.model.XAttributeMap;
//import org.deckfour.xes.model.XEvent;
//import org.deckfour.xes.model.XLog;
//import org.deckfour.xes.model.XTrace;
//import org.processmining.contexts.uitopia.UIPluginContext;
//import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
//import org.processmining.filtering.filter.factories.FilterFactory;
//import org.processmining.filtering.filter.interfaces.Filter;
//import org.processmining.filtering.xfilter.factories.XFilterFactory;
//import org.processmining.filtering.xfilter.interfaces.XAttributableFilter;
//import org.processmining.filtering.xfilter.interfaces.XFilter;
//import org.processmining.filtering.xflog.implementations.XFLogImpl;
//import org.processmining.filtering.xflog.interfaces.XFLog;
//import org.processmining.framework.plugin.annotations.Plugin;
//import org.processmining.framework.plugin.annotations.PluginVariant;
//
//@Plugin(name = ""Filter test"", parameterLabels = { ""Event log"" }, returnLabels = { ""Log"" }, returnTypes = { XFLog.class })
//public class FilterTestPlugin {
//
//	@UITopiaVariant(affiliation = ""Eindhoven University of Technology"", author = ""S.J. van Zelst"", email = ""s.j.v.zelst@tue.nl"")
//	@PluginVariant(variantLabel = ""Filter test"", requiredParameterLabels = { 0 })
//	/**
//	 * ProM entry point for filter testing.
//	 *
//	 * @param context
//	 * @param log
//	 * @return
//	 */
//	public XFLog filter(final UIPluginContext context, final XLog log) {
//		XAttributableFilter<XEvent> eventFilter = XFilterFactory.containsKeyValuePairFilter(XConceptExtension.KEY_NAME, ""e"");
//		XFilter<XTrace> traceFilter = XFilterFactory.hideXEvent(eventFilter);
//		Filter<XAttributeMap> attributeMapFilter = FilterFactory.mirrorFilter();
//		
//		XFLog fLog = new XFLogImpl(log, traceFilter, attributeMapFilter);
//
//		return fLog;
//	}
//
//}
"
XFilterFactory.java,log,"package org.processmining.filtering.xfilter.factories;

import org.deckfour.xes.model.XAttributable;
import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XTrace;
import org.processmining.filtering.xfilter.implementations.HideXEventXAttributableFilterImpl;
import org.processmining.filtering.xfilter.implementations.XAttributableContainsKeyWithValueXFilterImpl;
import org.processmining.filtering.xfilter.interfaces.XAttributableFilter;
import org.processmining.filtering.xfilter.interfaces.XFilter;

public class XFilterFactory {

	/**
	 * {@link XAttributableContainsKeyWithValueXFilterImpl}
	 * @param key of pair
	 * @param value of pair
	 * @return filter based on pair <key,value>
	 */
	public static <T extends XAttributable> XAttributableFilter<T> containsKeyValuePairFilter(String key, String value) {
		return new XAttributableContainsKeyWithValueXFilterImpl<>(key, value);
	}
	
	/**
	 * {@link XAttributableContainsKeyWithValueXFilterImpl}
	 * @param key of pair
	 * @param value of pair
	 * @return filter based on pair <key,value>
	 */
	public static <T extends XAttributable> XAttributableFilter<T> containsKeyValuePairFilter(String key, boolean value) {
		return new XAttributableContainsKeyWithValueXFilterImpl<>(key, value);
	}
	
	public static XFilter<XTrace> hideXEvent(XAttributableFilter<XEvent> eventFilter) {
		return new HideXEventXAttributableFilterImpl(eventFilter);
	}
}
"
HideXEventXAttributableFilterImpl.java,log,"package org.processmining.filtering.xfilter.implementations;

import java.util.Arrays;

import org.deckfour.xes.model.XAttributeMap;
import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XTrace;
import org.processmining.filtering.filter.factories.FilterFactory;
import org.processmining.filtering.filter.interfaces.Filter;
import org.processmining.filtering.xfilter.interfaces.XAttributableFilter;
import org.processmining.filtering.xfilter.interfaces.XFilter;
import org.processmining.filtering.xflog.implementations.XFTraceImpl;

public class HideXEventXAttributableFilterImpl implements XFilter<XTrace> {
	
	protected XAttributableFilter<XEvent> eventFilter;
	
	public HideXEventXAttributableFilterImpl(XAttributableFilter<XEvent> eventFilter) {
		this.eventFilter = eventFilter;
	}	
	
	public XTrace apply(XTrace t) {
		int[] keep = new int[0];		
		for (int i = 0; i < t.size(); i++) {
			if (eventFilter.apply(t.get(i)) == null) {
				keep = Arrays.copyOf(keep, keep.length + 1);
				keep[keep.length - 1] = i;
			}
		}
		Filter<XEvent> eventFilter = FilterFactory.mirrorFilter();
		Filter<XAttributeMap> traceAttributeFilter = FilterFactory.mirrorFilter();
		return new XFTraceImpl(t, keep, eventFilter, traceAttributeFilter);
	}
	

	public XFilter<XTrace> clone() {
		HideXEventXAttributableFilterImpl clone = null;
		try {
			clone = (HideXEventXAttributableFilterImpl) super.clone();
		} catch (CloneNotSupportedException e) {
			e.printStackTrace();
		}
		return clone;
	}

	
	
}
"
XAttributableContainsKeyWithValueXFilterImpl.java,log,"package org.processmining.filtering.xfilter.implementations;

import org.deckfour.xes.model.XAttributable;
import org.deckfour.xes.model.XAttributeBoolean;
import org.deckfour.xes.model.XAttributeLiteral;
import org.processmining.filtering.xfilter.interfaces.XAttributableFilter;

/**
 * The XAttributableContainsKeyWithValueXFilterImpl class checks whether an
 * XAttributable object contains a given <Key, Value> pair. If the object
 * contains the pair, the apply method will return the object (that is
 * mirrored). If the object does not contain the pair, the apply method will
 * return null.
 * 
 * @author S.J. van Zelst
 * 
 * @param <T> XAttributable object
 */
public class XAttributableContainsKeyWithValueXFilterImpl<T extends XAttributable> implements XAttributableFilter<T> {

	protected String key;

	protected String strVal = null;
	protected Boolean boolVal = null;

	public XAttributableContainsKeyWithValueXFilterImpl(String key, String value) {
		this(key);
		this.strVal = value;
	}

	public XAttributableContainsKeyWithValueXFilterImpl(String key, boolean value) {
		this(key);
		this.boolVal = value;
	}

	private XAttributableContainsKeyWithValueXFilterImpl(String key) {
		this.key = key;
	}

	@SuppressWarnings(""unchecked"")
	public XAttributableFilter<T> clone() {
		XAttributableFilter<T> clone = null;
		try {
			clone = (XAttributableFilter<T>) super.clone();
		} catch (CloneNotSupportedException e) {
			e.printStackTrace();
		}
		return clone;
	}

	/**
	 * Apply method, will return (t) iff <K,V> is contained by the given
	 * XAttributable t. Will return null if t does not contain <K,V>.
	 */
	public T apply(T t) {
		T result = null;
		if (t.getAttributes().containsKey(key)) {
			if (routedCheck(t)) {
				result = t;
			}
		}
		return result;
	}

	private boolean routedCheck(T t) {
		boolean result = false;
		if (strVal != null) {
			result = strEquals(t);
		} else if (boolVal != null) {
			result = boolEquals(t);
		}
		return result;
	}

	private boolean strEquals(T t) {
		boolean result = false;
		XAttributeLiteral literal;
		if (t.getAttributes().get(key) instanceof XAttributeLiteral) {
			literal = (XAttributeLiteral) t.getAttributes().get(key);
			if (literal.getValue().equals(strVal)) {
				result = true;
			}
		}
		return result;
	}

	private boolean boolEquals(T t) {
		boolean result = false;
		XAttributeBoolean bool;
		if (t.getAttributes().get(key) instanceof XAttributeBoolean) {
			bool = (XAttributeBoolean) t.getAttributes().get(key);
			if (bool.getValue() == boolVal) {
				result = true;
			}
		}
		return result;
	}

}
"
XAttributableFilter.java,log,"package org.processmining.filtering.xfilter.interfaces;

import org.deckfour.xes.model.XAttributable;

public interface XAttributableFilter<T extends XAttributable> extends XFilter<T> {
}
"
XFilter.java,log,"package org.processmining.filtering.xfilter.interfaces;

import org.processmining.filtering.filter.interfaces.Filter;

public interface XFilter<T> extends Filter<T> {

}
"
ShuffleInsertionList.java,log,"package org.processmining.filtering.xflog.implementations;

import java.util.AbstractList;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * An abstract shuffle insertion list is a list that allows a programmer to
 * hide/add/duplicate elements from the list. It does so by maintaining an array
 * of indices referring either to: 1. the original list 2. a set of ""added""
 * elements.
 * 
 * @author S.J. van Zelst
 * 
 * @param <T>
 *            generic type of elements within the list.
 */
public class ShuffleInsertionList<T> extends AbstractList<T> implements Cloneable {

	protected List<T> source;
	protected int[] positions;

	@SuppressWarnings(""unchecked"")
	protected T[] newElements = (T[]) new Object[0];

	public ShuffleInsertionList(List<T> source) {
		this.source = source;
		positions = new int[source.size()];
		for (int i = 0; i < source.size(); i++) {
			positions[i] = i;
		}
	}

	public ShuffleInsertionList(List<T> source, int[] elementPositions) {
		this.source = source;
		this.positions = elementPositions;
	}

	//TODO: Test addition of (artificial) events
	public ShuffleInsertionList(List<T> source, List<T> modifiedOrder) {
		this.source = source;
		Map<T, Integer> newElementMap = new HashMap<>();
		positions = new int[modifiedOrder.size()];
		for (int i = 0; i < modifiedOrder.size(); i++) {
			T t = modifiedOrder.get(i);
			if (source.contains(t)) {
				positions[i] = source.indexOf(t);
			} else {
				if (!(newElementMap.keySet().contains(t))) {
					newElements = Arrays.copyOf(newElements, newElements.length + 1);
					newElements[newElements.length - 1] = t;
					newElementMap.put(t, newElements.length * -1);
				}
				positions[i] = newElementMap.get(t);
			}
		}
	}

	public int size() {
		return positions.length;
	}

	@SuppressWarnings(""unchecked"")
	@Override
	public Object clone() {
		ShuffleInsertionList<T> clone = null;
		try {
			clone = (ShuffleInsertionList<T>) super.clone();
			clone.source = new ArrayList<T>(source);
			clone.positions = positions.clone();
			clone.newElements = newElements.clone();
		} catch (CloneNotSupportedException e) {
			e.printStackTrace();
		}
		return clone;
	}

	public T get(int index) {
		T result;
		if (positions[index] >= 0) {
			result = source.get(positions[index]);
		} else {
			result = newElements[(positions[index] * -1) - 1];
		}
		return result;
	}

}
"
XFLogImpl.java,log,"package org.processmining.filtering.xflog.implementations;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import org.deckfour.xes.classification.XEventClassifier;
import org.deckfour.xes.extension.XExtension;
import org.deckfour.xes.info.XLogInfo;
import org.deckfour.xes.model.XAttribute;
import org.deckfour.xes.model.XAttributeMap;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.deckfour.xes.model.XVisitor;
import org.processmining.filtering.filter.interfaces.Filter;
import org.processmining.filtering.xflog.interfaces.XFLog;

public class XFLogImpl extends ShuffleInsertionList<XTrace> implements XFLog {

	/**
	 * Filter related variables
	 */
	protected XLog source;
	protected XAttributeMap attributes;
	protected Set<XExtension> extensions = new HashSet<>();
	protected List<XEventClassifier> classifiers = new ArrayList<>();
	protected List<XAttribute> globalTraceAttributes = new ArrayList<>();
	protected List<XAttribute> globalEventAttributes = new ArrayList<>();
	protected XLogInfo cachedInfo = null;
	protected XEventClassifier cachedClassifier = null;

	Filter<XTrace> traceFilter;
	Filter<XAttributeMap> logAttributeFilter;

	public XFLogImpl(XLog source, Filter<XTrace> traceFilter, Filter<XAttributeMap> logAttributeFilter) {
		super(source);
		init(source, traceFilter, logAttributeFilter);
	}

	public XFLogImpl(XLog source, int[] tracePositions, Filter<XTrace> traceFilter,
			Filter<XAttributeMap> logAttributeFilter) {
		super(source, tracePositions);
		init(source, traceFilter, logAttributeFilter);
	}

	public XFLogImpl(XLog source, List<XTrace> modifiedOrder, Filter<XTrace> traceFilter,
			Filter<XAttributeMap> logAttributeFilter) {
		super(source, modifiedOrder);
		init(source, traceFilter, logAttributeFilter);
	}

	protected void init(XLog source, Filter<XTrace> traceFilter, Filter<XAttributeMap> logAttributeFilter) {
		this.source = source;
		attributes = source.getAttributes();
		this.traceFilter = traceFilter;
		this.logAttributeFilter = logAttributeFilter;
	}

	public Object clone() {
		XFLogImpl clone = null;
		try {
			clone = (XFLogImpl) super.clone();
			clone.attributes = (XAttributeMap) attributes.clone();
			clone.extensions = new HashSet<>(extensions);
			clone.classifiers = new ArrayList<>(classifiers);
			clone.globalTraceAttributes = new ArrayList<>(globalTraceAttributes);
			clone.globalEventAttributes = new ArrayList<>(globalEventAttributes);
			clone.cachedClassifier = null;
			clone.cachedInfo = null;
			clone.source = (XLog) this.source.clone();
			clone.traceFilter = traceFilter;
			clone.logAttributeFilter = logAttributeFilter;

			clone.setSource((XLog) source.clone());
			clone.clear();
			for (XTrace trace : this) {
				clone.add((XTrace) trace.clone());
			}
		} catch (NullPointerException e) {
			e.printStackTrace();
		}
		return clone;
	}

	public XAttributeMap getAttributes() {
		return logAttributeFilter.apply(attributes);
	}

	public void setAttributes(XAttributeMap attributes) {
		this.attributes = attributes;

	}

	public Set<XExtension> getExtensions() {
		return extensions;
	}

	public boolean hasAttributes() {
		return !attributes.isEmpty();
	}

	public XLog getSource() {
		return source;
	}

	public void setSource(XLog log) {
		source = log;
	}

	public XTrace get(int index) {
		return traceFilter.apply(super.get(index));
	}

	@Override
	public void setTraceFilter(Filter<XTrace> filter) {
		traceFilter = filter;
	}

	@Override
	public void setLogAttributeFilter(Filter<XAttributeMap> filter) {
		logAttributeFilter = filter;
	}

	public boolean accept(XVisitor visitor) {
		boolean accept = false;
		if (visitor.precondition()) {
			accept = true;
			visitor.init(this);
			visitor.visitLogPre(this);

			// visit extensions
			for (XExtension extension : extensions) {
				extension.accept(visitor, this);
			}

			// visit classifiers
			for (XEventClassifier classifier : classifiers) {
				classifier.accept(visitor, this);
			}

			// visit attributes
			for (XAttribute attribute : attributes.values()) {
				attribute.accept(visitor, this);
			}

			for (XTrace trace : this) {
				trace.accept(visitor, this);
			}

			visitor.visitLogPost(this);
		}
		return accept;
	}

	//TODO: Check what the impact of filtering is on these functions!
	public List<XEventClassifier> getClassifiers() {
		return classifiers;
	}

	public List<XAttribute> getGlobalEventAttributes() {
		return globalEventAttributes;
	}

	public List<XAttribute> getGlobalTraceAttributes() {
		return globalTraceAttributes;
	}

	public XLogInfo getInfo(XEventClassifier classifier) {
		return classifier.equals(cachedClassifier) ? cachedInfo : null;
	}

	public void setInfo(XEventClassifier classifier, XLogInfo info) {
		cachedClassifier = classifier;
		cachedInfo = info;
	}

}
"
XFTraceImpl.java,log,"package org.processmining.filtering.xflog.implementations;

import java.util.List;
import java.util.Set;

import org.deckfour.xes.extension.XExtension;
import org.deckfour.xes.model.XAttribute;
import org.deckfour.xes.model.XAttributeMap;
import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.deckfour.xes.model.XVisitor;
import org.deckfour.xes.util.XAttributeUtils;
import org.processmining.filtering.filter.interfaces.Filter;
import org.processmining.filtering.xflog.interfaces.XFTrace;

public class XFTraceImpl extends ShuffleInsertionList<XEvent> implements XFTrace {

	protected XAttributeMap attributes;
	protected XTrace source;

	protected Filter<XEvent> eventAttributeFilter;
	protected Filter<XAttributeMap> traceAttributeFilter;

	public XFTraceImpl(XTrace source, Filter<XEvent> eventFilter, Filter<XAttributeMap> traceAttributeFilter) {
		super(source);
		init(source, eventFilter, traceAttributeFilter);
	}

	public XFTraceImpl(XTrace source, int[] eventPositions, Filter<XEvent> eventAttributeFilter,
			Filter<XAttributeMap> traceAttributeFilter) {
		super(source, eventPositions);
		init(source, eventAttributeFilter, traceAttributeFilter);
	}

	public XFTraceImpl(XTrace source, List<XEvent> modifiedOrder, Filter<XEvent> eventAttributeFilter,
			Filter<XAttributeMap> traceAttributeFilter) {
		super(source, modifiedOrder);
		init(source, eventAttributeFilter, traceAttributeFilter);
	}

	protected void init(XTrace source, Filter<XEvent> eventAttributeFilter, Filter<XAttributeMap> traceAttributeFilter) {
		this.source = source;
		attributes = source.getAttributes();
		this.eventAttributeFilter = eventAttributeFilter;
		this.traceAttributeFilter = traceAttributeFilter;
	}

	public XEvent get(int index) {
		return eventAttributeFilter.apply(super.get(index));
	}

	@Override
	public Object clone() {
		XFTrace clone = null;
		clone = (XFTraceImpl) super.clone();
		clone.setSource((XTrace) source.clone());
		clone.setAttributes((XAttributeMap) attributes.clone());
		clone.setEventFilter(eventAttributeFilter);
		clone.setTraceAttributeFilter(traceAttributeFilter);
		clone.clear();
		for (XEvent event : this) {
			clone.add((XEvent) event.clone());
		}
		return clone;
	}

	@Override
	public void accept(XVisitor visitor, XLog log) {
		// first call;
		visitor.visitTracePre(this, log);

		// visit attributes
		for (XAttribute attribute : attributes.values()) {
			attribute.accept(visitor, this);
		}

		// visit events
		for (XEvent event : this) {
			event.accept(visitor, this);
		}

		// final call
		visitor.visitTracePost(this, log);
	}

	@Override
	public XAttributeMap getAttributes() {
		return traceAttributeFilter.apply(attributes);
	}

	@Override
	public void setAttributes(XAttributeMap attributes) {
		this.attributes = attributes;

	}

	@Override
	public Set<XExtension> getExtensions() {
		return XAttributeUtils.extractExtensions(getAttributes());
	}

	@Override
	public boolean hasAttributes() {
		return !(attributes.isEmpty());
	}

	@Override
	public XTrace getSource() {
		return source;
	}

	@Override
	public void setSource(XTrace trace) {
		source = trace;
		attributes = trace.getAttributes();
	}

	@Override
	public void setEventFilter(Filter<XEvent> filter) {
		eventAttributeFilter = filter;
	}

	@Override
	public void setTraceAttributeFilter(Filter<XAttributeMap> filter) {
		traceAttributeFilter = filter;
	}

	/**
	 * The interface describes an ""ordering based on time"". This does no longer
	 * comply with the ""current"" view on Logs.
	 */
	public int insertOrdered(XEvent event) {
		throw new UnsupportedOperationException();
	}

}
"
XFLog.java,log,"package org.processmining.filtering.xflog.interfaces;

import org.deckfour.xes.model.XAttributeMap;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.processmining.filtering.filter.interfaces.Filter;

/**
 * An XFLog is a ""Filtered"" XLog. It behaves like an XLog, though using some
 * source log, it can apply various filtering capabilities. An XFLog can apply a
 * ""trace filter"" on each trace and a ""log attribute filter"" on it's own
 * attributes.
 * 
 * @author M.L. van Eck
 * @author S.J. van Zelst
 */
public interface XFLog extends XLog {

	/**
	 * What log is this filtered log based upon?
	 * 
	 * @return pointer to current source.
	 */
	public XLog getSource();

	/**
	 * Set the source of this filtered log. Setting the source can invoke a
	 * re-evaluation of the internal apply(s).
	 * 
	 * @param log
	 *            pointer to new source.
	 */
	public void setSource(XLog log);

	/**
	 * Set the ""trace filter"" of this log. The trace filter will be applied on
	 * each trace upon trace request (lazy evaluation).
	 * 
	 * @param filter
	 *            to apply on traces in the log.
	 */
	public void setTraceFilter(Filter<XTrace> filter);

	/**
	 * Set the ""log attribute filter"" of this log. The filter will be applied on
	 * the log's attribute upon attribute request (lazy evaluation).
	 * 
	 * @param filter
	 *            to apply on log's attributes.
	 */
	public void setLogAttributeFilter(Filter<XAttributeMap> filter);
}
"
XFTrace.java,log,"package org.processmining.filtering.xflog.interfaces;

import org.deckfour.xes.model.XAttributeMap;
import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XTrace;
import org.processmining.filtering.filter.interfaces.Filter;

/**
 * An XFTrace is a Filtered XTrace. It behaves like a trace and is based on some
 * data type which adheres to the XTrace interface.
 * 
 * @author M.L. van Eck
 * @author S.J. van Zelst
 */
public interface XFTrace extends XTrace {

	/**
	 * What trace is this filtered trace based upon?
	 * 
	 * @return pointer to current source.
	 */
	public XTrace getSource();

	/**
	 * Set the source of this filtered trace. Setting the source can invoke a
	 * re-evaluation of the internal apply(s).
	 * 
	 * @param trace
	 *            pointer to new source.
	 */
	public void setSource(XTrace trace);

	/**
	 * Set the trace's event attribute filter.
	 * 
	 * @param filter
	 *            on attribute map.
	 */
	public void setEventFilter(Filter<XEvent> filter);

	/**
	 * Set the trace's attribute filter
	 * 
	 * @param filter
	 *            on trace attribute-map
	 */
	public void setTraceAttributeFilter(Filter<XAttributeMap> filter);
}
"
AddIdentityFilter.java,log,"
package org.processmining.log.filters;

import java.util.HashMap;
import java.util.Map;
import java.util.Map.Entry;

import org.deckfour.xes.extension.std.XIdentityExtension;
import org.deckfour.xes.id.XID;
import org.deckfour.xes.id.XIDFactory;
import org.deckfour.xes.model.XAttributable;
import org.deckfour.xes.model.XAttribute;
import org.deckfour.xes.model.XAttributeBoolean;
import org.deckfour.xes.model.XAttributeContinuous;
import org.deckfour.xes.model.XAttributeDiscrete;
import org.deckfour.xes.model.XAttributeID;
import org.deckfour.xes.model.XAttributeLiteral;
import org.deckfour.xes.model.XAttributeTimestamp;
import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.log.xes.extensions.id.IdentityConnection;
import org.processmining.plugins.log.logfilters.LogFilter;
import org.processmining.plugins.log.logfilters.LogFilterException;
import org.processmining.plugins.log.logfilters.XEventEditor;
import org.processmining.plugins.log.logfilters.XTraceEditor;

public class AddIdentityFilter implements XEventEditor, XTraceEditor {

	public static XLog addIdentities(PluginContext context, XLog log) {
		AddIdentityFilter af = new AddIdentityFilter(log);

		try {
			return af.filter(context);
		} catch (LogFilterException e) {
			e.printStackTrace();
		}

		return null;
	}

	protected AddIdentityFilter(XLog log) {
		this.log = log;
	}

	private XLog log;

	public XLog filter(PluginContext context) throws LogFilterException {
		idmapping = new HashMap<String, XAttributable>();

		attributeValueMapping = new HashMap<String, Map<Object, XID>>();

		addIdentity(log);
		XLog filtered = LogFilter.filter(context.getProgress(), log.size(), log, null, this, this);
		//create connection
		context.addConnection(getConnection(filtered));

		return filtered;
	}

	public IdentityConnection getConnection(XLog filtered) {
		return new IdentityConnection(filtered, idmapping);
	}

	public XTrace editTrace(XTrace trace) {
		addIdentity(trace);
		return trace;
	}

	public XEvent editEvent(XEvent event) {
		XEvent editedEvent = (XEvent) event.clone();
		addIdentity(editedEvent);

		return editedEvent;
	}

	private Map<String, XAttributable> idmapping;

	private void addIdentity(XAttributable target) {
		//if I'm the identity, ignore me!
		if (target instanceof XAttribute) {
			if (((XAttribute) target).getKey() == XIdentityExtension.KEY_ID) {
				return;
			}
		}

		//first add an identity to my kids...
		for (Entry<String, XAttribute> attr : target.getAttributes().entrySet()) {
			addIdentity(attr.getValue());
		}

		//then to me
		XID id = XIdentityExtension.instance().extractID(target);
		if (id == null) {

			//first check, whether ""I""already have an id in my attribute mapping...
			if (target instanceof XAttribute) {
				id = getIdFromMemory((XAttribute) target);
			} else {
				id = XIDFactory.instance().createId();
			}
		}
		XIdentityExtension.instance().assignID(target, id);

		//store the mapping
		idmapping.put(id.toString(), target);
	}

	private Map<String, Map<Object, XID>> attributeValueMapping;

	private XID getIdFromMemory(XAttribute attr) {
		String key = attr.getKey();

		Map<Object, XID> values = attributeValueMapping.get(key);
		if (values == null) {
			values = new HashMap<Object, XID>();
			attributeValueMapping.put(key, values);
		}

		Object value = getValueOf(attr);
		XID id = values.get(value);
		if (id == null) {
			id = XIDFactory.instance().createId();
			values.put(value, id);
		}

		return id;
	}

	private Object getValueOf(XAttribute attr) {

		if (attr instanceof XAttributeBoolean) {
			return ((XAttributeBoolean) attr).getValue();
		} else if (attr instanceof XAttributeContinuous) {
			return ((XAttributeContinuous) attr).getValue();
		} else if (attr instanceof XAttributeDiscrete) {
			return ((XAttributeDiscrete) attr).getValue();
		} else if (attr instanceof XAttributeTimestamp) {
			return ((XAttributeTimestamp) attr).getValue();
		} else if (attr instanceof XAttributeLiteral) {
			return ((XAttributeLiteral) attr).getValue();
		} else if (attr instanceof XAttributeID) {
			return ((XAttributeID) attr).getValue();
		} else {
			return new Object();
		}
	}

}
"
ExtensionFilter.java,log,"package org.processmining.log.filters;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashSet;
import java.util.Map.Entry;
import java.util.Set;

import org.deckfour.xes.extension.XExtension;
import org.deckfour.xes.model.XAttributable;
import org.deckfour.xes.model.XAttribute;
import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.processmining.framework.plugin.Progress;
import org.processmining.plugins.log.logfilters.LogFilter;
import org.processmining.plugins.log.logfilters.LogFilterException;
import org.processmining.plugins.log.logfilters.XEventEditor;
import org.processmining.plugins.log.logfilters.XTraceEditor;

/**
 * 
 * 
 * 
 * @author jvdwerf
 *
 */
public class ExtensionFilter implements XEventEditor, XTraceEditor {

	public static XLog removeExtensions(XLog log, XExtension extension) {		
		return removeExtensions(null, log, extension);
	}
	
	public static XLog removeExtensions(XLog log, String extension) {		
		return removeExtensions(null, log, extension);
	}
	
	
	public static XLog removeExtensions(Progress progress, XLog log, XExtension extension) {
		return removeExtensions(progress, log, extension.getName());
	}
	
	public static XLog removeExtensions(Progress progress, XLog log, String extension) {
		Set<String> names = new HashSet<String>();
		names.add(extension);
		
		return removeExtensions(progress, log, names);
	}
	
	public static XLog removeExtensions(Progress progress, XLog log, String... extensions) {
		return removeExtensions(progress, log, Arrays.asList(extensions));
	}
	
	public static XLog removeExtensions(Progress progress, XLog log, Collection<String> extensions) {

		ExtensionFilter ef = new ExtensionFilter((XLog) log.clone());
		
		try {
			return ef.filter(progress, extensions);
			
		} catch (LogFilterException e) {
			e.printStackTrace();
		}
		
		return null;
	}
	
	//////
	///
	
	private Set<String> attrKeys;
	private Set<String> logKeys;
	private Set<String> traceKeys;
	private Set<String> eventKeys;
	
	private XLog log;
	
	public ExtensionFilter(XLog log) {
		this.log = log;
	}
	
	public XLog getLog() {
		return log;
	}
	
	public XLog filter(Progress progress, Collection<String> extensions) throws LogFilterException {
		
		//set the attribute sets, and remove extensions from log
		prepareExtensionList(extensions);
		
		removeAttributes(log, logKeys);
		
		return LogFilter.filter(progress, log.size(), log, null, this, this);
	}
	
	private void prepareExtensionList(Collection<String> extensions) {
		attrKeys = new HashSet<String>();
		logKeys = new HashSet<String>();
		traceKeys = new HashSet<String>();
		eventKeys = new HashSet<String>();
		
		Collection<XExtension> tbr = new ArrayList<XExtension>();
		
		for(XExtension ext : log.getExtensions()) {
			if (extensions.contains(ext.getName())) {
				for(XAttribute attr : ext.getLogAttributes()) {
					logKeys.add(attr.getKey());
				}
				for(XAttribute attr : ext.getTraceAttributes()) {
					traceKeys.add(attr.getKey());
				}
				for(XAttribute attr : ext.getEventAttributes()) {
					eventKeys.add(attr.getKey());
				}
				for(XAttribute attr : ext.getMetaAttributes()) {
					attrKeys.add(attr.getKey());
				}
				
				tbr.add(ext);
			}
		}
		
		log.getExtensions().removeAll(tbr);
	}
	
	public XTrace editTrace(XTrace trace) {
		
		removeAttributes(trace, traceKeys);
		
		return trace;
	}

	public XEvent editEvent(XEvent event) {
		XEvent editedEvent = (XEvent) event.clone();
		
		removeAttributes(editedEvent, eventKeys);
		
		return editedEvent;
	}
	
	private void removeAttributes(XAttributable target, Set<String> items) {
		for(String key : items) {
			target.getAttributes().remove(key);
		}
		for(Entry<String,XAttribute> attr : target.getAttributes().entrySet()) {
			removeAttributes(attr.getValue(), attrKeys);
		}
	}
	
	
	
	
}
"
AddIdentityFilterUI.java,log,"package org.processmining.log.filters.ui;

import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.model.XLog;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.log.filters.AddIdentityFilter;

@Plugin(name = ""Add identity attribute"", returnLabels = { ""Log with identities"" }, returnTypes = {
		XLog.class }, parameterLabels = { ""Log"" })
public class AddIdentityFilterUI {

	@UITopiaVariant(uiLabel = ""Add identities to log"", affiliation = UITopiaVariant.EHV, author = ""J.M.E.M. van der Werf"", email = ""j.m.e.m.v.d.werf@tue.nl"", pack = ""Ontologies"")
	@PluginVariant(variantLabel = ""Add identities to log"", requiredParameterLabels = { 0 })
	public XLog addIdentitiesUI(UIPluginContext context, XLog log) {
		return addIdentities(context, log);
	}

	@PluginVariant(variantLabel = ""Add identities to log"", requiredParameterLabels = { 0 })
	public XLog addIdentities(PluginContext context, XLog log) {
		XLog filtered = AddIdentityFilter.addIdentities(context, log);
		if (filtered != null) {
			String name = XConceptExtension.instance().extractName(log);
			if (name == null) {
				name = ""Log"";
			}
			context.getFutureResult(0).setLabel(name + "" with identities"");
			return filtered;
		} else {
			context.getFutureResult(0).cancel(true);
			return null;
		}
	}

}
"
ExtensionFilterUI.java,log,"package org.processmining.log.filters.ui;

import java.util.HashSet;
import java.util.Set;

import javax.swing.DefaultListModel;
import javax.swing.JComponent;

import org.deckfour.xes.extension.XExtension;
import org.deckfour.xes.model.XLog;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.framework.util.ui.widgets.ProMList;
import org.processmining.framework.util.ui.widgets.ProMPropertiesPanel;
import org.processmining.framework.util.ui.wizard.ListWizard;
import org.processmining.framework.util.ui.wizard.ProMWizardDisplay;
import org.processmining.framework.util.ui.wizard.ProMWizardStep;
import org.processmining.log.filters.ExtensionFilter;

@Plugin(name = ""Extension Filter"", returnLabels = { ""Filtered log"" }, returnTypes = { XLog.class }, parameterLabels = {
		""Log"" })
public class ExtensionFilterUI {

	@UITopiaVariant(uiLabel = ""Remove extensions from log"", affiliation = UITopiaVariant.EHV, author = ""J.M.E.M. van der Werf"", email = ""j.m.e.m.v.d.werf@tue.nl"", pack = ""Ontologies"")
	@PluginVariant(variantLabel = ""Remove extensions from log"", requiredParameterLabels = { 0 })
	public XLog removeExtensions(final UIPluginContext context, final XLog log) {

		Step wizardStep = new Step(log);
		ListWizard<Set<String>> wizard = new ListWizard<Set<String>>(wizardStep);

		Set<String> extensions = ProMWizardDisplay.show(context, wizard, new HashSet<String>());

		if (extensions == null || extensions.size() == 0) {
			context.getFutureResult(0).cancel(true);
			return null;
		}

		return ExtensionFilter.removeExtensions(context.getProgress(), log, extensions);
	}

	/*
	 * ProMPropertiesPanel props = new ProMPropertiesPanel(""Remove extensions"");
	 * //ProMList extList = new ProMList(""Extensions"", listModel);
	 * props.add(extList);
	 * 
	 */
	private class Step implements ProMWizardStep<Set<String>> {

		public String getTitle() {
			return ""Remove extensions"";
		}

		private ProMPropertiesPanel panel;
		private ProMList listbox;

		public Step(XLog log) {
			panel = new ProMPropertiesPanel(null);

			DefaultListModel model = new DefaultListModel();

			for (XExtension ext : log.getExtensions()) {
				model.addElement(ext.getName());
			}

			//add a list
			listbox = new ProMList(""Extensions"", model);
			panel.addProperty(""Extensions to be removed"", listbox);
		}

		public JComponent getComponent(Set<String> model) {

			listbox.setSelection(model);

			return panel;
		}

		public Set<String> apply(Set<String> model, JComponent component) {
			//set the model to all selected items.
			Set<String> items = new HashSet<String>();
			for (Object o : listbox.getSelectedValues()) {
				items.add((String) o);
			}
			return items;
		}

		public boolean canApply(Set<String> model, JComponent component) {
			return true;
		}

	}

}
"
StandardDateFormats.java,log,"package org.processmining.log.formats;

import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.LinkedHashSet;
import java.util.Set;

/**
 * Standard formats for Dates that might be encountered in log data, e.g. in CSV
 * format.
 */
public final class StandardDateFormats {

	@SuppressWarnings(""serial"")
	private static final Set<SimpleDateFormat> STANDARD_DATE_FORMATS = new LinkedHashSet<SimpleDateFormat>() {
		{
			add(new SimpleDateFormat(""yyyy-M-d H:mm:ss.SSSXXX""));
			add(new SimpleDateFormat(""yyyy-M-d H:mm:ss.SSSz""));
			add(new SimpleDateFormat(""yyyy-M-d H:mm:ss.SSS""));
			add(new SimpleDateFormat(""yyyy-M-d H:mm:ssXXX""));
			add(new SimpleDateFormat(""yyyy-M-d H:mm:ssz""));
			add(new SimpleDateFormat(""yyyy-M-d H:mm:ss""));
			add(new SimpleDateFormat(""yyyy-M-d H:mm""));
			add(new SimpleDateFormat(""yyyy-M-d'T'H:mm:ss.SSSXXX""));
			add(new SimpleDateFormat(""yyyy-M-d'T'H:mm:ss.SSSz""));
			add(new SimpleDateFormat(""yyyy-M-d'T'H:mm:ss.SSS""));
			add(new SimpleDateFormat(""yyyy-M-d'T'H:mm:ssXXX""));
			add(new SimpleDateFormat(""yyyy-M-d'T'H:mm:ssz""));
			add(new SimpleDateFormat(""yyyy-M-d'T'H:mm:ss""));
			add(new SimpleDateFormat(""yyyy-M-d'T'H:mm""));
			add(new SimpleDateFormat(""yyyy-M-d""));

			add(new SimpleDateFormat(""yyyy-MM-dd HH:mm:ss.SSSXXX""));
			add(new SimpleDateFormat(""yyyy-MM-dd HH:mm:ss.SSSz""));
			add(new SimpleDateFormat(""yyyy-MM-dd HH:mm:ss.SSS""));
			add(new SimpleDateFormat(""yyyy-MM-dd HH:mm:ssXXX""));
			add(new SimpleDateFormat(""yyyy-MM-dd HH:mm:ssz""));
			add(new SimpleDateFormat(""yyyy-MM-dd HH:mm:ss""));
			add(new SimpleDateFormat(""yyyy-MM-dd HH:mm""));
			add(new SimpleDateFormat(""yyyy-MM-dd'T'HH:mm:ss.SSSXXX""));
			add(new SimpleDateFormat(""yyyy-MM-dd'T'HH:mm:ss.SSSz""));
			add(new SimpleDateFormat(""yyyy-MM-dd'T'HH:mm:ss.SSS""));
			add(new SimpleDateFormat(""yyyy-MM-dd'T'HH:mm:ssXXX""));
			add(new SimpleDateFormat(""yyyy-MM-dd'T'HH:mm:ssz""));
			add(new SimpleDateFormat(""yyyy-MM-dd'T'HH:mm:ss""));
			add(new SimpleDateFormat(""yyyy-MM-dd'T'HH:mm""));
			add(new SimpleDateFormat(""yyyy-MM-dd""));

			add(new SimpleDateFormat(""yyyy/M/d H:mm:ss.SSSXXX""));
			add(new SimpleDateFormat(""yyyy/M/d H:mm:ss.SSSz""));
			add(new SimpleDateFormat(""yyyy/M/d H:mm:ss.SSS""));
			add(new SimpleDateFormat(""yyyy/M/d H:mm:ssXXX""));
			add(new SimpleDateFormat(""yyyy/M/d H:mm:ssz""));
			add(new SimpleDateFormat(""yyyy/M/d H:mm:ss""));
			add(new SimpleDateFormat(""yyyy/M/d H:mm""));
			add(new SimpleDateFormat(""yyyy/M/d'T'H:mm:ss.SSSXXX""));
			add(new SimpleDateFormat(""yyyy/M/d'T'H:mm:ss.SSSz""));
			add(new SimpleDateFormat(""yyyy/M/d'T'H:mm:ss.SSS""));
			add(new SimpleDateFormat(""yyyy/M/d'T'H:mm:ssXXX""));
			add(new SimpleDateFormat(""yyyy/M/d'T'H:mm:ssz""));
			add(new SimpleDateFormat(""yyyy/M/d'T'H:mm:ss""));
			add(new SimpleDateFormat(""yyyy/M/d'T'H:mm""));
			add(new SimpleDateFormat(""yyyy/M/d""));

			add(new SimpleDateFormat(""yyyy/MM/dd HH:mm:ss.SSSXXX""));
			add(new SimpleDateFormat(""yyyy/MM/dd HH:mm:ss.SSSz""));
			add(new SimpleDateFormat(""yyyy/MM/dd HH:mm:ss.SSS""));
			add(new SimpleDateFormat(""yyyy/MM/dd HH:mm:ssXXX""));
			add(new SimpleDateFormat(""yyyy/MM/dd HH:mm:ssz""));
			add(new SimpleDateFormat(""yyyy/MM/dd HH:mm:ss""));
			add(new SimpleDateFormat(""yyyy/MM/dd HH:mm""));
			add(new SimpleDateFormat(""yyyy/MM/dd'T'HH:mm:ss.SSSXXX""));
			add(new SimpleDateFormat(""yyyy/MM/dd'T'HH:mm:ss.SSSz""));
			add(new SimpleDateFormat(""yyyy/MM/dd'T'HH:mm:ss.SSS""));
			add(new SimpleDateFormat(""yyyy/MM/dd'T'HH:mm:ssXXX""));
			add(new SimpleDateFormat(""yyyy/MM/dd'T'HH:mm:ssz""));
			add(new SimpleDateFormat(""yyyy/MM/dd'T'HH:mm:ss""));
			add(new SimpleDateFormat(""yyyy/MM/dd'T'HH:mm""));
			add(new SimpleDateFormat(""yyyy/MM/dd""));

			add(new SimpleDateFormat(""M/d/yyyy H:mm:ss.SSSXXX""));
			add(new SimpleDateFormat(""M/d/yyyy H:mm:ss.SSSz""));
			add(new SimpleDateFormat(""M/d/yyyy H:mm:ss.SSS""));
			add(new SimpleDateFormat(""M/d/yyyy H:mm:ssXXX""));
			add(new SimpleDateFormat(""M/d/yyyy H:mm:ssz""));
			add(new SimpleDateFormat(""M/d/yyyy H:mm:ss""));
			add(new SimpleDateFormat(""M/d/yyyy H:mm""));
			add(new SimpleDateFormat(""M/d/yyyy'T'H:mm:ss.SSSXXX""));
			add(new SimpleDateFormat(""M/d/yyyy'T'H:mm:ss.SSSz""));
			add(new SimpleDateFormat(""M/d/yyyy'T'H:mm:ss.SSS""));
			add(new SimpleDateFormat(""M/d/yyyy'T'H:mm:ssXXX""));
			add(new SimpleDateFormat(""M/d/yyyy'T'H:mm:ssz""));
			add(new SimpleDateFormat(""M/d/yyyy'T'H:mm:ss""));
			add(new SimpleDateFormat(""M/d/yyyy'T'H:mm""));
			add(new SimpleDateFormat(""M/d/yyyy""));

			add(new SimpleDateFormat(""MM/dd/yyyy HH:mm:ss.SSSXXX""));
			add(new SimpleDateFormat(""MM/dd/yyyy HH:mm:ss.SSSz""));
			add(new SimpleDateFormat(""MM/dd/yyyy HH:mm:ss.SSS""));
			add(new SimpleDateFormat(""MM/dd/yyyy HH:mm:ssXXX""));
			add(new SimpleDateFormat(""MM/dd/yyyy HH:mm:ssz""));
			add(new SimpleDateFormat(""MM/dd/yyyy HH:mm:ss""));
			add(new SimpleDateFormat(""MM/dd/yyyy HH:mm""));
			add(new SimpleDateFormat(""MM/dd/yyyy'T'HH:mm:ss.SSSXXX""));
			add(new SimpleDateFormat(""MM/dd/yyyy'T'HH:mm:ss.SSSz""));
			add(new SimpleDateFormat(""MM/dd/yyyy'T'HH:mm:ss.SSS""));
			add(new SimpleDateFormat(""MM/dd/yyyy'T'HH:mm:ssXXX""));
			add(new SimpleDateFormat(""MM/dd/yyyy'T'HH:mm:ssz""));
			add(new SimpleDateFormat(""MM/dd/yyyy'T'HH:mm:ss""));
			add(new SimpleDateFormat(""MM/dd/yyyy'T'HH:mm""));
			add(new SimpleDateFormat(""MM/dd/yyyy""));
			
			add(new SimpleDateFormat(""dd/MM/yyyy HH:mm:ss.SSSXXX""));
			add(new SimpleDateFormat(""dd/MM/yyyy HH:mm:ss.SSSz""));
			add(new SimpleDateFormat(""dd/MM/yyyy HH:mm:ss.SSS""));
			add(new SimpleDateFormat(""dd/MM/yyyy HH:mm:ssXXX""));
			add(new SimpleDateFormat(""dd/MM/yyyy HH:mm:ssz""));
			add(new SimpleDateFormat(""dd/MM/yyyy HH:mm:ss""));
			add(new SimpleDateFormat(""dd/MM/yyyy HH:mm""));
			add(new SimpleDateFormat(""dd/MM/yyyy'T'HH:mm:ss.SSSXXX""));
			add(new SimpleDateFormat(""dd/MM/yyyy'T'HH:mm:ss.SSSz""));
			add(new SimpleDateFormat(""dd/MM/yyyy'T'HH:mm:ss.SSS""));
			add(new SimpleDateFormat(""dd/MM/yyyy'T'HH:mm:ssXXX""));
			add(new SimpleDateFormat(""dd/MM/yyyy'T'HH:mm:ssz""));
			add(new SimpleDateFormat(""dd/MM/yyyy'T'HH:mm:ss""));
			add(new SimpleDateFormat(""dd/MM/yyyy'T'HH:mm""));	

			add(new SimpleDateFormat(""yyyy.M.d H:mm:ss.SSSXXX""));
			add(new SimpleDateFormat(""yyyy.M.d H:mm:ss.SSSz""));
			add(new SimpleDateFormat(""yyyy.M.d H:mm:ss.SSS""));
			add(new SimpleDateFormat(""yyyy.M.d H:mm:ssXXX""));
			add(new SimpleDateFormat(""yyyy.M.d H:mm:ssz""));
			add(new SimpleDateFormat(""yyyy.M.d H:mm:ss""));
			add(new SimpleDateFormat(""yyyy.M.d H:mm""));

			add(new SimpleDateFormat(""yyyy.MM.dd HH:mm:ss.SSSXXX""));
			add(new SimpleDateFormat(""yyyy.MM.dd HH:mm:ss.SSSz""));
			add(new SimpleDateFormat(""yyyy.MM.dd HH:mm:ss.SSS""));
			add(new SimpleDateFormat(""yyyy.MM.dd HH:mm:ssXXX""));
			add(new SimpleDateFormat(""yyyy.MM.dd HH:mm:ssz""));
			add(new SimpleDateFormat(""yyyy.MM.dd HH:mm:ss""));
			add(new SimpleDateFormat(""yyyy.MM.dd HH:mm""));
			
			add(new SimpleDateFormat(""dd.MM.yyyy HH:mm:ss.SSSXXX""));
			add(new SimpleDateFormat(""dd.MM.yyyy HH:mm:ss.SSSz""));
			add(new SimpleDateFormat(""dd.MM.yyyy HH:mm:ss.SSS""));
			add(new SimpleDateFormat(""dd.MM.yyyy HH:mm:ssXXX""));
			add(new SimpleDateFormat(""dd.MM.yyyy HH:mm:ssz""));
			add(new SimpleDateFormat(""dd.MM.yyyy HH:mm:ss""));
			add(new SimpleDateFormat(""dd.MM.yyyy HH:mm""));

			add(new SimpleDateFormat(""d-M-yyyy:H:mm:ss""));
			add(new SimpleDateFormat(""EEE, d MMM yyyy H:mm:ss z""));
			add(new SimpleDateFormat(""M-d-yyyy H:mm:ss""));
			add(new SimpleDateFormat(""M-d-yyyy H:mm""));
			add(new SimpleDateFormat(""M-d-yyyy""));
			add(new SimpleDateFormat(""d-M-yyyy H:mm:ss""));
			add(new SimpleDateFormat(""d-M-yyyy H:mm""));
			add(new SimpleDateFormat(""d-M-yyyy""));

			add(new SimpleDateFormat(""dd-MM-yyyy:HH:mm:ss""));
			add(new SimpleDateFormat(""EEE, dd MMM yyyy HH:mm:ss z""));
			add(new SimpleDateFormat(""MM-dd-yyyy HH:mm:ss""));
			add(new SimpleDateFormat(""MM-dd-yyyy HH:mm""));
			add(new SimpleDateFormat(""MM-dd-yyyy""));
			add(new SimpleDateFormat(""dd-MM-yyyy HH:mm:ss""));
			add(new SimpleDateFormat(""dd-MM-yyyy HH:mm""));
			add(new SimpleDateFormat(""dd-MM-yyyy""));
			
			add(new SimpleDateFormat(""dd.MM.yyyy HH.mm""));
		}
	};

	static {
		for (DateFormat df : STANDARD_DATE_FORMATS) {
			df.setLenient(false);
		}
	}

	private StandardDateFormats() {
		super();
	}

	/**
	 * @return {@link SimpleDateFormat} for various {@link Date} patterns in
	 *         order from most specific to least specific.
	 */
	public static Iterable<SimpleDateFormat> getStandardDateFormats() {
		return STANDARD_DATE_FORMATS;
	}

}
"
HighFrequencyFilterArrayHelp.java,log,"package org.processmining.log.help;

public class HighFrequencyFilterArrayHelp {

	public final static String TEXT = """"
			+ ""Filters every log in the array using a frequency threshold (a percentage) and a distance threshold (edit distance). ""
			+ ""Any trace that either<ol>""
			+ ""<li>has a high-enough frequency or</li>""
			+ ""<li>is close enough to a trace with high-enough frequency</li>""
			+ ""</ol>will be filtered in. ""
			+ ""A trace has high-enough frequency if its frequency is required to reach the overall frequency threshold."";

}
"
HighFrequencyFilterHelp.java,log,"package org.processmining.log.help;

public class HighFrequencyFilterHelp {

	public final static String TEXT = """"
			+ ""Filters a log using a frequency threshold (a percentage) and a distance threshold (edit distance). ""
			+ ""Any trace that either<ol>""
			+ ""<li>has a high-enough frequency or</li>""
			+ ""<li>is close enough to a trace with high-enough frequency</li>""
			+ ""</ol>will be filtered in. ""
			+ ""A trace has high-enough frequency if its frequency is required to reach the overall frequency threshold."";

}
"
LogCentralityFilterHelp.java,log,"package org.processmining.log.help;

public class LogCentralityFilterHelp {

	public final static String TEXT = """"
			+ ""Filters a log using a centrality threshold (edit distance). ""
			+ ""Any trace that is close enough to the centre will be filtered in."";

}
"
LogCentralityHelp.java,log,"package org.processmining.log.help;

public class LogCentralityHelp {

	public final static String TEXT = """"
			+ ""Extends the log with centrality information, that is, with distances between all traces."";

}
"
LogCheckerHelp.java,log,"package org.processmining.log.help;

public class LogCheckerHelp {

	public final static String TEXT = """"
			+ ""Checks a log for common problems."";
}
"
LogFrequencyArrayHelp.java,log,"package org.processmining.log.help;

public class LogFrequencyArrayHelp {

	public final static String TEXT = """"
			+ ""Builds frequency overviews (how often traces occur) for every log in the array. ""
			+ ""The classifier provided determines which traces are considered equal."";

}
"
LogFrequencyHelp.java,log,"package org.processmining.log.help;

public class LogFrequencyHelp {

	public final static String TEXT = """"
			+ ""Filters a log using a frequency threshold (a percentage). ""
			+ ""Any trace that has a high-enough frequency will be filtered in. ""
			+ ""A trace has high-enough frequency if its frequency is required to reach the overall frequency threshold."";

}
"
LowFrequencyFilterArrayHelp.java,log,"package org.processmining.log.help;

public class LowFrequencyFilterArrayHelp {

	public final static String TEXT = """"
			+ ""Filters every log in the array using a frequency threshold. ""
			+ ""Traces that do not appear frequent enough, will be filtered out."";

}
"
LowFrequencyFilterHelp.java,log,"package org.processmining.log.help;

public class LowFrequencyFilterHelp {

	public final static String TEXT = """"
			+ ""Filters a log using a frequency threshold. ""
			+ ""Traces that do not appear frequent enough, will be filtered out. "";

}
"
LowOccurrencesFilterArrayHelp.java,log,"package org.processmining.log.help;

public class LowOccurrencesFilterArrayHelp {

	public final static String TEXT = """"
			+ ""Filters every log in the array using an absolute threshold. ""
			+ ""Traces that do not appear often enough, will be filtered out. "";

}
"
LowOccurrencesFilterHelp.java,log,"package org.processmining.log.help;

public class LowOccurrencesFilterHelp {

	public final static String TEXT = """"
			+ ""Filters a log using an absolute threshold. ""
			+ ""Traces that do not appear often enough, will be filtered out. "";

}
"
MergeLogsHelp.java,log,"package org.processmining.log.help;

public class MergeLogsHelp {

	public final static String TEXT = """"
			+ ""Merges two logs."";
}
"
SplitLogHelp.java,log,"package org.processmining.log.help;

public class SplitLogHelp {

	public final static String TEXT = """"
			+ ""Splits traces in a log on a selected event attribute. ""
			+ ""If the attribute exists for an event, then it is assumed to be a white-space spearated list of values. ""
			+ ""A trace will be split into as many subtraces as there are values in its events for the selected attribute. ""
			+ ""The subtrace for a given value contains (in the same order as in the trace) all events that: ""
			+ ""(1) either contain this value in the attribute value or (2) have no such attribute."";
}
"
HighFrequencyFilterAlgorithm.java,log,"package org.processmining.log.algorithms;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.log.parameters.HighFrequencyFilterParameters;
import org.processmining.log.parameters.LogFilterParameters;

public class HighFrequencyFilterAlgorithm implements LogFilterAlgorithm {

	private Map<Set<List<String>>, Integer> cache;

	public HighFrequencyFilterAlgorithm() {
		cache = new HashMap<Set<List<String>>, Integer>();
	}
	
	public XLog apply(PluginContext context, XLog log, LogFilterParameters parameters) {
		final Map<List<String>, Integer> traceOccurrenceMap = new HashMap<List<String>, Integer>();
		final Map<XTrace, List<String>> traceActivitiesMap = new HashMap<XTrace, List<String>>();
		XLog clonedLog = (XLog) log.clone();

		for (XTrace trace : clonedLog) {
			List<String> activities = new ArrayList<String>();
			for (XEvent event : trace) {
				activities.add(parameters.getClassifier().getClassIdentity(event));
			}
			traceActivitiesMap.put(trace, activities);
			if (traceOccurrenceMap.keySet().contains(activities)) {
				traceOccurrenceMap.put(activities, traceOccurrenceMap.get(activities) + 1);
			} else {
				traceOccurrenceMap.put(activities, 1);
			}
		}

		List<Integer> occurrences = new ArrayList<Integer>(traceOccurrenceMap.values());
		Collections.sort(occurrences);

//		SummaryStatistics statistics = new SummaryStatistics();
//		for (int occurrence : occurrences) {
//			for (int i = 0; i < occurrence; i++) {
//				statistics.addValue(occurrence);
//			}
//		}
//		int threshold = (int) Math.round(statistics.getMean() - 1.0 * statistics.getStandardDeviation());
		int threshold = ((100 - ((HighFrequencyFilterParameters) parameters).getFrequencyThreshold()) * clonedLog
				.size()) / 100;
		int sum = 0;
		int index = -1;
		while (sum < threshold) {
			sum += occurrences.get(++index);
		}
		/*
		 * The 'traces' occurrences[index]...occurrences[occurrences.size()-1]
		 * cover more than X% if the log, where X = parameters.getThreshold().
		 */
		threshold = occurrences.get(index);
		/*
		 * If we take all traces that occur at least as many times as threshold
		 * times, we cover at least X% of the log.
		 */
		if (threshold == occurrences.get(occurrences.size() - 1) + 1) {
			/*
			 * We're about to remove all traces. That seems to be undesirable.
			 */
			threshold--;
		}
		System.out.println(""Threshold = "" + threshold);

		Collection<XTrace> tracesToRemove = new HashSet<XTrace>();

		for (XTrace trace : clonedLog) {
			if (traceOccurrenceMap.get(traceActivitiesMap.get(trace)) >= threshold) {
				/*
				 * Trace occurs often enough. Filter it in.
				 */
			} else {
				/*
				 * Trace does not occur often enough by itself. Check whether it
				 * matches one that does.
				 */
				boolean retain = false;
				for (XTrace otherTrace : clonedLog) {
					if (traceOccurrenceMap.get(traceActivitiesMap.get(otherTrace)) >= threshold) {
						if (getTraceDistance(traceActivitiesMap.get(trace), traceActivitiesMap.get(otherTrace)) < ((HighFrequencyFilterParameters) parameters)
								.getDistanceThreshold()) {
							/*
							 * Yes, it matches one that does. Filter this trace
							 * in as well.
							 */
							retain = true;
							continue;
						}
					}
				}
				if (!retain) {
					/*
					 * This trace does not occur frequent enough, an dit does
					 * not match any other traces that does. Filter it out.
					 */
					tracesToRemove.add(trace);
				}
			}
		}

		clonedLog.removeAll(tracesToRemove);
		/*
		 * At least X% of the log is retained.
		 */

		return clonedLog;
	}

	private int getTraceDistance(List<String> activities1, List<String> activities2) {
		return getTraceDistance(activities1, activities2, 0, 0);
	}

	private int getTraceDistance(List<String> activities1, List<String> activities2, int index1, int index2) {
		int distance = 0;
		if (index1 >= activities1.size()) {
			distance = activities2.size() - index2;
		} else if (index2 >= activities2.size()) {
			distance = activities1.size() - index1;
		} else {
			Set<List<String>> activities = new HashSet<List<String>>();
			activities.add(activities1);
			activities.add(activities2);
			if (cache.containsKey(activities)) {
				distance = cache.get(activities);
			} else {
				if (activities1.get(index1).equals(activities2.get(index2))) {
					distance = getTraceDistance(activities1, activities2, index1 + 1, index2 + 1);
				} else {
					int distance1 = 1 + getTraceDistance(activities1, activities2, index1 + 1, index2);
					int distance2 = 1 + getTraceDistance(activities1, activities2, index1, index2 + 1);
					if (distance1 < distance2) {
						distance = distance1;
					} else {
						distance = distance2;
					}
				}
				cache.put(activities, distance);
			}
		}
		return distance;
	}
}
"
LogCentralityAlgorithm.java,log,"package org.processmining.log.algorithms;

import org.deckfour.xes.model.XLog;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.log.models.LogCentrality;
import org.processmining.log.parameters.LogCentralityParameters;

public class LogCentralityAlgorithm {

	public LogCentrality apply(PluginContext context, XLog log, LogCentrality centrality, LogCentralityParameters parameters) {
		context.getProgress().setMaximum(log.size());
		centrality.setClassifier(context, parameters);
		return centrality;
	}
}
"
LogCentralityFilterAlgorithm.java,log,"package org.processmining.log.algorithms;

import org.deckfour.xes.model.XLog;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.log.models.LogCentrality;
import org.processmining.log.parameters.LogCentralityFilterParameters;

public class LogCentralityFilterAlgorithm {

	public XLog apply(PluginContext context, LogCentrality centrality, LogCentralityFilterParameters parameters) {
		context.getProgress().setMaximum(centrality.size());
		return centrality.filter(context, parameters);
	}
}
"
LogCentralityVisualizerAlgorithm.java,log,"package org.processmining.log.algorithms;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;

import javax.swing.BorderFactory;
import javax.swing.Box;
import javax.swing.BoxLayout;
import javax.swing.JComponent;
import javax.swing.JLabel;
import javax.swing.JPanel;

import org.processmining.log.models.LogCentrality;
import org.processmining.log.parameters.LogCentralityFilterParameters;

import com.fluxicon.slickerbox.components.DistributionUI;
import com.fluxicon.slickerbox.components.RoundedPanel;

public class LogCentralityVisualizerAlgorithm {

	protected Color colorEnclosureBg = new Color(250, 250, 250, 105);
	protected Color colorTitleFg = new Color(20, 20, 20, 230);
	protected Color colorInfoBg = new Color(60, 60, 60, 160);
	protected Color colorInfoBgMouseOver = new Color(60, 60, 60, 240);
	protected Color colorInfoLabel = new Color(210, 210, 210);
	protected Color colorInfoValue = new Color(255, 255, 255);

	private int factor = 100;

	public JComponent apply(LogCentrality centrality, LogCentralityFilterParameters parameters) {
		double sumCentrality = 0.0;
		int j = ((parameters == null) ? centrality.getCentralities().size() : (parameters.getPercentage() * centrality
				.getCentralities().size()) / 100);
		if (j >= centrality.getCentralities().size()) {
			j = centrality.getCentralities().size() - 1;
		}
		while ((j < centrality.getCentralities().size() - 1)
				&& (centrality.getCentralities().get(j) == centrality.getCentralities().get(j + 1))) {
			j++;
		}
		int left, right;
		if (parameters == null || parameters.isFilterIn()) {
			left = 0;
			right = j;
		} else {
			left = j + 1;
			right = centrality.getCentralities().size() - 1;
			if (left > right) {
				left = right;
			}
		}
		int minCentrality = (int) Math.round(factor * centrality.getCentralities().get(left));
		int maxCentrality = (int) Math.round(factor * centrality.getCentralities().get(right));
		int[] centralityArray = new int[right + 1 - left];
		for (int k = left; k <= right; k++) {
			Double value = centrality.getCentralities().get(k);
			centralityArray[k - left] = (int) Math.round(factor * value);
			sumCentrality += value;
		}
		int meanCentrality = (int) Math.round(factor * sumCentrality / (right + 1 - left));
		JComponent[] components = new JComponent[4];
		JComponent panel = getDistributionPanel(""Trace happiness"", centralityArray, meanCentrality, components);
		((JLabel) components[0]).setText("""" + minCentrality / (double) factor);
		((JLabel) components[1]).setText("""" + meanCentrality / (double) factor);
		((JLabel) components[2]).setText("""" + maxCentrality / (double) factor);
		return panel;
	}

	private RoundedPanel getDistributionPanel(String title, int[] values, int meanValue, JComponent[] result) {

		// create distribution panel
		RoundedPanel instancePanel = new RoundedPanel(15, 0, 0);
		instancePanel.setBackground(colorEnclosureBg);
		instancePanel.setLayout(new BoxLayout(instancePanel, BoxLayout.Y_AXIS));
		instancePanel.add(getLeftAlignedHeader(title));
		instancePanel.add(Box.createVerticalStrut(6));
		if (values.length == 0) {
			return instancePanel;
		}
		RoundedPanel instanceDistPanel = new RoundedPanel(10, 0, 0);
		result[3] = instanceDistPanel;
		instanceDistPanel.setBackground(new Color(20, 20, 20));
		instanceDistPanel.setLayout(new BorderLayout());
		DistributionUI instanceDistUI = new DistributionUI(values);
		instanceDistPanel.add(instanceDistUI, BorderLayout.CENTER);
		JPanel keyPanel = new JPanel();
		keyPanel.setOpaque(false);
		keyPanel.setBorder(BorderFactory.createEmptyBorder());
		keyPanel.setLayout(new BoxLayout(keyPanel, BoxLayout.X_AXIS));
		result[0] = packInfo(keyPanel, ""Min"");
		keyPanel.add(Box.createHorizontalGlue());
		keyPanel.add(Box.createHorizontalGlue());
		keyPanel.add(Box.createHorizontalGlue());
		result[1] = packInfo(keyPanel, ""Mean"");
		keyPanel.add(Box.createHorizontalGlue());
		keyPanel.add(Box.createHorizontalGlue());
		keyPanel.add(Box.createHorizontalGlue());
		result[2] = packInfo(keyPanel, ""Max"");
		instancePanel.add(instanceDistPanel);
		instancePanel.add(Box.createVerticalStrut(4));
		instancePanel.add(keyPanel);
		return instancePanel;
	}

	private JLabel packInfo(JPanel panel, String name) {
		String value = ""Initializing ..."";

		RoundedPanel packed = new RoundedPanel(10, 0, 0);
		packed.setBackground(colorInfoBg);
		final RoundedPanel target = packed;
		packed.addMouseListener(new MouseListener() {
			public void mouseClicked(MouseEvent arg0) { /* ignore */
			}

			public void mouseEntered(MouseEvent arg0) {
				target.setBackground(colorInfoBgMouseOver);
				target.repaint();
			}

			public void mouseExited(MouseEvent arg0) {
				target.setBackground(colorInfoBg);
				target.repaint();
			}

			public void mousePressed(MouseEvent arg0) { /* ignore */
			}

			public void mouseReleased(MouseEvent arg0) { /* ignore */
			}
		});
		packed.setLayout(new BoxLayout(packed, BoxLayout.X_AXIS));
		JLabel nameLabel = new JLabel(name);
		nameLabel.setOpaque(false);
		nameLabel.setForeground(colorInfoLabel);
		nameLabel.setFont(nameLabel.getFont().deriveFont(12f));
		JLabel valueLabel = new JLabel(value);
		valueLabel.setOpaque(false);
		valueLabel.setForeground(colorInfoValue);
		valueLabel.setFont(valueLabel.getFont().deriveFont(14f));
		packed.add(Box.createHorizontalStrut(5));
		packed.add(nameLabel);
		packed.add(Box.createHorizontalGlue());
		packed.add(valueLabel);
		packed.add(Box.createHorizontalStrut(5));
		packed.revalidate();

		panel.add(packed);

		return valueLabel;
	}

	private JPanel getLeftAlignedHeader(String title) {
		JLabel hLabel = new JLabel(title);
		hLabel.setOpaque(false);
		hLabel.setForeground(colorTitleFg);
		hLabel.setFont(hLabel.getFont().deriveFont(15f));
		return alignLeft(hLabel);
	}

	private JPanel alignLeft(JComponent component) {
		JPanel hPanel = new JPanel();
		hPanel.setBorder(BorderFactory.createEmptyBorder());
		hPanel.setOpaque(false);
		hPanel.setLayout(new BoxLayout(hPanel, BoxLayout.X_AXIS));
		hPanel.add(component);
		hPanel.add(Box.createHorizontalGlue());
		return hPanel;
	}

}
"
LogCheckerAlgorithm.java,log,"package org.processmining.log.algorithms;

import org.deckfour.xes.model.XLog;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.log.logchecks.LogCheckType;
import org.processmining.log.models.LogCheckerReport;
import org.processmining.log.parameters.LogCheckerParameters;

public class LogCheckerAlgorithm {

	public LogCheckerReport apply(PluginContext context, final XLog log, final LogCheckerParameters parameters) {
		LogCheckerReport report = new LogCheckerReport();
		boolean allOk = true;
		for (LogCheckType logCheckType: parameters.getLogChecks()) {
			allOk = logCheckType.getLogCheck().check(context, log, report) && allOk;
		}
		if (allOk) {
			report.add(""<h2>No problems detected, congratulations!</h2>"");
		}
		return report;
	}
}
"
LogFilterAlgorithm.java,log,"package org.processmining.log.algorithms;

import org.deckfour.xes.model.XLog;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.log.parameters.LogFilterParameters;

public interface LogFilterAlgorithm {
	
	public XLog apply(PluginContext context, XLog log, LogFilterParameters parameters);

}
"
LogFrequencyAlgorithm.java,log,"package org.processmining.log.algorithms;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.log.models.LogFrequency;
import org.processmining.log.models.impl.LogFrequencyFactory;
import org.processmining.log.parameters.LogFrequencyParameters;

public class LogFrequencyAlgorithm {

	public LogFrequency apply(PluginContext context, XLog log, LogFrequencyParameters parameters) {
		LogFrequency frequency = LogFrequencyFactory.createLogFrequency(log);
		final Map<List<String>, Integer> traceOccurrenceMap = new HashMap<List<String>, Integer>();

		for (XTrace trace : log) {
			List<String> activities = new ArrayList<String>();
			for (XEvent event : trace) {
				activities.add(parameters.getClassifier().getClassIdentity(event));
			}
			if (traceOccurrenceMap.keySet().contains(activities)) {
				traceOccurrenceMap.put(activities, traceOccurrenceMap.get(activities) + 1);
			} else {
				traceOccurrenceMap.put(activities, 1);
			}
		}

		for (List<String> activities : traceOccurrenceMap.keySet()) {
			frequency.add(traceOccurrenceMap.get(activities));
		}
		return frequency;
	}
}
"
LogFrequencyArrayAlgorithm.java,log,"package org.processmining.log.algorithms;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XTrace;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.log.models.EventLogArray;
import org.processmining.log.models.LogFrequencyArray;
import org.processmining.log.models.impl.LogFrequencyFactory;
import org.processmining.log.parameters.LogFrequencyParameters;

public class LogFrequencyArrayAlgorithm {

	public LogFrequencyArray apply(PluginContext context, EventLogArray logs, LogFrequencyParameters parameters) {
		LogFrequencyArray frequencies = LogFrequencyFactory.createLogFrequencyArray(logs);
		for (int i = 0; i < logs.getSize(); i++) {
			frequencies.set(i);
			final Map<List<String>, Integer> traceOccurrenceMap = new HashMap<List<String>, Integer>();

			for (XTrace trace : logs.getLog(i)) {
				List<String> activities = new ArrayList<String>();
				for (XEvent event : trace) {
					activities.add(parameters.getClassifier().getClassIdentity(event));
				}
				if (traceOccurrenceMap.keySet().contains(activities)) {
					traceOccurrenceMap.put(activities, traceOccurrenceMap.get(activities) + 1);
				} else {
					traceOccurrenceMap.put(activities, 1);
				}
			}

			for (List<String> activities : traceOccurrenceMap.keySet()) {
				frequencies.add(traceOccurrenceMap.get(activities));
			}
		}
		return frequencies;
	}
}
"
LowFrequencyFilterAlgorithm.java,log,"package org.processmining.log.algorithms;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;

import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.log.parameters.LogFilterParameters;
import org.processmining.log.parameters.LowFrequencyFilterParameters;

public class LowFrequencyFilterAlgorithm implements LogFilterAlgorithm {

	public XLog apply(PluginContext context, XLog log, LogFilterParameters parameters) {
		final Map<List<String>, Integer> traceOccurrenceMap = new HashMap<List<String>, Integer>();
		final Map<XTrace, List<String>> traceActivitiesMap = new HashMap<XTrace, List<String>>();
		
		XLog clonedLog = (XLog) log.clone();
		
		for (XTrace trace : clonedLog) {
			List<String> activities = new ArrayList<String>();
			for (XEvent event : trace) {
				activities.add(parameters.getClassifier().getClassIdentity(event));
			}
			traceActivitiesMap.put(trace,  activities);
			if (traceOccurrenceMap.keySet().contains(activities)) {
				traceOccurrenceMap.put(activities, traceOccurrenceMap.get(activities) + 1);
			} else {
				traceOccurrenceMap.put(activities, 1);
			}
		}
		
		List<Integer> occurrences = new ArrayList<Integer>(traceOccurrenceMap.values());
		Collections.sort(occurrences);
		int threshold = (((LowFrequencyFilterParameters) parameters).getThreshold() * clonedLog.size()) / 100;
		int sum = 0;
		int index = -1;
		while (sum < threshold) {
			sum += occurrences.get(++index);
		}
		/*
		 * The low-frequency 'traces' (occurrences[0]...occurrences[index]) counted so far make up for X% of the log, 
		 * where X = parameters.getThreshold().
		 */
		threshold = (index == -1 ? 0 : occurrences.get(index)) + 1;
		/*
		 * If we take all traces that occur fewer than threshold times, we cover at least X% of the log.
		 */
		
		if (threshold == occurrences.get(occurrences.size() - 1) + 1) {
			/*
			 * We're about to remove all traces. That seems to be undesirable.
			 */
			threshold--;
		}
		
		Collection<XTrace> tracesToRemove = new HashSet<XTrace>();

		for (XTrace trace : clonedLog) {
			/*
			 * Trace does not occur often enough. Have it removed.
			 */
			if (traceOccurrenceMap.get(traceActivitiesMap.get(trace)) < threshold) {
				tracesToRemove.add(trace);
			}
		}
		
		/*
		 * tracesToRemove holds at least X% of the log.
		 */
		clonedLog.removeAll(tracesToRemove);
		
		return clonedLog;
	}

}
"
LowOccurrencesFilterAlgorithm.java,log,"package org.processmining.log.algorithms;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;

import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.log.parameters.LogFilterParameters;
import org.processmining.log.parameters.LowOccurrencesFilterParameters;

public class LowOccurrencesFilterAlgorithm implements LogFilterAlgorithm {

	public XLog apply(PluginContext context, XLog log, LogFilterParameters parameters) {
		final Map<List<String>, Integer> traceOccurrenceMap = new HashMap<List<String>, Integer>();
		final Map<XTrace, List<String>> traceActivitiesMap = new HashMap<XTrace, List<String>>();
		XLog clonedLog = (XLog) log.clone();

		for (XTrace trace : clonedLog) {
			List<String> activities = new ArrayList<String>();
			for (XEvent event : trace) {
				activities.add(parameters.getClassifier().getClassIdentity(event));
			}
			traceActivitiesMap.put(trace, activities);
			if (traceOccurrenceMap.keySet().contains(activities)) {
				traceOccurrenceMap.put(activities, traceOccurrenceMap.get(activities) + 1);
			} else {
				traceOccurrenceMap.put(activities, 1);
			}
		}

		Collection<XTrace> tracesToRemove = new HashSet<XTrace>();

		for (XTrace trace : clonedLog) {
			if (traceOccurrenceMap.get(traceActivitiesMap.get(trace)) < ((LowOccurrencesFilterParameters) parameters).getThreshold()) {
				/*
				 * Trace does not occur often enough. Have it removed.
				 */
				tracesToRemove.add(trace);
			}
		}

		clonedLog.removeAll(tracesToRemove);

		return clonedLog;
	}

}
"
MergeLogsAlgorithm.java,log,"package org.processmining.log.algorithms;

import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
import java.util.concurrent.TimeUnit;

import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.extension.std.XTimeExtension;
import org.deckfour.xes.factory.XFactoryRegistry;
import org.deckfour.xes.model.XAttribute;
import org.deckfour.xes.model.XAttributeContinuous;
import org.deckfour.xes.model.XAttributeDiscrete;
import org.deckfour.xes.model.XAttributeLiteral;
import org.deckfour.xes.model.XAttributeTimestamp;
import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.log.parameters.MergeLogsParameters;

public class MergeLogsAlgorithm {

	private final String STOPWORDS = ""a about above above across after afterwards again against ""
			+ ""all almost alone along already also although always am among amongst amoungst ""
			+ ""amount an and another any anyhow anyone anything anyway anywhere are around as at ""
			+ ""back be became because become becomes becoming been before beforehand behind being ""
			+ ""below beside besides between beyond bill both bottom but by call can cannot cant co ""
			+ ""con could couldnt cry de describe detail do done down due during each eg eight either ""
			+ ""eleven else elsewhere empty enough etc even ever every everyone everything everywhere ""
			+ ""except few fifteen fify fill find fire first five for former formerly forty found four ""
			+ ""from front full further get give go had has hasnt have he hence her here hereafter hereby ""
			+ ""herein hereupon hers herself him himself his how however hundred ie if in inc indeed ""
			+ ""interest into is it its itself keep last latter latterly least less ltd made many may me ""
			+ ""meanwhile might mill mine more moreover most mostly move much must my myself name namely ""
			+ ""neither never nevertheless next nine no nobody none noone nor not nothing now nowhere of off ""
			+ ""often on once one only onto or other others otherwise our ours ourselves out over own part ""
			+ ""per perhaps please put rather re same see seem seemed seeming seems serious several she should ""
			+ ""show side since sincere six sixty so some somehow someone something sometime sometimes ""
			+ ""somewhere still such system take ten than that the their them themselves then thence there ""
			+ ""thereafter thereby therefore therein thereupon these they thickv thin third this those though ""
			+ ""three through throughout thru thus to together too top toward towards twelve twenty two un ""
			+ ""under until up upon us very via was we well were what whatever when whence whenever where ""
			+ ""whereafter whereas whereby wherein whereupon wherever whether which while whither who whoever ""
			+ ""whole whom whose why will with within without would yet you your yours yourself yourselves the"";

	public XLog apply(PluginContext context, XLog mainLog, XLog subLog, MergeLogsParameters parameters) {
		XLog log = XFactoryRegistry.instance().currentDefault().createLog();
		DateFormat df = new SimpleDateFormat(parameters.getDateFormat());

		long time = -System.currentTimeMillis();

		for (XTrace mainTrace : mainLog) {
			boolean doApply = true;
			if (doApply && parameters.getTraceId() != null) {
				/*
				 * User has selected specific main trace. Filter in only the
				 * trace that has that id as concept:name.
				 */
				String id = XConceptExtension.instance().extractName(mainTrace);
				doApply = (id != null && id.equals(parameters.getTraceId()));
			}
			if (doApply && parameters.getFromDate() != null && parameters.getToDate() != null) {
				/*
				 * User has selected from date and to date. Filter in only those
				 * traces that occur entirely in that interval.
				 */
				doApply = isBetween(mainTrace, parameters.getFromDate(), parameters.getToDate());
			}
			if (doApply && parameters.getSpecificDate() != null) {
				/*
				 * User has selected a specific date. Only filter in those
				 * traces that have this exact date.
				 */
				doApply = false;
				for (XEvent event : mainTrace) {
					Date date = XTimeExtension.instance().extractTimestamp(event);
					if (date.equals(parameters.getSpecificDate())) {
						doApply = true;
						continue;
					}
				}
			}
			if (doApply && parameters.getRequiredWords() != null) {
				/*
				 * User has selected required words. Filter in those traces that
				 * match one of these words.
				 */
				doApply = false;
				Collection<String> required = new HashSet<String>(
						Arrays.asList(parameters.getRequiredWords().split("","")));
				for (XEvent event : mainTrace) {
					for (XAttribute attribute : event.getAttributes().values()) {
						if (attribute instanceof XAttributeLiteral) {
							String value = ((XAttributeLiteral) attribute).getValue();
							if (required.contains(value)) {
								doApply = true;
								continue;
							}
						} else if (attribute instanceof XAttributeDiscrete) {
							long value = ((XAttributeDiscrete) attribute).getValue();
							if (required.contains(String.valueOf(value))) {
								doApply = true;
								continue;
							}
						} else if (attribute instanceof XAttributeContinuous) {
							double value = ((XAttributeContinuous) attribute).getValue();
							if (required.contains(String.valueOf(value))) {
								doApply = true;
								continue;
							}
						} else if (attribute instanceof XAttributeTimestamp) {
							Date value = ((XAttributeTimestamp) attribute).getValue();
							if (required.contains(df.format(value))) {
								doApply = true;
								continue;
							}
						}
					}
					if (doApply) {
						continue;
					}
				}
			}
			if (doApply && parameters.getForbiddenWords() != null) {
				/*
				 * User has selected forbidden words. Filter out those traces
				 * that match one of these words.
				 */
				doApply = true;
				Collection<String> forbidden = new HashSet<String>(
						Arrays.asList(parameters.getForbiddenWords().split("","")));
				for (XEvent event : mainTrace) {
					for (XAttribute attribute : event.getAttributes().values()) {
						if (attribute instanceof XAttributeLiteral) {
							String value = ((XAttributeLiteral) attribute).getValue();
							if (forbidden.contains(value)) {
								doApply = false;
								continue;
							}
						} else if (attribute instanceof XAttributeDiscrete) {
							long value = ((XAttributeDiscrete) attribute).getValue();
							if (forbidden.contains(String.valueOf(value))) {
								doApply = false;
								continue;
							}
						} else if (attribute instanceof XAttributeContinuous) {
							double value = ((XAttributeContinuous) attribute).getValue();
							if (forbidden.contains(String.valueOf(value))) {
								doApply = false;
								continue;
							}
						} else if (attribute instanceof XAttributeTimestamp) {
							Date value = ((XAttributeTimestamp) attribute).getValue();
							if (forbidden.contains(df.format(value))) {
								doApply = false;
								continue;
							}
						}
					}
					if (!doApply) {
						continue;
					}
				}
			}
			if (doApply) {
				/*
				 * Main trace has passed all filters. Add it with all
				 * corresponding sub traces to the resulting log.
				 */
				apply(context, mainTrace, mainLog, subLog, log, parameters);
			}
		}

		time += System.currentTimeMillis();
		context.log(""Merging time :"" + convet_MS(time));
		return log;
	}

	private void apply(PluginContext context, XTrace mainTrace, XLog mainLog, XLog subLog, XLog log,
			MergeLogsParameters parameters) {
		for (XTrace subTrace : subLog) {
			if (isBetween(mainTrace, subTrace)) {
				boolean doApply = true;
				if (doApply && (checkMatch(mainTrace, subTrace) < parameters.getRelated())) {
					doApply = false;
				}
				if (doApply && (checkWordMatch(mainTrace, subTrace) < parameters.getMinMatches())) {
					doApply = false;
				}
				if (doApply) {
					XTrace trace = XFactoryRegistry.instance().currentDefault().createTrace(mainTrace.getAttributes());
					int mainCtr = 0;
					int subCtr = 0;
					while (mainCtr < mainTrace.size() && subCtr < subTrace.size()) {
						Date mainDate = XTimeExtension.instance().extractTimestamp(mainTrace.get(mainCtr));
						if (mainDate == null) {
							trace.add(mainTrace.get(mainCtr));
							mainCtr++;
						} else {
							Date subDate = XTimeExtension.instance().extractTimestamp(subTrace.get(subCtr));
							if (subDate == null) {
								trace.add(subTrace.get(subCtr));
								subCtr++;
							} else if (subDate.before(mainDate)) {
								trace.add(subTrace.get(subCtr));
								subCtr++;
							} else {
								trace.add(mainTrace.get(mainCtr));
								mainCtr++;
							}
						}
					}
					log.add(trace);
				}
			}
		}
	}

	private XTrace previousMainTrace = null;
	private Collection<String> mainWords = null;
	private Collection<String> stopWords = null;

	private int checkWordMatch(XTrace mainTrace, XTrace subTrace) {
		/*
		 * Build the stop words.
		 */
		if (stopWords == null) {
			stopWords = new HashSet<String>();
			stopWords.addAll(Arrays.asList(STOPWORDS.split("" "")));
		}
		/*
		 * Build (or reuse) the main words.
		 */
		if (mainTrace != previousMainTrace) {
			mainWords = new HashSet<String>();
			for (XEvent event : mainTrace) {
				for (XAttribute attribute : event.getAttributes().values()) {
					/*
					 * Exclude date/time from comparision.
					 */
					if (!(attribute instanceof XAttributeTimestamp)) {
						mainWords.addAll(Arrays.asList(attribute.toString().split("" "")));
					}
				}
			}
			mainWords.removeAll(stopWords);
			previousMainTrace = mainTrace;			
		}
		/*
		 * Build the sub words.
		 */
		Collection<String> subWords = new HashSet<String>();
		for (XEvent event : subTrace) {
			for (XAttribute attribute : event.getAttributes().values()) {
				/*
				 * Exclude date/time from comparision.
				 */
				if (!(attribute instanceof XAttributeTimestamp)) {
					subWords.addAll(Arrays.asList(attribute.toString().split("" "")));
				}
			}
		}
		subWords.removeAll(stopWords);
		/*
		 * Remove all words not in the main words.
		 */
		subWords.retainAll(mainWords);
		/*
		 * Return number of matching words.
		 */
		return subWords.size();
	}

	private int checkMatch(XTrace mainTrace, XTrace subTrace) {
		int match = 0;
		for (XEvent mainEvent : mainTrace) {
			for (XEvent subEvent : mainTrace) {
				match += checkMatch(mainEvent, subEvent);
			}
		}
		return match;
	}

	private int checkMatch(XEvent mainEvent, XEvent subEvent) {
		int match = 0;
		for (XAttribute mainAttribute : mainEvent.getAttributes().values()) {
			if (!(mainAttribute instanceof XAttributeTimestamp)) {
				for (XAttribute subAttribute : subEvent.getAttributes().values()) {
					if (mainAttribute.equals(subAttribute)) {
						match++;
					}
				}
			}
		}
		return match;
	}

	private boolean isBetween(XTrace trace, Date firstDate, Date lastDate) {
		Date firstTraceDate = getFirstDate(trace);
		if (firstTraceDate == null) {
			return false;
		}
		/*
		 * Update on June 6, 2016: the subtrace should start after the main trace
		 * has started, but not after it has started. 
		 * There is no requirement on when the subtrace ends.
		 */
		return (firstTraceDate.after(firstDate) && !firstTraceDate.after(lastDate));
	}

	private boolean isBetween(XTrace mainTrace, XTrace subTrace) {
		Date firstTraceDate = getFirstDate(mainTrace);
		Date lastTraceDate = getLastDate(mainTrace);
		if (firstTraceDate == null || lastTraceDate == null) {
			return false;
		}
		return isBetween(subTrace, firstTraceDate, lastTraceDate);
	}

	private Date getFirstDate(XTrace trace) {
		Date firstDate = null;
		for (XEvent event : trace) {
			Date date = XTimeExtension.instance().extractTimestamp(event);
			if (firstDate == null) {
				firstDate = date;
			} else if (date.before(firstDate)) {
				firstDate = date;
			}
		}
		return firstDate;
	}

	private Date getLastDate(XTrace trace) {
		Date lastDate = null;
		for (XEvent event : trace) {
			Date date = XTimeExtension.instance().extractTimestamp(event);
			if (lastDate == null) {
				lastDate = date;
			} else if (date.after(lastDate)) {
				lastDate = date;
			}
		}
		return lastDate;
	}

	private String convet_MS(long millis) {

		return String.format(""%d min, %d sec %d ms"", TimeUnit.MILLISECONDS.toMinutes(millis),
				TimeUnit.MILLISECONDS.toSeconds(millis)
						- TimeUnit.MINUTES.toSeconds(TimeUnit.MILLISECONDS.toMinutes(millis)),
				millis - TimeUnit.SECONDS.toMillis(TimeUnit.MILLISECONDS.toSeconds(millis)));
	}

}
"
SplitLogAlgorithm.java,log,"package org.processmining.log.algorithms;

import java.util.Arrays;
import java.util.Set;
import java.util.TreeSet;

import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.factory.XFactory;
import org.deckfour.xes.factory.XFactoryRegistry;
import org.deckfour.xes.model.XAttribute;
import org.deckfour.xes.model.XAttributeLiteral;
import org.deckfour.xes.model.XAttributeMap;
import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.log.parameters.SplitLogParameters;

public class SplitLogAlgorithm {

	public XLog apply(PluginContext context, XLog log, SplitLogParameters parameters) {

		XFactory factory = XFactoryRegistry.instance().currentDefault();

		XLog splittedLog = factory.createLog(log.getAttributes());
		splittedLog.getExtensions().addAll(log.getExtensions());
		splittedLog.getGlobalTraceAttributes().addAll(log.getGlobalTraceAttributes());
		splittedLog.getGlobalEventAttributes().addAll(log.getGlobalEventAttributes());
		splittedLog.getClassifiers().addAll(log.getClassifiers());

		for (XTrace trace : log) {
			Set<String> splitValues = new TreeSet<String>();
			for (XEvent event : trace) {
				if (event.getAttributes().containsKey(parameters.getKey())) {
					String value = event.getAttributes().get(parameters.getKey()).toString();
					if (value != null && !value.trim().isEmpty()) {
						splitValues.addAll(Arrays.asList(value.trim().split("" "")));
					}
				}
			}
			int ctr = 1;

			for (String splitValue : splitValues) {
				XTrace splittedTrace = factory.createTrace((XAttributeMap) trace.getAttributes().clone());
				XAttributeLiteral attr = factory.createAttributeLiteral(""oldname"",
						XConceptExtension.instance().extractName(trace), null);
				splittedTrace.getAttributes().put(""oldname"", attr);
				XConceptExtension.instance().assignName(splittedTrace,
						XConceptExtension.instance().extractName(trace) + ""-"" + ctr);
				ctr++;
				for (XEvent event : trace) {
					XAttribute attribute = event.getAttributes().get(parameters.getKey());
					String value = attribute == null ? null : attribute.toString();
					if (value == null || value.trim().isEmpty()
							|| Arrays.asList(value.trim().split("" "")).contains(splitValue)) {
						XEvent splittedEvent = factory.createEvent((XAttributeMap) event.getAttributes().clone());
						attr = factory.createAttributeLiteral(parameters.getKey(), splitValue, null);
						splittedEvent.getAttributes().put(parameters.getKey(), attr);
						splittedTrace.add(splittedEvent);
					}
				}
				splittedLog.add(splittedTrace);
			}
		}
		return splittedLog;
	}

	/*
	 * private CSVReader reader;
	 * 
	 * public ArrayList<ArrayList<String>> read(String file, final int index) {
	 * try {
	 * 
	 * reader = new CSVReader(new FileReader(file));
	 * 
	 * String[] nextLine; ArrayList<String> bucket = new ArrayList<String>();
	 * ArrayList<ArrayList<String>> container = new
	 * ArrayList<ArrayList<String>>(); ArrayList<ArrayList<ArrayList<String>>>
	 * super_container = new ArrayList<ArrayList<ArrayList<String>>>(); int
	 * counter = 0; String CaseID = null; while ((nextLine = reader.readNext())
	 * != null) { if (counter == 0) { CaseID = nextLine[0]; } String[] splitted
	 * = nextLine[index].trim().split("" ""); for (int i = 0; i < splitted.length;
	 * i++) { bucket = new ArrayList<String>(); bucket.add(nextLine[0]); if
	 * (!CaseID.equals(nextLine[0])) { super_container.add(container); container
	 * = new ArrayList<ArrayList<String>>(); counter = 0; } else { counter = 1;
	 * } for (int j = 0; j < index; j++) { bucket.add(nextLine[j]); }
	 * bucket.add(splitted[i]); if (index < nextLine.length - 1) { for (int j =
	 * index + 1; j < nextLine.length; j++) { bucket.add(nextLine[j]); } }
	 * container.add(bucket); }
	 * 
	 * } super_container.add(container); for (int i = 0; i <
	 * super_container.size(); i++) { Collections.sort(super_container.get(i),
	 * new Comparator<ArrayList<String>>() {
	 * 
	 * @Override public int compare(ArrayList<String> a, ArrayList<String> b) {
	 * // TODO Auto-generated method stub return a.get(index +
	 * 1).compareTo(b.get(index + 1)); } }); }
	 * 
	 * container = new ArrayList<ArrayList<String>>(); for (int i = 0; i <
	 * super_container.size(); i++) { int counter2 = 1; for (int j = 0; j <
	 * super_container.get(i).size(); j++) {
	 * 
	 * if (j + 1 < super_container.get(i).size() &&
	 * super_container.get(i).get(j).get(index + 1)
	 * .equals(super_container.get(i).get(j + 1).get(index + 1))) {
	 * super_container.get(i).get(j).set(0, super_container.get(i).get(j).get(0)
	 * + ""-"" + counter2); } else { if (j - 1 >= 0 &&
	 * super_container.get(i).get(j).get(index + 1)
	 * .equals(super_container.get(i).get(j - 1).get(index + 1))) {
	 * super_container.get(i).get(j).set(0, super_container.get(i).get(j).get(0)
	 * + ""-"" + counter2); counter2++; } else {
	 * super_container.get(i).get(j).set(0, super_container.get(i).get(j).get(0)
	 * + ""-"" + counter2); } }
	 * 
	 * }
	 * 
	 * } for (int i = 0; i < super_container.size(); i++) { for (int j = 0; j <
	 * super_container.get(i).size(); j++) {
	 * container.add(super_container.get(i).get(j)); } } return container;
	 * 
	 * } catch (FileNotFoundException e) {
	 * 
	 * } catch (IOException e) {
	 * 
	 * } return null; }
	 * 
	 * public void write(ArrayList<ArrayList<String>> sorted) { try { CSVWriter
	 * writer = new CSVWriter(new FileWriter(""./SplitFile.csv""), ',',
	 * CSVWriter.NO_QUOTE_CHARACTER);
	 * 
	 * for (int i = 0; i < sorted.size(); i++) { String[] entries = new
	 * String[sorted.get(i).size()]; for (int j = 0; j < sorted.get(i).size();
	 * j++) { entries[j] = sorted.get(i).get(j); } writer.writeNext(entries);
	 * 
	 * } System.out.println(""Written to the File Successfully""); writer.close();
	 * } catch (IOException e) { System.out.println(""File Name is Already There""
	 * ); } }
	 */
}
"
HighFrequencyFilterConnection.java,log,"package org.processmining.log.connections;

import org.deckfour.xes.model.XLog;
import org.processmining.framework.connections.impl.AbstractConnection;
import org.processmining.log.parameters.HighFrequencyFilterParameters;

public class HighFrequencyFilterConnection extends AbstractConnection {

	public final static String LOG = ""Log"";
	public final static String FILTEREDLOG = ""Filtered log"";

	private HighFrequencyFilterParameters parameters;

	public HighFrequencyFilterConnection(XLog log, XLog filteredLog,
			HighFrequencyFilterParameters parameters) {
		super(""High Frequency Filter Connection"");
		put(LOG, log);
		put(FILTEREDLOG, filteredLog);
		this.parameters = new HighFrequencyFilterParameters(parameters);
	}

	public HighFrequencyFilterParameters getParameters() {
		return parameters;
	}
}
"
LogCentralityConnection.java,log,"package org.processmining.log.connections;

import org.deckfour.xes.model.XLog;
import org.processmining.framework.connections.impl.AbstractConnection;
import org.processmining.log.models.LogCentrality;
import org.processmining.log.parameters.LogCentralityParameters;

public class LogCentralityConnection extends AbstractConnection {

	public final static String LOG = ""Log"";
	public final static String LOGCENTRALITY = ""Log Centrality"";

	private LogCentralityParameters parameters;

	public LogCentralityConnection(XLog log, LogCentrality logCentrality,
			LogCentralityParameters parameters) {
		super(""Log Centrality Connection"");
		put(LOG, log);
		put(LOGCENTRALITY, logCentrality);
		this.parameters = new LogCentralityParameters(parameters);
	}

	public LogCentralityParameters getParameters() {
		return parameters;
	}
}"
LogCentralityFilterConnection.java,log,"package org.processmining.log.connections;

import org.deckfour.xes.model.XLog;
import org.processmining.framework.connections.impl.AbstractConnection;
import org.processmining.log.models.LogCentrality;
import org.processmining.log.parameters.LogCentralityFilterParameters;

public class LogCentralityFilterConnection  extends AbstractConnection {

	public final static String LOG = ""Log"";
	public final static String LOGCENTRALITY = ""Log Centrality"";

	private LogCentralityFilterParameters parameters;

	public LogCentralityFilterConnection(XLog log, LogCentrality logCentrality,
			LogCentralityFilterParameters parameters) {
		super(""Log Centrality Filter Connection"");
		put(LOG, log);
		put(LOGCENTRALITY, logCentrality);
		this.parameters = new LogCentralityFilterParameters(parameters);
	}

	public LogCentralityFilterParameters getParameters() {
		return parameters;
	}
}"
LogFrequencyConnection.java,log,"package org.processmining.log.connections;

import org.deckfour.xes.model.XLog;
import org.processmining.framework.connections.impl.AbstractConnection;
import org.processmining.log.models.LogFrequency;
import org.processmining.log.parameters.LogFrequencyParameters;

public class LogFrequencyConnection extends AbstractConnection {

	public final static String LOG = ""Log"";
	public final static String LOGFREQUENCY = ""Log Frequency"";

	private LogFrequencyParameters parameters;

	public LogFrequencyConnection(XLog log, LogFrequency logFrequency,
			LogFrequencyParameters parameters) {
		super(""Log Frequency Connection"");
		put(LOG, log);
		put(LOGFREQUENCY, logFrequency);
		this.parameters = new LogFrequencyParameters(parameters);
	}

	public LogFrequencyParameters getParameters() {
		return parameters;
	}
}"
LowFrequencyFilterConnection.java,log,"package org.processmining.log.connections;

import org.deckfour.xes.model.XLog;
import org.processmining.framework.connections.impl.AbstractConnection;
import org.processmining.log.parameters.LowFrequencyFilterParameters;

public class LowFrequencyFilterConnection extends AbstractConnection {

	public final static String LOG = ""Log"";
	public final static String FILTEREDLOG = ""Filtered log"";

	private LowFrequencyFilterParameters parameters;

	public LowFrequencyFilterConnection(XLog log, XLog filteredLog,
			LowFrequencyFilterParameters parameters) {
		super(""Low Frequency Filter Connection"");
		put(LOG, log);
		put(FILTEREDLOG, filteredLog);
		this.parameters = new LowFrequencyFilterParameters(parameters);
	}

	public LowFrequencyFilterParameters getParameters() {
		return parameters;
	}
}
"
LowOccurrencesFilterConnection.java,log,"package org.processmining.log.connections;

import org.deckfour.xes.model.XLog;
import org.processmining.framework.connections.impl.AbstractConnection;
import org.processmining.log.parameters.LowOccurrencesFilterParameters;

public class LowOccurrencesFilterConnection extends AbstractConnection {

	public final static String LOG = ""Log"";
	public final static String FILTEREDLOG = ""Filtered log"";

	private LowOccurrencesFilterParameters parameters;

	public LowOccurrencesFilterConnection(XLog log, XLog filteredLog,
			 LowOccurrencesFilterParameters parameters) {
		super(""Low Occurrences Filter Connection"");
		put(LOG, log);
		put(FILTEREDLOG, filteredLog);
		this.parameters = new LowOccurrencesFilterParameters(parameters);
	}

	public  LowOccurrencesFilterParameters getParameters() {
		return parameters;
	}
}
"
AbstractCSVFile.java,log,"package org.processmining.log.csv;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.nio.file.Path;
import java.util.zip.GZIPInputStream;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;

import com.google.common.io.Files;

public abstract class AbstractCSVFile implements CSVFile {

	private final Path file;

	public AbstractCSVFile(Path file) {
		this.file = file;	
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see org.processmining.log.csvimport.ICSVFile#getFile()
	 */
	@Override
	public Path getFile() {
		return file;
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see org.processmining.log.csvimport.ICSVFile#getFilename()
	 */
	@Override
	public String getFilename() {
		return file.getFileName().toString();
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see org.processmining.log.csv.CSVFile#getInputStream()
	 */
	@Override
	public InputStream getInputStream() throws IOException {
		String ext = Files.getFileExtension(getFile().toFile().getName());
		if (ext.equalsIgnoreCase(""csv"") || ext.equalsIgnoreCase(""txt"")) {
			return new FileInputStream(getFile().toFile());
		} else if (ext.equalsIgnoreCase(""zip"")) {
			ZipInputStream zipInputStream = new ZipInputStream(new FileInputStream(getFile().toFile()));
			ZipEntry nextEntry = zipInputStream.getNextEntry();
			if (nextEntry == null) {
				throw new IOException(""ZIP files does not contain any files"");
			}
			return zipInputStream;
		} else if (ext.equalsIgnoreCase(""gz"")) {
			return new GZIPInputStream(new FileInputStream(getFile().toFile()));
		}
		throw new UnsupportedOperationException(""Unsupported file type "" + ext);
	}

}
"
CSVConfig.java,log,"package org.processmining.log.csv.config;

import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStreamReader;
import java.nio.charset.Charset;
import java.util.HashMap;
import java.util.Map;

import org.apache.commons.lang3.StringUtils;
import org.mozilla.universalchardet.UniversalDetector;
import org.processmining.log.csv.CSVFile;
import org.processmining.log.csvimport.exception.CSVConversionException;

/**
 * Configuration for the import of the CSV
 * 
 * @author F. Mannhardt
 *
 */
public final class CSVConfig {
	
	private static final int SEPARATOR_DETECTION_ROW_LIMIT = 10;
	
	private String charset = Charset.defaultCharset().name();
	private CSVSeperator separator = CSVSeperator.COMMA;
	private CSVQuoteCharacter quoteChar = CSVQuoteCharacter.DOUBLE_QUOTE;
	private CSVEscapeCharacter escapeChar = CSVEscapeCharacter.QUOTE;
	
	public CSVConfig() {
	}
	
	public CSVConfig(final CSVFile csvFile) throws CSVConversionException {
		try {
			charset = autoDetectCharset(csvFile);
			separator = autoDetectSeparator(csvFile, charset);
			quoteChar = autoDetectQuote(csvFile, charset);
		} catch (IOException e) {
			throw new CSVConversionException(""Could not auto-detect CSV import parameters."", e);
		}
	}
	
	private static String autoDetectCharset(final CSVFile csvFile) throws FileNotFoundException, IOException {

		final UniversalDetector detector = new UniversalDetector(null);
		
		try (FileInputStream fis = new FileInputStream(csvFile.getFile().toFile())) {
			byte[] buf = new byte[4096];
			int nread;
			while ((nread = fis.read(buf)) > 0 && !detector.isDone()) {
				detector.handleData(buf, 0, nread);
			}
			detector.dataEnd();
		}
		
		if (detector.getDetectedCharset() != null) {
			return detector.getDetectedCharset();
		} else {
			// Nothing detected, assume OS default
			return Charset.defaultCharset().name();
		}
	}

	private static CSVSeperator autoDetectSeparator(final CSVFile csvFile, String charset) throws FileNotFoundException, IOException {
		try (BufferedReader reader = new BufferedReader(new InputStreamReader(new FileInputStream(csvFile.getFile().toFile()), Charset.forName(charset)))) {
			Map<CSVSeperator, Integer> counter = new HashMap<>();
			for (int i = 0; i < SEPARATOR_DETECTION_ROW_LIMIT; i++) {
				String line = reader.readLine();
				if (line == null) {
					break;
				}
				updateCounter(counter, CSVSeperator.COMMA, "","", line);
				updateCounter(counter, CSVSeperator.TAB, ""\t"", line);
				updateCounter(counter, CSVSeperator.SEMICOLON, "";"", line);
			}
			// now check which are still fine
			for (CSVSeperator seperator : counter.keySet()) {
				if (counter.get(seperator) > 1) {
					return seperator;
				}
			}
			// if none of them was properly detected go with inconsistent ones
			for (CSVSeperator seperator : counter.keySet()) {
				if (counter.get(seperator) == -1) {
					return seperator;
				}
			}
		}
		
		// Fall back to default
		return CSVSeperator.COMMA;
	}

	private static void updateCounter(Map<CSVSeperator, Integer> counter, CSVSeperator separator, String token,
			String line) {
		// Remove all text in between quotes as it should be ignored for separator detection 
		String lineWithoutQuotes = removeTextInQuotes(line);
		int matchCount = StringUtils.countMatches(lineWithoutQuotes, token);
		if (counter.get(separator) == null) {
			counter.put(separator, matchCount);
		} else if (counter.get(separator) != matchCount) {
			// Inconsistent number of separator characters
			counter.put(separator, -1);
		}
	}

	private static String removeTextInQuotes(String line) {
		String internalLine = line;
		while (internalLine.contains(""\"""")) {
			int startIndex = internalLine.indexOf(""\"""");
			int endIndex = internalLine.substring(startIndex + 1, internalLine.length()).indexOf(""\"""");
			// now remove the in between part of the string and replace it with some placeholder text
			internalLine = internalLine.substring(0, startIndex) + ""placeholder""
					+ internalLine.substring(startIndex + 1 + endIndex + 1, internalLine.length());
		}
		return internalLine;
	}

	private static CSVQuoteCharacter autoDetectQuote(CSVFile csvFile, String charset) {
		//TODO implement
		return CSVQuoteCharacter.DOUBLE_QUOTE;
	}

	public String getCharset() {
		return charset;
	}

	public void setCharset(String charset) {
		this.charset = charset;
	}

	public CSVSeperator getSeparator() {
		return separator;
	}

	public void setSeparator(CSVSeperator separator) {
		this.separator = separator;
	}

	public CSVQuoteCharacter getQuoteChar() {
		return quoteChar;
	}

	public void setQuoteChar(CSVQuoteCharacter quoteChar) {
		this.quoteChar = quoteChar;
	}

	public CSVEscapeCharacter getEscapeChar() {
		return escapeChar;
	}

	public void setEscapeChar(CSVEscapeCharacter escapeChar) {
		this.escapeChar = escapeChar;
	}
	
}"
CSVEscapeCharacter.java,log,"package org.processmining.log.csv.config;

public enum CSVEscapeCharacter {
	
	QUOTE(""QUOTE (\"")"", '""');
	
	private final String description;
	private final char escapeChar;

	private CSVEscapeCharacter(String description, char escapeCharacter) {
		this.description = description;
		this.escapeChar = escapeCharacter;
	}

	public String toString() {
		return description;
	}

	public char getEscapeChar() {
		return escapeChar;
	}

}
"
CSVQuoteCharacter.java,log,"package org.processmining.log.csv.config;


public enum CSVQuoteCharacter {
	
	SINGLE_QUOTE(""QUOTE (')"", '\''),
	DOUBLE_QUOTE(""DOUBLE QUOTE (\"")"", '""'), 
	NONE(""NONE"", '\0');

	private final String description;
	private final char quoteChar;

	private CSVQuoteCharacter(String description, char quoteCharacter) {
		this.description = description;
		this.quoteChar = quoteCharacter;
	}

	public String toString() {
		return description;
	}

	public char getQuoteChar() {
		return quoteChar;
	}

}
"
CSVSeperator.java,log,"package org.processmining.log.csv.config;


public enum CSVSeperator {
	COMMA(""Comma (,)"", ','), 
	SEMICOLON(""Semicolon (;)"",';'),
	TAB(""Tab"", '\t'),
	WHITESPACE(""Whitespace"",' ');

	private final String description;
	private final char seperatorChar;

	private CSVSeperator(String description, char seperatorChar) {
		this.description = description;
		this.seperatorChar = seperatorChar;
	}

	public String toString() {
		return description;
	}

	public char getSeperatorChar() {
		return seperatorChar;
	}

}"
CSVFile.java,log,"package org.processmining.log.csv;

import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.nio.file.Path;

import org.processmining.log.csv.config.CSVConfig;

/**
 * Interface for a CSV file managed in the ProM environment. Example usage:
 * 
 * <pre>
 * CSVFile file; // get it from a plug-in
 * 
 * // Prepare config with auto guessing of encoding etc.
 * CSVConfig importConfig = new CSVConfig(csvFile);
 * 
 * // Read header
 * try {
 * 	String[] header = csvFile.readHeader(importConfig);
 * } catch (IOException e) {
 * 	// do someting
 * }
 * 
 * // Read content
 * try (ICSVReader reader = csvFile.createReader(importConfig)) {
 * 	while ((nextLine = reader.readNext()) != null) {
 * 		// do something
 * 	}
 * }
 * </pre>
 * 
 * @author F. Mannhardt
 * 
 */
public interface CSVFile {

	/**
	 * @return the complete path to the CSV file (including the file itself)
	 */
	Path getFile();

	/**
	 * @return the filename with extension
	 */
	String getFilename();

	/**
	 * @return input stream of this CSV file
	 * @throws FileNotFoundException
	 * @throws IOException
	 */
	InputStream getInputStream() throws FileNotFoundException, IOException;

	/**
	 * Returns the first row of the CSV file.
	 * 
	 * @param config
	 * @return
	 * @throws IOException
	 */
	String[] readHeader(CSVConfig config) throws IOException;

	/**
	 * Returns a new {@link ICSVReader} that can be used to read through the
	 * input stream. The caller is responsible for calling
	 * {@link ICSVReader#close()} on the reader.
	 * 
	 * @param config
	 * @return
	 * @throws IOException
	 */
	ICSVReader createReader(CSVConfig config) throws IOException;

	/**
	 * @return the CSV reader/writer interface used for this {@link CSVFile}
	 */
	ICSV getCSV();

}"
CSVFileReferenceOpenCSVImpl.java,log,"package org.processmining.log.csv;

import java.io.IOException;
import java.nio.file.Path;

import org.processmining.log.csv.config.CSVConfig;

/**
 * {@link CSVFile} implementation that holds a reference to a CSV file on disk.
 * The {@link CSVFileReferenceUnivocityImpl} is recommended!
 *
 * @author F. Mannhardt
 *
 */
public final class CSVFileReferenceOpenCSVImpl extends AbstractCSVFile {

	private final CSVOpenCSVImpl csv;

	public CSVFileReferenceOpenCSVImpl(Path file) {
		super(file);
		csv = new CSVOpenCSVImpl();
	}

	@Deprecated
	public CSVFileReferenceOpenCSVImpl(Path file, String filename, long fileSizeInBytes) {
		this(file);
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see
	 * org.processmining.log.csv.CSVFile#readHeader(org.processmining.log.csvimport
	 * .CSVImportConfig)
	 */
	@Override
	public String[] readHeader(CSVConfig importConfig) throws IOException {
		return createReader(importConfig).readNext();
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see
	 * org.processmining.log.csv.CSVFile#createReader(org.processmining.log.
	 * csv.CSVConfig)
	 */
	@Override
	public ICSVReader createReader(CSVConfig config) throws IOException {
		return csv.createReader(getInputStream(), config);
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see org.processmining.log.csv.CSVFile#getCSV()
	 */
	@Override
	public ICSV getCSV() {
		return csv;
	}

}
"
CSVFileReferenceUnivocityImpl.java,log,"package org.processmining.log.csv;

import java.io.IOException;
import java.nio.file.Path;

import org.processmining.log.csv.config.CSVConfig;

import com.univocity.parsers.common.TextParsingException;

/**
 * {@link CSVFile} implementation that holds a reference to a CSV file on disk.
 *
 * @author N. Tax
 *
 */
public final class CSVFileReferenceUnivocityImpl extends AbstractCSVFile {
	
	private final CSVUnivocityImpl csv;

	public CSVFileReferenceUnivocityImpl(Path file) {
		super(file);
		csv = new CSVUnivocityImpl();
	}
	
	@Deprecated
	public CSVFileReferenceUnivocityImpl(Path file, String filename, long fileSizeInBytes) {
		this(file);
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see
	 * org.processmining.log.csv.CSVFile#readHeader(org.processmining.log.csvimport
	 * .CSVImportConfig)
	 */
	@Override
	public String[] readHeader(CSVConfig importConfig) throws IOException {
		try {
			return createReader(importConfig).readNext();
		} catch (TextParsingException | IllegalStateException e) {
			// Wrap unchecked Univocity exceptions into a IOException for consistency
			throw new IOException(e);
		}
	}

	/* (non-Javadoc)
	 * @see org.processmining.log.csv.CSVFile#createReader(org.processmining.log.csv.CSVConfig)
	 */
	@Override
	public ICSVReader createReader(CSVConfig config) throws IOException {
		return csv.createReader(getInputStream(), config);
	}

	/* (non-Javadoc)
	 * @see org.processmining.log.csv.CSVFile#getCSV()
	 */
	@Override
	public ICSV getCSV() {
		return csv;
	}
	
}
"
CSVOpenCSVImpl.java,log,"package org.processmining.log.csv;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.UnsupportedEncodingException;

import org.processmining.log.csv.config.CSVConfig;

import au.com.bytecode.opencsv.CSVParser;
import au.com.bytecode.opencsv.CSVReader;
import au.com.bytecode.opencsv.CSVWriter;

public class CSVOpenCSVImpl implements ICSV {
	
	private static final int BUFFER_SIZE = 8192 * 4;

	private static CSVReader createCSVReader(InputStream is, CSVConfig importConfig)
			throws UnsupportedEncodingException {
		if (importConfig.getQuoteChar() == null) {
			return new CSVReader(new BufferedReader(new InputStreamReader(is, importConfig.getCharset()), BUFFER_SIZE),
					importConfig.getSeparator().getSeperatorChar(), CSVParser.DEFAULT_QUOTE_CHARACTER,
					CSVParser.DEFAULT_ESCAPE_CHARACTER, 0, false, false, true);
		} else {
			return new CSVReader(new BufferedReader(new InputStreamReader(is, importConfig.getCharset()), BUFFER_SIZE),
					importConfig.getSeparator().getSeperatorChar(), importConfig.getQuoteChar().getQuoteChar());
		}

	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see
	 * org.processmining.log.csv.CSVFile#createReader(org.processmining.log.
	 * csvimport.CSVImportConfig)
	 */
	@Override
	public ICSVReader createReader(InputStream is, CSVConfig importConfig) throws IOException {
		final CSVReader csvReader = createCSVReader(is, importConfig);
		return new ICSVReader() {

			/* (non-Javadoc)
			 * @see org.processmining.log.csv.AbstractCSVReader#readNext()
			 */
			public String[] readNext() throws IOException {
				return csvReader.readNext();
			}

			/* (non-Javadoc)
			 * @see org.processmining.log.csv.AbstractCSVReader#close()
			 */
			public void close() throws IOException {
				csvReader.close();
			}
			
		};
	}
	
	private static CSVWriter createCSVWriter(OutputStream os, CSVConfig importConfig)
			throws UnsupportedEncodingException {
		return new CSVWriter(new BufferedWriter(new OutputStreamWriter(os, importConfig.getCharset()), BUFFER_SIZE),
				importConfig.getSeparator().getSeperatorChar(), importConfig.getQuoteChar().getQuoteChar());
	}

	public ICSVWriter createWriter(OutputStream os, CSVConfig importConfig) throws IOException {
		final CSVWriter csvWriter = createCSVWriter(os, importConfig);
		return new ICSVWriter() {

			public void writeNext(String[] value) {
				csvWriter.writeNext(value, false);
			}

			public void close() throws IOException {
				csvWriter.close();
			}

			
		};
	}

}
"
CSVUnivocityImpl.java,log,"package org.processmining.log.csv;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.UnsupportedEncodingException;

import org.apache.commons.io.input.BOMInputStream;
import org.processmining.log.csv.config.CSVConfig;

import com.univocity.parsers.csv.CsvParser;
import com.univocity.parsers.csv.CsvParserSettings;
import com.univocity.parsers.csv.CsvWriter;
import com.univocity.parsers.csv.CsvWriterSettings;

public class CSVUnivocityImpl implements ICSV {
	
	private static final int MAX_CHARS_PER_COLUMN = 65536;
	
	private static final int BUFFER_SIZE = 8192 * 4;

	private static CsvParser createCSVReader(InputStream is, CSVConfig importConfig) throws UnsupportedEncodingException{
		CsvParserSettings settings = new CsvParserSettings();
		settings.setMaxCharsPerColumn(MAX_CHARS_PER_COLUMN);
		settings.setLineSeparatorDetectionEnabled(true);
		settings.getFormat().setDelimiter(importConfig.getSeparator().getSeperatorChar());
		settings.getFormat().setQuote(importConfig.getQuoteChar().getQuoteChar());
		settings.getFormat().setCharToEscapeQuoteEscaping(importConfig.getEscapeChar().getEscapeChar());
		CsvParser parser = new CsvParser(settings);
		BOMInputStream bomExcludingStream = new BOMInputStream(is); // exclude BOM byte for UTF-BOM encoded files as those mess up with pretty much everything
		parser.beginParsing(new BufferedReader(new InputStreamReader(bomExcludingStream, importConfig.getCharset()), BUFFER_SIZE));
		return parser;
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see
	 * org.processmining.log.csv.CSVFile#createReader(org.processmining.log.
	 * csvimport.CSVImportConfig)
	 */
	@Override
	public ICSVReader createReader(InputStream is, CSVConfig importConfig) throws IOException {
		final CsvParser csvReader = createCSVReader(is, importConfig);
		return new ICSVReader() {
			
			public String[] readNext() throws IOException {
				return csvReader.parseNext();
			}

			public void close() throws IOException {
				csvReader.stopParsing();
			}
			
		};
	}
	
	private static CsvWriter createCSVWriter(OutputStream os, CSVConfig importConfig) throws UnsupportedEncodingException {
		CsvWriterSettings settings = new CsvWriterSettings();
		settings.getFormat().setDelimiter(importConfig.getSeparator().getSeperatorChar());
		settings.getFormat().setQuote(importConfig.getQuoteChar().getQuoteChar());
		settings.getFormat().setCharToEscapeQuoteEscaping(importConfig.getEscapeChar().getEscapeChar());
		CsvWriter writer = new CsvWriter(new OutputStreamWriter(os, importConfig.getCharset()), settings);
		return writer;
	}

	/* (non-Javadoc)
	 * @see org.processmining.log.csv.CSVFile#createWriter(java.io.OutputStream, org.processmining.log.csvimport.config.CSVImportConfig)
	 */
	@Override
	public ICSVWriter createWriter(OutputStream os, CSVConfig config) throws IOException {
		final CsvWriter writer = createCSVWriter(os, config);
		return new ICSVWriter() {
			
			public void writeNext(String[] value) {
				writer.writeRow((Object[])value);
			}
			
			public void close() throws IOException {				
				writer.close();				
			}
		};
	}

}
"
ICSV.java,log,"package org.processmining.log.csv;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;

import org.processmining.log.csv.config.CSVConfig;

/**
 * Wrapper around some CSV parsing library.
 * 
 * @author F. Mannhardt
 *
 */
public interface ICSV {

	/**
	 * Returns a new {@link ICSVWriter} that can be used to write data to a new
	 * {@link OutputStream} in CSV format. The caller is responsible for calling
	 * {@link ICSVWriter#close()} on the writer.
	 * 
	 * @param os
	 * @param config
	 * @return
	 * @throws IOException
	 */
	ICSVWriter createWriter(OutputStream os, CSVConfig config) throws IOException;

	/**
	 * Returns a new {@link ICSVReader} that can be used to read data from the
	 * {@link InputStream} in CSV format. The caller is responsible for calling
	 * {@link ICSVReader#close()} on the writer.
	 * 
	 * @param os
	 * @param config
	 * @return
	 * @throws IOException
	 */
	ICSVReader createReader(InputStream is, CSVConfig config) throws IOException;

}
"
ICSVReader.java,log,"package org.processmining.log.csv;

import java.io.IOException;

/**
 * Reader of a CSV file
 * 
 * @author F. Mannhardt
 *
 */
public interface ICSVReader extends AutoCloseable {

	/**
	 * @return the next line or NULL in case of EOF
	 * @throws IOException
	 */
	String[] readNext() throws IOException;

	/* (non-Javadoc)
	 * @see java.lang.AutoCloseable#close()
	 */
	void close() throws IOException;

}
"
ICSVWriter.java,log,"package org.processmining.log.csv;

import java.io.IOException;

public interface ICSVWriter {

	void writeNext(String[] value);
	
	void close() throws IOException;
	
}
"
CSVViewer.java,log,"package org.processmining.log.csv.plugin;

import javax.swing.JComponent;

import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.contexts.uitopia.annotations.Visualizer;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginLevel;
import org.processmining.log.csv.CSVFile;
import org.processmining.log.csv.config.CSVConfig;
import org.processmining.log.csvimport.exception.CSVConversionException;

public class CSVViewer {

	@Plugin(name = ""View CSV"", level = PluginLevel.Regular, //
	parameterLabels = { ""CSV"" }, returnLabels = { ""XES Event Log"" }, // 
	returnTypes = { JComponent.class }, userAccessible = true)
	@Visualizer
	public JComponent viewCSV(final UIPluginContext context, final CSVFile csvFile) throws CSVConversionException {
		return new CSVViewerPanel(csvFile, new CSVConfig(csvFile));
	}

}
"
CSVViewerPanel.java,log,"package org.processmining.log.csv.plugin;

import java.awt.Font;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.io.IOException;
import java.nio.charset.Charset;
import java.util.List;

import javax.swing.BoxLayout;
import javax.swing.GroupLayout;
import javax.swing.GroupLayout.Alignment;
import javax.swing.GroupLayout.ParallelGroup;
import javax.swing.GroupLayout.SequentialGroup;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.SwingConstants;
import javax.swing.SwingWorker;

import org.processmining.framework.util.ui.widgets.ProMComboBox;
import org.processmining.framework.util.ui.widgets.helper.ProMUIHelper;
import org.processmining.log.csv.CSVFile;
import org.processmining.log.csv.ICSVReader;
import org.processmining.log.csv.config.CSVConfig;
import org.processmining.log.csv.config.CSVQuoteCharacter;
import org.processmining.log.csv.config.CSVSeperator;
import org.processmining.log.csvimport.ui.preview.CSVPreviewPanel;

import com.fluxicon.slickerbox.factory.SlickerFactory;

/**
 * CSV Viewer
 * 
 * @author F. Mannhardt
 *
 */
final class CSVViewerPanel extends JPanel {

	private static final long serialVersionUID = 2L;

	private static final int MAX_PREVIEW = 1000;
	private static final int COLUMN_WIDTH = 240;

	private final CSVFile csv;
	private final CSVConfig importConfig;

	private final ProMComboBox<String> charsetCbx;
	private final ProMComboBox<CSVSeperator> separatorField;
	private final ProMComboBox<CSVQuoteCharacter> quoteField;

	private final CSVPreviewPanel previewPanel;

	private SwingWorker<Void, String[]> worker;

	public CSVViewerPanel(final CSVFile csv, final CSVConfig importConfig) {
		super();
		this.importConfig = importConfig;
		this.csv = csv;
		this.previewPanel = new CSVPreviewPanel();

		setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));
		setOpaque(false);

		JLabel header = new JLabel(
				""<HTML><H2>Read-only CSV Viewer</H2>""
				+ ""<H3>This visualization is a read-only preview of the CSV file. Please use plug-in 'Convert CSV to XES' for conversion to XES</H3></HTML>"");
		header.setAlignmentX(CENTER_ALIGNMENT);

		add(header);

		JPanel topPanel = new JPanel();

		GroupLayout layout = new GroupLayout(topPanel);
		layout.setAutoCreateContainerGaps(true);
		layout.setAutoCreateGaps(true);

		topPanel.setOpaque(false);
		topPanel.setLayout(layout);

		JPanel charsetPanel = new JPanel();
		charsetPanel.setOpaque(false);
		charsetPanel.setLayout(new BoxLayout(charsetPanel, BoxLayout.Y_AXIS));
		charsetCbx = new ProMComboBox<>(Charset.availableCharsets().keySet());
		charsetCbx.setSelectedItem(importConfig.getCharset());
		charsetCbx.setPreferredSize(null);
		charsetCbx.setMinimumSize(null);
		JLabel charsetLabel = createLabel(""Charset"", ""Configure the character encoding that is used by the CSV file"");
		charsetLabel.setAlignmentX(LEFT_ALIGNMENT);
		charsetCbx.setAlignmentX(LEFT_ALIGNMENT);
		charsetPanel.add(charsetLabel);
		charsetPanel.add(charsetCbx);
		charsetCbx.addActionListener(new ActionListener() {

			public void actionPerformed(ActionEvent e) {
				importConfig.setCharset(charsetCbx.getSelectedItem().toString());
				refreshPreview();
			}
		});

		JPanel separatorPanel = new JPanel();
		separatorPanel.setOpaque(false);
		separatorPanel.setLayout(new BoxLayout(separatorPanel, BoxLayout.Y_AXIS));
		separatorField = new ProMComboBox<>(CSVSeperator.values());
		separatorField.setPreferredSize(null);
		separatorField.setMinimumSize(null);
		separatorField.setSelectedItem(importConfig.getSeparator());
		JLabel seperationLabel = createLabel(""Separator Character"",
				""Configure the character that is used by the CSV file to separate two fields"");
		seperationLabel.setAlignmentX(LEFT_ALIGNMENT);
		separatorField.setAlignmentX(LEFT_ALIGNMENT);
		separatorPanel.add(seperationLabel);
		separatorPanel.add(separatorField);
		separatorField.addActionListener(new ActionListener() {

			public void actionPerformed(ActionEvent e) {
				importConfig.setSeparator(((CSVSeperator) separatorField.getSelectedItem()));
				refreshPreview();
			}
		});

		JPanel quotePanel = new JPanel();
		quotePanel.setOpaque(false);
		quotePanel.setLayout(new BoxLayout(quotePanel, BoxLayout.Y_AXIS));
		quoteField = new ProMComboBox<>(CSVQuoteCharacter.values());
		quoteField.setPreferredSize(null);
		quoteField.setMinimumSize(null);
		quoteField.setSelectedItem(importConfig.getQuoteChar());
		JLabel quoteLabel = createLabel(
				""Quote Character"",
				""Configure the character that is used by the CSV file that is used to quote values if they contain the separator character or a newline"");
		quoteLabel.setAlignmentX(LEFT_ALIGNMENT);
		quoteField.setAlignmentX(LEFT_ALIGNMENT);
		quotePanel.add(quoteLabel);
		quotePanel.add(quoteField);
		quoteField.addActionListener(new ActionListener() {

			public void actionPerformed(ActionEvent e) {
				importConfig.setQuoteChar((CSVQuoteCharacter) quoteField.getSelectedItem());
				refreshPreview();
			}
		});		

		ParallelGroup verticalGroup = layout.createParallelGroup().addComponent(charsetPanel, Alignment.TRAILING)
				.addComponent(separatorPanel, Alignment.TRAILING).addComponent(quotePanel, Alignment.TRAILING);

		SequentialGroup horizontalGroup = layout.createSequentialGroup()
				.addComponent(charsetPanel, COLUMN_WIDTH, COLUMN_WIDTH, COLUMN_WIDTH)
				.addComponent(separatorPanel, COLUMN_WIDTH, COLUMN_WIDTH, COLUMN_WIDTH)
				.addComponent(quotePanel, COLUMN_WIDTH, COLUMN_WIDTH, COLUMN_WIDTH);

		layout.linkSize(SwingConstants.HORIZONTAL, separatorPanel, charsetPanel, quotePanel);

		layout.setAutoCreateContainerGaps(true);
		layout.setAutoCreateGaps(true);

		layout.setVerticalGroup(verticalGroup);
		layout.setHorizontalGroup(horizontalGroup);

		add(topPanel);
		add(previewPanel);
		refreshPreview();
	}

	private void refreshPreview() {

		if (worker != null) {
			worker.cancel(true);
		}

		previewPanel.clear();

		// Update Header
		try {
			previewPanel.setHeader(csv.readHeader(importConfig));
		} catch (IOException | ArrayIndexOutOfBoundsException e) {
			ProMUIHelper.showWarningMessage(this, ""Error parsing CSV "" + e.getMessage(), ""CSV Parsing Error"");
			return;
		}

		worker = new SwingWorker<Void, String[]>() {

			protected Void doInBackground() throws Exception {

				try (ICSVReader reader = csv.createReader(importConfig)) {
					// Skip header
					reader.readNext();
					String[] nextLine;
					int i = 0;
					while ((nextLine = reader.readNext()) != null && i < MAX_PREVIEW) {
						publish(nextLine);
						i++;
					}
				}

				return null;
			}

			protected void process(List<String[]> chunks) {
				for (String[] row : chunks) {
					previewPanel.addRow(row);
				}
			}

		};

		try {
			worker.execute();
		} catch (Exception e) {
			JOptionPane.showMessageDialog(this, ""Error parsing CSV "" + e.getMessage(), ""CSV Parsing Error"",
					JOptionPane.ERROR_MESSAGE);
		}
	}

	private static JLabel createLabel(String caption, String description) {
		JLabel eventLabel = SlickerFactory.instance().createLabel(
				""<HTML><B>"" + caption + ""</B><BR/><I>"" + description + ""</I></HTML>"");
		eventLabel.setFont(eventLabel.getFont().deriveFont(Font.PLAIN));
		return eventLabel;
	}

}"
CSVExportPlugin.java,log,"package org.processmining.log.csvexport;

import java.io.File;
import java.io.IOException;

import org.processmining.contexts.uitopia.annotations.UIExportPlugin;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginLevel;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.log.csv.CSVFile;

import com.google.common.io.Files;

/**
 * Exports a CSVFile
 * 
 * @author F. Mannhardt
 *
 */
@Plugin(name = ""Export CSV"", returnLabels = {}, returnTypes = {},
		level = PluginLevel.Regular, parameterLabels = { ""CSVFile"", ""File"" }, userAccessible = true)
@UIExportPlugin(description = ""Export CSV"", extension = ""csv"")
public final class CSVExportPlugin  {

	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""F. Mannhardt"", email = ""f.mannhardt@tue.nl"")
	@PluginVariant(requiredParameterLabels = { 0, 1 }, variantLabel = ""Export CSV File"")
	public void export(PluginContext context, CSVFile csvFile, File file) throws IOException {
		Files.copy(csvFile.getFile().toFile(), file);
	}
}
"
ExportLogCsv.java,log,"package org.processmining.log.csvexport;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;

import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.extension.std.XLifecycleExtension;
import org.deckfour.xes.factory.XFactory;
import org.deckfour.xes.factory.XFactoryRegistry;
import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.deckfour.xes.out.XSerializer;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.contexts.uitopia.annotations.UIExportPlugin;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginLevel;
import org.processmining.framework.plugin.annotations.PluginVariant;

@Plugin(name = ""Export Log to CSV File"", level= PluginLevel.PeerReviewed, parameterLabels = { ""Log"", ""File"" }, returnLabels = {}, returnTypes = {}, userAccessible = true)
@UIExportPlugin(description = ""CSV files"", extension = ""csv"")
public final class ExportLogCsv {
	
//TODO: Export plug-in cannot show any Dialog :(
	
/*	private class DateFormatPanel extends BorderPanel {

		private static final long serialVersionUID = -6547392010448275699L;
		private final ProMTextField dateFormatTextField;

		public DateFormatPanel() {
			super(0, 0);
			dateFormatTextField = new ProMTextField(""yyyy-MM-dd'T'HH:mm:ssZ"");
			add(dateFormatTextField);
		}	
		
		public String getDateFormat() {
			return dateFormatTextField.getText().trim();		
		}

		public InteractionResult getUserChoice(UIPluginContext context) {
			return context.showConfiguration(""Specify date format"", this);
		}

	}*/
	
	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""F. Mannhardt, M. de Leoni"", email = ""m.d.leoni@tue.nl"")
	@PluginVariant(requiredParameterLabels = { 0, 1 }, variantLabel = ""Export Log to CSV File"")
	public void export(UIPluginContext context, XLog log, File file) throws IOException {
		FileOutputStream out = new FileOutputStream(file);

		long instanceNumber=1;

		//final XLog result = XFactoryRegistry.instance().currentDefault().createLog(log.getAttributes());
		final XLifecycleExtension lfExt = XLifecycleExtension.instance();
		final XFactory factory=XFactoryRegistry.instance().currentDefault();
		final XConceptExtension cpExt=XConceptExtension.instance();
		final HashMap<String,List<Long>> map=new HashMap<String, List<Long>>();
		String activityName;
		
		for (XTrace trace : log) {
			map.clear();
			for (XEvent event : trace) {
				switch(lfExt.extractStandardTransition(event))
				{
					case START :
						activityName=cpExt.extractName(event);
						if (activityName!=null)
						{
							//event=factory.createEvent(e.getAttributes());
							if (cpExt.extractInstance(event)==null)
							{						
								List<Long> listInstances=map.get(activityName);
								if (listInstances==null)
								{
									listInstances=new LinkedList<Long>();
									map.put(activityName, listInstances);
								}
								cpExt.assignInstance(event, String.valueOf(instanceNumber));
								listInstances.add(instanceNumber++);
							}
						}
						break;					
					case COMPLETE :
						activityName=cpExt.extractName(event);
						if (activityName!=null)
						{
							event=factory.createEvent(event.getAttributes());							
							if (cpExt.extractInstance(event)==null)
							{
								List<Long> listInstances=map.get(activityName);
								if (listInstances==null || listInstances.isEmpty())									
									cpExt.assignInstance(event, String.valueOf(instanceNumber++));
								else
								{
									cpExt.assignInstance(event, String.valueOf(listInstances.remove(0)));
								}
							}
						}
						break;
					default :
						//event=null;
						break;
				}
				//copy.add(event);
			}
		}
		XSerializer logSerializer = new XesCsvSerializer(""yyyy/MM/dd HH:mm:ss.SSS"");
		logSerializer.serialize(log, out);
		out.close();	
	}
}
"
XesCsvSerializer.java,log,"package org.processmining.log.csvexport;

import java.io.IOException;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.ListIterator;
import java.util.Map;
import java.util.Set;

import org.apache.commons.lang3.time.FastDateFormat;
import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.extension.std.XLifecycleExtension;
import org.deckfour.xes.extension.std.XLifecycleExtension.StandardModel;
import org.deckfour.xes.extension.std.XTimeExtension;
import org.deckfour.xes.info.XAttributeInfo;
import org.deckfour.xes.info.XLogInfo;
import org.deckfour.xes.info.XLogInfoFactory;
import org.deckfour.xes.logging.XLogging;
import org.deckfour.xes.model.XAttribute;
import org.deckfour.xes.model.XAttributeTimestamp;
import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.deckfour.xes.out.XSerializer;
import org.processmining.log.utils.XUtils;

import au.com.bytecode.opencsv.CSVWriter;

/**
 * XES serialization to CSV including all trace/event attributes. The names of
 * trace attributes are prefixed with ""trace_"", those of event attributes are
 * prefixed with ""event_"".
 *
 * @author F. Mannhardt
 *
 */
public final class XesCsvSerializer implements XSerializer {

	private final FastDateFormat dateFormat;

	public XesCsvSerializer(String dateFormatString) {
		super();
		dateFormat = FastDateFormat.getInstance(dateFormatString);
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see org.deckfour.xes.out.XesSerializer#getDescription()
	 */
	public String getDescription() {
		return ""XES CSV Serialization"";
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see org.deckfour.xes.out.XesSerializer#getName()
	 */
	public String getName() {
		return ""XES CSV"";
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see org.deckfour.xes.out.XesSerializer#getAuthor()
	 */
	public String getAuthor() {
		return ""F. Mannhardt"";
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see org.deckfour.xes.out.XesSerializer#getSuffices()
	 */
	public String[] getSuffices() {
		return new String[] { ""csv"" };
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see
	 * org.deckfour.xes.out.XesSerializer#serialize(org.deckfour.xes.model.XLog,
	 * java.io.OutputStream)
	 */
	public void serialize(XLog log, OutputStream out) throws IOException {
		XLogging.log(""start serializing log to .csv"", XLogging.Importance.DEBUG);
		long start = System.currentTimeMillis();

		CSVWriter writer = new CSVWriter(new OutputStreamWriter(out, ""UTF-8""));
		Map<String, Integer> columnMap = new HashMap<String, Integer>();

		String[] header = compileHeader(log, columnMap);
		writer.writeNext(header);

		for (XTrace trace : log) {
			writer.writeAll(compileTrace(trace, columnMap, header.length));
		}

		writer.close();
		String duration = "" ("" + (System.currentTimeMillis() - start) + "" msec.)"";
		XLogging.log(""finished serializing log"" + duration, XLogging.Importance.DEBUG);
	}

	private List<String[]> compileTrace(XTrace trace, Map<String, Integer> columnMap, int rowLength) {
		List<String[]> traceList = new ArrayList<String[]>();
		String[] currentRow = null;
		Set<XEvent> convertedEvents = new HashSet<>();
		for (ListIterator<XEvent> iterator = trace.listIterator(); iterator.hasNext();) {
			XEvent event = iterator.next();
			if (!convertedEvents.contains(event)) {
				StandardModel lifecycle = XLifecycleExtension.instance().extractStandardTransition(event);
				if (lifecycle == null) {
					// treat as complete
					currentRow = compileEvent(trace, null, event, columnMap, rowLength, currentRow);
					convertedEvents.add(event);
				} else if (lifecycle == StandardModel.START) {
					XEvent completionEvent = null;
					if (lifecycle == StandardModel.START) {
						completionEvent = lookup(trace.listIterator(iterator.nextIndex()), event,
								StandardModel.COMPLETE);
					}
					currentRow = compileEvent(trace, event, completionEvent, columnMap, rowLength, currentRow);
					convertedEvents.add(event);
					if (completionEvent != null) {
						convertedEvents.add(completionEvent);
					}
				} else if (lifecycle == StandardModel.COMPLETE) {
					//XEvent startEvent = null;
					//MASSIMILIANO: Not sure what the aim: if lifecycle==COMPLETE, we are in this block. Hence, lifecycle cannot be
					//START. Therefore, we never enter the loop below.
					/*if (lifecycle == StandardModel.START) {
						startEvent = lookup(trace.listIterator(iterator.nextIndex()), event, StandardModel.START);
					}*/
					currentRow = compileEvent(trace, null, event, columnMap, rowLength, currentRow);
					convertedEvents.add(event);

					//MASSIMILIANO: I've removed the following part. I have the feeling that you're trying to map with some
					//start event following the complete. This would mean that the end event might be larger than the start event.
					/*convertedEvents.add(event);
					if (startEvent != null) {
						convertedEvents.add(startEvent);*/
				//}
				} else {
					// ignore we only export start and complete
				}
			traceList.add(currentRow);
			}
		}
		return traceList;
	}

	private XEvent lookup(ListIterator<XEvent> listIterator, XEvent event, StandardModel model) {
		XConceptExtension concept = XConceptExtension.instance();
		String eventInstance = concept.extractInstance(event);
		while (listIterator.hasNext()) {
			XEvent e = listIterator.next();
			if (eventInstance != null && eventInstance.equals(concept.extractInstance(e))) {
				StandardModel lifecycle = XLifecycleExtension.instance().extractStandardTransition(e);
				if (lifecycle == model) {
					return e;
				}
			}
		}
		return null;
	}

	private String[] compileEvent(XTrace trace, XEvent startEvent, XEvent completionEvent,
			Map<String, Integer> columnMap, int rowLength, String[] lastRow) {
		XEvent mainEvent = completionEvent != null ? completionEvent : startEvent;
		String[] row = new String[rowLength];
		row[0] = XConceptExtension.instance().extractName(trace);
		row[1] = XConceptExtension.instance().extractName(mainEvent);
		if (startEvent != null) {
			Date date = XTimeExtension.instance().extractTimestamp(startEvent);
			if (date != null) {
				row[2] = dateFormat.format(date);
			}
		} else {
			Date date = XTimeExtension.instance().extractTimestamp(completionEvent);
			if (date != null) {
				row[2] = dateFormat.format(date);
			}
		}
		if (completionEvent != null) {
			Date date = XTimeExtension.instance().extractTimestamp(completionEvent);
			if (date != null) {
				row[3] = dateFormat.format(date);
			}
		} else {
			Date date = XTimeExtension.instance().extractTimestamp(startEvent);
			if (date != null) {
				row[3] = dateFormat.format(date);
			}
		}

		for (XAttribute attr : trace.getAttributes().values()) {
			if (!XUtils.isStandardExtensionAttribute(attr) || attr.getKey().startsWith(""org:"")) {
				assert columnMap.containsKey(""trace_"" + attr.getKey()) : ""Column unkown "" + attr.getKey();
				row[columnMap.get(""trace_"" + attr.getKey())] = convertAttribute(attr);
			}
		}
		for (XAttribute attr : mainEvent.getAttributes().values()) {
			if (!XUtils.isStandardExtensionAttribute(attr) || attr.getKey().startsWith(""org:"")) {
				assert columnMap.containsKey(""event_"" + attr.getKey()) : ""Column unkown "" + attr.getKey();
				row[columnMap.get(""event_"" + attr.getKey())] = convertAttribute(attr);
			}
		}
		if (lastRow != null) {
			for (int i = 0; i < row.length; i++) {
				if (row[i] == null) {
					row[i] = lastRow[i];
				}
			}
		}
		return row;
	}

	private String[] compileHeader(XLog log, Map<String, Integer> columnMap) {
		XLogInfo logInfo = XLogInfoFactory.createLogInfo(log);

		List<String> headerList = new ArrayList<String>();
		headerList.add(""case"");
		headerList.add(""event"");
		headerList.add(""startTime"");
		headerList.add(""completeTime"");

		int i = headerList.size() - 1;
		XAttributeInfo traceAttributeInfo = logInfo.getTraceAttributeInfo();
		for (XAttribute attr : traceAttributeInfo.getAttributes()) {
			if (!XUtils.isStandardExtensionAttribute(attr) || attr.getKey().startsWith(""org:"")) {
				i++;
				headerList.add(attr.getKey());
				columnMap.put(""trace_"" + attr.getKey(), i);
			}
		}
		XAttributeInfo eventAttributeInfo = logInfo.getEventAttributeInfo();
		for (XAttribute attr : eventAttributeInfo.getAttributes() ) {
			if (!XUtils.isStandardExtensionAttribute(attr) || attr.getKey().startsWith(""org:"")) {
				i++;
				if (headerList.contains(attr.getKey())) {
					headerList.add(""event_"" + attr.getKey());
					columnMap.put(""event_"" + attr.getKey(), i);
				} else {
					headerList.add(attr.getKey());
					columnMap.put(""event_"" + attr.getKey(), i);
				}
			}
		}
		return headerList.toArray(new String[headerList.size()]);
	}

	/**
	 * Helper method, returns the String representation of the attribute
	 *
	 * @param attribute
	 *            The attributes to convert
	 */
	protected String convertAttribute(XAttribute attribute) {
		if (attribute instanceof XAttributeTimestamp) {
			Date timestamp = ((XAttributeTimestamp) attribute).getValue();
			return dateFormat.format(timestamp);
		} else {
			return attribute.toString();
		}
	}

	/**
	 * toString() defaults to getName().
	 */
	public String toString() {
		return this.getName();
	}

}
"
CSVConversionConfig.java,log,"package org.processmining.log.csvimport.config;

import java.io.IOException;
import java.text.DateFormat;
import java.text.DecimalFormat;
import java.text.Format;
import java.text.MessageFormat;
import java.text.ParsePosition;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Set;
import java.util.regex.Pattern;

import org.deckfour.xes.extension.XExtension;
import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.extension.std.XCostExtension;
import org.deckfour.xes.extension.std.XLifecycleExtension;
import org.deckfour.xes.extension.std.XOrganizationalExtension;
import org.deckfour.xes.extension.std.XTimeExtension;
import org.deckfour.xes.factory.XFactory;
import org.deckfour.xes.factory.XFactoryRegistry;
import org.deckfour.xes.model.XAttribute;
import org.processmining.log.csv.CSVFile;
import org.processmining.log.csv.ICSVReader;
import org.processmining.log.csv.config.CSVConfig;
import org.processmining.log.csvimport.exception.CSVConversionException;
import org.processmining.log.formats.StandardDateFormats;

import com.google.common.collect.ImmutableList;

/**
 * Configuration regarding the conversion of the CSV file.
 * 
 * @author F. Mannhardt
 * 
 */
public final class CSVConversionConfig {

	private static final int DATA_TYPE_FORMAT_AUTO_DETECT_NUM_LINES = 5000;

	private static final Set<String> CASE_COLUMN_IDS = new HashSet<String>() {
		private static final long serialVersionUID = 1113995381788343439L;
		{
			add(""case"");
			add(""trace"");
			add(""traceid"");
			add(""caseid"");
		}
	};

	private static final Set<String> EVENT_COLUMN_IDS = new HashSet<String>() {
		private static final long serialVersionUID = -4218883319932959922L;
		{
			add(""event"");
			add(""eventname"");
			add(""activity"");
			add(""eventid"");
			add(""activityid"");
			add(""task"");
			add(""action"");
			add(""actie"");
		}
	};

	private static final Set<String> START_TIME_COLUMN_IDS = new HashSet<String>() {
		private static final long serialVersionUID = 6419129336151793063L;
		{
			add(""starttime"");
			add(""startdate"");
			add(""datumtijdbegin"");
		}
	};

	private static final Set<String> COMPLETION_TIME_COLUMN_IDS = new HashSet<String>() {
		private static final long serialVersionUID = 6419129336151793063L;
		{
			add(""timecomplete"");
			add(""completetime"");
			add(""completiontime"");
			add(""time"");
			add(""date"");
			add(""enddate"");
			add(""endtime"");
			add(""timestamp"");
			add(""datetime"");
			add(""date"");
			add(""eventtime"");
			add(""eindtijd"");
			add(""tijd"");
			add(""datum"");
			add(""datumtijdeind"");
		}
	};

	public static final class ExtensionAttribute {

		public ExtensionAttribute(String key, XExtension extension) {
			this.key = key;
			this.extension = extension;
		}

		public XExtension extension;
		public String key;

		public String toString() {
			if (key != null) {
				return String.format(""%s (%s)"", key, extension.getName());
			} else {
				return """";
			}
		}

		public int hashCode() {
			final int prime = 31;
			int result = 1;
			result = prime * result + ((extension == null) ? 0 : extension.hashCode());
			result = prime * result + ((key == null) ? 0 : key.hashCode());
			return result;
		}

		public boolean equals(Object obj) {
			if (this == obj)
				return true;
			if (obj == null)
				return false;
			if (getClass() != obj.getClass())
				return false;
			ExtensionAttribute other = (ExtensionAttribute) obj;
			if (extension == null) {
				if (other.extension != null)
					return false;
			} else if (!extension.equals(other.extension))
				return false;
			if (key == null) {
				if (other.key != null)
					return false;
			} else if (!key.equals(other.key))
				return false;
			return true;
		}

	}

	public static final ExtensionAttribute NO_EXTENSION_ATTRIBUTE = new ExtensionAttribute(null, null);
	public static final ExtensionAttribute[] AVAILABLE_EVENT_EXTENSIONS_ATTRIBUTES;
	static {
		List<ExtensionAttribute> list = new ArrayList<>();
		list.add(NO_EXTENSION_ATTRIBUTE);
		addAttributesFromExtension(XConceptExtension.instance(), XConceptExtension.instance().getEventAttributes(),
				list);
		addAttributesFromExtension(XOrganizationalExtension.instance(),
				XOrganizationalExtension.instance().getEventAttributes(), list);
		addAttributesFromExtension(XTimeExtension.instance(), XTimeExtension.instance().getEventAttributes(), list);
		addAttributesFromExtension(XLifecycleExtension.instance(), XLifecycleExtension.instance().getEventAttributes(),
				list);
		addAttributesFromExtension(XCostExtension.instance(), XCostExtension.instance().getEventAttributes(), list);
		AVAILABLE_EVENT_EXTENSIONS_ATTRIBUTES = list.toArray(new ExtensionAttribute[list.size()]);
	}

	private static void addAttributesFromExtension(XExtension extension, Collection<XAttribute> attributes,
			List<ExtensionAttribute> list) {
		for (XAttribute attr : attributes) {
			list.add(new ExtensionAttribute(attr.getKey(), extension));
		}
	}

	public enum CSVErrorHandlingMode {
		ABORT_ON_ERROR(""Stop on Error""), OMIT_TRACE_ON_ERROR(""Omit Trace on Error""), OMIT_EVENT_ON_ERROR(
				""Omit Event on Error""), BEST_EFFORT(""Omit Attribute on Error"");

		private String desc;

		CSVErrorHandlingMode(String desc) {
			this.desc = desc;
		}

		@Override
		public String toString() {
			return desc;
		}
	}

	public enum CSVAttributeConversionMode {
		ADD_TO_COMPLETE(""Add attributes to complete event""), ADD_TO_BOTH(
				""Add attributes to both start and complete event"");

		private String desc;

		CSVAttributeConversionMode(String desc) {
			this.desc = desc;
		}

		@Override
		public String toString() {
			return desc;
		}
	}

	public enum CSVEmptyCellHandlingMode {
		DENSE(""Dense (Include empty cells)""), SPARSE(""Sparse (Exclude empty cells)"");

		private String desc;

		CSVEmptyCellHandlingMode(String desc) {
			this.desc = desc;
		}

		@Override
		public String toString() {
			return desc;
		}

	}

	public enum Datatype {
		LITERAL, DISCRETE, CONTINUOUS, TIME, BOOLEAN
	}

	public static final class CSVMapping {

		public static final String DEFAULT_DATE_PATTERN = """";
		public static final String DEFAULT_DISCRETE_PATTERN = """";
		public static final String DEFAULT_CONTINUOUS_PATTERN = """";
		public static final String DEFAULT_LITERAL_PATTERN = """";

		private Datatype dataType = Datatype.LITERAL;
		private String dataPattern = """";
		private DateFormat cachedDateFormat = null;
		private String traceAttributeName = """";
		private String eventAttributeName = """";
		private ExtensionAttribute eventExtensionAttribute = NO_EXTENSION_ATTRIBUTE;

		public Datatype getDataType() {
			return dataType;
		}

		public void setDataType(Datatype dataType) {
			this.dataType = dataType;
		}

		public String getPattern() {
			return dataPattern;
		}

		/**
		 * @return a format to parse the value, which might be NOT be thread safe
		 */
		public Format getFormat() {
			switch (getDataType()) {
				case BOOLEAN :
					return null;
				case CONTINUOUS :
					if (dataPattern.isEmpty()) {
						return null;
					} else {
						return new DecimalFormat(dataPattern);
					}
				case DISCRETE :
					if (dataPattern.isEmpty()) {
						return null;
					} else {
						DecimalFormat integerFormat = new DecimalFormat(dataPattern);
						integerFormat.setMaximumFractionDigits(0);
						integerFormat.setDecimalSeparatorAlwaysShown(false);
						integerFormat.setParseIntegerOnly(true);
						return integerFormat;
					}
				case LITERAL :
					if (dataPattern.isEmpty()) {
						return null;
					} else {
						return new MessageFormat(dataPattern);
					}
				case TIME :
					if (dataPattern.isEmpty()) {
						return null;
					} else {
						if (cachedDateFormat == null) {
							cachedDateFormat = new SimpleDateFormat(dataPattern);
						} 
						return cachedDateFormat; 
					}
			}
			throw new RuntimeException(""Unkown data type "" + getDataType());
		}

		public void setPattern(String dataPattern) {
			this.dataPattern = dataPattern;
			this.cachedDateFormat = null;
		}

		public String getTraceAttributeName() {
			return traceAttributeName;
		}

		public void setTraceAttributeName(String traceAttributeName) {
			this.traceAttributeName = traceAttributeName;
		}

		public String getEventAttributeName() {
			return eventAttributeName;
		}

		public void setEventAttributeName(String eventAttributeName) {
			this.eventAttributeName = eventAttributeName;
		}

		public void setEventExtensionAttribute(ExtensionAttribute extensionAttribute) {
			this.eventExtensionAttribute = extensionAttribute;
		}

		public ExtensionAttribute getEventExtensionAttribute() {
			return eventExtensionAttribute;
		}

	}

	// XFactory to use for conversion if XESConversionHandler is used
	private XFactory factory = XFactoryRegistry.instance().currentDefault();

	// Mapping to some of the XES standard extensions
	private List<String> caseColumns = Collections.emptyList();
	private List<String> eventNameColumns = Collections.emptyList();
	private String completionTimeColumn = null; // may be NULL
	private String startTimeColumn = null; // may be NULL

	// How to concatenate attributes built from multiple columns
	private String compositeAttributeSeparator = ""|"";

	// Data-type mapping
	private Map<String, CSVMapping> conversionMap = new HashMap<>();

	// Various ""expert"" configuration options	
	private CSVErrorHandlingMode errorHandlingMode = CSVErrorHandlingMode.OMIT_TRACE_ON_ERROR;
	private CSVEmptyCellHandlingMode emptyCellHandlingMode = CSVEmptyCellHandlingMode.SPARSE;
	private Set<String> treatAsEmptyValues = new HashSet<>();
	private boolean shouldAddStartEventAttributes = true;

	// Internal only
	private final CSVFile csvFile;
	private final CSVConfig csvConfig;

	public CSVConversionConfig(CSVFile csvFile, CSVConfig csvConfig) throws CSVConversionException {
		this.csvFile = csvFile;
		this.csvConfig = csvConfig;

		try {
			String[] headers = csvFile.readHeader(csvConfig);
			for (String columnHeader : headers) {
				CSVMapping mapping = new CSVMapping();
				if (!conversionMap.containsKey(columnHeader) && columnHeader != null) {
					// We do not support duplicate column names or empty column names!
					mapping.setEventAttributeName(columnHeader);
					conversionMap.put(columnHeader, mapping);
				} else {
					if (columnHeader == null) {
						throw new CSVConversionException(MessageFormat.format(
								""The CSV file contains two columns with an empty name! The CSV importer cannot handle such CSV files. Please rename the columns (i.e., the first line of the CSV file) such that columns have unique names."",
								columnHeader));
					} else {
						throw new CSVConversionException(MessageFormat.format(
								""The CSV file contains two columns with the same name: {0}! The CSV importer cannot handle such CSV files. Please rename the columns (i.e., the first line of the CSV file) such that columns have unique names."",
								columnHeader));
					}
				}
			}
		} catch (IOException e) {
			throw new CSVConversionException(""Could not read headers of CSV"", e);
		}

		// Standard settings for empty/NULL or N/A values
		treatAsEmptyValues.add("""");
		treatAsEmptyValues.add(""NULL"");
		treatAsEmptyValues.add(""null"");
		treatAsEmptyValues.add(""NOT_SET"");
		treatAsEmptyValues.add(""N/A"");
		treatAsEmptyValues.add(""n/a"");
	}

	public void autoDetect() throws CSVConversionException {
		try {
			String[] headers = csvFile.readHeader(csvConfig);
			//TODO put those auto detection methods in a new class
			autoDetectCaseColumn(headers);
			autoDetectEventColumn(headers);
			autoDetectCompletionTimeColumn(headers);
			autoDetectStartTimeColumn(headers);
			autoDetectDataTypes();
		} catch (IOException e) {
			throw new CSVConversionException(""Could not auto-detect column types."", e);
		}
	}

	private void autoDetectCaseColumn(String[] headers) {
		List<String> caseColumns = new ArrayList<>();
		for (int i = 0; i < headers.length; i++) {
			String header = headers[i];
			if (header != null && CASE_COLUMN_IDS.contains(header.toLowerCase(Locale.US).trim())) {
				caseColumns.add(header);
			}
		}
		setCaseColumns(caseColumns);
	}

	private void autoDetectEventColumn(String[] headers) {
		List<String> eventColumns = new ArrayList<>();
		for (int i = 0; i < headers.length; i++) {
			String header = headers[i];
			if (header != null && EVENT_COLUMN_IDS.contains(header.toLowerCase(Locale.US).trim())) {
				eventColumns.add(header);
			}
		}
		setEventNameColumns(eventColumns);
	}

	private void autoDetectCompletionTimeColumn(String[] headers) {
		for (int i = 0; i < headers.length; i++) {
			String header = headers[i];

			if (header != null && COMPLETION_TIME_COLUMN_IDS.contains(header.toLowerCase(Locale.US).trim())) {
				setCompletionTimeColumn(header);
				return;
			}
		}
	}

	private void autoDetectStartTimeColumn(String[] headers) {
		for (int i = 0; i < headers.length; i++) {
			String header = headers[i];
			if (header != null && START_TIME_COLUMN_IDS.contains(header.toLowerCase(Locale.US).trim())) {
				setStartTimeColumn(header);
				return;
			}
		}
	}

	public void autoDetectDataTypes() throws CSVConversionException {
		try (ICSVReader reader = csvFile.createReader(csvConfig)) {
			String[] header = reader.readNext();

			//TODO FM, can't this be done in a more streaming fashion?
			Map<String, List<String>> valuesPerColumn = new HashMap<>();
			for (String h : header) {
				if (h != null) {
					valuesPerColumn.put(h, new ArrayList<String>(DATA_TYPE_FORMAT_AUTO_DETECT_NUM_LINES));
				}
			}
			// now read some lines or so to guess the data type
			for (int i = 0; i < DATA_TYPE_FORMAT_AUTO_DETECT_NUM_LINES; i++) {
				String[] cells = reader.readNext();
				if (cells == null) {
					//TODO FM, shouldn't that be a return?
					break;
				}
				for (int j = 0; j < cells.length; j++) {
					if (header[j] != null) {
						List<String> values = valuesPerColumn.get(header[j]);
						values.add(cells[j]);
						valuesPerColumn.put(header[j], values);
					}
				}
			}
			// now we can guess the data type
			for (String column : header) {
				if (column != null) {
					List<String> values = valuesPerColumn.get(column);
					if (values != null) {
						DatatypeWithPattern inferred = inferDataType(values);
						getConversionMap().get(column).setDataType(inferred.getType());
						getConversionMap().get(column).setPattern(inferred.getPattern());
					}

				}
			}
		} catch (IOException e) {
			throw new CSVConversionException(""Could not auto-detect column types."", e);
		}
	}

	private static boolean isInteger(String s) {
		return isInteger(s, 10); // check for base-10 number (plus optional minus sign)
	}

	private static boolean isInteger(String s, int radix) {
		if (s.isEmpty())
			return false;
		for (int i = 0; i < s.length(); i++) {
			if (i == 0 && s.charAt(i) == '-') {
				if (s.length() == 1)
					return false;
				else
					continue;
			}
			if (Character.digit(s.charAt(i), radix) < 0)
				return false;
		}
		return true;
	}

	public interface DatatypeWithPattern {
		Datatype getType();

		String getPattern();
	}

	private DatatypeWithPattern inferDataType(List<String> values) {

		boolean allEmpty = true;
		for (String value : values) {
			if (value != null && !value.isEmpty()) {
				allEmpty = false;
				break;
			}
		}
		if (allEmpty)
			return new DatatypeWithPattern() {

				public Datatype getType() {
					return Datatype.LITERAL;
				}

				public String getPattern() {
					return """";
				}
			};

		boolean hasParsed = false;

		// check whether type is boolean
		boolean isBoolean = true;
		for (String value : values) {
			if (value == null || value.isEmpty() || treatAsEmptyValues.contains(value)) {
				continue;
			}
			hasParsed = true;
			//TODO what about mixed
			if (!(""J"".equalsIgnoreCase(value) || ""Y"".equalsIgnoreCase(value) || ""T"".equalsIgnoreCase(value)
					|| ""true"".equalsIgnoreCase(value) || ""false"".equalsIgnoreCase(value) || ""N"".equalsIgnoreCase(value)
					|| ""F"".equalsIgnoreCase(value))) {
				isBoolean = false;
				break;
			}
		}
		if (hasParsed && isBoolean)
			return new DatatypeWithPattern() {

				public Datatype getType() {
					return Datatype.BOOLEAN;
				}

				public String getPattern() {
					return """";
				}
			};

		// check whether type is discrete
		hasParsed = false;
		boolean isDiscrete = true;
		for (String value : values) {
			if (value == null || value.isEmpty() || treatAsEmptyValues.contains(value)) {
				continue;
			}
			hasParsed = true;
			if (!isInteger(value)) {
				isDiscrete = false;
				break;
			}
		}
		if (hasParsed && isDiscrete)
			return new DatatypeWithPattern() {

				public Datatype getType() {
					return Datatype.DISCRETE;
				}

				public String getPattern() {
					return """";
				}
			};

		// check whether type is continuous
		final Pattern CONTINUOUS_PATTERN = Pattern
				.compile(""((-)?[0-9]*\\.[0-9]+)|((-)?[0-9]+(\\.[0-9]+)?(e|E)\\+[0-9]+)"");
		hasParsed = false;
		boolean isContinuous = true;
		for (String value : values) {
			if (value == null || value.isEmpty() || treatAsEmptyValues.contains(value)) {
				continue;
			}
			hasParsed = true;
			if (!CONTINUOUS_PATTERN.matcher(value).matches()) {
				isContinuous = false;
				break;
			}
		}
		if (hasParsed && isContinuous)
			return new DatatypeWithPattern() {

				public Datatype getType() {
					return Datatype.CONTINUOUS;
				}

				public String getPattern() {
					return """";
				}
			};

		// check whether type is date
		boolean isConsistentDateFormat = true;
		// Millisecond fix for Java SimpleDateFormat in case of a date like this 14:08:09.100000 
		// where the milliseconds would be treated as 100000ms instead of 100ms
		// Only matche when at the end of the string to avoid capturing year values when using the '.' as separator
		final Pattern INVALID_MS_PATTERN = Pattern.compile(""(\\.[0-9]{3})[0-9]*$""); 
		for (SimpleDateFormat formatter : StandardDateFormats.getStandardDateFormats()) {
			if (canParseAllValues(values, isConsistentDateFormat, INVALID_MS_PATTERN, formatter)) {
				final String pattern = formatter.toPattern();
				return new DatatypeWithPattern() {

					public Datatype getType() {
						return Datatype.TIME;
					}

					public String getPattern() {
						return pattern;
					}
				};
			}
		}

		return new DatatypeWithPattern() {

			public Datatype getType() {
				return Datatype.LITERAL;
			}

			public String getPattern() {
				return """";
			}
		};
	}

	private boolean canParseAllValues(List<String> values, boolean isConsistentDateFormat,
			final Pattern INVALID_MS_PATTERN, DateFormat formatter) {
		boolean hasParsed = false;
		for (String value : values) {
			if (value == null || value.isEmpty() || treatAsEmptyValues.contains(value))
				continue;

			// Millisecond fix for Java SimpleDateFormat
			String fixedValue = INVALID_MS_PATTERN.matcher(value).replaceFirst(""$1"");

			ParsePosition pos = new ParsePosition(0);
			pos.setIndex(0);
			Date date = formatter.parse(fixedValue, pos);

			hasParsed = true;

			// check whether date is not parsable, or date format for parsing is inconsistent
			if (date == null) {
				return false;
			}

		}
		return hasParsed;
	}

	public XFactory getFactory() {
		return factory;
	}

	public void setFactory(XFactory factory) {
		this.factory = factory;
	}

	public List<String> getCaseColumns() {
		return ImmutableList.copyOf(caseColumns);
	}

	public void setCaseColumns(List<String> caseColumns) {
		// Remove old mapping
		for (String caseColumn : this.caseColumns) {
			getConversionMap().get(caseColumn).setTraceAttributeName("""");
		}
		// Set new mapping
		for (String caseColumn : caseColumns) {
			if (caseColumn != null) {
				getConversionMap().get(caseColumn).setTraceAttributeName(""concept:name"");
				getConversionMap().get(caseColumn).setDataType(Datatype.LITERAL);	
			} else {
				throw new NullPointerException(""Tried to set a column with NULL identifier as case column!"");
			}
		}
		this.caseColumns = caseColumns;
	}

	public List<String> getEventNameColumns() {
		return ImmutableList.copyOf(eventNameColumns);
	}

	public void setEventNameColumns(List<String> eventNameColumns) {
		// Remove old mapping
		for (String eventColumn : this.eventNameColumns) {
			getConversionMap().get(eventColumn).setEventExtensionAttribute(NO_EXTENSION_ATTRIBUTE);
			getConversionMap().get(eventColumn).setEventAttributeName(eventColumn);
		}
		// Set new mapping
		for (String eventColumn : eventNameColumns) {
			if (eventColumn != null) {
				getConversionMap().get(eventColumn)
						.setEventExtensionAttribute(new ExtensionAttribute(""concept:name"", XConceptExtension.instance()));
				getConversionMap().get(eventColumn).setEventAttributeName(""concept:name"");
				getConversionMap().get(eventColumn).setDataType(Datatype.LITERAL);
			} else {
				throw new NullPointerException(""Tried to set a column with NULL identifier as event column!"");
			}
		}
		this.eventNameColumns = eventNameColumns;
	}

	public String getCompletionTimeColumn() {
		return completionTimeColumn;
	}

	private ExtensionAttribute previousCompletionTimeExtension;
	private Datatype previousCompletionTimeDataType;

	public void setCompletionTimeColumn(String completionTimeColumn) {
		// Reset mapping for old column		
		if (this.completionTimeColumn != null && !this.completionTimeColumn.isEmpty()) {
			getConversionMap().get(this.completionTimeColumn).setDataType(previousCompletionTimeDataType);
			getConversionMap().get(this.completionTimeColumn).setEventExtensionAttribute(previousCompletionTimeExtension);
			getConversionMap().get(this.completionTimeColumn).setEventAttributeName(this.completionTimeColumn);
		}

		if (completionTimeColumn != null && !completionTimeColumn.isEmpty()) {
			CSVMapping mapping = getConversionMap().get(completionTimeColumn);
			previousCompletionTimeDataType = mapping.getDataType();
			mapping.setDataType(Datatype.TIME);
			previousCompletionTimeExtension = mapping.getEventExtensionAttribute();
			mapping.setEventExtensionAttribute(new ExtensionAttribute(""time:timestamp"", XTimeExtension.instance()));
			mapping.setEventAttributeName(""time:timestamp"");
		}
		this.completionTimeColumn = completionTimeColumn;
	}

	public String getStartTimeColumn() {
		return startTimeColumn;
	}

	private ExtensionAttribute previousStartTimeExtension;
	private Datatype previousStartTimeDataType;

	public void setStartTimeColumn(String startTimeColumn) {
		// Reset mapping for old column
		if (this.startTimeColumn != null && !this.startTimeColumn.isEmpty()) {
			getConversionMap().get(this.startTimeColumn).setDataType(previousStartTimeDataType);
			getConversionMap().get(this.startTimeColumn).setEventExtensionAttribute(previousStartTimeExtension);
			getConversionMap().get(this.startTimeColumn).setEventAttributeName(this.startTimeColumn);
		}

		if (startTimeColumn != null && !startTimeColumn.isEmpty()) {
			CSVMapping mapping = getConversionMap().get(startTimeColumn);
			previousStartTimeDataType = mapping.getDataType();
			mapping.setDataType(Datatype.TIME);
			previousStartTimeExtension = mapping.getEventExtensionAttribute();
			mapping.setEventExtensionAttribute(new ExtensionAttribute(""time:timestamp"", XTimeExtension.instance()));
			mapping.setEventAttributeName(""time:timestamp"");
		}
		this.startTimeColumn = startTimeColumn;
	}

	public String getCompositeAttributeSeparator() {
		return compositeAttributeSeparator;
	}

	public void setCompositeAttributeSeparator(String compositeAttributeSeparator) {
		this.compositeAttributeSeparator = compositeAttributeSeparator;
	}

	public CSVErrorHandlingMode getErrorHandlingMode() {
		return errorHandlingMode;
	}

	public void setErrorHandlingMode(CSVErrorHandlingMode errorHandlingMode) {
		this.errorHandlingMode = errorHandlingMode;
	}

	public Map<String, CSVMapping> getConversionMap() {
		return conversionMap;
	}

	public Set<String> getTreatAsEmptyValues() {
		return treatAsEmptyValues;
	}

	public CSVEmptyCellHandlingMode getEmptyCellHandlingMode() {
		return emptyCellHandlingMode;
	}

	public void setEmptyCellHandlingMode(CSVEmptyCellHandlingMode emptyCellHandlingMode) {
		this.emptyCellHandlingMode = emptyCellHandlingMode;
	}

	public boolean isShouldAddStartEventAttributes() {
		return shouldAddStartEventAttributes;
	}

	public void setShouldAddStartEventAttributes(boolean shouldAddStartEventAttributes) {
		this.shouldAddStartEventAttributes = shouldAddStartEventAttributes;
	}

}"
CSVConversion.java,log,"package org.processmining.log.csvimport;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.nio.file.Files;
import java.text.DateFormat;
import java.text.MessageFormat;
import java.text.ParseException;
import java.text.ParsePosition;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import java.util.regex.Pattern;

import org.deckfour.xes.factory.XFactory;
import org.deckfour.xes.model.XLog;
import org.processmining.framework.plugin.Progress;
import org.processmining.log.csv.CSVFile;
import org.processmining.log.csv.CSVFileReferenceOpenCSVImpl;
import org.processmining.log.csv.ICSVReader;
import org.processmining.log.csv.config.CSVConfig;
import org.processmining.log.csvimport.config.CSVConversionConfig;
import org.processmining.log.csvimport.config.CSVConversionConfig.CSVEmptyCellHandlingMode;
import org.processmining.log.csvimport.config.CSVConversionConfig.CSVErrorHandlingMode;
import org.processmining.log.csvimport.config.CSVConversionConfig.CSVMapping;
import org.processmining.log.csvimport.exception.CSVConversionConfigException;
import org.processmining.log.csvimport.exception.CSVConversionException;
import org.processmining.log.csvimport.exception.CSVSortException;
import org.processmining.log.csvimport.handler.CSVConversionHandler;
import org.processmining.log.csvimport.handler.XESConversionHandlerImpl;

import com.google.common.collect.ObjectArrays;
import com.google.common.collect.Ordering;
import com.google.common.primitives.Ints;
import com.ning.compress.lzf.LZFInputStream;

/**
 * Conversion from CSV to a structure like XES. Use
 * {@link #doConvertCSVToXES(ProgressListener, CSVFile, CSVConfig, CSVConversionConfig)}
 * to convert to XES, use
 * {@link #convertCSV(ProgressListener, CSVConfig, CSVConversionConfig, CSVFile, CSVConversionHandler)}
 * to use your own {@link CSVConversionHandler} for some other format.
 * <p>
 * Example usage:
 * <p>
 * 
 * <pre>
 * CSVFileReferenceUnivocityImpl csvFile = new CSVFileReferenceUnivocityImpl(getFile().toPath());
 * CSVConfig config = new CSVConfig(csvFile);
 * try (ICSVReader reader = csvFile.createReader(config)) {
 * 	CSVConversion conversion = new CSVConversion();
 * 	CSVConversionConfig conversionConfig = new CSVConversionConfig(csvFile, config);
 * 	conversionConfig.autoDetect();
 * 
 * 	conversionConfig.setCaseColumns(ImmutableList.of(&quot;case&quot;));
 * 	conversionConfig.setEventNameColumns(ImmutableList.of(&quot;event&quot;));
 * 	conversionConfig.setCompletionTimeColumn(&quot;time&quot;);
 * 	conversionConfig.setEmptyCellHandlingMode(CSVEmptyCellHandlingMode.SPARSE);
 * 	conversionConfig.setErrorHandlingMode(CSVErrorHandlingMode.ABORT_ON_ERROR);
 * 	Map&lt;String, CSVMapping&gt; conversionMap = conversionConfig.getConversionMap();
 * 	CSVMapping mapping = conversionMap.get(&quot;time&quot;);
 * 	mapping.setDataType(Datatype.TIME);
 * 	mapping.setPattern(&quot;yyyy/MM/dd&quot;);
 * 
 * 	ConversionResult&lt;XLog&gt; result = conversion.doConvertCSVToXES(new NoOpProgressListenerImpl(), csvFile, config,
 * 			conversionConfig);
 * 
 * 	XLog log = result.getResult();
 * }
 * </pre>
 * 
 * @author F. Mannhardt
 *
 */
public final class CSVConversion {

	private static final int PROGRESS_REPORT_WINDOW = 10000;

	public interface ConversionResult<R> {
		R getResult();

		boolean hasConversionErrors();

		String getConversionErrors();
	}

	public interface ProgressListener {
		Progress getProgress();

		void log(String message);
	}

	public static class NoOpProgressListenerImpl implements ProgressListener {

		public void log(String message) {
		}

		public Progress getProgress() {
			return new NoOpProgressImpl();
		}

	}

	public static class NoOpProgressImpl implements Progress {

		public void setValue(int value) {
		}

		public void setMinimum(int value) {
		}

		public void setMaximum(int value) {
		}

		public void setIndeterminate(boolean makeIndeterminate) {
		}

		public void setCaption(String message) {
		}

		public boolean isIndeterminate() {
			return false;
		}

		public boolean isCancelled() {
			return false;
		}

		public void inc() {
		}

		public int getValue() {
			return 0;
		}

		public int getMinimum() {
			return 0;
		}

		public int getMaximum() {
			return 0;
		}

		public String getCaption() {
			return """";
		}

		public void cancel() {
		}

	}

	/**
	 * Convert a {@link CSVFileReferenceOpenCSVImpl} into an {@link XLog} using
	 * the supplied configuration. Without progress information.
	 * 
	 * @param csvFile
	 * @param importConfig
	 * @param conversionConfig
	 * @return
	 * @throws CSVConversionException
	 * @throws CSVConversionConfigException
	 */
	public ConversionResult<XLog> doConvertCSVToXES(CSVFile csvFile, CSVConfig importConfig,
			CSVConversionConfig conversionConfig) throws CSVConversionException, CSVConversionConfigException {
		return doConvertCSVToXES(new NoOpProgressListenerImpl(), csvFile, importConfig, conversionConfig);
	}

	/**
	 * Convert a {@link CSVFileReferenceOpenCSVImpl} into an {@link XLog} using
	 * the supplied configuration.
	 * 
	 * @param progressListener
	 * @param csvFile
	 * @param importConfig
	 * @param conversionConfig
	 * @return
	 * @throws CSVConversionException
	 * @throws CSVConversionConfigException
	 */
	public ConversionResult<XLog> doConvertCSVToXES(final ProgressListener progressListener, CSVFile csvFile,
			CSVConfig importConfig, CSVConversionConfig conversionConfig)
			throws CSVConversionException, CSVConversionConfigException {
		return convertCSV(progressListener, importConfig, conversionConfig, csvFile,
				new XESConversionHandlerImpl(importConfig, conversionConfig));
	}

	/**
	 * Converts a {@link CSVFileReferenceOpenCSVImpl} into something determined
	 * by the supplied {@link CSVConversionHandler}. Use
	 * {@link #doConvertCSVToXES(ProgressListener, CSVFileReferenceOpenCSVImpl, CSVConfig, CSVConversionConfig)}
	 * in case you want to convert to an {@link XLog}.
	 * 
	 * @param progress
	 * @param importConfig
	 * @param conversionConfig
	 * @param csvFile
	 * @param conversionHandler
	 * @return
	 * @throws CSVConversionException
	 * @throws CSVConversionConfigException
	 */
	public <R> ConversionResult<R> convertCSV(ProgressListener progress, CSVConfig importConfig,
			CSVConversionConfig conversionConfig, CSVFile csvFile, final CSVConversionHandler<R> conversionHandler)
			throws CSVConversionException, CSVConversionConfigException {

		Progress p = progress.getProgress();

		p.setMinimum(0);
		p.setMaximum(1);
		p.setValue(0);
		p.setIndeterminate(true);

		long startCSVTime = System.currentTimeMillis();

		conversionHandler.startLog(csvFile);

		int[] caseColumnIndex = new int[conversionConfig.getCaseColumns().size()];
		int[] eventNameColumnIndex = new int[conversionConfig.getEventNameColumns().size()];
		int completionTimeColumnIndex = -1;
		int startTimeColumnIndex = -1;
		String[] header = null;

		final Map<String, Integer> headerMap = new HashMap<>();
		final Map<Integer, CSVMapping> columnMap = new HashMap<>();

		try {
			header = csvFile.readHeader(importConfig);
			for (int i = 0; i < header.length; i++) {
				String columnHeader = header[i];
				Integer oldIndex = headerMap.put(columnHeader, i);
				if (oldIndex != null) {
					throw new CSVConversionException(String.format(
							""Ambigous header in the CSV file: Two columns (%s, %s) have the same header %s. Please fix this in the CSV file!"",
							oldIndex, i, columnHeader));
				}
				CSVMapping columnMapping = conversionConfig.getConversionMap().get(columnHeader);
				columnMap.put(i, columnMapping);
			}

			for (int i = 0; i < conversionConfig.getCaseColumns().size(); i++) {
				caseColumnIndex[i] = headerMap.get(conversionConfig.getCaseColumns().get(i));
			}
			for (int i = 0; i < conversionConfig.getEventNameColumns().size(); i++) {
				eventNameColumnIndex[i] = headerMap.get(conversionConfig.getEventNameColumns().get(i));
			}
			if (conversionConfig.getCompletionTimeColumn() != null
					&& !conversionConfig.getCompletionTimeColumn().isEmpty()) {
				completionTimeColumnIndex = headerMap.get(conversionConfig.getCompletionTimeColumn());
			}
			if (conversionConfig.getStartTimeColumn() != null && !conversionConfig.getStartTimeColumn().isEmpty()) {
				startTimeColumnIndex = headerMap.get(conversionConfig.getStartTimeColumn());
			}
		} catch (IOException e) {
			throw new CSVConversionException(""Could not read first row of CSV file with header information"", e);
		}

		InputStream sortedCsvInputStream = null;
		File sortedFile = null;

		try {
			try {
				long startSortTime = System.currentTimeMillis();
				int maxMemory = (int) ((Runtime.getRuntime().maxMemory() * maxSortingMemory) / 1024 / 1024);
				progress.log(
						String.format(""Sorting CSV file (%.2f MB) by case and time using maximal %s MB of memory ..."",
								(getFileSizeInBytes(csvFile) / 1024 / 1024), maxMemory));
				Ordering<String[]> caseComparator = new StringBasedImportOrdering(caseColumnIndex);
				sortedFile = CSVSorter.sortCSV(csvFile, caseComparator, importConfig, maxMemory, header.length,
						progress);
				sortedCsvInputStream = new LZFInputStream(new FileInputStream(sortedFile));
				long endSortTime = System.currentTimeMillis();
				progress.log(
						String.format(""Finished sorting in %.2f seconds"", (endSortTime - startSortTime) / 1000.0d));
			} catch (IllegalArgumentException e) {
				throw new CSVSortException(""Could not sort CSV file"", e);
			} catch (IOException e) {
				throw new CSVSortException(""Could not sort CSV file"", e);
			}

			// The following code assumes that the file is sorted by cases and written to disk compressed with LZF
			progress.log(""Reading cases ..."");
			try (ICSVReader reader = csvFile.getCSV().createReader(sortedCsvInputStream, importConfig)) {

				int caseIndex = 0;
				int eventIndex = 0;
				int lineIndex = -1;
				String[] nextLine;
				String currentCaseId = null;

				while ((nextLine = reader.readNext()) != null && (caseIndex % 100 != 0 || !p.isCancelled())) {
					lineIndex++;

					final String newCaseID = readCompositeAttribute(caseColumnIndex, nextLine,
							conversionConfig.getCompositeAttributeSeparator());

					// Handle new traces
					if (!newCaseID.equals(currentCaseId)) {

						if (currentCaseId != null) {
							// Finished with current case
							conversionHandler.endTrace(currentCaseId);
						}

						// Update current case id to next case id
						currentCaseId = newCaseID;

						// Create new case
						conversionHandler.startTrace(currentCaseId);
						caseIndex++;

						if (caseIndex % PROGRESS_REPORT_WINDOW == 0) {
							progress.log(""Reading line "" + lineIndex + "", already "" + caseIndex + "" cases and ""
									+ eventIndex + "" events processed ..."");
						}

					}

					// Create new event

					// Read event name
					final String eventClass = readCompositeAttribute(eventNameColumnIndex, nextLine,
							conversionConfig.getCompositeAttributeSeparator());

					// Read time stamps
					Date completionTime = parseTime(conversionHandler, completionTimeColumnIndex, columnMap, lineIndex,
							nextLine);
					Date startTime = parseTime(conversionHandler, startTimeColumnIndex, columnMap, lineIndex, nextLine);

					conversionHandler.startEvent(eventClass, completionTime, startTime);

					for (int i = 0; i < nextLine.length; i++) {
						if (Ints.contains(eventNameColumnIndex, i) || Ints.contains(caseColumnIndex, i)
								|| i == completionTimeColumnIndex || i == startTimeColumnIndex) {
							// Is already mapped to a special column, do not include again
							continue;
						}

						final String name = header[i];
						final String value = nextLine[i];

						if (!(conversionConfig.getEmptyCellHandlingMode() == CSVEmptyCellHandlingMode.SPARSE
								&& (value == null || conversionConfig.getTreatAsEmptyValues().contains(value)
										|| value.isEmpty()))) {
							parseAttributes(progress, conversionConfig, conversionHandler, columnMap.get(i), lineIndex,
									i, name, nextLine);
						}
					}

					// Already sorted by time
					conversionHandler.endEvent();
					eventIndex++;
				}

				// Close last trace
				if (currentCaseId != null) { // at least one trace is present
					conversionHandler.endTrace(currentCaseId);	
				}				

			} catch (IOException e) {
				throw new CSVConversionException(""Error converting the CSV file to XES"", e);
			}
		} finally {
			if (sortedCsvInputStream != null) {
				try {
					sortedCsvInputStream.close();
				} catch (Exception e) {
					throw new CSVConversionException(""Error closing the CSV file"", e);
				}
			}
			if (sortedFile != null) {
				sortedFile.delete();
			}
		}
		commitFactoryIfNeeded(conversionConfig.getFactory());
		long endConvertTime = System.currentTimeMillis();
		progress.log(String.format(""Finished reading cases in %d seconds."", (endConvertTime - startCSVTime) / 1000));

		return new ConversionResult<R>() {

			public R getResult() {
				return conversionHandler.getResult();
			}

			public boolean hasConversionErrors() {
				return conversionHandler.hasConversionErrors();
			}

			public String getConversionErrors() {
				return conversionHandler.getConversionErrors();
			}
		};
	}

	/**
	 * Calls the XESLite commit method if available. Uses reflection to not
	 * introduce a dependency on XESLite.
	 * 
	 * @param factory
	 */
	private void commitFactoryIfNeeded(XFactory factory) {
		try {
			Method method = factory.getClass().getMethod(""commit"");
			if (method != null) {
				method.invoke(factory);
			}
		} catch (NoSuchMethodException | SecurityException | IllegalAccessException | IllegalArgumentException
				| InvocationTargetException e) {
		}
	}

	private <R> Date parseTime(final CSVConversionHandler<R> conversionHandler, int timeColumnIndex,
			final Map<Integer, CSVMapping> columnMap, int lineIndex, String[] nextLine) throws CSVConversionException {
		if (timeColumnIndex == -1) {
			return null;
		} else {
			String timeValue = nextLine[timeColumnIndex];
			try {
				return parseDate((DateFormat) columnMap.get(timeColumnIndex).getFormat(), timeValue);
			} catch (ParseException e) {
				conversionHandler.errorDetected(lineIndex, timeColumnIndex,
						columnMap.get(timeColumnIndex).getEventAttributeName(), timeValue, e);
				return null;
			}
		}
	}

	private static double getFileSizeInBytes(CSVFile csvFile) throws IOException {
		return Files.size(csvFile.getFile());
	}

	private <R> void parseAttributes(ProgressListener progress, CSVConversionConfig conversionConfig,
			CSVConversionHandler<R> conversionHandler, CSVMapping csvMapping, int lineIndex, int columnIndex,
			String name, String[] line) throws CSVConversionException {

		String value = line[columnIndex];
		if (name == null) // TODO: Nicer would be to create names like ""unknown-1"", ""unknown-2"", etc. instead of skipping the attribute
			return;
		if (csvMapping.getDataType() == null) {
			conversionHandler.startAttribute(name, value);
		} else {
			try {
				switch (csvMapping.getDataType()) {
					case BOOLEAN :
						boolean boolVal;
						if (""true"".equalsIgnoreCase(value) || ""J"".equalsIgnoreCase(value) || ""Y"".equalsIgnoreCase(value)
								|| ""T"".equalsIgnoreCase(value) || ""1"".equals(value)) {
							boolVal = true;
						} else if (""false"".equalsIgnoreCase(value) || ""N"".equalsIgnoreCase(value)
								|| ""F"".equalsIgnoreCase(value) || ""0"".equals(value)) {
							boolVal = false;
						} else {
							throw new ParseException(value + "" cannot be converted to a boolean"", 0);
						}
						conversionHandler.startAttribute(name, boolVal);
						break;
					case CONTINUOUS :
						if (csvMapping.getFormat() != null) {
							conversionHandler.startAttribute(name, (Double) csvMapping.getFormat().parseObject(value));
						} else {
							conversionHandler.startAttribute(name, Double.parseDouble(value));
						}
						break;
					case DISCRETE :
						if (csvMapping.getFormat() != null) {
							conversionHandler.startAttribute(name, (Integer) csvMapping.getFormat().parseObject(value));
						} else {
							conversionHandler.startAttribute(name, Long.parseLong(value));
						}
						break;
					case TIME :
						conversionHandler.startAttribute(name, parseDate((DateFormat) csvMapping.getFormat(), value));
						break;
					case LITERAL :
					default :
						if (csvMapping.getFormat() != null) {
							value = ((MessageFormat) csvMapping.getFormat())
									.format(ObjectArrays.concat(value, line), new StringBuffer(), null).toString();
						}
						conversionHandler.startAttribute(name, value);
						break;
				}
			} catch (NumberFormatException e) {
				conversionHandler.errorDetected(lineIndex, columnIndex, name, value, e);
				if (conversionConfig.getErrorHandlingMode() == CSVErrorHandlingMode.BEST_EFFORT) {
					conversionHandler.startAttribute(name, value);
				}
			} catch (ParseException e) {
				conversionHandler.errorDetected(lineIndex, columnIndex, name, value, e);
				if (conversionConfig.getErrorHandlingMode() == CSVErrorHandlingMode.BEST_EFFORT) {
					conversionHandler.startAttribute(name, value);
				}
			}
		}
		conversionHandler.endAttribute();
	}

	/**
	 * Concatenates multiple composite attributes to a String representation.
	 * 
	 * @param columnIndex
	 * @param line
	 * @param compositeSeparator
	 * @return the composite attributes concatenated or an empty String in case
	 *         no columns are selected
	 */
	private static String readCompositeAttribute(int[] columnIndex, String[] line, String compositeSeparator) {
		if (columnIndex.length == 0) {
			return """";
		}
		int size = 0;
		for (int index : columnIndex) {
			String cell = line[index];
			size += (cell == null ? 0 : cell.length());
		}
		StringBuilder sb = new StringBuilder(size + columnIndex.length);
		for (int index : columnIndex) {
			String cell = line[index];
			if (cell != null) {
				sb.append(cell);
			}
			sb.append(compositeSeparator);
		}
		return sb.substring(0, sb.length() - 1);
	}

	private static Pattern INVALID_MS_PATTERN = Pattern.compile(""(:[0-5][0-9]\\.[0-9]{3})[0-9]*$"");
	private double maxSortingMemory = 0.30;

	private static Date parseDate(DateFormat customDateFormat, String value) throws ParseException {

		if (value == null) {
			throw new ParseException(""Could not parse NULL timestamp!"", 0);
		}

		if (customDateFormat != null) {
			ParsePosition pos = new ParsePosition(0);
			Date date = customDateFormat.parse(value, pos);
			
			// Fix if there are more than 3 digits for ms for example 44.00.540000, do not return and
			// ensure string is formatted to 540 ms instead of 540000 ms
			if (date != null && !INVALID_MS_PATTERN.matcher(value).find()) {
				return date;
			} else {
				String fixedValue = INVALID_MS_PATTERN.matcher(value).replaceFirst(""$1"");
				pos.setIndex(0);
				date = customDateFormat.parse(fixedValue, pos);
				if (date != null) {
					return date;
				} else {
					String pattern = ""unkown"";
					if (customDateFormat instanceof SimpleDateFormat) {
						pattern = ((SimpleDateFormat) customDateFormat).toPattern();
					}
					throw new ParseException(""Could not parse "" + value + "" using pattern '"" + pattern + ""'"",
							pos.getErrorIndex());
				}
			}
		}

		throw new ParseException(""Could not parse "" + value, -1);
	}

	public double getMaxSortingMemory() {
		return maxSortingMemory;
	}

	public void setMaxSortingMemory(double maxSortingMemory) {
		this.maxSortingMemory = maxSortingMemory;
	}

}
"
CSVConversionCLI.java,log,"package org.processmining.log.csvimport;

import java.io.File;
import java.io.IOException;
import java.io.PrintStream;

import org.apache.commons.cli.CommandLine;
import org.apache.commons.cli.CommandLineParser;
import org.apache.commons.cli.HelpFormatter;
import org.apache.commons.cli.Option;
import org.apache.commons.cli.OptionBuilder;
import org.apache.commons.cli.Options;
import org.apache.commons.cli.ParseException;
import org.apache.commons.cli.PosixParser;
import org.deckfour.xes.model.XLog;
import org.processmining.log.csv.CSVFile;
import org.processmining.log.csv.CSVFileReferenceUnivocityImpl;
import org.processmining.log.csv.config.CSVConfig;
import org.processmining.log.csvimport.CSVConversion.ConversionResult;
import org.processmining.log.csvimport.CSVConversion.ProgressListener;
import org.processmining.log.csvimport.config.CSVConversionConfig;
import org.processmining.log.csvimport.exception.CSVConversionConfigException;
import org.processmining.log.csvimport.exception.CSVConversionException;
import org.processmining.log.utils.XUtils;

import com.google.common.collect.ImmutableList;

/**
 * CLI interface to the ProM XES conversion
 * 
 * @author F. Mannhardt
 *
 */
public final class CSVConversionCLI {

	private static final class ProgressListenerPrintStreamImpl extends CSVConversion.NoOpProgressListenerImpl {

		private final PrintStream out;

		public ProgressListenerPrintStreamImpl(PrintStream out) {
			this.out = out;
		}

		public void log(String message) {
			out.println(message);
		}

	}

	private static final Options OPTIONS = new Options();

	private static final Option HELP = OptionBuilder.withDescription(""help"").create('h');
	private static final Option XES = OptionBuilder.hasArg().withArgName(""filename"").create(""xes"");
	private static final Option TRACE = OptionBuilder.hasArg().withArgName(""traceColumn"").create(""trace"");
	private static final Option EVENT = OptionBuilder.hasArg().withArgName(""eventColumn"").create(""event"");
	private static final Option START = OptionBuilder.hasArg().withArgName(""startColumn"").create(""start"");
	private static final Option COMPLETE = OptionBuilder.hasArg().withArgName(""completionColumn"").create(""complete"");

	static {
		OPTIONS.addOption(HELP);
		OPTIONS.addOption(XES);
		OPTIONS.addOption(TRACE);
		OPTIONS.addOption(EVENT);
		OPTIONS.addOption(START);
		OPTIONS.addOption(COMPLETE);
	}

	public static void main(String[] args) {

		try {
			CommandLineParser parser = new PosixParser();
			CommandLine commandLine = parser.parse(OPTIONS, args);

			if (commandLine.hasOption(HELP.getOpt())) {
				printUsage();
				return;
			}

			if (commandLine.getArgs().length != 1) {
				printUsage();
				System.err.println(""Missing filename of the CSV file!"");
				return;
			}

			File logFile = new File(commandLine.getArgs()[0]);

			try {
				XLog log = parseCSV(logFile, commandLine);

				if (commandLine.hasOption(XES.getOpt())) {
					XUtils.saveLogGzip(log, new File(commandLine.getOptionValue(XES.getOpt())));
				} else {
					XUtils.saveLogGzip(log, new File(logFile.getAbsolutePath() + "".xes.gz""));
				}
			} catch (CSVConversionException | IOException e) {
				if (e.getMessage() != null) {
					System.err.println(e.getMessage());
				}
				e.printStackTrace();
			}

			System.out.println(""Log converted successfully!"");

		} catch (ParseException e) {
			printUsage();
			if (e.getMessage() != null) {
				System.err.println(e.getMessage());
			}
		}
		
		System.exit(0);

	}

	private static XLog parseCSV(File inputFile, CommandLine commandLine) throws CSVConversionException, CSVConversionConfigException {
		CSVConversion conversion = new CSVConversion();
		CSVFile csvFile = new CSVFileReferenceUnivocityImpl(inputFile.toPath());
		CSVConfig importConfig = new CSVConfig(csvFile);
		CSVConversionConfig conversionConfig = new CSVConversionConfig(csvFile, importConfig);
		conversionConfig.autoDetect();

		if (commandLine.hasOption(TRACE.getOpt())) {
			conversionConfig.setCaseColumns(ImmutableList.of(commandLine.getOptionValue(TRACE.getOpt())));
		}
		
		if (commandLine.hasOption(EVENT.getOpt())) {
			conversionConfig.setEventNameColumns(ImmutableList.of(commandLine.getOptionValue(EVENT.getOpt())));
		}
		
		if (commandLine.hasOption(START.getOpt())) {
			conversionConfig.setStartTimeColumn(commandLine.getOptionValue(START.getOpt()));
		}
		
		if (commandLine.hasOption(COMPLETE.getOpt())) {
			conversionConfig.setCompletionTimeColumn(commandLine.getOptionValue(COMPLETE.getOpt()));
		}
		
		ProgressListener cmdLineProgressListener = new ProgressListenerPrintStreamImpl(System.out);
		ConversionResult<XLog> result = conversion.doConvertCSVToXES(cmdLineProgressListener, csvFile, importConfig,
				conversionConfig);
		return result.getResult();
	}

	private static void printUsage() {
		HelpFormatter helpFormatter = new HelpFormatter();
		helpFormatter.printHelp(""mpe [CSVFILE]"", OPTIONS, true);
		return;
	}

}"
CSVConversionPlugin.java,log,"package org.processmining.log.csvimport;

import java.io.IOException;

import javax.swing.JOptionPane;

import org.deckfour.uitopia.api.event.TaskListener.InteractionResult;
import org.deckfour.xes.model.XLog;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.Progress;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginLevel;
import org.processmining.framework.plugin.events.Logger.MessageLevel;
import org.processmining.framework.util.ui.widgets.helper.ProMUIHelper;
import org.processmining.log.csv.CSVFile;
import org.processmining.log.csv.config.CSVConfig;
import org.processmining.log.csvimport.CSVConversion.ConversionResult;
import org.processmining.log.csvimport.CSVConversion.ProgressListener;
import org.processmining.log.csvimport.config.CSVConversionConfig;
import org.processmining.log.csvimport.exception.CSVConversionConfigException;
import org.processmining.log.csvimport.exception.CSVConversionException;
import org.processmining.log.csvimport.handler.XESConversionHandlerImpl;
import org.processmining.log.csvimport.ui.ConversionConfigUI;
import org.processmining.log.csvimport.ui.ExpertConfigUI;
import org.processmining.log.csvimport.ui.ImportConfigUI;

import com.google.common.base.Throwables;

/**
 * CSV to XES XLog conversion plug-in
 * 
 * @author F. Mannhardt
 * 
 */
public final class CSVConversionPlugin {

	@Plugin(name = ""Convert CSV to XES"", level = PluginLevel.PeerReviewed, parameterLabels = { ""CSV"" }, returnLabels = {
			""XES Event Log"" }, // 
			returnTypes = { XLog.class }, userAccessible = true, mostSignificantResult = 1, // 
			keywords = { ""CSV"", ""OpenXES"", ""Conversion"",
					""Import"" }, help = ""Converts the CSV file to a OpenXES XLog object."")
	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = "" F. Mannhardt, N. Tax, D.M.M. Schunselaar"", // 
			email = ""f.mannhardt@tue.nl, n.tax@tue.nl, d.m.m.schunselaar@vu.nl"", pack = ""Log"")
	public XLog convertCSVToXES(final UIPluginContext context, CSVFile csvFile) {

		InteractionResult result = InteractionResult.CONTINUE;

		try {
			CSVConfig importConfig = new CSVConfig(csvFile);
			CSVConversionConfig csvConversionConfig = null;

			int i = 0;
			wizardLoop: while (result != InteractionResult.FINISHED) {
				switch (i) {
					case 0 :
						result = queryImportConfig(context, csvFile, importConfig);
						try {
							csvConversionConfig = new CSVConversionConfig(csvFile, importConfig);
							csvConversionConfig.autoDetect();
						} catch (CSVConversionException e) {								
							// Due to the strange wizard framework, we cannot cancel this dialog. So show again. The only way to cancel is through the user.
							if (result != InteractionResult.CANCEL) {
								ProMUIHelper.showErrorMessage(context, e.getMessage(), ""CSV Conversion Failed"");
								continue wizardLoop;	
							}
						}
						break;
					case 1 :
						result = queryConversionConfig(context, csvFile, importConfig, csvConversionConfig);
						if (result == InteractionResult.NEXT || result == InteractionResult.CONTINUE) {
							boolean reconfigure = queryMissingConfiguration(context, csvConversionConfig);
							if (reconfigure) {
								// Show same dialog again
								continue wizardLoop;
							}
						}
						break;
					case 2 :
						result = queryExpertConfig(context, csvFile, importConfig, csvConversionConfig);
						break;
				}
				if (result == InteractionResult.NEXT || result == InteractionResult.CONTINUE) {
					i++;
				} else if (result == InteractionResult.PREV) {
					i--;
				} else if (result == InteractionResult.CANCEL) {
					return cancel(context);
				}
			}

			CSVConversion csvConversion = new CSVConversion();
			ConversionResult<XLog> conversionResult = doConvertCSVToXes(context, csvFile, importConfig,
					csvConversionConfig, csvConversion);
			if (conversionResult.hasConversionErrors()) {
				ProMUIHelper.showWarningMessage(context, conversionResult.getConversionErrors(),
						""Warning: Some issues have been detected during conversion"");
			}
			return conversionResult.getResult();
		} catch (CSVConversionException e) {
			Throwable rootCause = Throwables.getRootCause(e);
			String errorMessage;
			if (rootCause != null) {
				errorMessage = rootCause.getMessage();
			} else {
				errorMessage = e.toString();
			}
			String stackTrace = Throwables.getStackTraceAsString(e);
			ProMUIHelper.showErrorMessage(context, errorMessage + ""\n\nDebug information:\n"" + stackTrace,
					""CSV Conversion Failed"");
			return cancel(context);
		}

	}

	private boolean queryMissingConfiguration(final UIPluginContext context, CSVConversionConfig csvConversionConfig) {
		boolean noCase = csvConversionConfig.getCaseColumns().isEmpty();
		boolean noEvents = csvConversionConfig.getEventNameColumns().isEmpty();
		Object[] options = { ""Continue"", ""Reconfigure"" };
		String message;
		String title;
		if (noCase) {
			message = ""<HTML>You did not select a column containing the case identifier. This will result in an event log with a single trace.<BR/> ""
					+ ""Do you want to continue without case identifier or reconfigure the conversion?</HTML>"";
			title = ""Missing event column"";
		} else if (noEvents) {
			message = ""<HTML>You did not select a column containing the event name. This will result in an event log with unamed events.<BR/> ""
					+ ""Do you want to continue without event name or reconfigure the conversion?</HTML>"";
			title = ""Missing event column"";
		} else if (noEvents && noCase) {
			message = ""You did not select columns containing the case identifier and event name. This will result in an event log with a single trace and unnamed events. ""
					+ ""Do you want to continue or reconfigure the conversion?"";
			title = ""Missing case and event columns"";
		} else {
			return false;
		}
		int warningResult = JOptionPane.showOptionDialog(context.getGlobalContext().getUI(), message, title,
				JOptionPane.PLAIN_MESSAGE, JOptionPane.WARNING_MESSAGE, null, options, options[0]);
		return warningResult == 1; // reconfigure
	}

	private XLog cancel(final UIPluginContext context) {
		context.getFutureResult(0).cancel(false);
		return null;
	}

	public ConversionResult<XLog> doConvertCSVToXes(final PluginContext context, CSVFile csvFile,
			CSVConfig importConfig, CSVConversionConfig conversionConfig, CSVConversion csvConversion)
			throws CSVConversionConfigException, CSVConversionException {

		ProgressListener progressListener = new ProgressListener() {

			public Progress getProgress() {
				return context.getProgress();
			}

			public void log(String message) {
				context.log(message);

			}
		};

		XESConversionHandlerImpl xesHandler = new XESConversionHandlerImpl(importConfig, conversionConfig);
		final ConversionResult<XLog> conversionResult = csvConversion.convertCSV(progressListener, importConfig,
				conversionConfig, csvFile, xesHandler);
		final XLog convertedLog = conversionResult.getResult();

		if (xesHandler.hasConversionErrors()) {
			context.log(xesHandler.getConversionErrors(), MessageLevel.WARNING);
		}

		return new ConversionResult<XLog>() {

			public boolean hasConversionErrors() {
				return conversionResult.hasConversionErrors();
			}

			public XLog getResult() {
				return convertedLog;
			}

			public String getConversionErrors() {
				return conversionResult.getConversionErrors();
			}
		};

	}

	public static InteractionResult queryExpertConfig(UIPluginContext context, CSVFile csv, CSVConfig importConfig,
			CSVConversionConfig converionConfig) {
		ExpertConfigUI expertConfigUI = new ExpertConfigUI(csv, importConfig, converionConfig);
		return context.showWizard(""Configure Additional Conversion Settings"", false, true, expertConfigUI);
	}

	public static InteractionResult queryImportConfig(UIPluginContext context, CSVFile csv, CSVConfig importConfig) {
		ImportConfigUI importConfigUI = new ImportConfigUI(csv, importConfig);
		return context.showWizard(""Configure CSV Parser Settings"", true, false, importConfigUI);
	}

	public static InteractionResult queryConversionConfig(UIPluginContext context, CSVFile csv, CSVConfig importConfig,
			CSVConversionConfig conversionConfig) throws CSVConversionException {
		try (ConversionConfigUI conversionConfigUI = new ConversionConfigUI(csv, importConfig, conversionConfig)) {
			return context.showWizard(""Configure Conversion from CSV to XES"", false, false, conversionConfigUI);
		} catch (IOException e) {
			throw new CSVConversionConfigException(""Could not query conversion config."", e);
		}
	}

}
"
CSVImportPlugin.java,log,"package org.processmining.log.csvimport;

import java.io.InputStream;

import org.deckfour.xes.model.XLog;
import org.processmining.framework.abstractplugins.AbstractImportPlugin;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.log.csv.CSVFile;
import org.processmining.log.csv.CSVFileReferenceOpenCSVImpl;

/**
 * Converts a {@link CSVFile} to {@link XLog}.
 * 
 * @author F. Mannhardt
 *
 */
// Old OpenCSV parser
//@Plugin(name = ""Import a CSV file and convert it to XES"", parameterLabels = { ""Filename"" }, returnLabels = { ""Imported CSV File"" }, returnTypes = { CSVFile.class })
//@UIImportPlugin(description = ""CSV File (XES Conversion with Log package)"", extensions = { ""csv"", ""zip"", ""csv.gz"", ""txt"" })
@Deprecated
final class CSVImportPlugin extends AbstractImportPlugin {

	@Override
	protected CSVFile importFromStream(final PluginContext context, final InputStream input, final String filename,
			final long fileSizeInBytes) throws Exception {
		context.getFutureResult(0).setLabel(""Imported CSV: ""+filename);
		return new CSVFileReferenceOpenCSVImpl(getFile().toPath(), filename, fileSizeInBytes);
	}

}
"
CSVImportPluginUnivocity.java,log,"package org.processmining.log.csvimport;

import java.io.InputStream;

import org.deckfour.xes.model.XLog;
import org.processmining.contexts.uitopia.annotations.UIImportPlugin;
import org.processmining.framework.abstractplugins.AbstractImportPlugin;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginLevel;
import org.processmining.log.csv.CSVFile;
import org.processmining.log.csv.CSVFileReferenceUnivocityImpl;

/**
 * Converts a {@link CSVFile} to {@link XLog}.
 * 
 * @author N. Tax
 *
 */
@Plugin(name = ""Import a CSV file and convert it to XES"", level= PluginLevel.PeerReviewed, parameterLabels = { ""Filename"" }, returnLabels = { ""Imported CSV File"" }, returnTypes = { CSVFile.class })
@UIImportPlugin(description = ""CSV File (XES Conversion with Log package)"", extensions = { ""csv"", ""zip"", ""csv.gz"", ""txt"", ""rpt"" })
public final class CSVImportPluginUnivocity extends AbstractImportPlugin {

	@Override
	protected CSVFile importFromStream(final PluginContext context, final InputStream input, final String filename,
			final long fileSizeInBytes) throws Exception {
		context.getFutureResult(0).setLabel(""Imported CSV: ""+filename);
		return new CSVFileReferenceUnivocityImpl(getFile().toPath());
	}

}
"
CSVSorter.java,log,"package org.processmining.log.csvimport;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.nio.file.Files;
import java.text.MessageFormat;
import java.util.Comparator;
import java.util.Iterator;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;

import org.processmining.log.csv.CSVFile;
import org.processmining.log.csv.ICSVReader;
import org.processmining.log.csv.ICSVWriter;
import org.processmining.log.csv.config.CSVConfig;
import org.processmining.log.csvimport.CSVConversion.ProgressListener;
import org.processmining.log.csvimport.exception.CSVSortException;

import com.fasterxml.sort.DataReader;
import com.fasterxml.sort.DataReaderFactory;
import com.fasterxml.sort.DataWriter;
import com.fasterxml.sort.DataWriterFactory;
import com.fasterxml.sort.IteratingSorter;
import com.fasterxml.sort.SortConfig;
import com.fasterxml.sort.SortingState.Phase;
import com.fasterxml.sort.TempFileProvider;
import com.ning.compress.lzf.LZFInputStream;
import com.ning.compress.lzf.parallel.PLZFOutputStream;

/**
 * Sorts an {@link CSVFile}
 * 
 * @author F. Mannhardt
 * 
 */
final class CSVSorter {

	private static final class UncompressedCSVReaderWithoutHeader extends DataReader<String[]> {

		private static final int MAX_COLUMNS_FOR_ERROR_REPORTING = 32;
		private static final int MAX_FIELD_LENGTH_FOR_ERROR_REPORTING = 64;

		private final ICSVReader reader;
		private final int numColumns;
		private int currentRow = 1;

		private UncompressedCSVReaderWithoutHeader(CSVFile csvFile, CSVConfig importConfig, int numColumns)
				throws IOException {
			this.numColumns = numColumns;
			this.reader = csvFile.createReader(importConfig);
			// Skip header line
			this.reader.readNext();
		}

		public void close() throws IOException {
			reader.close();
		}

		public int estimateSizeInBytes(String[] val) {
			return estimateSize(val);
		}

		public String[] readNext() throws IOException {
			String[] val = reader.readNext();
			if (val != null && val.length != numColumns) {
				String offendingLine = safeToString(val);
				throw new IOException(
						MessageFormat
								.format(""The number of fields in rows of the CSV file is inconsistent. There should be {0} fields in each row according to the header, but there was a row with {1} fields in the CSV file! Row {2} is invalid: {3}"",
										numColumns, val.length, currentRow, offendingLine));
			}
			currentRow++;
			return val;
		}

		private String safeToString(String[] valueArray) {
			if (valueArray == null) {
				return ""NULL"";
			} else if (valueArray.length == 0) {
				return ""[]"";
			} else {
				StringBuilder sb = new StringBuilder();
				sb.append('[');
				for (int i = 0; i < valueArray.length; i++) {
					String value = valueArray[i];
					if (value != null) {
						if (value.length() < MAX_FIELD_LENGTH_FOR_ERROR_REPORTING) {
							sb.append(value);
						} else {
							sb.append(value.substring(0, MAX_FIELD_LENGTH_FOR_ERROR_REPORTING - 1));
						}
						if (i > MAX_COLUMNS_FOR_ERROR_REPORTING) {
							return sb.append(String.format(""[... omitted %s further columns]"", valueArray.length - i))
									.toString();
						}
						if (i < valueArray.length - 1) {
							sb.append("", "");
						}
					}
				}
				return sb.append(']').toString();
			}
		}
	}

	private static final class CompressedCSVDataWriterFactory extends DataWriterFactory<String[]> {

		private final CSVConfig importConfig;
		private final CSVFile csvFile;

		private CompressedCSVDataWriterFactory(CSVFile csvFile, CSVConfig importConfig) {
			this.csvFile = csvFile;
			this.importConfig = importConfig;
		}

		public DataWriter<String[]> constructWriter(OutputStream os) throws IOException {
			final ICSVWriter writer = csvFile.getCSV().createWriter(new PLZFOutputStream(os), importConfig);
			// Write Header
			return new DataWriter<String[]>() {

				public void close() throws IOException {
					writer.close(); // catch IllegalStateException
				}

				public void writeEntry(String[] val) throws IOException {
					writer.writeNext(val);
				}
			};
		}
	}

	private static final class CompressedCSVDataReaderFactory extends DataReaderFactory<String[]> {

		private final CSVConfig importConfig;
		private final CSVFile csvFile;

		private CompressedCSVDataReaderFactory(CSVFile csvFile, CSVConfig importConfig) {
			this.csvFile = csvFile;
			this.importConfig = importConfig;
		}

		public DataReader<String[]> constructReader(InputStream is) throws IOException {
			final ICSVReader reader = csvFile.getCSV().createReader(new LZFInputStream(is), importConfig);
			return new DataReader<String[]>() {

				public void close() throws IOException {
					reader.close();
				}

				public int estimateSizeInBytes(String[] item) {
					return estimateSize(item);
				}

				public String[] readNext() throws IOException {
					return reader.readNext();
				}
			};
		}
	}

	private CSVSorter() {
	}

	/**
	 * Sorts an {@link CSVFile} using only a configurable, limited amount of
	 * memory.
	 * 
	 * @param csvFile
	 * @param rowComparator
	 * @param importConfig
	 * @param maxMemory
	 * @param numOfColumnsInCSV
	 * @param progress
	 * @return a {@link File} containing the sorted CSV
	 * @throws CSVSortException
	 */
	public static File sortCSV(final CSVFile csvFile, final Comparator<String[]> rowComparator,
			final CSVConfig importConfig, final int maxMemory, final int numOfColumnsInCSV,
			final ProgressListener progress) throws CSVSortException {

		// Create Sorter
		final CompressedCSVDataReaderFactory dataReaderFactory = new CompressedCSVDataReaderFactory(csvFile,
				importConfig);
		final CompressedCSVDataWriterFactory dataWriterFactory = new CompressedCSVDataWriterFactory(csvFile,
				importConfig);
		final IteratingSorter<String[]> sorter = new IteratingSorter<>(new SortConfig().withMaxMemoryUsage(
				maxMemory * 1024l * 1024l).withTempFileProvider(new TempFileProvider() {

			public File provide() throws IOException {
				return Files.createTempFile(csvFile.getFilename() + ""-merge-sort"", "".lzf"").toFile();
			}
		}), dataReaderFactory, dataWriterFactory, rowComparator);

		ExecutorService executorService = Executors.newSingleThreadExecutor();
		Future<File> future = executorService.submit(new Callable<File>() {

			public File call() throws Exception {

				// Read uncompressed CSV
				DataReader<String[]> inputDataReader = new UncompressedCSVReaderWithoutHeader(csvFile, importConfig,
						numOfColumnsInCSV);
				try {
					Iterator<String[]> result = sorter.sort(inputDataReader);

					// Write sorted result to compressed file
					if (result != null) {
						File sortedCsvFile = Files.createTempFile(csvFile.getFilename() + ""-sorted"", "".lzf"").toFile();
						DataWriter<String[]> dataWriter = dataWriterFactory.constructWriter(new FileOutputStream(
								sortedCsvFile));
						try {
							while (result.hasNext()) {
								dataWriter.writeEntry(result.next());
							}
						} finally {
							try {
								dataWriter.close();
							} catch (IllegalStateException e) {
								// already closed - ignore here to propagate the real exception
							}
						}
						return sortedCsvFile;
					} else {
						throw new CSVSortException(""Could not sort file! Unkown error while sorting."");
					}

				} finally {
					sorter.close();
				}

			}
		});

		try {
			executorService.shutdown();
			int sortRound = -1;
			int preSortFiles = -1;
			while (!executorService.awaitTermination(100, TimeUnit.MILLISECONDS)) {
				if (progress.getProgress().isCancelled()) {
					progress.log(""Cancelling sorting, this might take a while ..."");
					sorter.cancel(new RuntimeException(""Cancelled""));
					throw new CSVSortException(""User cancelled sorting"");
				}
				if (sorter.getPhase() == Phase.PRE_SORTING) {
					if (sorter.getSortRound() != sortRound) {
						sortRound = sorter.getSortRound();
						progress.log(MessageFormat.format(""Pre-sorting finished segment {0} in memory ..."",
								sortRound + 1));
					}
					if (sorter.getNumberOfPreSortFiles() != preSortFiles) {
						preSortFiles = sorter.getNumberOfPreSortFiles();
						progress.log(MessageFormat.format(""Pre-sorting finished segment {0} ..."", preSortFiles + 1));
					}
				} else if (sorter.getPhase() == Phase.SORTING) {
					if (sorter.getSortRound() != sortRound) {
						sortRound = sorter.getSortRound();
						progress.log(MessageFormat.format(""Sorting finished round {0}/{1} ..."", sortRound + 1,
								sorter.getNumberOfSortRounds() + 1));
					}
				}
			}
			return future.get();
		} catch (InterruptedException e) {
			progress.log(""Cancelling sorting, this might take a while ..."");
			sorter.cancel();
			throw new CSVSortException(""Cancelled sorting"", e);
		} catch (ExecutionException e) {
			throw new CSVSortException(""Could not sort file."", e);
		}
	}

	private static int estimateSize(String[] item) {
		int size = 8 * ((item.length * 4 + 12) / 8);
		for (String s : item) {
			if (s != null) {
				size += 8 * ((((s.length()) * 4) + 45) / 8);
			}
		}
		return size;
	}

}
"
CSVConversionConfigException.java,log,"package org.processmining.log.csvimport.exception;


/**
 * @author F. Mannhardt
 *
 */
public class CSVConversionConfigException extends CSVConversionException {

	private static final long serialVersionUID = 4329858720296484283L;

	public CSVConversionConfigException() {
	}

	public CSVConversionConfigException(String message) {
		super(message);
	}

	public CSVConversionConfigException(Throwable cause) {
		super(cause);
	}

	public CSVConversionConfigException(String message, Throwable cause) {
		super(message, cause);
	}

	public CSVConversionConfigException(String message, Throwable cause, boolean enableSuppression,
			boolean writableStackTrace) {
		super(message, cause, enableSuppression, writableStackTrace);
	}

}
"
CSVConversionException.java,log,"package org.processmining.log.csvimport.exception;


/**
 * @author F. Mannhardt
 *
 */
public class CSVConversionException extends Exception {

	private static final long serialVersionUID = -4532347650248107292L;

	public CSVConversionException() {
		super();
	}

	public CSVConversionException(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace) {
		super(message, cause, enableSuppression, writableStackTrace);
	}

	public CSVConversionException(String message, Throwable cause) {
		super(message, cause);
	}

	public CSVConversionException(String message) {
		super(message);
	}

	public CSVConversionException(Throwable cause) {
		super(cause);
	}
	

}
"
CSVSortException.java,log,"package org.processmining.log.csvimport.exception;

/**
 * @author F. Mannhardt
 *
 */
public class CSVSortException extends CSVConversionException {

	private static final long serialVersionUID = 5352796938595731289L;

	public CSVSortException() {
	}

	public CSVSortException(String message) {
		super(message);
	}

	public CSVSortException(Throwable cause) {
		super(cause);
	}

	public CSVSortException(String message, Throwable cause) {
		super(message, cause);
	}

	public CSVSortException(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace) {
		super(message, cause, enableSuppression, writableStackTrace);
	}

}
"
CSVConversionHandler.java,log,"package org.processmining.log.csvimport.handler;

import java.util.Date;

import org.processmining.log.csv.CSVFile;
import org.processmining.log.csvimport.exception.CSVConversionException;

/**
 * Handler for the conversion following a visitor-like pattern.
 * 
 * @author F. Mannhardt
 *
 * @param <R>
 */
public interface CSVConversionHandler<R> {

	/**
	 * Called upon start parsing the {@link CSVFile}.
	 * 
	 * @param inputFile
	 */
	void startLog(CSVFile inputFile);

	/**
	 * Called when a new trace is encountered. Traces are assumed to be sorted
	 * by caseId, therefore, this is only called once per trace.
	 * 
	 * @param caseId
	 */
	void startTrace(String caseId);

	/**
	 * Called after a traces has been fully parsed.
	 * 
	 * @param caseId
	 */
	void endTrace(String caseId);

	/**
	 * Called when parsing a row, thereby creating an event.
	 * 
	 * @param eventClass
	 *            the name (class) of the event
	 * @param completionTime
	 *            the completion time possibly NULL
	 * @param startTime
	 *            the start time possibly NULL
	 */
	void startEvent(String eventClass, Date completionTime, Date startTime);

	/**
	 * Called when a string attribute is parsed
	 * 
	 * @param name
	 * @param value
	 */
	void startAttribute(String name, String value);

	/**
	 * Called when a long attribute is parsed
	 * 
	 * @param name
	 * @param value
	 */
	void startAttribute(String name, long value);

	/**
	 * Called when a double attribute is parsed
	 * 
	 * @param name
	 * @param value
	 */
	void startAttribute(String name, double value);

	/**
	 * Called when a date attribute is parsed
	 * 
	 * @param name
	 * @param value
	 */
	void startAttribute(String name, Date value);

	/**
	 * Called when a boolean attribute is parsed
	 * 
	 * @param name
	 * @param value
	 */
	void startAttribute(String name, boolean value);

	/**
	 * Called after the attribute has been parsed
	 */
	void endAttribute();

	/**
	 * Called when the full row (including all attributes) have been parsed.
	 */
	void endEvent();

	/**
	 * Detected an error in the conversion.
	 * 
	 * @param lineNumber
	 * @param columnIndex
	 * @param attributeName
	 * @param cellContent
	 * @param e
	 * @throws CSVConversionException
	 */
	void errorDetected(int lineNumber, int columnIndex, String attributeName, Object cellContent, Exception e) throws CSVConversionException;

	/**
	 * @return the result of the parse
	 */
	R getResult();

	/**
	 * @return whether any errors have been encountered during the conversion
	 */
	boolean hasConversionErrors();

	/**
	 * @return a descriptive String of the error
	 */
	String getConversionErrors();

}
"
XESConversionHandlerImpl.java,log,"package org.processmining.log.csvimport.handler;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.Date;
import java.util.List;

import org.deckfour.xes.extension.XExtension;
import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.extension.std.XLifecycleExtension;
import org.deckfour.xes.extension.std.XLifecycleExtension.StandardModel;
import org.deckfour.xes.extension.std.XTimeExtension;
import org.deckfour.xes.factory.XFactory;
import org.deckfour.xes.info.impl.XLogInfoImpl;
import org.deckfour.xes.model.XAttributable;
import org.deckfour.xes.model.XAttribute;
import org.deckfour.xes.model.XAttributeBoolean;
import org.deckfour.xes.model.XAttributeContinuous;
import org.deckfour.xes.model.XAttributeDiscrete;
import org.deckfour.xes.model.XAttributeLiteral;
import org.deckfour.xes.model.XAttributeTimestamp;
import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.processmining.log.csv.CSVFile;
import org.processmining.log.csv.config.CSVConfig;
import org.processmining.log.csvimport.config.CSVConversionConfig;
import org.processmining.log.csvimport.config.CSVConversionConfig.CSVErrorHandlingMode;
import org.processmining.log.csvimport.config.CSVConversionConfig.CSVMapping;
import org.processmining.log.csvimport.config.CSVConversionConfig.ExtensionAttribute;
import org.processmining.log.csvimport.exception.CSVConversionException;
import org.processmining.log.utils.XUtils;

import com.google.common.collect.Ordering;

/**
 * Handler that creates an XLog from a CSV
 * 
 * @author F. Mannhardt
 *
 */
public class XESConversionHandlerImpl implements CSVConversionHandler<XLog> {

	private static final int MAX_ERROR_LENGTH = 1 * 1024 * 1024;

	private static final Comparator<? super XEvent> TIME_COMPARATOR = new Comparator<XEvent>() {

		public int compare(XEvent o1, XEvent o2) {
			// assumes stable sorting so start events will be always before complete events
			Date time1 = XUtils.getTimestamp(o1);
			Date time2 = XUtils.getTimestamp(o2);
			return Ordering.natural() // use Date built-in comparator
					.nullsFirst() // null aware since some events might not have times
					.compare(time1, time2);
		}
	};

	private final XFactory factory;
	private final CSVConversionConfig conversionConfig;
	private final StringBuilder conversionErrors;

	private XLog log = null;

	private XTrace currentTrace = null;
	private List<XEvent> currentEvents = new ArrayList<>();

	private int instanceCounter = 0;

	private XEvent currentEvent = null;
	private XEvent currentStartEvent;

	private boolean errorDetected = false;

	public XESConversionHandlerImpl(CSVConfig importConfig, CSVConversionConfig conversionConfig) {
		this.conversionConfig = conversionConfig;
		this.factory = conversionConfig.getFactory();
		this.conversionErrors = new StringBuilder();
	}

	@Override
	public String getConversionErrors() {
		if (conversionErrors.length() >= MAX_ERROR_LENGTH) {
			return conversionErrors.toString()
					.concat(""... (multiple error messages have been omitted to avoid running out of memory)"");
		} else {
			return conversionErrors.toString();
		}
	}

	@Override
	public boolean hasConversionErrors() {
		return conversionErrors.length() != 0;
	}

	@Override
	public void startLog(CSVFile inputFile) {
		log = factory.createLog();
		if (conversionConfig.getEventNameColumns() != null) {
			log.getExtensions().add(XConceptExtension.instance());
			log.getClassifiers().add(XLogInfoImpl.NAME_CLASSIFIER);
		}
		if (conversionConfig.getCompletionTimeColumn() != null || conversionConfig.getStartTimeColumn() != null) {
			log.getExtensions().add(XTimeExtension.instance());
			log.getExtensions().add(XLifecycleExtension.instance());
			log.getClassifiers().add(XUtils.STANDARDCLASSIFIER);
		}
		assignName(factory, log, inputFile.getFilename());
	}

	@Override
	public void startTrace(String caseId) {
		currentEvents.clear();
		errorDetected = false;
		currentTrace = factory.createTrace();
		assignName(factory, currentTrace, caseId);
	}

	@Override
	public void endTrace(String caseId) {
		if (errorDetected && conversionConfig.getErrorHandlingMode() == CSVErrorHandlingMode.OMIT_TRACE_ON_ERROR) {
			// Skip the entire trace
			return;
		}
		sortEventsByTimestamp();
		currentTrace.addAll(currentEvents);
		log.add(currentTrace);
	}

	private void sortEventsByTimestamp() {
		Collections.sort(currentEvents, TIME_COMPARATOR);
	}

	@Override
	public void startEvent(String eventClass, Date completionTime, Date startTime) {
		if (conversionConfig.getErrorHandlingMode() == CSVErrorHandlingMode.OMIT_EVENT_ON_ERROR) {
			// Include the other events in that trace
			errorDetected = false;
		}

		currentEvent = factory.createEvent();
		if (eventClass != null) {
			assignName(factory, currentEvent, eventClass);
		}

		if (startTime == null && completionTime == null) {
			// Both times are unknown only create an event assuming it is the completion event
			assignLifecycleTransition(factory, currentEvent, XLifecycleExtension.StandardModel.COMPLETE);
		} else if (startTime != null && completionTime != null) {
			// Both start and complete are present
			String instance = String.valueOf((instanceCounter++));

			// Assign attribute for complete event (currentEvent)			
			assignTimestamp(factory, currentEvent, completionTime);
			assignInstance(factory, currentEvent, instance);
			assignLifecycleTransition(factory, currentEvent, XLifecycleExtension.StandardModel.COMPLETE);

			// Add additional start event
			currentStartEvent = factory.createEvent();
			if (eventClass != null) {
				assignName(factory, currentStartEvent, eventClass);
			}
			assignTimestamp(factory, currentStartEvent, startTime);
			assignInstance(factory, currentStartEvent, instance);
			assignLifecycleTransition(factory, currentStartEvent, XLifecycleExtension.StandardModel.START);

		} else {
			// Either start or complete are present
			if (completionTime != null) {
				// Only create Complete
				assignTimestamp(factory, currentEvent, completionTime);
				assignLifecycleTransition(factory, currentEvent, XLifecycleExtension.StandardModel.COMPLETE);
			} else if (startTime != null) {
				// Only create Start
				assignTimestamp(factory, currentEvent, startTime);
				assignLifecycleTransition(factory, currentEvent, XLifecycleExtension.StandardModel.START);
			} else {
				throw new IllegalStateException(
						""Both start and complete time are NULL. This should never be the case here!"");
			}
		}
	}

	@Override
	public void startAttribute(String name, String value) {
		if (!specialColumn(name)) {
			assignAttribute(currentEvent, createLiteral(name, value));
			if (isShouldAddStartEventAttributes() && currentStartEvent != null) {
				assignAttribute(currentStartEvent, createLiteral(name, value));
			}
		}
	}

	private XAttributeLiteral createLiteral(String name, String value) {
		return factory.createAttributeLiteral(getNameFromConfig(name), value, getExtensionFromConfig(name));
	}

	@Override
	public void startAttribute(String name, long value) {
		if (!specialColumn(name)) {
			assignAttribute(currentEvent, createDiscrete(name, value));
			if (isShouldAddStartEventAttributes() && currentStartEvent != null) {
				assignAttribute(currentStartEvent, createDiscrete(name, value));
			}
		}
	}

	private XAttributeDiscrete createDiscrete(String name, long value) {
		return factory.createAttributeDiscrete(getNameFromConfig(name), value, getExtensionFromConfig(name));
	}

	@Override
	public void startAttribute(String name, double value) {
		if (!specialColumn(name)) {
			assignAttribute(currentEvent, createContinuous(name, value));
			if (isShouldAddStartEventAttributes() && currentStartEvent != null) {
				assignAttribute(currentStartEvent, createContinuous(name, value));
			}
		}
	}

	private XAttributeContinuous createContinuous(String name, double value) {
		return factory.createAttributeContinuous(getNameFromConfig(name), value, getExtensionFromConfig(name));
	}

	@Override
	public void startAttribute(String name, Date value) {
		if (!specialColumn(name)) {
			assignAttribute(currentEvent, createDate(name, value));
			if (isShouldAddStartEventAttributes() && currentStartEvent != null) {
				assignAttribute(currentStartEvent, createDate(name, value));
			}
		}
	}

	private XAttributeTimestamp createDate(String name, Date value) {
		return factory.createAttributeTimestamp(getNameFromConfig(name), value, getExtensionFromConfig(name));
	}

	@Override
	public void startAttribute(String name, boolean value) {
		if (!specialColumn(name)) {
			assignAttribute(currentEvent, createBoolean(name, value));
			if (isShouldAddStartEventAttributes() && currentStartEvent != null) {
				assignAttribute(currentStartEvent, createBoolean(name, value));
			}
		}
	}

	private XAttributeBoolean createBoolean(String name, boolean value) {
		return factory.createAttributeBoolean(getNameFromConfig(name), value, getExtensionFromConfig(name));
	}

	private XExtension getExtensionFromConfig(String name) {
		ExtensionAttribute extensionAttribute = getExtensionAttribute(name);
		return extensionAttribute == null ? null : extensionAttribute.extension;
	}

	private String getNameFromConfig(String columnName) {
		CSVMapping csvMapping = getMapping(columnName);
		if (csvMapping.getEventExtensionAttribute() != null
				&& csvMapping.getEventExtensionAttribute() != CSVConversionConfig.NO_EXTENSION_ATTRIBUTE) {
			return csvMapping.getEventExtensionAttribute().key;
		} else if (csvMapping.getEventAttributeName() != null && !csvMapping.getEventAttributeName().isEmpty()) {
			return csvMapping.getEventAttributeName();
		} else {
			return columnName;
		}
	}

	private ExtensionAttribute getExtensionAttribute(String name) {
		return getMapping(name).getEventExtensionAttribute();
	}

	private CSVMapping getMapping(String name) {
		return conversionConfig.getConversionMap().get(name);
	}

	@Override
	public void endAttribute() {
		//No-op
	}

	@Override
	public void endEvent() {
		if (errorDetected && conversionConfig.getErrorHandlingMode() == CSVErrorHandlingMode.OMIT_EVENT_ON_ERROR) {
			// Do not include the event
			return;
		}
		// Add start event before complete event to guarantee order for events with same time-stamp
		if (currentStartEvent != null) {
			currentEvents.add(currentStartEvent);
			currentStartEvent = null;
		}
		currentEvents.add(currentEvent);
		currentEvent = null;
	}

	public XLog getResult() {
		return log;
	}

	private static void assignAttribute(XAttributable a, XAttribute value) {
		XUtils.putAttribute(a, value);
	}

	private static void assignLifecycleTransition(XFactory factory, XAttributable a, StandardModel lifecycle) {
		assignAttribute(a, factory.createAttributeLiteral(XLifecycleExtension.KEY_TRANSITION, lifecycle.getEncoding(),
				XLifecycleExtension.instance()));
	}

	private static void assignInstance(XFactory factory, XAttributable a, String value) {
		assignAttribute(a,
				factory.createAttributeLiteral(XConceptExtension.KEY_INSTANCE, value, XConceptExtension.instance()));
	}

	private static void assignTimestamp(XFactory factory, XAttributable a, Date value) {
		assignAttribute(a,
				factory.createAttributeTimestamp(XTimeExtension.KEY_TIMESTAMP, value, XTimeExtension.instance()));
	}

	private static void assignName(XFactory factory, XAttributable a, String value) {
		assignAttribute(a,
				factory.createAttributeLiteral(XConceptExtension.KEY_NAME, value, XConceptExtension.instance()));
	}

	@Override
	public void errorDetected(int lineNumber, int columnIndex, String attributeName, Object content, Exception e)
			throws CSVConversionException {
		CSVErrorHandlingMode errorMode = conversionConfig.getErrorHandlingMode();
		errorDetected = true;
		String columnInfo = String.format(""Attribute '%s' with column index %s "", attributeName, columnIndex);
		switch (errorMode) {
			case BEST_EFFORT :
				if (conversionErrors.length() < MAX_ERROR_LENGTH) {
					conversionErrors.append(""Line: "" + lineNumber + "", "" + columnInfo + ""\n"" + ""Skipping attribute ""
							+ nullSafeToString(content) + ""\nError: "" + e + ""\n\n"");
				}
				break;
			case OMIT_EVENT_ON_ERROR :
				if (conversionErrors.length() < MAX_ERROR_LENGTH) {
					conversionErrors.append(
							""Line: "" + lineNumber + "", "" + columnInfo + ""\n"" + ""Skipping event, could not convert ""
									+ nullSafeToString(content) + ""\nError: "" + e + ""\n\n"");
				}
				break;
			case OMIT_TRACE_ON_ERROR :
				if (conversionErrors.length() < MAX_ERROR_LENGTH) {
					conversionErrors.append(""Line: "" + lineNumber + "", "" + columnInfo + ""\n"" + ""Skipping trace ""
							+ XUtils.getConceptName(currentTrace) + "", could not convert "" + nullSafeToString(content)
							+ ""\nError: "" + e + ""\n\n"");
				}
				break;
			default :
			case ABORT_ON_ERROR :
				throw new CSVConversionException(
						""Error converting "" + content + "" at line "" + lineNumber + ""and column "" + columnIndex, e);
		}
	}

	private static String nullSafeToString(Object obj) {
		if (obj == null) {
			return ""NULL"";
		} else if (obj.getClass().isArray()) {
			return Arrays.toString((Object[]) obj);
		} else {
			return obj.toString();
		}
	}

	private boolean specialColumn(String columnName) {
		return columnName == null
				|| (XConceptExtension.KEY_NAME.equals(columnName) && !conversionConfig.getEventNameColumns().isEmpty())
				|| (XTimeExtension.KEY_TIMESTAMP.equals(columnName)
						&& conversionConfig.getCompletionTimeColumn() != null)
				|| (XConceptExtension.KEY_INSTANCE.equals(columnName) && conversionConfig.getStartTimeColumn() != null);
	}

	public boolean isShouldAddStartEventAttributes() {
		return conversionConfig.isShouldAddStartEventAttributes();
	}

}"
StringBasedImportOrdering.java,log,"package org.processmining.log.csvimport;

import com.google.common.collect.Ordering;

final class StringBasedImportOrdering extends Ordering<String[]> {

	private final int[] sortingIndices;

	public StringBasedImportOrdering(int[] sortingIndicies) {
		this.sortingIndices = sortingIndicies;
	}

	public int compare(String[] o1, String[] o2) {
		if (o1.length != o2.length) {
			throw new IllegalArgumentException(
					""Can only compare lines in a CSV file with the same number of columns!"");
		}
		// First compare on all the case columns
		for (int i = 0; i < sortingIndices.length; i++) {
			int index = sortingIndices[i];
			// We treat empty and NULL cells as the same as there is no concept of a NULL cell in CSV 
			String s1 = o1[index] == null ? """" : o1[index];
			String s2 = o2[index] == null ? """" : o2[index];
			int comp = s1.compareTo(s2);
			if (comp != 0) {
				// Case ID is different on current index
				return comp;
			}
		}
		// Keep ordering -> using a stable sort algorithm
		return 0;
	}

}"
ConversionConfigUI.java,log,"package org.processmining.log.csvimport.ui;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.AdjustmentEvent;
import java.awt.event.AdjustmentListener;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.io.IOException;
import java.text.SimpleDateFormat;
import java.util.List;

import javax.swing.DefaultComboBoxModel;
import javax.swing.GroupLayout;
import javax.swing.GroupLayout.Alignment;
import javax.swing.GroupLayout.ParallelGroup;
import javax.swing.GroupLayout.SequentialGroup;
import javax.swing.JButton;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.SwingWorker;
import javax.swing.Timer;
import javax.swing.event.ListDataEvent;
import javax.swing.event.ListDataListener;

import org.processmining.framework.util.ui.widgets.ProMComboBox;
import org.processmining.framework.util.ui.widgets.ProMListSortableWithComboBox;
import org.processmining.framework.util.ui.widgets.ProMTextField;
import org.processmining.framework.util.ui.widgets.helper.ProMUIHelper;
import org.processmining.log.csv.CSVFile;
import org.processmining.log.csv.ICSVReader;
import org.processmining.log.csv.config.CSVConfig;
import org.processmining.log.csvimport.config.CSVConversionConfig;
import org.processmining.log.csvimport.config.CSVConversionConfig.CSVMapping;
import org.processmining.log.csvimport.ui.preview.CSVPreviewFrame;

import com.fluxicon.slickerbox.components.SlickerButton;
import com.fluxicon.slickerbox.factory.SlickerFactory;
import com.google.common.collect.Lists;

/**
 * UI for the configuration of the actual conversion
 * 
 * @author F. Mannhardt
 *
 */
public final class ConversionConfigUI extends CSVConfigurationPanel implements AutoCloseable {

	private static final int COLUMN_WIDTH = 360;

	private final class ChangeListenerImpl implements ActionListener {

		public void actionPerformed(ActionEvent e) {
			updateSettings();
		}

		public void updateSettings() {
			try {
				conversionConfig.setCaseColumns(caseComboBox.getElements());
				conversionConfig.setEventNameColumns(eventComboBox.getElements());
				conversionConfig.setStartTimeColumn(startTimeColumnCbx.getSelectedItem().toString());
				conversionConfig.setCompletionTimeColumn(completionTimeColumnCbx.getSelectedItem().toString());

				if (conversionConfig.getStartTimeColumn().isEmpty()) {
					startTimeFormat.setText("""");
					startTimeFormat.setEnabled(false);
				} else {
					startTimeFormat.setEnabled(true);
					if (hasManipulatedStartTime) {
						CSVMapping mapping = conversionConfig.getConversionMap()
								.get(conversionConfig.getStartTimeColumn());
						mapping.setPattern(startTimeFormat.getText());
					} else {
						// use originally guess format 
						startTimeFormat.setText(conversionConfig.getConversionMap()
								.get(conversionConfig.getStartTimeColumn()).getPattern());
					}
				}

				if (conversionConfig.getCompletionTimeColumn().isEmpty()) {
					completionTimeFormat.setText("""");
					completionTimeFormat.setEnabled(false);
				} else {
					completionTimeFormat.setEnabled(true);
					if (hasManipulatedCompletionTime) {
						CSVMapping mapping = conversionConfig.getConversionMap()
								.get(conversionConfig.getCompletionTimeColumn());
						mapping.setPattern(completionTimeFormat.getText());
					} else {
						// use originally guess format 
						completionTimeFormat.setText(conversionConfig.getConversionMap()
								.get(conversionConfig.getCompletionTimeColumn()).getPattern());
					}
				}
			} catch (RuntimeException e) {
				ProMUIHelper.showErrorMessage(previewFrame, e.getMessage() != null ? e.getMessage() : e.toString(), ""Error updating configuration"", e);
			}

			previewFrame.refresh();
		}

	}

	private final class LoadCSVRecordsWorker extends SwingWorker<Void, String[]> {
		protected Void doInBackground() throws Exception {
			String[] oldLine = null;
			String[] nextLine;
			int i = 0;
			while ((nextLine = reader.readNext()) != null && i < maxLoad) {
				if (oldLine != null) {
					if (oldLine.length != nextLine.length) {
						throw new IllegalArgumentException(
								""CSV file has inconsistent number of columns, please check CSV config."");
					}
				}
				publish(nextLine);
				oldLine = nextLine;
				i++;
			}
			return null;
		}

		protected void process(List<String[]> chunks) {
			previewFrame.addRows(chunks);
			previewFrame.setTitle(String.format(""CSV Preview (%s rows - scroll down to load more)"",
					previewFrame.getPreviewTable().getModel().getRowCount()));
		}
	}

	private static final long serialVersionUID = 2L;

	private static final int ACTION_DELAY = 500;

	private final CSVConversionConfig conversionConfig;

	private final String[] headers;
	private final String[] headersInclEmpty;

	private final ProMListSortableWithComboBox<String> caseComboBox;
	private final ProMListSortableWithComboBox<String> eventComboBox;
	private final ProMComboBox<String> completionTimeColumnCbx;
	private final ProMComboBox<String> startTimeColumnCbx;

	private final ChangeListenerImpl changeListener;
	private final Timer updateTimer;

	private final ICSVReader reader;
	private final CSVPreviewFrame previewFrame;
	private int maxLoad = 1000;

	private ProMTextField completionTimeFormat;
	private ProMTextField startTimeFormat;

	private boolean hasManipulatedStartTime = false;
	private boolean hasManipulatedCompletionTime = false;

	public ConversionConfigUI(final CSVFile csv, final CSVConfig importConfig, CSVConversionConfig conversionConfig)
			throws IOException {
		this.conversionConfig = conversionConfig;

		reader = csv.createReader(importConfig);
		headers = reader.readNext();
		headersInclEmpty = Lists.asList("""", headers).toArray(new String[headers.length + 1]);
		changeListener = new ChangeListenerImpl();
		updateTimer = new Timer(ACTION_DELAY, new ActionListener() {

			public void actionPerformed(ActionEvent e) {
				changeListener.updateSettings();
			}
		});
		updateTimer.setRepeats(false);

		GroupLayout layout = new GroupLayout(this);
		setLayout(layout);
		setMaximumSize(new Dimension(COLUMN_WIDTH * 2, Short.MAX_VALUE));
		layout.setAutoCreateContainerGaps(true);
		layout.setAutoCreateGaps(true);

		JLabel standardAttributesLabel = SlickerFactory.instance()
				.createLabel(""<HTML><H2>Mapping to Standard XES Attributes</H2></HTML>"");
		JButton showPreviewButton = new SlickerButton(""Show Expert Configuration"");
		showPreviewButton.addActionListener(new ActionListener() {

			public void actionPerformed(ActionEvent e) {
				togglePreviewFrame();
			}
		});

		caseComboBox = new ProMListSortableWithComboBox<>(new DefaultComboBoxModel<>(headers));
		JLabel caseLabel = createLabel(""Case Column (Optional)"",
				""Groups events into traces, and is mapped to 'concept:name' of the trace. Select one or more columns, re-order by drag & drop."");
		for (String caseColumn : conversionConfig.getCaseColumns()) {
			caseComboBox.addElement(caseColumn);
		}
		caseComboBox.getSelectedItemsText().setText(""Selected case columns:"");
		caseComboBox.getListModel().addListDataListener(new ListDataListener() {

			public void intervalRemoved(ListDataEvent e) {
				changeListener.updateSettings();
			}

			public void intervalAdded(ListDataEvent e) {
				changeListener.updateSettings();
			}

			public void contentsChanged(ListDataEvent e) {
				changeListener.updateSettings();
			}
		});

		eventComboBox = new ProMListSortableWithComboBox<>(new DefaultComboBoxModel<>(headers));
		JLabel eventLabel = createLabel(""Event Column (Optional)"",
				""Mapped to 'concept:name' of the event. Select one or more columns, re-order by drag & drop."");
		for (String eventColumn : conversionConfig.getEventNameColumns()) {
			eventComboBox.addElement(eventColumn);
		}
		eventComboBox.getSelectedItemsText().setText(""Selected event columns:"");
		eventComboBox.getListModel().addListDataListener(new ListDataListener() {

			public void intervalRemoved(ListDataEvent e) {
				changeListener.updateSettings();
			}

			public void intervalAdded(ListDataEvent e) {
				changeListener.updateSettings();
			}

			public void contentsChanged(ListDataEvent e) {
				changeListener.updateSettings();
			}
		});

		completionTimeColumnCbx = new ProMComboBox<>(headersInclEmpty);
		completionTimeColumnCbx.setToolTipText(
				""Mapped to 'time:timestamp' of the main event that is created for each row in the CSV file."");
		JLabel completionTimeLabel = createLabel(""Completion Time (Optional)"", ""Mapped to 'time:timestamp'"");
		if (conversionConfig.getCompletionTimeColumn() != null) {
			completionTimeColumnCbx.setSelectedItem(conversionConfig.getCompletionTimeColumn());
		} else {
			completionTimeColumnCbx.setSelectedItem("""");
		}
		completionTimeColumnCbx.addActionListener(new ActionListener() {

			public void actionPerformed(ActionEvent e) {
				hasManipulatedCompletionTime = false;
				changeListener.updateSettings();
			}
		});

		completionTimeFormat = new ProMTextField("""",
				""Could not auto-detect the used date format. Please provide a SimpleDateFormat pattern!"");
		if (conversionConfig.getCompletionTimeColumn() != null
				&& !conversionConfig.getCompletionTimeColumn().isEmpty()) {
			completionTimeFormat.setText(
					conversionConfig.getConversionMap().get(conversionConfig.getCompletionTimeColumn()).getPattern());
		}
		completionTimeFormat.addKeyListener(new KeyAdapter() {

			public void keyPressed(KeyEvent e) {
				hasManipulatedCompletionTime = true;
				update();
			}

			private void update() {
				try {
					new SimpleDateFormat(completionTimeFormat.getText());
					updateTimer.restart();
					completionTimeFormat.getTextField().setForeground(Color.WHITE);
				} catch (IllegalArgumentException e) {
					completionTimeFormat.getTextField().setForeground(Color.RED);
				}
			}

		});

		startTimeColumnCbx = new ProMComboBox<>(headersInclEmpty);
		startTimeColumnCbx.setToolTipText(
				""<HTML>Mapped to 'time:timestamp' of an extra 'start' event that is created for each row in the CSV file. ""
						+ ""<BR/>In case your lifecycle events such as 'start' are already separate row in the CSV file, please leave this empty and use the 'Expert Mode' to configure an appropriate mapping.</HTML>"");
		JLabel startTimeLabel = createLabel(""Start Time (Optional)"",
				""Mapped to 'time:timestamp' of a separate start event"");
		if (conversionConfig.getStartTimeColumn() != null) {
			startTimeColumnCbx.setSelectedItem(conversionConfig.getStartTimeColumn());
		} else {
			startTimeColumnCbx.setSelectedItem("""");
		}
		startTimeColumnCbx.addActionListener(new ActionListener() {

			public void actionPerformed(ActionEvent e) {
				hasManipulatedStartTime = false;
				changeListener.updateSettings();
			}
		});

		startTimeFormat = new ProMTextField("""",
				""Could not auto-detect the used date format. Please provide a SimpleDateFormat pattern!"");
		if (conversionConfig.getStartTimeColumn() != null && !conversionConfig.getStartTimeColumn().isEmpty()) {
			startTimeFormat.setText(
					conversionConfig.getConversionMap().get(conversionConfig.getStartTimeColumn()).getPattern());
		}

		startTimeFormat.addKeyListener(new KeyAdapter() {

			public void keyPressed(KeyEvent e) {
				hasManipulatedStartTime = true;
				update();
			}

			private void update() {
				try {
					new SimpleDateFormat(startTimeFormat.getText());
					updateTimer.restart();
					startTimeFormat.getTextField().setForeground(Color.WHITE);
				} catch (IllegalArgumentException e) {
					startTimeFormat.getTextField().setForeground(Color.RED);
				}
			}

		});

		SequentialGroup verticalGroup = layout.createSequentialGroup();
		verticalGroup.addGroup(layout.createParallelGroup(Alignment.CENTER).addComponent(standardAttributesLabel)
				.addComponent(showPreviewButton));
		verticalGroup.addGroup(layout.createParallelGroup()
				.addGroup(layout.createSequentialGroup().addComponent(caseLabel).addComponent(caseComboBox))
				.addGroup(layout.createSequentialGroup().addComponent(eventLabel).addComponent(eventComboBox)));
		verticalGroup.addGroup(layout.createParallelGroup()
				.addGroup(layout.createSequentialGroup().addComponent(startTimeLabel).addComponent(startTimeColumnCbx)
						.addComponent(startTimeFormat))
				.addGroup(layout.createSequentialGroup().addComponent(completionTimeLabel)
						.addComponent(completionTimeColumnCbx).addComponent(completionTimeFormat)));

		ParallelGroup horizontalGroup = layout.createParallelGroup();
		horizontalGroup.addGroup(
				layout.createSequentialGroup().addComponent(standardAttributesLabel).addComponent(showPreviewButton));
		horizontalGroup.addGroup(layout.createSequentialGroup()
				.addGroup(layout.createParallelGroup().addComponent(caseLabel, COLUMN_WIDTH, COLUMN_WIDTH, COLUMN_WIDTH)
						.addComponent(caseComboBox, COLUMN_WIDTH, COLUMN_WIDTH, COLUMN_WIDTH))
				.addGroup(
						layout.createParallelGroup().addComponent(eventLabel, COLUMN_WIDTH, COLUMN_WIDTH, COLUMN_WIDTH)
								.addComponent(eventComboBox, COLUMN_WIDTH, COLUMN_WIDTH, COLUMN_WIDTH)));
		horizontalGroup.addGroup(layout.createSequentialGroup()
				.addGroup(layout.createParallelGroup()
						.addComponent(startTimeLabel, COLUMN_WIDTH, COLUMN_WIDTH, COLUMN_WIDTH)
						.addComponent(startTimeColumnCbx, COLUMN_WIDTH, COLUMN_WIDTH, COLUMN_WIDTH)
						.addComponent(startTimeFormat, COLUMN_WIDTH, COLUMN_WIDTH, COLUMN_WIDTH))
				.addGroup(layout.createParallelGroup()
						.addComponent(completionTimeLabel, COLUMN_WIDTH, COLUMN_WIDTH, COLUMN_WIDTH)
						.addComponent(completionTimeColumnCbx, COLUMN_WIDTH, COLUMN_WIDTH, COLUMN_WIDTH)
						.addComponent(completionTimeFormat, COLUMN_WIDTH, COLUMN_WIDTH, COLUMN_WIDTH)));

		layout.linkSize(eventLabel, caseLabel);
		layout.linkSize(completionTimeLabel, startTimeLabel);

		layout.setAutoCreateContainerGaps(true);
		layout.setAutoCreateGaps(true);

		layout.setVerticalGroup(verticalGroup);
		layout.setHorizontalGroup(horizontalGroup);

		previewFrame = new CSVPreviewFrame(headers, conversionConfig);
		previewFrame.setTitle(""Expert Configuration & Preview - Scroll down to load more rows"");
		previewFrame.getMainScrollPane().getVerticalScrollBar().addAdjustmentListener(new AdjustmentListener() {

			public void adjustmentValueChanged(AdjustmentEvent e) {
				int maximum = e.getAdjustable().getMaximum();
				int current = e.getValue();
				if (Math.abs(maximum - current) < 1000 && !e.getValueIsAdjusting()) {
					new LoadCSVRecordsWorker().execute();
				}
			}
		});

		changeListener.updateSettings();
	}

	private void togglePreviewFrame() {
		if (!previewFrame.isVisible()) {
			previewFrame.showFrame(this);
			try {
				// Update Content
				new LoadCSVRecordsWorker().execute();
			} catch (Exception e) {
				JOptionPane.showMessageDialog(this, ""Error parsing CSV "" + e.getMessage(), ""CSV Parsing Error"",
						JOptionPane.ERROR_MESSAGE);
			}
		} else {
			previewFrame.setVisible(false);
		}
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see javax.swing.JComponent#addNotify()
	 */
	@Override
	public void addNotify() {
		super.addNotify();
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see javax.swing.JComponent#removeNotify()
	 */
	@Override
	public void removeNotify() {
		super.removeNotify();
		changeListener.updateSettings();
		previewFrame.save();
		previewFrame.setVisible(false);
	}

	public CSVConversionConfig getConversionConfig() {
		return conversionConfig;
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see java.lang.AutoCloseable#close()
	 */
	public void close() {
		try {
			reader.close();
		} catch (IOException e) {
			JOptionPane.showMessageDialog(null, e.toString());
		}
	}

}
"
CSVConfigurationPanel.java,log,"package org.processmining.log.csvimport.ui;

import java.awt.Font;

import javax.swing.JLabel;
import javax.swing.JPanel;

import com.fluxicon.slickerbox.factory.SlickerFactory;

public class CSVConfigurationPanel extends JPanel {

	private static final long serialVersionUID = 6462901867808436259L;

	protected static JLabel createLabel(String caption, String description) {
		JLabel eventLabel = SlickerFactory.instance().createLabel(
				""<HTML><B>"" + caption + ""</B><BR/><I>"" + description + ""</I></HTML>"");
		eventLabel.setFont(eventLabel.getFont().deriveFont(Font.PLAIN));
		return eventLabel;
	}


}
"
ExpertConfigUI.java,log,"package org.processmining.log.csvimport.ui;

import java.awt.Dimension;
import java.awt.Font;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.lang.reflect.InvocationTargetException;
import java.util.Set;

import javax.swing.GroupLayout;
import javax.swing.GroupLayout.Alignment;
import javax.swing.GroupLayout.ParallelGroup;
import javax.swing.GroupLayout.SequentialGroup;
import javax.swing.JLabel;

import org.deckfour.xes.factory.XFactory;
import org.deckfour.xes.factory.XFactoryRegistry;
import org.processmining.framework.util.ui.widgets.ProMComboBox;
import org.processmining.log.csv.CSVFile;
import org.processmining.log.csv.config.CSVConfig;
import org.processmining.log.csvimport.config.CSVConversionConfig;
import org.processmining.log.csvimport.config.CSVConversionConfig.CSVAttributeConversionMode;
import org.processmining.log.csvimport.config.CSVConversionConfig.CSVEmptyCellHandlingMode;
import org.processmining.log.csvimport.config.CSVConversionConfig.CSVErrorHandlingMode;

import com.fluxicon.slickerbox.factory.SlickerFactory;
import com.google.common.base.Function;
import com.google.common.collect.Iterables;

public class ExpertConfigUI extends CSVConfigurationPanel {

	private static final long serialVersionUID = 7749368962812585099L;

	private static final int COLUMN_WIDTH = 360;

	private static final class XFactoryUI {

		private final XFactory factory;

		public XFactoryUI(XFactory factory) {
			super();
			this.factory = factory;
		}

		public XFactory getFactory() {
			return factory;
		}

		@Override
		public String toString() {
			return factory.getName();
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;
			result = prime * result + ((factory == null) ? 0 : factory.hashCode());
			return result;
		}

		@Override
		public boolean equals(Object obj) {
			if (this == obj)
				return true;
			if (obj == null)
				return false;
			if (!(obj instanceof XFactoryUI))
				return false;
			XFactoryUI other = (XFactoryUI) obj;
			if (factory == null) {
				if (other.factory != null)
					return false;
			} else if (!factory.equals(other.factory))
				return false;
			return true;
		}

	}

	private final ProMComboBox<XFactoryUI> xFactoryChoice;
	private final ProMComboBox<CSVEmptyCellHandlingMode> emptyCellHandlingModeCbx;
	private final ProMComboBox<CSVErrorHandlingMode> errorHandlingModeCbx;
	private final ProMComboBox<CSVAttributeConversionMode> attributeConversionModeCbx;

	public ExpertConfigUI(final CSVFile csv, final CSVConfig importConfig, final CSVConversionConfig conversionConfig) {
		super();
		GroupLayout layout = new GroupLayout(this);
		setLayout(layout);
		setMaximumSize(new Dimension(COLUMN_WIDTH * 2, Short.MAX_VALUE));

		JLabel conversionOptionsLabel = SlickerFactory.instance().createLabel(
				""Additional Conversion Options (Defaults are a good guess)"");
		conversionOptionsLabel.setFont(conversionOptionsLabel.getFont().deriveFont(Font.BOLD, 20));

		xFactoryChoice = new ProMComboBox<>(Iterables.transform(getAvailableXFactories(),
				new Function<XFactory, XFactoryUI>() {

					public XFactoryUI apply(XFactory factory) {
						return new XFactoryUI(factory);
					}

				}));
		xFactoryChoice.setSelectedItem(new XFactoryUI(conversionConfig.getFactory()));
		JLabel xFactoryLabel = createLabel(
				""XFactory"",
				""XFactory implementation that is used to create the log. Some implementations might be more memory efficient, consider changing this in case you import a huge log."");

		xFactoryChoice.addActionListener(new ActionListener() {

			public void actionPerformed(ActionEvent e) {
				conversionConfig.setFactory(((XFactoryUI) xFactoryChoice.getSelectedItem()).getFactory());
			}
		});

		errorHandlingModeCbx = new ProMComboBox<>(CSVErrorHandlingMode.values());
		errorHandlingModeCbx.setSelectedItem(conversionConfig.getErrorHandlingMode());
		JLabel errorHandlingModeLabel = createLabel(""Error Handling"",
				""Stop conversion upon malformed input or try to import as much as possible?"");
		errorHandlingModeCbx.addActionListener(new ActionListener() {

			public void actionPerformed(ActionEvent e) {
				conversionConfig.setErrorHandlingMode((CSVErrorHandlingMode) errorHandlingModeCbx.getSelectedItem());
			}
		});

		emptyCellHandlingModeCbx = new ProMComboBox<>(CSVEmptyCellHandlingMode.values());
		emptyCellHandlingModeCbx.setSelectedItem(conversionConfig.getEmptyCellHandlingMode());
		JLabel emptyCellHandlingModeLabel = createLabel(
				""Sparse / Dense Log"",
				""Exclude (sparse) or include (dense) empty cells in the conversion. This affects how empty cells in the CSV are handled. ""
						+ ""Some plug-ins require the log to be dense, i.e., all attributes are defined for each event. ""
						+ ""In other cases it might be more efficient or even required to only add attributes to events if the attributes actually contain data."");
		emptyCellHandlingModeCbx.addActionListener(new ActionListener() {

			public void actionPerformed(ActionEvent e) {
				conversionConfig.setEmptyCellHandlingMode((CSVEmptyCellHandlingMode) emptyCellHandlingModeCbx
						.getSelectedItem());
			}
		});

		attributeConversionModeCbx = new ProMComboBox<>(CSVAttributeConversionMode.values());
		attributeConversionModeCbx
				.setSelectedItem(conversionConfig.isShouldAddStartEventAttributes() ? CSVAttributeConversionMode.ADD_TO_BOTH
						: CSVAttributeConversionMode.ADD_TO_COMPLETE);
		JLabel attributeConversionModeLabel = createLabel(
				""Attribute Conversion Mode"",
				""Add attributes either to both start and complete events, or only to the complete event. ""
				+ ""This is only relevant if your log contains information on the 'start' and 'completion' of an activity."");
		attributeConversionModeCbx.addActionListener(new ActionListener() {

			public void actionPerformed(ActionEvent e) {
				conversionConfig.setShouldAddStartEventAttributes(attributeConversionModeCbx.getSelectedItem() == CSVAttributeConversionMode.ADD_TO_BOTH);
			}
		});

		SequentialGroup verticalGroup = layout.createSequentialGroup();
		verticalGroup.addGroup(layout
				.createParallelGroup()
				.addGroup(
						layout.createSequentialGroup().addComponent(errorHandlingModeLabel)
								.addComponent(errorHandlingModeCbx))
				.addGroup(
						layout.createSequentialGroup().addComponent(xFactoryLabel)
								.addComponent(xFactoryChoice)));
		verticalGroup.addGroup(layout
				.createParallelGroup()
				.addGroup(
						layout.createSequentialGroup().addComponent(emptyCellHandlingModeLabel)
							.addComponent(emptyCellHandlingModeCbx))
				.addGroup(layout.createSequentialGroup().addComponent(attributeConversionModeLabel).addComponent(attributeConversionModeCbx)));

		ParallelGroup horizontalGroup = layout.createParallelGroup();
		horizontalGroup.addGroup(layout
				.createSequentialGroup()
				.addGroup(
						layout.createParallelGroup()
								.addComponent(errorHandlingModeLabel, Alignment.LEADING, COLUMN_WIDTH, COLUMN_WIDTH,
										COLUMN_WIDTH)
								.addComponent(errorHandlingModeCbx, COLUMN_WIDTH, COLUMN_WIDTH, COLUMN_WIDTH))
				.addGroup(
						layout.createParallelGroup()
								.addComponent(xFactoryLabel, COLUMN_WIDTH, COLUMN_WIDTH, COLUMN_WIDTH)
								.addComponent(xFactoryChoice, COLUMN_WIDTH, COLUMN_WIDTH, COLUMN_WIDTH)));
		horizontalGroup.addGroup(layout
				.createSequentialGroup()
				.addGroup(
						layout.createParallelGroup()
								.addComponent(emptyCellHandlingModeLabel, Alignment.LEADING, COLUMN_WIDTH, COLUMN_WIDTH,
										COLUMN_WIDTH)
								.addComponent(emptyCellHandlingModeCbx, COLUMN_WIDTH, COLUMN_WIDTH, COLUMN_WIDTH))
				.addGroup(
						layout.createParallelGroup()
								.addComponent(attributeConversionModeLabel, COLUMN_WIDTH, COLUMN_WIDTH, COLUMN_WIDTH)
								.addComponent(attributeConversionModeCbx, COLUMN_WIDTH, COLUMN_WIDTH, COLUMN_WIDTH)));

		layout.linkSize(errorHandlingModeLabel, xFactoryLabel, emptyCellHandlingModeLabel, attributeConversionModeLabel);

		layout.setAutoCreateContainerGaps(true);
		layout.setAutoCreateGaps(true);

		layout.setVerticalGroup(verticalGroup);
		layout.setHorizontalGroup(horizontalGroup);
	}

	private Set<XFactory> getAvailableXFactories() {
		//Try to register XESLite Factories
		tryRegisterFactory(""org.xeslite.lite.factory.XFactoryLiteImpl"");
		tryRegisterFactory(""org.xeslite.external.XFactoryExternalStore$MapDBDiskImpl"");
		tryRegisterFactory(""org.xeslite.external.XFactoryExternalStore$MapDBDiskWithoutCacheImpl"");
		tryRegisterFactory(""org.xeslite.external.XFactoryExternalStore$MapDBDiskSequentialAccessImpl"");
		tryRegisterFactory(""org.xeslite.external.XFactoryExternalStore$InMemoryStoreImpl"");
		return XFactoryRegistry.instance().getAvailable();
	}

	/**
	 * Tries to load the class and call the 'register' method.
	 * 
	 * @param className
	 */
	private void tryRegisterFactory(String className) {
		try {
			getClass().getClassLoader().loadClass(className).getDeclaredMethod(""register"").invoke(null);
		} catch (ClassNotFoundException | NoSuchMethodException | SecurityException | IllegalAccessException
				| IllegalArgumentException | InvocationTargetException e) {
		}
	}

}
"
ImportConfigUI.java,log,"package org.processmining.log.csvimport.ui;

import java.awt.Dimension;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.io.IOException;
import java.nio.charset.Charset;
import java.util.List;

import javax.swing.Box;
import javax.swing.BoxLayout;
import javax.swing.GroupLayout;
import javax.swing.GroupLayout.Alignment;
import javax.swing.GroupLayout.ParallelGroup;
import javax.swing.GroupLayout.SequentialGroup;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.SwingConstants;
import javax.swing.SwingWorker;

import org.processmining.framework.util.ui.widgets.ProMComboBox;
import org.processmining.framework.util.ui.widgets.helper.ProMUIHelper;
import org.processmining.log.csv.CSVFile;
import org.processmining.log.csv.ICSVReader;
import org.processmining.log.csv.config.CSVConfig;
import org.processmining.log.csv.config.CSVQuoteCharacter;
import org.processmining.log.csv.config.CSVSeperator;
import org.processmining.log.csvimport.ui.preview.CSVPreviewPanel;

/**
 * UI for the import configuration (charset, separator, ..)
 * 
 * @author F. Mannhardt
 *
 */
public final class ImportConfigUI extends CSVConfigurationPanel {

	private static final long serialVersionUID = 2L;

	private static final int MAX_PREVIEW = 1000;
	private static final int COLUMN_WIDTH = 240;

	private final CSVFile csv;
	private final CSVConfig importConfig;

	private final ProMComboBox<String> charsetCbx;
	private final ProMComboBox<CSVSeperator> separatorField;
	private final ProMComboBox<CSVQuoteCharacter> quoteField;

	private final CSVPreviewPanel previewPanel;

	private SwingWorker<Void, String[]> worker;

	public ImportConfigUI(final CSVFile csv, final CSVConfig importConfig) {
		super();
		this.importConfig = importConfig;
		this.csv = csv;
		this.previewPanel = new CSVPreviewPanel();

		setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));
		setOpaque(false);		

		JLabel header = new JLabel(""<HTML><H2>CSV Parser: Settings</H2></HTML>"");
		header.setAlignmentX(CENTER_ALIGNMENT);
		
		add(header);

		add(Box.createVerticalStrut(10));

		JPanel topPanel = new JPanel();
		
		GroupLayout layout = new GroupLayout(topPanel);
		layout.setAutoCreateContainerGaps(true);
		layout.setAutoCreateGaps(true);

		topPanel.setOpaque(false);
		topPanel.setLayout(layout);
		
		JPanel charsetPanel = new JPanel();
		charsetPanel.setOpaque(false);
		charsetPanel.setLayout(new BoxLayout(charsetPanel, BoxLayout.Y_AXIS));
		charsetCbx = new ProMComboBox<>(Charset.availableCharsets().keySet());
		charsetCbx.setSelectedItem(importConfig.getCharset());
		charsetCbx.setPreferredSize(null);
		charsetCbx.setMinimumSize(null);
		JLabel charsetLabel = createLabel(""Charset"", 
				""Configure the character encoding that is used by the CSV file"");
		charsetLabel.setAlignmentX(LEFT_ALIGNMENT);
		charsetCbx.setAlignmentX(LEFT_ALIGNMENT);
		charsetPanel.add(charsetLabel);
		charsetPanel.add(charsetCbx);
		charsetCbx.addActionListener(new ActionListener() {

			public void actionPerformed(ActionEvent e) {
				importConfig.setCharset(charsetCbx.getSelectedItem().toString());
				refreshPreview();
			}
		});

		JPanel separatorPanel = new JPanel();
		separatorPanel.setOpaque(false);
		separatorPanel.setLayout(new BoxLayout(separatorPanel, BoxLayout.Y_AXIS));
		separatorField = new ProMComboBox<>(CSVSeperator.values());
		separatorField.setPreferredSize(null);
		separatorField.setMinimumSize(null);
		separatorField.setSelectedItem(importConfig.getSeparator());
		JLabel seperationLabel = createLabel(""Separator Character"", 
				""Configure the character that is used by the CSV file to separate two fields"");
		seperationLabel.setAlignmentX(LEFT_ALIGNMENT);
		separatorField.setAlignmentX(LEFT_ALIGNMENT);
		separatorPanel.add(seperationLabel);
		separatorPanel.add(separatorField);
		separatorField.addActionListener(new ActionListener() {

			public void actionPerformed(ActionEvent e) {
				importConfig.setSeparator(((CSVSeperator) separatorField.getSelectedItem()));
				refreshPreview();
			}
		});

		JPanel quotePanel = new JPanel();
		quotePanel.setOpaque(false);
		quotePanel.setLayout(new BoxLayout(quotePanel, BoxLayout.Y_AXIS));
		quoteField = new ProMComboBox<>(CSVQuoteCharacter.values());
		quoteField.setPreferredSize(null);
		quoteField.setMinimumSize(null);
		JLabel quoteLabel = createLabel(""Quote Character"", 
				""Configure the character that is used by the CSV file that is used to quote values if they contain the separator character or a newline"");
		quoteLabel.setAlignmentX(LEFT_ALIGNMENT);
		quoteField.setAlignmentX(LEFT_ALIGNMENT);
		quotePanel.add(quoteLabel);
		quotePanel.add(quoteField);
		quoteField.addActionListener(new ActionListener() {

			public void actionPerformed(ActionEvent e) {
				importConfig.setQuoteChar((CSVQuoteCharacter) quoteField.getSelectedItem());
				refreshPreview();
			}
		});
		quoteField.setSelectedItem(importConfig.getQuoteChar());

		ParallelGroup verticalGroup = layout.createParallelGroup()
				.addComponent(charsetPanel, Alignment.TRAILING)
				.addComponent(separatorPanel, Alignment.TRAILING)
				.addComponent(quotePanel, Alignment.TRAILING);

		SequentialGroup horizontalGroup = layout.createSequentialGroup()
				.addComponent(charsetPanel, COLUMN_WIDTH, COLUMN_WIDTH, COLUMN_WIDTH)
				.addComponent(separatorPanel, COLUMN_WIDTH, COLUMN_WIDTH, COLUMN_WIDTH )
				.addComponent(quotePanel, COLUMN_WIDTH, COLUMN_WIDTH, COLUMN_WIDTH);

		layout.linkSize(SwingConstants.HORIZONTAL, separatorPanel, charsetPanel, quotePanel);
		
		layout.setAutoCreateContainerGaps(true);
		layout.setAutoCreateGaps(true);

		layout.setVerticalGroup(verticalGroup);
		layout.setHorizontalGroup(horizontalGroup);
		
		add(topPanel);
		previewPanel.setMaximumSize(new Dimension(725, 350));
		add(previewPanel);
	}

	private void refreshPreview() {

		if (worker != null) {
			worker.cancel(true);
		}

		previewPanel.clear();

		// Update Header
		try {
			previewPanel.setHeader(csv.readHeader(importConfig));
		} catch (IOException | ArrayIndexOutOfBoundsException e) {
			ProMUIHelper.showWarningMessage(this, ""Error parsing CSV "" + e.getMessage(), ""CSV Parsing Error"");
			return;
		}

		worker = new SwingWorker<Void, String[]>() {

			protected Void doInBackground() throws Exception {

				try (ICSVReader reader = csv.createReader(importConfig)) {
					// Skip header
					reader.readNext();
					String[] nextLine;
					int i = 0;
					while ((nextLine = reader.readNext()) != null && i < MAX_PREVIEW) {
						publish(nextLine);
						i++;
					}
				}

				return null;
			}

			protected void process(List<String[]> chunks) {
				for (String[] row : chunks) {
					previewPanel.addRow(row);
				}
			}

		};

		try {
			worker.execute();
		} catch (Exception e) {
			JOptionPane.showMessageDialog(this, ""Error parsing CSV "" + e.getMessage(), ""CSV Parsing Error"",
					JOptionPane.ERROR_MESSAGE);
		}
	}

	public CSVConfig getImportConfig() {
		return importConfig;
	}

}"
CSVPreviewFrame.java,log,"package org.processmining.log.csvimport.ui.preview;

import java.awt.Component;
import java.awt.Dimension;
import java.awt.Frame;
import java.awt.GraphicsDevice;
import java.awt.GraphicsEnvironment;
import java.util.Enumeration;
import java.util.List;
import java.util.Vector;

import javax.swing.AbstractCellEditor;
import javax.swing.Box;
import javax.swing.BoxLayout;
import javax.swing.DefaultCellEditor;
import javax.swing.DefaultComboBoxModel;
import javax.swing.JComboBox;
import javax.swing.JComponent;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JTable;
import javax.swing.JTextField;
import javax.swing.ListSelectionModel;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ListSelectionEvent;
import javax.swing.event.TableColumnModelEvent;
import javax.swing.event.TableColumnModelListener;
import javax.swing.table.AbstractTableModel;
import javax.swing.table.DefaultTableModel;
import javax.swing.table.TableCellEditor;
import javax.swing.table.TableColumn;
import javax.swing.table.TableColumnModel;
import javax.swing.table.TableModel;

import org.processmining.framework.util.ui.widgets.ProMScrollPane;
import org.processmining.framework.util.ui.widgets.ProMTableWithoutPanel;
import org.processmining.log.csvimport.config.CSVConversionConfig;
import org.processmining.log.csvimport.config.CSVConversionConfig.CSVMapping;
import org.processmining.log.csvimport.config.CSVConversionConfig.Datatype;
import org.processmining.log.csvimport.config.CSVConversionConfig.ExtensionAttribute;

/**
 * Frame showing a part of the CSV file.
 * 
 * @author F. Mannhardt
 * 
 */
public final class CSVPreviewFrame extends JFrame {

	private final class MappingCellEditor extends AbstractCellEditor implements TableCellEditor {

		private static final long serialVersionUID = -8465152263165430372L;

		private TableCellEditor editor;

		public Object getCellEditorValue() {
			if (editor != null) {
				return editor.getCellEditorValue();
			}
			return null;
		}

		public Component getTableCellEditorComponent(JTable table, Object value, boolean isSelected, int row, int column) {
			if (value instanceof Datatype) {
				editor = new DefaultCellEditor(new JComboBox<>(new DefaultComboBoxModel<>(Datatype.values())));
			} else if (value instanceof String) {
				editor = new DefaultCellEditor(new JTextField());
			} else if (value instanceof ExtensionAttribute) {
				editor = new DefaultCellEditor(new JComboBox<ExtensionAttribute>(
						CSVConversionConfig.AVAILABLE_EVENT_EXTENSIONS_ATTRIBUTES));
			} else {
				throw new RuntimeException(""Unkown value type "" + value.getClass().getSimpleName());
			}
			return editor.getTableCellEditorComponent(table, value, isSelected, row, column);
		}
	}

	private final class BatchUpdateDefaultTableModel extends DefaultTableModel {

		private static final long serialVersionUID = 1L;

		private BatchUpdateDefaultTableModel(Vector<String> columnNames, int rowCount) {
			super(columnNames, rowCount);
		}

		@SuppressWarnings(""unchecked"")
		public void addRows(List<String[]> rowData) {
			int firstRow = dataVector.size();
			for (Object[] row : rowData) {
				dataVector.add(convertToVector(row));
			}
			int lastRow = dataVector.size() - 1;
			fireTableRowsInserted(firstRow, lastRow);
		}

	}

	public static class DataTypeTableModel extends AbstractTableModel {

		private static final long serialVersionUID = 1L;

		private final CSVConversionConfig conversionConfig;
		private final String[] header;

		public DataTypeTableModel(CSVConversionConfig conversionConfig, String[] header) {
			this.conversionConfig = conversionConfig;
			this.header = header;
		}

		public int getRowCount() {
			return 5;
		}

		public void setValueAt(Object aValue, int rowIndex, int columnIndex) {
			String columnHeader = header[columnIndex];
			CSVMapping csvMapping = conversionConfig.getConversionMap().get(columnHeader);
			switch (rowIndex) {
				case 0 :
					Datatype newType = (Datatype) aValue;
					if (csvMapping.getDataType() != newType) {
						csvMapping.setPattern("""");
						fireTableCellUpdated(1, columnIndex);
					}
					csvMapping.setDataType(newType);
					break;
				case 1 :
					csvMapping.setPattern((String) aValue);
					break;
				case 2 :
					csvMapping.setTraceAttributeName((String) aValue);
					break;
				case 3 :
					if (aValue != null) {
						ExtensionAttribute extAttr = (ExtensionAttribute) aValue;
						if (extAttr != CSVConversionConfig.NO_EXTENSION_ATTRIBUTE) {
							csvMapping.setEventExtensionAttribute(extAttr);
							csvMapping.setEventAttributeName(extAttr.key);
						} else {
							csvMapping.setEventExtensionAttribute(CSVConversionConfig.NO_EXTENSION_ATTRIBUTE);
							csvMapping.setEventAttributeName(nullSafe(columnHeader));
						}
					} else {
						csvMapping.setEventExtensionAttribute(null);
						csvMapping.setEventAttributeName(nullSafe(columnHeader));
					}
					fireTableCellUpdated(4, columnIndex);
					break;
				case 4 :
					csvMapping.setEventAttributeName((String) aValue);
					break;
				default :
					throw new IllegalStateException(""Could not find value at row "" + rowIndex + "" column ""
							+ columnIndex);
			}
			conversionConfig.getConversionMap().put(columnHeader, csvMapping);
		}

		private static String nullSafe(String s) {
			return s == null ? """" : s;
		}

		public Object getValueAt(int rowIndex, int columnIndex) {
			String columnHeader = header[columnIndex];
			CSVMapping csvMapping = conversionConfig.getConversionMap().get(columnHeader);
			switch (rowIndex) {
				case 0 :
					return csvMapping.getDataType();
				case 1 :
					return csvMapping.getPattern();
				case 2 :
					return csvMapping.getTraceAttributeName();
				case 3 :
					return csvMapping.getEventExtensionAttribute();
				case 4 :
					return csvMapping.getEventAttributeName();
			}
			throw new IllegalStateException(""Could not find value at row "" + rowIndex + "" column "" + columnIndex);
		}

		public int getColumnCount() {
			return header.length;
		}

		public String getColumnName(int column) {
			return nullSafe(header[column]);
		}

		public Class<?> getColumnClass(int columnIndex) {
			return super.getColumnClass(columnIndex);
		}

		public boolean isCellEditable(int rowIndex, int columnIndex) {
			return rowIndex == 2 ? false : true;
		}

	}

	private static final long serialVersionUID = 1L;

	private final BatchUpdateDefaultTableModel previewTableModel;
	private final JTable previewTable;
	private final JScrollPane mainScrollPane;

	private JTable datatypeTable;

	public CSVPreviewFrame() {
		this(null);
	}

	public CSVPreviewFrame(String[] header) {
		this(null, null);
	}

	@SuppressWarnings(""serial"")
	public CSVPreviewFrame(String[] header, CSVConversionConfig conversionConfig) {
		super();
		setTitle(""CSV Import: Preview of the Import"");
		getContentPane().setLayout(new BoxLayout(getContentPane(), BoxLayout.Y_AXIS));

		Vector<String> columnIds = prepareNullSafeColumnNames(header);
		previewTableModel = new BatchUpdateDefaultTableModel(columnIds, 0);
		previewTable = new ProMTableWithoutPanel(previewTableModel);
		previewTable.setAutoResizeMode(JTable.AUTO_RESIZE_OFF);
		Enumeration<TableColumn> columns = previewTable.getColumnModel().getColumns();
		while (columns.hasMoreElements()) {
			final TableColumn column = columns.nextElement();
			column.setPreferredWidth(130);
			column.setCellEditor(new DefaultCellEditor(new JTextField()) {

				protected void fireEditingStopped() {
					this.cancelCellEditing();
					super.fireEditingStopped();
				}

				protected void fireEditingCanceled() {
					super.fireEditingCanceled();
				}

			});
		}
		previewTable.getColumnModel().setColumnSelectionAllowed(false);
		previewTable.getTableHeader().setReorderingAllowed(false);

		mainScrollPane = new ProMScrollPane(previewTable);

		JPanel mainPanel = new JPanel();
		mainPanel.setLayout(new BoxLayout(mainPanel, BoxLayout.X_AXIS));

		JPanel rightPanel = new JPanel();
		rightPanel.setLayout(new BoxLayout(rightPanel, BoxLayout.Y_AXIS));

		if (conversionConfig != null) {
			TableModel dataModel = new DataTypeTableModel(conversionConfig, header);
			datatypeTable = new JTable(dataModel);
			datatypeTable.setTableHeader(null);
			datatypeTable.setDefaultEditor(Object.class, new MappingCellEditor());
			datatypeTable.setAutoResizeMode(JTable.AUTO_RESIZE_OFF);
			datatypeTable.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
			ProMScrollPane dataTypeScrollpane = new ProMScrollPane(datatypeTable) {

				public Dimension getPreferredSize() {
					Dimension preferredSize = super.getPreferredSize();
					preferredSize.height = datatypeTable.getPreferredSize().height;
					preferredSize.width = Short.MAX_VALUE;
					return preferredSize;
				}

				public Dimension getMaximumSize() {
					return getPreferredSize();
				}

			};
			dataTypeScrollpane.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_NEVER);
			getMainScrollPane().setHorizontalScrollBar(dataTypeScrollpane.getHorizontalScrollBar());

			previewTable.getColumnModel().addColumnModelListener(new TableColumnModelListener() {

				public void columnSelectionChanged(ListSelectionEvent e) {
				}

				public void columnRemoved(TableColumnModelEvent e) {
				}

				public void columnMoved(TableColumnModelEvent e) {
				}

				public void columnMarginChanged(ChangeEvent e) {
					final TableColumnModel tableColumnModel = previewTable.getColumnModel();
					TableColumnModel dataTypeColumnModel = datatypeTable.getColumnModel();
					for (int i = 0; i < tableColumnModel.getColumnCount(); i++) {
						int w = tableColumnModel.getColumn(i).getWidth();
						dataTypeColumnModel.getColumn(i).setMinWidth(w);
						dataTypeColumnModel.getColumn(i).setMaxWidth(w);
					}
					datatypeTable.doLayout();
					datatypeTable.repaint();
					repaint();
				}

				public void columnAdded(TableColumnModelEvent e) {
				}

			});

			JPanel leftPanel = new JPanel();
			leftPanel.setLayout(new BoxLayout(leftPanel, BoxLayout.Y_AXIS));
			JLabel dataType = new JLabel(""Data Type"");
			leftPanel.add(dataType);
			JLabel dataPattern = new JLabel(""Data Pattern"");
			dataPattern
					.setToolTipText(""<HTML>Pattern describing how to parse the value to the selected data type. </BR>""
							+ ""<ul><li>For 'DATE' this is a pattern parseable by SimpleDateFormat,</li> ""
							+ ""<li>for 'DISCRETE' and 'CONTINUOUS' this is a pattern parseable by DecimalFormat, ""
							+ ""<li>for 'LITERAL' this is parsed by MessageFormat whereby the first parameter {0} is the value in the column itself, and the following parameters {1}-{n} are the values in the other columns starting from the first column (including the selected column itself).<li>""
							+ ""<HTML>"");
			leftPanel.add(dataPattern);
			JLabel traceAttribute = new JLabel(""Trace Attribute"");
			traceAttribute.setToolTipText(""Attribute in the trace (Read-only)"");
			leftPanel.add(traceAttribute);
			JLabel extensionAttribute = new JLabel(""XES Extension"");
			extensionAttribute.setToolTipText(""XES extension that is attached to the attribute."");
			leftPanel.add(extensionAttribute);
			JLabel eventAttribute = new JLabel(""Event Attribute"");
			eventAttribute.setToolTipText(""Attribute name in the event"");
			leftPanel.add(eventAttribute);
			leftPanel.add(Box.createVerticalGlue());
			mainPanel.add(leftPanel);

			rightPanel.add(dataTypeScrollpane);
		}

		rightPanel.add(mainScrollPane);
		mainPanel.add(rightPanel);
		getContentPane().add(mainPanel);

		setDefaultCloseOperation(DISPOSE_ON_CLOSE);
		pack();
	}

	private Vector<String> prepareNullSafeColumnNames(String[] header) {
		Vector<String> columnIds = new Vector<String>();
		for (String obj: header) {
			if (obj == null) {
				columnIds.add("""");
			} else {
				columnIds.add(obj);	
			}				
		}
		return columnIds;
	}

	public void showFrame(JComponent parent) {
		GraphicsEnvironment ge = GraphicsEnvironment.getLocalGraphicsEnvironment();
		GraphicsDevice[] gs = ge.getScreenDevices();
		if (gs.length > 1) {
			for (int i = 0; i < gs.length; i++) {
				if (gs[i] != parent.getGraphicsConfiguration().getDevice()) {
					JFrame dummy = new JFrame(gs[i].getDefaultConfiguration());
					setLocationRelativeTo(dummy);
					setExtendedState(Frame.MAXIMIZED_BOTH);
					setAlwaysOnTop(false);
					dummy.dispose();
					break;
				}
			}
		} else {
			setLocationRelativeTo(parent);
			setAlwaysOnTop(false);
			setPreferredSize(new Dimension(800, 800));
		}
		setVisible(true);
	}

	public void addRow(String[] data) {
		previewTableModel.addRow(data);
	}

	public void addRows(List<String[]> rows) {
		previewTableModel.addRows(rows);
	}

	public void refresh() {
		if (datatypeTable != null) {
			datatypeTable.repaint();
		}
	}

	public JTable getPreviewTable() {
		return previewTable;
	}

	public JScrollPane getMainScrollPane() {
		return mainScrollPane;
	}

	public void save() {
		if (datatypeTable.isEditing()) {
			datatypeTable.getCellEditor().stopCellEditing();
		}
	}

}
"
CSVPreviewPanel.java,log,"package org.processmining.log.csvimport.ui.preview;

import java.util.Enumeration;
import java.util.List;
import java.util.Vector;

import javax.swing.BoxLayout;
import javax.swing.DefaultCellEditor;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JTable;
import javax.swing.JTextField;
import javax.swing.table.DefaultTableModel;
import javax.swing.table.TableColumn;

import org.processmining.framework.util.ui.widgets.ProMScrollPane;
import org.processmining.framework.util.ui.widgets.ProMTableWithoutPanel;

public final class CSVPreviewPanel extends JPanel {

	private static final long serialVersionUID = 3007836604602201962L;

	private final class BatchUpdateDefaultTableModel extends DefaultTableModel {

		private static final long serialVersionUID = -3423057642229809442L;

		private BatchUpdateDefaultTableModel(Object[] columnNames, int rowCount) {
			super(columnNames, rowCount);
		}

		@SuppressWarnings(""unchecked"")
		public void addRows(List<String[]> rowData) {
			int firstRow = dataVector.size();
			for (String[] row : rowData) {
				dataVector.add(convertToVector(row));
			}
			int lastRow = dataVector.size() - 1;
			fireTableRowsInserted(firstRow, lastRow);
		}
	}

	private final BatchUpdateDefaultTableModel previewTableModel;
	private final JTable previewTable;
	private final JScrollPane mainScrollPane;

	private JTable datatypeTable;

	public CSVPreviewPanel() {
		super();
		setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));
		setOpaque(false);
		
		previewTableModel = new BatchUpdateDefaultTableModel(null, 0);
		previewTable = new ProMTableWithoutPanel(previewTableModel);
		previewTable.setAutoResizeMode(JTable.AUTO_RESIZE_OFF);
		
		Enumeration<TableColumn> columns = previewTable.getColumnModel().getColumns();
		
		while (columns.hasMoreElements()) {
			final TableColumn column = columns.nextElement();
			column.setPreferredWidth(130);
			column.setCellEditor(new DefaultCellEditor(new JTextField()) {

				private static final long serialVersionUID = -2741181064062738008L;

				protected void fireEditingStopped() {
					this.cancelCellEditing();
					super.fireEditingStopped();
				}

				protected void fireEditingCanceled() {
					super.fireEditingCanceled();
				}

			});
		}
		previewTable.getColumnModel().setColumnSelectionAllowed(false);
		previewTable.getTableHeader().setReorderingAllowed(false);

		mainScrollPane = new ProMScrollPane(previewTable);
		
		add(mainScrollPane);
	}

	public void addRow(String[] data) {
		previewTableModel.addRow(data);
	}

	public void addRows(List<String[]> rows) {
		previewTableModel.addRows(rows);
	}

	public void setHeader(String[] header) {
		if (header == null) {
			previewTable.setTableHeader(null);
		} else {			
			Vector<String> columnIds = new Vector<String>();
			for (String obj: header) {
				if (obj == null) {
					columnIds.add("""");
				} else {
					columnIds.add(obj);	
				}				
			}
			previewTableModel.setColumnIdentifiers(columnIds);
		}
	}

	public void clear() {
		previewTableModel.getDataVector().clear();
		previewTable.repaint();
	}

	public void refresh() {
		if (datatypeTable != null) {
			datatypeTable.repaint();
		}
	}

	public JTable getPreviewTable() {
		return previewTable;
	}

	public JScrollPane getMainScrollPane() {
		return mainScrollPane;
	}

}
"
ClassifierPanel.java,log,"package org.processmining.log.dialogs;

import java.awt.Dimension;
import java.util.List;

import javax.swing.DefaultListModel;
import javax.swing.JPanel;
import javax.swing.ListSelectionModel;
import javax.swing.event.ListSelectionEvent;
import javax.swing.event.ListSelectionListener;

import org.deckfour.xes.classification.XEventClassifier;
import org.processmining.framework.util.ui.widgets.ProMList;
import org.processmining.log.parameters.ClassifierParameter;
import org.processmining.log.parameters.UpdateParameter;

import info.clearthought.layout.TableLayout;
import info.clearthought.layout.TableLayoutConstants;

public class ClassifierPanel extends JPanel {
	
	/**
	 * 
	 */
	private static final long serialVersionUID = -7242932924333294111L;

	public ClassifierPanel(List<XEventClassifier> classifiers, final ClassifierParameter classifierParameter) {
		this (classifiers, classifierParameter, null);
	}
	
	public ClassifierPanel(List<XEventClassifier> classifiers, final ClassifierParameter classifierParameter, final UpdateParameter updateParameter) {
		double size[][] = { { TableLayoutConstants.FILL }, { TableLayoutConstants.FILL } };
		setLayout(new TableLayout(size));

		setOpaque(false);
		
		DefaultListModel<XEventClassifier> listModel = new DefaultListModel<XEventClassifier>();
		for (XEventClassifier classifier: classifiers) {
			listModel.addElement(classifier);
		}
		final ProMList<XEventClassifier> list = new ProMList<XEventClassifier>(""Select classifier"", listModel);
		list.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
		final XEventClassifier defaultClassifier = classifierParameter.getClassifier();
		list.setSelection(defaultClassifier);
		classifierParameter.setClassifier(wrap(defaultClassifier));
		list.addListSelectionListener(new ListSelectionListener() {
			public void valueChanged(ListSelectionEvent e) {
				List<XEventClassifier> selected = list.getSelectedValuesList();
				if (selected.size() == 1) {
					classifierParameter.setClassifier(wrap(selected.get(0)));
					if (updateParameter != null) {
						updateParameter.update();
					}
				} else {
					/*
					 * Nothing selected. Revert to selection of default classifier.
					 */
					list.setSelection(defaultClassifier);
					classifierParameter.setClassifier(wrap(defaultClassifier));
					if (updateParameter != null) {
						updateParameter.update();
					}
				}
			}
		});
		list.setPreferredSize(new Dimension(100, 100));
		add(list, ""0, 0"");

	}
	
	private XEventClassifier wrap(XEventClassifier classifier) {
//		if (classifier instanceof StartEndClassifier) {
			return classifier;
//		}
//		return new StartEndClassifier(classifier);
	}

}
"
HighFrequencyFilterDialog.java,log,"package org.processmining.log.dialogs;

import info.clearthought.layout.TableLayout;
import info.clearthought.layout.TableLayoutConstants;

import javax.swing.JPanel;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;

import org.deckfour.xes.model.XLog;
import org.processmining.log.parameters.HighFrequencyFilterParameters;

import com.fluxicon.slickerbox.components.NiceSlider;
import com.fluxicon.slickerbox.components.NiceSlider.Orientation;
import com.fluxicon.slickerbox.factory.SlickerFactory;

public class HighFrequencyFilterDialog extends JPanel {

	/**
	 * 
	 */
	private static final long serialVersionUID = 5152781639823196889L;

	public HighFrequencyFilterDialog(XLog eventLog, final HighFrequencyFilterParameters parameters) {
		double size[][] = { { TableLayoutConstants.FILL }, { TableLayoutConstants.FILL, 30, 30 } };
		setLayout(new TableLayout(size));
		
		add(new ClassifierPanel(eventLog.getClassifiers(), parameters), ""0, 0"");

		final NiceSlider frequenceThresholdSlider = SlickerFactory.instance().createNiceIntegerSlider(""Frequency threshold"", 0, 100,
				parameters.getFrequencyThreshold(), Orientation.HORIZONTAL);
		frequenceThresholdSlider.addChangeListener(new ChangeListener() {

			public void stateChanged(ChangeEvent e) {
				parameters.setFrequencyThreshold(frequenceThresholdSlider.getSlider().getValue());
			}
		});
		add(frequenceThresholdSlider, ""0, 1"");

		final NiceSlider distanceThresholdSlider = SlickerFactory.instance().createNiceIntegerSlider(""Distance threshold"", 0, 100,
				parameters.getDistanceThreshold(), Orientation.HORIZONTAL);
		distanceThresholdSlider.addChangeListener(new ChangeListener() {

			public void stateChanged(ChangeEvent e) {
				parameters.setDistanceThreshold(distanceThresholdSlider.getSlider().getValue());
			}
		});
		add(distanceThresholdSlider, ""0, 2"");
	}

}
"
LogCentralityDialog.java,log,"package org.processmining.log.dialogs;

import info.clearthought.layout.TableLayout;
import info.clearthought.layout.TableLayoutConstants;

import java.awt.Dimension;
import java.util.List;

import javax.swing.DefaultListModel;
import javax.swing.JPanel;
import javax.swing.ListSelectionModel;
import javax.swing.event.ListSelectionEvent;
import javax.swing.event.ListSelectionListener;

import org.deckfour.xes.classification.XEventClassifier;
import org.deckfour.xes.model.XLog;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.framework.util.ui.widgets.ProMList;
import org.processmining.log.models.LogCentrality;
import org.processmining.log.parameters.LogCentralityParameters;

public class LogCentralityDialog extends JPanel{

	/**
	 * 
	 */
	private static final long serialVersionUID = 8634000584911454942L;

	public LogCentralityDialog(final UIPluginContext context, final XLog log, final LogCentrality centrality, final LogCentralityParameters parameters) {
		double size[][] = { { TableLayoutConstants.FILL }, { TableLayoutConstants.FILL } };
		setLayout(new TableLayout(size));

		DefaultListModel<XEventClassifier> listModel = new DefaultListModel<XEventClassifier>();
		for (XEventClassifier classifier: log.getClassifiers()) {
			listModel.addElement(classifier);
		}
		final ProMList<XEventClassifier> list = new ProMList<XEventClassifier>(""Select Happy Classifier"", listModel);
		list.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
		final XEventClassifier defaultClassifier = parameters.getClassifier();
		list.setSelection(defaultClassifier);
		list.addListSelectionListener(new ListSelectionListener() {
			public void valueChanged(ListSelectionEvent e) {
				List<XEventClassifier> selected = list.getSelectedValuesList();
				if (selected.size() == 1) {
					parameters.setClassifier(selected.get(0));
				} else {
					/*
					 * Nothing selected. Revert to selection of default classifier.
					 */
					list.setSelection(defaultClassifier);
					parameters.setClassifier(defaultClassifier);
				}
				centrality.setClassifier(context, parameters);
			}
		});
		list.setPreferredSize(new Dimension(100, 100));
		add(list, ""0, 0"");	
	}
}
"
LogCentralityFilterDialog.java,log,"package org.processmining.log.dialogs;

import info.clearthought.layout.TableLayout;
import info.clearthought.layout.TableLayoutConstants;

import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

import javax.swing.JCheckBox;
import javax.swing.JComponent;
import javax.swing.JPanel;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;

import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.log.algorithms.LogCentralityVisualizerAlgorithm;
import org.processmining.log.models.LogCentrality;
import org.processmining.log.parameters.LogCentralityFilterParameters;

import com.fluxicon.slickerbox.components.NiceSlider;
import com.fluxicon.slickerbox.components.NiceSlider.Orientation;
import com.fluxicon.slickerbox.factory.SlickerFactory;

public class LogCentralityFilterDialog extends JPanel{

	/**
	 * 
	 */
	private static final long serialVersionUID = 1184378045381402638L;

	private JComponent holder;
	
	public LogCentralityFilterDialog(final UIPluginContext context, final LogCentrality centrality, final LogCentralityFilterParameters parameters) {
		double size[][] = { { TableLayoutConstants.FILL }, { TableLayoutConstants.FILL, 30, 30 } };
		setLayout(new TableLayout(size));

		holder = new JPanel();
		add(holder, ""0, 0"");
		double holderSize[][] = { { TableLayoutConstants.FILL }, { TableLayoutConstants.FILL } };
		holder.setLayout(new TableLayout(holderSize));
		holder.add((new LogCentralityVisualizerAlgorithm()).apply(centrality, parameters), ""0, 0"");
		
		final NiceSlider percSlider = SlickerFactory.instance().createNiceIntegerSlider(""Select Happy Percentage"", 0, 100,  parameters.getPercentage(),
				Orientation.HORIZONTAL);
		percSlider.addChangeListener(new ChangeListener() {

			public void stateChanged(ChangeEvent e) {
				parameters.setPercentage(percSlider.getSlider().getValue());
				holder.removeAll();
				holder.add((new LogCentralityVisualizerAlgorithm()).apply(centrality, parameters), ""0, 0"");
				revalidate();
				repaint();
			}
		});
		add(percSlider, ""0, 1"");

		final JCheckBox filterInBox = SlickerFactory.instance().createCheckBox(""Select if Happy (otherwise unhappy)"",
				false);
		filterInBox.setSelected(parameters.isFilterIn());
		filterInBox.addActionListener(new ActionListener() {

			public void actionPerformed(ActionEvent e) {
				parameters.setFilterIn(filterInBox.isSelected());
				holder.removeAll();
				holder.add((new LogCentralityVisualizerAlgorithm()).apply(centrality, parameters), ""0, 0"");
				revalidate();
				repaint();
			}

		});
		filterInBox.setOpaque(false);
		add(filterInBox, ""0, 2"");
		
	}
}
"
LogFrequencyDialog.java,log,"package org.processmining.log.dialogs;

import info.clearthought.layout.TableLayout;
import info.clearthought.layout.TableLayoutConstants;

import javax.swing.JPanel;

import org.deckfour.xes.model.XLog;
import org.processmining.log.parameters.LogFrequencyParameters;

public class LogFrequencyDialog extends JPanel {

	/**
	 * 
	 */
	private static final long serialVersionUID = 2707936407167128579L;

	public LogFrequencyDialog(XLog eventLog, final LogFrequencyParameters parameters) {
		double size[][] = { { TableLayoutConstants.FILL }, { TableLayoutConstants.FILL, } };
		setLayout(new TableLayout(size));
		
		add(new ClassifierPanel(eventLog.getClassifiers(), parameters), ""0, 0"");

	}
}"
LowFrequencyFilterDialog.java,log,"package org.processmining.log.dialogs;

import info.clearthought.layout.TableLayout;
import info.clearthought.layout.TableLayoutConstants;

import javax.swing.JPanel;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;

import org.deckfour.xes.model.XLog;
import org.processmining.log.parameters.LowFrequencyFilterParameters;

import com.fluxicon.slickerbox.components.NiceSlider;
import com.fluxicon.slickerbox.components.NiceSlider.Orientation;
import com.fluxicon.slickerbox.factory.SlickerFactory;

public class LowFrequencyFilterDialog extends JPanel {

	/**
	 * 
	 */
	private static final long serialVersionUID = -1217093745565528989L;

	public LowFrequencyFilterDialog(XLog eventLog, final LowFrequencyFilterParameters parameters) {
		double size[][] = { { TableLayoutConstants.FILL }, { TableLayoutConstants.FILL, 30 } };
		setLayout(new TableLayout(size));
		
		add(new ClassifierPanel(eventLog.getClassifiers(), parameters), ""0, 0"");

		final NiceSlider thresholdSlider = SlickerFactory.instance().createNiceIntegerSlider(""Frequency threshold"", 0, 100,
				parameters.getThreshold(), Orientation.HORIZONTAL);
		thresholdSlider.addChangeListener(new ChangeListener() {

			public void stateChanged(ChangeEvent e) {
				parameters.setThreshold(thresholdSlider.getSlider().getValue());
			}
		});
		add(thresholdSlider, ""0, 1"");
	}
}
"
LowOccurrencesFilterDialog.java,log,"package org.processmining.log.dialogs;

import info.clearthought.layout.TableLayout;
import info.clearthought.layout.TableLayoutConstants;

import javax.swing.JPanel;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;

import org.deckfour.xes.model.XLog;
import org.processmining.log.parameters.LowOccurrencesFilterParameters;

import com.fluxicon.slickerbox.components.NiceSlider;
import com.fluxicon.slickerbox.components.NiceSlider.Orientation;
import com.fluxicon.slickerbox.factory.SlickerFactory;

public class LowOccurrencesFilterDialog extends JPanel {

	/**
	 * 
	 */
	private static final long serialVersionUID = 9093478331292093365L;

	public LowOccurrencesFilterDialog(XLog eventLog, final LowOccurrencesFilterParameters parameters) {
		double size[][] = { { TableLayoutConstants.FILL }, { TableLayoutConstants.FILL, 30 } };
		setLayout(new TableLayout(size));
		
		add(new ClassifierPanel(eventLog.getClassifiers(), parameters), ""0, 0"");

		final NiceSlider thresholdSlider = SlickerFactory.instance().createNiceIntegerSlider(""Occurrence threshold"", 0, 100,
				parameters.getThreshold(), Orientation.HORIZONTAL);
		thresholdSlider.addChangeListener(new ChangeListener() {

			public void stateChanged(ChangeEvent e) {
				parameters.setThreshold(thresholdSlider.getSlider().getValue());
			}
		});
		add(thresholdSlider, ""0, 1"");
	}
}
"
MergeLogsDialog.java,log,"package org.processmining.log.dialogs;

import java.awt.Dimension;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
import java.util.List;

import javax.swing.DefaultListModel;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.ListSelectionModel;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
import javax.swing.event.ListSelectionEvent;
import javax.swing.event.ListSelectionListener;

import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.processmining.framework.util.ui.widgets.ProMList;
import org.processmining.framework.util.ui.widgets.ProMTextField;
import org.processmining.log.parameters.MergeLogsParameters;
import org.processmining.log.utils.MergeLogsUtils;

import com.fluxicon.slickerbox.components.NiceSlider;
import com.fluxicon.slickerbox.components.NiceSlider.Orientation;
import com.fluxicon.slickerbox.factory.SlickerFactory;

import info.clearthought.layout.TableLayout;
import info.clearthought.layout.TableLayoutConstants;

public class MergeLogsDialog extends JPanel {

	/**
	 * 
	 */
	private static final long serialVersionUID = -5486690145975904628L;

	public MergeLogsDialog(final MergeLogsParameters parameters, final XLog log) {
		double size[][] = { { 100, 700 }, { 30, TableLayoutConstants.FILL, 30, 30, 30, 30, 30, 30, 30 } };
		setLayout(new TableLayout(size));
		int row = 0;
		DateFormat df;
		final Collection<String> ids = new HashSet<String>();
		for (XTrace trace : log) {
			String id = XConceptExtension.instance().extractName(trace);
			if (id != null) {
				ids.add(id);
			}
		}
		
		final ProMTextField idField = new ProMTextField(parameters.getTraceId());
		idField.addKeyListener(new KeyListener() {

			public void keyPressed(KeyEvent e) {
			}

			public void keyTyped(KeyEvent e) {
			}

			public void keyReleased(KeyEvent e) {
				String value = idField.getText().trim();
				if (value.isEmpty() || !ids.contains(value)) {
					value = null;
				} 
				parameters.setTraceId(value);
				idField.visualizeStatus(idField.getText().trim().isEmpty() || value != null);
			}
		});
		add(new JLabel(""Choose Trace ID""), ""0, "" + row);
		add(idField, ""1, "" + row);
		row++;

		DefaultListModel<String> listModel = new DefaultListModel<String>();
		listModel.addElement(parameters.getDateFormat());
		listModel.addElement(""MM/dd/yyyy HH:mm:ss"");
		listModel.addElement(""MM/dd/yyyy hh:mm"");
		listModel.addElement(""MM/dd/yyyy hh:mm:ss"");
		listModel.addElement(""MM/dd/yyyy"");
		listModel.addElement(""dd/MM/yyyy HH:mm"");
		listModel.addElement(""dd/MM/yyyy HH:mm:ss"");
		listModel.addElement(""dd/MM/yyyy hh:mm"");
		listModel.addElement(""dd/MM/yyyy hh:mm:ss"");
		listModel.addElement(""dd/MM/yyyy"");
		listModel.addElement(""dd-MMM-yyyy HH:mm"");
		listModel.addElement(""dd-MMM-yyyy HH:mm:ss"");
		listModel.addElement(""dd-MMM-yyyy hh:mm"");
		listModel.addElement(""dd-MMM-yyyy hh:mm:ss"");
		listModel.addElement(""dd-MMM-yyyy"");
		listModel.addElement(""MM/dd/yy HH:mm"");
		listModel.addElement(""MM/dd/yy HH:mm:ss"");
		listModel.addElement(""MM/dd/yy hh:mm"");
		listModel.addElement(""MM/dd/yy hh:mm:ss"");
		listModel.addElement(""MM/dd/yy"");
		listModel.addElement(""dd/MM/yy HH:mm"");
		listModel.addElement(""dd/MM/yy HH:mm:ss"");
		listModel.addElement(""dd/MM/yy hh:mm"");
		listModel.addElement(""dd/MM/yy hh:mm:ss"");
		listModel.addElement(""dd/MM/yy"");
		listModel.addElement(""dd-MMM-yy HH:mm"");
		listModel.addElement(""dd-MMM-yy HH:mm:ss"");
		listModel.addElement(""dd-MMM-yy hh:mm"");
		listModel.addElement(""dd-MMM-yy hh:mm:ss"");
		listModel.addElement(""dd-MMM-yy"");
		final ProMList<String> list = new ProMList<String>(""Select date format"", listModel);
		list.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
		final String defaultConfiguration = parameters.getDateFormat();
		list.setSelection(defaultConfiguration);
		list.addListSelectionListener(new ListSelectionListener() {
			public void valueChanged(ListSelectionEvent e) {
				List<String> selected = list.getSelectedValuesList();
				if (selected.size() == 1) {
					parameters.setDateFormat(selected.get(0));
				} else {
					/*
					 * Nothing selected. Revert to selection of default classifier.
					 */
					list.setSelection(defaultConfiguration);
					parameters.setDateFormat(defaultConfiguration);
				}
			}
		});
		list.setPreferredSize(new Dimension(10, 10));
		add(list, ""0, "" + row + "", 1, "" + row);
		row++;

		String fromDate = """";
		df = new SimpleDateFormat(parameters.getDateFormat());
		if (parameters.getFromDate() != null) {
			fromDate = df.format(parameters.getFromDate());
		}
		final ProMTextField fromField = new ProMTextField(fromDate);
		fromField.addKeyListener(new KeyListener() {

			public void keyPressed(KeyEvent e) {
			}

			public void keyTyped(KeyEvent e) {
			}

			public void keyReleased(KeyEvent e) {
				Date date = MergeLogsUtils.getDate(parameters, fromField.getText().trim());
				parameters.setFromDate(date);
				fromField.visualizeStatus(fromField.getText().trim().isEmpty() || date != null); 
			}
			
		});
		add(new JLabel(""From Date""), ""0, "" + row);
		add(fromField, ""1, "" + row);
		row++;

		String toDate = """";
		df = new SimpleDateFormat(parameters.getDateFormat());
		if (parameters.getToDate() != null) {
			toDate = df.format(parameters.getToDate());
		}
		final ProMTextField toField = new ProMTextField(toDate);
		toField.addKeyListener(new KeyListener() {

			public void keyPressed(KeyEvent e) {
			}

			public void keyTyped(KeyEvent e) {
			}

			public void keyReleased(KeyEvent e) {
				Date date = MergeLogsUtils.getDate(parameters, toField.getText().trim());
				parameters.setToDate(date);
				toField.visualizeStatus(toField.getText().trim().isEmpty() || date != null); 
			}
			
		});
		add(new JLabel(""To Date""), ""0, "" + row);
		add(toField, ""1, "" + row);
		row++;

		String specificDate = """";
		df = new SimpleDateFormat(parameters.getDateFormat());
		if (parameters.getSpecificDate() != null) {
			specificDate = df.format(parameters.getSpecificDate());
		}
		final ProMTextField specificField = new ProMTextField(specificDate);
		specificField.addKeyListener(new KeyListener() {

			public void keyPressed(KeyEvent e) {
			}

			public void keyTyped(KeyEvent e) {
			}

			public void keyReleased(KeyEvent e) {
				Date date = MergeLogsUtils.getDate(parameters, specificField.getText().trim());
				parameters.setSpecificDate(date);
				specificField.visualizeStatus(specificField.getText().trim().isEmpty() || date != null); 
			}
			
		});
		add(new JLabel(""Specific Date""), ""0, "" + row);
		add(specificField, ""1, "" + row);
		row++;

		final ProMTextField requiredField = new ProMTextField(parameters.getRequiredWords());
		requiredField.addKeyListener(new KeyListener() {

			public void keyPressed(KeyEvent e) {
			}

			public void keyTyped(KeyEvent e) {
			}

			public void keyReleased(KeyEvent e) {
				String value = requiredField.getText().trim();
				if (value.isEmpty()) {
					value = null;
				}
				parameters.setRequiredWords(requiredField.getText());
			}
			
		});
		add(new JLabel(""Required Words""), ""0, "" + row);
		add(requiredField, ""1, "" + row);
		row++;

		final ProMTextField forbiddenField = new ProMTextField(parameters.getForbiddenWords());
		forbiddenField.addKeyListener(new KeyListener() {

			public void keyPressed(KeyEvent e) {
			}

			public void keyTyped(KeyEvent e) {
			}

			public void keyReleased(KeyEvent e) {
				String value = forbiddenField.getText().trim();
				if (value.isEmpty()) {
					value = null;
				}
				parameters.setForbiddenWords(value);
			}
			
		});
		add(new JLabel(""Forbidden Words""), ""0, "" + row);
		add(forbiddenField, ""1, "" + row);
		row++;


		final NiceSlider clusterSlider = SlickerFactory.instance().createNiceIntegerSlider(""Set related"", 0, 100,
				parameters.getRelated(), Orientation.HORIZONTAL);
		clusterSlider.addChangeListener(new ChangeListener() {

			public void stateChanged(ChangeEvent e) {
				parameters.setRelated(clusterSlider.getSlider().getValue());
			}
		});
		add(clusterSlider, ""0, ""+ row + "", 1, "" + row);
		row++;


		final NiceSlider wordSlider = SlickerFactory.instance().createNiceIntegerSlider(""Set matching words"", 0, 100,
				parameters.getMinMatches(), Orientation.HORIZONTAL);
		clusterSlider.addChangeListener(new ChangeListener() {

			public void stateChanged(ChangeEvent e) {
				parameters.setMinMatches(wordSlider.getSlider().getValue());
			}
		});
		add(wordSlider, ""0, ""+ row + "", 1, "" + row);
		row++;

		
	}
	
}
"
MinerPanel.java,log,"package org.processmining.log.dialogs;

import java.awt.Dimension;
import java.util.List;

import javax.swing.DefaultListModel;
import javax.swing.JPanel;
import javax.swing.ListSelectionModel;
import javax.swing.event.ListSelectionEvent;
import javax.swing.event.ListSelectionListener;

import org.processmining.framework.util.ui.widgets.ProMList;
import org.processmining.log.parameters.MinerParameter;
import org.processmining.log.parameters.UpdateParameter;

import info.clearthought.layout.TableLayout;
import info.clearthought.layout.TableLayoutConstants;

public class MinerPanel extends JPanel {
	
	/**
	 * 
	 */
	private static final long serialVersionUID = 7656913719419272750L;

	public MinerPanel(List<String> miners, final MinerParameter minerParameter) {
		this(miners, minerParameter, null);
	}
	
	public MinerPanel(List<String> miners, final MinerParameter minerParameter, final UpdateParameter updateParameter) {
		double size[][] = { { TableLayoutConstants.FILL }, { TableLayoutConstants.FILL } };
		setLayout(new TableLayout(size));

		setOpaque(false);
		
		DefaultListModel<String> listModel = new DefaultListModel<String>();
		for (String miner: miners) {
			listModel.addElement(miner);
		}
		final ProMList<String> list = new ProMList<String>(""Select miner"", listModel);
		list.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
		final String defaultMiner = minerParameter.getMiner();
		list.setSelection(defaultMiner);
		list.addListSelectionListener(new ListSelectionListener() {
			public void valueChanged(ListSelectionEvent e) {
				List<String> selected = list.getSelectedValuesList();
				if (selected.size() == 1) {
					minerParameter.setMiner(selected.get(0));
					if (updateParameter != null) {
						updateParameter.update();
					}
				} else {
					/*
					 * Nothing selected. Revert to selection of default classifier.
					 */
					list.setSelection(defaultMiner);
					minerParameter.setMiner(defaultMiner);
					if (updateParameter != null) {
						updateParameter.update();
					}
				}
			}
		});
		list.setPreferredSize(new Dimension(100, 100));
		add(list, ""0, 0"");

	}

}
"
SplitLogDialog.java,log,"package org.processmining.log.dialogs;

import java.awt.Dimension;
import java.util.List;
import java.util.Set;
import java.util.TreeSet;

import javax.swing.DefaultListModel;
import javax.swing.JPanel;
import javax.swing.ListSelectionModel;
import javax.swing.event.ListSelectionEvent;
import javax.swing.event.ListSelectionListener;

import org.deckfour.xes.model.XAttribute;
import org.deckfour.xes.model.XAttributeLiteral;
import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.processmining.framework.util.ui.widgets.ProMList;
import org.processmining.log.parameters.SplitLogParameters;

import info.clearthought.layout.TableLayout;
import info.clearthought.layout.TableLayoutConstants;

public class SplitLogDialog extends JPanel{

	/**
	 * 
	 */
	private static final long serialVersionUID = -5028679044691450395L;

	public SplitLogDialog(final SplitLogParameters parameters, XLog log) {
		double size[][] = { { TableLayoutConstants.FILL }, { TableLayoutConstants.FILL } };
		setLayout(new TableLayout(size));
		DefaultListModel<String> listModel = new DefaultListModel<String>();
		Set<String> keys = new TreeSet<String>();
		for (XTrace trace : log) {
			for (XEvent event : trace) {
				for (XAttribute attribute : event.getAttributes().values()) {
					if (attribute instanceof XAttributeLiteral) {
						keys.add(attribute.getKey());
					}
				}
			}
		}
		for (String key : keys) {
			listModel.addElement(key);
		}
		final ProMList<String> list = new ProMList<String>(""Select attribute key"", listModel);
		list.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
		final String defaultKey = parameters.getKey();
		list.setSelection(defaultKey);
		list.addListSelectionListener(new ListSelectionListener() {
			public void valueChanged(ListSelectionEvent e) {
				List<String> selected = list.getSelectedValuesList();
				if (selected.size() == 1) {
					parameters.setKey(selected.get(0));
				} else {
					/*
					 * Nothing selected. Revert to selection of default key.
					 */
					list.setSelection(defaultKey);
					parameters.setKey(defaultKey);
				}
			}
		});
		list.setPreferredSize(new Dimension(10, 10));
		add(list, ""0, 0"");		
	}
}
"
AbstractLogExporter.java,log,"package org.processmining.plugins.log.exporting;

import java.io.File;
import java.io.IOException;

import org.deckfour.xes.model.XLog;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.log.utils.XUtils;

abstract class AbstractLogExporter {

	/**
	 * Temporarily changes the name of the XLog object, then calls the
	 * {@link #doExport(XLog, File)} method and, afterwards, changes the name of
	 * the XLog object back to the original one.
	 * 
	 * @param context
	 * @param log
	 * @param file
	 * @throws IOException
	 */
	protected void exportWithNameFromContext(PluginContext context, XLog log, File file) throws IOException {
		if (context == null) {
			doExport(log, file);
		} else {
			String originalName = XUtils.renameLogWithProMLabel(context, log);
			try {
				doExport(log, file);
			} finally {
				// Re-assign the original name to avoid changing the XLog object as ProMs connection framework might depend on it
				XUtils.assignConceptName(log, originalName);
			}
		}
	}

	/**
	 * Do the actual export
	 * 
	 * @param log
	 * @param file
	 * @throws IOException
	 */
	abstract void doExport(XLog log, File file) throws IOException;

}"
ExportLogMxml.java,log,"package org.processmining.plugins.log.exporting;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;

import org.deckfour.xes.model.XLog;
import org.deckfour.xes.out.XMxmlSerializer;
import org.deckfour.xes.out.XSerializer;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.contexts.uitopia.annotations.UIExportPlugin;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginLevel;
import org.processmining.framework.plugin.annotations.PluginVariant;

@Plugin(name = ""Export Log to MXML File"", level = PluginLevel.Regular, parameterLabels = { ""Log"", ""File"" }, returnLabels = {}, returnTypes = {}, userAccessible = true)
@UIExportPlugin(description = ""MXML files"", extension = ""mxml"")
public class ExportLogMxml extends AbstractLogExporter {

	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""H.M.W Verbeek"", email = ""h.m.w.verbeek@tue.nl"")
	@PluginVariant(requiredParameterLabels = { 0, 1 }, variantLabel = ""Export Log to XMXL File"")
	public void export(UIPluginContext context, XLog log, File file) throws IOException {		
		exportWithNameFromContext(context, log, file);
	}

	public static void export(XLog log, File file) throws IOException {
		FileOutputStream out = new FileOutputStream(file);
		XSerializer logSerializer = new XMxmlSerializer();
		logSerializer.serialize(log, out);
		out.close();
	}

	void doExport(XLog log, File file) throws IOException {
		export(log, file);
	}

}"
ExportLogMxmlGz.java,log,"package org.processmining.plugins.log.exporting;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;

import org.deckfour.xes.model.XLog;
import org.deckfour.xes.out.XMxmlGZIPSerializer;
import org.deckfour.xes.out.XSerializer;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.contexts.uitopia.annotations.UIExportPlugin;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginLevel;
import org.processmining.framework.plugin.annotations.PluginVariant;

@Plugin(name = ""Export Log to compressed MXML File"", level = PluginLevel.Regular, parameterLabels = { ""Log"",
		""File"" }, returnLabels = {}, returnTypes = {}, userAccessible = true)
@UIExportPlugin(description = ""Compressed MXML files"", extension = ""mxml.gz"")
public class ExportLogMxmlGz extends AbstractLogExporter {
	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""H.M.W Verbeek"", email = ""h.m.w.verbeek@tue.nl"")
	@PluginVariant(requiredParameterLabels = { 0, 1 }, variantLabel = ""Export Log to compressed XMXL File"")
	public void export(UIPluginContext context, XLog log, File file) throws IOException {
		exportWithNameFromContext(context, log, file);
	}

	public static void export(XLog log, File file) throws IOException {
		FileOutputStream out = new FileOutputStream(file);
		XSerializer logSerializer = new XMxmlGZIPSerializer();
		logSerializer.serialize(log, out);
		out.close();
	}

	void doExport(XLog log, File file) throws IOException {
		export(log, file);
	}
	
}"
ExportLogXes.java,log,"package org.processmining.plugins.log.exporting;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;

import org.deckfour.xes.model.XLog;
import org.deckfour.xes.out.XSerializer;
import org.deckfour.xes.out.XesXmlSerializer;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.contexts.uitopia.annotations.UIExportPlugin;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginLevel;
import org.processmining.framework.plugin.annotations.PluginVariant;

@Plugin(name = ""Export Log to XES File"", level = PluginLevel.PeerReviewed, parameterLabels = { ""Log"", ""File"" }, returnLabels = {}, returnTypes = {}, userAccessible = true)
@UIExportPlugin(description = ""XES files"", extension = ""xes"")
public class ExportLogXes extends AbstractLogExporter {

	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""H.M.W Verbeek"", email = ""h.m.w.verbeek@tue.nl"")
	@PluginVariant(requiredParameterLabels = { 0, 1 }, variantLabel = ""Export Log to XES File"")
	public void export(UIPluginContext context, XLog log, File file) throws IOException {
		exportWithNameFromContext(context, log, file);
	}

	void doExport(XLog log, File file) throws IOException {
		// Calls the static method for backwards compatibility
		export(log, file);
	}

	public static void export(XLog log, File file) throws IOException {
		FileOutputStream out = new FileOutputStream(file);
		XSerializer logSerializer = new XesXmlSerializer();
		logSerializer.serialize(log, out);
		out.close();
	}

}"
ExportLogXesGz.java,log,"package org.processmining.plugins.log.exporting;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;

import org.deckfour.xes.model.XLog;
import org.deckfour.xes.out.XSerializer;
import org.deckfour.xes.out.XesXmlGZIPSerializer;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.contexts.uitopia.annotations.UIExportPlugin;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginLevel;
import org.processmining.framework.plugin.annotations.PluginVariant;

@Plugin(name = ""Export Log to compressed XES File"", level = PluginLevel.PeerReviewed, parameterLabels = { ""Log"", ""File"" }, returnLabels = {}, returnTypes = {}, userAccessible = true)
@UIExportPlugin(description = ""Compressed XES files"", extension = ""xes.gz"")
public class ExportLogXesGz extends AbstractLogExporter {
	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""H.M.W Verbeek"", email = ""h.m.w.verbeek@tue.nl"")
	@PluginVariant(requiredParameterLabels = { 0, 1 }, variantLabel = ""Export Log to compressed XES File"")
	public void export(UIPluginContext context, XLog log, File file) throws IOException {
		exportWithNameFromContext(context, log, file);
	}

	public static void export(XLog log, File file) throws IOException {
		FileOutputStream out = new FileOutputStream(file);
		XSerializer logSerializer = new XesXmlGZIPSerializer();
		logSerializer.serialize(log, out);
		out.close();
	}

	void doExport(XLog log, File file) throws IOException {
		export(log, file);
	}
}
"
FileFormat.java,log,"package org.processmining.log;

/**
 * @see LogFileFormat
 */
@Deprecated
public enum FileFormat {
	XES(""xes""), XES_GZ(""xes.gz""), MXML(""mxml""), MXML_GZ(""mxml.gz"");

	private String desc;

	private FileFormat(String desc) {
		this.desc = desc;
	}

	@Override
	public String toString() {
		return desc;
	}
}
"
AttributeLogFilter.java,log,"package org.processmining.plugins.log.filter;

import java.util.HashSet;
import java.util.Set;

import org.deckfour.xes.model.XAttribute;
import org.deckfour.xes.model.XAttributeMap;
import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;

public class AttributeLogFilter {

	public static final String NONE = ""none"";
	public static final String TRACE_ATTRIBUTE = ""trace attribute"";
	public static final String EVENT_ATTRIBUTE = ""trace with an event having this attribute"";

	public String attribute_filterOn = TRACE_ATTRIBUTE;

	public boolean attribute_include = true;
	public String attribute_key = null;
	public Set<String> attribute_values = new HashSet<String>();

	public int length_min_value = 0;
	public int length_max_value = Integer.MAX_VALUE;

	public XLog log;

	public AttributeLogFilter(XLog log) {
		this.log = log;
		setDefaultValues();
	}

	public void setDefaultValues() {
		this.attribute_filterOn = NONE;
		int min_length = Integer.MAX_VALUE;
		int max_length = Integer.MIN_VALUE;
		for (XTrace t : log) {
			if (t.size() < min_length)
				min_length = t.size();
			if (t.size() > max_length)
				max_length = t.size();
		}
		length_min_value = min_length;
		length_max_value = max_length;
	}

	public boolean satisfies(XAttributeMap attributes) {
		if (!attributes.containsKey(attribute_key)) {
			return false;
		}
		XAttribute attr = attributes.get(attribute_key);
		// the only way to get the value consistently out of all the attribute subclasses
		String attr_value = attr.toString();

		return attribute_values.contains(attr_value);
	}

	public boolean keepTraceOnAttributes(XTrace trace) {

		if (attribute_filterOn == TRACE_ATTRIBUTE) {
			XAttributeMap attributes = trace.getAttributes();
			if (satisfies(attributes)) {
				return attribute_include;
			} else {
				return !attribute_include;
			}

		} else if (attribute_filterOn == EVENT_ATTRIBUTE) {
			for (XEvent e : trace) {
				XAttributeMap attributes = e.getAttributes();
				if (satisfies(attributes)) {
					if (attribute_include)
						return true;
					else
						return false;
				}
			}
			if (attribute_include)
				return false;
			else
				return true;
		}
		return false;
	}

	public boolean keepTraceOnLength(XTrace trace) {
		if (length_min_value <= trace.size() && trace.size() <= length_max_value)
			return true;
		else
			return false;
	}

	public boolean keepTrace(XTrace trace) {

		if (attribute_filterOn != NONE) {
			if (!keepTraceOnAttributes(trace))
				return false;
		}
		if (!keepTraceOnLength(trace))
			return false;

		return true;
	}

}"
AttributeLogFilterPlugin.java,log,"package org.processmining.plugins.log.filter;

import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Date;

import org.deckfour.uitopia.api.event.TaskListener.InteractionResult;
import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.factory.XFactory;
import org.deckfour.xes.factory.XFactoryRegistry;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginVariant;

@Plugin(name = ""Filter Log by Attributes"",
	parameterLabels = { ""a log"", ""filter settings""}, //
	returnLabels = { ""filtered log"" },
	returnTypes = { XLog.class }, 
	userAccessible = true,
	help = ""Filter traces and individual events from the log based on the presence or absence of attributes with particular values."",
	mostSignificantResult = 1)
public class AttributeLogFilterPlugin {
	
	// take log and net as input and guess initial marking
	@UITopiaVariant(
			affiliation=""TU/e"",
			author=""D. Fahland"",
			email=""d.fahland@tue.nl"",
			website = ""http://www.processmining.org/"",
			pack=""Uma"")
	@PluginVariant(variantLabel = ""Filter Log by Attributes"", requiredParameterLabels = { 0 })
	public XLog filterLog(UIPluginContext context, XLog log) {
		
		AttributeLogFilter filter = new AttributeLogFilter(log);
		AttributeLogFilter_UI ui = new AttributeLogFilter_UI(filter);
		if (ui.setParameters(context, filter) != InteractionResult.CANCEL)
			return filterLog(context, log, filter);
		else
			return cancel(context, ""Canceled by user."");
				
	}
	
	@PluginVariant(variantLabel = ""Filter Log by Attributes"", requiredParameterLabels = { 0, 1 })
	public XLog filterLog(PluginContext context, XLog log, AttributeLogFilter filter) {

		XFactory f = XFactoryRegistry.instance().currentDefault();
		
		// create new log, copy original attributes
		XLog filtered = f.createLog(log.getAttributes());
		
		// HV: Copy log metadata.
		filtered.getExtensions().addAll(log.getExtensions());
		filtered.getGlobalEventAttributes().addAll(log.getGlobalEventAttributes());
		filtered.getGlobalTraceAttributes().addAll(log.getGlobalTraceAttributes());
		filtered.getClassifiers().addAll(log.getClassifiers());
		
		for (XTrace t : log) {
			if (filter.keepTrace(t)) {
				filtered.add(t);
			}
		}
		
		DateFormat dateFormat = new SimpleDateFormat(""HH:mm:ss"");
		Date date = new Date();
		String timeString = dateFormat.format(date);
		
		String logName = XConceptExtension.instance().extractName(log);
		if (logName == null) logName = ""log"";
		logName = logName+"" (filtered @ ""+timeString+"")"";
		context.getFutureResult(0).setLabel(logName);
		
		return filtered;
	}

	protected static XLog cancel(PluginContext context, String message) {
		System.out.println(""[AttributeFilter]: ""+message);
		context.log(message);
		context.getFutureResult(0).cancel(true);
		return null;
	}
}
"
AttributeLogFilter_UI.java,log,"package org.processmining.plugins.log.filter;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.util.ArrayList;
import java.util.List;
import java.util.Set;
import java.util.TreeSet;

import javax.swing.AbstractListModel;
import javax.swing.ComboBoxModel;
import javax.swing.DefaultComboBoxModel;
import javax.swing.JCheckBox;
import javax.swing.JLabel;

import org.deckfour.uitopia.api.event.TaskListener.InteractionResult;
import org.deckfour.xes.model.XAttributeMap;
import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.framework.util.collection.AlphanumComparator;
import org.processmining.framework.util.ui.widgets.BorderPanel;
import org.processmining.framework.util.ui.widgets.ProMComboBox;
import org.processmining.framework.util.ui.widgets.ProMPropertiesPanel;
import org.processmining.framework.util.ui.widgets.WidgetColors;

import com.fluxicon.slickerbox.components.NiceSlider;
import com.fluxicon.slickerbox.components.NiceSlider.Orientation;
import com.fluxicon.slickerbox.components.SlickerTabbedPane;
import com.fluxicon.slickerbox.factory.SlickerFactory;

public class AttributeLogFilter_UI extends BorderPanel {

	private static final long serialVersionUID = 1L;

	public final static String DIALOG_TITLE = ""Filter Log by Properties"";
	public final static String ATTRIBUTE_DIALOG_TITLE = ""Filter Log by Attributes"";
	public final static String LENGTH_DIALOG_TITLE = ""Filter Log by Trace Length"";

	private XLog log;

	private JCheckBox attribute_filter_include_box;
	private ProMComboBox<String> attribute_filter_filter_on;
	private ProMComboBox<String> attribute_filter_log_attributes;
	private ProMComboBox<String> attribute_filter_log_values;

	private NiceSlider length_filter_min;
	private NiceSlider length_filter_max;

	@SuppressWarnings(""unchecked"")
	public AttributeLogFilter_UI(AttributeLogFilter filter) {
		super(0, 0);

		this.log = filter.log;

		SlickerTabbedPane tabs = SlickerFactory.instance().createTabbedPane("""", WidgetColors.COLOR_LIST_BG,
				WidgetColors.COLOR_LIST_FG, Color.GREEN);
		setLayout(new BorderLayout());
		add(tabs);

		ProMPropertiesPanel attributePanel = new ProMPropertiesPanel(ATTRIBUTE_DIALOG_TITLE);
		tabs.addTab(ATTRIBUTE_DIALOG_TITLE, attributePanel);
		attribute_filter_filter_on = new ProMComboBox<String>(new Object[] { AttributeLogFilter.NONE,
				AttributeLogFilter.TRACE_ATTRIBUTE, AttributeLogFilter.EVENT_ATTRIBUTE });
		attributePanel.addProperty(""filter on"", attribute_filter_filter_on);
		attribute_filter_filter_on.addActionListener(new FilterOnListener());

		// use
		attribute_filter_log_attributes = new ProMComboBox<String>(
				getAttributes((String) attribute_filter_filter_on.getSelectedItem()));
		attributePanel.addProperty(""attribute"", attribute_filter_log_attributes);
		attribute_filter_log_attributes.addActionListener(new AttributeListener());

		Set<String> values = getValues((String) attribute_filter_filter_on.getSelectedItem(),
				(String) attribute_filter_log_attributes.getSelectedItem());
		attribute_filter_log_values = new ProMComboBox<String>(values);
		MyComboBoxModel model = new MyComboBoxModel(MyComboBoxModel.NONE);
		attribute_filter_log_values.setModel(model);
		model.setSelectedItem(null);
		attributePanel.addProperty(""value"", attribute_filter_log_values);

		attribute_filter_include_box = SlickerFactory.instance().createCheckBox(null, true);
		attributePanel.addProperty(""keep matching traces"", attribute_filter_include_box);

		ProMPropertiesPanel lengthPanel = new ProMPropertiesPanel(LENGTH_DIALOG_TITLE);
		tabs.addTab(LENGTH_DIALOG_TITLE, lengthPanel);
		int min_length = Integer.MAX_VALUE;
		int max_length = Integer.MIN_VALUE;
		for (XTrace t : log) {
			if (t.size() < min_length)
				min_length = t.size();
			if (t.size() > max_length)
				max_length = t.size();
		}

		length_filter_min = new NiceSlider(null, min_length, max_length, min_length, Orientation.HORIZONTAL) {
			private static final long serialVersionUID = 1L;

			protected String formatValue(int arg0) {
				return Integer.toString(arg0);
			}
		};
		length_filter_min.remove(0); // remove the slider's label we already have one
		// set size and text of value label
		length_filter_min.getComponent(0).setForeground(WidgetColors.TEXT_COLOR);
		length_filter_min.getComponent(0).setMinimumSize(new Dimension(200, 16));
		length_filter_min.getComponent(0).setPreferredSize(new Dimension(200, 16));
		((JLabel) length_filter_min.getComponent(0)).setHorizontalAlignment(JLabel.RIGHT);
		// and put slider into the panel
		lengthPanel.addProperty(""minimum trace length"", length_filter_min);

		length_filter_max = new NiceSlider(null, min_length, max_length, max_length, Orientation.HORIZONTAL) {
			private static final long serialVersionUID = 1L;

			protected String formatValue(int arg0) {
				return Integer.toString(arg0);
			}
		};
		length_filter_max.remove(0); // remove the slider's label we already have one
		// set size and text of value label
		length_filter_max.getComponent(0).setForeground(WidgetColors.TEXT_COLOR);
		length_filter_max.getComponent(0).setMinimumSize(new Dimension(200, 16));
		length_filter_max.getComponent(0).setPreferredSize(new Dimension(200, 16));
		((JLabel) length_filter_max.getComponent(0)).setHorizontalAlignment(JLabel.RIGHT);
		// and put slider into the panel
		lengthPanel.addProperty(""maximum trace length"", length_filter_max);

		setFilterValues(filter);
	}

	/**
	 * Set values of controls based on values in the filter.
	 * 
	 * @param filter
	 */
	protected void setFilterValues(AttributeLogFilter filter) {
		attribute_filter_filter_on.setSelectedItem(filter.attribute_filterOn);
		attribute_filter_include_box.setSelected(filter.attribute_include);
		if (filter.attribute_key != null)
			attribute_filter_log_attributes.setSelectedItem(filter.attribute_key);
		if (filter.attribute_values != null)
			for (Object o : filter.attribute_values) {
				attribute_filter_log_values.setSelectedItem(o);
			}

		length_filter_min.getSlider().setValue(filter.length_min_value);
		length_filter_max.getSlider().setValue(filter.length_max_value);
	}

	/**
	 * display a dialog to ask user what to do
	 * 
	 * @param context
	 * @return
	 */
	protected InteractionResult getUserChoice(UIPluginContext context) {
		return context.showConfiguration(DIALOG_TITLE, this);
	}

	/**
	 * Populate filter object from settings in the panel.
	 * 
	 * @param filter
	 */
	@SuppressWarnings(""unchecked"")
	protected void getFilterValues(AttributeLogFilter filter) {
		filter.attribute_include = attribute_filter_include_box.isSelected();
		filter.attribute_filterOn = (String) attribute_filter_filter_on.getSelectedItem();
		filter.attribute_key = (String) attribute_filter_log_attributes.getSelectedItem();
		filter.attribute_values.clear();
		filter.attribute_values.addAll((List<String>) attribute_filter_log_values.getSelectedItem());

		filter.length_min_value = length_filter_min.getSlider().getValue();
		filter.length_max_value = length_filter_max.getSlider().getValue();
	}

	/**
	 * Open UI dialogue to populate the given configuration object with settings
	 * chosen by the user.
	 * 
	 * @param context
	 * @param config
	 * @return result of the user interaction
	 */
	public InteractionResult setParameters(UIPluginContext context, AttributeLogFilter filter) {
		InteractionResult wish = getUserChoice(context);
		if (wish != InteractionResult.CANCEL)
			getFilterValues(filter);
		return wish;
	}

	/**
	 * Listener to watch
	 * {@link AttributeLogFilter_UI#attribute_filter_filter_on} and store
	 * attribute names in
	 * {@link AttributeLogFilter_UI#attribute_filter_log_attributes} and updated
	 * {@link AttributeLogFilter_UI#attribute_filter_log_values} accordingly
	 */
	private class FilterOnListener implements ActionListener {

		@SuppressWarnings({ ""rawtypes"", ""unchecked"" })
		public void actionPerformed(ActionEvent e) {
			if (e.getID() == ActionEvent.ACTION_PERFORMED && e.getSource() == attribute_filter_filter_on) {

				TreeSet<String> attributeNames = getAttributes((String) attribute_filter_filter_on.getSelectedItem());
				attribute_filter_log_attributes.setModel(new DefaultComboBoxModel(attributeNames.toArray()));

				Set<String> values = getValues((String) attribute_filter_filter_on.getSelectedItem(),
						(String) attribute_filter_log_attributes.getSelectedItem());
				MyComboBoxModel model = new MyComboBoxModel(values.toArray());
				attribute_filter_log_values.setModel(model);
				model.setSelectedItem(null);

				//				attribute_filter_log_values.setModel(new DefaultComboBoxModel(values.toArray()));
			}
		}
	}

	/**
	 * Listener to watch
	 * {@link AttributeLogFilter_UI#attribute_filter_log_attributes} and store
	 * attribute names in
	 * {@link AttributeLogFilter_UI#attribute_filter_log_values}.
	 */
	private class AttributeListener implements ActionListener {

		@SuppressWarnings(""unchecked"")
		public void actionPerformed(ActionEvent e) {
			if (e.getID() == ActionEvent.ACTION_PERFORMED && e.getSource() == attribute_filter_log_attributes) {

				Set<String> values = getValues((String) attribute_filter_filter_on.getSelectedItem(),
						(String) attribute_filter_log_attributes.getSelectedItem());
				MyComboBoxModel model = new MyComboBoxModel(values.toArray());
				attribute_filter_log_values.setModel(model);
				model.setSelectedItem(null);

				//				attribute_filter_log_values.setModel(new DefaultComboBoxModel(values.toArray()));
			}
		}
	}

	/**
	 * Collect all attribute names of the selected category from
	 * {@link AttributeLogFilter_UI#log}
	 * 
	 * @param category
	 * @return
	 */
	private TreeSet<String> getAttributes(String category) {
		TreeSet<String> attributeNames = new TreeSet<String>();
		if (category == AttributeLogFilter.TRACE_ATTRIBUTE) {
			for (XTrace t : log) {
				XAttributeMap attributes = t.getAttributes();
				attributeNames.addAll(attributes.keySet());
			}

		} else if (category == AttributeLogFilter.EVENT_ATTRIBUTE) {
			for (XTrace trace : log) {
				for (XEvent event : trace) {
					XAttributeMap attributes = event.getAttributes();
					attributeNames.addAll(attributes.keySet());
				}
			}
		} else if (category == AttributeLogFilter.NONE) {
			attributeNames.add(""<none>"");
		}
		return attributeNames;
	}

	/**
	 * Collect all attribute values of the selected category and key from
	 * {@link AttributeLogFilter_UI#log}
	 * 
	 * @param category
	 * @return
	 */
	private Set<String> getValues(String category, String key) {
		TreeSet<String> values = new TreeSet<String>(new AlphanumComparator());
		if (category == AttributeLogFilter.TRACE_ATTRIBUTE) {
			for (XTrace t : log) {
				XAttributeMap attributes = t.getAttributes();
				if (attributes.containsKey(key))
					values.add(attributes.get(key).toString());
			}

		} else if (category == AttributeLogFilter.EVENT_ATTRIBUTE) {
			for (XTrace trace : log) {
				for (XEvent event : trace) {
					XAttributeMap attributes = event.getAttributes();
					if (attributes.containsKey(key))
						values.add(attributes.get(key).toString());
				}
			}
		} else if (category == AttributeLogFilter.NONE) {
			values.add(""<none>"");
		}
		return values;
	}

}

class MyComboBoxModel extends AbstractListModel<String> implements ComboBoxModel<String> {

	private static final long serialVersionUID = 1759722993311195116L;
	public static Object NONE = ""none"";
	List<String> values = new ArrayList<String>();
	List<String> selected = new ArrayList<String>();

	public MyComboBoxModel(Object... values) {
		for (Object object : values) {
			if (object == null || object == NONE || !(object instanceof String)) {
				continue;
			}
			this.values.add((String)object);
		}
	}

	@Override
	public int getSize() {
		return values.size();
	}

	@Override
	public String getElementAt(int index) {
		return values.get(index);
	}

	public void setSelectedItem(Object anItem) {
		if (anItem == null || anItem == NONE || !(anItem instanceof String)) {
			if (selected.isEmpty())
				return;
			selected.clear();
		} else {
			boolean removed = selected.remove(anItem);
			if (!removed) {
				selected.add((String)anItem);
			}
		}
		fireContentsChanged(this, -1, -1);
	}

	@Override
	public Object getSelectedItem() {
		return selected;
	}


}
"
AddIdentityFilter.java,log,"
package org.processmining.log.filters;

import java.util.HashMap;
import java.util.Map;
import java.util.Map.Entry;

import org.deckfour.xes.extension.std.XIdentityExtension;
import org.deckfour.xes.id.XID;
import org.deckfour.xes.id.XIDFactory;
import org.deckfour.xes.model.XAttributable;
import org.deckfour.xes.model.XAttribute;
import org.deckfour.xes.model.XAttributeBoolean;
import org.deckfour.xes.model.XAttributeContinuous;
import org.deckfour.xes.model.XAttributeDiscrete;
import org.deckfour.xes.model.XAttributeID;
import org.deckfour.xes.model.XAttributeLiteral;
import org.deckfour.xes.model.XAttributeTimestamp;
import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.log.xes.extensions.id.IdentityConnection;
import org.processmining.plugins.log.logfilters.LogFilter;
import org.processmining.plugins.log.logfilters.LogFilterException;
import org.processmining.plugins.log.logfilters.XEventEditor;
import org.processmining.plugins.log.logfilters.XTraceEditor;

public class AddIdentityFilter implements XEventEditor, XTraceEditor {

	public static XLog addIdentities(PluginContext context, XLog log) {
		AddIdentityFilter af = new AddIdentityFilter(log);

		try {
			return af.filter(context);
		} catch (LogFilterException e) {
			e.printStackTrace();
		}

		return null;
	}

	protected AddIdentityFilter(XLog log) {
		this.log = log;
	}

	private XLog log;

	public XLog filter(PluginContext context) throws LogFilterException {
		idmapping = new HashMap<String, XAttributable>();

		attributeValueMapping = new HashMap<String, Map<Object, XID>>();

		addIdentity(log);
		XLog filtered = LogFilter.filter(context.getProgress(), log.size(), log, null, this, this);
		//create connection
		context.addConnection(getConnection(filtered));

		return filtered;
	}

	public IdentityConnection getConnection(XLog filtered) {
		return new IdentityConnection(filtered, idmapping);
	}

	public XTrace editTrace(XTrace trace) {
		addIdentity(trace);
		return trace;
	}

	public XEvent editEvent(XEvent event) {
		XEvent editedEvent = (XEvent) event.clone();
		addIdentity(editedEvent);

		return editedEvent;
	}

	private Map<String, XAttributable> idmapping;

	private void addIdentity(XAttributable target) {
		//if I'm the identity, ignore me!
		if (target instanceof XAttribute) {
			if (((XAttribute) target).getKey() == XIdentityExtension.KEY_ID) {
				return;
			}
		}

		//first add an identity to my kids...
		for (Entry<String, XAttribute> attr : target.getAttributes().entrySet()) {
			addIdentity(attr.getValue());
		}

		//then to me
		XID id = XIdentityExtension.instance().extractID(target);
		if (id == null) {

			//first check, whether ""I""already have an id in my attribute mapping...
			if (target instanceof XAttribute) {
				id = getIdFromMemory((XAttribute) target);
			} else {
				id = XIDFactory.instance().createId();
			}
		}
		XIdentityExtension.instance().assignID(target, id);

		//store the mapping
		idmapping.put(id.toString(), target);
	}

	private Map<String, Map<Object, XID>> attributeValueMapping;

	private XID getIdFromMemory(XAttribute attr) {
		String key = attr.getKey();

		Map<Object, XID> values = attributeValueMapping.get(key);
		if (values == null) {
			values = new HashMap<Object, XID>();
			attributeValueMapping.put(key, values);
		}

		Object value = getValueOf(attr);
		XID id = values.get(value);
		if (id == null) {
			id = XIDFactory.instance().createId();
			values.put(value, id);
		}

		return id;
	}

	private Object getValueOf(XAttribute attr) {

		if (attr instanceof XAttributeBoolean) {
			return ((XAttributeBoolean) attr).getValue();
		} else if (attr instanceof XAttributeContinuous) {
			return ((XAttributeContinuous) attr).getValue();
		} else if (attr instanceof XAttributeDiscrete) {
			return ((XAttributeDiscrete) attr).getValue();
		} else if (attr instanceof XAttributeTimestamp) {
			return ((XAttributeTimestamp) attr).getValue();
		} else if (attr instanceof XAttributeLiteral) {
			return ((XAttributeLiteral) attr).getValue();
		} else if (attr instanceof XAttributeID) {
			return ((XAttributeID) attr).getValue();
		} else {
			return new Object();
		}
	}

}
"
ExtensionFilter.java,log,"package org.processmining.log.filters;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashSet;
import java.util.Map.Entry;
import java.util.Set;

import org.deckfour.xes.extension.XExtension;
import org.deckfour.xes.model.XAttributable;
import org.deckfour.xes.model.XAttribute;
import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.processmining.framework.plugin.Progress;
import org.processmining.plugins.log.logfilters.LogFilter;
import org.processmining.plugins.log.logfilters.LogFilterException;
import org.processmining.plugins.log.logfilters.XEventEditor;
import org.processmining.plugins.log.logfilters.XTraceEditor;

/**
 * 
 * 
 * 
 * @author jvdwerf
 *
 */
public class ExtensionFilter implements XEventEditor, XTraceEditor {

	public static XLog removeExtensions(XLog log, XExtension extension) {		
		return removeExtensions(null, log, extension);
	}
	
	public static XLog removeExtensions(XLog log, String extension) {		
		return removeExtensions(null, log, extension);
	}
	
	
	public static XLog removeExtensions(Progress progress, XLog log, XExtension extension) {
		return removeExtensions(progress, log, extension.getName());
	}
	
	public static XLog removeExtensions(Progress progress, XLog log, String extension) {
		Set<String> names = new HashSet<String>();
		names.add(extension);
		
		return removeExtensions(progress, log, names);
	}
	
	public static XLog removeExtensions(Progress progress, XLog log, String... extensions) {
		return removeExtensions(progress, log, Arrays.asList(extensions));
	}
	
	public static XLog removeExtensions(Progress progress, XLog log, Collection<String> extensions) {

		ExtensionFilter ef = new ExtensionFilter((XLog) log.clone());
		
		try {
			return ef.filter(progress, extensions);
			
		} catch (LogFilterException e) {
			e.printStackTrace();
		}
		
		return null;
	}
	
	//////
	///
	
	private Set<String> attrKeys;
	private Set<String> logKeys;
	private Set<String> traceKeys;
	private Set<String> eventKeys;
	
	private XLog log;
	
	public ExtensionFilter(XLog log) {
		this.log = log;
	}
	
	public XLog getLog() {
		return log;
	}
	
	public XLog filter(Progress progress, Collection<String> extensions) throws LogFilterException {
		
		//set the attribute sets, and remove extensions from log
		prepareExtensionList(extensions);
		
		removeAttributes(log, logKeys);
		
		return LogFilter.filter(progress, log.size(), log, null, this, this);
	}
	
	private void prepareExtensionList(Collection<String> extensions) {
		attrKeys = new HashSet<String>();
		logKeys = new HashSet<String>();
		traceKeys = new HashSet<String>();
		eventKeys = new HashSet<String>();
		
		Collection<XExtension> tbr = new ArrayList<XExtension>();
		
		for(XExtension ext : log.getExtensions()) {
			if (extensions.contains(ext.getName())) {
				for(XAttribute attr : ext.getLogAttributes()) {
					logKeys.add(attr.getKey());
				}
				for(XAttribute attr : ext.getTraceAttributes()) {
					traceKeys.add(attr.getKey());
				}
				for(XAttribute attr : ext.getEventAttributes()) {
					eventKeys.add(attr.getKey());
				}
				for(XAttribute attr : ext.getMetaAttributes()) {
					attrKeys.add(attr.getKey());
				}
				
				tbr.add(ext);
			}
		}
		
		log.getExtensions().removeAll(tbr);
	}
	
	public XTrace editTrace(XTrace trace) {
		
		removeAttributes(trace, traceKeys);
		
		return trace;
	}

	public XEvent editEvent(XEvent event) {
		XEvent editedEvent = (XEvent) event.clone();
		
		removeAttributes(editedEvent, eventKeys);
		
		return editedEvent;
	}
	
	private void removeAttributes(XAttributable target, Set<String> items) {
		for(String key : items) {
			target.getAttributes().remove(key);
		}
		for(Entry<String,XAttribute> attr : target.getAttributes().entrySet()) {
			removeAttributes(attr.getValue(), attrKeys);
		}
	}
	
	
	
	
}
"
AddIdentityFilterUI.java,log,"package org.processmining.log.filters.ui;

import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.model.XLog;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.log.filters.AddIdentityFilter;

@Plugin(name = ""Add identity attribute"", returnLabels = { ""Log with identities"" }, returnTypes = {
		XLog.class }, parameterLabels = { ""Log"" })
public class AddIdentityFilterUI {

	@UITopiaVariant(uiLabel = ""Add identities to log"", affiliation = UITopiaVariant.EHV, author = ""J.M.E.M. van der Werf"", email = ""j.m.e.m.v.d.werf@tue.nl"", pack = ""Ontologies"")
	@PluginVariant(variantLabel = ""Add identities to log"", requiredParameterLabels = { 0 })
	public XLog addIdentitiesUI(UIPluginContext context, XLog log) {
		return addIdentities(context, log);
	}

	@PluginVariant(variantLabel = ""Add identities to log"", requiredParameterLabels = { 0 })
	public XLog addIdentities(PluginContext context, XLog log) {
		XLog filtered = AddIdentityFilter.addIdentities(context, log);
		if (filtered != null) {
			String name = XConceptExtension.instance().extractName(log);
			if (name == null) {
				name = ""Log"";
			}
			context.getFutureResult(0).setLabel(name + "" with identities"");
			return filtered;
		} else {
			context.getFutureResult(0).cancel(true);
			return null;
		}
	}

}
"
ExtensionFilterUI.java,log,"package org.processmining.log.filters.ui;

import java.util.HashSet;
import java.util.Set;

import javax.swing.DefaultListModel;
import javax.swing.JComponent;

import org.deckfour.xes.extension.XExtension;
import org.deckfour.xes.model.XLog;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.framework.util.ui.widgets.ProMList;
import org.processmining.framework.util.ui.widgets.ProMPropertiesPanel;
import org.processmining.framework.util.ui.wizard.ListWizard;
import org.processmining.framework.util.ui.wizard.ProMWizardDisplay;
import org.processmining.framework.util.ui.wizard.ProMWizardStep;
import org.processmining.log.filters.ExtensionFilter;

@Plugin(name = ""Extension Filter"", returnLabels = { ""Filtered log"" }, returnTypes = { XLog.class }, parameterLabels = {
		""Log"" })
public class ExtensionFilterUI {

	@UITopiaVariant(uiLabel = ""Remove extensions from log"", affiliation = UITopiaVariant.EHV, author = ""J.M.E.M. van der Werf"", email = ""j.m.e.m.v.d.werf@tue.nl"", pack = ""Ontologies"")
	@PluginVariant(variantLabel = ""Remove extensions from log"", requiredParameterLabels = { 0 })
	public XLog removeExtensions(final UIPluginContext context, final XLog log) {

		Step wizardStep = new Step(log);
		ListWizard<Set<String>> wizard = new ListWizard<Set<String>>(wizardStep);

		Set<String> extensions = ProMWizardDisplay.show(context, wizard, new HashSet<String>());

		if (extensions == null || extensions.size() == 0) {
			context.getFutureResult(0).cancel(true);
			return null;
		}

		return ExtensionFilter.removeExtensions(context.getProgress(), log, extensions);
	}

	/*
	 * ProMPropertiesPanel props = new ProMPropertiesPanel(""Remove extensions"");
	 * //ProMList extList = new ProMList(""Extensions"", listModel);
	 * props.add(extList);
	 * 
	 */
	private class Step implements ProMWizardStep<Set<String>> {

		public String getTitle() {
			return ""Remove extensions"";
		}

		private ProMPropertiesPanel panel;
		private ProMList listbox;

		public Step(XLog log) {
			panel = new ProMPropertiesPanel(null);

			DefaultListModel model = new DefaultListModel();

			for (XExtension ext : log.getExtensions()) {
				model.addElement(ext.getName());
			}

			//add a list
			listbox = new ProMList(""Extensions"", model);
			panel.addProperty(""Extensions to be removed"", listbox);
		}

		public JComponent getComponent(Set<String> model) {

			listbox.setSelection(model);

			return panel;
		}

		public Set<String> apply(Set<String> model, JComponent component) {
			//set the model to all selected items.
			Set<String> items = new HashSet<String>();
			for (Object o : listbox.getSelectedValues()) {
				items.add((String) o);
			}
			return items;
		}

		public boolean canApply(Set<String> model, JComponent component) {
			return true;
		}

	}

}
"
StandardDateFormats.java,log,"package org.processmining.log.formats;

import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.LinkedHashSet;
import java.util.Set;

/**
 * Standard formats for Dates that might be encountered in log data, e.g. in CSV
 * format.
 */
public final class StandardDateFormats {

	@SuppressWarnings(""serial"")
	private static final Set<SimpleDateFormat> STANDARD_DATE_FORMATS = new LinkedHashSet<SimpleDateFormat>() {
		{
			add(new SimpleDateFormat(""yyyy-M-d H:mm:ss.SSSXXX""));
			add(new SimpleDateFormat(""yyyy-M-d H:mm:ss.SSSz""));
			add(new SimpleDateFormat(""yyyy-M-d H:mm:ss.SSS""));
			add(new SimpleDateFormat(""yyyy-M-d H:mm:ssXXX""));
			add(new SimpleDateFormat(""yyyy-M-d H:mm:ssz""));
			add(new SimpleDateFormat(""yyyy-M-d H:mm:ss""));
			add(new SimpleDateFormat(""yyyy-M-d H:mm""));
			add(new SimpleDateFormat(""yyyy-M-d'T'H:mm:ss.SSSXXX""));
			add(new SimpleDateFormat(""yyyy-M-d'T'H:mm:ss.SSSz""));
			add(new SimpleDateFormat(""yyyy-M-d'T'H:mm:ss.SSS""));
			add(new SimpleDateFormat(""yyyy-M-d'T'H:mm:ssXXX""));
			add(new SimpleDateFormat(""yyyy-M-d'T'H:mm:ssz""));
			add(new SimpleDateFormat(""yyyy-M-d'T'H:mm:ss""));
			add(new SimpleDateFormat(""yyyy-M-d'T'H:mm""));
			add(new SimpleDateFormat(""yyyy-M-d""));

			add(new SimpleDateFormat(""yyyy-MM-dd HH:mm:ss.SSSXXX""));
			add(new SimpleDateFormat(""yyyy-MM-dd HH:mm:ss.SSSz""));
			add(new SimpleDateFormat(""yyyy-MM-dd HH:mm:ss.SSS""));
			add(new SimpleDateFormat(""yyyy-MM-dd HH:mm:ssXXX""));
			add(new SimpleDateFormat(""yyyy-MM-dd HH:mm:ssz""));
			add(new SimpleDateFormat(""yyyy-MM-dd HH:mm:ss""));
			add(new SimpleDateFormat(""yyyy-MM-dd HH:mm""));
			add(new SimpleDateFormat(""yyyy-MM-dd'T'HH:mm:ss.SSSXXX""));
			add(new SimpleDateFormat(""yyyy-MM-dd'T'HH:mm:ss.SSSz""));
			add(new SimpleDateFormat(""yyyy-MM-dd'T'HH:mm:ss.SSS""));
			add(new SimpleDateFormat(""yyyy-MM-dd'T'HH:mm:ssXXX""));
			add(new SimpleDateFormat(""yyyy-MM-dd'T'HH:mm:ssz""));
			add(new SimpleDateFormat(""yyyy-MM-dd'T'HH:mm:ss""));
			add(new SimpleDateFormat(""yyyy-MM-dd'T'HH:mm""));
			add(new SimpleDateFormat(""yyyy-MM-dd""));

			add(new SimpleDateFormat(""yyyy/M/d H:mm:ss.SSSXXX""));
			add(new SimpleDateFormat(""yyyy/M/d H:mm:ss.SSSz""));
			add(new SimpleDateFormat(""yyyy/M/d H:mm:ss.SSS""));
			add(new SimpleDateFormat(""yyyy/M/d H:mm:ssXXX""));
			add(new SimpleDateFormat(""yyyy/M/d H:mm:ssz""));
			add(new SimpleDateFormat(""yyyy/M/d H:mm:ss""));
			add(new SimpleDateFormat(""yyyy/M/d H:mm""));
			add(new SimpleDateFormat(""yyyy/M/d'T'H:mm:ss.SSSXXX""));
			add(new SimpleDateFormat(""yyyy/M/d'T'H:mm:ss.SSSz""));
			add(new SimpleDateFormat(""yyyy/M/d'T'H:mm:ss.SSS""));
			add(new SimpleDateFormat(""yyyy/M/d'T'H:mm:ssXXX""));
			add(new SimpleDateFormat(""yyyy/M/d'T'H:mm:ssz""));
			add(new SimpleDateFormat(""yyyy/M/d'T'H:mm:ss""));
			add(new SimpleDateFormat(""yyyy/M/d'T'H:mm""));
			add(new SimpleDateFormat(""yyyy/M/d""));

			add(new SimpleDateFormat(""yyyy/MM/dd HH:mm:ss.SSSXXX""));
			add(new SimpleDateFormat(""yyyy/MM/dd HH:mm:ss.SSSz""));
			add(new SimpleDateFormat(""yyyy/MM/dd HH:mm:ss.SSS""));
			add(new SimpleDateFormat(""yyyy/MM/dd HH:mm:ssXXX""));
			add(new SimpleDateFormat(""yyyy/MM/dd HH:mm:ssz""));
			add(new SimpleDateFormat(""yyyy/MM/dd HH:mm:ss""));
			add(new SimpleDateFormat(""yyyy/MM/dd HH:mm""));
			add(new SimpleDateFormat(""yyyy/MM/dd'T'HH:mm:ss.SSSXXX""));
			add(new SimpleDateFormat(""yyyy/MM/dd'T'HH:mm:ss.SSSz""));
			add(new SimpleDateFormat(""yyyy/MM/dd'T'HH:mm:ss.SSS""));
			add(new SimpleDateFormat(""yyyy/MM/dd'T'HH:mm:ssXXX""));
			add(new SimpleDateFormat(""yyyy/MM/dd'T'HH:mm:ssz""));
			add(new SimpleDateFormat(""yyyy/MM/dd'T'HH:mm:ss""));
			add(new SimpleDateFormat(""yyyy/MM/dd'T'HH:mm""));
			add(new SimpleDateFormat(""yyyy/MM/dd""));

			add(new SimpleDateFormat(""M/d/yyyy H:mm:ss.SSSXXX""));
			add(new SimpleDateFormat(""M/d/yyyy H:mm:ss.SSSz""));
			add(new SimpleDateFormat(""M/d/yyyy H:mm:ss.SSS""));
			add(new SimpleDateFormat(""M/d/yyyy H:mm:ssXXX""));
			add(new SimpleDateFormat(""M/d/yyyy H:mm:ssz""));
			add(new SimpleDateFormat(""M/d/yyyy H:mm:ss""));
			add(new SimpleDateFormat(""M/d/yyyy H:mm""));
			add(new SimpleDateFormat(""M/d/yyyy'T'H:mm:ss.SSSXXX""));
			add(new SimpleDateFormat(""M/d/yyyy'T'H:mm:ss.SSSz""));
			add(new SimpleDateFormat(""M/d/yyyy'T'H:mm:ss.SSS""));
			add(new SimpleDateFormat(""M/d/yyyy'T'H:mm:ssXXX""));
			add(new SimpleDateFormat(""M/d/yyyy'T'H:mm:ssz""));
			add(new SimpleDateFormat(""M/d/yyyy'T'H:mm:ss""));
			add(new SimpleDateFormat(""M/d/yyyy'T'H:mm""));
			add(new SimpleDateFormat(""M/d/yyyy""));

			add(new SimpleDateFormat(""MM/dd/yyyy HH:mm:ss.SSSXXX""));
			add(new SimpleDateFormat(""MM/dd/yyyy HH:mm:ss.SSSz""));
			add(new SimpleDateFormat(""MM/dd/yyyy HH:mm:ss.SSS""));
			add(new SimpleDateFormat(""MM/dd/yyyy HH:mm:ssXXX""));
			add(new SimpleDateFormat(""MM/dd/yyyy HH:mm:ssz""));
			add(new SimpleDateFormat(""MM/dd/yyyy HH:mm:ss""));
			add(new SimpleDateFormat(""MM/dd/yyyy HH:mm""));
			add(new SimpleDateFormat(""MM/dd/yyyy'T'HH:mm:ss.SSSXXX""));
			add(new SimpleDateFormat(""MM/dd/yyyy'T'HH:mm:ss.SSSz""));
			add(new SimpleDateFormat(""MM/dd/yyyy'T'HH:mm:ss.SSS""));
			add(new SimpleDateFormat(""MM/dd/yyyy'T'HH:mm:ssXXX""));
			add(new SimpleDateFormat(""MM/dd/yyyy'T'HH:mm:ssz""));
			add(new SimpleDateFormat(""MM/dd/yyyy'T'HH:mm:ss""));
			add(new SimpleDateFormat(""MM/dd/yyyy'T'HH:mm""));
			add(new SimpleDateFormat(""MM/dd/yyyy""));
			
			add(new SimpleDateFormat(""dd/MM/yyyy HH:mm:ss.SSSXXX""));
			add(new SimpleDateFormat(""dd/MM/yyyy HH:mm:ss.SSSz""));
			add(new SimpleDateFormat(""dd/MM/yyyy HH:mm:ss.SSS""));
			add(new SimpleDateFormat(""dd/MM/yyyy HH:mm:ssXXX""));
			add(new SimpleDateFormat(""dd/MM/yyyy HH:mm:ssz""));
			add(new SimpleDateFormat(""dd/MM/yyyy HH:mm:ss""));
			add(new SimpleDateFormat(""dd/MM/yyyy HH:mm""));
			add(new SimpleDateFormat(""dd/MM/yyyy'T'HH:mm:ss.SSSXXX""));
			add(new SimpleDateFormat(""dd/MM/yyyy'T'HH:mm:ss.SSSz""));
			add(new SimpleDateFormat(""dd/MM/yyyy'T'HH:mm:ss.SSS""));
			add(new SimpleDateFormat(""dd/MM/yyyy'T'HH:mm:ssXXX""));
			add(new SimpleDateFormat(""dd/MM/yyyy'T'HH:mm:ssz""));
			add(new SimpleDateFormat(""dd/MM/yyyy'T'HH:mm:ss""));
			add(new SimpleDateFormat(""dd/MM/yyyy'T'HH:mm""));	

			add(new SimpleDateFormat(""yyyy.M.d H:mm:ss.SSSXXX""));
			add(new SimpleDateFormat(""yyyy.M.d H:mm:ss.SSSz""));
			add(new SimpleDateFormat(""yyyy.M.d H:mm:ss.SSS""));
			add(new SimpleDateFormat(""yyyy.M.d H:mm:ssXXX""));
			add(new SimpleDateFormat(""yyyy.M.d H:mm:ssz""));
			add(new SimpleDateFormat(""yyyy.M.d H:mm:ss""));
			add(new SimpleDateFormat(""yyyy.M.d H:mm""));

			add(new SimpleDateFormat(""yyyy.MM.dd HH:mm:ss.SSSXXX""));
			add(new SimpleDateFormat(""yyyy.MM.dd HH:mm:ss.SSSz""));
			add(new SimpleDateFormat(""yyyy.MM.dd HH:mm:ss.SSS""));
			add(new SimpleDateFormat(""yyyy.MM.dd HH:mm:ssXXX""));
			add(new SimpleDateFormat(""yyyy.MM.dd HH:mm:ssz""));
			add(new SimpleDateFormat(""yyyy.MM.dd HH:mm:ss""));
			add(new SimpleDateFormat(""yyyy.MM.dd HH:mm""));
			
			add(new SimpleDateFormat(""dd.MM.yyyy HH:mm:ss.SSSXXX""));
			add(new SimpleDateFormat(""dd.MM.yyyy HH:mm:ss.SSSz""));
			add(new SimpleDateFormat(""dd.MM.yyyy HH:mm:ss.SSS""));
			add(new SimpleDateFormat(""dd.MM.yyyy HH:mm:ssXXX""));
			add(new SimpleDateFormat(""dd.MM.yyyy HH:mm:ssz""));
			add(new SimpleDateFormat(""dd.MM.yyyy HH:mm:ss""));
			add(new SimpleDateFormat(""dd.MM.yyyy HH:mm""));

			add(new SimpleDateFormat(""d-M-yyyy:H:mm:ss""));
			add(new SimpleDateFormat(""EEE, d MMM yyyy H:mm:ss z""));
			add(new SimpleDateFormat(""M-d-yyyy H:mm:ss""));
			add(new SimpleDateFormat(""M-d-yyyy H:mm""));
			add(new SimpleDateFormat(""M-d-yyyy""));
			add(new SimpleDateFormat(""d-M-yyyy H:mm:ss""));
			add(new SimpleDateFormat(""d-M-yyyy H:mm""));
			add(new SimpleDateFormat(""d-M-yyyy""));

			add(new SimpleDateFormat(""dd-MM-yyyy:HH:mm:ss""));
			add(new SimpleDateFormat(""EEE, dd MMM yyyy HH:mm:ss z""));
			add(new SimpleDateFormat(""MM-dd-yyyy HH:mm:ss""));
			add(new SimpleDateFormat(""MM-dd-yyyy HH:mm""));
			add(new SimpleDateFormat(""MM-dd-yyyy""));
			add(new SimpleDateFormat(""dd-MM-yyyy HH:mm:ss""));
			add(new SimpleDateFormat(""dd-MM-yyyy HH:mm""));
			add(new SimpleDateFormat(""dd-MM-yyyy""));
			
			add(new SimpleDateFormat(""dd.MM.yyyy HH.mm""));
		}
	};

	static {
		for (DateFormat df : STANDARD_DATE_FORMATS) {
			df.setLenient(false);
		}
	}

	private StandardDateFormats() {
		super();
	}

	/**
	 * @return {@link SimpleDateFormat} for various {@link Date} patterns in
	 *         order from most specific to least specific.
	 */
	public static Iterable<SimpleDateFormat> getStandardDateFormats() {
		return STANDARD_DATE_FORMATS;
	}

}
"
HighFrequencyFilterArrayHelp.java,log,"package org.processmining.log.help;

public class HighFrequencyFilterArrayHelp {

	public final static String TEXT = """"
			+ ""Filters every log in the array using a frequency threshold (a percentage) and a distance threshold (edit distance). ""
			+ ""Any trace that either<ol>""
			+ ""<li>has a high-enough frequency or</li>""
			+ ""<li>is close enough to a trace with high-enough frequency</li>""
			+ ""</ol>will be filtered in. ""
			+ ""A trace has high-enough frequency if its frequency is required to reach the overall frequency threshold."";

}
"
HighFrequencyFilterHelp.java,log,"package org.processmining.log.help;

public class HighFrequencyFilterHelp {

	public final static String TEXT = """"
			+ ""Filters a log using a frequency threshold (a percentage) and a distance threshold (edit distance). ""
			+ ""Any trace that either<ol>""
			+ ""<li>has a high-enough frequency or</li>""
			+ ""<li>is close enough to a trace with high-enough frequency</li>""
			+ ""</ol>will be filtered in. ""
			+ ""A trace has high-enough frequency if its frequency is required to reach the overall frequency threshold."";

}
"
LogCentralityFilterHelp.java,log,"package org.processmining.log.help;

public class LogCentralityFilterHelp {

	public final static String TEXT = """"
			+ ""Filters a log using a centrality threshold (edit distance). ""
			+ ""Any trace that is close enough to the centre will be filtered in."";

}
"
LogCentralityHelp.java,log,"package org.processmining.log.help;

public class LogCentralityHelp {

	public final static String TEXT = """"
			+ ""Extends the log with centrality information, that is, with distances between all traces."";

}
"
LogCheckerHelp.java,log,"package org.processmining.log.help;

public class LogCheckerHelp {

	public final static String TEXT = """"
			+ ""Checks a log for common problems."";
}
"
LogFrequencyArrayHelp.java,log,"package org.processmining.log.help;

public class LogFrequencyArrayHelp {

	public final static String TEXT = """"
			+ ""Builds frequency overviews (how often traces occur) for every log in the array. ""
			+ ""The classifier provided determines which traces are considered equal."";

}
"
LogFrequencyHelp.java,log,"package org.processmining.log.help;

public class LogFrequencyHelp {

	public final static String TEXT = """"
			+ ""Filters a log using a frequency threshold (a percentage). ""
			+ ""Any trace that has a high-enough frequency will be filtered in. ""
			+ ""A trace has high-enough frequency if its frequency is required to reach the overall frequency threshold."";

}
"
LowFrequencyFilterArrayHelp.java,log,"package org.processmining.log.help;

public class LowFrequencyFilterArrayHelp {

	public final static String TEXT = """"
			+ ""Filters every log in the array using a frequency threshold. ""
			+ ""Traces that do not appear frequent enough, will be filtered out."";

}
"
LowFrequencyFilterHelp.java,log,"package org.processmining.log.help;

public class LowFrequencyFilterHelp {

	public final static String TEXT = """"
			+ ""Filters a log using a frequency threshold. ""
			+ ""Traces that do not appear frequent enough, will be filtered out. "";

}
"
LowOccurrencesFilterArrayHelp.java,log,"package org.processmining.log.help;

public class LowOccurrencesFilterArrayHelp {

	public final static String TEXT = """"
			+ ""Filters every log in the array using an absolute threshold. ""
			+ ""Traces that do not appear often enough, will be filtered out. "";

}
"
LowOccurrencesFilterHelp.java,log,"package org.processmining.log.help;

public class LowOccurrencesFilterHelp {

	public final static String TEXT = """"
			+ ""Filters a log using an absolute threshold. ""
			+ ""Traces that do not appear often enough, will be filtered out. "";

}
"
MergeLogsHelp.java,log,"package org.processmining.log.help;

public class MergeLogsHelp {

	public final static String TEXT = """"
			+ ""Merges two logs."";
}
"
SplitLogHelp.java,log,"package org.processmining.log.help;

public class SplitLogHelp {

	public final static String TEXT = """"
			+ ""Splits traces in a log on a selected event attribute. ""
			+ ""If the attribute exists for an event, then it is assumed to be a white-space spearated list of values. ""
			+ ""A trace will be split into as many subtraces as there are values in its events for the selected attribute. ""
			+ ""The subtrace for a given value contains (in the same order as in the trace) all events that: ""
			+ ""(1) either contain this value in the attribute value or (2) have no such attribute."";
}
"
LogCheckConsistentTypes.java,log,"package org.processmining.log.logchecks.impl;

import java.util.HashMap;
import java.util.Map;

import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.model.XAttribute;
import org.deckfour.xes.model.XAttributeBoolean;
import org.deckfour.xes.model.XAttributeContinuous;
import org.deckfour.xes.model.XAttributeDiscrete;
import org.deckfour.xes.model.XAttributeID;
import org.deckfour.xes.model.XAttributeList;
import org.deckfour.xes.model.XAttributeLiteral;
import org.deckfour.xes.model.XAttributeTimestamp;
import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.log.logchecks.LogCheck;
import org.processmining.log.models.LogCheckerReport;

public class LogCheckConsistentTypes implements LogCheck {

	private enum Type {
		LITERAL(""string""), //
		DISCRETE(""int""), //
		CONTINUOUS(""double""), //
		TIMESTAMP(""date""), // 
		BOOLEAN(""boolean""), //
		ID(""id""), //
		LIST(""list""), //
		UNKNOWN(""unknown""); //

		private String label;

		Type(String label) {
			this.label = label;
		}

		public String toString() {
			return label;
		}
	};

	private static LogCheck instance;

	private LogCheckConsistentTypes() {

	}

	public static LogCheck getInstance() {
		if (instance == null) {
			instance = new LogCheckConsistentTypes();
		}
		return instance;
	}

	public boolean checkTraces(PluginContext context, XLog log, LogCheckerReport report) {
		boolean allOk = true;
		Map<String, Type> traceAttributeTypes = new HashMap<String, Type>();
		for (XAttribute attribute : log.getGlobalTraceAttributes()) {
			Type existingType = traceAttributeTypes.get(attribute.getKey());
			Type type = getType(attribute);
			if (existingType == null) {
				traceAttributeTypes.put(attribute.getKey(), type);
			} else if (type != existingType) {
				report.add(allOk ? ""<h2>Inconsistent types for trace attribute</h2><ul>"" : """");
				report.add(""<li>Global attribute key "" + attribute.getKey() + "": "" + type + "" vs. "" + existingType + ""</li>"");
				allOk = false;
			}
		}
		int traceCtr = 0;
		for (XTrace trace : log) {
			for (XAttribute attribute : trace.getAttributes().values()) {
				Type existingType = traceAttributeTypes.get(attribute.getKey());
				Type type = getType(attribute);
				if (existingType == null) {
					traceAttributeTypes.put(attribute.getKey(), type);
				} else if (type != existingType) {
					String traceId = "" at position "" + traceCtr;
					if (trace.getAttributes().containsKey(XConceptExtension.KEY_NAME)) {
						traceId = XConceptExtension.instance().extractName(trace) + "" "" + traceId;
					} else {
						traceId = ""<i>unknown</i> "" + traceId;
					}
					report.add(allOk ? ""<h2>Inconsistent types for trace attribute</h2><ul>"" : """");
					report.add(""<li>Trace "" + traceId + "", attribute key "" + attribute.getKey() + "": "" + type + "" vs. "" + existingType + ""</li>"");
					allOk = false;
				}
			}
			traceCtr++;
		}
		report.add(allOk ? """" : ""</ul>"");
		return allOk;
	}

	public boolean checkEvents(PluginContext context, XLog log, LogCheckerReport report) {
		boolean allOk = true;
		Map<String, Type> eventAttributeTypes = new HashMap<String, Type>();
		for (XAttribute attribute : log.getGlobalEventAttributes()) {
			Type existingType = eventAttributeTypes.get(attribute.getKey());
			Type type = getType(attribute);
			if (existingType == null) {
				eventAttributeTypes.put(attribute.getKey(), type);
			} else if (type != existingType) {
				report.add(allOk ? ""<h2>Inconsistent types for event attribute</h2><ul>"" : """");
				report.add(""<li>Attribute key "" + attribute.getKey() + "": "" + type + "" vs. "" + existingType + ""</li>"");
				allOk = false;
			}
		}
		int traceCtr = 0;
		for (XTrace trace : log) {
			int eventCtr = 0;
			for (XEvent event : trace) {
				for (XAttribute attribute : event.getAttributes().values()) {
					Type existingType = eventAttributeTypes.get(attribute.getKey());
					Type type = getType(attribute);
					if (existingType == null) {
						eventAttributeTypes.put(attribute.getKey(), getType(attribute));
					} else if (type != existingType) {
						String traceId = "" at position "" + traceCtr;
						if (trace.getAttributes().containsKey(XConceptExtension.KEY_NAME)) {
							traceId = XConceptExtension.instance().extractName(trace) + "" "" + traceId;
						} else {
							traceId = ""<i>unknown</i> "" + traceId;
						}
						String eventId = "" at position "" + eventCtr;
						if (event.getAttributes().containsKey(XConceptExtension.KEY_NAME)) {
							eventId = XConceptExtension.instance().extractName(event) + "" "" + eventId;
						} else {
							eventId = ""<i>unknown</i> "" + eventId;
						}
						report.add(allOk ? ""<h2>Inconsistent types for event attribute</h2><ul>"" : """");
						report.add(""<li>Trace "" + traceId + "", event "" + eventId + "", attribute key "" + attribute.getKey() + "": "" + type + "" vs. "" + existingType + ""</li>"");
						allOk = false;
					}
				}
				eventCtr++;
			}
			traceCtr++;
		}
		report.add(allOk ? """" : ""</ul>"");
		return allOk;
	}

	private Type getType(XAttribute attribute) {
		if (attribute instanceof XAttributeLiteral) {
			return Type.LITERAL;
		} else if (attribute instanceof XAttributeDiscrete) {
			return Type.DISCRETE;
		} else if (attribute instanceof XAttributeTimestamp) {
			return Type.TIMESTAMP;
		} else if (attribute instanceof XAttributeContinuous) {
			return Type.CONTINUOUS;
		} else if (attribute instanceof XAttributeID) {
			return Type.ID;
		} else if (attribute instanceof XAttributeBoolean) {
			return Type.BOOLEAN;
		} else if (attribute instanceof XAttributeList) {
			return Type.LIST;
		}
		return Type.UNKNOWN;
	}

	public boolean check(PluginContext context, XLog log, LogCheckerReport report) {
		boolean okTraces = checkTraces(context, log, report);
		boolean okEvents = checkEvents(context, log, report);
		return okTraces && okEvents;
	}

}
"
LogCheckEventClassifiersGlobal.java,log,"package org.processmining.log.logchecks.impl;

import org.deckfour.xes.classification.XEventClassifier;
import org.deckfour.xes.model.XAttribute;
import org.deckfour.xes.model.XLog;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.log.logchecks.LogCheck;
import org.processmining.log.models.LogCheckerReport;

public class LogCheckEventClassifiersGlobal implements LogCheck {

	private static LogCheck instance;
	
	private LogCheckEventClassifiersGlobal() {
		
	}
	
	public static LogCheck getInstance() {
		if (instance == null) {
			instance = new LogCheckEventClassifiersGlobal();
		}
		return instance;
	}
	
	public boolean check(PluginContext context, XLog log, LogCheckerReport report) {
		boolean checkOk = true;
		for (XEventClassifier classifier : log.getClassifiers()) {
			for (String key : classifier.getDefiningAttributeKeys()) {
				boolean keyFound = false;
				for (XAttribute attribute : log.getGlobalEventAttributes()) {
					keyFound = attribute.getKey().equals(key);
					if (keyFound) {
						break;
					}
				}
				if (!keyFound) {
					String message = checkOk ? ""<h2>Event classifier uses non-global attribute</h2><ul>"" : """";
					checkOk = false;
					message += ""<li>Classifier "" + classifier.name() + "" uses key "" + key + "", but key "" + key + "" is not declared as being global.</li>""; 
					report.add(message);
				}
			}
		}
		if (!checkOk) {
			report.add(""</ul>"");
		}
		return checkOk;
	}

}
"
LogCheckGlobalAttributes.java,log,"package org.processmining.log.logchecks.impl;

import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.model.XAttribute;
import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.log.logchecks.LogCheck;
import org.processmining.log.models.LogCheckerReport;

public class LogCheckGlobalAttributes implements LogCheck {

	private static LogCheck instance;

	private LogCheckGlobalAttributes() {

	}

	public static LogCheck getInstance() {
		if (instance == null) {
			instance = new LogCheckGlobalAttributes();
		}
		return instance;
	}

	public boolean check(PluginContext context, XLog log, LogCheckerReport report) {
		boolean allOk = true;
		int traceCtr = 0;
		int eventCtr = 0;
		for (XTrace trace : log) {
			traceCtr++;
			eventCtr = 0;
			for (XAttribute attribute : log.getGlobalTraceAttributes()) {
				if (!trace.getAttributes().containsKey(attribute.getKey())) {
					if (allOk) {
						report.add(""<h2>Trace/event misses global attributes</h2><ul>"");
					}
					allOk = false;
					String traceId = "" at position "" + traceCtr;
					if (trace.getAttributes().containsKey(XConceptExtension.KEY_NAME)) {
						traceId = XConceptExtension.instance().extractName(trace) + "" "" + traceId;
					} else {
						traceId = ""<i>unknown</i> "" + traceId;
					}
					report.add(""<li>Trace "" + traceId + "" misses global attribute "" + attribute.getKey() + "".</li>"");
				}
			}
			for (XEvent event : trace) {
				eventCtr++;
				for (XAttribute attribute : log.getGlobalEventAttributes()) {
					if (!event.getAttributes().containsKey(attribute.getKey())) {
						if (allOk) {
							report.add(""<h2>Trace/event misses global attributes</h2><ul>"");
						}
						allOk = false;
						String eventId = "" at position "" + eventCtr;
						if (event.getAttributes().containsKey(XConceptExtension.KEY_NAME)) {
							eventId = XConceptExtension.instance().extractName(event) + "" "" + eventId;
						} else {
							eventId = ""<i>unknown</i> "" + eventId;
						}
						String traceId = "" at position "" + traceCtr;
						if (trace.getAttributes().containsKey(XConceptExtension.KEY_NAME)) {
							traceId = XConceptExtension.instance().extractName(trace) + "" "" + traceId;
						} else {
							traceId = ""<i>unknown</i> "" + traceId;
						}
						report.add(
								""<li>Event "" + eventId + "" in trace "" + traceId + "" misses global attribute "" + attribute.getKey() + "".</li>"");
					}
				}
			}
		}
		if (!allOk) {
			report.add(""</ul>"");
		}
		return allOk;
	}

}
"
LogCheck.java,log,"package org.processmining.log.logchecks;

import org.deckfour.xes.model.XLog;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.log.models.LogCheckerReport;

public interface LogCheck {

	public boolean check(PluginContext context, XLog log, LogCheckerReport report);
	
}
"
LogCheckType.java,log,"package org.processmining.log.logchecks;

import org.processmining.log.logchecks.impl.LogCheckConsistentTypes;
import org.processmining.log.logchecks.impl.LogCheckEventClassifiersGlobal;
import org.processmining.log.logchecks.impl.LogCheckGlobalAttributes;

public enum LogCheckType {
	LOG_CHECK_EVENT_CLASSIFIERS_GLOBAL(LogCheckEventClassifiersGlobal.getInstance()),
	LOG_CHECK_GLOBAL_ATTRIBUTE(LogCheckGlobalAttributes.getInstance()),
	LOG_CHECK_CONSISTENT_TYPES(LogCheckConsistentTypes.getInstance());
	
	
	private LogCheck logCheck;
	
	private LogCheckType(LogCheck logCheck) {
		this.logCheck = logCheck;
	}
	
	public LogCheck getLogCheck() {
		return logCheck;
	}
	
	
}
"
BasicEventClassifier.java,log,"package org.processmining.plugins.log.logclassifiers;

import org.deckfour.xes.classification.XEventAttributeClassifier;
import org.deckfour.xes.classification.XEventLifeTransClassifier;
import org.deckfour.xes.classification.XEventNameClassifier;
import org.deckfour.xes.classification.XEventResourceClassifier;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginVariant;

@Plugin(name = ""Basic event classifier"", parameterLabels = {}, returnLabels = { ""Event classifier"" }, returnTypes = { XEventAttributeClassifier.class }, userAccessible = true)
public class BasicEventClassifier {

	@PluginVariant(variantLabel = ""Activity name classifier"", requiredParameterLabels = {})
	public static XEventAttributeClassifier getEventNameClassifier(final PluginContext context) {
		return new XEventNameClassifier();
	}

	@PluginVariant(variantLabel = ""Resource classifier"", requiredParameterLabels = {})
	public static XEventAttributeClassifier getEventResourceClassifier(final PluginContext context) {
		return new XEventResourceClassifier();
	}

	@PluginVariant(variantLabel = ""Lifecycle transition classifier"", requiredParameterLabels = {})
	public static XEventAttributeClassifier getEventLifeTransClassifier(final PluginContext context) {
		return new XEventLifeTransClassifier();
	}

}
"
EventAndClassifier.java,log,"package org.processmining.plugins.log.logclassifiers;

import org.deckfour.xes.classification.XEventAndClassifier;
import org.deckfour.xes.classification.XEventClassifier;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;

public class EventAndClassifier {

	@Plugin(name = ""And event classifier"", parameterLabels = { ""Event classifiers"" }, returnLabels = { ""Event classifier"" }, returnTypes = { XEventAndClassifier.class }, userAccessible = true)
	public static XEventAndClassifier getEventNameClassifier(final PluginContext context, XEventClassifier[] classifiers) {
		return new XEventAndClassifier(classifiers);
	}

}
"
LogFileFormat.java,log,"package org.processmining.log;

/**
 * Specifies the different possible Log File Formats. Mainly used within
 * RapidProM.
 *
 */
public enum LogFileFormat {
	XES(""xes""), XES_GZ(""xes.gz""), MXML(""mxml""), MXML_GZ(""mxml.gz"");

	private String desc;

	private LogFileFormat(String desc) {
		this.desc = desc;
	}

	@Override
	public String toString() {
		return desc;
	}
}
"
AttributeFilterDialog.java,log,"package org.processmining.plugins.log.logfilters;

import info.clearthought.layout.TableLayout;
import info.clearthought.layout.TableLayoutConstants;

import java.awt.Dimension;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import javax.swing.DefaultListModel;
import javax.swing.JCheckBox;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JTabbedPane;
import javax.swing.ListSelectionModel;

import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.util.collection.AlphanumComparator;
import org.processmining.framework.util.ui.widgets.BorderPanel;
import org.processmining.framework.util.ui.widgets.ProMList;
import org.processmining.framework.util.ui.widgets.ProMTextField;

import com.fluxicon.slickerbox.factory.SlickerFactory;

public class AttributeFilterDialog extends JPanel {

	/**
	 * 
	 */
	private static final long serialVersionUID = -5477222861834208877L;
	private Map<String, ProMList<String>> lists;
	private Map<String, JCheckBox> mustHaves;
	private ProMTextField textField;
	private JCheckBox removeEmptyTraces;
	AttributeFilterParameters parameters;
	
	public AttributeFilterDialog(PluginContext context, AttributeFilterParameters parameters, String namePostfix) {
		this.parameters = parameters;
		Map<String, List<String>> values = new HashMap<String, List<String>>();
		for (String key : parameters.getFilter().keySet()) {
			values.put(key, new ArrayList<String>());
			values.get(key).addAll(parameters.getFilter().get(key));
			Collections.sort(values.get(key), new AlphanumComparator());
			context.getProgress().inc();
		}

		double size[][] = { { 80, TableLayoutConstants.FILL }, { TableLayoutConstants.FILL, 30, 30 } };
		setLayout(new TableLayout(size));

		setOpaque(false);
		
		lists = new HashMap<String, ProMList<String>>();
		mustHaves = new HashMap<String, JCheckBox>();
		
		JTabbedPane tabbedPane = new JTabbedPane();
		List<String> sortedKeys = new ArrayList<String>();
		sortedKeys.addAll(values.keySet());
		Collections.sort(sortedKeys, new AlphanumComparator());
		for (String key : sortedKeys) {
			DefaultListModel<String>listModel = new DefaultListModel<String>();
			int[] selected = new int[values.get(key).size()];
			int i = 0;
			for (String value: values.get(key)) {
				listModel.addElement(value);
				selected[i] = i;
				i++;
			}
			context.getProgress().inc();
			ProMList<String> list = new ProMList<String>(""Select values"", listModel);
			lists.put(key, list);
			list.setSelectionMode(ListSelectionModel.MULTIPLE_INTERVAL_SELECTION);
			list.setSelectedIndices(selected);
			list.setPreferredSize(new Dimension(100, 100));
			context.getProgress().inc();
			
			JCheckBox checkBox = SlickerFactory.instance().createCheckBox(""Remove if no value provided"", false);
			checkBox.setSelected(parameters.getMustHaves().contains(key));
			mustHaves.put(key, checkBox);
			
			JPanel panel = new BorderPanel(5, 2);
			double panelSize[][] = { { TableLayoutConstants.FILL }, { TableLayoutConstants.FILL, 30 } };
			panel.setLayout(new TableLayout(panelSize));
			panel.add(lists.get(key), ""0, 0"");
			panel.add(mustHaves.get(key), ""0, 1"");
			
			tabbedPane.add(key, panel);
		}
		this.add(tabbedPane, ""0, 0, 1, 0"");
		
		textField = new ProMTextField();
		textField.setText(parameters.getName() + namePostfix);
		add(textField, ""1, 1"");
		textField.setPreferredSize(new Dimension(100, 25));
		add(new JLabel(""Log name:""), ""0, 1"");

		removeEmptyTraces = SlickerFactory.instance().createCheckBox(""Remove trace if all events were removed"", parameters.isRemoveEmptyTraces()); 
		add(removeEmptyTraces, ""0, 2, 1, 2"");
	}
	
	public void applyFilter() {
		Set<String> mustHaves = new HashSet<String>();
		for (String key : lists.keySet()) {
			parameters.getFilter().get(key).clear();
			parameters.getFilter().get(key).addAll(lists.get(key).getSelectedValuesList());
			if (this.mustHaves.get(key).isSelected()) {
				mustHaves.add(key);
			}
		}
		parameters.setMustHave(mustHaves);
		parameters.setName(textField.getText());
		parameters.setRemoveEmptyTraces(removeEmptyTraces.isSelected());
	}
}
"
AttributeFilterParameters.java,log,"package org.processmining.plugins.log.logfilters;

import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.model.XAttribute;
import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.processmining.framework.plugin.PluginContext;

public class AttributeFilterParameters {

	protected Map<String,Set<String>> filter;
	protected Set<String> mustHaves;
	protected String name;
	private boolean removeEmptyTraces;
	
	public AttributeFilterParameters(PluginContext context) {
		filter = new HashMap<String,Set<String>>();
		mustHaves = new HashSet<String>();
		name = """";
		setRemoveEmptyTraces(false);
	}
	
	public AttributeFilterParameters(PluginContext context, XLog log) {
		filter = new HashMap<String,Set<String>>();
		for (XTrace trace : log) {
			for (XEvent event : trace) {
				for (String key : event.getAttributes().keySet()) {
					if (!filter.containsKey(key)) {
						filter.put(key, new HashSet<String>());
					}
					filter.get(key).add(event.getAttributes().get(key).toString());
				}
			}
			context.getProgress().inc();
		}
		mustHaves = new HashSet<String>();
		for (XAttribute attribute : log.getGlobalEventAttributes()) {
			mustHaves.add(attribute.getKey());
		}
		name = XConceptExtension.instance().extractName(log);
	}
	
	public void setFilter(Map<String,Set<String>> filter) {
		this.filter = filter;
	}

	public Map<String,Set<String>> getFilter() {
		return filter;
	}
	
	public void setMustHave(Set<String> mustHaves) {
		this.mustHaves = mustHaves;
	}
	
	public Set<String> getMustHaves() {
		return mustHaves;
	}
	
	public void setName(String name) {
		this.name = name;
	}
	
	public String getName() {
		return name;
	}

	public boolean isRemoveEmptyTraces() {
		return removeEmptyTraces;
	}

	public void setRemoveEmptyTraces(boolean removeEmptyTraces) {
		this.removeEmptyTraces = removeEmptyTraces;
	}
}
"
AttributeFilterPlugin.java,log,"package org.processmining.plugins.log.logfilters;

import org.deckfour.uitopia.api.event.TaskListener.InteractionResult;
import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.factory.XFactory;
import org.deckfour.xes.factory.XFactoryRegistry;
import org.deckfour.xes.model.XAttributeMap;
import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginCategory;
import org.processmining.framework.plugin.annotations.PluginLevel;
import org.processmining.framework.plugin.annotations.PluginVariant;

@Plugin(name = ""Filter Log on Event Attribute Values"", level= PluginLevel.PeerReviewed, categories = { PluginCategory.Filtering }, parameterLabels = { ""Log"", ""Parameters"" }, returnLabels = { ""Log"" }, returnTypes = { XLog.class })
public class AttributeFilterPlugin {

	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""H.M.W. Verbeek"", email = ""h.m.w.verbeek@tue.nl"")
	@PluginVariant(variantLabel = ""Filter Log on Event Attribute Values, UI"", requiredParameterLabels = { 0 })
	public XLog filterDialog(UIPluginContext context, XLog log) {
		context.getProgress().setMaximum(3 * log.size());
		AttributeFilterParameters parameters = new AttributeFilterParameters(context, log);
		parameters.setRemoveEmptyTraces(true);
		AttributeFilterDialog dialog = new AttributeFilterDialog(context, parameters, "" (filtered on event attributes)"");
		InteractionResult result = context.showWizard(""Configure filter (values)"", true, true, dialog);
		if (result != InteractionResult.FINISHED) {
			context.log(""Canceled by user."");
			context.getFutureResult(0).cancel(true);
			return null;
		}
		dialog.applyFilter();
		return filterPrivate(context, log, parameters);
	}

	@PluginVariant(variantLabel = ""Filter Log on Event Attribute Values, Parameters"", requiredParameterLabels = { 0 })
	public XLog filterParameters(PluginContext context, XLog log, AttributeFilterParameters parameters) {
		return filterPrivate(context, log, parameters);
	}

	private XLog filterPrivate(PluginContext context, XLog log, AttributeFilterParameters parameters) {
		XFactory factory = XFactoryRegistry.instance().currentDefault();
		XLog filteredLog = factory.createLog((XAttributeMap) log.getAttributes().clone());
		filteredLog.getClassifiers().addAll(log.getClassifiers());
		filteredLog.getExtensions().addAll(log.getExtensions());
		filteredLog.getGlobalTraceAttributes().addAll(log.getGlobalTraceAttributes());
		filteredLog.getGlobalEventAttributes().addAll(log.getGlobalEventAttributes());
		for (XTrace trace : log) {
			XTrace filteredTrace = factory.createTrace(trace.getAttributes());
			for (XEvent event : trace) {
				boolean add = true;
				if (event.getAttributes().keySet().containsAll(parameters.getMustHaves())) {
					for (String key : event.getAttributes().keySet()) {
						String value = event.getAttributes().get(key).toString();
						if (!parameters.getFilter().get(key).contains(value)) {
							add = false;
							continue;
						}
					}
					if (add) {
						filteredTrace.add(event);
					}
				}
				context.getProgress().inc();
			}
			if (!parameters.isRemoveEmptyTraces() || !filteredTrace.isEmpty()) {
				filteredLog.add(filteredTrace);
			}
		}
		XConceptExtension.instance().assignName(filteredLog, parameters.getName());
		context.getFutureResult(0).setLabel(parameters.getName());
		return filteredLog;
	}
}
"
AddArtificialEndFilter.java,log,"package org.processmining.plugins.log.logfilters.impl;

import org.deckfour.xes.info.XLogInfoFactory;
import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.plugins.log.logfilters.LogFilter;
import org.processmining.plugins.log.logfilters.LogFilterException;
import org.processmining.plugins.log.logfilters.XTraceEditor;

@Plugin(name = ""Add Artificial End Event Filter"", parameterLabels = { ""Log"", ""Event Label"" }, returnLabels = { ""Log (filtered)"" }, returnTypes = { XLog.class })
public class AddArtificialEndFilter {
	/**
	 * This method filters a log by adding an artificial end event to each trace
	 * in the log.
	 * 
	 * @param context
	 *            The pluginContext in which this plugin is executed.
	 * @param log
	 *            The log that needs to be filtered.
	 * @param event
	 *            The event label of the event to be added
	 * @return the filtered log
	 * @throws LogFilterException
	 */
	@PluginVariant(requiredParameterLabels = { 0, 1 }, variantLabel = ""Keep given events"")
	public XLog filter(PluginContext context, XLog log, final XEvent event) throws LogFilterException {
		// Construct a sorted set of events for easy lookup

		return LogFilter.filter(context.getProgress(), 100, log, XLogInfoFactory.createLogInfo(log),
				new XTraceEditor() {

					public XTrace editTrace(XTrace trace) {
						// Add the new final event
						trace.add(event);
						return trace;
					}
				});
	}
}
"
AddArtificialStartFilter.java,log,"package org.processmining.plugins.log.logfilters.impl;

import org.deckfour.xes.info.XLogInfoFactory;
import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.plugins.log.logfilters.LogFilter;
import org.processmining.plugins.log.logfilters.LogFilterException;
import org.processmining.plugins.log.logfilters.XTraceEditor;

@Plugin(name = ""Add Artificial Start Event Filter"", parameterLabels = { ""Log"", ""Event Label"" }, returnLabels = { ""Log (filtered)"" }, returnTypes = { XLog.class })
public class AddArtificialStartFilter {
	/**
	 * This method filters a log by adding an artificial start event to each
	 * trace in the log.
	 * 
	 * @param context
	 *            The pluginContext in which this plugin is executed.
	 * @param log
	 *            The log that needs to be filtered.
	 * @param event
	 *            The event label of the event to be added
	 * @return the filtered log
	 * @throws LogFilterException
	 */
	@PluginVariant(requiredParameterLabels = { 0, 1 }, variantLabel = ""Keep given events"")
	public XLog filter(PluginContext context, XLog log, final XEvent event) throws LogFilterException {
		// Construct a sorted set of events for easy lookup

		return LogFilter.filter(context.getProgress(), 100, log, XLogInfoFactory.createLogInfo(log),
				new XTraceEditor() {

					public XTrace editTrace(XTrace trace) {
						// Keep the trace if the first event is contained in the
						// given set.
						trace.add(0, event);
						return trace;
					}
				});
	}

}
"
DayAbstractionLogEditor.java,log,"package org.processmining.plugins.log.logfilters.impl;

import java.util.Calendar;
import java.util.Date;

import org.deckfour.xes.extension.std.XTimeExtension;
import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XLog;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginCategory;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.plugins.log.logfilters.LogFilter;
import org.processmining.plugins.log.logfilters.LogFilterException;
import org.processmining.plugins.log.logfilters.XEventEditor;

@Plugin(name = ""Day Abstraction Log Editor"", categories = { PluginCategory.Filtering }, parameterLabels = { ""Log"" }, returnLabels = { ""Log (edited)"" }, returnTypes = { XLog.class })
public class DayAbstractionLogEditor {

	XTimeExtension timeExtension = XTimeExtension.instance();
	Calendar calendar = Calendar.getInstance();

	//	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""H.M.W Verbeek"", email = ""h.m.w.verbeek@tue.nl"")
	@PluginVariant(requiredParameterLabels = { 0 }, variantLabel = ""Day Abstraction Log Editor"")
	public XLog editor(PluginContext context, XLog log) throws LogFilterException {

		return LogFilter.filter(log, new XEventEditor() {

			public XEvent editEvent(XEvent event) {
				// TODO Auto-generated method stub
				XEvent editedEvent = (XEvent) event.clone();

				Date date = timeExtension.extractTimestamp(event);
				calendar.setTime(date);
				/*
				 * Abstract from the day.
				 */
				calendar.set(Calendar.YEAR, 2008);
				calendar.set(Calendar.MONTH, 0);
				calendar.set(Calendar.DAY_OF_MONTH, 1);

				timeExtension.assignTimestamp(editedEvent, calendar.getTime());
				return editedEvent;
			}
		});
	}
}
"
DefaultLogFilter.java,log,"package org.processmining.plugins.log.logfilters.impl;

import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;

import org.deckfour.xes.extension.std.XLifecycleExtension;
import org.deckfour.xes.info.XLogInfoFactory;
import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginCategory;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.plugins.log.logfilters.LogFilter;
import org.processmining.plugins.log.logfilters.XEventCondition;
import org.processmining.plugins.log.logfilters.XTraceCondition;

@Plugin(name = ""Default Log Filter"", categories = { PluginCategory.Filtering }, parameterLabels = { ""Log"", ""Remove"", ""Skip instance"" }, returnLabels = { ""Log (filtered)"" }, returnTypes = { XLog.class })
public class DefaultLogFilter {
	/**
	 * This method filters a log by 1) removing all XEvents of which the
	 * XLifeCycleExtension
	 * 
	 * @param context
	 *            The pluginContext in which this plugin is executed.
	 * @param log
	 *            The log that needs to be filtered.
	 * @param event
	 *            The event label of the event to be added
	 * @return the filtered log
	 */
	@PluginVariant(requiredParameterLabels = { 0, 1, 2 }, variantLabel = ""Keep given events"")
	public XLog filter(PluginContext context, XLog log, String[] lifeCycleObjectsToIgnore,
			String[] lifeCycleObjectsToRemoveCase) {
//		long time = -System.currentTimeMillis();
		final Set<?> remove = new HashSet<Object>(Arrays.asList(lifeCycleObjectsToRemoveCase));
		XLog filtered = log;
		
		if (!remove.isEmpty()) {
			// First, remove all cases containing an event of which the lifecycle extension is such
			// that the trace should be removed.
			filtered = LogFilter.filter((context != null ? context.getProgress() : null), 100, filtered,
					(context != null ? XLogInfoFactory.createLogInfo(filtered) : null), new XTraceCondition() {

						public boolean keepTrace(XTrace trace) {
							for (XEvent event : trace) {
								if (remove.contains(XLifecycleExtension.instance().extractTransition(event))) {
									return false;
								}
							}
							return true;
						}
					});
		}
//		time += System.currentTimeMillis();
//		System.err.println(""[DefaultLogFilter] remove time = "" + time);

//		time = -System.currentTimeMillis();
		final Set<?> ignore = new HashSet<Object>(Arrays.asList(lifeCycleObjectsToIgnore));

		if (!ignore.isEmpty()) {
			// Finally, remove all events of which the lifecycle extension is such
			// that it should be ignored.
			filtered = LogFilter.filter((context != null ? context.getProgress() : null), 100, filtered,
					(context != null ? XLogInfoFactory.createLogInfo(filtered) : null), new XEventCondition() {

						public boolean keepEvent(XEvent event) {
							if (ignore.contains(XLifecycleExtension.instance().extractTransition(event))) {
								return false;
							}
							return true;
						}
					});
		}
//		time += System.currentTimeMillis();
//		System.err.println(""[DefaultLogFilter] ignore time = "" + time);
		return filtered;
	}
}
"
DuplicateEventLogFilter.java,log,"package org.processmining.plugins.log.logfilters.impl;

import org.deckfour.xes.classification.XEventClasses;
import org.deckfour.xes.info.XLogInfoFactory;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginCategory;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.plugins.log.logfilters.LogFilter;
import org.processmining.plugins.log.logfilters.LogFilterException;
import org.processmining.plugins.log.logfilters.XTraceEditor;

@Plugin(name = ""Duplicate Event Log Filter"", categories = { PluginCategory.Filtering }, parameterLabels = { ""Log"", ""Event Classes"" }, returnLabels = { ""Log (filtered)"" }, returnTypes = { XLog.class })
public class DuplicateEventLogFilter {
	/**
	 * This method filters a log by removing events from a trace, if the event
	 * is of the same XEventClass as the previous event
	 * 
	 * @param context
	 *            The pluginContext in which this plugin is executed.
	 * @param log
	 *            The log that needs to be filtered.
	 * @param events
	 *            The event classes that are distinguished.
	 * @return the filtered log
	 * @throws LogFilterException
	 */
	@PluginVariant(requiredParameterLabels = { 0, 1 }, variantLabel = ""Keep given events"")
	public XLog filter(PluginContext context, XLog log, final XEventClasses events) throws LogFilterException {
		// Construct a sorted set of events for easy lookup

		return LogFilter.filter(context.getProgress(), 100, log, XLogInfoFactory.createLogInfo(log),
				new XTraceEditor() {

					public XTrace editTrace(XTrace trace) {
						// Keep the trace if the first event is contained in the
						// given set.
						for (int i = 1; i < trace.size(); i++) {
							if (events.getClassOf(trace.get(i)).equals(events.getClassOf(trace.get(i - 1)))) {
								trace.remove(i);
								i--;
							}
						}

						// No check is necessary for empty traces for 2 reasons:
						// 1) the trace cannot become empty, as the first element is
						// never removed
						// 2) even if the trace becomes empty, the LogFilter code
						// removes the trace
						return trace;
					}
				});
	}
}
"
EventLogFilter.java,log,"package org.processmining.plugins.log.logfilters.impl;

import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;

import org.deckfour.xes.classification.XEventClass;
import org.deckfour.xes.classification.XEventClasses;
import org.deckfour.xes.classification.XEventClassifier;
import org.deckfour.xes.info.XLogInfoFactory;
import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XLog;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginCategory;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.plugins.log.logfilters.LogFilter;
import org.processmining.plugins.log.logfilters.XEventCondition;

@Plugin(name = ""Event Log Filter"", categories = { PluginCategory.Filtering }, parameterLabels = { ""Log"", ""All Event Classes"", ""Event Classes to keep"",
		""Minimal Occurrence frequency"", ""Minimal Occurrence in cases"", ""Satisfy both"" }, returnLabels = { ""Log (filtered)"" }, returnTypes = { XLog.class })
public class EventLogFilter {

	/**
	 * This method filters a log by removing XEvent objects from all XTrace
	 * object in the given XLog, if the XEventClass belonging to this XEvent is
	 * not provided in the given XEventClasses object
	 * 
	 * @param context
	 *            The pluginContext in which this plugin is executed
	 * @param log
	 *            The log that needs to be filtered.
	 * @param allEventClasses
	 *            All event classes
	 * @param events
	 *            The event classes that should be kept in the log. Events not
	 *            belonging to these classes are removed, after which emtpy
	 *            traces are also removed
	 * @return the filtered log
	 */
	@PluginVariant(requiredParameterLabels = { 0, 1, 2 }, variantLabel = ""Filter on Event Class"")
	public XLog filterWithNames(PluginContext context, XLog log, final XEventClasses allEventClasses,
			XEventClass[] eventClassesToKeep) {
		// Construct a sorted set of names for easy lookup
		final HashSet<XEventClass> toKeep = new HashSet<XEventClass>(Arrays.asList(eventClassesToKeep));

		return LogFilter.filter((context != null ? context.getProgress() : null), 100, log, (context != null ? XLogInfoFactory.createLogInfo(log) : null),
				new XEventCondition() {

					public boolean keepEvent(XEvent event) {
						// only keep the event if:
						// 1) its name is in toKeep
						XEventClass c = allEventClasses.getClassOf(event);
						if (!toKeep.contains(c)) {
							return false;
						}
						return true;
					}

				});
	}

	public XLog filterWithClassifier(PluginContext context, XLog log, final XEventClassifier classifier,
			final String[] selectedIds) {
		final Collection<String> ids = new HashSet<String>(Arrays.asList(selectedIds));

		return LogFilter.filter((context != null ? context.getProgress() : null), 100, log, (context != null ? XLogInfoFactory.createLogInfo(log) : null),
				new XEventCondition() {

					public boolean keepEvent(XEvent event) {
						return ids.contains(classifier.getClassIdentity(event));
					}

				});
	}

	/**
	 * This method filters a log by removing XEvent objects from all XTrace
	 * object in the given XLog, if the getName() of XEvent is not contained in
	 * the given set of labels. Note that the percentages are based on the
	 * original log, not on the log with the unnecessary events removed.
	 * 
	 * @param context
	 *            The pluginContext in which this plugin is executed
	 * @param log
	 *            The log that needs to be filtered.
	 * @param allEventClasses
	 *            All event classes
	 * @param eventClassesToKeep
	 *            The event classes that should be kept in the log. Events not
	 *            belonging to these classes are removed, after which emtpy
	 *            traces are also removed
	 * @param minOccurrence
	 *            All events with an event class which represent less than this
	 *            percentage of the events in the log are removed. Value should
	 *            be 0 <= minOccurrence <= 1. If 0, then all events are kept, if
	 *            1, then no events are kept.
	 * @return the filtered log
	 */
	@PluginVariant(requiredParameterLabels = { 0, 1, 2, 3 }, variantLabel = ""Filter on Frequencies names"")
	public XLog filterWithMinOccFreq(PluginContext context, XLog log, final XEventClasses allEventClasses,
			final XEventClass[] eventClassesToKeep, final Double minOccurrence) {

		final HashSet<XEventClass> toKeep = new HashSet<XEventClass>(Arrays.asList(eventClassesToKeep));
		final Map<XEventClass, Double> count = new HashMap<XEventClass, Double>();// allEventClasses
		// .
		// getOccurrenceFrequency
		// (log);
		return LogFilter.filter(context.getProgress(), 100, log, XLogInfoFactory.createLogInfo(log),
				new XEventCondition() {

					public boolean keepEvent(XEvent event) {
						// only keep the event if:
						// 1) it's name is in eventClassesToKeep
						// 2) the frequency is >= minOccurrence
						XEventClass c = allEventClasses.getClassOf(event);
						if (!toKeep.contains(c)) {
							return false;
						}

						double percentage = count.get(c);
						return percentage >= minOccurrence;
					}

				});
	}

	/**
	 * This method filters a log by removing XEvent objects from all XTrace
	 * object in the given XLog, if the getName() of XEvent is not contained in
	 * the given set of labels. Note that the percentages are based on the
	 * original log, not on the log with the unnecessary events removed.
	 * 
	 * @param context
	 *            The pluginContext in which this plugin is executed
	 * @param log
	 *            The log that needs to be filtered.
	 * @param allEventClasses
	 *            All event classes
	 * @param eventClassesToKeep
	 *            The event classes that should be kept in the log. Events not
	 *            belonging to these classes are removed, after which emtpy
	 *            traces are also removed
	 * @param minCases
	 *            All events which occur in less than minCasses percent of the
	 *            cases are removed. Value should be 0 <= minCases <= 1. If 0,
	 *            then all events are kept, if 1, then only events appearing in
	 *            all cases are kept.
	 * @return the filtered log
	 */
	@PluginVariant(requiredParameterLabels = { 0, 1, 2, 4 }, variantLabel = ""Filter on Frequencies names"")
	public XLog filterWithMinCases(PluginContext context, XLog log, final XEventClasses allEventClasses,
			XEventClass[] eventClassesToKeep, final Double minCases) {

		final Map<XEventClass, Double> count = new HashMap<XEventClass, Double>();// allEventClasses
		// .
		// getCaseFrequency(log);
		final HashSet<XEventClass> toKeep = new HashSet<XEventClass>(Arrays.asList(eventClassesToKeep));

		return LogFilter.filter(context.getProgress(), 100, log, XLogInfoFactory.createLogInfo(log),
				new XEventCondition() {

					public boolean keepEvent(XEvent event) {
						// only keep the event if:
						// 1) it's name is in eventClassesToKeep
						// 2) the frequency is >= minCases
						XEventClass c = allEventClasses.getClassOf(event);
						if (!toKeep.contains(c)) {
							return false;
						}

						double percentage = count.get(c);
						return percentage >= minCases;
					}

				});
	}

	/**
	 * This method filters a log by removing XEvent objects from all XTrace
	 * object in the given XLog, if the getName() of XEvent is not contained in
	 * the given set of labels. Note that the percentages are based on the
	 * original log, not on the log with the unnecessary events removed.
	 * 
	 * @param context
	 *            The pluginContext in which this plugin is executed
	 * @param log
	 *            The log that needs to be filtered.
	 * @param allEventClasses
	 *            All event classes
	 * @param eventClassesToKeep
	 *            The event classes that should be kept in the log. Events not
	 *            belonging to these classes are removed, after which emtpy
	 *            traces are also removed
	 * @param minOccurrence
	 *            All events with an event class which represent less than this
	 *            percentage of the events in the log are removed. Value should
	 *            be 0 <= minOccurrence <= 1. If 0, then all events are kept, if
	 *            1, then no events are kept.
	 * @param minCases
	 *            All events which occur in less than minCasses percent of the
	 *            cases are removed. Value should be 0 <= minCases <= 1. If 0,
	 *            then all events are kept, if 1, then only events appearing in
	 *            all cases are kept.
	 * @param fullfillBoth
	 *            A boolean indicating wheter both minimal frequencies should be
	 *            obeyed (true) or whether one is enough (false)
	 * @return the filtered log
	 */
	@PluginVariant(requiredParameterLabels = { 0, 1, 2, 3, 4, 5 }, variantLabel = ""Filter on Frequencies names"")
	public XLog filterWithBoth(PluginContext context, XLog log, final XEventClasses allEventClasses,
			XEventClass[] eventClassesToKeep, final Double minOccurrence, final Double minCases,
			final Boolean fullfillBoth) {

		final Map<XEventClass, Double> countFreq = new HashMap<XEventClass, Double>();// allEventClasses
		// .
		// getCaseFrequency
		// (log);
		final Map<XEventClass, Double> countCase = new HashMap<XEventClass, Double>();// allEventClasses
		// .
		// getCaseFrequency
		// (log);
		final HashSet<XEventClass> toKeep = new HashSet<XEventClass>(Arrays.asList(eventClassesToKeep));

		return LogFilter.filter(context.getProgress(), 100, log, XLogInfoFactory.createLogInfo(log),
				new XEventCondition() {

					public boolean keepEvent(XEvent event) {
						// only keep the event if:
						// 1) it's name is in eventClassesToKeep
						// 2) the frequency is >= minCases
						XEventClass c = allEventClasses.getClassOf(event);
						if (!toKeep.contains(c)) {
							return false;
						}
						double casePercentage = countFreq.get(c);
						double freqPercentage = countCase.get(c);
						if (fullfillBoth) {
							return (casePercentage >= minCases) && (freqPercentage >= minOccurrence);
						} else {
							return (casePercentage >= minCases) || (freqPercentage >= minOccurrence);
						}
					}

				});
	}
}
"
FinalEventLogFilter.java,log,"package org.processmining.plugins.log.logfilters.impl;

import java.util.Arrays;
import java.util.Collection;
import java.util.HashSet;

import org.deckfour.xes.classification.XEventClasses;
import org.deckfour.xes.classification.XEventClassifier;
import org.deckfour.xes.info.XLogInfoFactory;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginCategory;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.plugins.log.logfilters.LogFilter;
import org.processmining.plugins.log.logfilters.XTraceCondition;

@Plugin(name = ""Final Event Log Filter"", categories = { PluginCategory.Filtering }, parameterLabels = { ""Log"", ""Event Classes"", ""Classifier"", ""Start IDs"" }, returnLabels = { ""Log (filtered)"" }, returnTypes = { XLog.class })
public class FinalEventLogFilter {
	/**
	 * This method filters a log by removing all traces from the log which do
	 * not end with one of the given events
	 * 
	 * @param context
	 *            The pluginContext in which this plugin is executed
	 * @param log
	 *            The log that needs to be filtered.
	 * @param events
	 *            The event classes that can serve as end events of a trace
	 * @return the filtered log
	 */
	@PluginVariant(requiredParameterLabels = { 0, 1 }, variantLabel = ""Keep given events"")
	public XLog filterWithNames(PluginContext context, XLog log, final XEventClasses events) {
		// Construct a sorted set of events for easy lookup

		return LogFilter.filter((context != null ? context.getProgress() : null), 100, log, (context != null ? XLogInfoFactory.createLogInfo(log) : null),
				new XTraceCondition() {

					public boolean keepTrace(XTrace trace) {
						// Keep the trace if the first event is contained in the
						// given set.
						return !trace.isEmpty() && events.getClasses().contains(events.getClassOf(trace.get(trace.size() - 1)));
					}

				});
	}

	@PluginVariant(requiredParameterLabels = { 0, 2, 3 }, variantLabel = ""Keep given events"")
	public XLog filterWithClassifier(PluginContext context, XLog log, final XEventClassifier classifier,
			final String[] finalIds) {
		// Construct a sorted set of events for easy lookup
		final Collection<String> ids = new HashSet<String>(Arrays.asList(finalIds));

		return LogFilter.filter((context != null ? context.getProgress() : null), 100, log, (context != null ? XLogInfoFactory.createLogInfo(log) : null),
				new XTraceCondition() {

					public boolean keepTrace(XTrace trace) {
						// Keep the trace if the first event is contained in the
						// given set.
						return !trace.isEmpty() && ids.contains(classifier.getClassIdentity(trace.get(trace.size() - 1)));
					}

				});
	}
}
"
FirstSixMonthsFilter.java,log,"package org.processmining.plugins.log.logfilters.impl;

import java.util.Calendar;
import java.util.Date;
import java.util.Iterator;

import org.deckfour.xes.extension.std.XTimeExtension;
import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginCategory;

public class FirstSixMonthsFilter {

	@Plugin(name = ""Filter log on first six months per trace"", categories = { PluginCategory.Filtering }, parameterLabels = { ""Log"" }, returnLabels = { ""Log (filtered)"" }, returnTypes = { XLog.class })
	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""H.M.W. Verbeek"", email = ""h.m.w.verbeek@tue.nl"")
	public XLog filter(PluginContext context, XLog log) {
		XLog filtered = (XLog) log.clone();
		Iterator<XTrace> itTrace = filtered.iterator();
		while (itTrace.hasNext()) {
			XTrace trace = itTrace.next();
			Iterator<XEvent> itEvent = trace.iterator();
			Date startDate = XTimeExtension.instance().extractTimestamp(itEvent.next());
			Calendar cal = Calendar.getInstance();
			cal.setTime(startDate);
			cal.add(Calendar.MONTH, 6);
			Date filterDate = cal.getTime();
			while (itEvent.hasNext()) {
				if (XTimeExtension.instance().extractTimestamp(itEvent.next()).after(filterDate)) {
					itEvent.remove();
				}
			}
			if (trace.isEmpty()) {
				itTrace.remove();
			}
		}
		return filtered;
	}

}
"
OriginatorLogFilter.java,log,"package org.processmining.plugins.log.logfilters.impl;

import java.util.Arrays;
import java.util.Set;
import java.util.TreeSet;

import org.deckfour.xes.extension.std.XOrganizationalExtension;
import org.deckfour.xes.info.XLogInfoFactory;
import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XLog;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginCategory;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.plugins.log.logfilters.LogFilter;
import org.processmining.plugins.log.logfilters.XEventCondition;

@Plugin(name = ""Originator Log Filter"", categories = { PluginCategory.Filtering }, parameterLabels = { ""Log"", ""Resources"", ""Groups"", ""Roles"" }, returnLabels = { ""Log (filtered)"" }, returnTypes = { XLog.class })
public class OriginatorLogFilter {

	/**
	 * This method filters a log by removing XEvent objects from all XTrace
	 * object in the given XLog, if the resource of XEvent is not contained in
	 * the given set of resources.
	 * 
	 * If no resource information is available in the log, all events are
	 * removed.
	 * 
	 * @param context
	 *            The pluginContext in which this plugin is executed
	 * @param log
	 *            The log that needs to be filtered.
	 * @param namesToKeep
	 *            The names of the resources to keep
	 * @return the filtered log
	 */
	@PluginVariant(requiredParameterLabels = { 0, 1 }, variantLabel = ""Filter on Names"")
	public XLog filterWithNames(PluginContext context, XLog log, String[] namesToKeep) {
		return filterWithAll(context, log, namesToKeep, new String[0], new String[0]);
	}

	/**
	 * This method filters a log by removing XEvent objects from all XTrace
	 * object in the given XLog, if the group of XEvent is not contained in the
	 * given set of groups.
	 * 
	 * If no resource information is available in the log, all events are
	 * removed.
	 * 
	 * @param context
	 *            The pluginContext in which this plugin is executed
	 * @param log
	 *            The log that needs to be filtered.
	 * @param groupsToKeep
	 *            The names of the groups to keep
	 * @return the filtered log
	 */
	@PluginVariant(requiredParameterLabels = { 0, 2 }, variantLabel = ""Filter on Groups"")
	public XLog filterWithGroups(PluginContext context, XLog log, String[] groupsToKeep) {
		return filterWithAll(context, log, new String[0], groupsToKeep, new String[0]);
	}

	/**
	 * This method filters a log by removing XEvent objects from all XTrace
	 * object in the given XLog, if the role of XEvent is not contained in the
	 * given set of roles.
	 * 
	 * If no resource information is available in the log, all events are
	 * removed.
	 * 
	 * @param context
	 *            The pluginContext in which this plugin is executed
	 * @param log
	 *            The log that needs to be filtered.
	 * @param rolesToKeep
	 *            The names of the roles to keep
	 * @return the filtered log
	 */
	@PluginVariant(requiredParameterLabels = { 0, 3 }, variantLabel = ""Filter on Roles"")
	public XLog filterWithRoles(PluginContext context, XLog log, String[] rolesToKeep) {
		return filterWithAll(context, log, new String[0], new String[0], rolesToKeep);
	}

	/**
	 * This method filters a log by removing XEvent objects from all XTrace
	 * object in the given XLog, if the resource of XEvent is not contained in
	 * the given set of resources, or in the given set of groups.
	 * 
	 * If no resource information is available in the log, all events are
	 * removed.
	 * 
	 * @param context
	 *            The pluginContext in which this plugin is executed
	 * @param log
	 *            The log that needs to be filtered.
	 * @param namesToKeep
	 *            The names of the resources to keep
	 * @param groupsToKeep
	 *            The names of the groups to keep
	 * @return the filtered log
	 */
	@PluginVariant(requiredParameterLabels = { 0, 1, 2 }, variantLabel = ""Filter on Names and Groups"")
	public XLog filterWithNamesAndGroups(PluginContext context, XLog log, String[] namesToKeep, String[] groupsToKeep) {
		return filterWithAll(context, log, namesToKeep, groupsToKeep, new String[0]);
	}

	/**
	 * This method filters a log by removing XEvent objects from all XTrace
	 * object in the given XLog, if the group of XEvent is not contained in the
	 * given set of groups, or in the given set of roles.
	 * 
	 * If no resource information is available in the log, all events are
	 * removed.
	 * 
	 * @param context
	 *            The pluginContext in which this plugin is executed
	 * @param log
	 *            The log that needs to be filtered.
	 * @param groupsToKeep
	 *            The names of the groups to keep
	 * @param rolesToKeep
	 *            The names of the roles to keep
	 * @return the filtered log
	 */
	@PluginVariant(requiredParameterLabels = { 0, 2, 3 }, variantLabel = ""Filter on Groups"")
	public XLog filterWithGroupsAndRoles(PluginContext context, XLog log, final String[] groupsToKeep,
			String[] rolesToKeep) {
		return filterWithAll(context, log, new String[0], groupsToKeep, rolesToKeep);
	}

	/**
	 * This method filters a log by removing XEvent objects from all XTrace
	 * object in the given XLog, if the group of XEvent is not contained in the
	 * given set of resources, or in the given set of roles.
	 * 
	 * If no resource information is available in the log, all events are
	 * removed.
	 * 
	 * @param context
	 *            The pluginContext in which this plugin is executed
	 * @param log
	 *            The log that needs to be filtered.
	 * @param namesToKeep
	 *            The names of the resources to keep
	 * @param rolesToKeep
	 *            The names of the roles to keep
	 * @return the filtered log
	 */
	@PluginVariant(requiredParameterLabels = { 0, 1, 3 }, variantLabel = ""Filter on Groups"")
	public XLog filterWithNamesAndRoles(PluginContext context, XLog log, String[] namesToKeep, String[] rolesToKeep) {
		return filterWithAll(context, log, namesToKeep, new String[0], rolesToKeep);
	}

	/**
	 * This method filters a log by removing XEvent objects from all XTrace
	 * object in the given XLog, if the group of XEvent is not contained in the
	 * given set of resources, or in the given set of roles, or in the given set
	 * of groups.
	 * 
	 * If no resource information is available in the log, all events are
	 * removed.
	 * 
	 * @param context
	 *            The pluginContext in which this plugin is executed
	 * @param log
	 *            The log that needs to be filtered.
	 * @param namesToKeep
	 *            The names of the resources to keep
	 * @param groupsToKeep
	 *            The names of the resources to keep
	 * @param rolesToKeep
	 *            The names of the roles to keep
	 * @return the filtered log
	 */
	@PluginVariant(requiredParameterLabels = { 0, 1, 2, 3 }, variantLabel = ""Filter on Groups"")
	public XLog filterWithAll(PluginContext context, XLog log, String[] namesToKeep, String[] groupsToKeep,
			String[] rolesToKeep) {

		// Construct a sorted set of names for easy lookup
		final Set<String> names = new TreeSet<String>(Arrays.asList(namesToKeep));
		final Set<String> roles = new TreeSet<String>(Arrays.asList(rolesToKeep));
		final Set<String> groups = new TreeSet<String>(Arrays.asList(groupsToKeep));

		return LogFilter.filter(context.getProgress(), 100, log, XLogInfoFactory.createLogInfo(log),
				new XEventCondition() {

					public boolean keepEvent(XEvent event) {
						// Keep the event if the getName() is contained in events.
						return roles.contains(XOrganizationalExtension.instance().extractRole(event))
								|| groups.contains(XOrganizationalExtension.instance().extractGroup(event))
								|| names.contains(XOrganizationalExtension.instance().extractResource(event));
					}

				});
	}

}
"
StartEventLogFilter.java,log,"package org.processmining.plugins.log.logfilters.impl;

import java.util.Arrays;
import java.util.Collection;
import java.util.HashSet;

import org.deckfour.xes.classification.XEventClasses;
import org.deckfour.xes.classification.XEventClassifier;
import org.deckfour.xes.info.XLogInfoFactory;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginCategory;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.plugins.log.logfilters.LogFilter;
import org.processmining.plugins.log.logfilters.XTraceCondition;

@Plugin(name = ""Start Event Log Filter"", categories = { PluginCategory.Filtering }, parameterLabels = { ""Log"", ""Event Classes"", ""Classifier"", ""Start IDs"" }, returnLabels = { ""Log (filtered)"" }, returnTypes = { XLog.class })
public class StartEventLogFilter {
	/**
	 * This method filters a log by removing all traces from the log which do
	 * not start with one of the given events
	 * 
	 * @param context
	 *            The pluginContext in which this plugin is executed
	 * @param log
	 *            The log that needs to be filtered.
	 * @param events
	 *            The event classes that can serve as start events of a trace
	 * @return the filtered log
	 */
	@PluginVariant(requiredParameterLabels = { 0, 1 }, variantLabel = ""Keep given events"")
	public XLog filterWithNames(PluginContext context, XLog log, final XEventClasses events) {
		// Construct a sorted set of events for easy lookup

		return LogFilter.filter((context != null ? context.getProgress() : null), 100, log, (context != null ? XLogInfoFactory.createLogInfo(log) : null),
				new XTraceCondition() {

					public boolean keepTrace(XTrace trace) {
						// Keep the trace if the first event is contained in the
						// given set.
						return !trace.isEmpty() && events.getClasses().contains(events.getClassOf(trace.get(0)));
					}

				});
	}

	@PluginVariant(requiredParameterLabels = { 0, 2, 3 }, variantLabel = ""Keep given events"")
	public XLog filterWithClassifier(PluginContext context, XLog log, final XEventClassifier classifier,
			final String[] startIds) {
		// Construct a sorted set of events for easy lookup
		final Collection<String> ids = new HashSet<String>(Arrays.asList(startIds));

		return LogFilter.filter((context != null ? context.getProgress() : null), 100, log, (context != null ? XLogInfoFactory.createLogInfo(log) : null),
				new XTraceCondition() {

					public boolean keepTrace(XTrace trace) {
						// Keep the trace if the first event is contained in the
						// given set.
						return !trace.isEmpty() && ids.contains(classifier.getClassIdentity(trace.get(0)));
					}

				});
	}
}
"
WeekAbstractionLogEditor.java,log,"package org.processmining.plugins.log.logfilters.impl;

import java.util.Calendar;
import java.util.Date;

import org.deckfour.xes.extension.std.XTimeExtension;
import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XLog;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginCategory;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.plugins.log.logfilters.LogFilter;
import org.processmining.plugins.log.logfilters.LogFilterException;
import org.processmining.plugins.log.logfilters.XEventEditor;

@Plugin(name = ""Week Abstraction Log Editor"", categories = { PluginCategory.Filtering }, parameterLabels = { ""Log"" }, returnLabels = { ""Log (edited)"" }, returnTypes = { XLog.class })
public class WeekAbstractionLogEditor {

	XTimeExtension timeExtension = XTimeExtension.instance();
	Calendar calendar = Calendar.getInstance();

	//	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""H.M.W Verbeek"", email = ""h.m.w.verbeek@tue.nl"")
	@PluginVariant(requiredParameterLabels = { 0 }, variantLabel = ""Day Abstraction Log Editor"")
	public XLog editor(PluginContext context, XLog log) throws LogFilterException {

		return LogFilter.filter(log, new XEventEditor() {

			public XEvent editEvent(XEvent event) {
				// TODO Auto-generated method stub
				XEvent editedEvent = (XEvent) event.clone();

				Date date = timeExtension.extractTimestamp(event);
				calendar.setTime(date);
				/*
				 * Abstract from the day.
				 */
				calendar.set(Calendar.YEAR, 2008);
				calendar.set(Calendar.MONTH, 0);
				calendar.set(Calendar.DAY_OF_WEEK_IN_MONTH, 1);

				timeExtension.assignTimestamp(editedEvent, calendar.getTime());
				return editedEvent;
			}
		});
	}
}
"
LogFilter.java,log,"package org.processmining.plugins.log.logfilters;

import java.util.Iterator;

import org.deckfour.xes.info.XLogInfo;
import org.deckfour.xes.info.XLogInfoFactory;
import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.processmining.framework.plugin.Progress;

/**
 * Class containing some static methods that are easy to use when implementing a
 * new filter on a log.
 * 
 * @author bfvdonge
 * 
 */
public class LogFilter {

	/**
	 * This method filters a log by removing XEvent objects from all XTrace
	 * object in the given XLog, if the given XEventCondition returns false.
	 * After that, the given XTrace condition is checked on the filtered trace
	 * and the trace is removed if this condition returns false.
	 * 
	 * @param log
	 *            The log that needs to be filtered.
	 * @param eventCondition
	 *            The condition that is checked for all events in the log.
	 * @param traceCondition
	 *            The condition that is checked for all traces in the log. Note
	 *            that on each trace, the eventCondition is first checked on all
	 *            events, and then the trace condition is checked on the
	 *            filtered trace.
	 * @return the filtered log. The result is a clone of the input log, i.e.
	 *         the given log object does not change
	 */
	public static XLog filter(XLog log, XEventCondition eventCondition, XTraceCondition traceCondition) {
		return filter(null, 1, log, null, eventCondition, traceCondition);

	}

	/**
	 * This method filters a log by removing XEvent objects from all XTrace
	 * object in the given XLog, if the given XEventCondition returns false.
	 * After that, the given XTrace condition is checked on the filtered trace
	 * and the trace is removed if this condition returns false.
	 * 
	 * @param progress
	 *            A Progress object which is used for showing progress. steps
	 *            steps are added to the maximum and progress is increased in
	 *            steps steps. May be null.
	 * @param steps
	 *            The number of steps in which progress is provided. Should be >
	 *            0
	 * @param log
	 *            The log that needs to be filtered.
	 * @param summary
	 *            The summary of the log. Is used to determine the number of
	 *            events in the log. If null, it will be constructed if progress
	 *            is not null.
	 * @param eventCondition
	 *            The condition that is checked for all events in the log.
	 * @param traceCondition
	 *            The condition that is checked for all traces in the log. Note
	 *            that on each trace, the eventCondition is first checked on all
	 *            events, and then the trace condition is checked on the
	 *            filtered trace.
	 * @return the filtered log. The result is a clone of the input log, i.e.
	 *         the given log object does not change
	 */
	public static XLog filter(Progress progress, int steps, XLog log, XLogInfo summary, XEventCondition eventCondition,
			XTraceCondition traceCondition) {

		// set the progress indicator to the maximum number of events / 100
		if ((summary == null) && (progress != null)) {
			summary = XLogInfoFactory.createLogInfo(log);
		}
		int barSize = 100;
		if (summary != null) {
			steps = Math.min(steps, summary.getNumberOfTraces());
			barSize = summary.getNumberOfEvents() / (steps > 0 ? steps : 1);
			if (progress != null) {
				progress.setMaximum(progress.getMaximum() + steps);
			}
		}

		// Go through the log to remove all XEvents, of which the name is not
		// contains in
		// labels
		XLog filtered = (XLog) log.clone();
		int i = 0;
		Iterator<XTrace> itTrace = filtered.iterator();
//		long time = -System.currentTimeMillis();
//		long progressTime = 0;
		while (itTrace.hasNext()) {
			XTrace trace = itTrace.next();
			Iterator<XEvent> itEvent = trace.iterator();
			while (itEvent.hasNext()) {
				if (!eventCondition.keepEvent(itEvent.next())) {
					// The XEvent should be removed
					itEvent.remove();
				}
				// Check for progress and signal if necessary
//				progressTime -= System.currentTimeMillis();
				if (progress != null) {
					if (i % barSize == 0) {
						progress.inc();
					}
					i++;
				}
//				progressTime += System.currentTimeMillis();
			}
			if (trace.isEmpty() || !traceCondition.keepTrace(trace)) {
				itTrace.remove();
			}
		}
//		time += System.currentTimeMillis();
//		System.err.println(""[LogFilter] time = "" + time + "", progressTime = "" + progressTime);
		return filtered;
	}

	/**
	 * This method filters a log by checking the given XTrace condition on each
	 * trance. The trace is removed if this condition returns false.
	 * 
	 * @param log
	 *            The log that needs to be filtered.
	 * @param traceCondition
	 *            The condition that is checked for all traces in the log. Note
	 *            that on each trace, the eventCondition is first checked on all
	 *            events, and then the trace condition is checked on the
	 *            filtered trace.
	 * @return the filtered log. The result is a clone of the input log, i.e.
	 *         the given log object does not change
	 */
	public static XLog filter(XLog log, XTraceCondition traceCondition) {
		return filter(null, 1, log, null, traceCondition);
	}

	/**
	 * This method filters a log by checking the given XTrace condition on each
	 * trance. The trace is removed if this condition returns false.
	 * 
	 * @param progress
	 *            A Progress object which is used for showing progress. steps
	 *            steps are added to the maximum and progress is increased in
	 *            steps steps. May be null.
	 * @param steps
	 *            The number of steps in which progress is provided. Should be >
	 *            0
	 * @param log
	 *            The log that needs to be filtered.
	 * @param summary
	 *            The summary of the log. Is used to determine the number of
	 *            events in the log. If null, it will be constructed if progress
	 *            is not null.
	 * @param traceCondition
	 *            The condition that is checked for all traces in the log. Note
	 *            that on each trace, the eventCondition is first checked on all
	 *            events, and then the trace condition is checked on the
	 *            filtered trace.
	 * @return the filtered log. The result is a clone of the input log, i.e.
	 *         the given log object does not change
	 */
	public static XLog filter(Progress progress, int steps, XLog log, XLogInfo summary, XTraceCondition traceCondition) {

		// set the progress indicator to the maximum number of events / 100
		if ((summary == null) && (progress != null)) {
			summary = XLogInfoFactory.createLogInfo(log);
		}
		int barSize = 100;
		if (summary != null) {
			steps = Math.max(1, Math.min(steps, summary.getNumberOfTraces()));
			barSize = summary.getNumberOfTraces() / steps;
			if (progress != null) {
				progress.setMaximum(progress.getMaximum() + steps);
			}
		}

		// Go through the log to remove all XEvents, of which the name is not
		// contains in
		// labels
		XLog filtered = (XLog) log.clone();
		int i = 0;
		Iterator<XTrace> itTrace = filtered.iterator();
//		long time = -System.currentTimeMillis();
//		long progressTime = 0;
		while (itTrace.hasNext()) {
			XTrace trace = itTrace.next();
			if (!traceCondition.keepTrace(trace)) {
				itTrace.remove();
			}
//			progressTime -= System.currentTimeMillis();
			if (progress != null) {
				if (i % barSize == 0) {
					progress.inc();
				}
				i++;
			}
//			progressTime += System.currentTimeMillis();
		}
//		time += System.currentTimeMillis();
//		System.err.println(""[LogFilter] time = "" + time + "", progressTime = "" + progressTime);
		return filtered;
	}

	/**
	 * This method filters a log by removing XEvent objects from all XTrace
	 * object in the given XLog, if the given XEventCondition returns false.
	 * After that, the filtered trace is removed if it remains empty.
	 * 
	 * @param log
	 *            The log that needs to be filtered.
	 * @param eventCondition
	 *            The condition that is checked for all events in the log.
	 * @return the filtered log
	 */
	public static XLog filter(XLog log, XEventCondition eventCondition) {
		return filter(null, 1, log, null, eventCondition);
	}

	/**
	 * This method filters a log by removing XEvent objects from all XTrace
	 * object in the given XLog, if the given XEventCondition returns false.
	 * After that, the filtered trace is removed if it remains empty.
	 * 
	 * @param progress
	 *            A Progress object which is used for showing progress. steps
	 *            steps are added to the maximum and progress is increased in
	 *            steps steps. May be null.
	 * @param steps
	 *            The number of steps in which progress is provided. Should be >
	 *            0
	 * @param log
	 *            The log that needs to be filtered.
	 * @param summary
	 *            The summary of the log. Is used to determine the number of
	 *            events in the log. If null, it will be constructed if progress
	 *            is not null.
	 * @param eventCondition
	 *            The condition that is checked for all events in the log.
	 * @return the filtered log
	 */
	public static XLog filter(Progress progress, int steps, XLog log, XLogInfo summary, XEventCondition eventCondition) {

		return filter(progress, steps, log, summary, eventCondition, new XTraceCondition() {

			public boolean keepTrace(XTrace trace) {
				// Keep the trace
				return true;
			}
		});
	}

	/**
	 * This method filters a log by editing the XEvent objects from all XTrace
	 * object in the given XLog. XEvent objects are removed if the given
	 * XEventEditor returns null. If a new XEvent object is returned by the
	 * XEventEditor, then the original XEvent is replaced by the new XEvent.
	 * After editing all events, the filtered trace is removed if it remains
	 * empty. If it is not empty, then it is provided to the given XTraceEditor
	 * for editing. If this editor returns null, the trace is removed. If this
	 * editor returns a new XTrace object, the original XTrace is replaces.
	 * 
	 * @param log
	 *            The log that needs to be filtered.
	 * @param eventEditor
	 *            The editor that is applied to all XEvents in the log
	 * @param traceEditor
	 *            The editor that is applied to each trace. Note that first all
	 *            events are edited and that the trace editor is then applied to
	 *            the filtered trace, if it is not empty.
	 * @return the filtered log. The result is a clone of the input log, i.e.
	 *         the given log object does not change
	 * @throws LogFilterException
	 */
	public static XLog filter(XLog log, XEventEditor eventEditor, XTraceEditor traceEditor) throws LogFilterException {
		return filter(null, 1, log, null, eventEditor, traceEditor);
	}

	/**
	 * This method filters a log by editing the XEvent objects from all XTrace
	 * object in the given XLog. XEvent objects are removed if the given
	 * XEventEditor returns null. If a new XEvent object is returned by the
	 * XEventEditor, then the original XEvent is replaced by the new XEvent.
	 * After editing all events, the filtered trace is removed if it remains
	 * empty. If it is not empty, then it is provided to the given XTraceEditor
	 * for editing. If this editor returns null, the trace is removed. If this
	 * editor returns a new XTrace object, the original XTrace is replaces.
	 * 
	 * @param progress
	 *            A Progress object which is used for showing progress. steps
	 *            steps are added to the maximum and progress is increased in
	 *            steps steps. May be null.
	 * @param steps
	 *            The number of steps in which progress is provided. Should be >
	 *            0
	 * @param log
	 *            The log that needs to be filtered.
	 * @param summary
	 *            The summary of the log. Is used to determine the number of
	 *            events in the log. If null, it will be constructed if progress
	 *            is not null.
	 * @param eventEditor
	 *            The editor that is applied to all XEvents in the log
	 * @param traceEditor
	 *            The editor that is applied to each trace. Note that first all
	 *            events are edited and that the trace editor is then applied to
	 *            the filtered trace, if it is not empty.
	 * @return the filtered log. The result is a clone of the input log, i.e.
	 *         the given log object does not change
	 * @throws LogFilterException
	 *             if an XTraceEditor returns a new trace.
	 */
	public static XLog filter(Progress progress, int steps, XLog log, XLogInfo summary, XEventEditor eventEditor,
			XTraceEditor traceEditor) throws LogFilterException {

		int barSize = 100;
		// set the progress indicator to the maximum number of events / 100
		if (progress != null) {
			if (summary == null) {
				summary = XLogInfoFactory.createLogInfo(log);
			}
			steps = Math.min(steps, summary.getNumberOfTraces());
			barSize = summary.getNumberOfEvents() / steps;
			progress.setMaximum(progress.getMaximum() + steps);
		}

		// Go through the log to remove all XEvents, of which the name is not
		// contains in
		// labels
		XLog filtered = (XLog) log.clone();

		int progressStep = 0;

		Iterator<XTrace> it = filtered.iterator();
		while (it.hasNext()) {
			XTrace oldTrace = it.next();

			for (int eventIndex = 0; eventIndex < oldTrace.size(); eventIndex++) {
				XEvent oldEvent = oldTrace.get(eventIndex);
				XEvent newEvent = eventEditor.editEvent(oldEvent);
				if (newEvent == null) {
					// The editor returned null, so remove the event
					oldTrace.remove(eventIndex);
					eventIndex--;
				} else if (newEvent != oldEvent) {
					// The editor returned a new event, so replace the old one
					oldTrace.set(eventIndex, newEvent);
				}
				// Check for progress and signal if necessary
				if (progress != null) {
					if (progressStep % barSize == 0) {
						progress.inc();
					}
					progressStep++;
				}
			}
			if (oldTrace.isEmpty()) {
				// All events of this trace were removed, remove the trace
				it.remove();
			} else {
				// Edit the trace
				XTrace newTrace = traceEditor.editTrace(oldTrace);
				if (newTrace == null) {
					// The editor returned null, so remove the trace
					it.remove();
				} else if (newTrace != oldTrace) {
					// The editor returned a new trace, so this is wrong!
					throw new LogFilterException(""New traces cannot be produced by XTraceEditors."");
				}
			}
		}
		return filtered;
	}

	/**
	 * This method filters a log by editing all XTrace objects in the given
	 * XLog. Each XTrace object is provided to the given XTraceEditor for
	 * editing. If this editor returns null, the trace is removed. If this
	 * editor returns a new XTrace object, the original XTrace is replaces.
	 * 
	 * @param log
	 *            The log that needs to be filtered.
	 * @param traceEditor
	 *            The editor that is applied to each trace.
	 * @return the filtered log. The result is a clone of the input log, i.e.
	 *         the given log object does not change
	 * @throws LogFilterException
	 */
	public static XLog filter(XLog log, XTraceEditor traceEditor) throws LogFilterException {
		return filter(null, 1, log, null, traceEditor);
	}

	/**
	 * This method filters a log by editing all XTrace objects in the given
	 * XLog. Each XTrace object is provided to the given XTraceEditor for
	 * editing. If this editor returns null, the trace is removed. If this
	 * editor returns a new XTrace object, the original XTrace is replaces.
	 * 
	 * @param progress
	 *            A Progress object which is used for showing progress. steps
	 *            steps are added to the maximum and progress is increased in
	 *            steps steps. May be null.
	 * @param steps
	 *            The number of steps in which progress is provided. Should be >
	 *            0
	 * @param log
	 *            The log that needs to be filtered.
	 * @param summary
	 *            The summary of the log. Is used to determine the number of
	 *            events in the log. If null, it will be constructed if progress
	 *            is not null.
	 * @param traceEditor
	 *            The editor that is applied to each trace.
	 * @return the filtered log. The result is a clone of the input log, i.e.
	 *         the given log object does not change
	 */
	public static XLog filter(Progress progress, int steps, XLog log, XLogInfo summary, XTraceEditor traceEditor)
			throws LogFilterException {

		// set the progress indicator to the maximum number of events / 100
		if ((summary == null) && (progress != null)) {
			summary = XLogInfoFactory.createLogInfo(log);
		}
		int barSize = 100;
		if (summary != null) {
			steps = Math.min(steps, summary.getNumberOfTraces());
			barSize = summary.getNumberOfTraces() / steps;
			if (progress != null) {
				progress.setMaximum(progress.getMaximum() + steps);
			}
		}

		// Go through the log to remove all XEvents, of which the name is not
		// contains in
		// labels
		XLog filtered = (XLog) log.clone();
		int progressStep = 0;
		Iterator<XTrace> it = filtered.iterator();
		while (it.hasNext()) {
			XTrace oldTrace = it.next();

			// Edit the trace
			XTrace newTrace = traceEditor.editTrace(oldTrace);
			if (newTrace == null) {
				// The editor returned null, so remove the trace
				it.remove();
			} else if (newTrace != oldTrace) {
				// The editor returned a new trace, so this is wrong
				throw new LogFilterException(""New traces cannot be produced by XTraceEditors."");
			}
			// Check for progress and signal if necessary
			if (progress != null) {
				if (progressStep % barSize == 0) {
					progress.inc();
				}
				progressStep++;
			}
		}
		return filtered;
	}

	/**
	 * This method filters a log by editing the XEvent objects from all XTrace
	 * object in the given XLog. XEvent objects are removed if the given
	 * XEventEditor returns null. If a new XEvent object is returned by the
	 * XEventEditor, then the original XEvent is replaced by the new XEvent.
	 * After editing, the filtered trace is removed if it remains empty.
	 * 
	 * @param log
	 *            The log that needs to be filtered.
	 * @param eventEditor
	 *            The editor that is applied to all XEvents in the log
	 * @return the filtered log. The result is a clone of the input log, i.e.
	 *         the given log object does not change
	 * @throws LogFilterException
	 */
	public static XLog filter(XLog log, XEventEditor eventEditor) throws LogFilterException {
		return filter(null, 1, log, null, eventEditor);
	}

	/**
	 * This method filters a log by editing the XEvent objects from all XTrace
	 * object in the given XLog. XEvent objects are removed if the given
	 * XEventEditor returns null. If a new XEvent object is returned by the
	 * XEventEditor, then the original XEvent is replaced by the new XEvent.
	 * After editing, the filtered trace is removed if it remains empty.
	 * 
	 * @param progress
	 *            A Progress object which is used for showing progress. steps
	 *            steps are added to the maximum and progress is increased in
	 *            steps steps. May be null.
	 * @param steps
	 *            The number of steps in which progress is provided. Should be >
	 *            0
	 * @param log
	 *            The log that needs to be filtered.
	 * @param summary
	 *            The summary of the log. Is used to determine the number of
	 *            events in the log. If null, it will be constructed if progress
	 *            is not null.
	 * @param eventEditor
	 *            The editor that is applied to all XEvents in the log
	 * @return the filtered log. The result is a clone of the input log, i.e.
	 *         the given log object does not change
	 * @throws LogFilterException
	 */
	public static XLog filter(Progress progress, int steps, XLog log, XLogInfo summary, XEventEditor eventEditor)
			throws LogFilterException {

		return filter(progress, steps, log, summary, eventEditor, new XTraceEditor() {

			public XTrace editTrace(XTrace trace) {
				if (trace.isEmpty()) {
					return null;
				} else {
					return trace;
				}
			}
		});
	}

}
"
LogFilterException.java,log,"package org.processmining.plugins.log.logfilters;

public class LogFilterException extends Exception {

	/**
	 * 
	 */
	private static final long serialVersionUID = 8913201243551484739L;

	public LogFilterException(String message) {
		super(message);
	}
}"
TraceAttributeFilterParameters.java,log,"package org.processmining.plugins.log.logfilters;

import java.util.HashMap;
import java.util.HashSet;
import java.util.Set;

import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.model.XAttribute;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.processmining.framework.plugin.PluginContext;

public class TraceAttributeFilterParameters extends AttributeFilterParameters {

	public TraceAttributeFilterParameters(PluginContext context, XLog log) {
		super(context);
		filter = new HashMap<String, Set<String>>();
		for (XTrace trace : log) {
			for (String key : trace.getAttributes().keySet()) {
				if (!filter.containsKey(key)) {
					filter.put(key, new HashSet<String>());
				}
				filter.get(key).add(trace.getAttributes().get(key).toString());
			}
			context.getProgress().inc();
		}
		for (XAttribute attribute : log.getGlobalTraceAttributes()) {
			mustHaves.add(attribute.getKey());
		}
		name = XConceptExtension.instance().extractName(log);
	}
}
"
TraceAttributeFilterPlugin.java,log,"package org.processmining.plugins.log.logfilters;

import org.deckfour.uitopia.api.event.TaskListener.InteractionResult;
import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.factory.XFactory;
import org.deckfour.xes.factory.XFactoryRegistry;
import org.deckfour.xes.model.XAttributeMap;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginCategory;
import org.processmining.framework.plugin.annotations.PluginLevel;
import org.processmining.framework.plugin.annotations.PluginVariant;

@Plugin(name = ""Filter Log on Trace Attribute Values"", level= PluginLevel.PeerReviewed, categories = { PluginCategory.Filtering }, parameterLabels = { ""Log"", ""Parameters"" }, returnLabels = { ""Log"" }, returnTypes = { XLog.class })
public class TraceAttributeFilterPlugin {

	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""H.M.W. Verbeek"", email = ""h.m.w.verbeek@tue.nl"")
	@PluginVariant(variantLabel = ""Filter Log on Trace Attribute Values, UI"", requiredParameterLabels = { 0 })
	public XLog filterDialog(UIPluginContext context, XLog log) {
		context.getProgress().setMaximum(3 * log.size());
		TraceAttributeFilterParameters parameters = new TraceAttributeFilterParameters(context, log);
		AttributeFilterDialog dialog = new AttributeFilterDialog(context, parameters, "" (filtered on trace attributes)"");
		InteractionResult result = context.showWizard(""Configure filter (values)"", true, true, dialog);
		if (result != InteractionResult.FINISHED) {
			context.log(""Canceled by user."");
			context.getFutureResult(0).cancel(true);
			return null;
		}
		dialog.applyFilter();
		return filterPrivate(context, log, parameters);
	}

	@PluginVariant(variantLabel = ""Filter Log on Trace Attribute Values, Parameters"", requiredParameterLabels = { 0 })
	public XLog filterParameters(PluginContext context, XLog log, AttributeFilterParameters parameters) {
		return filterPrivate(context, log, parameters);
	}

	private XLog filterPrivate(PluginContext context, XLog log, AttributeFilterParameters parameters) {
		XFactory factory = XFactoryRegistry.instance().currentDefault();
		XLog filteredLog = factory.createLog((XAttributeMap) log.getAttributes().clone());
		filteredLog.getClassifiers().addAll(log.getClassifiers());
		filteredLog.getExtensions().addAll(log.getExtensions());
		filteredLog.getGlobalTraceAttributes().addAll(log.getGlobalTraceAttributes());
		filteredLog.getGlobalEventAttributes().addAll(log.getGlobalEventAttributes());
		for (XTrace trace : log) {
			boolean add = true;
			if (trace.getAttributes().keySet().containsAll(parameters.getMustHaves())) {
				for (String key : trace.getAttributes().keySet()) {
					String value = trace.getAttributes().get(key).toString();
					if (!parameters.getFilter().get(key).contains(value)) {
						add = false;
						continue;
					}
				}
				if (add) {
					filteredLog.add(trace);
				}
			}
			context.getProgress().inc();
		}
		XConceptExtension.instance().assignName(filteredLog, parameters.getName());
		context.getFutureResult(0).setLabel(parameters.getName());
		return filteredLog;
	}
}
"
LogFilterPlugin.java,log,"package org.processmining.plugins.log.logfilters.ui;

import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.model.XLog;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginCategory;
import org.processmining.framework.plugin.annotations.PluginLevel;
import org.processmining.framework.plugin.annotations.PluginVariant;

@Plugin(name = ""Filter Log using Simple Heuristics"", level= PluginLevel.PeerReviewed, categories = { PluginCategory.Filtering }, parameterLabels = { ""Log"" }, returnLabels = { ""Log"" }, returnTypes = { XLog.class }, userAccessible = true)
public class LogFilterPlugin {

	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""H.M.W. Verbeek"", email = ""h.m.w.verbeek@tue.nl"", pack = ""Log"")
	@PluginVariant(variantLabel = ""Default"", requiredParameterLabels = { 0 })
	public static XLog main(final UIPluginContext context, XLog log) {
		LogFilterUI filterUI = new LogFilterUI(context);
		XLog filteredLog = filterUI.filter(log);
		if (filteredLog != null) {
			XConceptExtension.instance().assignName(filteredLog, filterUI.getName());
			context.getFutureResult(0).setLabel(filterUI.getName());
		} else {
			context.log(""Canceled by user."");
			context.getFutureResult(0).cancel(true);
		}
		return filteredLog;
	}
}
"
LogFilterUI.java,log,"package org.processmining.plugins.log.logfilters.ui;

import info.clearthought.layout.TableLayout;
import info.clearthought.layout.TableLayoutConstants;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import java.util.TreeSet;

import javax.swing.BorderFactory;
import javax.swing.Box;
import javax.swing.BoxLayout;
import javax.swing.JComponent;
import javax.swing.JLabel;
import javax.swing.JList;
import javax.swing.JPanel;
import javax.swing.JScrollBar;
import javax.swing.JScrollPane;
import javax.swing.ListSelectionModel;
import javax.swing.ScrollPaneConstants;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;

import org.deckfour.uitopia.api.event.TaskListener.InteractionResult;
import org.deckfour.xes.classification.XEventClass;
import org.deckfour.xes.classification.XEventClasses;
import org.deckfour.xes.classification.XEventClassifier;
import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.info.XLogInfo;
import org.deckfour.xes.info.impl.XLogInfoImpl;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.framework.util.collection.AlphanumComparator;
import org.processmining.framework.util.ui.widgets.ProMTextField;
import org.processmining.plugins.log.logfilters.impl.DefaultLogFilter;
import org.processmining.plugins.log.logfilters.impl.EventLogFilter;
import org.processmining.plugins.log.logfilters.impl.FinalEventLogFilter;
import org.processmining.plugins.log.logfilters.impl.StartEventLogFilter;
import org.processmining.plugins.log.logfilters.ui.SlickerEventTypeConfiguration.EventTypeAction;

import com.fluxicon.slickerbox.components.NiceSlider;
import com.fluxicon.slickerbox.components.NiceSlider.Orientation;
import com.fluxicon.slickerbox.components.RoundedPanel;
import com.fluxicon.slickerbox.factory.SlickerFactory;
import com.fluxicon.slickerbox.ui.SlickerScrollBarUI;

/**
 * Simple log filter. Allows the user to use the following filters in the given
 * order: 1. Filter events using the lifecycle transition classification. 2.
 * Filter traces on start events using the standard classification (concept name
 * and lifecycle transition). 3. Filter traces on end events using the standard
 * classification (concept name and lifecycle transition). 4. Filter events
 * using the standard classification (concept name and lifecycle transition).
 * During steps 2, 3, and 4, the user can use a slider to indicate how much
 * coverage s/he wants. The most occurring events/traces will then be selected
 * until the coverage has been reached.
 * 
 * @author hverbeek
 * 
 */
public class LogFilterUI {

	private final UIPluginContext context;
	private int nofSteps;
	private int eventTypeStep;
	private int startEventStep;
	private int endEventStep;
	private int eventFilterStep;
	private int currentStep;
	private myStep[] mySteps;
	private String name;

	/**
	 * Whether to use all events, only the start events, or only the end events.
	 */
	enum Mode {
		ALLEVENTS, STARTEVENTS, ENDEVENTS
	}

	public LogFilterUI(UIPluginContext context) {
		this.context = context;
	}

	public String getName() {
		return name;
	}
	
	/**
	 * Runs the simple log filter on the given log.
	 * 
	 * @param log
	 *            The given log.
	 * @return The filtered log (depends on the settings chosen by the user).
	 */
	public XLog filter(XLog log) {
		InteractionResult result;

		name = XConceptExtension.instance().extractName(log) + "" (filtered on simple heuristics)"";
		/*
		 * Create all filter steps.
		 */
		nofSteps = 0;
		eventTypeStep = nofSteps++;
		startEventStep = nofSteps++;
		endEventStep = nofSteps++;
		eventFilterStep = nofSteps++;

		mySteps = new myStep[nofSteps];

		mySteps[eventTypeStep] = new EventTypeStep();
		mySteps[startEventStep] = new StartEventStep();
		mySteps[endEventStep] = new EndEventStep();
		mySteps[eventFilterStep] = new EventFilterStep();

		/*
		 * Initialize the first step.
		 */
		currentStep = eventTypeStep;
		mySteps[currentStep].initComponents(log);

		/*
		 * The wizard loop.
		 */
		while (true) {
			/*
			 * Show the current step.
			 */
			result = context.showWizard(""Log Filter"", currentStep == 0, currentStep == nofSteps - 1,
					mySteps[currentStep]);
			switch (result) {
				case NEXT :
					/*
					 * Show the next step. First get the log of the previous
					 * step, then move the next step, and initialize it with the
					 * filtered log of the previous step.
					 */
					//					long time = -System.currentTimeMillis();
					XLog filteredLog = mySteps[currentStep].getLog();
					//					time += System.currentTimeMillis();
					//					System.err.println(""[LogFilterUI] log time = "" + time);
					go(1);
					//					time = -System.currentTimeMillis();
					mySteps[currentStep].initComponents(filteredLog);
					mySteps[currentStep].repaint();
					//					time += System.currentTimeMillis();
					//					System.err.println(""[LogFilterUI] UI time = "" + time);
					break;
				case PREV :
					/*
					 * Move back. The previous step should still be valid.
					 */
					go(-1);
					break;
				case FINISHED :
					/*
					 * Return the filtered log of the final step.
					 */
					return mySteps[currentStep].getLog();
				default :
					/*
					 * Should not occur.
					 */
					return null;
			}
		}
	}

	/**
	 * Move the wizard in either direction.
	 * 
	 * @param direction
	 *            The direction, use 1 for forward and -1 for backward.
	 * @return The next step.
	 */
	private int go(int direction) {
		currentStep += direction;
		if ((currentStep >= 0) && (currentStep < nofSteps)) {
			if (mySteps[currentStep].precondition()) {
				return currentStep;
			} else {
				return go(direction);
			}
		}
		return currentStep;
	}

	/*
	 * Now follows a section containing some graphical improvements. Not
	 * important for the logic.
	 */
	protected Color colorBg = new Color(140, 140, 140);
	protected Color colorOuterBg = new Color(100, 100, 100);
	protected Color colorListBg = new Color(60, 60, 60);
	protected Color colorListBgSelected = new Color(10, 90, 10);
	protected Color colorListFg = new Color(200, 200, 200, 160);
	protected Color colorListFgSelected = new Color(230, 230, 230, 200);
	protected Color colorListEnclosureBg = new Color(150, 150, 150);
	protected Color colorListHeader = new Color(10, 10, 10);
	protected Color colorListDescription = new Color(60, 60, 60);

	protected JComponent configureList(JList<Object> list, String title, String description) {
		list.setFont(list.getFont().deriveFont(13f));
		list.setBackground(colorListBg);
		list.setForeground(colorListFg);
		list.setSelectionBackground(colorListBgSelected);
		list.setSelectionForeground(colorListFgSelected);
		list.setFont(list.getFont().deriveFont(12f));
		list.setSelectionMode(ListSelectionModel.MULTIPLE_INTERVAL_SELECTION);
		list.setSelectionInterval(0, list.getModel().getSize() - 1);
		return configureAnyScrollable(list, title, description);
	}

	protected JComponent configureAnyScrollable(JComponent scrollable, String title, String description) {
		RoundedPanel enclosure = new RoundedPanel(10, 5, 5);
		enclosure.setBackground(colorListEnclosureBg);
		enclosure.setLayout(new BoxLayout(enclosure, BoxLayout.Y_AXIS));
		JLabel headerLabel = new JLabel(title);
		headerLabel.setOpaque(false);
		headerLabel.setForeground(colorListHeader);
		headerLabel.setFont(headerLabel.getFont().deriveFont(14f));
		JLabel descriptionLabel = new JLabel(""<html>"" + description + ""</html>"");
		descriptionLabel.setOpaque(false);
		descriptionLabel.setForeground(colorListDescription);
		descriptionLabel.setFont(descriptionLabel.getFont().deriveFont(11f));
		JScrollPane listScrollPane = new JScrollPane(scrollable);
		listScrollPane.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_AS_NEEDED);
		listScrollPane.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);
		listScrollPane.setViewportBorder(BorderFactory.createLineBorder(new Color(40, 40, 40)));
		listScrollPane.setBorder(BorderFactory.createEmptyBorder());
		JScrollBar vBar = listScrollPane.getVerticalScrollBar();
		vBar.setUI(new SlickerScrollBarUI(vBar, colorListEnclosureBg, new Color(30, 30, 30), new Color(80, 80, 80), 4,
				12));
		enclosure.add(packLeftAligned(headerLabel));
		enclosure.add(Box.createVerticalStrut(3));
		enclosure.add(packLeftAligned(descriptionLabel));
		enclosure.add(Box.createVerticalStrut(5));
		enclosure.add(listScrollPane);
		return enclosure;
	}

	protected JComponent packLeftAligned(JComponent component) {
		JPanel packed = new JPanel();
		packed.setOpaque(false);
		packed.setBorder(BorderFactory.createEmptyBorder());
		packed.setLayout(new BoxLayout(packed, BoxLayout.X_AXIS));
		packed.add(component);
		packed.add(Box.createHorizontalGlue());
		return packed;
	}

	/**
	 * Basic step class. Every step has a log, a way to check whether it should
	 * be displayed, a way to get the filtered log, and a way to initialize it
	 * with some log.
	 * 
	 * @author hverbeek
	 * 
	 */
	private abstract class myStep extends JPanel {
		/**
		 * 
		 */
		private static final long serialVersionUID = 6125158693462475923L;
		/**
		 * The log to filter using this step.
		 */
		protected XLog log;

		public void setLog(XLog log) {
			this.log = log;
		}

		/**
		 * Returns whether this step should be displayed. If not, it should be
		 * skipped.
		 * 
		 * @return Whether to display this step.
		 */
		public abstract boolean precondition();

		/**
		 * Returns the filtered log.
		 * 
		 * @return The filtered log.
		 */
		public abstract XLog getLog();

		/**
		 * Initializes the step given the log to filter.
		 * 
		 * @param log
		 *            The log to filter.
		 */
		public abstract void initComponents(XLog log);
	}

	private class EventClassComparator implements Comparator<XEventClass> {

		public int compare(XEventClass o1, XEventClass o2) {
			// TODO Auto-generated method stub
			return (new AlphanumComparator().compare(o1.toString(), o2.toString()));
		}
	}

	/**
	 * Simple step class. All steps belong to this class, but in the future
	 * additional (non-simple) steps may be added.
	 * 
	 * @author hverbeek
	 * 
	 */
	private abstract class SimpleStep extends myStep {
		/**
		 * 
		 */
		private static final long serialVersionUID = 2288113155552125657L;
		/**
		 * The classifier to use for the filtering.
		 */
		protected XEventClassifier classifier;
		/**
		 * The log info obtained for this classifier.
		 */
		private XLogInfo logInfo;
		/**
		 * The advanced selection list used in step 1.
		 */
		protected SlickerEventTypeConfiguration cfg;
		/**
		 * The simple selection list used in steps 2,3 , and 4.
		 */
		protected JComponent comp;
		protected JList<Object> list;
		/**
		 * Whether to use the advanced (true) or simple (false) selection list.
		 */
		private final boolean useCfg;
		/**
		 * The heading to display for the simple selection list.
		 */
		private final String heading;
		/**
		 * The text to display for the simple selection list.
		 */
		private final String text;
		/**
		 * Whether to use all events, only start events, or only end events.
		 */
		private final Mode mode;
		/**
		 * The event classes found.
		 */
		private XEventClasses eventClasses;
		private List<XEventClass> sortedEventClasses;
		/**
		 * The slider used for the simple selection list.
		 */
		private NiceSlider slider;

		/**
		 * Creates the simple step.
		 * 
		 * @param classifier
		 *            The classifier to use in this step.
		 * @param mode
		 *            The mode to use (all events, start events, or end events).
		 * @param useCfg
		 *            Whether to use the advanced list or the simple list.
		 * @param heading
		 *            The heading to use, if simple list (null otherwise).
		 * @param text
		 *            The text to use, if simple list (null otherwise).
		 */
		public SimpleStep(XEventClassifier classifier, Mode mode, boolean useCfg, String heading, String text) {
			this.classifier = classifier;
			this.mode = mode;
			this.useCfg = useCfg;
			this.heading = heading;
			this.text = text;
			cfg = null;
			comp = null;
			slider = null;
		}

		/**
		 * All steps may always be displayed.
		 */
		public boolean precondition() {
			// TODO Auto-generated method stub
			return true;
		}

		/**
		 * Initializes the component, given the log to filter.
		 */
		public void initComponents(XLog log) {
			setLog(log);
			double size[][] = { { 80, TableLayoutConstants.FILL }, { TableLayoutConstants.FILL, 30, 30 } };
			setLayout(new TableLayout(size));
			add(new JLabel(""Log name:""), ""0, 2"");
			final ProMTextField textField = new ProMTextField(name);
			textField.setPreferredSize(new Dimension(100, 25));
			this.add(textField, ""1, 2"");
			textField.addKeyListener(new KeyListener() {

				public void keyTyped(KeyEvent e) {
					name = textField.getText();
				}

				public void keyPressed(KeyEvent e) {
					name = textField.getText();
				}

				public void keyReleased(KeyEvent e) {
					name = textField.getText();
				}
				
			});

			/**
			 * Initialize the event classes.
			 */
			eventClasses = null;
			switch (mode) {
				case ALLEVENTS :
					logInfo = XLogInfoImpl.create(log, classifier);
					eventClasses = logInfo.getEventClasses(classifier);
					break;
				case STARTEVENTS :
					eventClasses = new XEventClasses(classifier);
					for (XTrace trace : log) {
						if (!trace.isEmpty()) {
							eventClasses.register(trace.get(0));
						}
					}
					break;
				case ENDEVENTS :
					eventClasses = new XEventClasses(classifier);
					for (XTrace trace : log) {
						if (!trace.isEmpty()) {
							eventClasses.register(trace.get(trace.size() - 1));
						}
					}
					break;
				default :
			}
			/**
			 * Initialize the selection list.
			 */
			if (eventClasses != null) {
				if (useCfg) {
					if (cfg != null) {
						this.remove(cfg);
					}
					cfg = new SlickerEventTypeConfiguration(eventClasses.getClasses().toArray());
					this.add(cfg, ""0, 0, 1, 0"");
				} else {
					if (comp != null) {
						this.remove(comp);
					}
					sortedEventClasses = new ArrayList<XEventClass>(eventClasses.getClasses());
					Collections.sort(sortedEventClasses, new EventClassComparator());
					list = new JList<Object>(sortedEventClasses.toArray());
					comp = configureList(list, heading, text);
					this.add(comp, ""0, 0, 1, 0"");
				}
			}
			/**
			 * Initialize the slider, if necessary.
			 */
			if (!useCfg) {
				if (slider != null) {
					this.remove(slider);
				}
				slider = SlickerFactory.instance().createNiceIntegerSlider(""Select top percentage"", 0, 100, 80,
						Orientation.HORIZONTAL);
				ChangeListener listener = new ChangeListener() {

					public void stateChanged(ChangeEvent e) {
						// TODO Auto-generated method stub
						int percentage = slider.getSlider().getValue();
						int size = 0;
						TreeSet<Integer> eventSizes = new TreeSet<Integer>();
						for (XEventClass event : sortedEventClasses) {
							size += event.size();
							eventSizes.add(event.size());
						}
						int treshold = size * percentage;
						int value = 0;
						list.clearSelection();
						while (100 * value < treshold) {
							int eventSize = eventSizes.last();
							eventSizes.remove(eventSize);
							int index = 0;
							for (XEventClass event : sortedEventClasses) {
								if (event.size() == eventSize) {
									value += eventSize;
									list.addSelectionInterval(index, index);
								}
								index++;
							}
						}
					}

				};
				slider.addChangeListener(listener);
				listener.stateChanged(null);
				this.add(slider, ""0, 1, 1, 1"");
			}
		}
	}

	private class EventTypeStep extends SimpleStep {
		/**
		 * 
		 */
		private static final long serialVersionUID = 1266880064535493470L;

		public EventTypeStep() {
			super(XLogInfoImpl.LIFECYCLE_TRANSITION_CLASSIFIER, Mode.ALLEVENTS, true, null, null);
		}

		public XLog getLog() {
			String[] toRemove = cfg.getFilteredEventTypes(EventTypeAction.REMOVE);
			String[] toSkip = cfg.getFilteredEventTypes(EventTypeAction.SKIP_INSTANCE);
			//			PluginContext filterContext = context.createChildContext(""Default Log Filter"");
			DefaultLogFilter filter = new DefaultLogFilter();
			return filter.filter(null, log, toRemove, toSkip);

			/*
			 * try { return
			 * context.tryToFindOrConstructFirstNamedObject(XLog.class,
			 * ""Default Log Filter"", Connection.class, """", log, toRemove,
			 * toSkip); } catch (ConnectionCannotBeObtained e) { // TODO
			 * Auto-generated catch block e.printStackTrace(); }
			 */
			/*
			 * Set<Pair<Integer, PluginParameterBinding>> plugins =
			 * context.getPluginManager().find(Plugin.class, XLog.class,
			 * context.getPluginContextType(), true, true, true, XLog.class,
			 * String[].class, String[].class); for (Pair<Integer,
			 * PluginParameterBinding> plugin: plugins) { if
			 * (plugin.getSecond().
			 * getPlugin().getName().equals(""Default Log Filter"")) {
			 * UIPluginContext subContext =
			 * context.createChildContext(""Default Log Filter"");
			 * PluginExecutionResult result =
			 * plugin.getSecond().invoke(subContext, log, toRemove, toSkip); try
			 * { result.synchronize(); } catch (CancellationException e) { //
			 * TODO Auto-generated catch block e.printStackTrace(); } catch
			 * (ExecutionException e) { // TODO Auto-generated catch block
			 * e.printStackTrace(); } catch (InterruptedException e) { // TODO
			 * Auto-generated catch block e.printStackTrace(); } return
			 * result.getResult(plugin.getFirst()); } } return log;
			 */
		}
	}

	private class StartEventStep extends SimpleStep {
		/**
		 * 
		 */
		private static final long serialVersionUID = 8547494758416001029L;

		public StartEventStep() {
			super(XLogInfoImpl.STANDARD_CLASSIFIER, Mode.STARTEVENTS, false, ""Start events"",
					""Only instances starting with a green event will be used."");
		}

		public XLog getLog() {
			// TODO Auto-generated method stub
			List<Object> selectedObjects = list.getSelectedValuesList();
			String[] startIds = new String[selectedObjects.size()];
			for (int i = 0; i < selectedObjects.size(); i++) {
				startIds[i] = selectedObjects.get(i).toString();
			}
			//			PluginContext filterContext = context.createChildContext(""Start Event Log Filter"");
			StartEventLogFilter filter = new StartEventLogFilter();
			return filter.filterWithClassifier(null, log, classifier, startIds);

			/*
			 * try { return
			 * context.tryToFindOrConstructFirstNamedObject(XLog.class,
			 * ""Start Event Log Filter"", Connection.class, """", log, classifier,
			 * startIds); } catch (ConnectionCannotBeObtained e) { // TODO
			 * Auto-generated catch block e.printStackTrace(); } return log;
			 */
		}
	}

	private class EndEventStep extends SimpleStep {
		/**
		 * 
		 */
		private static final long serialVersionUID = 4750780067360884545L;

		public EndEventStep() {
			super(XLogInfoImpl.STANDARD_CLASSIFIER, Mode.ENDEVENTS, false, ""End events"",
					""Only instances ending with a green event will be used."");
		}

		public XLog getLog() {
			// TODO Auto-generated method stub
			List<Object> selectedObjects = list.getSelectedValuesList();
			String[] endIds = new String[selectedObjects.size()];
			for (int i = 0; i < selectedObjects.size(); i++) {
				endIds[i] = selectedObjects.get(i).toString();
			}
			//			PluginContext filterContext = context.createChildContext(""Final Event Log Filter"");
			FinalEventLogFilter filter = new FinalEventLogFilter();
			return filter.filterWithClassifier(null, log, classifier, endIds);

			/*
			 * try { return
			 * context.tryToFindOrConstructFirstNamedObject(XLog.class,
			 * ""Final Event Log Filter"", Connection.class, """", log, classifier,
			 * endIds); } catch (ConnectionCannotBeObtained e) { // TODO
			 * Auto-generated catch block e.printStackTrace(); } return log;
			 */
		}
	}

	private class EventFilterStep extends SimpleStep {
		/**
		 * 
		 */
		private static final long serialVersionUID = 2295002325162718535L;

		public EventFilterStep() {
			super(XLogInfoImpl.STANDARD_CLASSIFIER, Mode.ALLEVENTS, false, ""Event filter"",
					""Only green events will be used."");
		}

		public XLog getLog() {
			// TODO Auto-generated method stub
			List<Object> selectedObjects = list.getSelectedValuesList();
			String[] selectedIds = new String[selectedObjects.size()];
			for (int i = 0; i < selectedObjects.size(); i++) {
				selectedIds[i] = selectedObjects.get(i).toString();
			}
			//			PluginContext filterContext = context.createChildContext(""Event Log Filter"");
			EventLogFilter filter = new EventLogFilter();
			return filter.filterWithClassifier(null, log, classifier, selectedIds);

			/*
			 * try { return
			 * context.tryToFindOrConstructFirstNamedObject(XLog.class,
			 * ""Event Log Filter"", Connection.class, """", log, eventClasses,
			 * selectedClasses); } catch (ConnectionCannotBeObtained e) { //
			 * TODO Auto-generated catch block e.printStackTrace(); } return
			 * log;
			 */
		}

	}
}
"
SlickerEventTypeConfiguration.java,log,"package org.processmining.plugins.log.logfilters.ui;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.ArrayList;

import javax.swing.BorderFactory;
import javax.swing.Box;
import javax.swing.BoxLayout;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.SwingConstants;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;

import com.fluxicon.slickerbox.components.GradientPanel;

public class SlickerEventTypeConfiguration extends JPanel {

	/**
	 * 
	 */
	private static final long serialVersionUID = 52715433965263148L;
	protected static Color colorText = new Color(255, 255, 255, 160);
	protected static Color colorKeep1 = new Color(10, 90, 1);
	protected static Color colorKeep2 = new Color(20, 140, 20);
	protected static Color colorRemove1 = new Color(90, 60, 10);
	protected static Color colorRemove2 = new Color(140, 100, 20);
	protected static Color colorSkipInstance1 = new Color(90, 10, 10);
	protected static Color colorSkipInstance2 = new Color(140, 20, 20);

	public enum EventTypeAction {
		KEEP, REMOVE, SKIP_INSTANCE;
	}

	protected Object[] objects;
	protected EventTypeConfigurationItem[] configurationItems;
	protected ChangeListener updateListener = null;

	public SlickerEventTypeConfiguration(Object[] objects) {
		this.objects = objects;
		setBackground(new Color(60, 60, 60));
		setMinimumSize(new Dimension(70, 40));
		setMaximumSize(new Dimension(1000, 5000));
		setBorder(BorderFactory.createEmptyBorder());
		setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));
		configurationItems = new EventTypeConfigurationItem[objects.length];
		int height = 0;
		for (int i = 0; i < objects.length; i++) {
			configurationItems[i] = new EventTypeConfigurationItem(objects[i]);
			this.add(configurationItems[i]);
			height += configurationItems[i].getPreferredSize().height + 2;
		}
		this.add(Box.createVerticalGlue());
		setPreferredSize(new Dimension(120, height));
		revalidate();
	}

	public void setUpdateListener(ChangeListener updateListener) {
		this.updateListener = updateListener;
	}

	public String[] getFilteredEventTypes(EventTypeAction action) {
		ArrayList<Object> types = new ArrayList<Object>();
		for (EventTypeConfigurationItem item : configurationItems) {
			if (item.getAction() == action) {
				types.add(item.getObject().toString());
			}
		}
		return types.toArray(new String[0]);
	}

	protected class EventTypeConfigurationItem extends GradientPanel {

		/**
		 * 
		 */
		private static final long serialVersionUID = -7596401396201481445L;
		protected Object object;
		protected EventTypeAction action;
		protected JLabel actionLabel;
		protected JLabel nameLabel;

		public EventTypeConfigurationItem(Object object) {
			super(colorKeep2, colorKeep1);
			setMinimumSize(new Dimension(70, 28));
			setMaximumSize(new Dimension(500, 28));
			setPreferredSize(new Dimension(120, 28));
			setBorder(BorderFactory.createEmptyBorder(4, 10, 4, 10));
			setLayout(new BoxLayout(this, BoxLayout.X_AXIS));
			this.object = object;
			nameLabel = new JLabel(object.toString());
			nameLabel.setOpaque(false);
			nameLabel.setForeground(colorText);
			nameLabel.setVerticalAlignment(SwingConstants.CENTER);
			nameLabel.setFont(nameLabel.getFont().deriveFont(13f));
			actionLabel = new JLabel(""change_me"");
			actionLabel.setOpaque(false);
			actionLabel.setForeground(colorText);
			actionLabel.setVerticalAlignment(SwingConstants.CENTER);
			actionLabel.setFont(actionLabel.getFont().deriveFont(12f).deriveFont(Font.ITALIC));
			if (object.toString().equals(""reassign"") || object.toString().equals(""suspend"")
					|| object.toString().equals(""resume"")) {
				setAction(EventTypeAction.REMOVE);
			} else if (object.toString().equals(""withdraw"") || object.toString().equals(""ate_abort"")
					|| object.toString().equals(""pi_abort"")) {
				setAction(EventTypeAction.SKIP_INSTANCE);
			} else {
				// schedule, assign, start, complete, autoskip, manualskip, rest
				setAction(EventTypeAction.KEEP);
			}
			this.add(nameLabel);
			this.add(Box.createHorizontalGlue());
			this.add(actionLabel);
			addMouseListener(new MouseListener() {
				public void mouseClicked(MouseEvent arg0) {
					if (action == EventTypeAction.KEEP) {
						setAction(EventTypeAction.REMOVE);
					} else if (action == EventTypeAction.REMOVE) {
						setAction(EventTypeAction.SKIP_INSTANCE);
					} else if (action == EventTypeAction.SKIP_INSTANCE) {
						setAction(EventTypeAction.KEEP);
					}
					// notify update listener
					if (updateListener != null) {
						updateListener.stateChanged(new ChangeEvent(this));
					}
				}

				public void mouseEntered(MouseEvent arg0) { /* ignore */
				}

				public void mouseExited(MouseEvent arg0) { /* ignore */
				}

				public void mousePressed(MouseEvent arg0) { /* ignore */
				}

				public void mouseReleased(MouseEvent arg0) { /* ignore */
				}
			});
		}

		public EventTypeAction getAction() {
			return action;
		}

		public Object getObject() {
			return object;
		}

		public void setAction(EventTypeAction action) {
			this.action = action;
			if (action == EventTypeAction.KEEP) {
				actionLabel.setText(""(keep)"");
				super.setColors(colorKeep2, colorKeep1);
			} else if (action == EventTypeAction.REMOVE) {
				actionLabel.setText(""(remove)"");
				super.setColors(colorRemove2, colorRemove1);
			} else if (action == EventTypeAction.SKIP_INSTANCE) {
				actionLabel.setText(""(discard instance)"");
				super.setColors(colorSkipInstance2, colorSkipInstance1);
			}
		}
	}
}
"
XEventCondition.java,log,"package org.processmining.plugins.log.logfilters;

import org.deckfour.xes.model.XEvent;

/**
 * Interface used for easy filtering of XLog object. Used by LogFilter.
 * 
 * @author bfvdonge
 * 
 */
public interface XEventCondition {

	/**
	 * When filtering, this method is called for each XEvent in the log. The
	 * event should not be edited (use the XEventEditor for that). Instead, this
	 * method should test whether the event should be kept by a given filter or
	 * not.
	 * 
	 * @param event
	 *            The event that is currently being considered by the calling
	 *            filter.
	 * @return true if the event should be kept, false if the given event should
	 *         be removed.
	 */
	public boolean keepEvent(XEvent event);
}
"
XEventEditor.java,log,"package org.processmining.plugins.log.logfilters;

import org.deckfour.xes.model.XEvent;

/**
 * Interface used for easy filtering of XLog object. Used by LogFilter.
 * 
 * @author bfvdonge
 * 
 */
public interface XEventEditor {

	/**
	 * When filtering, this method is called for each XEvent in the log. The
	 * event can be edited, or a new one can be returned. If null is returned,
	 * the calling filter will remove the event from the log. If a new XEvent
	 * object is returned, the called filter will replace the old event with the
	 * new event.
	 * 
	 * @param event
	 *            The event that is currently being considered by the calling
	 *            filter.
	 * @return The edited event. If null is returned, then the event is removed.
	 *         If a new XEvent object is returned, the event is replaced.
	 * 
	 */
	public XEvent editEvent(XEvent event);

}
"
XTraceCondition.java,log,"package org.processmining.plugins.log.logfilters;

import org.deckfour.xes.model.XTrace;

/**
 * Interface used for easy filtering of XLog object. Used by LogFilter.
 * 
 * @author bfvdonge
 * 
 */
public interface XTraceCondition {

	/**
	 * When filtering, this method is called for each XTrace in the log. The
	 * trace should not be edited (use the XTraceEditor for that). Instead, this
	 * method should test whether the trace should be kept by a given filter or
	 * not.
	 * 
	 * @param trace
	 *            The trace that is currently being considered by the calling
	 *            filter. Note that it can be assumed that
	 *            trace.isEmpty()==false
	 * @return true if the trace should be kept, false if the given trace should
	 *         be removed.
	 */
	public boolean keepTrace(XTrace trace);
}
"
XTraceEditor.java,log,"package org.processmining.plugins.log.logfilters;

import org.deckfour.xes.model.XTrace;

/**
 * Interface used for easy filtering of XLog object. Used by LogFilter.
 * 
 * @author bfvdonge
 * 
 */
public interface XTraceEditor {

	/**
	 * When filtering, this method is called for each XTrace in the log. The
	 * trace can be edited, or a new one can be returned. If null is returned,
	 * or an empty trace is returned, the calling filter will remove the trace
	 * from the log. No new XTrace objects should be returned.
	 * 
	 * @param trace
	 *            The trace that is currently being considered by the calling
	 *            filter. Note that it can be assumed that
	 *            trace.isEmpty()==false
	 * @return The edited trace. If null, or an empty trace is returned, then
	 *         the trace is removed. No new trace objects should be returned.
	 */
	public XTrace editTrace(XTrace trace);

}
"
EventLogArray.java,log,"package org.processmining.log.models;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;

import org.deckfour.xes.model.XLog;
import org.deckfour.xes.out.XSerializer;
import org.processmining.framework.annotations.AuthoredType;
import org.processmining.framework.annotations.Icon;
import org.processmining.framework.plugin.PluginContext;

@AuthoredType(typeName = ""Event log array"", affiliation = AuthoredType.TUE, author = ""H.M.W. Verbeek"", email = ""h.m.w.verbeek@tue.nl"")
@Icon(icon = ""resourcetype_ela_30x35.png"")
public interface EventLogArray {

	/**
	 * Initializes the event log array.
	 */
	void init();

	/**
	 * Adds the given log to the array.
	 * 
	 * @param log
	 *            The given log.
	 * @return The index of the added log in the array.
	 */
	int addLog(XLog log);

	/**
	 * Removes the first occurrence of the given log from the array,
	 * 
	 * @param log
	 *            The given log.
	 * @return The index of the removed log, if present. -1 if not present.
	 */
	int removeLog(XLog log);

	/**
	 * Adds the given log at the given index to the array.
	 * 
	 * @param index
	 *            The given index.
	 * @param log
	 *            The given log.
	 */
	void addLog(int index, XLog log);

	/**
	 * Removes the log from the given index.
	 * 
	 * @param index
	 *            The given index.
	 */
	void removeLog(int index);

	/**
	 * Returns the log at the given index.
	 * 
	 * @param index The given index.
	 * @return The log at the given index, if valid. null if not valid.
	 */
	XLog getLog(int index);
	
	int getSize();
	
	public void importFromStream(PluginContext context, InputStream input, String parent) throws Exception;
	public void exportToFile(PluginContext context, File file, XSerializer logSerializer) throws IOException;
}
"
EventLogArrayFactory.java,log,"package org.processmining.log.models.impl;

import org.processmining.log.models.EventLogArray;

public class EventLogArrayFactory {

	public static EventLogArray createEventLogArray() {
		return new EventLogArrayImpl();
	}
	
}
"
EventLogArrayImpl.java,log,"package org.processmining.log.models.impl;

import java.io.File;
import java.io.FileOutputStream;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStream;
import java.io.Writer;

import org.deckfour.xes.model.XLog;
import org.deckfour.xes.out.XSerializer;
import org.deckfour.xes.out.XesXmlSerializer;
import org.processmining.basicutils.models.impl.ObjectArrayImpl;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.log.models.EventLogArray;
import org.processmining.plugins.log.OpenLogFilePlugin;

import com.csvreader.CsvWriter;

public class EventLogArrayImpl extends ObjectArrayImpl<XLog> implements EventLogArray {

	@Deprecated 
	public int addLog(XLog log) {
		return addElement(log);
	}

	@Deprecated
	public int removeLog(XLog log) {
		return removeElement(log);
	}

	@Deprecated
	public void addLog(int index, XLog log) {
		addElement(log);
	}

	@Deprecated
	public void removeLog(int index) {
		removeElement(index);
	}

	@Deprecated
	public XLog getLog(int index) {
		return getElement(index);
	}

	public void importFromStream(PluginContext context, InputStream input, String parent) throws Exception {
		importFromStream(context, input, parent, new OpenLogFilePlugin());
	}

	public void exportToFile(PluginContext context, File file, XSerializer logSerializer) throws IOException {
		Writer fileWriter = new FileWriter(file);
		CsvWriter csvWriter = new CsvWriter(fileWriter, ',');
		int n = 1;
		for (XLog log: list) {
			String fileName = file.getName();
			File dir = file.getParentFile();
			String prefix = fileName.substring(0, fileName.indexOf("".""));
			File netFile = File.createTempFile(prefix + ""."" + n + ""."", ""."" + logSerializer.getSuffices()[0], dir);
			csvWriter.write(netFile.getName());
			csvWriter.endRecord();
			System.out.println(""Exporting Accepting Petri Net to "" + netFile.getName());
			FileOutputStream out = new FileOutputStream(netFile);
			logSerializer.serialize(log, out);
			out.close();
			n++;
		}
		csvWriter.close();
	}

	public void exportToFile(PluginContext context, File file) throws Exception {
		exportToFile(context, file, new XesXmlSerializer());
	}


}
"
LogFrequencyArrayImpl.java,log,"package org.processmining.log.models.impl;

import org.deckfour.xes.extension.std.XConceptExtension;
import org.processmining.log.models.EventLogArray;
import org.processmining.log.models.LogFrequency;
import org.processmining.log.models.LogFrequencyArray;

public class LogFrequencyArrayImpl implements LogFrequencyArray {

	private String label;
	private LogFrequency[] subFrequencies;
	private int index;
	private int factor;
	private int buckets = 20;

	public LogFrequencyArrayImpl(EventLogArray logs) {
		label = null;
		if (logs.getSize() > 0) {
			label = XConceptExtension.instance().extractName(logs.getLog(0));
		}
		if (label == null) {
			label = ""<Not specified>"";
		}
		factor = (logs.getLog(0).size() / buckets) + (logs.getLog(0).size() % buckets > 0 ? 1 : 0);
		subFrequencies = new LogFrequency[logs.getSize()];
		for (int i = 0; i < logs.getSize(); i++) {
			subFrequencies[i] = LogFrequencyFactory.createLogFrequency(logs.getLog(i));
		}
		index = -1;
	}

	public String toHTMLString(boolean includeHTMLTags) {
		StringBuffer buf = new StringBuffer();
		if (includeHTMLTags) {
			buf.append(""<html>"");
		}
		buf.append(""<h1>"");
		buf.append(label);
		buf.append(""</h1>"");
		buf.append(""<table>"");
		buf.append(""<tr><th>Frequency</th>"");
		for (int i = 0; i < subFrequencies.length ; i++) {
			buf.append(""<th>Log "" + (i + 1) + ""</th>"");
			
		}
		buf.append(""</tr>"");
		for (int i = 0; i < buckets; i++) {
			buf.append(""<tr><th>"");
			buf.append(i * factor + 1);
			buf.append(""</th>"");
			for (int j = 0; j < subFrequencies.length ; j++) {
				buf.append(""<td>"" + subFrequencies[j].get(i * factor + 1) + ""</td>"");
			}
			buf.append(""</tr>"");
		}
		buf.append(""</table>"");
		if (includeHTMLTags) {
			buf.append(""</html>"");
		}
		return buf.toString();
	}

	public void set(int index) {
		this.index = index;
	}

	public void add(int frequency) {
		subFrequencies[index].add(frequency);
	}

	public int get(int frequency) {
		// TODO Auto-generated method stub
		return subFrequencies[index].get(frequency);
	}
}
"
LogFrequencyFactory.java,log,"package org.processmining.log.models.impl;

import org.deckfour.xes.model.XLog;
import org.processmining.log.models.EventLogArray;
import org.processmining.log.models.LogFrequency;
import org.processmining.log.models.LogFrequencyArray;


public class LogFrequencyFactory {

	public static LogFrequency createLogFrequency(XLog log) {
		return new LogFrequencyImpl(log);
	}

	public static LogFrequencyArray createLogFrequencyArray(EventLogArray logs) {
		return new LogFrequencyArrayImpl(logs);
	}
}
"
LogFrequencyImpl.java,log,"package org.processmining.log.models.impl;

import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.model.XLog;
import org.processmining.log.models.LogFrequency;

public class LogFrequencyImpl implements LogFrequency {

	private String label;
	private int[] frequencies;
	private int factor;
	private int buckets = 20;
	
	public LogFrequencyImpl(XLog log) {
		label = XConceptExtension.instance().extractName(log);
		if (label == null) {
			label = ""<Not specified>"";
		}
		factor = (log.size() / buckets) + (log.size() % buckets > 0 ? 1 : 0);
		frequencies = new int[buckets];
		for (int i = 0; i < buckets; i++) {
			frequencies[i] = 0;
		}
	}
	
	public String toHTMLString(boolean includeHTMLTags) {
		StringBuffer buf = new StringBuffer();
		if (includeHTMLTags) {
			buf.append(""<html>"");
		}
		buf.append(""<h1>"");
		buf.append(label);
		buf.append(""</h1>"");
		buf.append(""<table>"");
		buf.append(""<tr><th>Frequency</th><th>Log</th></tr>"");
		for (int i = 0 ; i < buckets ; i++) {
			buf.append(""<tr><th>"");
			buf.append(i * factor + 1);
			buf.append(""</th><td>"");
			buf.append(frequencies[i]);
			buf.append(""</td></tr>"");
		}
		buf.append(""</table>"");
		if (includeHTMLTags) {
			buf.append(""</html>"");
		}
		return buf.toString();
	}

	public void add(int frequency) {
		frequencies[(frequency - 1) / factor] += frequency;
	}

	public int get(int frequency) {
		return frequencies[(frequency - 1) / factor];
	}
}
"
XEventClassifierListImpl.java,log,"package org.processmining.log.models.impl;

import java.util.ArrayList;

import org.deckfour.xes.classification.XEventClassifier;
import org.processmining.log.models.XEventClassifierList;

public class XEventClassifierListImpl extends ArrayList<XEventClassifier> implements XEventClassifierList {

	/**
	 * 
	 */
	private static final long serialVersionUID = 2050835582426869158L;

}
"
LogCentrality.java,log,"package org.processmining.log.models;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.deckfour.xes.classification.XEventClassifier;
import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.log.parameters.LogCentralityFilterParameters;
import org.processmining.log.parameters.LogCentralityParameters;

public class LogCentrality {

	private XLog log;
	private XEventClassifier classifier;
	private Map<List<String>, Double> centralityMap;
	private List<Double> centralities;
	private Map<Set<List<String>>, Integer> cache;

	public LogCentrality(XLog log) {
		this.log = log;
		this.classifier = null;
		this.cache = null;
	}

	public XLog getLog() {
		return log;
	}
	
	public XEventClassifier getClassifier() {
		return classifier;
	}
	
	public List<Double> getCentralities() {
		return centralities;
	}
	
	public void setClassifier(PluginContext context, LogCentralityParameters parameters) {
		if (context != null) {
			context.getProgress().setValue(0);
		}
		if (this.classifier == null || !this.classifier.equals(parameters.getClassifier())) {
			this.classifier = parameters.getClassifier();
			this.centralityMap = new HashMap<List<String>, Double>();
			this.centralities = new ArrayList<Double>();
			this.cache = new HashMap<Set<List<String>>, Integer>();

			for (XTrace trace : log) {
				List<String> traceId = getTraceId(trace, classifier);
				if (!centralityMap.containsKey(traceId)) {
					centralityMap.put(traceId, getTraceCentrality(trace, log, classifier));
				}
				centralities.add(centralityMap.get(traceId));
				if (context != null) {
					context.getProgress().inc();
				}
			}
			Collections.sort(centralities);
			this.cache = null;
		}
	}

	public int size() {
		return log.size();
	}
	
	public XLog filter(PluginContext context, LogCentralityFilterParameters parameters) {
		XLog log = (XLog) this.log.clone();
		int index = (parameters.getPercentage() * centralities.size()) / 100;
		if (index >= centralities.size()) {
			index = centralities.size() - 1;
		}
		Double threshold = centralities.get(index);
		Set<XTrace> removedTraces = new HashSet<XTrace>();
		for (XTrace trace : log) {
			if (parameters.isFilterIn() == (centralityMap.get(getTraceId(trace, classifier)) > threshold)) {
				removedTraces.add(trace);
			}
			if (context != null) {
				context.getProgress().inc();
			}
		}
		for (XTrace trace : removedTraces) {
			log.remove(trace);
		}
		return log;
	}

	private List<String> getTraceId(XTrace trace, XEventClassifier classifier) {
		List<String> traceId = new ArrayList<String>();
		for (XEvent event : trace) {
			traceId.add(classifier.getClassIdentity(event));
		}
		return traceId;
	}

	private double getTraceCentrality(XTrace trace, XLog log, XEventClassifier classifier) {
		int totalSquareDistance = 0;
		for (XTrace otherTrace : log) {
			int distance = getTraceDistance(trace, otherTrace, classifier);
			totalSquareDistance += (distance * distance);
		}
		return Math.sqrt(totalSquareDistance);
	}

	private int getTraceDistance(XTrace trace1, XTrace trace2, XEventClassifier classifier) {
		List<String> activities1 = new ArrayList<String>();
		List<String> activities2 = new ArrayList<String>();
		for (XEvent event : trace1) {
			activities1.add(classifier.getClassIdentity(event));
		}
		for (XEvent event : trace2) {
			activities2.add(classifier.getClassIdentity(event));
		}
		return getTraceDistance(activities1, activities2, 0, 0);
	}

	private int getTraceDistance(List<String> activities1, List<String> activities2, int index1, int index2) {
		int distance = 0;
		if (index1 >= activities1.size()) {
			distance = activities2.size() - index2;
		} else if (index2 >= activities2.size()) {
			distance = activities1.size() - index1;
		} else {
			Set<List<String>> activities = new HashSet<List<String>>();
			activities.add(activities1);
			activities.add(activities2);
			if (cache.containsKey(activities)) {
				distance = cache.get(activities);
			} else {
				if (activities1.get(index1).equals(activities2.get(index2))) {
					distance = getTraceDistance(activities1, activities2, index1 + 1, index2 + 1);
				} else {
					int distance1 = 1 + getTraceDistance(activities1, activities2, index1 + 1, index2);
					int distance2 = 1 + getTraceDistance(activities1, activities2, index1, index2 + 1);
					if (distance1 < distance2) {
						distance = distance1;
					} else {
						distance = distance2;
					}
				}
				cache.put(activities, distance);
			}
		}
		return distance;
	}
}
"
LogCheckerReport.java,log,"package org.processmining.log.models;

import org.processmining.framework.util.HTMLToString;

public class LogCheckerReport implements HTMLToString {

	private String report;
	
	public LogCheckerReport() {
		report = """";
	}
	
	public void add(String message) {
		report += message;
	}
	
	public String toHTMLString(boolean includeHTMLTags) {
		return includeHTMLTags ? ""<html>"" + report + ""</html>"" : report;
	}

}
"
LogFrequency.java,log,"package org.processmining.log.models;

import org.processmining.framework.util.HTMLToString;

public interface LogFrequency extends HTMLToString {

	public void add(int frequency);

	public int get(int index);
}
"
LogFrequencyArray.java,log,"package org.processmining.log.models;

public interface LogFrequencyArray extends LogFrequency {

	public void set(int i);
	
}
"
XEventClassifierList.java,log,"package org.processmining.log.models;

import java.util.List;

import org.deckfour.xes.classification.XEventClassifier;

public interface XEventClassifierList extends List<XEventClassifier> {

}
"
OpenBufferedLogFilePlugin.java,log,"package org.processmining.plugins.log;

import java.io.InputStream;

import org.deckfour.xes.factory.XFactoryBufferedImpl;
import org.processmining.framework.plugin.PluginContext;

//@Plugin(name = ""Open XES Log File (Buffered)"", parameterLabels = { ""Filename"" }, returnLabels = { ""Log (single process)"" }, returnTypes = { XLog.class })
//@UIImportPlugin(description = ""ProM log files (Buffered)"", extensions = { ""mxml"", ""xml"", ""gz"", ""zip"", ""xes"", ""xez"" })
public class OpenBufferedLogFilePlugin extends OpenLogFilePlugin {
	protected Object importFromStream(PluginContext context, InputStream input, String filename, long fileSizeInBytes)
	throws Exception {
		return importFromStream(context, input, filename, fileSizeInBytes, new XFactoryBufferedImpl());
	}
}
"
OpenLogFilePlugin.java,log,"package org.processmining.plugins.log;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.InputStream;
import java.security.InvalidParameterException;
import java.util.Collection;
import java.util.Enumeration;
import java.util.zip.GZIPInputStream;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;

import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.factory.XFactory;
import org.deckfour.xes.factory.XFactoryRegistry;
import org.deckfour.xes.in.XMxmlParser;
import org.deckfour.xes.in.XParser;
import org.deckfour.xes.in.XesXmlParser;
import org.deckfour.xes.model.XLog;
import org.processmining.framework.abstractplugins.AbstractImportPlugin;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;

@Plugin(name = ""Open XES Log File"", parameterLabels = { ""Filename"" }, returnLabels = {
		""Log (single process)"" }, returnTypes = { XLog.class })
//@UIImportPlugin(description = ""ProM log files"", extensions = { ""mxml"", ""xml"", ""gz"", ""zip"", ""xes"", ""xez"" })
public class OpenLogFilePlugin extends AbstractImportPlugin {

	/**
	 * Holds zip file, if zip file is open.
	 */
	private ZipFile zipFile;
	/**
	 * Holds the name of the zipped file, if input is zip file.
	 */
	private String zipName;

	public OpenLogFilePlugin() {
		zipFile = null;
		zipName = null;
	}

	protected Object importFromStream(PluginContext context, InputStream input, String filename, long fileSizeInBytes,
			XFactory factory) throws Exception {
		context.getFutureResult(0).setLabel(filename);
		//	System.out.println(""Open file"");
		XParser parser;
		if (zipName != null) {
			/*
			 * Stream contains a zip file. Use the name of the zipped file, not
			 * of the zip file itself.
			 */
			filename = zipName;
		}
		/*
		 * Only use MXML parser if the file has th eproper extesnion. 
		 * In all other cases, use the XES parser.
		 */
		if (filename.toLowerCase().endsWith("".mxml"") || filename.toLowerCase().endsWith("".mxml.gz"")) {
			parser = new XMxmlParser(factory);
		} else {
			parser = new XesXmlParser(factory);
		}
		Collection<XLog> logs = null;
		Exception firstException = null;
		String errorMessage = """";
		try {
			logs = parser.parse(new XContextMonitoredInputStream(input, fileSizeInBytes, context.getProgress()));
		} catch (Exception e) {
			logs = null;
			firstException = e;
			errorMessage = errorMessage + e;
		}
//		if (logs == null || logs.isEmpty()) {
//			// try any other parser
//			for (XParser p : XParserRegistry.instance().getAvailable()) {
//				if (p == parser) {
//					continue;
//				}
//				try {
//					logs = p.parse(new XContextMonitoredInputStream(input, fileSizeInBytes, context.getProgress()));
//					if (logs.size() > 0) {
//						break;
//					}
//				} catch (Exception e1) {
//					// ignore and move on.
//					logs = null;
//					errorMessage = errorMessage + "" ["" + p.name() + "":"" + e1 + ""]"";
//				}
//			}
//		}

		// Log file has been read from the stream. The zip file (if present) can now be closed.
		if (zipFile != null) {
			zipFile.close();
			zipFile = null;
		}

		// log sanity checks;
		// notify user if the log is awkward / does miss crucial information
		if (logs == null) {
			//			context.getFutureResult(0).cancel(false);
			throw new Exception(""Could not open log file, possible cause: ""
					/* + errorMessage, */ + firstException);
		}
		if (logs.size() == 0) {
			//			context.getFutureResult(0).cancel(false);
			throw new Exception(""No processes contained in log!"");
		}

		XLog log = logs.iterator().next();
		if (XConceptExtension.instance().extractName(log) == null) {
			/*
			 * Log name not set. Create a default log name.
			 */
			XConceptExtension.instance().assignName(log, ""Anonymous log imported from "" + filename);
		}

		//		if (log.isEmpty()) {
		//			throw new Exception(""No process instances contained in log!"");
		//		}

		/*
		 * Set the log name as the name of the provided object.
		 */
		if (context != null) {
			context.getFutureResult(0).setLabel(XConceptExtension.instance().extractName(log));
		}

		return log;

	}

	/**
	 * This method returns an inputStream for a file. Note that the default
	 * implementation returns ""new FileInputStream(file);""
	 * 
	 * @param file
	 * @return
	 * @throws FileNotFoundException
	 */
	@Override
	protected InputStream getInputStream(File file) throws Exception {
		FileInputStream stream = new FileInputStream(file);
		if (file.getName().endsWith("".gz"") || file.getName().endsWith("".xez"")) {
			return new GZIPInputStream(stream);
		}
		if (file.getName().endsWith("".zip"")) {
			// Open zip file.
			zipFile = new ZipFile(file);
			Enumeration<? extends ZipEntry> entries = zipFile.entries();
			ZipEntry zipEntry = entries.nextElement();
			if (entries.hasMoreElements()) {
				throw new InvalidParameterException(""Zipped log files should not contain more than one entry."");
			}
			/*
			 * Store the name of the zipped file. This will override the
			 * provided filename when importing.
			 */
			zipName = zipEntry.getName();
			// Return stream of only entry in zip file.
			// Do not yet close zip file, as the retruend stream still needs to be read.
			return zipFile.getInputStream(zipEntry);
		}
		return stream;
	}

	protected Object importFromStream(PluginContext context, InputStream input, String filename, long fileSizeInBytes)
			throws Exception {
		// TODO Auto-generated method stub
		return importFromStream(context, input, filename, fileSizeInBytes,
				XFactoryRegistry.instance().currentDefault());
	}

}
"
OpenNaiveLogFilePlugin.java,log,"package org.processmining.plugins.log;

import java.io.InputStream;

import org.deckfour.xes.factory.XFactoryNaiveImpl;
import org.deckfour.xes.model.XLog;
import org.processmining.contexts.uitopia.annotations.UIImportPlugin;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginLevel;

@Plugin(name = ""Open XES Log File (Naive)"", level = PluginLevel.PeerReviewed, parameterLabels = { ""Filename"" }, returnLabels = { ""Log (single process)"" }, returnTypes = { XLog.class })
@UIImportPlugin(description = ""ProM log files (Naive)"", extensions = { ""mxml"", ""xml"", ""gz"", ""zip"", ""xes"", ""xez"" })
public class OpenNaiveLogFilePlugin extends OpenLogFilePlugin {
	protected Object importFromStream(PluginContext context, InputStream input, String filename, long fileSizeInBytes)
	throws Exception {
		return importFromStream(context, input, filename, fileSizeInBytes, new XFactoryNaiveImpl());
	}
}
"
AbstractLogFilterParameters.java,log,"package org.processmining.log.parameters;

import org.deckfour.xes.classification.XEventClassifier;
import org.processmining.basicutils.parameters.impl.PluginParametersImpl;

public abstract class AbstractLogFilterParameters extends PluginParametersImpl implements LogFilterParameters {

	private XEventClassifier classifier;

	public AbstractLogFilterParameters(XEventClassifier classifier) {
		super();
		setClassifier(classifier);
	}

	public AbstractLogFilterParameters(AbstractLogFilterParameters parameters) {
		super(parameters);
		setClassifier(parameters.getClassifier());
	}

	public XEventClassifier getClassifier() {
		return classifier;
	}

	public void setClassifier(XEventClassifier classifier) {
		this.classifier = classifier;
	}

	public boolean equals(Object object) {
		if (object instanceof AbstractLogFilterParameters) {
			AbstractLogFilterParameters parameters = (AbstractLogFilterParameters) object;
			return super.equals(parameters) 
					&& getClassifier().equals(parameters.getClassifier());
		}
		return false;
	}
}
"
ClassifierParameter.java,log,"package org.processmining.log.parameters;

import org.deckfour.xes.classification.XEventClassifier;

public interface ClassifierParameter {

	public void setClassifier(XEventClassifier classifier);
	public XEventClassifier getClassifier();
}
"
HighFrequencyFilterParameters.java,log,"package org.processmining.log.parameters;

import org.deckfour.xes.model.XLog;
import org.processmining.log.utils.XUtils;

public class HighFrequencyFilterParameters extends AbstractLogFilterParameters {

	private int frequencyThreshold;

	private int distanceThreshold;

	public HighFrequencyFilterParameters(XLog log) {
		super(XUtils.getDefaultClassifier(log));
		/*
		 * Keep at least 50% of the log. This determines the set of
		 * most-occurring traces.
		 */
		setFrequencyThreshold(50);
		/*
		 * Keep a trace if its distance to a most-occurring trace is less than
		 * 3.
		 */
		setDistanceThreshold(3);
	}

	public HighFrequencyFilterParameters(HighFrequencyFilterParameters parameters) {
		super(parameters);
		setFrequencyThreshold(parameters.getFrequencyThreshold());
		setDistanceThreshold(parameters.getDistanceThreshold());
	}

	public int getFrequencyThreshold() {
		return frequencyThreshold;
	}

	public void setFrequencyThreshold(int frequencyThreshold) {
		this.frequencyThreshold = frequencyThreshold;
	}

	public int getDistanceThreshold() {
		return distanceThreshold;
	}

	public void setDistanceThreshold(int distanceThreshold) {
		this.distanceThreshold = distanceThreshold;
	}

	public boolean equals(Object object) {
		if (object instanceof HighFrequencyFilterParameters) {
			HighFrequencyFilterParameters parameters = (HighFrequencyFilterParameters) object;
			return super.equals(parameters) && 
					getFrequencyThreshold() == parameters.getFrequencyThreshold() && 
					getDistanceThreshold() == parameters.getDistanceThreshold();
		}
		return false;
	}
}
"
LogCentralityFilterParameters.java,log,"package org.processmining.log.parameters;

import org.processmining.basicutils.parameters.impl.PluginParametersImpl;
import org.processmining.log.models.LogCentrality;


public class LogCentralityFilterParameters extends PluginParametersImpl {

	private int percentage;
	private boolean filterIn;

	public LogCentralityFilterParameters(LogCentrality centrality) {
		super();
		setPercentage(80);
		setFilterIn(true);
	}

	public LogCentralityFilterParameters(LogCentralityFilterParameters parameters) {
		super(parameters);
		setPercentage(parameters.getPercentage());
		setFilterIn(parameters.isFilterIn());
	}
	
	public void setPercentage(int percentage) {
		this.percentage = percentage;
	}

	public int getPercentage() {
		return percentage;
	}

	public void setFilterIn(boolean filterIn) {
		this.filterIn = filterIn;
	}

	public boolean isFilterIn() {
		return filterIn;
	}

	public boolean equals(Object object) {
		if (object instanceof LogCentralityFilterParameters) {
			LogCentralityFilterParameters parameters = (LogCentralityFilterParameters) object;
			return super.equals(parameters) &&
					getPercentage() == parameters.getPercentage() &&
					isFilterIn() == parameters.isFilterIn();
		}
		return false;
	}

}
"
LogCentralityParameters.java,log,"package org.processmining.log.parameters;

import org.deckfour.xes.model.XLog;
import org.processmining.log.utils.XUtils;

public class LogCentralityParameters extends AbstractLogFilterParameters {

	public LogCentralityParameters(XLog log) {
		super(XUtils.getDefaultClassifier(log));
	}

	public LogCentralityParameters(LogCentralityParameters parameters) {
		super(parameters);
	}

	public boolean equals(Object object) {
		if (object instanceof LogCentralityParameters) {
			LogCentralityParameters parameters = (LogCentralityParameters) object;
			return super.equals(parameters);
		}
		return false;
	}
}
"
LogCheckerParameters.java,log,"package org.processmining.log.parameters;

import java.util.EnumSet;

import org.processmining.log.logchecks.LogCheckType;

public class LogCheckerParameters {

	private EnumSet<LogCheckType> logChecks;

	public EnumSet<LogCheckType> getLogChecks() {
		return logChecks;
	}

	public void setLogChecks(EnumSet<LogCheckType> logChecks) {
		this.logChecks = logChecks;
	}
	
}
"
LogFilterParameters.java,log,"package org.processmining.log.parameters;

import org.processmining.basicutils.parameters.PluginParameters;


public interface LogFilterParameters extends PluginParameters, ClassifierParameter {


}
"
LogFrequencyParameters.java,log,"package org.processmining.log.parameters;

import org.deckfour.xes.model.XLog;
import org.processmining.log.utils.XUtils;

public class LogFrequencyParameters extends AbstractLogFilterParameters {

	public LogFrequencyParameters(XLog log) {
		super(XUtils.getDefaultClassifier(log));
	}
	
	public LogFrequencyParameters(LogFrequencyParameters parameters) {
		super(parameters);
	}

	public boolean equals(Object object) {
		if (object instanceof LogFrequencyParameters) {
			LogFrequencyParameters parameters = (LogFrequencyParameters) object;
			return super.equals(parameters);
		}
		return false;
	}
}
"
LowFrequencyFilterParameters.java,log,"package org.processmining.log.parameters;

import org.deckfour.xes.model.XLog;
import org.processmining.log.utils.XUtils;

public class LowFrequencyFilterParameters extends AbstractLogFilterParameters {

	private int threshold;

	public LowFrequencyFilterParameters(XLog log) {
		super(XUtils.getDefaultClassifier(log));
		/*
		 * The least-occurring traces that make up at least 5% of the log will be removed.
		 */
		setThreshold(5); 
	}
	
	public LowFrequencyFilterParameters(LowFrequencyFilterParameters parameters) {
		super(parameters);
		setThreshold(parameters.getThreshold());
	}

	public int getThreshold() {
		return threshold;
	}

	public void setThreshold(int threshold) {
		this.threshold = threshold;
	}

	public boolean equals(Object object) {
		if (object instanceof LowFrequencyFilterParameters) {
			LowFrequencyFilterParameters parameters = (LowFrequencyFilterParameters) object;
			return super.equals(parameters) &&
					getThreshold() == parameters.getThreshold();
		}
		return false;
	}
}
"
LowOccurrencesFilterParameters.java,log,"package org.processmining.log.parameters;

import org.deckfour.xes.model.XLog;
import org.processmining.log.utils.XUtils;

public class LowOccurrencesFilterParameters extends AbstractLogFilterParameters {

	private int threshold;

	public LowOccurrencesFilterParameters(XLog log) {
		super(XUtils.getDefaultClassifier(log));
		/*
		 * Traces that occur at least 2 times will be retained.
		 */
		setThreshold(2);
	}
	
	public LowOccurrencesFilterParameters(LowOccurrencesFilterParameters parameters) {
		super(parameters);
		setThreshold(parameters.getThreshold());
	}
	
	public int getThreshold() {
		return threshold;
	}

	public void setThreshold(int threshold) {
		this.threshold = threshold;
	}
	
	public boolean equals(Object object) {
		if (object instanceof LowOccurrencesFilterParameters) {
			LowOccurrencesFilterParameters parameters = (LowOccurrencesFilterParameters) object;
			return super.equals(parameters) &&
					getThreshold() == parameters.getThreshold();
		}
		return false;
	}
}
"
MergeLogsParameters.java,log,"package org.processmining.log.parameters;

import java.util.Date;

public class MergeLogsParameters {

	private String traceId;
	private String dateFormat;
	private Date fromDate;
	private Date toDate;
	private Date specificDate;
	private String requiredWords;
	private String forbiddenWords;
	private int minMatches;
	private boolean maxMatch;
	private boolean multi;
	private int related;
	

	public MergeLogsParameters() {
		setTraceId(null);
		setDateFormat(""MM/dd/yyyy HH:mm"");
		setFromDate(null);
		setToDate(null);
		setSpecificDate(null);
		setRequiredWords(null);
		setForbiddenWords(null);
		setMinMatches(0);
		setMaxMatch(true);
		setMulti(false);
		setRelated(0);
	}
	
	public String getTraceId() {
		return traceId;
	}

	public void setTraceId(String id) {
		this.traceId = id;
	}

	public String getDateFormat() {
		return dateFormat;
	}

	public void setDateFormat(String dateFormat) {
		this.dateFormat = dateFormat;
	}

	public Date getFromDate() {
		return fromDate;
	}

	public void setFromDate(Date fromDate) {
		this.fromDate = fromDate;
	}

	public Date getToDate() {
		return toDate;
	}

	public void setToDate(Date toDate) {
		this.toDate = toDate;
	}

	public Date getSpecificDate() {
		return specificDate;
	}

	public void setSpecificDate(Date specificDate) {
		this.specificDate = specificDate;
	}

	public String getForbiddenWords() {
		return forbiddenWords;
	}

	public void setForbiddenWords(String remove) {
		this.forbiddenWords = remove;
	}

	public int getRelated() {
		return related;
	}

	public void setRelated(int related) {
		this.related = related;
	}

	public int getMinMatches() {
		return minMatches;
	}

	public void setMinMatches(int minMatches) {
		this.minMatches = minMatches;
	}

	public boolean isMaxMatch() {
		return maxMatch;
	}

	public void setMaxMatch(boolean maxMatch) {
		this.maxMatch = maxMatch;
	}

	public boolean isMulti() {
		return multi;
	}

	public void setMulti(boolean multi) {
		this.multi = multi;
	}

	public String getRequiredWords() {
		return requiredWords;
	}

	public void setRequiredWords(String requiredWords) {
		this.requiredWords = requiredWords;
	}
}
"
MinerParameter.java,log,"package org.processmining.log.parameters;

public interface MinerParameter {

	public void setMiner(String miner);
	public String getMiner();
}
"
SplitLogParameters.java,log,"package org.processmining.log.parameters;

import org.deckfour.xes.model.XAttribute;
import org.deckfour.xes.model.XAttributeLiteral;
import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;

public class SplitLogParameters {

	private String key;

	public SplitLogParameters(XLog log) {
		for (XTrace trace : log) {
			for (XEvent event : trace) {
				for (XAttribute attribute : event.getAttributes().values()) {
					if (attribute instanceof XAttributeLiteral) {
						setKey(attribute.getKey());
						break;
					}
				}
			}
		}
	}
	
	public String getKey() {
		return key;
	}

	public void setKey(String key) {
		this.key = key;
	}
}
"
UpdateParameter.java,log,"package org.processmining.log.parameters;

public interface UpdateParameter {

	public void update();
}
"
SaxHandlerGlobalEventAttributesParser.java,log,"package org.processmining.log.parsers;

import java.util.List;
import java.util.Vector;

import org.xml.sax.Attributes;
import org.xml.sax.SAXException;
import org.xml.sax.helpers.DefaultHandler;

public class SaxHandlerGlobalEventAttributesParser extends DefaultHandler {

	private static final String TAG = ""global"", KEY = ""key"", SCOPE = ""scope"", EVENT = ""event"";

	private final List<String> globals = new Vector<String>();

	private boolean isInGlobalEvent = false;

	@Override
	public void startElement(String uri, String local, String qName, Attributes attributes) throws SAXException {
		if (isInGlobalEvent == false) {
			if (qName.toLowerCase().equals(TAG)) {
				String scope = attributes.getValue(SCOPE);
				if (scope != null && scope.equals(EVENT)) {
					isInGlobalEvent = true;
				}
			}
		} else {
			if (qName.toLowerCase().equals(TAG))
				throw new SAXException();
			String key = attributes.getValue(KEY);
			if (key != null)
				globals.add(key);
		}
	}
	
	@Override
	public void endElement(String uri, String local, String qName) {
		if(isInGlobalEvent)
			if(qName.toLowerCase().equals(TAG))
				isInGlobalEvent = false;
	}
	
	public List<String> getGlobalEventAttributes(){
		return globals;
	}

}
"
SaxHandlerXEventClassifierParser.java,log,"package org.processmining.log.parsers;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;

import org.deckfour.xes.classification.XEventAttributeClassifier;
import org.deckfour.xes.classification.XEventClassifier;
import org.processmining.log.models.XEventClassifierList;
import org.processmining.log.models.impl.XEventClassifierListImpl;
import org.xml.sax.Attributes;
import org.xml.sax.SAXException;
import org.xml.sax.helpers.DefaultHandler;

/**
 * This parser tries to read the classifiers contained in a log, based on the
 * global event attributes. In order to find the classifiers, the elements of
 * the list of globals are checked if they are contained in the classifier
 * definition. This is done greedily based on the global´s sting length:
 * longest first. If globals are contained in the classifier definition, then we
 * return the corresponding XEventClassifier.
 * 
 * @author abolt *
 */
public class SaxHandlerXEventClassifierParser extends DefaultHandler {

	private static final String CLASSIFIER_TAG = ""classifier"", CLASSIFIER_TAG_ATTRIBUTE_NAME = ""name"",
			CLASSIFIER_TAG_ATTRIBUTEKEY = ""keys"";

	private final XEventClassifierList classifierList = new XEventClassifierListImpl();

	public XEventClassifierList getClassifierList() {
		return classifierList;
	}

	private final List<String> globalEventAttributes;
	private XEventClassifier current = null;
	private boolean insideClassifierTag = false;

	public SaxHandlerXEventClassifierParser(List<String> globalEventAttributes) {
		Collections.sort(globalEventAttributes, new Comparator<String>() {
			public int compare(String o1, String o2) {
				return o2.length() - o1.length();
			}
		});
		this.globalEventAttributes = globalEventAttributes;
	}

	@Override
	public void startElement(String uri, String local, String qName, Attributes attributes) throws SAXException {
		if (!insideClassifierTag) {
			if (qName.toLowerCase().equals(CLASSIFIER_TAG)) {
				insideClassifierTag = true;
				String name = attributes.getValue(CLASSIFIER_TAG_ATTRIBUTE_NAME) == null ? """"
						: attributes.getValue(CLASSIFIER_TAG_ATTRIBUTE_NAME);
				String keys = attributes.getValue(CLASSIFIER_TAG_ATTRIBUTEKEY) == null ? """"
						: attributes.getValue(CLASSIFIER_TAG_ATTRIBUTEKEY);
				List<String> parsedKeys = getGlobalsInClassifier(globalEventAttributes, keys);
				if (parsedKeys != null) {
					current = new XEventAttributeClassifier(name, parsedKeys.toArray(new String[parsedKeys.size()]));
				} else {
					current = null;
				}
			}
		} else {
			if (qName.toLowerCase().equals(CLASSIFIER_TAG)) {
				throw new SAXException(""Nested xml tag in classifier tag."");
			}
			// the code here is actually not described by the standard, so we  disable this for now.
			//			if (qName.toLowerCase().equals(STRING_TAG) && attributes.getValue(STRING_TAG_ATTRIBUTE_KEY) != null) {
			//				if (attributes.getValue(STRING_TAG_ATTRIBUTE_KEY).equals(CLASSIFIER_TAG_ATTRIBUTE_NAME)) {
			//					if (attributes.getValue(STRING_TAG_ATTRIBUTE_VALUE) != null) {
			//						current.setName(attributes.getValue(STRING_TAG_ATTRIBUTE_VALUE));
			//					}
			//				} else if (attributes.getValue(STRING_TAG_ATTRIBUTE_KEY).equals(CLASSIFIER_TAG_ATTRIBUTEKEY)) {
			//					if (attributes.getValue(STRING_TAG_ATTRIBUTE_VALUE) != null) {
			//						List<String> parsedKeys = getGlobalsInClassifier(globalEventAttributes,
			//								attributes.getValue(STRING_TAG_ATTRIBUTE_VALUE));
			//						current = new XEventAttributeClassifier(current.name(),
			//								parsedKeys.toArray(new String[parsedKeys.size()]));
			//					}
			//				}
			//			}
		}
	}

	@Override
	public void endElement(String uri, String local, String qName) {
		if (qName.toLowerCase().equals(CLASSIFIER_TAG)) {
			insideClassifierTag = false;
			if (current != null) {
				classifierList.add(current);
			}
		}

	}

	private List<String> getGlobalsInClassifier(List<String> globals, String keysInClassifier) {
		List<String> classifierKeys = new ArrayList<String>();
		for (String globalElement : globalEventAttributes) {
			if (keysInClassifier.contains(globalElement)) {
				classifierKeys.add(globalElement);
				// This will replace all matches, but since the list is ordered greedily, it should not replace strings used by other globals
				keysInClassifier = keysInClassifier.replace(globalElement, """");
			}
		}
		keysInClassifier = keysInClassifier.replace("" "", """");
		keysInClassifier = keysInClassifier.replace(""'"", """");
		return keysInClassifier.isEmpty() ? classifierKeys : null;
	}

}
"
ExportEventLogArrayAsCompressedMXMLPlugin.java,log,"package org.processmining.log.plugins;

import java.io.File;
import java.io.IOException;

import org.deckfour.xes.out.XMxmlGZIPSerializer;
import org.processmining.contexts.uitopia.annotations.UIExportPlugin;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.log.models.EventLogArray;

@Plugin(name = ""ELA export (Event Log Array)"", returnLabels = {}, returnTypes = {}, parameterLabels = {
		""Event Log Array (Compressed MXML)"", ""File"" }, userAccessible = true)
@UIExportPlugin(description = ""Event Log Array (Compressed MXML)"", extension = ""ela"")
public class ExportEventLogArrayAsCompressedMXMLPlugin {

	@PluginVariant(variantLabel = ""ELA export to compressed MXML files (Event Log Array)"", requiredParameterLabels = { 0, 1 })
	public void exportMxmlGz(PluginContext context, EventLogArray eventLogs, File file) throws IOException {
		eventLogs.exportToFile(context, file, new XMxmlGZIPSerializer());
	}

}
"
ExportEventLogArrayAsCompressedXESPlugin.java,log,"package org.processmining.log.plugins;

import java.io.File;
import java.io.IOException;

import org.deckfour.xes.out.XesXmlGZIPSerializer;
import org.processmining.contexts.uitopia.annotations.UIExportPlugin;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.log.models.EventLogArray;

@Plugin(name = ""ELA export (Event Log Array)"", returnLabels = {}, returnTypes = {}, parameterLabels = {
		""Event Log Array (Compressed XES)"", ""File"" }, userAccessible = true)
@UIExportPlugin(description = ""Event Log Array (Compressed XES)"", extension = ""ela"")
public class ExportEventLogArrayAsCompressedXESPlugin {

	@PluginVariant(variantLabel = ""ELA export to compressed XES files (Event Log Array)"", requiredParameterLabels = { 0, 1 })
	public void exportXes(PluginContext context, EventLogArray eventLogs, File file) throws IOException {
		eventLogs.exportToFile(context, file, new XesXmlGZIPSerializer());
	}

}
"
ExportEventLogArrayAsMXMLPlugin.java,log,"package org.processmining.log.plugins;

import java.io.File;
import java.io.IOException;

import org.deckfour.xes.out.XMxmlSerializer;
import org.processmining.contexts.uitopia.annotations.UIExportPlugin;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.log.models.EventLogArray;

@Plugin(name = ""ELA export (Event Log Array)"", returnLabels = {}, returnTypes = {}, parameterLabels = {
		""Event Log Array (MXML)"", ""File"" }, userAccessible = true)
@UIExportPlugin(description = ""Event Log Array (MXML)"", extension = ""ela"")
public class ExportEventLogArrayAsMXMLPlugin {

	@PluginVariant(variantLabel = ""ELA export to MXML files (Event Log Array)"", requiredParameterLabels = { 0, 1 })
	public void exportMxml(PluginContext context, EventLogArray eventLogs, File file) throws IOException {
		eventLogs.exportToFile(context, file, new XMxmlSerializer());
	}
}
"
ExportEventLogArrayAsXESPlugin.java,log,"package org.processmining.log.plugins;

import java.io.File;
import java.io.IOException;

import org.deckfour.xes.out.XesXmlSerializer;
import org.processmining.contexts.uitopia.annotations.UIExportPlugin;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.log.models.EventLogArray;

@Plugin(name = ""ELA export (Event Log Array)"", returnLabels = {}, returnTypes = {}, parameterLabels = {
		""Event Log Array (XES)"", ""File"" }, userAccessible = true)
@UIExportPlugin(description = ""Event Log Array (XES)"", extension = ""ela"")
public class ExportEventLogArrayAsXESPlugin {

	@PluginVariant(variantLabel = ""ELA export to XES files (Event Log Array)"", requiredParameterLabels = { 0, 1 })
	public void exportXesGz(PluginContext context, EventLogArray eventLogs, File file) throws IOException {
		eventLogs.exportToFile(context, file, new XesXmlSerializer());
	}

}
"
HighFrequencyFilterArrayPlugin.java,log,"package org.processmining.log.plugins;

import org.deckfour.uitopia.api.event.TaskListener.InteractionResult;
import org.deckfour.xes.model.XLog;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginCategory;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.log.dialogs.HighFrequencyFilterDialog;
import org.processmining.log.help.HighFrequencyFilterArrayHelp;
import org.processmining.log.models.EventLogArray;
import org.processmining.log.models.impl.EventLogArrayFactory;
import org.processmining.log.parameters.HighFrequencyFilterParameters;

@Plugin(name = ""Filter In High-Frequency Traces (Multiple Logs)"", categories = { PluginCategory.Filtering }, parameterLabels = { ""Event Logs"" }, returnLabels = { ""Filtered Logs"" }, returnTypes = { EventLogArray.class }, userAccessible = true, help = HighFrequencyFilterArrayHelp.TEXT)
public class HighFrequencyFilterArrayPlugin {

	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""Eric Verbeek"", email = ""h.m.w.verbeek@tue.nl"", website = ""www.processmining.org"", pack=""Log"")
	@PluginVariant(variantLabel = ""Filter In High-Frequency Traces (Multiple Logs), UI"", requiredParameterLabels = { 0 })
	public EventLogArray runUI(UIPluginContext context, EventLogArray logs) {
		if (logs.getSize() > 0) {
			XLog log = logs.getLog(0);
			HighFrequencyFilterParameters parameters = new HighFrequencyFilterParameters(log);
			HighFrequencyFilterDialog dialog = new HighFrequencyFilterDialog(log, parameters);
			InteractionResult result = context.showWizard(""Configure High-Frequency Filter"", true, true, dialog);
			if (result != InteractionResult.FINISHED) {
				return null;
			}
			EventLogArray filteredLogs = EventLogArrayFactory.createEventLogArray();
			filteredLogs.init();
			for (int i = 0; i < logs.getSize(); i++) {
				parameters.displayMessage(""[HighFrequencyFilterArrayPlugin] Filtering log "" + i + "" of "" + logs.getSize());
				filteredLogs.addLog((new HighFrequencyFilterPlugin()).run(context, logs.getLog(i), parameters));
			}
			return filteredLogs;
		}
		return null;
	}

	/**
	 * @deprecated Use runUI instead.
	 */
	@Deprecated
	public EventLogArray publicUIArray(UIPluginContext context, EventLogArray logs) {
		return runUI(context, logs);
	}

	@PluginVariant(variantLabel = ""Filter In High-Frequency Traces (Multiple Logs), Parameters"", requiredParameterLabels = { 0 })
	public EventLogArray run(PluginContext context, EventLogArray logs,
			HighFrequencyFilterParameters parameters) {
		if (logs.getSize() > 0) {
			EventLogArray filteredLogs = EventLogArrayFactory.createEventLogArray();
			filteredLogs.init();
			for (int i = 0; i < logs.getSize(); i++) {
				parameters.displayMessage(""[HighFrequencyFilterArrayPlugin] Filtering log "" + i + "" of "" + logs.getSize());
				filteredLogs.addLog((new HighFrequencyFilterPlugin()).run(context, logs.getLog(i), parameters));
			}
			return filteredLogs;
		}
		return null;
	}

	/**
	 * @deprecated Use run instead.
	 */
	@Deprecated
	public EventLogArray publicParameters(PluginContext context, EventLogArray logs,
			HighFrequencyFilterParameters parameters) {
		return run(context, logs, parameters);
	}
	
	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""Eric Verbeek"", email = ""h.m.w.verbeek@tue.nl"", website = ""www.processmining.org"", pack=""Log"")
	@PluginVariant(variantLabel = ""Filter In High-Frequency Traces (Multiple Logs), Default"", requiredParameterLabels = { 0 })
	public EventLogArray runDefault(PluginContext context, EventLogArray logs) {
		if (logs.getSize() > 0) {
			HighFrequencyFilterParameters parameters = new HighFrequencyFilterParameters(logs.getLog(0));
			EventLogArray filteredLogs = EventLogArrayFactory.createEventLogArray();
			filteredLogs.init();
			for (int i = 0; i < logs.getSize(); i++) {
				parameters.displayMessage(""[HighFrequencyFilterArrayPlugin] Filtering log "" + i + "" of "" + logs.getSize());
				filteredLogs.addLog((new HighFrequencyFilterPlugin()).run(context, logs.getLog(i), parameters));
			}
			return filteredLogs;
		}
		return null;
	}

	/**
	 * @deprecated Use runDefault instead.
	 */
	@Deprecated
	public EventLogArray publicDefault(PluginContext context, EventLogArray logs) {
		return runDefault(context, logs);
	}
}
"
HighFrequencyFilterPlugin.java,log,"package org.processmining.log.plugins;

import java.util.Collection;

import org.deckfour.uitopia.api.event.TaskListener.InteractionResult;
import org.deckfour.xes.model.XLog;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.connections.ConnectionCannotBeObtained;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginCategory;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.log.algorithms.HighFrequencyFilterAlgorithm;
import org.processmining.log.connections.HighFrequencyFilterConnection;
import org.processmining.log.dialogs.HighFrequencyFilterDialog;
import org.processmining.log.help.HighFrequencyFilterHelp;
import org.processmining.log.parameters.HighFrequencyFilterParameters;

@Plugin(name = ""Filter In High-Frequency Traces (Single Log)"", categories = { PluginCategory.Filtering }, parameterLabels = { ""Event Log"" }, returnLabels = { ""Filtered Log"" }, returnTypes = { XLog.class }, userAccessible = true, help = HighFrequencyFilterHelp.TEXT)
public class HighFrequencyFilterPlugin {

	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""Eric Verbeek"", email = ""h.m.w.verbeek@tue.nl"", website = ""www.processmining.org"", pack=""Log"")
	@PluginVariant(variantLabel = ""Filter In High-Frequency Traces (Single Log), UI"", requiredParameterLabels = { 0 })
	public XLog runUI(UIPluginContext context, XLog log) {
		HighFrequencyFilterParameters parameters = new HighFrequencyFilterParameters(log);
		HighFrequencyFilterDialog dialog = new HighFrequencyFilterDialog(log, parameters);
		InteractionResult result = context.showWizard(""Configure High-Frequency Filter"", true, true, dialog);
		if (result != InteractionResult.FINISHED) {
			return null;
		}
		return runConnections(context, log, parameters);
	}

	/**
	 * @deprecated Use runUI() instead.
	 */
	@Deprecated
	public XLog publicUI(UIPluginContext context, XLog log) {
		return runUI(context, log);
	}

	@PluginVariant(variantLabel = ""Filter In High-Frequency Traces (Single Log), Parameters"", requiredParameterLabels = { 0 })
	public XLog run(PluginContext context, XLog log, HighFrequencyFilterParameters parameters) {
		return runConnections(context, log, parameters);
	}

	/**
	 * @deprecated Use run() instead.
	 */
	@Deprecated
	public XLog publicParameters(PluginContext context, XLog log, HighFrequencyFilterParameters parameters) {
		return run(context, log, parameters);
	}

	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""Eric Verbeek"", email = ""h.m.w.verbeek@tue.nl"", website = ""www.processmining.org"", pack=""Log"")
	@PluginVariant(variantLabel = ""Filter In High-Frequency Traces (Single Log), Default"", requiredParameterLabels = { 0 })
	public XLog runDefault(PluginContext context, XLog log) {
		HighFrequencyFilterParameters parameters = new HighFrequencyFilterParameters(log);
		return runConnections(context, log, parameters);
	}

	/**
	 * @deprecated Use runDefault() instead.
	 */
	@Deprecated
	public XLog publicDefault(PluginContext context, XLog log) {
		return runDefault(context, log);
	}

	private XLog runConnections(PluginContext context, XLog log, HighFrequencyFilterParameters parameters) {
		if (parameters.isTryConnections()) {
			Collection<HighFrequencyFilterConnection> connections;
			try {
				connections = context.getConnectionManager().getConnections(HighFrequencyFilterConnection.class,
						context, log);
				for (HighFrequencyFilterConnection connection : connections) {
					if (connection.getObjectWithRole(HighFrequencyFilterConnection.LOG).equals(log)
							&& connection.getParameters().equals(parameters)) {
						return connection.getObjectWithRole(HighFrequencyFilterConnection.FILTEREDLOG);
					}
				}
			} catch (ConnectionCannotBeObtained e) {
			}
		}
		XLog filteredLog = (new HighFrequencyFilterAlgorithm()).apply(context, log, parameters);
		if (parameters.isTryConnections()) {
			context.getConnectionManager().addConnection(
					new HighFrequencyFilterConnection(log, filteredLog, parameters));
		}
		return filteredLog;
	}
}
"
ImportEventLogArrayPlugin.java,log,"package org.processmining.log.plugins;

import java.io.File;
import java.io.InputStream;

import javax.swing.filechooser.FileFilter;
import javax.swing.filechooser.FileNameExtensionFilter;

import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.model.XLog;
import org.processmining.contexts.uitopia.annotations.UIImportPlugin;
import org.processmining.framework.abstractplugins.AbstractImportPlugin;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.log.models.EventLogArray;
import org.processmining.log.models.impl.EventLogArrayFactory;

@Plugin(name = ""Import Event Log Array from ELA file"", parameterLabels = { ""Filename"" }, returnLabels = { ""Event Log Array"" }, returnTypes = { EventLogArray.class })
@UIImportPlugin(description = ""ELA Event Log Array files"", extensions = { ""ela"" })
public class ImportEventLogArrayPlugin extends AbstractImportPlugin {

	protected FileFilter getFileFilter() {
		return new FileNameExtensionFilter(""ELA files"", ""ela"");
	}

	protected Object importFromStream(PluginContext context, InputStream input, String filename, long fileSizeInBytes)
			throws Exception {
		EventLogArray logs = EventLogArrayFactory.createEventLogArray();
		File file = getFile();
		String parent = (file == null ? null : file.getParent());
		logs.importFromStream(context, input, parent);
		setLabel(context, logs, filename);
		return logs;
	}

	/*
	 * Sets a proper default name for the event log array.
	 */
	private void setLabel(PluginContext context, EventLogArray logs, String filename) {
		String prefix = null;
		String postfix = null;
		boolean allSame = true;
		for (int i = 0; i < logs.getSize(); i++) {
			XLog log = logs.getLog(i);
			String name = XConceptExtension.instance().extractName(log);
			if (name != null) {
				if (prefix == null) {
					prefix = name;
				} else {
					if (!name.equals(prefix)) {
						allSame = false;
						prefix = greatestCommonPrefix(prefix, name);
					}
				}
				if (postfix == null) {
					postfix = name;
				} else {
					if (!name.equals(postfix)) {
						allSame = false;
						postfix = new StringBuilder(greatestCommonPrefix(
								new StringBuilder(prefix).reverse().toString(), new StringBuilder(name).reverse()
										.toString())).reverse().toString();
					}
				}
			}
		}
		if ((prefix != null && prefix.length() > 0) || (postfix != null && postfix.length() > 0)) {
			StringBuffer buf = new StringBuffer();
			if (prefix != null) {
				buf.append(prefix);
			}
			if (!allSame) {
				buf.append("" ... "");
				if (postfix != null) {
					buf.append(postfix);
				}
			}
			context.getFutureResult(0).setLabel(buf.toString());
		} else {
			context.getFutureResult(0).setLabel(""Event log array from file '"" + filename + ""'"");
		}
	}

	private String greatestCommonPrefix(String a, String b) {
		int minLength = Math.min(a.length(), b.length());
		for (int i = 0; i < minLength; i++) {
			if (a.charAt(i) != b.charAt(i)) {
				return a.substring(0, i);
			}
		}
		return a.substring(0, minLength);
	}
}
"
ImportXEventClassifierListPlugin.java,log,"package org.processmining.log.plugins;

import java.io.InputStream;

import javax.xml.parsers.SAXParser;
import javax.xml.parsers.SAXParserFactory;

import org.processmining.contexts.uitopia.annotations.UIImportPlugin;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.log.models.XEventClassifierList;
import org.processmining.log.parsers.SaxHandlerGlobalEventAttributesParser;
import org.processmining.log.parsers.SaxHandlerXEventClassifierParser;
import org.processmining.plugins.log.OpenLogFilePlugin;

@Plugin(name = ""Import XEvent Classifiers list form event log"", parameterLabels = { ""Filename"" }, returnLabels = {
		""XEventClassifier List"" }, returnTypes = {
				XEventClassifierList.class }, help = ""This plugin performs a lightweight read of the XLog and retrieves the available XEventClassifiers as a list. This plugins is mainly used by RapidProM"")
@UIImportPlugin(description = ""Import XEvent Classifiers list form event log"", extensions = { ""xes"", ""zip"", ""gz"" })
public class ImportXEventClassifierListPlugin extends OpenLogFilePlugin {
	protected XEventClassifierList importFromStream(PluginContext context, InputStream input, String filename,
			long fileSizeInBytes) throws Exception {
		SAXParserFactory saxFactory = SAXParserFactory.newInstance();
		try {
			saxFactory.setValidating(false);
			saxFactory.setNamespaceAware(false);
			saxFactory.setSchema(null);
		} catch (UnsupportedOperationException e) {

		}
		InputStream is = getInputStream(getFile());
		SAXParser globalsParser = saxFactory.newSAXParser();
		SaxHandlerGlobalEventAttributesParser globalsHandler = new SaxHandlerGlobalEventAttributesParser();
		globalsParser.parse(is, globalsHandler);
		is.close();

		is = getInputStream(getFile());
		SAXParser classifiersParser = saxFactory.newSAXParser();
		SaxHandlerXEventClassifierParser classifiersHandler = new SaxHandlerXEventClassifierParser(
				globalsHandler.getGlobalEventAttributes());
		classifiersParser.parse(is, classifiersHandler);
		is.close();

		return classifiersHandler.getClassifierList();
	}
}
"
LogCentralityFilterPlugin.java,log,"package org.processmining.log.plugins;

import java.util.Collection;

import org.deckfour.uitopia.api.event.TaskListener.InteractionResult;
import org.deckfour.xes.model.XLog;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.connections.ConnectionCannotBeObtained;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginCategory;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.log.algorithms.LogCentralityFilterAlgorithm;
import org.processmining.log.connections.LogCentralityFilterConnection;
import org.processmining.log.dialogs.LogCentralityFilterDialog;
import org.processmining.log.help.LogCentralityFilterHelp;
import org.processmining.log.models.LogCentrality;
import org.processmining.log.parameters.LogCentralityFilterParameters;

@Plugin(name = ""Happify Log"", categories = { PluginCategory.Filtering }, parameterLabels = { ""Happifiable Log"", ""Parameters"" }, returnLabels = { ""Happified Log"" }, returnTypes = { XLog.class }, help = LogCentralityFilterHelp.TEXT)
public class LogCentralityFilterPlugin extends LogCentralityFilterAlgorithm {

	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""H.M.W. Verbeek"", email = ""h.m.w.verbeek@tue.nl"", pack=""Log"")
	@PluginVariant(variantLabel = ""Happify Log, UI"", requiredParameterLabels = { 0 })
	public XLog runDialog(UIPluginContext context, LogCentrality centrality) {
		LogCentralityFilterParameters parameters = new LogCentralityFilterParameters(centrality);
		LogCentralityFilterDialog dialog = new LogCentralityFilterDialog(context, centrality, parameters);
		InteractionResult result = context.showWizard(""Configure Happification of Log"", true, true, dialog);
		if (result != InteractionResult.FINISHED) {
			return null;
		}
		return runConnections(context, centrality, parameters);
	}
	
	@PluginVariant(variantLabel = ""Happify Log, Parameters"", requiredParameterLabels = { 0, 1 })
	public XLog runParameters(PluginContext context, LogCentrality centrality, LogCentralityFilterParameters parameters) {
		return runConnections(context, centrality, parameters);
	}
	
	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""H.M.W. Verbeek"", email = ""h.m.w.verbeek@tue.nl"", pack=""Log"")
	@PluginVariant(variantLabel = ""Happify Log, Default"", requiredParameterLabels = { 0 })
	public XLog runDefault(PluginContext context, LogCentrality centrality) {
		LogCentralityFilterParameters parameters = new LogCentralityFilterParameters(centrality);
		return runConnections(context, centrality, parameters);
	}
	
	private XLog runConnections(PluginContext context, LogCentrality centrality, LogCentralityFilterParameters parameters) {
		if (parameters.isTryConnections()) {
			Collection<LogCentralityFilterConnection> connections;
			try {
				connections = context.getConnectionManager().getConnections(
						LogCentralityFilterConnection.class, context, centrality);
				for (LogCentralityFilterConnection connection : connections) {
					if (connection.getObjectWithRole(LogCentralityFilterConnection.LOGCENTRALITY)
							.equals(centrality) && connection.getParameters().equals(parameters)) {
						return connection
								.getObjectWithRole(LogCentralityFilterConnection.LOG);
					}
				}
			} catch (ConnectionCannotBeObtained e) {
			}
		}
		XLog filteredLog = apply(context, centrality, parameters);
		if (parameters.isTryConnections()) {
			context.getConnectionManager().addConnection(
					new LogCentralityFilterConnection(filteredLog, centrality, parameters));
		}
		return filteredLog;
	}
}
"
LogCentralityPlugin.java,log,"package org.processmining.log.plugins;

import java.util.Collection;

import org.deckfour.uitopia.api.event.TaskListener.InteractionResult;
import org.deckfour.xes.model.XLog;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.connections.ConnectionCannotBeObtained;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginCategory;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.log.algorithms.LogCentralityAlgorithm;
import org.processmining.log.connections.LogCentralityConnection;
import org.processmining.log.dialogs.LogCentralityDialog;
import org.processmining.log.help.LogCentralityHelp;
import org.processmining.log.models.LogCentrality;
import org.processmining.log.parameters.LogCentralityParameters;

@Plugin(name = ""Create Happifiable Log"", categories = { PluginCategory.Enhancement }, parameterLabels = { ""Event Log"", ""Parameters"" }, returnLabels = { ""Happifiable Log"" }, returnTypes = { LogCentrality.class }, help = LogCentralityHelp.TEXT)
public class LogCentralityPlugin extends LogCentralityAlgorithm {

	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""H.M.W. Verbeek"", email = ""h.m.w.verbeek@tue.nl"", pack=""Log"")
	@PluginVariant(variantLabel = ""Create Happifiable Log, UI"", requiredParameterLabels = { 0 })
	public LogCentrality runUI(UIPluginContext context, XLog log) {
		LogCentralityParameters parameters = new LogCentralityParameters(log);
		LogCentrality centrality = new LogCentrality(log);
		LogCentralityDialog dialog = new LogCentralityDialog(context, log, centrality, parameters);
		InteractionResult result = context.showWizard(""Configure Creation of Happifiable Log"", true, true, dialog);
		if (result != InteractionResult.FINISHED) {
			return null;
		}
		return runConnections(context, log, centrality, parameters);
	}
	
	/**
	 * @deprecated Use runUI() instead.
	 */
	@Deprecated
	public LogCentrality runDialog(UIPluginContext context, XLog log) {
		return runUI(context, log);
	}
	
	@PluginVariant(variantLabel = ""Create Happifiable Log, Parameters"", requiredParameterLabels = { 0, 1 })
	public LogCentrality run(PluginContext context, XLog log, LogCentralityParameters parameters) {
		LogCentrality centrality = new LogCentrality(log);
		return runConnections(context, log, centrality, parameters);
	}
	
	/**
	 * @deprecated Use runUI() instead.
	 */
	@Deprecated
	public LogCentrality runParameters(PluginContext context, XLog log, LogCentralityParameters parameters) {
		return run(context, log, parameters);
	}
	
	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""H.M.W. Verbeek"", email = ""h.m.w.verbeek@tue.nl"", pack=""Log"")
	@PluginVariant(variantLabel = ""Create Happifiable Log, Default"", requiredParameterLabels = { 0 })
	public LogCentrality runDefault(PluginContext context, XLog log) {
		LogCentralityParameters parameters = new LogCentralityParameters(log);
		LogCentrality centrality = new LogCentrality(log);
		return runConnections(context, log, centrality, parameters);
	}
	
	private LogCentrality runConnections(PluginContext context, XLog log, LogCentrality centrality, LogCentralityParameters parameters) {
		if (parameters.isTryConnections()) {
			Collection<LogCentralityConnection> connections;
			try {
				connections = context.getConnectionManager().getConnections(
						LogCentralityConnection.class, context, log);
				for (LogCentralityConnection connection : connections) {
					if (connection.getObjectWithRole(LogCentralityConnection.LOG)
							.equals(log) && connection.getParameters().equals(parameters)) {
						return connection
								.getObjectWithRole(LogCentralityConnection.LOGCENTRALITY);
					}
				}
			} catch (ConnectionCannotBeObtained e) {
			}
		}
		LogCentrality logCentrality = apply(context, log, centrality, parameters);
		if (parameters.isTryConnections()) {
			context.getConnectionManager().addConnection(
					new LogCentralityConnection(log, logCentrality, parameters));
		}
		return logCentrality;
	}
}
"
LogCentralityVisualizerPlugin.java,log,"package org.processmining.log.plugins;

import javax.swing.JComponent;

import org.deckfour.xes.info.XLogInfo;
import org.deckfour.xes.info.XLogInfoFactory;
import org.processmining.contexts.uitopia.annotations.Visualizer;
import org.processmining.framework.connections.ConnectionCannotBeObtained;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.log.algorithms.LogCentralityVisualizerAlgorithm;
import org.processmining.log.models.LogCentrality;

public class LogCentralityVisualizerPlugin extends LogCentralityVisualizerAlgorithm {

	@Plugin(name = ""Log Summary"", parameterLabels = ""Happifiable Log"", returnTypes = JComponent.class, returnLabels = ""Log Visualization"", userAccessible = false, mostSignificantResult = 1, help = ""Provides an overview of the centralized log"")
	@Visualizer(name = ""Log Summary"")
	public JComponent visualizeLog(PluginContext context, LogCentrality centrality) throws ConnectionCannotBeObtained {
		XLogInfo info = XLogInfoFactory.createLogInfo(centrality.getLog(), centrality.getClassifier());
		JComponent component = context.tryToFindOrConstructFirstNamedObject(JComponent.class, ""  Log Summary"", null,
				null, centrality.getLog(), info);
		return component;
	}

	@Plugin(name = ""Trace Happiness"", parameterLabels = ""Happifiable Log"", returnTypes = JComponent.class, returnLabels = ""Log Visualization"", userAccessible = false, mostSignificantResult = 1, help = ""Provides an overview of the centralized log"")
	@Visualizer(name = ""Trace Happiness Visualizer"")
	public JComponent visualize(PluginContext context, LogCentrality centrality) {
		return apply(centrality, null);
	}

}
"
LogCheckerPlugin.java,log,"package org.processmining.log.plugins;

import java.util.EnumSet;

import org.deckfour.xes.model.XLog;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.framework.util.HTMLToString;
import org.processmining.log.algorithms.LogCheckerAlgorithm;
import org.processmining.log.help.LogCheckerHelp;
import org.processmining.log.logchecks.LogCheckType;
import org.processmining.log.models.LogCheckerReport;
import org.processmining.log.parameters.LogCheckerParameters;

@Plugin(name = ""Check Log"", categories = {}, parameterLabels = { ""Log"", ""Parameters"" }, returnLabels = {
		""Log Check Report"" }, returnTypes = { HTMLToString.class }, help = LogCheckerHelp.TEXT)
public class LogCheckerPlugin extends LogCheckerAlgorithm {

	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""Eric Verbeek"", email = ""h.m.w.verbeek@tue.nl"", website = ""www.processmining.org"")
	@PluginVariant(variantLabel = ""Check Log, default"", requiredParameterLabels = { 0 })
	public LogCheckerReport runDefault(PluginContext context, XLog log) {
		LogCheckerParameters parameters = new LogCheckerParameters();
		parameters.setLogChecks(EnumSet.of(
				LogCheckType.LOG_CHECK_EVENT_CLASSIFIERS_GLOBAL,
				LogCheckType.LOG_CHECK_GLOBAL_ATTRIBUTE, 
				LogCheckType.LOG_CHECK_CONSISTENT_TYPES));
		return apply(context, log, parameters);
	}
}
"
LogFrequencyArrayPlugin.java,log,"package org.processmining.log.plugins;

import org.deckfour.uitopia.api.event.TaskListener.InteractionResult;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.log.dialogs.LogFrequencyDialog;
import org.processmining.log.help.LogFrequencyArrayHelp;
import org.processmining.log.models.EventLogArray;
import org.processmining.log.models.LogFrequencyArray;
import org.processmining.log.parameters.LogFrequencyParameters;

@Plugin(name = ""Create Frequency Distributions"", parameterLabels = { ""Event Logs"" }, returnLabels = { ""Log Frequency Distribution"" }, returnTypes = { LogFrequencyArray.class }, userAccessible = true, help = LogFrequencyArrayHelp.TEXT)
public class LogFrequencyArrayPlugin {

	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""Eric Verbeek"", email = ""h.m.w.verbeek@tue.nl"", website = ""www.processmining.org"")
	@PluginVariant(variantLabel = ""Create Frequency Distributions, UI"", requiredParameterLabels = { 0 })
	public LogFrequencyArray runUI(UIPluginContext context, EventLogArray logs) {
		LogFrequencyParameters parameters = new LogFrequencyParameters(logs.getLog(0));
		LogFrequencyDialog dialog = new LogFrequencyDialog(logs.getLog(0), parameters);
		InteractionResult result = context.showWizard(""Configure Frequency Distributions (classifier)"", true, true,
				dialog);
		if (result != InteractionResult.FINISHED) {
			return null;
		}
		return (new LogFrequencyArrayPlugin()).run(context, logs, parameters);
	}

	/**
	 * @deprecated Use runUI() instead.
	 */
	@Deprecated
	public LogFrequencyArray publicUI(UIPluginContext context, EventLogArray logs) {
		return runUI(context, logs);
		
	}
	@PluginVariant(variantLabel = ""Create Frequency Distributions, Parameters"", requiredParameterLabels = { 0 })
	public LogFrequencyArray run(PluginContext context, EventLogArray logs, LogFrequencyParameters parameters) {
		return (new LogFrequencyArrayPlugin()).run(context, logs, parameters);
	}

	/**
	 * @deprecated Use run() instead.
	 */
	@Deprecated
	public LogFrequencyArray publicParameters(PluginContext context, EventLogArray logs, LogFrequencyParameters parameters) {
		return run(context, logs, parameters);
	}
	
	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""Eric Verbeek"", email = ""h.m.w.verbeek@tue.nl"", website = ""www.processmining.org"")
	@PluginVariant(variantLabel = ""Create Frequency Distributions, Default"", requiredParameterLabels = { 0 })
	public LogFrequencyArray runDefault(PluginContext context, EventLogArray logs) {
		LogFrequencyParameters parameters = new LogFrequencyParameters(logs.getLog(0));
		return (new LogFrequencyArrayPlugin()).run(context, logs, parameters);
	}
	
	/**
	 * @deprecated Use runDefault() instead.
	 */
	@Deprecated
	public LogFrequencyArray publicDefault(PluginContext context, EventLogArray logs) {
		return runDefault(context, logs);
	}
}
"
LogFrequencyPlugin.java,log,"package org.processmining.log.plugins;

import java.util.Collection;

import org.deckfour.uitopia.api.event.TaskListener.InteractionResult;
import org.deckfour.xes.model.XLog;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.connections.ConnectionCannotBeObtained;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.log.algorithms.LogFrequencyAlgorithm;
import org.processmining.log.connections.LogFrequencyConnection;
import org.processmining.log.dialogs.LogFrequencyDialog;
import org.processmining.log.help.LogFrequencyHelp;
import org.processmining.log.models.LogFrequency;
import org.processmining.log.parameters.LogFrequencyParameters;

@Plugin(name = ""Create Frequency Distribution"", parameterLabels = { ""Event Log"" }, returnLabels = { ""Log Frequency Distribution"" }, returnTypes = { LogFrequency.class }, userAccessible = true, help = LogFrequencyHelp.TEXT)
public class LogFrequencyPlugin {

	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""Eric Verbeek"", email = ""h.m.w.verbeek@tue.nl"", website = ""www.processmining.org"")
	@PluginVariant(variantLabel = ""Create Frequency Distribution, UI"", requiredParameterLabels = { 0 })
	public LogFrequency runUI(UIPluginContext context, XLog log) {
		LogFrequencyParameters parameters = new LogFrequencyParameters(log);
		LogFrequencyDialog dialog = new LogFrequencyDialog(log, parameters);
		InteractionResult result = context.showWizard(""Configure Frequency Distribution (classifier)"", true, true,
				dialog);
		if (result != InteractionResult.FINISHED) {
			return null;
		}
		return runConnections(context, log, parameters);
	}

	/**
	 * @deprecated Use runUI() instead.
	 */
	@Deprecated
	public LogFrequency publicUI(UIPluginContext context, XLog log) {
		return runUI(context, log);
	}
	
	@PluginVariant(variantLabel = ""Create Frequency Distribution, Parameters"", requiredParameterLabels = { 0 })
	public LogFrequency run(PluginContext context, XLog log, LogFrequencyParameters parameters) {
		return runConnections(context, log, parameters);
	}

	/**
	 * @deprecated Use run() instead.
	 */
	@Deprecated
	public LogFrequency publicParameters(PluginContext context, XLog log, LogFrequencyParameters parameters) {
		return run(context, log, parameters);
	}
	
	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""Eric Verbeek"", email = ""h.m.w.verbeek@tue.nl"", website = ""www.processmining.org"")
	@PluginVariant(variantLabel = ""Create Frequency Distribution, Default"", requiredParameterLabels = { 0 })
	public LogFrequency runDefault(PluginContext context, XLog log) {
		LogFrequencyParameters parameters = new LogFrequencyParameters(log);
		return runConnections(context, log, parameters);
	}

	/**
	 * @deprecated Use runDefault() instead.
	 */
	@Deprecated
	public LogFrequency publicDefault(PluginContext context, XLog log) {
		return runDefault(context, log);
	}

	private LogFrequency runConnections(PluginContext context, XLog log, LogFrequencyParameters parameters) {
		if (parameters.isTryConnections()) {
			Collection<LogFrequencyConnection> connections;
			try {
				connections = context.getConnectionManager().getConnections(
						LogFrequencyConnection.class, context, log);
				for (LogFrequencyConnection connection : connections) {
					if (connection.getObjectWithRole(LogFrequencyConnection.LOG)
							.equals(log) && connection.getParameters().equals(parameters)) {
						return connection
								.getObjectWithRole(LogFrequencyConnection.LOGFREQUENCY);
					}
				}
			} catch (ConnectionCannotBeObtained e) {
			}
		}
		LogFrequency logFrequency = (new LogFrequencyAlgorithm()).apply(context, log, parameters);
		if (parameters.isTryConnections()) {
			context.getConnectionManager().addConnection(
					new LogFrequencyConnection(log, logFrequency, parameters));
		}
		return logFrequency;
	}
}
"
LowFrequencyFilterArrayPlugin.java,log,"package org.processmining.log.plugins;

import org.deckfour.uitopia.api.event.TaskListener.InteractionResult;
import org.deckfour.xes.model.XLog;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginCategory;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.log.algorithms.LowFrequencyFilterAlgorithm;
import org.processmining.log.dialogs.LowFrequencyFilterDialog;
import org.processmining.log.help.LowFrequencyFilterArrayHelp;
import org.processmining.log.models.EventLogArray;
import org.processmining.log.models.impl.EventLogArrayFactory;
import org.processmining.log.parameters.LowFrequencyFilterParameters;

@Plugin(name = ""Filter Out Low-Frequency Traces (Multiple Logs)"", categories = { PluginCategory.Filtering }, parameterLabels = { ""Event Logs"" }, returnLabels = { ""Filtered Logs"" }, returnTypes = { EventLogArray.class }, userAccessible = true, help = LowFrequencyFilterArrayHelp.TEXT)
public class LowFrequencyFilterArrayPlugin {

	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""Eric Verbeek"", email = ""h.m.w.verbeek@tue.nl"", website = ""www.processmining.org"")
	@PluginVariant(variantLabel = ""Filter Out Low-Frequency Traces (Multiple Logs), UI"", requiredParameterLabels = { 0 })
	public EventLogArray runUI(UIPluginContext context, EventLogArray logs) {
		if (logs.getSize() > 0) {
			XLog log = logs.getLog(0);
			LowFrequencyFilterParameters parameters = new LowFrequencyFilterParameters(log);
			LowFrequencyFilterDialog dialog = new LowFrequencyFilterDialog(log, parameters);
			InteractionResult result = context.showWizard(""Configure Low-Frequency Filter"", true, true, dialog);
			if (result != InteractionResult.FINISHED) {
				return null;
			}
			EventLogArray filteredLogs = EventLogArrayFactory.createEventLogArray();
			filteredLogs.init();
			for (int i = 0; i < logs.getSize(); i++) {
				filteredLogs.addLog((new LowFrequencyFilterPlugin()).run(context, logs.getLog(i), parameters));
			}
			return filteredLogs;
		}
		return null;
	}

	/**
	 * @deprecated Use runUI instead.
	 */
	@Deprecated
	public EventLogArray publicUIArray(UIPluginContext context, EventLogArray logs) {
		return runUI(context, logs);
	}
	
	@PluginVariant(variantLabel = ""Filter Out Low-Frequency Traces (Multiple Logs), Parameters"", requiredParameterLabels = { 0 })
	public EventLogArray run(PluginContext context, EventLogArray logs,
			LowFrequencyFilterParameters parameters) {
		if (logs.getSize() > 0) {
			EventLogArray filteredLogs = EventLogArrayFactory.createEventLogArray();
			filteredLogs.init();
			for (int i = 0; i < logs.getSize(); i++) {
				filteredLogs.addLog((new LowFrequencyFilterAlgorithm()).apply(context, logs.getLog(i), parameters));
			}
			return filteredLogs;
		}
		return null;
	}

	/**
	 * @deprecated Use run instead.
	 */
	@Deprecated
	public EventLogArray publicParameters(PluginContext context, EventLogArray logs,
			LowFrequencyFilterParameters parameters) {
		return run(context, logs, parameters);
	}
	
	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""Eric Verbeek"", email = ""h.m.w.verbeek@tue.nl"", website = ""www.processmining.org"")
	@PluginVariant(variantLabel = ""Filter Out Low-Frequency Traces (Multiple Logs), Default"", requiredParameterLabels = { 0 })
	public EventLogArray runDefault(PluginContext context, EventLogArray logs) {
		if (logs.getSize() > 0) {
			LowFrequencyFilterParameters parameters = new LowFrequencyFilterParameters(logs.getLog(0));
			EventLogArray filteredLogs = EventLogArrayFactory.createEventLogArray();
			filteredLogs.init();
			for (int i = 0; i < logs.getSize(); i++) {
				filteredLogs.addLog((new LowFrequencyFilterAlgorithm()).apply(context, logs.getLog(i), parameters));
			}
			return filteredLogs;
		}
		return null;
	}

	/**
	 * @deprecated Use runDefault instead.
	 */
	@Deprecated
	public EventLogArray publicDefault(PluginContext context, EventLogArray logs) {
		return runDefault(context, logs);
	}
}
"
LowFrequencyFilterPlugin.java,log,"package org.processmining.log.plugins;

import java.util.Collection;

import org.deckfour.uitopia.api.event.TaskListener.InteractionResult;
import org.deckfour.xes.model.XLog;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.connections.ConnectionCannotBeObtained;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginCategory;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.log.algorithms.LowFrequencyFilterAlgorithm;
import org.processmining.log.connections.LowFrequencyFilterConnection;
import org.processmining.log.dialogs.LowFrequencyFilterDialog;
import org.processmining.log.help.LowFrequencyFilterHelp;
import org.processmining.log.parameters.LowFrequencyFilterParameters;

@Plugin(name = ""Filter Out Low-Frequency Traces (Single Log)"", categories = { PluginCategory.Filtering }, parameterLabels = {""Event Log""}, returnLabels = { ""Filtered Log"" }, returnTypes = {XLog.class }, userAccessible = true, help = LowFrequencyFilterHelp.TEXT)
public class LowFrequencyFilterPlugin {

	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""Eric Verbeek"", email = ""h.m.w.verbeek@tue.nl"", website = ""www.processmining.org"")
	@PluginVariant(variantLabel = ""Filter Out Low-Frequency Traces (Single Log), UI"", requiredParameterLabels = { 0 })
	public XLog runUI(UIPluginContext context, XLog log) {
		LowFrequencyFilterParameters parameters = new LowFrequencyFilterParameters(log);
		LowFrequencyFilterDialog dialog = new LowFrequencyFilterDialog(log, parameters);
		InteractionResult result = context.showWizard(""Configure Low-Frequency Filter"", true, true, dialog);
		if (result != InteractionResult.FINISHED) {
			return null;
		}
		return runConnections(context, log, parameters);
	}
	
	/**
	 * @deprecated Use runUI instead.
	 */
	@Deprecated
	public XLog publicUI(UIPluginContext context, XLog log) {
		return runUI(context, log);
	}
	
	@PluginVariant(variantLabel = ""Filter Out Low-Frequency Traces (Single Log), Parameters"", requiredParameterLabels = { 0 })
	public XLog run(PluginContext context, XLog log, LowFrequencyFilterParameters parameters) {
		return runConnections(context, log, parameters);
	}
	
	/**
	 * @deprecated Use run instead.
	 */
	@Deprecated
	public XLog publicParameters(PluginContext context, XLog log, LowFrequencyFilterParameters parameters) {
		return run(context, log, parameters);
	}
	
	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""Eric Verbeek"", email = ""h.m.w.verbeek@tue.nl"", website = ""www.processmining.org"")
	@PluginVariant(variantLabel = ""Filter Out Low-Frequency Traces (Single Log), Default"", requiredParameterLabels = { 0 })
	public XLog runDefault(PluginContext context, XLog log) {
		LowFrequencyFilterParameters parameters = new LowFrequencyFilterParameters(log);
		return runConnections(context, log, parameters);
	}

	/**
	 * @deprecated Use run instead.
	 */
	@Deprecated
	public XLog publicDefault(PluginContext context, XLog log) {
		return runDefault(context, log);
	}
	
	private XLog runConnections(PluginContext context, XLog log, LowFrequencyFilterParameters parameters) {
		if (parameters.isTryConnections()) {
			Collection<LowFrequencyFilterConnection> connections;
			try {
				connections = context.getConnectionManager().getConnections(
						LowFrequencyFilterConnection.class, context, log);
				for (LowFrequencyFilterConnection connection : connections) {
					if (connection.getObjectWithRole(LowFrequencyFilterConnection.LOG)
							.equals(log) && connection.getParameters().equals(parameters)) {
						return connection
								.getObjectWithRole(LowFrequencyFilterConnection.FILTEREDLOG);
					}
				}
			} catch (ConnectionCannotBeObtained e) {
			}
		}
		XLog filteredLog = (new LowFrequencyFilterAlgorithm()).apply(context, log, parameters);
		if (parameters.isTryConnections()) {
			context.getConnectionManager().addConnection(
					new LowFrequencyFilterConnection(log, filteredLog, parameters));
		}
		return filteredLog;
	}
}
"
LowOccurrencesFilterArrayPlugin.java,log,"package org.processmining.log.plugins;

import org.deckfour.uitopia.api.event.TaskListener.InteractionResult;
import org.deckfour.xes.model.XLog;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginCategory;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.log.dialogs.LowOccurrencesFilterDialog;
import org.processmining.log.help.LowOccurrencesFilterArrayHelp;
import org.processmining.log.models.EventLogArray;
import org.processmining.log.models.impl.EventLogArrayFactory;
import org.processmining.log.parameters.LowOccurrencesFilterParameters;

@Plugin(name = ""Filter Out Low-Occurrence Traces (Multiple Logs)"", categories = { PluginCategory.Filtering }, parameterLabels = { ""Event Logs"" }, returnLabels = { ""Filtered Logs"" }, returnTypes = { EventLogArray.class }, userAccessible = true, help = LowOccurrencesFilterArrayHelp.TEXT)
public class LowOccurrencesFilterArrayPlugin {

	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""Eric Verbeek"", email = ""h.m.w.verbeek@tue.nl"", website = ""www.processmining.org"")
	@PluginVariant(variantLabel = ""Filter Out Low-Occurrence Traces (Multiple Logs), UI"", requiredParameterLabels = { 0 })
	public EventLogArray runUI(UIPluginContext context, EventLogArray logs) {
		if (logs.getSize() > 0) {
			XLog log = logs.getLog(0);
			LowOccurrencesFilterParameters parameters = new LowOccurrencesFilterParameters(log);
			LowOccurrencesFilterDialog dialog = new LowOccurrencesFilterDialog(log, parameters);
			InteractionResult result = context.showWizard(""Configure Low-Occurrence Filter"", true, true, dialog);
			if (result != InteractionResult.FINISHED) {
				return null;
			}
			EventLogArray filteredLogs = EventLogArrayFactory.createEventLogArray();
			filteredLogs.init();
			for (int i = 0; i < logs.getSize(); i++) {
				filteredLogs.addLog((new LowOccurrencesFilterPlugin()).run(context, logs.getLog(i), parameters));
			}
			return filteredLogs;
		}
		return null;
	}

	/**
	 * @deprecated Use runUI instead.
	 */
	@Deprecated
	public EventLogArray publicUIArray(UIPluginContext context, EventLogArray logs) {
		return runUI(context, logs);
	}
	
	@PluginVariant(variantLabel = ""Filter Out Low-Occurrence Traces (Multiple Logs), Parameters"", requiredParameterLabels = { 0 })
	public EventLogArray run(PluginContext context, EventLogArray logs,
			LowOccurrencesFilterParameters parameters) {
		if (logs.getSize() > 0) {
			EventLogArray filteredLogs = EventLogArrayFactory.createEventLogArray();
			filteredLogs.init();
			for (int i = 0; i < logs.getSize(); i++) {
				filteredLogs.addLog((new LowOccurrencesFilterPlugin()).run(context, logs.getLog(i), parameters));
			}
			return filteredLogs;
		}
		return null;
	}

	/**
	 * @deprecated Use run instead.
	 */
	@Deprecated
	public EventLogArray publicParameters(UIPluginContext context, EventLogArray logs,
			LowOccurrencesFilterParameters parameters) {
		return run(context, logs, parameters);
	}
	
	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""Eric Verbeek"", email = ""h.m.w.verbeek@tue.nl"", website = ""www.processmining.org"")
	@PluginVariant(variantLabel = ""Filter Out Low-Occurrence Traces (Multiple Logs), Default"", requiredParameterLabels = { 0 })
	public EventLogArray runDefault(PluginContext context, EventLogArray logs) {
		if (logs.getSize() > 0) {
			LowOccurrencesFilterParameters parameters = new LowOccurrencesFilterParameters(logs.getLog(0));
			EventLogArray filteredLogs = EventLogArrayFactory.createEventLogArray();
			filteredLogs.init();
			for (int i = 0; i < logs.getSize(); i++) {
				filteredLogs.addLog((new LowOccurrencesFilterPlugin()).run(context, logs.getLog(i), parameters));
			}
			return filteredLogs;
		}
		return null;
	}

	/**
	 * @deprecated Use runDefault instead.
	 */
	@Deprecated
	public EventLogArray publicDefault(UIPluginContext context, EventLogArray logs) {
		return runDefault(context, logs);
	}
	
}
"
LowOccurrencesFilterPlugin.java,log,"package org.processmining.log.plugins;

import java.util.Collection;

import org.deckfour.uitopia.api.event.TaskListener.InteractionResult;
import org.deckfour.xes.model.XLog;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.connections.ConnectionCannotBeObtained;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginCategory;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.log.algorithms.LowOccurrencesFilterAlgorithm;
import org.processmining.log.connections.LowOccurrencesFilterConnection;
import org.processmining.log.dialogs.LowOccurrencesFilterDialog;
import org.processmining.log.help.LowOccurrencesFilterHelp;
import org.processmining.log.parameters.LowOccurrencesFilterParameters;

@Plugin(name = ""Filter Out Low-Occurrence Traces (Single Log)"", categories = { PluginCategory.Filtering }, parameterLabels = { ""Event Log"" }, returnLabels = { ""Filtered Log"" }, returnTypes = { XLog.class }, userAccessible = true, help = LowOccurrencesFilterHelp.TEXT)
public class LowOccurrencesFilterPlugin {

	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""Eric Verbeek"", email = ""h.m.w.verbeek@tue.nl"", website = ""www.processmining.org"")
	@PluginVariant(variantLabel = ""Filter Out Low-Occurrence Traces (Single Log), UI"", requiredParameterLabels = { 0 })
	public XLog runUI(UIPluginContext context, XLog log) {
		LowOccurrencesFilterParameters parameters = new LowOccurrencesFilterParameters(log);
		LowOccurrencesFilterDialog dialog = new LowOccurrencesFilterDialog(log, parameters);
		InteractionResult result = context.showWizard(""Configure Low-Occurrence Filter"", true, true, dialog);
		if (result != InteractionResult.FINISHED) {
			return null;
		}
		return runConnections(context, log, parameters);
	}

	/**
	 * @deprecated Use runUI instead.
	 */
	@Deprecated
	public XLog publicUI(UIPluginContext context, XLog log) {
		return runUI(context, log);
	}
	
	@PluginVariant(variantLabel = ""Filter Out Low-Occurrence Traces (Single Log), Parameters"", requiredParameterLabels = { 0 })
	public XLog run(PluginContext context, XLog log, LowOccurrencesFilterParameters parameters) {
		return runConnections(context, log, parameters);
	}

	/**
	 * @deprecated Use run instead.
	 */
	@Deprecated
	public XLog publicParameters(UIPluginContext context, XLog log, LowOccurrencesFilterParameters parameters) {
		return run(context, log, parameters);
	}
	
	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""Eric Verbeek"", email = ""h.m.w.verbeek@tue.nl"", website = ""www.processmining.org"")
	@PluginVariant(variantLabel = ""Filter Out Low-Occurrence Traces (Single Log), Default"", requiredParameterLabels = { 0 })
	public XLog runDefault(PluginContext context, XLog log) {
		LowOccurrencesFilterParameters parameters = new LowOccurrencesFilterParameters(log);
		return runConnections(context, log, parameters);
	}
	
	/**
	 * @deprecated Use runDefault instead.
	 */
	@Deprecated
	public XLog publicDefault(UIPluginContext context, XLog log) {
		return runDefault(context, log);
	}
	
	private XLog runConnections(PluginContext context, XLog log, LowOccurrencesFilterParameters parameters) {
		if (parameters.isTryConnections()) {
			Collection<LowOccurrencesFilterConnection> connections;
			try {
				connections = context.getConnectionManager().getConnections(
						LowOccurrencesFilterConnection.class, context, log);
				for (LowOccurrencesFilterConnection connection : connections) {
					if (connection.getObjectWithRole(LowOccurrencesFilterConnection.LOG)
							.equals(log) && connection.getParameters().equals(parameters)) {
						return connection
								.getObjectWithRole(LowOccurrencesFilterConnection.FILTEREDLOG);
					}
				}
			} catch (ConnectionCannotBeObtained e) {
			}
		}
		XLog filteredLog = (new LowOccurrencesFilterAlgorithm()).apply(context, log, parameters);
		if (parameters.isTryConnections()) {
			context.getConnectionManager().addConnection(
					new LowOccurrencesFilterConnection(log, filteredLog, parameters));
		}
		return filteredLog;
	}

}
"
MergeLogsPlugin.java,log,"package org.processmining.log.plugins;

import org.deckfour.uitopia.api.event.TaskListener.InteractionResult;
import org.deckfour.xes.model.XLog;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginCategory;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.log.algorithms.MergeLogsAlgorithm;
import org.processmining.log.dialogs.MergeLogsDialog;
import org.processmining.log.help.MergeLogsHelp;
import org.processmining.log.parameters.MergeLogsParameters;

@Plugin(name = ""Merge logs"", categories = { PluginCategory.Filtering }, parameterLabels = { ""Main Log"", ""Sub log"", ""Parameters"" }, 
returnLabels = { ""Merged logs"" }, returnTypes = { XLog.class }, help = MergeLogsHelp.TEXT)
public class MergeLogsPlugin extends MergeLogsAlgorithm {

	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""H.M.W. Verbeek"", email = ""h.m.w.verbeek@tue.nl"")
	@PluginVariant(variantLabel = ""Decomposed Discovery, UI"", requiredParameterLabels = { 0, 1 })
	public XLog runUI(UIPluginContext context, XLog mainLog, XLog subLog) {
		MergeLogsParameters parameters = new MergeLogsParameters();
		MergeLogsDialog dialog = new MergeLogsDialog(parameters, mainLog);
		InteractionResult result = context.showWizard(""Configure merge"", true, true, dialog);
		if (result != InteractionResult.FINISHED) {
			context.getFutureResult(0).cancel(true);
			return null;
		}
		return run(context, mainLog, subLog, parameters);
	}

	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""H.M.W. Verbeek"", email = ""h.m.w.verbeek@tue.nl"")
	@PluginVariant(variantLabel = ""Merge logs, Default"", requiredParameterLabels = { 0, 1 })
	public XLog run(PluginContext context, XLog mainLog, XLog subLog) {
		MergeLogsParameters parameters = new MergeLogsParameters();

		XLog log = apply(context, mainLog, subLog, parameters);

		return log;
	}

	@PluginVariant(variantLabel = ""Merge logs, Parameters"", requiredParameterLabels = { 0, 1, 2 })
	public XLog run(PluginContext context, XLog mainLog, XLog subLog,
			MergeLogsParameters parameters) {

		XLog log = apply(context, mainLog, subLog, parameters);

		return log;
	}
}
"
SplitLogPlugin.java,log,"package org.processmining.log.plugins;

import org.deckfour.uitopia.api.event.TaskListener.InteractionResult;
import org.deckfour.xes.model.XLog;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginCategory;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.log.algorithms.SplitLogAlgorithm;
import org.processmining.log.dialogs.SplitLogDialog;
import org.processmining.log.help.SplitLogHelp;
import org.processmining.log.parameters.SplitLogParameters;

@Plugin(name = ""Split traces"", categories = { PluginCategory.Filtering }, parameterLabels = { ""Log"", ""Parameters"" }, 
returnLabels = { ""Log containing splitted traces"" }, returnTypes = { XLog.class }, help = SplitLogHelp.TEXT)
public class SplitLogPlugin extends SplitLogAlgorithm {

	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""H.M.W. Verbeek"", email = ""h.m.w.verbeek@tue.nl"")
	@PluginVariant(variantLabel = ""Split traces, UI"", requiredParameterLabels = { 0 })
	public XLog runUI(UIPluginContext context, XLog log) {
		SplitLogParameters parameters = new SplitLogParameters(log);
		SplitLogDialog dialog = new SplitLogDialog(parameters, log);
		InteractionResult result = context.showWizard(""Configure split"", true, true, dialog);
		if (result != InteractionResult.FINISHED) {
			context.getFutureResult(0).cancel(true);
			return null;
		}
		return run(context, log, parameters);
	}

	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""H.M.W. Verbeek"", email = ""h.m.w.verbeek@tue.nl"")
	@PluginVariant(variantLabel = ""Merge logs, Default"", requiredParameterLabels = { 0 })
	public XLog run(PluginContext context, XLog log) {
		SplitLogParameters parameters = new SplitLogParameters(log);

		XLog splittedLog = apply(context, log, parameters);

		return splittedLog;
	}

	@PluginVariant(variantLabel = ""Merge logs, Parameters"", requiredParameterLabels = { 0, 1 })
	public XLog run(PluginContext context, XLog log,
			SplitLogParameters parameters) {

		XLog splittedLog = apply(context, log, parameters);

		return splittedLog;
	}
}
"
RepairAttributeDataType.java,log,"package org.processmining.log.repair;

import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.Dimension;
import java.text.DateFormat;
import java.text.ParsePosition;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.ListIterator;
import java.util.Map;
import java.util.Map.Entry;
import java.util.regex.Pattern;

import javax.swing.DefaultCellEditor;
import javax.swing.DefaultComboBoxModel;
import javax.swing.DefaultListCellRenderer;
import javax.swing.JComboBox;
import javax.swing.JComponent;
import javax.swing.JLabel;
import javax.swing.JList;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JTable;
import javax.swing.table.DefaultTableCellRenderer;
import javax.swing.table.DefaultTableModel;
import javax.swing.table.TableCellRenderer;
import javax.swing.table.TableColumnModel;

import org.deckfour.uitopia.api.event.TaskListener.InteractionResult;
import org.deckfour.xes.factory.XFactory;
import org.deckfour.xes.factory.XFactoryRegistry;
import org.deckfour.xes.model.XAttribute;
import org.deckfour.xes.model.XAttributeBoolean;
import org.deckfour.xes.model.XAttributeContinuous;
import org.deckfour.xes.model.XAttributeDiscrete;
import org.deckfour.xes.model.XAttributeLiteral;
import org.deckfour.xes.model.XAttributeMap;
import org.deckfour.xes.model.XAttributeTimestamp;
import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.Progress;
import org.processmining.framework.util.ui.widgets.ProMScrollPane;
import org.processmining.framework.util.ui.widgets.helper.ProMUIHelper;
import org.processmining.framework.util.ui.widgets.helper.UserCancelledException;
import org.processmining.log.formats.StandardDateFormats;

import com.google.common.collect.ImmutableList;
import com.google.common.collect.Iterables;
import com.google.common.collect.Ordering;

/**
 * Tries to automatically guess the data type of all XES attributes and updates
 * the log accordingly.
 * <p>
 * PLEASE NOTE: This filter will update the original XLog instead of creating a
 * new XLog, to be able to process huge logs without exhausting the available
 * memory.
 * 
 * @author F. Mannhardt
 * 
 */
public final class RepairAttributeDataType {

	private static class ReviewTable {

		private Map<String, Class<? extends XAttribute>> attributeDataType;
		private final JTable datatypeTable;
		private final DefaultTableModel tableModel;

		@SuppressWarnings({ ""unchecked"", ""serial"" })
		public ReviewTable(final Map<String, Class<? extends XAttribute>> attributeDataType) {
			super();
			this.attributeDataType = attributeDataType;
			this.tableModel = new DefaultTableModel() {

				public void setValueAt(Object aValue, int row, int column) {
					super.setValueAt(aValue, row, column);
					attributeDataType.put(getColumnName(column), (Class<? extends XAttribute>) aValue);
				}

			};

			for (String attributeKey : Ordering.natural().immutableSortedCopy(attributeDataType.keySet())) {
				Class<? extends XAttribute> dataType = attributeDataType.get(attributeKey);
				tableModel.addColumn(attributeKey, new Class[] { dataType });
			}

			this.datatypeTable = new JTable(tableModel);
			JComboBox<Class<? extends XAttribute>> comboBox = new JComboBox<>(
					new DefaultComboBoxModel<Class<? extends XAttribute>>(new Class[] { XAttributeBoolean.class,
							XAttributeContinuous.class, XAttributeDiscrete.class, XAttributeLiteral.class,
							XAttributeTimestamp.class }));
			comboBox.setRenderer(new DefaultListCellRenderer() {

				@SuppressWarnings(""rawtypes"")
				public Component getListCellRendererComponent(JList<?> list, Object value, int index,
						boolean isSelected, boolean cellHasFocus) {
					JLabel superComponent = (JLabel) super.getListCellRendererComponent(list, value, index, isSelected,
							cellHasFocus);
					superComponent.setText(((Class) value).getSimpleName());
					return superComponent;
				}

			});
			datatypeTable.setDefaultEditor(Object.class, new DefaultCellEditor(comboBox));
			datatypeTable.setDefaultRenderer(Object.class, new DefaultTableCellRenderer() {

				@SuppressWarnings(""rawtypes"")
				public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected,
						boolean hasFocus, int row, int column) {
					JLabel c = (JLabel) super.getTableCellRendererComponent(table, value, isSelected, hasFocus, row,
							column);
					c.setText(((Class) value).getSimpleName());
					return c;
				}

			});

			datatypeTable.setAutoResizeMode(JTable.AUTO_RESIZE_OFF);
			resizeColumnWidth(datatypeTable);
		}

		public Map<String, Class<? extends XAttribute>> getDataTypeMap() {
			return attributeDataType;
		}

		public JComponent getDatatypeTable() {
			JPanel workaroundPanel = new JPanel(new BorderLayout());
			ProMScrollPane scrollPane = new ProMScrollPane(datatypeTable);
			scrollPane.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);
			scrollPane.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_NEVER);
			workaroundPanel.add(scrollPane, BorderLayout.CENTER);
			workaroundPanel.setPreferredSize(new Dimension(400, 200));
			return workaroundPanel;
		}

		public void resizeColumnWidth(JTable table) {
			final TableColumnModel columnModel = table.getColumnModel();
			for (int column = 0; column < table.getColumnCount(); column++) {
				int width = 150; // Min width
				for (int row = 0; row < table.getRowCount(); row++) {
					TableCellRenderer renderer = table.getCellRenderer(row, column);
					Component comp = table.prepareRenderer(renderer, row, column);
					width = Math.max(comp.getPreferredSize().width * 2, width);
				}
				columnModel.getColumn(column).setPreferredWidth(width);
			}
		}

	}

	public interface ReviewCallback {
		Map<String, Class<? extends XAttribute>> reviewDataTypes(
				Map<String, Class<? extends XAttribute>> guessedDataTypes);
	}

	public RepairAttributeDataType() {
		super();
	}

	public void doRepairEventAttributes(PluginContext context, XLog log, Iterable<? extends DateFormat> dateFormats) {
		doRepairEventAttributes(context, log, dateFormats, null);
	}

	public void doRepairEventAttributes(PluginContext context, XLog log, Iterable<? extends DateFormat> dateFormats,
			ReviewCallback reviewCallback) {

		Progress progBar = context.getProgress();
		progBar.setMinimum(0);
		progBar.setMaximum(log.size() * 2); // two pass
		progBar.setValue(0);

		Map<String, Class<? extends XAttribute>> guessedDataType = new HashMap<>();

		// Determine best datatype
		for (XTrace trace : log) {
			for (XEvent event : trace) {
				buildDataTypeMap(event.getAttributes(), guessedDataType, dateFormats);
			}
			if (progBar.isCancelled()) {
				return;
			}
			progBar.inc();
		}

		boolean isDefinite = false;

		if (reviewCallback != null) {
			guessedDataType = reviewCallback.reviewDataTypes(guessedDataType);
			isDefinite = true; // Always obey user input
		}

		XFactory factory = XFactoryRegistry.instance().currentDefault();
		ListIterator<XTrace> traceIterator = log.listIterator();

		while (traceIterator.hasNext()) {

			XTrace trace = traceIterator.next();
			ListIterator<XEvent> eventIterator = trace.listIterator();

			while (eventIterator.hasNext()) {
				int eventIndex = eventIterator.nextIndex();
				XEvent event = eventIterator.next();
				XAttributeMap eventAttr = event.getAttributes();
				repairAttributes(context, factory, eventAttr, dateFormats, guessedDataType, isDefinite);
				trace.set(eventIndex, event);
			}
			if (progBar.isCancelled()) {
				return;
			}
			progBar.inc();
		}

	}

	public void doRepairTraceAttributes(PluginContext context, XLog log, Iterable<? extends DateFormat> dateFormats) {
		doRepairTraceAttributes(context, log, dateFormats, null);
	}

	public void doRepairTraceAttributes(PluginContext context, XLog log, Iterable<? extends DateFormat> dateFormats,
			ReviewCallback reviewCallback) {

		Progress progBar = context.getProgress();
		progBar.setMinimum(0);
		progBar.setMaximum(log.size() * 2); // two pass
		progBar.setValue(0);

		Map<String, Class<? extends XAttribute>> guessedDataType = new HashMap<>();

		// Determine best datatype
		for (XTrace trace : log) {
			buildDataTypeMap(trace.getAttributes(), guessedDataType, dateFormats);
			if (progBar.isCancelled()) {
				return;
			}
			progBar.inc();
		}

		boolean isDefinite = false;

		if (reviewCallback != null) {
			guessedDataType = reviewCallback.reviewDataTypes(guessedDataType);
			isDefinite = true;
		}

		XFactory factory = XFactoryRegistry.instance().currentDefault();

		ListIterator<XTrace> traceIterator = log.listIterator();

		while (traceIterator.hasNext()) {

			XTrace trace = traceIterator.next();
			XAttributeMap traceAttr = trace.getAttributes();
			repairAttributes(context, factory, traceAttr, dateFormats, guessedDataType, isDefinite);

			if (progBar.isCancelled()) {
				return;
			}
			progBar.inc();
		}

	}

	/**
	 * Shows a wizard that allows the user to specify an additional custom date
	 * format.
	 * 
	 * @param context
	 * @return a set of DateFormats including the user specified format
	 */
	public static Iterable<? extends DateFormat> queryDateFormats(UIPluginContext context) {

		try {
			String dateFormat = ProMUIHelper
					.queryForString(
							context,
							""Specify a custom DateFormat pattern (Format as defined in Java SimpleDateFormat) that is used to parse literal attributes that contain dates (LEAVE BLANK OR CANCEL TO USE DEFAULTS)"");
			SimpleDateFormat userDateFormat;
			if (dateFormat != null && !dateFormat.isEmpty()) {
				try {
					userDateFormat = new SimpleDateFormat(dateFormat);
					return Iterables.concat(ImmutableList.of(userDateFormat),
							StandardDateFormats.getStandardDateFormats());
				} catch (IllegalArgumentException e) {
					JOptionPane.showMessageDialog(null, e.getMessage(), ""Wrong Date Format"", JOptionPane.ERROR_MESSAGE);
				}
			}
		} catch (UserCancelledException e) {
		}

		return StandardDateFormats.getStandardDateFormats();
	}

	/**
	 * 
	 * 
	 * @param context
	 * @param attributeDataType
	 * @return
	 */
	public static Map<String, Class<? extends XAttribute>> queryCustomDataTypes(UIPluginContext context,
			Map<String, Class<? extends XAttribute>> attributeDataType) {
		ReviewTable reviewPanel = new ReviewTable(attributeDataType);
		InteractionResult reviewResult = context.showConfiguration(
				""Review/Adjust the automatically determined data types"", reviewPanel.getDatatypeTable());
		if (reviewResult == InteractionResult.FINISHED) {
			return reviewPanel.getDataTypeMap();
		}
		return attributeDataType;
	}

	private static void repairAttributes(PluginContext context, XFactory factory, XAttributeMap attributes,
			Iterable<? extends DateFormat> dateFormats, Map<String, Class<? extends XAttribute>> attributeDataType,
			boolean isDefinite) {
		// Use entrySet here, to avoid a lot of 'put' operations, maybe the underlying map can optimize the replacement operation using 'entry.setValue'
		Iterator<Entry<String, XAttribute>> traceAttr = attributes.entrySet().iterator();
		while (traceAttr.hasNext()) {
			Entry<String, XAttribute> entry = traceAttr.next();

			if (!isExtensionAttribute(entry.getValue())) {
				if (!(entry.getValue() instanceof XAttributeTimestamp)) {
					Class<? extends XAttribute> dataType = attributeDataType.get(entry.getKey());
					if (dataType != null) {
						try {
							XAttribute newAttribute = createAttribute(dataType, entry, factory, dateFormats);
							if (newAttribute != null) {
								entry.setValue(newAttribute);
							} else {
								throw new RuntimeException(String.format(
										""Could convert of attribute %s to %s NULL value returned."", entry.getKey(),
										dataType));
							}
						} catch (UnexpectedDataTypeException e) {
							if (isDefinite) {
								// remove non-matching entries
								traceAttr.remove();
								context.log(""Removing non-matching value "" + entry.getValue().toString());
							} else {
								throw new RuntimeException(String.format(
										""Could convert of attribute %s to data type %s."", entry.getKey(), dataType), e);
							}
						}
					} else {
						throw new RuntimeException(String.format(
								""Could not find datatype of attribute %s. Available data types are %s."",
								entry.getKey(), attributeDataType));
					}
				}
			}
		}
	}

	private static boolean isExtensionAttribute(XAttribute value) {
		return value.getExtension() != null;
	}

	private static void buildDataTypeMap(XAttributeMap attributes,
			Map<String, Class<? extends XAttribute>> attributeDataType, Iterable<? extends DateFormat> dateFormats) {
		for (XAttribute attribute : attributes.values()) {

			if (!(attribute instanceof XAttributeTimestamp)) {

				try {
					String value = getAttrAsString(attribute);
					Class<? extends XAttribute> currentDataType = inferDataType(value, dateFormats);
					Class<? extends XAttribute> lastDataType = attributeDataType.get(attribute.getKey());

					if (lastDataType == null) {
						// First occurrence
						attributeDataType.put(attribute.getKey(), currentDataType);
					} else if (!lastDataType.equals(currentDataType)) {
						// Stored data type does not match new occurrence

						if (checkChangeBothWays(currentDataType, lastDataType, XAttributeBoolean.class,
								XAttributeDiscrete.class)) {
							// Mixed Boolean (e.g. 0,1) & Integer -> XAttributeDiscrete
							if (lastDataType != XAttributeDiscrete.class) {
								attributeDataType.put(attribute.getKey(), XAttributeDiscrete.class);
							}
						} else if (checkChangeBothWays(currentDataType, lastDataType, XAttributeBoolean.class,
								XAttributeContinuous.class)) {
							// Mixed Boolean  (e.g. 0,1) & Float -> XAttributeContinuous
							if (lastDataType != XAttributeContinuous.class) {
								attributeDataType.put(attribute.getKey(), XAttributeContinuous.class);
							}
						} else if (checkChangeBothWays(currentDataType, lastDataType, XAttributeDiscrete.class,
								XAttributeContinuous.class)) {
							// Mixed Integer & Float -> XAttributeContinuous
							if (lastDataType != XAttributeContinuous.class) {
								attributeDataType.put(attribute.getKey(), XAttributeContinuous.class);
							}
						} else {
							// Fallback to Literal
							if (lastDataType != XAttributeLiteral.class) {
								attributeDataType.put(attribute.getKey(), XAttributeLiteral.class);
							}
						}
					}
				} catch (UnexpectedDataTypeException e) {
					// Ignore this attribute
				}

			}

		}
	}

	private static boolean checkChangeBothWays(Class<? extends XAttribute> dataType,
			Class<? extends XAttribute> lastDataType, Class<? extends XAttribute> class1,
			Class<? extends XAttribute> class2) {
		return (class1.equals(lastDataType) && class2.equals(dataType))
				|| (class2.equals(lastDataType) && class1.equals(dataType));
	}

	private static XAttribute createAttribute(Class<? extends XAttribute> dataType, Entry<String, XAttribute> entry,
			XFactory factory, Iterable<? extends DateFormat> dateFormats) throws UnexpectedDataTypeException {
		if (XAttributeDiscrete.class.equals(dataType)) {
			return factory.createAttributeDiscrete(entry.getKey(), getAttrAsLong(entry.getValue()), null);
		} else if (XAttributeContinuous.class.equals(dataType)) {
			return factory.createAttributeContinuous(entry.getKey(), getAttrAsDouble(entry.getValue()), null);
		} else if (XAttributeBoolean.class.equals(dataType)) {
			return factory.createAttributeBoolean(entry.getKey(), getAttrAsBoolean(entry.getValue()), null);
		} else if (XAttributeLiteral.class.equals(dataType)) {
			return factory.createAttributeLiteral(entry.getKey(), getAttrAsString(entry.getValue()), null);
		} else if (XAttributeTimestamp.class.equals(dataType)) {
			return factory.createAttributeTimestamp(entry.getKey(), getAttrAsDate(entry.getValue(), dateFormats), null);
		} else {
			throw new IllegalArgumentException(String.format(""Unexpected Attribute %s: Type %s instead %s"",
					entry.getValue(), entry.getValue().getClass().getSimpleName(), dataType.getSimpleName()));
		}
	}

	private static Date getAttrAsDate(XAttribute value, Iterable<? extends DateFormat> dateFormats)
			throws UnexpectedDataTypeException {
		if (value instanceof XAttributeLiteral) {
			Date date = tryParseDate(((XAttributeLiteral) value).getValue(), dateFormats);
			if (date == null) {
				throw new UnexpectedDataTypeException(""Unexpected date format "" + value);
			}
			return date;
		} else {
			throw new UnexpectedDataTypeException(""Unexpected attribute type "" + value);
		}
	}

	private static Date tryParseDate(String value, Iterable<? extends DateFormat> dateFormats) {
		ParsePosition pos = new ParsePosition(0);
		for (DateFormat formatter : dateFormats) {
			pos.setIndex(0);
			Date date = formatter.parse(value, pos);
			if (date != null && pos.getIndex() == value.length()) {
				return date;
			}
		}
		return null;
	}

	private static String getAttrAsString(XAttribute value) throws UnexpectedDataTypeException {
		if (value instanceof XAttributeDiscrete) {
			return Long.toString(((XAttributeDiscrete) value).getValue());
		} else if (value instanceof XAttributeContinuous) {
			return Double.toString(((XAttributeContinuous) value).getValue());
		} else if (value instanceof XAttributeBoolean) {
			return Boolean.toString(((XAttributeBoolean) value).getValue());
		} else if (value instanceof XAttributeLiteral) {
			return ((XAttributeLiteral) value).getValue();
		} else {
			throw new UnexpectedDataTypeException(""Unexpected attribute type "" + value);
		}
	}

	private static boolean getAttrAsBoolean(XAttribute value) throws UnexpectedDataTypeException {
		if (value instanceof XAttributeBoolean) {
			return ((XAttributeBoolean) value).getValue();
		} else if (value instanceof XAttributeLiteral) {
			String val = ((XAttributeLiteral) value).getValue();
			if (""0"".equals(val) || ""N"".equalsIgnoreCase(val)) {
				return false;
			} else if (""1"".equals(val) || ""J"".equalsIgnoreCase(val) || ""Y"".equalsIgnoreCase(val)) {
				return true;
			} else {
				return Boolean.valueOf(val);
			}
		} else if (value instanceof XAttributeDiscrete) {
			long val = ((XAttributeDiscrete) value).getValue();
			if (val != 0 && val != 1) {
				throw new UnexpectedDataTypeException(""Unexpected value "" + val);
			}
			return Boolean.valueOf(val == 0 ? false : true);
		} else {
			throw new UnexpectedDataTypeException(""Unexpected attribute type "" + value);
		}
	}

	private static double getAttrAsDouble(XAttribute value) throws UnexpectedDataTypeException {
		try {
			if (value instanceof XAttributeDiscrete) {
				return ((XAttributeDiscrete) value).getValue();
			} else if (value instanceof XAttributeContinuous) {
				return ((XAttributeContinuous) value).getValue();
			} else if (value instanceof XAttributeLiteral) {
				return Double.valueOf(((XAttributeLiteral) value).getValue());
			} else {
				throw new UnexpectedDataTypeException(""Unexpected attribute type "" + value);
			}
		} catch (NumberFormatException e) {
			throw new UnexpectedDataTypeException(e);
		}
	}

	private static long getAttrAsLong(XAttribute value) throws UnexpectedDataTypeException {
		try {
			if (value instanceof XAttributeDiscrete) {
				return ((XAttributeDiscrete) value).getValue();
			} else if (value instanceof XAttributeLiteral) {
				return Long.valueOf(((XAttributeLiteral) value).getValue());
			} else {
				throw new UnexpectedDataTypeException(""Unexpected attribute type "" + value);
			}
		} catch (NumberFormatException e) {
			throw new UnexpectedDataTypeException(e);
		}
	}

	private static Pattern DISCRETE_PATTERN = Pattern.compile(""(-)?[0-9]{1,19}"");
	private static Pattern CONTINUOUS_PATTERN = Pattern
			.compile(""((-)?[0-9]*\\.[0-9]+)|((-)?[0-9]+(\\.[0-9]+)?(e|E)\\+[0-9]+)"");
	private static Pattern BOOLEAN_PATTERN = Pattern.compile(""(true)|(false)|(TRUE)|(FALSE)|(0)|(1)|(Y)|(N)|(J)"");

	private static Class<? extends XAttribute> inferDataType(String value, Iterable<? extends DateFormat> dateFormats) {
		if (BOOLEAN_PATTERN.matcher(value).matches()) {
			return XAttributeBoolean.class;
		} else if (DISCRETE_PATTERN.matcher(value).matches()) {
			try {
				Long.parseLong(value);
				return XAttributeDiscrete.class;
			} catch (NumberFormatException e) {
				return XAttributeLiteral.class;
			}
		} else if (CONTINUOUS_PATTERN.matcher(value).matches()) {
			return XAttributeContinuous.class;
		} else if (tryParseDate(value, dateFormats) != null) {
			return XAttributeTimestamp.class;
		} else {
			return XAttributeLiteral.class;
		}
	}

}
"
RepairGlobalAttributesPlugin.java,log,"package org.processmining.log.repair;

import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.ListIterator;
import java.util.Set;

import org.deckfour.xes.classification.XEventAttributeClassifier;
import org.deckfour.xes.classification.XEventClassifier;
import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.extension.std.XCostExtension;
import org.deckfour.xes.extension.std.XLifecycleExtension;
import org.deckfour.xes.extension.std.XOrganizationalExtension;
import org.deckfour.xes.extension.std.XTimeExtension;
import org.deckfour.xes.model.XAttribute;
import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.deckfour.xes.util.XAttributeUtils;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginCategory;
import org.processmining.framework.plugin.annotations.PluginLevel;
import org.processmining.framework.util.ui.widgets.helper.ProMUIHelper;
import org.processmining.framework.util.ui.widgets.helper.UserCancelledException;

import com.google.common.base.Function;
import com.google.common.base.Predicate;
import com.google.common.collect.Collections2;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Iterables;

public final class RepairGlobalAttributesPlugin {

	private static final Function<XAttribute, XAttribute> PROTOTYPE_TRANSFORMER = new Function<XAttribute, XAttribute>() {

		public XAttribute apply(XAttribute firstAttr) {
			return XAttributeUtils.derivePrototype(firstAttr);
		}
	};

	public interface GlobalInfo {
		
		Collection<XAttribute> getEventAttributes();

		Collection<XAttribute> getTraceAttributes();
		
	}

	@Plugin(name = ""Repair Log: Globals, Classifiers, Extensions (In Place)"", level = PluginLevel.Regular, parameterLabels = { ""Event Log"" },//
			returnLabels = {}, returnTypes = {}, userAccessible = true, mostSignificantResult = -1, categories = { PluginCategory.Enhancement }, //
	help = ""Repairs the Event Log by detecting which attributes are global, updating the information about global attributes, adding possible classifiers, and adding correct extensions to certain attributes (time:timestamp, etc). This plug-ins changes the input event log to be able to deal with large event logs!"")
	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""F. Mannhardt"", email = ""f.mannhardt@tue.nl"")
	public void repairLogInPlace(PluginContext context, XLog log) {

		context.getProgress().setMinimum(0);
		context.getProgress().setMaximum(log.size());
		doRepairLog(log);
	}

	@Plugin(name = ""Repair Log: Globals, Classifiers, Extensions"", level = PluginLevel.PeerReviewed, parameterLabels = { ""Event Log"" }, //
			returnLabels = { ""Repaired Log with Globals"" }, returnTypes = { XLog.class }, userAccessible = true, mostSignificantResult = 1, categories = { PluginCategory.Enhancement }, //
	help = ""Repairs the Event Log by detecting which attributes are global, updating the information about global attributes, adding possible classifiers, and adding correct extensions to certain attributes (time:timestamp, etc)."")
	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""F. Mannhardt"", email = ""f.mannhardt@tue.nl"")
	public XLog repairLog(PluginContext context, XLog log) {

		context.getProgress().setMinimum(0);
		context.getProgress().setMaximum(log.size());

		XLog newLog = (XLog) log.clone();

		doRepairLog(newLog);

		return newLog;
	}

	@Plugin(name = ""Repair Log: Globals, Classifiers, Extensions (In Place)"", level = PluginLevel.Regular, parameterLabels = { ""Event Log"" }, returnLabels = {}, returnTypes = {}, userAccessible = true, mostSignificantResult = -1, categories = { PluginCategory.Enhancement }, //
	help = ""Repairs the Event Log by detecting which attributes are global, updating the information about global attributes, adding possible classifiers, and adding correct extensions to certain attributes (time:timestamp, etc). This plug-ins changes the input event log to be able to deal with large event logs!"")
	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""F. Mannhardt"", email = ""f.mannhardt@tue.nl"")
	public void repairLogInPlaceUI(UIPluginContext context, XLog log) {

		context.getProgress().setMinimum(0);
		context.getProgress().setMaximum(log.size());

		try {
			doRepairLogUI(context, log);
		} catch (UserCancelledException e) {
			context.getFutureResult(0).cancel(false);
		}
	}

	@Plugin(name = ""Repair Log: Globals, Classifiers, Extensions"", level = PluginLevel.PeerReviewed, parameterLabels = { ""Event Log"" }, returnLabels = { ""Repaired Log with Globals"" }, returnTypes = { XLog.class }, userAccessible = true, mostSignificantResult = 1, categories = { PluginCategory.Enhancement }, //
	help = ""Repairs the Event Log by detecting which attributes are global, updating the information about global attributes, adding possible classifiers, and adding correct extensions to certain attributes (time:timestamp, etc)."")
	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""F. Mannhardt"", email = ""f.mannhardt@tue.nl"")
	public XLog repairLogUI(UIPluginContext context, XLog log) {

		context.getProgress().setMinimum(0);
		context.getProgress().setMaximum(log.size());

		XLog newLog = (XLog) log.clone();

		try {
			doRepairLogUI(context, newLog);
		} catch (UserCancelledException e) {
			context.getFutureResult(0).cancel(false);
		}

		return newLog;
	}

	public void doRepairLogUI(UIPluginContext context, XLog log) throws UserCancelledException {

		GlobalInfo globals = detectGlobals(log);

		final Set<String> classifierAttribute = ImmutableSet
				.copyOf(ProMUIHelper.queryForObjects(context,
						""Which of the following global attributes should be added as classifier?"",
						Iterables.transform(globals.getEventAttributes(), new Function<XAttribute, String>() {

							public String apply(XAttribute a) {
								return a.getKey();
							}
						})));

		doRepairLog(log, globals, new Predicate<XAttribute>() {

			public boolean apply(XAttribute a) {
				return classifierAttribute.contains(a.getKey());
			}
		});
	}

	public static void doRepairLog(XLog log) {
		doRepairLog(log, detectGlobals(log), new Predicate<XAttribute>() {

			public boolean apply(XAttribute a) {
				return isClassifierAttribute(a);
			}
		});
	}

	public static void doRepairLog(XLog log, GlobalInfo info, Predicate<XAttribute> useForClassifier) {
		for (XAttribute attr : info.getEventAttributes()) {
			if (useForClassifier.apply(attr)) {
				if (!hasClassifier(attr, log.getClassifiers())) {
					log.getClassifiers().add(new XEventAttributeClassifier(attr.getKey(), attr.getKey()));
				}
			}
			switch (attr.getKey()) {
				case XConceptExtension.KEY_NAME :
				case XConceptExtension.KEY_INSTANCE :
					if (!log.getExtensions().contains(XConceptExtension.instance())) {
						log.getExtensions().add(XConceptExtension.instance());
					}
					break;
				case XTimeExtension.KEY_TIMESTAMP :
					if (!log.getExtensions().contains(XTimeExtension.instance())) {
						log.getExtensions().add(XTimeExtension.instance());
					}
					break;
				case XLifecycleExtension.KEY_MODEL :
				case XLifecycleExtension.KEY_TRANSITION :
					if (!log.getExtensions().contains(XLifecycleExtension.instance())) {
						log.getExtensions().add(XLifecycleExtension.instance());
					}
					break;
				case XOrganizationalExtension.KEY_GROUP :
				case XOrganizationalExtension.KEY_RESOURCE :
				case XOrganizationalExtension.KEY_ROLE :
					if (!log.getExtensions().contains(XOrganizationalExtension.instance())) {
						log.getExtensions().add(XOrganizationalExtension.instance());
					}
					break;
				case XCostExtension.KEY_AMOUNT :
				case XCostExtension.KEY_CURRENCY :
				case XCostExtension.KEY_DRIVER :
				case XCostExtension.KEY_TOTAL :
				case XCostExtension.KEY_TYPE :
					if (!log.getExtensions().contains(XCostExtension.instance())) {
						log.getExtensions().add(XCostExtension.instance());
					}
					break;
			}
			if (!hasGlobalAttribute(attr, log.getGlobalEventAttributes())) {
				log.getGlobalEventAttributes().add(attr);
			}
		}

		for (XAttribute attr : info.getTraceAttributes()) {
			if (!hasGlobalAttribute(attr, log.getGlobalTraceAttributes())) {
				log.getGlobalTraceAttributes().add(attr);
			}
		}
	}

	private static boolean hasGlobalAttribute(XAttribute attribute, List<XAttribute> globalAttributes) {
		for (XAttribute globalAttribute : globalAttributes) {
			if (globalAttribute.getKey().equals(attribute.getKey())) {
				return true;
			}
		}
		return false;
	}

	private static boolean hasClassifier(XAttribute attrribute, List<XEventClassifier> classifierList) {
		for (XEventClassifier classifier : classifierList) {
			for (String key : classifier.getDefiningAttributeKeys()) {
				if (key.equals(attrribute.getKey())) {
					return true;
				}
			}
		}
		return false;
	}

	private static boolean isClassifierAttribute(XAttribute attribute) {
		switch (attribute.getKey()) {
			case XConceptExtension.KEY_INSTANCE :
			case XTimeExtension.KEY_TIMESTAMP :
			case XLifecycleExtension.KEY_MODEL :
			case XLifecycleExtension.KEY_TRANSITION :
			case XCostExtension.KEY_AMOUNT :
			case XCostExtension.KEY_CURRENCY :
			case XCostExtension.KEY_DRIVER :
			case XCostExtension.KEY_TOTAL :
			case XCostExtension.KEY_TYPE :
				return false;
		}
		return true;
	}

	public static GlobalInfo detectGlobals(XLog log) {

		Set<XAttribute> eventAttributes = new HashSet<>();
		Set<XAttribute> traceAttributes = new HashSet<>();

		for (ListIterator<XTrace> logIter = log.listIterator(); logIter.hasNext();) {
			int traceIndex = logIter.nextIndex();
			XTrace trace = logIter.next();
			if (traceIndex == 0) {
				traceAttributes.addAll(trace.getAttributes().values());
			} else {
				Iterator<XAttribute> it = traceAttributes.iterator();
				while (it.hasNext()) {
					if (!trace.getAttributes().containsKey(it.next().getKey())) {
						it.remove();
					}
				}
			}
			for (ListIterator<XEvent> eventIter = trace.listIterator(); eventIter.hasNext();) {
				int eventIndex = eventIter.nextIndex();
				XEvent event = eventIter.next();
				if (traceIndex == 0 && eventIndex == 0) {
					eventAttributes.addAll(event.getAttributes().values());
				} else {
					Iterator<XAttribute> it = eventAttributes.iterator();
					while (it.hasNext()) {
						if (!event.getAttributes().containsKey(it.next().getKey())) {
							it.remove();
						}
					}
				}
			}
		}

		final Collection<XAttribute> defaultEventAttributes = Collections2.transform(eventAttributes,
				PROTOTYPE_TRANSFORMER);
		final Collection<XAttribute> defaultTraceAttributes = Collections2.transform(traceAttributes,
				PROTOTYPE_TRANSFORMER);

		return new GlobalInfo() {

			public Collection<XAttribute> getEventAttributes() {
				return defaultEventAttributes;
			}

			public Collection<XAttribute> getTraceAttributes() {
				return defaultTraceAttributes;
			}

		};
	}

}
"
UnexpectedDataTypeException.java,log,"package org.processmining.log.repair;

public final class UnexpectedDataTypeException extends Exception {

	private static final long serialVersionUID = 1L;

	public UnexpectedDataTypeException() {
	}

	public UnexpectedDataTypeException(String message) {
		super(message);
	}

	public UnexpectedDataTypeException(Throwable cause) {
		super(cause);
	}

	public UnexpectedDataTypeException(String message, Throwable cause) {
		super(message, cause);
	}

}
"
ReSortLog.java,log,"package org.processmining.plugins.log;

import java.util.Date;

import org.deckfour.xes.extension.std.XTimeExtension;
import org.deckfour.xes.factory.XFactoryRegistry;
import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;

public class ReSortLog {

	@Plugin(name = ""Resort Log Based on Time"", parameterLabels = { ""log"" }, returnLabels = { ""log"" }, returnTypes = { XLog.class }, userAccessible = true)
	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""B.F. van Dongen"", email = ""b.f.v.dongen@tue.nl"")
	public static XLog removeEdgePoints(PluginContext context, XLog log) {

		XLog result = XFactoryRegistry.instance().currentDefault().createLog(log.getAttributes());

		for (XTrace t : log) {
			XTrace copy = XFactoryRegistry.instance().currentDefault().createTrace(t.getAttributes());
			result.add(copy);

			for (XEvent e : t) {
				XEvent copyEvent = XFactoryRegistry.instance().currentDefault().createEvent(e.getAttributes());
				Date insertAt = XTimeExtension.instance().extractTimestamp(e);
				if (insertAt == null || copy.size() == 0) {
					copy.add(copyEvent);
					continue;
				}
				for (int i = copy.size() - 1; i >= 0; i--) {
					XEvent e2 = copy.get(i);
					Date d2 = XTimeExtension.instance().extractTimestamp(e2);
					if (d2 == null || d2.before(insertAt)) {
						copy.add(i+1, copyEvent);
						break;
					}
					if (i == 0) {
						copy.add(0, copyEvent);
					}
				}

			}

		}

		return result;

	}
}
"
TraceReverser.java,log,"package org.processmining.plugins.log.reverse;

import java.util.Date;

import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.extension.std.XTimeExtension;
import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.deckfour.xes.model.impl.XTraceImpl;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginVariant;

/**
 * Reverses all events per trace (leaving the timestamps as they are)
 * 
 * @author T. van der Wiel
 * 
 */
@Plugin(name = ""Reverse Log"", parameterLabels = { ""Log"" }, returnLabels = { ""Reversed log"" }, returnTypes = { XLog.class }, userAccessible = true)
public class TraceReverser {
	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""T. van der Wiel"", email = ""t.v.d.wiel@student.tue.nl"")
	@PluginVariant(requiredParameterLabels = { 0 }, variantLabel = ""Reverse Log"")
	public XLog reverse(UIPluginContext context, XLog log) {
		context.getFutureResult(0).setLabel(""Reversed "" + XConceptExtension.instance().extractName(log));
		XTimeExtension te = XTimeExtension.instance();
		XLog revLog = (XLog) log.clone();
		Date first = getFirstDate(log), last = getLastDate(log);
		revLog.clear();
		XConceptExtension.instance().assignName(revLog, ""Reversed "" + XConceptExtension.instance().extractName(log));
		for (XTrace t : log) {
			XTrace revT = new XTraceImpl(t.getAttributes());
			for (int i = t.size() - 1; i >= 0; i--) {
				XEvent e = (XEvent) t.get(i).clone();
				te.assignTimestamp(e, reverseTime(first, te.extractTimestamp(e), last));
				revT.add(e);
			}
			revLog.add(revT);
		}
		return revLog;
	}

	private Date reverseTime(Date first, Date date, Date last) {
		long f = first.getTime(), v = date.getTime(), l = last.getTime();
		return new Date((l - v) + f);
	}

	private Date getLastDate(XLog log) {
		XTimeExtension te = XTimeExtension.instance();
		Date last = te.extractTimestamp(log.get(0).get(0));
		for (XTrace t : log) {
			for (XEvent e : t) {
				Date current = te.extractTimestamp(e);
				if (current.after(last)) {
					last = current;
				}
			}
		}
		return last;
	}

	private Date getFirstDate(XLog log) {
		XTimeExtension te = XTimeExtension.instance();
		Date last = te.extractTimestamp(log.get(0).get(0));
		for (XTrace t : log) {
			for (XEvent e : t) {
				Date current = te.extractTimestamp(e);
				if (current.before(last)) {
					last = current;
				}
			}
		}
		return last;
	}
}
"
MergeLogsUtils.java,log,"package org.processmining.log.utils;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;

import org.processmining.log.parameters.MergeLogsParameters;

public class MergeLogsUtils {
	
	public static Date getDate(MergeLogsParameters parameters, String date) {
		SimpleDateFormat dateFormat = new SimpleDateFormat(parameters.getDateFormat());
		dateFormat.setLenient(false);
		try {
			return dateFormat.parse(date.trim());
		} catch (ParseException pe) {
			return null;
		}
		
	}

}
"
TraceVariant.java,log,"package org.processmining.log.utils;

import java.util.List;

/**
 * Trace variant which should override {@link #equals(Object)} and
 * {@link #hashCode()} to provide an equivalence relation for traces. A standard
 * implementation based on the classification of events is provided in
 * {@link TraceVariantByClassifier}.
 * 
 * @author F. Mannhardt
 *
 * @param <E>
 *            what constitutes an event
 */
public interface TraceVariant<E> {

	/**
	 * @return the list of events as viewed by this variant
	 */
	List<E> getEvents();

}"
TraceVariantByClassifier.java,log,"package org.processmining.log.utils;

import java.util.Iterator;

import org.deckfour.xes.classification.XEventClass;
import org.deckfour.xes.classification.XEventClasses;
import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XTrace;

import com.google.common.base.Function;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.Lists;
import com.google.common.primitives.Ints;

public final class TraceVariantByClassifier implements TraceVariant<XEventClass> {

	private final XTrace trace;
	private final XEventClasses eventClasses;

	public TraceVariantByClassifier(XTrace trace, XEventClasses eventClasses) {
		this.trace = trace;
		this.eventClasses = eventClasses;
	}

	public ImmutableList<XEventClass> getEvents() {
		return ImmutableList.copyOf(Lists.transform(trace, new Function<XEvent, XEventClass>() {

			public XEventClass apply(XEvent e) {
				return eventClasses.getClassOf(e);
			}
		}));
	}

	public int hashCode() {
		int hashCode = 1;
		for (XEvent e : trace) {
			XEventClass eventClass = eventClasses.getClassOf(e);
			hashCode = 31 * hashCode + (e == null ? 0 : Ints.hashCode(eventClass.getIndex()));
		}
		return hashCode;
	}

	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (getClass() != obj.getClass())
			return false;
		TraceVariantByClassifier other = (TraceVariantByClassifier) obj;
		if (trace == null) {
			if (other.trace != null)
				return false;
		} else if (!isEqualVariant(trace, other.trace))
			return false;
		return true;
	}

	private boolean isEqualVariant(XTrace t1, XTrace t2) {
		if (t1 == t2) {
			return true;
		}

		Iterator<XEvent> it1 = t1.iterator();
		Iterator<XEvent> it2 = t2.iterator();

		while (it1.hasNext() && it2.hasNext()) {
			XEventClass cl1 = eventClasses.getClassOf(it1.next());
			XEventClass cl2 = eventClasses.getClassOf(it2.next());
			if (cl1.getIndex() != cl2.getIndex()) {
				return false;
			}
		}
		return !(it1.hasNext() || it2.hasNext());
	}

}"
XLogBuilder.java,log,"/*
 * Copyright (c) 2014 F. Mannhardt (f.mannhardt@tue.nl)
 * 
 * LICENSE:
 * 
 * This code is free software; you can redistribute it and/or modify it under
 * the terms of the GNU Lesser General Public License as published by the Free
 * Software Foundation; either version 3 of the License, or (at your option) any
 * later version.
 * 
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
 * details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA
 */
package org.processmining.log.utils;

import java.util.Date;

import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.factory.XFactory;
import org.deckfour.xes.factory.XFactoryRegistry;
import org.deckfour.xes.model.XAttribute;
import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;

/**
 * Fluent-style builder for create a XLog in an easy way. Get an instance by
 * calling {@link XLogBuilder#newInstance()}, then it can be used as follows: 

 * <pre>
 * {@code
 *  XLog log = XLogBuilder.newInstance()
 *	 	.startLog(""logName"")
 *		.addTrace(""traceName"", 2)
 *		.addAttribute(""traceAttribute"", ""test"")
 *			.addEvent(""Event1"")
 *			.addAttribute(""eventAttribute"", 21)
 *			.addEvent(""Event2"")
 *			.addEvent(""Event3"")
 *			.addEvent(""Event4"", 2)
 *		.build();
 * }
 * </pre>
 * Please note that a {@link XLogBuilder} instance is design to be used to 
 * create one log only. 
 * 
 * @author F. Mannhardt
 * 
 */
public class XLogBuilder {

	public static XLogBuilder newInstance() {
		return new XLogBuilder();
	}

	private XFactory factory = XFactoryRegistry.instance().currentDefault();
	private final XConceptExtension conceptInstance = XConceptExtension.instance();

	private XLog log = null;

	private XTrace currentTrace = null;
	private int currentTraceMultiplicity = 1;

	private XEvent currentEvent = null;
	private int currentEventMultiplicity;

	public XLogBuilder startLog(String name) {
		log = factory.createLog();
		if (log != null) {
			conceptInstance.assignName(log, name);
		}
		return this;
	}

	public XLogBuilder addTrace(String name) {
		return addTrace(name, 1);
	}

	public XLogBuilder addTrace(String name, int numberOfTraces) {
		if (log == null) {
			throw new IllegalStateException(""Please call 'startLog' first!"");
		}
		if (currentEvent != null) {
			addCurrentEventToTrace();
		}
		if (currentTrace != null) {
			addCurrentTraceToLog();
			currentEvent = null;
		}
		currentTrace = factory.createTrace();
		if (name != null) {
			conceptInstance.assignName(currentTrace, name);
		}
		currentTraceMultiplicity = numberOfTraces;
		return this;
	}

	private void addCurrentTraceToLog() {
		log.add(currentTrace);
		if (currentTraceMultiplicity > 1) {
			for (int i = 0; i < currentTraceMultiplicity - 1; i++) {
				XTrace clone = (XTrace) currentTrace.clone();
				String name = conceptInstance.extractName(clone);
				if (name != null) {
					conceptInstance.assignName(clone, name.concat(""-"").concat(String.valueOf(i+1)));
				}
				log.add(clone);
			}
		}
	}

	public XLogBuilder addEvent(String name) {
		addEvent(name, 1);
		return this;
	}

	public XLogBuilder addEvent(String name, int numberOfEvents) {
		if (currentTrace == null) {
			throw new IllegalStateException(""Please call 'addTrace' first!"");
		}
		if (currentEvent != null) {
			addCurrentEventToTrace();
		}
		currentEvent = factory.createEvent();
		conceptInstance.assignName(currentEvent, name);
		currentEventMultiplicity = numberOfEvents;
		return this;
	}

	private void addCurrentEventToTrace() {
		currentTrace.add(currentEvent);
		if (currentEventMultiplicity > 1) {
			for (int i = 0; i < currentEventMultiplicity - 1; i++) {
				currentTrace.add((XEvent) currentEvent.clone());
			}
		}
	}
	
	/**
	 * Add the given attribute
	 * 
	 * @param attribute
	 * @return {@link XLogBuilder}
	 */
	public XLogBuilder addAttribute(XAttribute attribute) {
		addAttributeInternal(attribute.getKey(), attribute);
		return this;
	}
	
	/**
	 * @param name
	 * @param value
	 * @return
	 */
	public XLogBuilder addAttribute(String name, boolean value) {
		XAttribute attribute = factory.createAttributeBoolean(name, value, null);
		addAttributeInternal(name, attribute);
		return this;
	}

	/**
	 * @param name
	 * @param value
	 * @return the {@link XLogBuilder} itself
	 */
	public XLogBuilder addAttribute(String name, long value) {
		XAttribute attribute = factory.createAttributeDiscrete(name, value, null);
		addAttributeInternal(name, attribute);
		return this;
	}

	/**
	 * @param name
	 * @param value
	 * @return the {@link XLogBuilder} itself
	 */
	public XLogBuilder addAttribute(String name, String value) {
		XAttribute attribute = factory.createAttributeLiteral(name, value, null);
		addAttributeInternal(name, attribute);
		return this;
	}

	/**
	 * @param name
	 * @param value
	 * @return the {@link XLogBuilder} itself
	 */
	public XLogBuilder addAttribute(String name, Date value) {
		XAttribute attribute = factory.createAttributeTimestamp(name, value, null);
		addAttributeInternal(name, attribute);
		return this;
	}

	/**
	 * @param name
	 * @param value
	 * @return the {@link XLogBuilder} itself
	 */
	public XLogBuilder addAttribute(String name, double value) {
		XAttribute attribute = factory.createAttributeContinuous(name, value, null);
		addAttributeInternal(name, attribute);
		return this;
	}
	
	public XLogBuilder setFactory(XFactory factory) {
		this.factory = factory;
		return this;
	}

	private void addAttributeInternal(String name, XAttribute attribute) {
		if (currentEvent == null && currentTrace == null) {
			throw new IllegalStateException(""Please call 'addEvent' or 'addTrace' first!"");
		}

		if (currentEvent == null) {
			// Trace Attributes			
			currentTrace.getAttributes().put(name, attribute);
		} else {
			// Event Attributes
			currentEvent.getAttributes().put(name, attribute);
		}
	}

	/**
	 * Builds and returns the XLog. This is only to be used once! 
	 * 
	 * @return the final XLog
	 */ 
	public XLog build() {
		if (currentEvent != null) {
			addCurrentEventToTrace();
		}
		if (currentTrace != null) {
			addCurrentTraceToLog();
		}
		return log;
	}

}
"
XUtils.java,log,"/*
 * Copyright (c) 2014 F. Mannhardt (f.mannhardt@tue.nl)
 * 
 * LICENSE:
 * 
 * This code is free software; you can redistribute it and/or modify it under
 * the terms of the GNU Lesser General Public License as published by the Free
 * Software Foundation; either version 3 of the License, or (at your option) any
 * later version.
 * 
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
 * details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA
 */
package org.processmining.log.utils;

import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.UnsupportedEncodingException;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.NavigableSet;
import java.util.Set;
import java.util.TreeSet;

import org.deckfour.xes.classification.XEventAndClassifier;
import org.deckfour.xes.classification.XEventClass;
import org.deckfour.xes.classification.XEventClasses;
import org.deckfour.xes.classification.XEventClassifier;
import org.deckfour.xes.classification.XEventLifeTransClassifier;
import org.deckfour.xes.classification.XEventNameClassifier;
import org.deckfour.xes.extension.XExtension;
import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.extension.std.XCostExtension;
import org.deckfour.xes.extension.std.XLifecycleExtension;
import org.deckfour.xes.extension.std.XOrganizationalExtension;
import org.deckfour.xes.extension.std.XTimeExtension;
import org.deckfour.xes.factory.XFactory;
import org.deckfour.xes.factory.XFactoryRegistry;
import org.deckfour.xes.id.XID;
import org.deckfour.xes.in.XesXmlParser;
import org.deckfour.xes.info.XLogInfo;
import org.deckfour.xes.info.impl.XLogInfoImpl;
import org.deckfour.xes.model.XAttributable;
import org.deckfour.xes.model.XAttribute;
import org.deckfour.xes.model.XAttributeBoolean;
import org.deckfour.xes.model.XAttributeContainer;
import org.deckfour.xes.model.XAttributeContinuous;
import org.deckfour.xes.model.XAttributeDiscrete;
import org.deckfour.xes.model.XAttributeID;
import org.deckfour.xes.model.XAttributeList;
import org.deckfour.xes.model.XAttributeLiteral;
import org.deckfour.xes.model.XAttributeMap;
import org.deckfour.xes.model.XAttributeTimestamp;
import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.deckfour.xes.out.XSerializer;
import org.deckfour.xes.out.XesXmlGZIPSerializer;
import org.deckfour.xes.out.XesXmlSerializer;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.plugins.utils.ProvidedObjectHelper;

import com.google.common.base.Function;
import com.google.common.collect.ImmutableListMultimap;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Iterables;
import com.google.common.collect.ListMultimap;
import com.google.common.collect.Multimaps;
import com.google.common.collect.SetMultimap;

/**
 * Commonly used methods for handling XES logs
 * 
 * @author F. Mannhardt
 *
 */
public final class XUtils {

	private XUtils() {
		//only for static methods
	}

	/**
	 * The invisible activity. Activity to be used for mapping silent
	 * transitions on.
	 */
	public final static XEventClass INVISIBLEACTIVITY = new XEventClass(""[invisible]"", 0);

	/**
	 * The move-on-model activity. Activity to be used for mapping transition on
	 * that are not covered by the log at hand. As such, they will always have
	 * to be a move-on-model.
	 */
	public final static XEventClass MOVEONMODELACTIVITY = new XEventClass(""[move on model]"", 0);

	public static final XEventClassifier STANDARDCLASSIFIER = new XEventAndClassifier(new XEventNameClassifier(),
			new XEventLifeTransClassifier());

	/**
	 * Returns whether the attribute key matches one of the registered standard
	 * extensions of XES.
	 * 
	 * @param attribute
	 * @return whether the attribute is one of the standard extension attributes
	 */
	public static boolean isStandardExtensionAttribute(XAttribute attribute) {
		// Lets hope that the JIT is clever enough to transform this to a hash table
		switch (attribute.getKey()) {
			case XConceptExtension.KEY_NAME :
			case XConceptExtension.KEY_INSTANCE :
			case XTimeExtension.KEY_TIMESTAMP :
			case XLifecycleExtension.KEY_MODEL :
			case XLifecycleExtension.KEY_TRANSITION :
			case XOrganizationalExtension.KEY_GROUP :
			case XOrganizationalExtension.KEY_RESOURCE :
			case XOrganizationalExtension.KEY_ROLE :
			case XCostExtension.KEY_AMOUNT :
			case XCostExtension.KEY_CURRENCY :
			case XCostExtension.KEY_DRIVER :
			case XCostExtension.KEY_TOTAL :
			case XCostExtension.KEY_TYPE :
				return true;
		}
		return false;
	}

	/**
	 * Added by Eric Verbeek
	 * 
	 * Returns a default classifier to use with an event log. If the log
	 * contains classifiers, then the first classifier is returned. Otherwise,
	 * the standard MXML classifier is constructed and returned.
	 * 
	 * @param log
	 * @return A default classifier to use with the provided log.
	 */
	public static XEventClassifier getDefaultClassifier(XLog log) {
		if (log.getClassifiers().isEmpty()) {
			return STANDARDCLASSIFIER;
		}
		return log.getClassifiers().get(0);
	}

	/**
	 * Returns both the event classifiers defined by the XLog, as well as the
	 * three standard classifiers {@link XLogInfoImpl#NAME_CLASSIFIER},
	 * {@link XLogInfoImpl#RESOURCE_CLASSIFIER} and
	 * {@link XLogInfoImpl#STANDARD_CLASSIFIER}.
	 * 
	 * @param log
	 * @return a list of event classifiers that can be used on the log
	 */
	public static List<XEventClassifier> getStandardAndLogDefinedEventClassifiers(XLog log) {
		List<XEventClassifier> classList = new ArrayList<>(log.getClassifiers());
		if (!classList.contains(XLogInfoImpl.RESOURCE_CLASSIFIER)) {
			classList.add(XLogInfoImpl.RESOURCE_CLASSIFIER);
		}
		if (!classList.contains(XLogInfoImpl.STANDARD_CLASSIFIER)) {
			classList.add(XLogInfoImpl.STANDARD_CLASSIFIER);
		}
		if (!classList.contains(XLogInfoImpl.NAME_CLASSIFIER)) {
			classList.add(0, XLogInfoImpl.NAME_CLASSIFIER);
		}
		return classList;
	}

	/**
	 * Returns the event name.
	 * 
	 * @param element
	 * @return the value of the ""concept:name"" attribute or ""null""
	 */
	public static String getConceptName(XAttributable element) {
		return XConceptExtension.instance().extractName(element);
	}

	public static void assignConceptName(XLog log, String name) {
		XConceptExtension.instance().assignName(log, name);
	}

	public static void assignConceptName(XEvent event, String name) {
		XConceptExtension.instance().assignName(event, name);
	}

	public static void assignConceptName(XTrace trace, String name) {
		XConceptExtension.instance().assignName(trace, name);
	}

	/**
	 * Returns the event time.
	 * 
	 * @param event
	 * @return the value of the ""time:timestamp"" attribute or ""null""
	 */
	public static Date getTimestamp(XEvent event) {
		return XTimeExtension.instance().extractTimestamp(event);
	}

	public static void assignTimestamp(XEvent event, Date timestamp) {
		XTimeExtension.instance().assignTimestamp(event, timestamp);
	}

	public static void assignTimestamp(XEvent event, long timestamp) {
		XTimeExtension.instance().assignTimestamp(event, timestamp);
	}

	public static XLog loadLog(String string) throws UnsupportedEncodingException, Exception {
		return loadLog(new ByteArrayInputStream(string.getBytes(StandardCharsets.UTF_8)));
	}

	public static XLog loadLog(File file) throws FileNotFoundException, Exception {
		return loadLog(new FileInputStream(file));
	}

	public static XLog loadLog(InputStream is) throws Exception {
		XesXmlParser xmlParser = new XesXmlParser();
		return Iterables.getFirst(xmlParser.parse(is), null);
	}

	public static void saveLog(XLog log, File file) throws FileNotFoundException, IOException {
		saveLogPlain(log, file);
	}

	public static void saveLogPlain(XLog log, File file) throws FileNotFoundException, IOException {
		saveLogWithSerializer(log, file, new XesXmlSerializer());
	}

	public static void saveLogGzip(XLog log, File file) throws FileNotFoundException, IOException {
		saveLogWithSerializer(log, file, new XesXmlGZIPSerializer());
	}

	public static void saveLogWithSerializer(XLog log, File file, XSerializer logSerializer)
			throws FileNotFoundException, IOException {
		try (FileOutputStream out = new FileOutputStream(file)) {
			logSerializer.serialize(log, out);
		}
	}

	public static boolean containsEventWithName(String eventName, XTrace trace) {
		for (XEvent xEvent : trace) {
			if (eventName.equals(getConceptName(xEvent))) {
				return true;
			}
		}
		return false;
	}

	public static XEvent getLatestEventWithName(String eventName, XTrace trace) {
		XEvent latestEvent = null;
		for (XEvent xEvent : trace) {
			if (eventName.equals(getConceptName(xEvent))) {
				latestEvent = xEvent;
			}
		}
		return latestEvent;
	}

	public static NavigableSet<String> getAllEventNamesSorted(XLog log) {
		NavigableSet<String> eventNames = new TreeSet<>();
		for (XTrace trace : log) {
			for (XEvent event : trace) {
				eventNames.add(getConceptName(event));
			}
		}
		return eventNames;
	}

	public static String stringifyEvent(XEvent e, XEventClassifier classifier) {
		return classifier.getClassIdentity(e);
	}

	public static String stringifyEvent(XEvent e) {
		return stringifyEvent(e, new XEventNameClassifier());
	}

	public static String stringifyTrace(XTrace t, XEventClassifier classifier) {
		StringBuilder sBuilder = new StringBuilder(""["");
		Iterator<XEvent> iterator = t.iterator();
		while (iterator.hasNext()) {
			sBuilder.append(stringifyEvent(iterator.next(), classifier));
			if (iterator.hasNext()) {
				sBuilder.append("","");
			}
		}
		sBuilder.append(""]"");
		return sBuilder.toString();
	}

	public static String stringifyTrace(XTrace t) {
		return stringifyTrace(t, new XEventNameClassifier());
	}

	public static String stringifyLog(XLog l, XEventClassifier classifier) {
		StringBuilder sBuilder = new StringBuilder(""["");
		Iterator<XTrace> iterator = l.iterator();
		while (iterator.hasNext()) {
			sBuilder.append(stringifyTrace(iterator.next(), classifier));
			if (iterator.hasNext()) {
				sBuilder.append("",\n"");
			}
		}
		sBuilder.append(""]"");
		return sBuilder.toString();
	}

	public static String stringifyLog(XLog l) {
		return stringifyLog(l, new XEventNameClassifier());
	}

	public static String stringifyAttributes(XAttributeMap map) {
		StringBuilder sBuilder = new StringBuilder(""{"");
		Iterator<XAttribute> iterator = map.values().iterator();
		while (iterator.hasNext()) {
			XAttribute a = iterator.next();
			sBuilder.append(a.getKey() + "" -> "" + a.toString());
			if (iterator.hasNext()) {
				sBuilder.append("",\n"");
			}
		}
		sBuilder.append(""}"");
		return sBuilder.toString();
	}

	/**
	 * Creates a deep clone of the {@link XAttribute} with the same value, but a
	 * changed key.
	 * 
	 * @param oldAttribute
	 * @param newKey
	 * @return copy of the supplied attribute
	 */
	public static XAttribute cloneAttributeWithChangedKey(XAttribute oldAttribute, String newKey) {
		return cloneAttributeWithChangedKeyWithFactory(oldAttribute, newKey,
				XFactoryRegistry.instance().currentDefault());
	}

	/**
	 * Creates a deep clone of the {@link XAttribute} with the same value, but a
	 * changed key.
	 * 
	 * @param oldAttribute
	 * @param newKey
	 * @param factory
	 * @return copy of the supplied attribute
	 */
	public static XAttribute cloneAttributeWithChangedKeyWithFactory(XAttribute oldAttribute, String newKey,
			XFactory factory) {
		if (oldAttribute instanceof XAttributeList) {
			XAttributeList newAttribute = factory.createAttributeList(newKey, oldAttribute.getExtension());
			for (XAttribute a : ((XAttributeList) oldAttribute).getCollection()) {
				newAttribute.addToCollection(a);
			}
			return newAttribute;
		} else if (oldAttribute instanceof XAttributeContainer) {
			XAttributeContainer newAttribute = factory.createAttributeContainer(newKey, oldAttribute.getExtension());
			for (XAttribute a : ((XAttributeContainer) oldAttribute).getCollection()) {
				newAttribute.addToCollection(a);
			}
			return newAttribute;
		} else if (oldAttribute instanceof XAttributeLiteral) {
			return factory.createAttributeLiteral(newKey, ((XAttributeLiteral) oldAttribute).getValue(),
					oldAttribute.getExtension());
		} else if (oldAttribute instanceof XAttributeBoolean) {
			return factory.createAttributeBoolean(newKey, ((XAttributeBoolean) oldAttribute).getValue(),
					oldAttribute.getExtension());
		} else if (oldAttribute instanceof XAttributeContinuous) {
			return factory.createAttributeContinuous(newKey, ((XAttributeContinuous) oldAttribute).getValue(),
					oldAttribute.getExtension());
		} else if (oldAttribute instanceof XAttributeDiscrete) {
			return factory.createAttributeDiscrete(newKey, ((XAttributeDiscrete) oldAttribute).getValue(),
					oldAttribute.getExtension());
		} else if (oldAttribute instanceof XAttributeTimestamp) {
			return factory.createAttributeTimestamp(newKey, ((XAttributeTimestamp) oldAttribute).getValue(),
					oldAttribute.getExtension());
		} else if (oldAttribute instanceof XAttributeID) {
			return factory.createAttributeID(newKey, ((XAttributeID) oldAttribute).getValue(),
					oldAttribute.getExtension());
		} else {
			throw new IllegalArgumentException(""Unexpected attribute type!"");
		}
	}

	/**
	 * Creates a deep clone of the supplied event log without classifiers
	 * 
	 * @param log
	 * @return a clone of the supplied log
	 */
	public static XLog cloneLogWithoutClassifier(XLog log) {
		XLog clone = (XLog) log.clone();
		clone.getClassifiers().clear();
		return clone;
	}

	/**
	 * Creates a deep clone of the supplied event log without globals
	 * 
	 * @param log
	 * @return a clone of the supplied log
	 */
	public static XLog cloneLogWithoutGlobals(XLog log) {
		XLog clone = (XLog) log.clone();
		clone.getGlobalTraceAttributes().clear();
		clone.getGlobalEventAttributes().clear();
		return clone;
	}

	/**
	 * Creates a deep clone of the supplied event log without globals and
	 * without classifiers
	 * 
	 * @param log
	 * @return a clone of the supplied log
	 */
	public static XLog cloneLogWithoutGlobalsAndClassifiers(XLog log) {
		XLog clone = (XLog) log.clone();
		clone.getClassifiers().clear();
		clone.getGlobalTraceAttributes().clear();
		clone.getGlobalEventAttributes().clear();
		return clone;
	}

	/**
	 * Creates a new log with attributes and meta data (classifiers, globals,
	 * extension) from the oldLog.
	 * 
	 * @param oldLog
	 * @return
	 */
	public static XLog createLogFrom(XLog oldLog) {
		return createLogFrom(oldLog, XFactoryRegistry.instance().currentDefault());
	}

	/**
	 * Creates a new log with attributes and meta data (classifiers, globals,
	 * extension) from the oldLog.
	 * 
	 * @param oldLog
	 * @param factory
	 * @return
	 */
	public static XLog createLogFrom(XLog oldLog, XFactory factory) {
		XLog newLog = factory.createLog((XAttributeMap) oldLog.getAttributes().clone());
		newLog.getClassifiers().addAll(oldLog.getClassifiers());
		newLog.getExtensions().addAll(oldLog.getExtensions());
		for (XAttribute attr : oldLog.getGlobalEventAttributes()) {
			newLog.getGlobalEventAttributes().add((XAttribute) attr.clone());
		}
		for (XAttribute attr : oldLog.getGlobalTraceAttributes()) {
			newLog.getGlobalTraceAttributes().add((XAttribute) attr.clone());
		}
		return newLog;
	}

	/**
	 * Copies the meta data (classifiers, globals, extension) from the oldLog to
	 * the newLog.
	 * 
	 * @param oldLog
	 * @param newLog
	 */
	public static void copyLogMetadata(XLog oldLog, XLog newLog) {
		newLog.getClassifiers().addAll(oldLog.getClassifiers());
		newLog.getExtensions().addAll(oldLog.getExtensions());
		for (XAttribute attr : oldLog.getGlobalEventAttributes()) {
			newLog.getGlobalEventAttributes().add((XAttribute) attr.clone());
		}
		for (XAttribute attr : oldLog.getGlobalTraceAttributes()) {
			newLog.getGlobalTraceAttributes().add((XAttribute) attr.clone());
		}
	}

	/**
	 * Checks whether both objects implement the same XAttribute interface
	 * 
	 * @param obj1
	 * @param obj2
	 * @return
	 */
	public static boolean isSameType(XAttribute obj1, XAttribute obj2) {
		if (obj1 instanceof XAttributeList && obj2 instanceof XAttributeList) {
			return true;
		}
		if (obj1 instanceof XAttributeContainer && obj2 instanceof XAttributeContainer) {
			return true;
		}
		if (obj1 instanceof XAttributeLiteral && obj2 instanceof XAttributeLiteral) {
			return true;
		}
		if (obj1 instanceof XAttributeBoolean && obj2 instanceof XAttributeBoolean) {
			return true;
		}
		if (obj1 instanceof XAttributeContinuous && obj2 instanceof XAttributeContinuous) {
			return true;
		}
		if (obj1 instanceof XAttributeDiscrete && obj2 instanceof XAttributeDiscrete) {
			return true;
		}
		if (obj1 instanceof XAttributeTimestamp && obj2 instanceof XAttributeTimestamp) {
			return true;
		}		
		if (obj1 instanceof XAttributeID && obj2 instanceof XAttributeID) {
			return true;
		}	
		return false;
	}

	/**
	 * Returns the value of the {@link XAttribute} as {@link Object}
	 * 
	 * @param attribute
	 * @return value of the attribute
	 */
	public static Object getAttributeValue(XAttribute attribute) {
		if (attribute instanceof XAttributeList) {
			return ((XAttributeList) attribute).getCollection();
		} else if (attribute instanceof XAttributeContainer) {
			return ((XAttributeContainer) attribute).getCollection();
		} else if (attribute instanceof XAttributeLiteral) {
			return ((XAttributeLiteral) attribute).getValue();
		} else if (attribute instanceof XAttributeBoolean) {
			return ((XAttributeBoolean) attribute).getValue();
		} else if (attribute instanceof XAttributeContinuous) {
			return ((XAttributeContinuous) attribute).getValue();
		} else if (attribute instanceof XAttributeDiscrete) {
			return ((XAttributeDiscrete) attribute).getValue();
		} else if (attribute instanceof XAttributeTimestamp) {
			return ((XAttributeTimestamp) attribute).getValue();
		} else if (attribute instanceof XAttributeID) {
			return ((XAttributeID) attribute).getValue();
		} else {
			throw new IllegalArgumentException(""Unexpected attribute type!"");
		}
	}

	/**
	 * Returns the Java class of the {@link XAttribute} value.
	 * 
	 * @param attribute
	 * @return class of the attribute
	 */
	public static Class<?> getAttributeClass(XAttribute attribute) {
		if (attribute instanceof XAttributeLiteral) {
			return String.class;
		} else if (attribute instanceof XAttributeBoolean) {
			return Boolean.class;
		} else if (attribute instanceof XAttributeContinuous) {
			return Double.class;
		} else if (attribute instanceof XAttributeDiscrete) {
			return Long.class;
		} else if (attribute instanceof XAttributeTimestamp) {
			return Date.class;
		} else if (attribute instanceof XAttributeID) {
			return XID.class;
		} else {
			throw new IllegalArgumentException(""Unexpected attribute type!"");
		}
	}

	/**
	 * Creates an appropriate {@link XAttribute}, decided on the type of the
	 * parameter atttributeValue.
	 * 
	 * @param attributeName
	 * @param attributeValue
	 * @return
	 */
	public static XAttribute createAttribute(String attributeName, Object attributeValue) {
		return createAttributeWithFactory(attributeName, attributeValue, XFactoryRegistry.instance().currentDefault());
	}

	/**
	 * Creates an appropriate {@link XAttribute}, decided on the type of the
	 * parameter atttributeValue.
	 * 
	 * @param attributeName
	 * @param attributeValue
	 * @param factory
	 * @return
	 */
	public static XAttribute createAttributeWithFactory(String attributeName, Object attributeValue, XFactory factory) {
		return createAttributeWithFactory(attributeName, attributeValue, null, factory);
	}

	/**
	 * Creates an appropriate {@link XAttribute}, deciding by the type of the
	 * parameter atttributeValue.
	 * 
	 * @param attributeName
	 * @param attributeValue
	 * @param extension
	 * @return a {@link XAttribute} with correct type
	 */
	public static XAttribute createAttribute(String attributeName, Object attributeValue, XExtension extension) {
		return createAttributeWithFactory(attributeName, attributeValue, extension,
				XFactoryRegistry.instance().currentDefault());
	}

	/**
	 * Creates an appropriate {@link XAttribute}, deciding by the type of the
	 * parameter atttributeValue.
	 * 
	 * @param attributeName
	 * @param attributeValue
	 * @param extension
	 * @param factory
	 * @return a {@link XAttribute} with correct type
	 */
	private static XAttribute createAttributeWithFactory(String attributeName, Object attributeValue,
			XExtension extension, XFactory factory) {
		if (attributeValue instanceof Double || attributeValue instanceof Float) {
			return factory.createAttributeContinuous(attributeName, ((Number) attributeValue).doubleValue(), extension);
		} else if (attributeValue instanceof Integer || attributeValue instanceof Long) {
			return factory.createAttributeDiscrete(attributeName, ((Number) attributeValue).longValue(), extension);
		} else if (attributeValue instanceof Date) {
			return factory.createAttributeTimestamp(attributeName, ((Date) attributeValue), extension);
		} else if (attributeValue instanceof Boolean) {
			return factory.createAttributeBoolean(attributeName, ((Boolean) attributeValue), extension);
		} else {
			return factory.createAttributeLiteral(attributeName, attributeValue.toString(), extension);
		}
	}

	/**
	 * Adds multiple {@link XAttribute} to the supplied {@link XAttributable}.
	 * 
	 * @param attributable
	 * @param attributes
	 */
	public static void putAttributes(XAttributable attributable, Iterable<XAttribute> attributes) {
		for (XAttribute a : attributes) {
			putAttribute(attributable, a);
		}
	}

	/**
	 * Adds a single {@link XAttribute} to the supplied {@link XAttributable}.
	 * 
	 * @param attributable
	 * @param attribute
	 */
	public static void putAttribute(XAttributable attributable, XAttribute attribute) {
		attributable.getAttributes().put(attribute.getKey(), attribute);
	}

	/**
	 * Rename the XLog with the label for the ProM provided object
	 * 
	 * @param context
	 * @param log
	 * @return the old name
	 */
	public static String renameLogWithProMLabel(PluginContext context, XLog log) {
		String originalName = getConceptName(log);
		String promLabel = ProvidedObjectHelper.getProvidedObjectLabel(context, log);
		/*
		 * HV: Check whether promLabel equals null. This can happen if the log
		 * at hand is not a provided object.
		 */
		if (promLabel != null && !promLabel.equals(originalName)) {
			XConceptExtension.instance().assignName(log, promLabel);
		}
		return originalName;
	}

	/**
	 * Obtain the event classes from the supplied collection of traces using the
	 * specified classifier. Uses the {@link XEvent} cached in the
	 * {@link XLogInfo} if available and in case the trace are, in fact, a
	 * {@link XLog}.
	 * 
	 * @param classifier
	 * @param traces
	 * @return
	 */
	public static XEventClasses createEventClasses(XEventClassifier classifier, Iterable<XTrace> traces) {
		if (traces instanceof XLog) {
			XLog log = (XLog) traces;
			XLogInfo existingLogInfo = log.getInfo(classifier);
			if (existingLogInfo != null) {
				return existingLogInfo.getEventClasses();
			}
		}
		return deriveEventClasses(classifier, traces);
	}

	private static XEventClasses deriveEventClasses(XEventClassifier classifier, Iterable<XTrace> traces) {
		XEventClasses classes = new XEventClasses(classifier);
		for (XTrace trace : traces) {
			classes.register(trace);
		}
		classes.harmonizeIndices();
		return classes;
	}

	public static Set<String> getEventAttributeKeys(Iterable<XTrace> traces) {
		Set<String> attributeKeys = new HashSet<>();
		for (XTrace t : traces) {
			for (XEvent e : t) {
				attributeKeys.addAll(e.getAttributes().keySet());
			}
		}
		return attributeKeys;
	}

	public static Map<String, Class<?>> getEventAttributeTypes(Iterable<XTrace> traces) {
		Map<String, Class<?>> attributeTypes = new HashMap<String, Class<?>>();
		for (XTrace t : traces) {
			for (XEvent e : t) {
				for (XAttribute a : e.getAttributes().values()) {
					fillAttributeType(attributeTypes, a);
				}
			}
		}
		return attributeTypes;
	}

	public static Set<String> getTraceAttributeKeys(Iterable<XTrace> traces) {
		Set<String> attributeKeys = new HashSet<>();
		for (XTrace t : traces) {
			attributeKeys.addAll(t.getAttributes().keySet());
		}
		return attributeKeys;
	}

	public static Map<String, Class<?>> getTraceAttributeTypes(Iterable<XTrace> traces) {
		Map<String, Class<?>> attributeTypes = new HashMap<String, Class<?>>();
		for (XTrace t : traces) {
			for (XAttribute a : t.getAttributes().values()) {
				fillAttributeType(attributeTypes, a);
			}
		}
		return attributeTypes;
	}

	private static void fillAttributeType(Map<String, Class<?>> attributeTypes, XAttribute attribute) {
		if (!attributeTypes.containsKey(attribute.getKey())) {
			attributeTypes.put(attribute.getKey(), getAttributeClass(attribute));
		}
	}

	/**
	 * Groups traces in a {@link ListMultimap} by their event classification. A
	 * {@link ListMultimap} instead of an {@link SetMultimap} is returned as the
	 * input traces are not required to be a {@link Set}.
	 * 
	 * @param traces
	 * @param classifier
	 * @return
	 */
	public static ImmutableListMultimap<TraceVariantByClassifier, XTrace> getVariantsByClassifier(
			Iterable<XTrace> traces, XEventClassifier classifier) {
		final XEventClasses eventClasses = XUtils.createEventClasses(new XEventNameClassifier(), traces);
		return getVariantsByClassifier(traces, eventClasses);
	}

	public static int countVariantsByClassifier(Iterable<XTrace> traces, XEventClassifier classifier) {
		final XEventClasses eventClasses = XUtils.createEventClasses(new XEventNameClassifier(), traces);
		return countVariantsByClassifier(traces, eventClasses);
	}

	/**
	 * Groups traces in a {@link ListMultimap} by their event classification. A
	 * {@link ListMultimap} instead of an {@link SetMultimap} is returned as the
	 * input traces are not required to be a {@link Set}.
	 * 
	 * @param traces
	 * @param eventClasses
	 * @return
	 */
	public static ImmutableListMultimap<TraceVariantByClassifier, XTrace> getVariantsByClassifier(
			Iterable<XTrace> traces, final XEventClasses eventClasses) {
		return getVariants(traces, new Function<XTrace, TraceVariantByClassifier>() {

			public TraceVariantByClassifier apply(XTrace trace) {
				return new TraceVariantByClassifier(trace, eventClasses);
			}

		});
	}

	public static int countVariantsByClassifier(Iterable<XTrace> traces, final XEventClasses eventClasses) {
		return countVariants(traces, new Function<XTrace, TraceVariantByClassifier>() {

			public TraceVariantByClassifier apply(XTrace trace) {
				return new TraceVariantByClassifier(trace, eventClasses);
			}

		});
	}

	/**
	 * Groups traces in a {@link ListMultimap} by a generic {@link Function}. A
	 * {@link ListMultimap} instead of an {@link SetMultimap} is returned as the
	 * input traces are not required to be a {@link Set}.
	 * 
	 * @param traces
	 * @param variantFunction
	 * @return
	 */
	public static <T extends TraceVariant<E>, E> ImmutableListMultimap<T, XTrace> getVariants(Iterable<XTrace> traces,
			Function<XTrace, T> variantFunction) {
		return Multimaps.index(traces, variantFunction);
	}

	public static <T extends TraceVariant<?>> int countVariants(Iterable<XTrace> traces,
			Function<XTrace, T> variantFunction) {
		return ImmutableSet.copyOf(Iterables.transform(traces, variantFunction)).size();
	}

}"
XContextMonitoredInputStream.java,log,"package org.processmining.plugins.log;

import java.io.InputStream;

import org.processmining.framework.plugin.Progress;
import org.processmining.framework.util.progress.XMonitoredInputStream;
import org.processmining.framework.util.progress.XProgressListener;

public class XContextMonitoredInputStream extends XMonitoredInputStream {

	public XContextMonitoredInputStream(InputStream input, long fileSizeInBytes, final Progress progress) {
		super(input, fileSizeInBytes, new XProgressListener() {

			public void updateProgress(int p, int max) {
				if (progress.isIndeterminate() && (max > 0)) {
					progress.setMinimum(0);
					progress.setMaximum(max);
					progress.setIndeterminate(false);
				} else if (progress.getMaximum() != max) {
					progress.setMaximum(max);
				}
				progress.setValue(p);
			}

			public boolean isAborted() {
				return progress.isCancelled();
			}

		});
	}

}
"
IdentitiesMissingException.java,log,"package org.processmining.log.xes.extensions.id;

import java.util.Collection;

import org.deckfour.xes.model.XAttributable;

public class IdentitiesMissingException extends Exception {

	/**
	 * 
	 */
	private static final long serialVersionUID = 8593596865075088429L;
	
	private Collection<XAttributable> missing;

	public IdentitiesMissingException() {
		super(""Not all elements in the log have an identifier"");
	}
	
	public IdentitiesMissingException(Collection<XAttributable> missing) {
		this();
		
		this.missing = missing;
	}
	
}
"
IdentityConnection.java,log,"package org.processmining.log.xes.extensions.id;

import java.util.HashMap;
import java.util.Map;

import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.id.XID;
import org.deckfour.xes.model.XAttributable;
import org.deckfour.xes.model.XLog;
import org.processmining.framework.connections.impl.AbstractConnection;


/**
 * This class provides a mapping for the identity of XAttributeable elements. 
 * Given an ID, it returns the corresponding XAttributeable element.
 * 
 * TODO 
 * 
 * @author jvdwerf
 *
 */
public class IdentityConnection extends AbstractConnection {

	private final Map<String,XAttributable> idmapping;
	
	private final String LOG = ""LOG"";
	
	public IdentityConnection(XLog log) throws IdentitiesMissingException {
		super(""Identity connection for "" + 
				(XConceptExtension.instance().extractName(log) == null ? log.toString() : XConceptExtension.instance().extractName(log))				
		);
		
		IdentityMappingVisitor visitor = new IdentityMappingVisitor();
		log.accept(visitor);
		if (!visitor.allLogElementsHaveIdentifier()) {
			throw new IdentitiesMissingException(visitor.getElementsWithoutIdentity());
		}
		this.idmapping = visitor.getMapping();
		
		put(LOG, log);
	}
	
	
	
	public IdentityConnection(XLog log, Map<String,XAttributable> idmapping) {
		super(""Identity connection for "" + 
				(XConceptExtension.instance().extractName(log) == null ? log.toString() : XConceptExtension.instance().extractName(log))				
		);
		
		this.idmapping = new HashMap<String, XAttributable>(idmapping);
		
		put(LOG, log);
	}
	
	public XAttributable getElement(String id) {
		return idmapping.get(id);
	}
	
	public XAttributable getElement(XID id) {
		return getElement(id.toString());
	}
	
	public XLog getLog() {
		return (XLog) this.get(LOG);
	}
	
}
"
IdentityMappingVisitor.java,log,"package org.processmining.log.xes.extensions.id;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.deckfour.xes.extension.std.XIdentityExtension;
import org.deckfour.xes.id.XID;
import org.deckfour.xes.model.XAttributable;
import org.deckfour.xes.model.XAttribute;
import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.deckfour.xes.model.XVisitor;

/**
 * This visitor creates a mapping for the identities.
 * @author jvdwerf
 *
 */
class IdentityMappingVisitor extends XVisitor {

	private Map<String, XAttributable> idmap;
	private List<XAttributable> missing;
	
	//these are just standard
	public boolean precondition() { 
		return true; 
	}
	
	public void init(XLog log) {
		idmap = new HashMap<String, XAttributable>();
		missing = new ArrayList<XAttributable>();
	}
	
	public Map<String, XAttributable> getMapping() {
		return idmap;
	}
	
	public Collection<XAttributable> getElementsWithoutIdentity() {
		return missing;
	}
	
	public boolean allLogElementsHaveIdentifier() {
		return (missing.size() == 0);
	}
	
	@Override
	public void visitLogPre(XLog log) {
		visitXAttributable(log);
	}
	
	@Override
	public void visitTracePre(XTrace trace, XLog log) {
		visitXAttributable(trace);
	}
	
	@Override
	public void visitEventPre(XEvent event, XTrace trace) {
		visitXAttributable(event);
	}
	
	@Override
	public void visitAttributePre(XAttribute attr, XAttributable parent) {
		if (attr.getKey().equals(XIdentityExtension.KEY_ID)) {
			return;
		}
		
		visitXAttributable(attr);
	}
	
	private void visitXAttributable(XAttributable target) {
		XID id = XIdentityExtension.instance().extractID(target);
		if (id != null) {
			idmap.put(id.toString(), target);
		} else {
			missing.add(target);
		}
	}
}"
XPathExecutor.java,log,"package org.processmining.log.xpath.engine.ui;

import java.io.IOException;

import javax.swing.JComponent;

import org.deckfour.xes.model.XLog;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.contexts.uitopia.annotations.Visualizer;
import org.processmining.framework.connections.ConnectionCannotBeObtained;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.log.xes.extensions.id.IdentitiesMissingException;

/**
 * 
 * ""Vizualises"" a log so that XPath queries can be executed.
 * 
 * @author jvdwerf
 *
 */

public class XPathExecutor {

	@Visualizer(name = ""XPath executor"")
	@Plugin(name = ""XPath executor"", parameterLabels = ""XLog Event Log"", returnTypes = JComponent.class, returnLabels = ""XPath executor"", userAccessible = false)
	public JComponent showXPathExecutor(UIPluginContext context, XLog source) {

		try {
			return new XPathExecutorPanel(context, source);
		} catch (IdentitiesMissingException e) {
			try {
				XLog log = context.tryToFindOrConstructFirstNamedObject(XLog.class, ""Add identity attribute"", null,
						null, source);
				return new XPathExecutorPanel(context, log);
			} catch (ConnectionCannotBeObtained e1) {
			} catch (IdentitiesMissingException e1) {
				e1.printStackTrace();
			} catch (IOException e1) {
				e1.printStackTrace();
			}
		} catch (IOException e) {
			e.printStackTrace();
		}

		context.getFutureResult(0).cancel(true);
		return null;
	}
}
"
XPathExecutorPanel.java,log,"package org.processmining.log.xpath.engine.ui;

import java.awt.BorderLayout;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.InputMethodEvent;
import java.awt.event.InputMethodListener;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.List;
import java.util.Stack;
import java.util.logging.Level;
import java.util.logging.Logger;

import javax.swing.JButton;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.event.TableModelListener;
import javax.swing.table.DefaultTableCellRenderer;
import javax.swing.table.TableModel;

import org.deckfour.xes.extension.std.XIdentityExtension;
import org.deckfour.xes.model.XAttributable;
import org.deckfour.xes.model.XAttribute;
import org.deckfour.xes.model.XAttributeMap;
import org.deckfour.xes.model.XLog;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.util.Pair;
import org.processmining.framework.util.ui.widgets.ProMHeaderPanel;
import org.processmining.framework.util.ui.widgets.ProMSplitPane;
import org.processmining.framework.util.ui.widgets.ProMTable;
import org.processmining.framework.util.ui.widgets.ProMTextArea;
import org.processmining.framework.util.ui.widgets.ProMTextField;
import org.processmining.log.xes.extensions.id.IdentitiesMissingException;
import org.processmining.log.xpath.engine.XPathEngine;

import com.fluxicon.slickerbox.factory.SlickerFactory;

import net.sf.saxon.s9api.SaxonApiException;

public class XPathExecutorPanel extends JPanel {

	/**
	 * 
	 */
	private static final long serialVersionUID = 8961837431111952562L;

	private final XLog _log;
	private final PluginContext _context;

	private XPathEngine _engine;

	private ProMSplitPane splitter;
	private ProMTextArea errorText;
	private JPanel topPanel;
	private JPanel queryPanel;
	private ProMTextField queryText;
	private ProMTextField relQueryText;
	private JPanel buttonPanel;
	private JButton queryButton;
	private JButton clearButton;
	private JLabel resultCounter;

	private JPanel queryHistory;
	private JButton prevQuery;
	private JButton nextQuery;

	private ProMTable table;

	private Stack<Pair<String, String>> queryPast = new Stack<Pair<String, String>>();
	private Stack<Pair<String, String>> queryFuture = new Stack<Pair<String, String>>();

	private JPanel bottomPanel;
	private ProMSplitPane bottomSplitter;
	private JPanel bottomRight;

	private Logger logging;

	public XPathExecutorPanel(final PluginContext context, final XLog log)
			throws IdentitiesMissingException, IOException {
		_log = log;
		_context = context;

		_engine = new XPathEngine(_context, _log);

		logging = Logger.getLogger(""XPathExecutor"");
		logging.setLevel(Level.FINEST);

		initializeUI();
	}

	public XLog getLog() {
		return _log;
	}

	public PluginContext getContext() {
		return _context;
	}

	protected XPathEngine getEngine() {
		return _engine;
	}

	private void initializeUI() {
		this.setLayout(new BorderLayout());

		setTopPanel();
		setBottomPanel();
		setSplitter();
	}

	private void setTopPanel() {
		topPanel = new JPanel(new BorderLayout());

		setQueryPanel();
		topPanel.add(queryPanel, BorderLayout.CENTER);

		buttonPanel = new JPanel();
		queryButton = SlickerFactory.instance().createButton(""Query"");
		queryButton.addActionListener(new ActionListener() {

			public void actionPerformed(ActionEvent e) {
				executeQuery(queryText.getText(), relQueryText.getText());
			}
		});

		clearButton = SlickerFactory.instance().createButton(""Clear"");
		clearButton.addActionListener(new ActionListener() {

			public void actionPerformed(ActionEvent e) {
				executeClear();
			}
		});

		resultCounter = SlickerFactory.instance().createLabel("""");

		buttonPanel.add(queryButton);
		buttonPanel.add(clearButton);
		buttonPanel.add(resultCounter);
		topPanel.add(buttonPanel, BorderLayout.SOUTH);
	}

	private void setBottomPanel() {

		bottomPanel = new JPanel(new BorderLayout());

		bottomRight = new JPanel(new BorderLayout());
		errorText = new ProMTextArea(false);

		bottomSplitter = new ProMSplitPane(ProMSplitPane.HORIZONTAL_SPLIT);
		bottomSplitter.setLeftComponent(errorText);
		bottomSplitter.setRightComponent(bottomRight);

		bottomPanel.add(bottomSplitter);
	}

	private void setSplitter() {

		splitter = new ProMSplitPane(ProMSplitPane.VERTICAL_SPLIT);
		splitter.setTopComponent(topPanel);
		splitter.setBottomComponent(bottomPanel);
		add(splitter, BorderLayout.CENTER);
	}

	private void setQueryPanel() {
		queryPanel = new JPanel(new BorderLayout());

		JPanel qr = new JPanel(new BorderLayout());

		queryText = new ProMTextField();
		queryText.setText(""//trace"");
		relQueryText = new ProMTextField();

		InputMethodListener l = new InputMethodListener() {

			public void inputMethodTextChanged(InputMethodEvent event) {
				if (event.getCommittedCharacterCount() > 0) {
					resetQueryFuture();
				}
			}

			public void caretPositionChanged(InputMethodEvent event) {
			}
		};

		queryText.addInputMethodListener(l);
		relQueryText.addInputMethodListener(l);

		qr.add(queryText, BorderLayout.NORTH);
		qr.add(relQueryText, BorderLayout.SOUTH);

		queryPanel.add(qr, BorderLayout.CENTER);

		queryHistory = new JPanel(new BorderLayout());

		prevQuery = SlickerFactory.instance().createButton(""<"");
		prevQuery.addActionListener(new ActionListener() {

			public void actionPerformed(ActionEvent e) {
				setPrevQuery();
			}
		});

		nextQuery = SlickerFactory.instance().createButton("">"");
		nextQuery.setEnabled(false);
		nextQuery.addActionListener(new ActionListener() {

			public void actionPerformed(ActionEvent e) {
				setNextQuery();
			}
		});

		queryHistory.add(prevQuery, BorderLayout.NORTH);
		queryHistory.add(nextQuery, BorderLayout.SOUTH);

		queryPanel.add(queryHistory, BorderLayout.EAST);
	}

	private boolean queryChanged = false;

	public boolean isQueryChanged() {
		return queryChanged;
	}

	private void setPrevQuery() {

		if (!queryPast.isEmpty()) {
			queryFuture.push(new Pair<String, String>(queryText.getText(), relQueryText.getText()));

			Pair<String, String> pop = queryPast.pop();
			queryText.setText(pop.getFirst());
			relQueryText.setText(pop.getSecond());
		}

		prevQuery.setEnabled(!(queryPast.isEmpty()));
		nextQuery.setEnabled(true);

		queryChanged = false;
	}

	private void setNextQuery() {
		if (!queryFuture.isEmpty()) {
			queryPast.push(new Pair<String, String>(queryText.getText(), relQueryText.getText()));

			Pair<String, String> pop = queryFuture.pop();
			queryText.setText(pop.getFirst());
			relQueryText.setText(pop.getSecond());
		}

		nextQuery.setEnabled(!(queryFuture.isEmpty()));
		prevQuery.setEnabled(true);

		queryChanged = false;
	}

	private void resetQueryFuture() {
		queryFuture.clear();
		nextQuery.setEnabled(false);
	}

	private void executeClear() {
		queryText.setText("""");
		relQueryText.setText("""");
		errorText.setText("""");
		resultCounter.setText("""");
		bottomSplitter.setLeftComponent(errorText);
		bottomSplitter.setRightComponent(bottomRight);

		repaint();
	}

	private void executeQuery(String query, String relQuery) {
		queryPast.add(new Pair<String, String>(query, relQuery));

		long start = Calendar.getInstance().getTimeInMillis();
		logging.log(Level.INFO, ""start query '"" + query + ""'"");

		//get solution
		SolutionTable solTable = null;

		String error = """";

		if (relQuery.equals("""")) {
			List<XAttributable> solution = null;
			try {
				solution = getEngine().query(query, true);
			} catch (SaxonApiException e) {
				error = e.getMessage();
			}

			if (solution != null) {

				solTable = new SolutionTable(false);
				solTable.setSingleSolution(solution);

			}

		} else {

			List<Pair<XAttributable, XAttributable>> solution = null;
			try {
				solution = getEngine().query(query, relQuery, true);
			} catch (SaxonApiException e) {
				error = e.getMessage();
			}

			if (solution != null) {
				solTable = new SolutionTable(true);
				solTable.setPairSolution(solution);
			}
		}

		long end = Calendar.getInstance().getTimeInMillis();
		logging.log(Level.INFO, ""end query. Duration: '"" + (end - start) + "" ms"");

		if (solTable == null) {

			errorText.setText(error);
			resultCounter.setText(""Errors found"");
			bottomSplitter.setLeftComponent(errorText);
			bottomSplitter.setRightComponent(bottomRight);

		} else {
			//populate result table
			table = new ProMTable(solTable);
			table.getTable().setDefaultRenderer(XAttributable.class, new XAttributableRenderer());

			table.getTable().addMouseListener(new MouseListener() {

				public void mouseReleased(MouseEvent e) {
				}

				public void mousePressed(MouseEvent e) {
				}

				public void mouseExited(MouseEvent e) {
				}

				public void mouseEntered(MouseEvent e) {
				}

				public void mouseClicked(MouseEvent e) {
					int row = table.getTable().rowAtPoint(e.getPoint());
					int col = table.getTable().columnAtPoint(e.getPoint());

					if ((row >= 0 && row <= table.getTable().getRowCount())
							&& (col >= 0 && col <= table.getTable().getColumnCount())) {
						setPropertiesTable(table.getValueAt(row, col));
					}
				}
			});

			bottomSplitter.setLeftComponent(table);
			bottomSplitter.setRightComponent(bottomRight);
			resultCounter.setText(""Solutions found: "" + solTable.getRowCount());
		}

		repaint();
	}

	private void setPropertiesTable(Object value) {
		if (value instanceof XAttributable) {
			XAttributable parent = (XAttributable) value;

			ProMHeaderPanel php;
			if (value instanceof XAttribute) {
				XAttribute attr = (XAttribute) parent;
				php = new ProMHeaderPanel(""Attribute: "" + attr.getKey() + "" (value: "" + attr.toString() + "")"");
			} else {
				php = new ProMHeaderPanel(value.getClass().getSimpleName());
			}

			ProMTable propTable = new ProMTable(new PropertiesTable(parent));
			propTable.getTable().setDefaultRenderer(XAttribute.class, new XAttributeRender());
			php.add(propTable);
			bottomSplitter.setRightComponent(php);
		}
	}

	private class PropertiesTable implements TableModel {

		private XAttributeMap attrMap;
		private List<String> keys;

		public PropertiesTable(XAttributable parent) {

			attrMap = parent.getAttributes();
			keys = new ArrayList<String>(attrMap.keySet());

		}

		public int getRowCount() {
			return keys.size();
		}

		public int getColumnCount() {
			return 2;
		}

		public String getColumnName(int columnIndex) {
			switch (columnIndex) {
				case 0 :
					return ""Attribute"";
				case 1 :
					return ""Value"";
				default :
					return ""ERROR FIELD"";
			}
		}

		public Class<?> getColumnClass(int columnIndex) {
			switch (columnIndex) {
				case 0 :
					return String.class;
				case 1 :
					return XAttribute.class;
				default :
					return null;
			}
		}

		public boolean isCellEditable(int rowIndex, int columnIndex) {
			return false;
		}

		public Object getValueAt(int rowIndex, int columnIndex) {
			switch (columnIndex) {
				case 0 :
					return keys.get(rowIndex);
				case 1 :
					return attrMap.get(keys.get(rowIndex));
			}
			return null;
		}

		public void setValueAt(Object aValue, int rowIndex, int columnIndex) {
		}

		public void addTableModelListener(TableModelListener l) {
		}

		public void removeTableModelListener(TableModelListener l) {
		}

	}

	private class XAttributeRender extends DefaultTableCellRenderer {

		private static final long serialVersionUID = -4820042181333426306L;

		public void setValue(Object value) {
			if (value == null) {
				super.setValue(""Not set"");
			} else {
				if (value instanceof XAttribute) {
					super.setValue(value);
				} else {
					super.setValue(value);
				}
			}
		}

	}

	private class XAttributableRenderer extends DefaultTableCellRenderer {

		private static final long serialVersionUID = -4649231822102709523L;

		public void setValue(Object value) {
			if (value instanceof XAttributable) {
				super.setValue(XIdentityExtension.instance().extractID((XAttributable) value));
			} else {
				super.setValue(value);
			}
		}
	}

	private class SolutionTable implements TableModel {

		private List<Pair<XAttributable, XAttributable>> pairSolution;

		private boolean pairs;

		List<XAttributable> sol;

		public SolutionTable(boolean pairs) {
			this.pairs = pairs;
		}

		public void setPairSolution(List<Pair<XAttributable, XAttributable>> solution) {
			pairSolution = solution;
		}

		public void setSingleSolution(List<XAttributable> solution) {
			sol = solution;
		}

		public int getRowCount() {
			if (pairs)
				return pairSolution.size();
			else
				return sol.size();
		}

		public int getColumnCount() {
			if (pairs) {
				return 2;
			} else {
				return 1;
			}
		}

		public String getColumnName(int columnIndex) {
			switch (columnIndex) {
				case 0 :
					return ""First"";
				case 1 :
					return ""Second"";
				default :
					return ""Wrong"";
			}
		}

		public Class<?> getColumnClass(int columnIndex) {
			return XAttributable.class;
		}

		public boolean isCellEditable(int rowIndex, int columnIndex) {
			return false;
		}

		public Object getValueAt(int rowIndex, int columnIndex) {
			XAttributable attr = null;

			if (pairs) {
				Pair<XAttributable, XAttributable> item = pairSolution.get(rowIndex);

				if (item == null) {
					return null;
				}

				switch (columnIndex) {
					case 0 :
						attr = item.getFirst();
						break;
					case 1 :
						attr = item.getSecond();
						break;
				}

			} else {
				attr = sol.get(rowIndex);
			}
			return attr;

			//if (attr == null)
			//	return null;
			//else
			//	return XIdentityExtension.instance().extractID(attr);
		}

		public void setValueAt(Object aValue, int rowIndex, int columnIndex) {
		}

		public void addTableModelListener(TableModelListener l) {
		}

		public void removeTableModelListener(TableModelListener l) {
		}

	}

}
"
XPathEngine.java,log,"package org.processmining.log.xpath.engine;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.Set;

import org.deckfour.xes.extension.std.XIdentityExtension;
import org.deckfour.xes.model.XAttributable;
import org.deckfour.xes.model.XLog;
import org.processmining.framework.connections.ConnectionCannotBeObtained;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.PluginParameterBinding;
import org.processmining.framework.plugin.events.Logger.MessageLevel;
import org.processmining.framework.util.Pair;
import org.processmining.log.xes.extensions.id.IdentitiesMissingException;
import org.processmining.log.xes.extensions.id.IdentityConnection;
import org.processmining.plugins.log.exporting.ExportLogXes;

import net.sf.saxon.s9api.Axis;
import net.sf.saxon.s9api.DocumentBuilder;
import net.sf.saxon.s9api.Processor;
import net.sf.saxon.s9api.QName;
import net.sf.saxon.s9api.SaxonApiException;
import net.sf.saxon.s9api.WhitespaceStrippingPolicy;
import net.sf.saxon.s9api.XPathCompiler;
import net.sf.saxon.s9api.XPathSelector;
import net.sf.saxon.s9api.XdmItem;
import net.sf.saxon.s9api.XdmNode;
import net.sf.saxon.s9api.XdmSequenceIterator;

public class XPathEngine {

	private XLog log;
	private PluginContext context;
	private IdentityConnection idConnection;
	private XdmNode logXMLDoc;
	private XPathCompiler xpath;
	private File logFile;

	private String logNameSpace = ""http://www.xes-standard.org/"";

	private static QName KEYNAME = new QName(""key"");
	private static QName VALUENAME = new QName(""value"");
	private static QName IDNode = new QName("""", ""http://www.xes-standard.org/"", ""id"");

	public void setLogNameSpace(String namespace) {
		logNameSpace = namespace;

		IDNode = new QName("""", namespace, ""id"");
	}

	public String getLogNameSpace() {
		return logNameSpace;
	}

	public XPathEngine(PluginContext context, XLog log) throws IdentitiesMissingException, IOException {
		this.context = context;
		setLog(log);

		init();
	}

	public XLog getLog() {
		return log;
	}

	private void setLog(XLog log) throws IdentitiesMissingException {
		this.log = log;

		//get the connection
		try {
			Collection<IdentityConnection> cons = context.getConnectionManager()
					.getConnections(IdentityConnection.class, context, log);
			//context.log(""I found: "" + cons.size() + "" connections"", MessageLevel.DEBUG );

			for (IdentityConnection con : cons) {
				idConnection = con;
				break;
			}

		} catch (ConnectionCannotBeObtained e) {
			//context.log(""No connection found :-( We need to create one"", MessageLevel.DEBUG );
			idConnection = new IdentityConnection(log);

			context.addConnection(idConnection);
		}

	}

	private void init() throws IOException {
		//transform the log into a XES XML file

		PluginContext child = context.createChildContext(""export xes"");
		logFile = File.createTempFile(""ProM"", "".xes"");

		context.log(""Created temporary file: "" + logFile.getAbsolutePath(), MessageLevel.DEBUG);

		Set<PluginParameterBinding> plugins = context.getPluginManager().getPluginsAcceptingOrdered(child.getClass(),
				false, log.getClass(), File.class);

		//export log to temporary file
		(new ExportLogXes()).export(null, log, logFile);

		//and load the generated document in the XPath engine
		Processor proc = new Processor(false);
		xpath = proc.newXPathCompiler();
		xpath.declareNamespace("""", getLogNameSpace());

		DocumentBuilder builder = proc.newDocumentBuilder();
		builder.setLineNumbering(true);
		builder.setWhitespaceStrippingPolicy(WhitespaceStrippingPolicy.ALL);

		try {
			logXMLDoc = builder.build(logFile);

		} catch (SaxonApiException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

	}

	public List<Pair<XAttributable, XAttributable>> query(String query, String relQuery) {

		try {
			return query(query, relQuery, false);
		} catch (SaxonApiException e) {
		}

		return null;
	}

	public List<Pair<XAttributable, XAttributable>> query(String query, String relQuery, boolean throwException)
			throws SaxonApiException {
		try {
			return query(logXMLDoc, query, relQuery);
		} catch (SaxonApiException e) {
			if (throwException) {
				throw e;
			}
		}
		return null;
	}

	protected List<Pair<XAttributable, XAttributable>> query(XdmNode startNode, String query, String relQuery)
			throws SaxonApiException {
		List<Pair<XAttributable, XAttributable>> results = new ArrayList<Pair<XAttributable, XAttributable>>();

		XPathSelector selector;

		selector = xpath.compile(query).load();

		selector.setContextItem(startNode);

		int counter = 0;

		for (XdmItem item : selector) {
			XAttributable first = getItem(item);

			//now create a second selector
			XPathSelector relSel = xpath.compile(relQuery).load();
			relSel.setContextItem(item);

			for (XdmItem relItem : relSel) {
				XAttributable second = getItem(relItem);

				results.add(new Pair<XAttributable, XAttributable>(first, second));
				counter++;
			}

		}

		System.out.println(""Counter: "" + counter);

		return results;
	}

	/**
	 * Main function that actually queries the log object.
	 * 
	 * @param query
	 * @return
	 */
	public List<XAttributable> query(String query) {
		try {
			return query(query, false);
		} catch (SaxonApiException e) {
		}
		return null;
	}

	public List<XAttributable> query(String query, boolean throwException) throws SaxonApiException {
		try {
			return query(logXMLDoc, query);
		} catch (SaxonApiException e) {
			if (throwException) {
				throw e;
			}
		}

		return null;
	}

	protected List<XAttributable> query(XdmNode startNode, String query) throws SaxonApiException {
		//execute the query. Look whether the internal things have an ID...
		XPathSelector selector;

		selector = xpath.compile(query).load();

		selector.setContextItem(startNode);

		List<XAttributable> result = new ArrayList<XAttributable>();

		int counter = 0;

		for (XdmItem item : selector) {
			//check whether each element has an id.
			//if you find an id, use it :-)

			XAttributable target = getItem(item);
			counter++;
			if (target != null) {
				result.add(target);
			}
		}
		System.out.println(""Counter <single>: "" + counter);
		System.out.println(""   in result set: "" + result.size());

		return result;
	}

	public void close() {
		//remove the log file
		logFile.delete();
	}

	public void finalize() {
		close();
	}

	private XAttributable getItem(XdmItem item) {
		if (item instanceof XdmNode) {
			return getItem((XdmNode) item);
		}
		return null;
	}

	private XAttributable getItem(XdmNode node) {
		//get the type of this element, if it is an id node,
		//get the key, and if the key equals identity:id
		if (node.getNodeName().getLocalName().equals(""id"")) {
			if (node.getAttributeValue(KEYNAME) != null
					&& node.getAttributeValue(KEYNAME).equals(XIdentityExtension.KEY_ID)) {
				return idConnection.getElement(node.getAttributeValue(VALUENAME));
			}
		} else {
			XdmSequenceIterator iterator = node.axisIterator(Axis.CHILD, IDNode);
			while (iterator.hasNext()) {

				XAttributable item = getItem(iterator.next());
				if (item != null) {
					return item;
				}
			}
		}

		return null;
	}

}
"
XSLTTransformer.java,log,"package org.processmining.log.xsl.transformer;

import javax.xml.transform.Source;

import net.sf.saxon.s9api.Processor;
import net.sf.saxon.s9api.SaxonApiException;
import net.sf.saxon.s9api.XsltCompiler;
import net.sf.saxon.s9api.XsltExecutable;

public class XSLTTransformer {

	
	
	private void executeXSLT(Source xslt) {
		
        try {
        	Processor proc = new Processor(false);
            XsltCompiler comp = proc.newXsltCompiler();
            
        	XsltExecutable exp = comp.compile(xslt);
			
			
			
		} catch (SaxonApiException e) {

			e.printStackTrace();
		}
        
		
	}
	
}
"
LogCheckConsistentTypes.java,log,"package org.processmining.log.logchecks.impl;

import java.util.HashMap;
import java.util.Map;

import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.model.XAttribute;
import org.deckfour.xes.model.XAttributeBoolean;
import org.deckfour.xes.model.XAttributeContinuous;
import org.deckfour.xes.model.XAttributeDiscrete;
import org.deckfour.xes.model.XAttributeID;
import org.deckfour.xes.model.XAttributeList;
import org.deckfour.xes.model.XAttributeLiteral;
import org.deckfour.xes.model.XAttributeTimestamp;
import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.log.logchecks.LogCheck;
import org.processmining.log.models.LogCheckerReport;

public class LogCheckConsistentTypes implements LogCheck {

	private enum Type {
		LITERAL(""string""), //
		DISCRETE(""int""), //
		CONTINUOUS(""double""), //
		TIMESTAMP(""date""), // 
		BOOLEAN(""boolean""), //
		ID(""id""), //
		LIST(""list""), //
		UNKNOWN(""unknown""); //

		private String label;

		Type(String label) {
			this.label = label;
		}

		public String toString() {
			return label;
		}
	};

	private static LogCheck instance;

	private LogCheckConsistentTypes() {

	}

	public static LogCheck getInstance() {
		if (instance == null) {
			instance = new LogCheckConsistentTypes();
		}
		return instance;
	}

	public boolean checkTraces(PluginContext context, XLog log, LogCheckerReport report) {
		boolean allOk = true;
		Map<String, Type> traceAttributeTypes = new HashMap<String, Type>();
		for (XAttribute attribute : log.getGlobalTraceAttributes()) {
			Type existingType = traceAttributeTypes.get(attribute.getKey());
			Type type = getType(attribute);
			if (existingType == null) {
				traceAttributeTypes.put(attribute.getKey(), type);
			} else if (type != existingType) {
				report.add(allOk ? ""<h2>Inconsistent types for trace attribute</h2><ul>"" : """");
				report.add(""<li>Global attribute key "" + attribute.getKey() + "": "" + type + "" vs. "" + existingType + ""</li>"");
				allOk = false;
			}
		}
		int traceCtr = 0;
		for (XTrace trace : log) {
			for (XAttribute attribute : trace.getAttributes().values()) {
				Type existingType = traceAttributeTypes.get(attribute.getKey());
				Type type = getType(attribute);
				if (existingType == null) {
					traceAttributeTypes.put(attribute.getKey(), type);
				} else if (type != existingType) {
					String traceId = "" at position "" + traceCtr;
					if (trace.getAttributes().containsKey(XConceptExtension.KEY_NAME)) {
						traceId = XConceptExtension.instance().extractName(trace) + "" "" + traceId;
					} else {
						traceId = ""<i>unknown</i> "" + traceId;
					}
					report.add(allOk ? ""<h2>Inconsistent types for trace attribute</h2><ul>"" : """");
					report.add(""<li>Trace "" + traceId + "", attribute key "" + attribute.getKey() + "": "" + type + "" vs. "" + existingType + ""</li>"");
					allOk = false;
				}
			}
			traceCtr++;
		}
		report.add(allOk ? """" : ""</ul>"");
		return allOk;
	}

	public boolean checkEvents(PluginContext context, XLog log, LogCheckerReport report) {
		boolean allOk = true;
		Map<String, Type> eventAttributeTypes = new HashMap<String, Type>();
		for (XAttribute attribute : log.getGlobalEventAttributes()) {
			Type existingType = eventAttributeTypes.get(attribute.getKey());
			Type type = getType(attribute);
			if (existingType == null) {
				eventAttributeTypes.put(attribute.getKey(), type);
			} else if (type != existingType) {
				report.add(allOk ? ""<h2>Inconsistent types for event attribute</h2><ul>"" : """");
				report.add(""<li>Attribute key "" + attribute.getKey() + "": "" + type + "" vs. "" + existingType + ""</li>"");
				allOk = false;
			}
		}
		int traceCtr = 0;
		for (XTrace trace : log) {
			int eventCtr = 0;
			for (XEvent event : trace) {
				for (XAttribute attribute : event.getAttributes().values()) {
					Type existingType = eventAttributeTypes.get(attribute.getKey());
					Type type = getType(attribute);
					if (existingType == null) {
						eventAttributeTypes.put(attribute.getKey(), getType(attribute));
					} else if (type != existingType) {
						String traceId = "" at position "" + traceCtr;
						if (trace.getAttributes().containsKey(XConceptExtension.KEY_NAME)) {
							traceId = XConceptExtension.instance().extractName(trace) + "" "" + traceId;
						} else {
							traceId = ""<i>unknown</i> "" + traceId;
						}
						String eventId = "" at position "" + eventCtr;
						if (event.getAttributes().containsKey(XConceptExtension.KEY_NAME)) {
							eventId = XConceptExtension.instance().extractName(event) + "" "" + eventId;
						} else {
							eventId = ""<i>unknown</i> "" + eventId;
						}
						report.add(allOk ? ""<h2>Inconsistent types for event attribute</h2><ul>"" : """");
						report.add(""<li>Trace "" + traceId + "", event "" + eventId + "", attribute key "" + attribute.getKey() + "": "" + type + "" vs. "" + existingType + ""</li>"");
						allOk = false;
					}
				}
				eventCtr++;
			}
			traceCtr++;
		}
		report.add(allOk ? """" : ""</ul>"");
		return allOk;
	}

	private Type getType(XAttribute attribute) {
		if (attribute instanceof XAttributeLiteral) {
			return Type.LITERAL;
		} else if (attribute instanceof XAttributeDiscrete) {
			return Type.DISCRETE;
		} else if (attribute instanceof XAttributeTimestamp) {
			return Type.TIMESTAMP;
		} else if (attribute instanceof XAttributeContinuous) {
			return Type.CONTINUOUS;
		} else if (attribute instanceof XAttributeID) {
			return Type.ID;
		} else if (attribute instanceof XAttributeBoolean) {
			return Type.BOOLEAN;
		} else if (attribute instanceof XAttributeList) {
			return Type.LIST;
		}
		return Type.UNKNOWN;
	}

	public boolean check(PluginContext context, XLog log, LogCheckerReport report) {
		boolean okTraces = checkTraces(context, log, report);
		boolean okEvents = checkEvents(context, log, report);
		return okTraces && okEvents;
	}

}
"
LogCheckEventClassifiersGlobal.java,log,"package org.processmining.log.logchecks.impl;

import org.deckfour.xes.classification.XEventClassifier;
import org.deckfour.xes.model.XAttribute;
import org.deckfour.xes.model.XLog;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.log.logchecks.LogCheck;
import org.processmining.log.models.LogCheckerReport;

public class LogCheckEventClassifiersGlobal implements LogCheck {

	private static LogCheck instance;
	
	private LogCheckEventClassifiersGlobal() {
		
	}
	
	public static LogCheck getInstance() {
		if (instance == null) {
			instance = new LogCheckEventClassifiersGlobal();
		}
		return instance;
	}
	
	public boolean check(PluginContext context, XLog log, LogCheckerReport report) {
		boolean checkOk = true;
		for (XEventClassifier classifier : log.getClassifiers()) {
			for (String key : classifier.getDefiningAttributeKeys()) {
				boolean keyFound = false;
				for (XAttribute attribute : log.getGlobalEventAttributes()) {
					keyFound = attribute.getKey().equals(key);
					if (keyFound) {
						break;
					}
				}
				if (!keyFound) {
					String message = checkOk ? ""<h2>Event classifier uses non-global attribute</h2><ul>"" : """";
					checkOk = false;
					message += ""<li>Classifier "" + classifier.name() + "" uses key "" + key + "", but key "" + key + "" is not declared as being global.</li>""; 
					report.add(message);
				}
			}
		}
		if (!checkOk) {
			report.add(""</ul>"");
		}
		return checkOk;
	}

}
"
LogCheckGlobalAttributes.java,log,"package org.processmining.log.logchecks.impl;

import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.model.XAttribute;
import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.log.logchecks.LogCheck;
import org.processmining.log.models.LogCheckerReport;

public class LogCheckGlobalAttributes implements LogCheck {

	private static LogCheck instance;

	private LogCheckGlobalAttributes() {

	}

	public static LogCheck getInstance() {
		if (instance == null) {
			instance = new LogCheckGlobalAttributes();
		}
		return instance;
	}

	public boolean check(PluginContext context, XLog log, LogCheckerReport report) {
		boolean allOk = true;
		int traceCtr = 0;
		int eventCtr = 0;
		for (XTrace trace : log) {
			traceCtr++;
			eventCtr = 0;
			for (XAttribute attribute : log.getGlobalTraceAttributes()) {
				if (!trace.getAttributes().containsKey(attribute.getKey())) {
					if (allOk) {
						report.add(""<h2>Trace/event misses global attributes</h2><ul>"");
					}
					allOk = false;
					String traceId = "" at position "" + traceCtr;
					if (trace.getAttributes().containsKey(XConceptExtension.KEY_NAME)) {
						traceId = XConceptExtension.instance().extractName(trace) + "" "" + traceId;
					} else {
						traceId = ""<i>unknown</i> "" + traceId;
					}
					report.add(""<li>Trace "" + traceId + "" misses global attribute "" + attribute.getKey() + "".</li>"");
				}
			}
			for (XEvent event : trace) {
				eventCtr++;
				for (XAttribute attribute : log.getGlobalEventAttributes()) {
					if (!event.getAttributes().containsKey(attribute.getKey())) {
						if (allOk) {
							report.add(""<h2>Trace/event misses global attributes</h2><ul>"");
						}
						allOk = false;
						String eventId = "" at position "" + eventCtr;
						if (event.getAttributes().containsKey(XConceptExtension.KEY_NAME)) {
							eventId = XConceptExtension.instance().extractName(event) + "" "" + eventId;
						} else {
							eventId = ""<i>unknown</i> "" + eventId;
						}
						String traceId = "" at position "" + traceCtr;
						if (trace.getAttributes().containsKey(XConceptExtension.KEY_NAME)) {
							traceId = XConceptExtension.instance().extractName(trace) + "" "" + traceId;
						} else {
							traceId = ""<i>unknown</i> "" + traceId;
						}
						report.add(
								""<li>Event "" + eventId + "" in trace "" + traceId + "" misses global attribute "" + attribute.getKey() + "".</li>"");
					}
				}
			}
		}
		if (!allOk) {
			report.add(""</ul>"");
		}
		return allOk;
	}

}
"
LogCheck.java,log,"package org.processmining.log.logchecks;

import org.deckfour.xes.model.XLog;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.log.models.LogCheckerReport;

public interface LogCheck {

	public boolean check(PluginContext context, XLog log, LogCheckerReport report);
	
}
"
LogCheckType.java,log,"package org.processmining.log.logchecks;

import org.processmining.log.logchecks.impl.LogCheckConsistentTypes;
import org.processmining.log.logchecks.impl.LogCheckEventClassifiersGlobal;
import org.processmining.log.logchecks.impl.LogCheckGlobalAttributes;

public enum LogCheckType {
	LOG_CHECK_EVENT_CLASSIFIERS_GLOBAL(LogCheckEventClassifiersGlobal.getInstance()),
	LOG_CHECK_GLOBAL_ATTRIBUTE(LogCheckGlobalAttributes.getInstance()),
	LOG_CHECK_CONSISTENT_TYPES(LogCheckConsistentTypes.getInstance());
	
	
	private LogCheck logCheck;
	
	private LogCheckType(LogCheck logCheck) {
		this.logCheck = logCheck;
	}
	
	public LogCheck getLogCheck() {
		return logCheck;
	}
	
	
}
"
LogDirectedGraphConnection.java,log,"package org.processmining.models.connections;

import java.util.Collection;
import java.util.Map;

import org.deckfour.xes.classification.XEventClass;
import org.deckfour.xes.classification.XEventClasses;
import org.deckfour.xes.model.XLog;
import org.processmining.framework.connections.annotations.ConnectionDoesntExistMessage;
import org.processmining.framework.util.Pair;
import org.processmining.models.graphbased.directed.DirectedGraph;
import org.processmining.models.graphbased.directed.DirectedGraphEdge;
import org.processmining.models.graphbased.directed.DirectedGraphNode;

@ConnectionDoesntExistMessage(message = ""No mapping is known between the given XEventClasses and the nodes of the given graph."")
public class LogDirectedGraphConnection extends
		AbstractLogModelConnection<DirectedGraphNode, DirectedGraphEdge<DirectedGraphNode, DirectedGraphNode>> {

	public LogDirectedGraphConnection(XLog log, XEventClasses classes,
			DirectedGraph<DirectedGraphNode, DirectedGraphEdge<DirectedGraphNode, DirectedGraphNode>> graph,
			Collection<Pair<DirectedGraphNode, XEventClass>> relations) {
		super(log, classes, graph, graph.getNodes(), relations);
	}

	public LogDirectedGraphConnection(XLog log, XEventClasses classes,
			DirectedGraph<DirectedGraphNode, DirectedGraphEdge<DirectedGraphNode, DirectedGraphNode>> graph,
			Map<DirectedGraphNode, XEventClass> relations) {
		super(log, classes, graph, graph.getNodes(), relations);
	}

}
"
LogFileFormat.java,log,"package org.processmining.log;

/**
 * Specifies the different possible Log File Formats. Mainly used within
 * RapidProM.
 *
 */
public enum LogFileFormat {
	XES(""xes""), XES_GZ(""xes.gz""), MXML(""mxml""), MXML_GZ(""mxml.gz"");

	private String desc;

	private LogFileFormat(String desc) {
		this.desc = desc;
	}

	@Override
	public String toString() {
		return desc;
	}
}
"
AddSt.java,log,"package org.processmining.plugins.loginsertstart;

import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.Set;
import java.util.TreeSet;

import javax.swing.JPanel;

import org.deckfour.xes.extension.std.XLifecycleExtension;
import org.deckfour.xes.extension.std.XTimeExtension;
import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.framework.util.Pair;

/**
 * Add Start Events
 * 
 * The main class
 * 
 * @author jnakatumba
 * 
 */

public class AddSt {

	private ObtainDurationsWithoutStart withoutStart;
	private ObtainDurationWithStart withStart;
	private AddStMain addStart;
	private AddStSecPanel inPanel;

	private BoxandWhiskerPlot graphing;
	private List<Pair<String, Long>> resDurationList;
	private Set<String> resNamesList;
	private final ArrayList<Date> startDatesList;
	private int addCounter, removeCounter;
	private String displayChoice, outlierChoice;

	private JPanel jPanel;

	private final UIPluginContext context;
	private XLog log;
	private XLog changedLog;

	public AddSt(final UIPluginContext context, XLog log) {
		this.context = context;
		this.log = log;

		jPanel = new JPanel();
		resNamesList = new TreeSet<String>();
		startDatesList = new ArrayList<Date>();
	}

	public AddStVisualizer mine() {

		context.getProgress().setMinimum(0);
		context.getProgress().setIndeterminate(false);

		inPanel = new AddStSecPanel(context);
		jPanel = inPanel.getPanel();

		/**
		 * Display the first Panel
		 */
		context.showConfiguration(""Insert Missing Events"", jPanel);
		displayChoice = inPanel.getDisplayChoice();

		/**
		 * Check if the log has any start events
		 */
		for (XTrace trace : log) {
			for (XEvent event : trace) {
				if (XLifecycleExtension.instance().extractTransition(event).equals(""start"")) {
					Date startDate = XTimeExtension.instance().extractTimestamp(event);
					startDatesList.add(startDate);

				}
			}
		}

		context.getProgress().inc();
		/**
		 * if the log does not have any start events
		 */
		if (startDatesList.size() == 0) {
			/**
			 * Obtain the durations per activity executed for each resource
			 */
			withoutStart = new ObtainDurationsWithoutStart(log, displayChoice);
			resDurationList = withoutStart.getResDateDetails();
			resNamesList = withoutStart.getResNames();
			/**
			 * Construct a Box-and-Whisker Graph showing the durations per
			 * resource and any outliers
			 */

			graphing = new BoxandWhiskerPlot(context, resDurationList, resNamesList);
			outlierChoice = graphing.getOutlierRange();

			if (outlierChoice != null) {

				/**
				 * Add the start events to the log
				 */
				addStart = new AddStMain(context, log, displayChoice, outlierChoice);
				addCounter = addStart.getAddCounter();
				removeCounter = addStart.getRemoveCounter();
				context.log(""The Number of Start Events Added is: "" + addCounter);
				context.log(""The Number of Events Removed is: "" + removeCounter);
				/**
				 * Get the edited log
				 */
				log = addStart.getLog();
			} else {
				context.getFutureResult(0).cancel(true);

			}

			changedLog = addStart.getLog();
			/**
			 * if the log has some start events
			 */
		} else {
			withStart = new ObtainDurationWithStart(context, log);
			resDurationList = withStart.getResDateDetails();
			resNamesList = withStart.getResNames();
			/**
			 * Construct a Box-and-Whisker Graph showing the durations per
			 * resource and any outliers
			 */

			graphing = new BoxandWhiskerPlot(context, resDurationList, resNamesList);
			outlierChoice = graphing.getOutlierRange();
			if (outlierChoice != null) {
				/**
				 * Add the start events to the log
				 */
				addStart = new AddStMain(context, log, displayChoice, outlierChoice);
				addCounter = addStart.getAddCounter();
				removeCounter = addStart.getRemoveCounter();
				context.log(""The Number of Start Events Added is: "" + addCounter);
				context.log(""The Number of Events Removed is: "" + removeCounter);
				changedLog = addStart.getLog();

			} else {
				context.getFutureResult(0).cancel(true);

			}

		}

		AddStVisualizer output = new AddStVisualizer();
		output.setLog(changedLog);
		return output;
	}

}
"
AddStEvents.java,log,"package org.processmining.plugins.loginsertstart;

import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.List;
import java.util.ListIterator;

import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.extension.std.XLifecycleExtension;
import org.deckfour.xes.extension.std.XOrganizationalExtension;
import org.deckfour.xes.extension.std.XTimeExtension;
import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XTrace;
import org.processmining.framework.util.Pair;
import org.processmining.framework.util.collection.ComparablePair;

/**
 * Add Start Events
 * 
 * This is the class where the start events are actually added to the event log
 * 
 * @author jnakatumba
 * 
 */

public class AddStEvents {
	private final XTrace trace;
	private final String transition = ""start"";

	private final List<ComparablePair<String, Date>> cidDateList;
	private final List<ComparablePair<String, Date>> resDateList;
	private ComparablePair<String, Date> cidDate;
	private ComparablePair<String, Date> prevPair, prevPairCase;
	private final List<Pair<String, String>> startEventsList;
	private final List<Pair<String, String>> completeEventsList;
	private final List<Pair<String, String>> startEventsList1;
	private final List<Pair<String, String>> completeEventsList1;

	private final ArrayList<XEvent> eventList;
	private final List<XEvent> starts;
	private final List<XEvent> removeEvents;
	private Pair<String, String> typeNamePair;
	private Pair<String, String> startNamePair;
	private Integer removeCount = 0;

	private Date prevCasDate;

	private Long serviceTime = 0L, currentTimeS = 0L;
	private Long prevResTimeS = 0L, prevCasTimeS = 0L;

	private XEvent myEvent;
	private Date cDate, newDate;
	private String rName, caseId;
	private Integer count = 0;
	private final String displayChoice, outlierChoice;
	private String eventType, actName;

	/**
	 * Add start events
	 * 
	 * @param traces
	 *            The trace that is to be edited
	 * @param resDateList
	 *            The list of all the resources in the log and the particular
	 *            dates at which an event execution occurred in the log that was
	 *            done by the resources.
	 */

	public AddStEvents(XTrace trace, List<ComparablePair<String, Date>> resDateList, String displaychoice,
			String outlierChoice, Integer addcounter, Integer rCount) {

		this.resDateList = resDateList;
		displayChoice = displaychoice;
		this.outlierChoice = outlierChoice;
		count = addcounter;
		removeCount = rCount;

		startEventsList = new ArrayList<Pair<String, String>>();
		completeEventsList = new ArrayList<Pair<String, String>>();
		startEventsList1 = new ArrayList<Pair<String, String>>();
		completeEventsList1 = new ArrayList<Pair<String, String>>();
		eventList = new ArrayList<XEvent>();
		starts = new ArrayList<XEvent>();
		removeEvents = new ArrayList<XEvent>();

		cidDateList = new ArrayList<ComparablePair<String, Date>>();
		cidDate = new ComparablePair<String, Date>(null, null);

		/**
		 * Iterate through each trace in the log and see if there are duplicate
		 * events. For example if we have a start event followed by another
		 * start event, and then a complete event, we match the second start
		 * event with the complete event and then discard the first start event
		 */
		for (XEvent event : trace) {
			cDate = XTimeExtension.instance().extractTimestamp(event);
			caseId = XConceptExtension.instance().extractName(trace);
			rName = XOrganizationalExtension.instance().extractResource(event);
			eventType = XLifecycleExtension.instance().extractTransition(event);
			actName = XConceptExtension.instance().extractName(event);
			myEvent = event;
			typeNamePair = new Pair<String, String>(eventType, actName);
			starts.add(myEvent);

			if (eventType.equals(""start"")) {
				if (startEventsList1.contains(typeNamePair) == false) {
					startEventsList1.add(typeNamePair);
				} else {
					for (int i = 0; i < starts.size(); i++) {
						XEvent prevEvent = starts.get(i);
						String actvName = XConceptExtension.instance().extractName(prevEvent);
						if (actvName.equals(actName)
								&& XLifecycleExtension.instance().extractTransition(prevEvent).equals(""start"")) {
							removeEvents.add(prevEvent);
							starts.remove(prevEvent);
						}

					}
				}

			} else if (eventType.equals(""complete"")) {

				if (completeEventsList1.contains(typeNamePair) == false) {
					completeEventsList1.add(typeNamePair);

				} else {
					for (int i = 0; i < starts.size(); i++) {
						XEvent prevEvent = starts.get(i);
						String actvName = XConceptExtension.instance().extractName(prevEvent);
						if (actvName.equals(actName)
								&& XLifecycleExtension.instance().extractTransition(prevEvent).equals(""complete"")) {
							removeEvents.add(prevEvent);
							starts.remove(prevEvent);

						}
					}

				}
			}

		}

		/**
		 * Discard the events that are of the same event type per activity
		 * occurring in a trace
		 */
		for (int i = 0; i < removeEvents.size(); i++) {
			XEvent prevEvent = removeEvents.get(i);
			trace.remove(prevEvent);
			removeCount++;

		}

		/**
		 * Obtain when to insert the start events to the log
		 */
		for (XEvent event : trace) {
			cDate = XTimeExtension.instance().extractTimestamp(event);
			caseId = XConceptExtension.instance().extractName(trace);
			rName = XOrganizationalExtension.instance().extractResource(event);
			eventType = XLifecycleExtension.instance().extractTransition(event);
			actName = XConceptExtension.instance().extractName(event);
			myEvent = event;
			typeNamePair = new Pair<String, String>(eventType, actName);
			init();
			cidDate = getIdDate(caseId, cDate);
			cidDateList.add(cidDate);

		}

		/**
		 * Add the new start events to the event log. These are added before
		 * each complete event observed in the log.
		 */
		for (int i = 0; i < eventList.size(); i++) {
			XEvent events = eventList.get(i);
			String actNames = XConceptExtension.instance().extractName(events);
			int sn = 0;
			now: for (ListIterator<XEvent> eventListIt = trace.listIterator(); eventListIt.hasNext();) {
				if (eventListIt.hasNext() == true) {
					XEvent event = eventListIt.next();
					sn++;
					if (XLifecycleExtension.instance().extractTransition(event).equals(""complete"")) {
						String actName = XConceptExtension.instance().extractName(event);
						if (actNames.equals(actName)) {
							trace.add(sn - 1, events);
							count++;
							break now;
						}

					}
				}

			}
		}

		this.trace = trace;

	}

	/**
	 * Check if a start event in the log can be matched with a corresponding
	 * event and if a start event is missing,i.e., we observe only a complete
	 * event, then we insert it into the log.
	 */
	private void init() {
		if (eventType.equals(""start"")) {
			if (startEventsList.contains(typeNamePair) == false) {
				startEventsList.add(typeNamePair);
				starts.add(myEvent);
			}

		} else if (eventType.equals(""complete"")) {
			if (completeEventsList.contains(typeNamePair) == false) {
				startNamePair = new Pair<String, String>(""start"", actName);

				if (startEventsList.contains(startNamePair) == false) {
					start();

				}
			}

		}
	}

	/**
	 * The durations for each event can be checked based on either the resource
	 * perspective, case of the maximum of both the resource and case
	 * perspective.
	 */

	private void start() {
		if (displayChoice.equals(""Resource perspective"")) {
			getResourceDetails();

		} else if (displayChoice.equals(""Case perspective"")) {
			getServiceTimesOnCase();

		} else if (displayChoice.equals(""Resource/Case perspective"")) {
			getServiceTimesOnAverage();
		}

	}

	/**
	 * Check to see if the current resource executed any event before this one.
	 */
	private void getResourceDetails() {

		String rname;
		Date rDate;
		if (resDateList.size() != 0) {
			search: for (int i = 0; i < resDateList.size(); i++) {
				prevPair = resDateList.get(i);
				rname = prevPair.getFirst();
				rDate = prevPair.getSecond();
				if (rname.equals(rName) == true) {
					if (rDate.compareTo(cDate) == 0) {
						if (i != 0) {
							ComparablePair<String, Date> currentP = resDateList.get(i - 1);
							rname = currentP.getFirst();

							if (rname.equals(rName)) {
								rDate = currentP.getSecond();
								prevResTimeS = rDate.getTime();
								currentTimeS = cDate.getTime();
								serviceTime = currentTimeS - prevResTimeS;
								serviceTime = serviceTime / 1000;
								serviceTime = serviceTime / 60;

								long value = serviceTime.longValue();
								double dValue = Double.valueOf(value);

								if (outlierChoice.equals(""Estimate Values"")) {
									estimateDates(serviceTime);
									break search;

								} else {
									Double outlierRange = Double.valueOf(outlierChoice);
									if (dValue < outlierRange) {
										Date pDate = estimateStartDates(serviceTime);
										XTimeExtension.instance().assignTimestamp(myEvent, pDate);
										eventList.add(myEvent);
										break search;

									} else {
										XTimeExtension.instance().assignTimestamp(myEvent, cDate);
										eventList.add(myEvent);
										break search;

									}

								}

							}
							if (outlierChoice.equals(""Estimate Values"")) {
								estimateDates(serviceTime);
								break search;
							} else {
								XTimeExtension.instance().assignTimestamp(myEvent, cDate);
								eventList.add(myEvent);
								break search;
							}

						}
					}
				}
			}

		}

	}

	/**
	 * Checks the information based on the case perspective and then edits the
	 * event with the new information obtained.
	 */

	private void getServiceTimesOnAverage() {
		String rname;
		Date rDate;
		int listSize = cidDateList.size();
		XOrganizationalExtension.instance().assignResource(myEvent, rName);
		XLifecycleExtension.instance().assignTransition(myEvent, transition);

		if (resDateList.size() != 0) {
			search: for (int i = 0; i < resDateList.size(); i++) {
				prevPair = resDateList.get(i);
				rname = prevPair.getFirst();
				rDate = prevPair.getSecond();
				if (rname.equals(rName) == true) {
					if (rDate.compareTo(cDate) == 0) {
						if (i != 0) {
							ComparablePair<String, Date> currentP = resDateList.get(i - 1);
							rname = currentP.getFirst();

							if (rname.equals(rName)) {
								rDate = currentP.getSecond();
								prevResTimeS = rDate.getTime();
								currentTimeS = cDate.getTime();

								if (listSize != 0) {
									prevPairCase = cidDateList.get(listSize - 1);
									prevCasDate = prevPairCase.getSecond();

									if (prevCasDate.compareTo(cDate) < 0) {
										currentTimeS = cDate.getTime();
										prevCasTimeS = prevCasDate.getTime();

										serviceTime = currentTimeS - Math.max(prevCasTimeS, prevResTimeS);
										serviceTime = serviceTime / 1000;
										serviceTime = serviceTime / 60;

										if (outlierChoice.equals(""Estimate Values"")) {
											estimateDates(serviceTime);
											break search;

										} else {
											Double outlierRange = Double.valueOf(outlierChoice);
											long value = serviceTime.longValue();
											double dValue = Double.valueOf(value);
											if (dValue < outlierRange) {
												Date pDate = estimateStartDates(serviceTime);
												XTimeExtension.instance().assignTimestamp(myEvent, pDate);
												eventList.add(myEvent);
												break search;

											} else {
												XTimeExtension.instance().assignTimestamp(myEvent, cDate);
												eventList.add(myEvent);
												break search;

											}

										}

									} else {
										XTimeExtension.instance().assignTimestamp(myEvent, cDate);
										eventList.add(myEvent);
										break search;
									}

								}
							}
							XTimeExtension.instance().assignTimestamp(myEvent, cDate);
							eventList.add(myEvent);
							break search;
						}
					}
				}
			}
		}

	}

	private void getServiceTimesOnCase() {
		int listSize = cidDateList.size();
		if (listSize != 0) {
			prevPairCase = cidDateList.get(listSize - 1);
			prevCasDate = prevPairCase.getSecond();
			XOrganizationalExtension.instance().assignResource(myEvent, rName);
			XLifecycleExtension.instance().assignTransition(myEvent, transition);
			if (prevCasDate.compareTo(cDate) < 0) {
				currentTimeS = cDate.getTime();
				prevCasTimeS = prevCasDate.getTime();

				serviceTime = currentTimeS - prevCasTimeS;
				serviceTime = serviceTime / 1000;
				serviceTime = serviceTime / 60;

				if (outlierChoice.equals(""Estimate Values"")) {
					estimateDates(serviceTime);

				} else {

					Double outlierRange = Double.valueOf(outlierChoice);
					long value = serviceTime.longValue();
					double dValue = Double.valueOf(value);
					if (dValue < outlierRange) {
						Date pDate = estimateStartDates(serviceTime);
						XTimeExtension.instance().assignTimestamp(myEvent, pDate);
						eventList.add(myEvent);

					} else {
						XTimeExtension.instance().assignTimestamp(myEvent, cDate);
						eventList.add(myEvent);

					}
				}
			}

		} else {
			XTimeExtension.instance().assignTimestamp(myEvent, cDate);
			eventList.add(myEvent);

		}

	}

	/**
	 * We obtain a start date based on a duration and a complete date per event.
	 * If the complete date occurred before 13hrs we assume it was started at
	 * 8hrs or else it was started at 13hrs.
	 * 
	 * @param serviceT
	 *            Service time
	 */

	private void estimateDates(Long serviceT) {
		long st = serviceT.longValue();

		Calendar myCalendar = Calendar.getInstance();
		myCalendar.setTime(cDate);
		int currentDay = myCalendar.get(Calendar.DAY_OF_WEEK);
		int currentMonth = myCalendar.get(Calendar.MONTH);
		int currentTime = myCalendar.get(Calendar.HOUR_OF_DAY);
		int currentDayMonth = myCalendar.get(Calendar.DAY_OF_MONTH);
		int currentYear = myCalendar.get(Calendar.YEAR);

		int a = (int) st;
		myCalendar.add(Calendar.MINUTE, -a);
		newDate = myCalendar.getTime();

		if (outlierChoice.equals(""Estimate Values"")) {

			Calendar newCalendars = Calendar.getInstance();
			newCalendars.setTime(newDate);

			int prevDay = newCalendars.get(Calendar.DAY_OF_WEEK);
			int prevMonth = newCalendars.get(Calendar.MONTH);
			int prevDayMonth = newCalendars.get(Calendar.DAY_OF_MONTH);
			int prevYear = myCalendar.get(Calendar.YEAR);

			if ((prevDay < currentDay) || (prevMonth < currentMonth) || (prevDayMonth < currentDayMonth)
					|| (prevYear < currentYear)) {
				Calendar newCalendar = Calendar.getInstance();
				newCalendar.setTime(cDate);

				int cTime = newCalendar.get(Calendar.HOUR_OF_DAY);
				if (cTime < 12) {
					newCalendar.add(Calendar.HOUR_OF_DAY, -(currentTime - 8));
					newDate = newCalendar.getTime();
					XTimeExtension.instance().assignTimestamp(myEvent, newDate);
					eventList.add(myEvent);

				} else {
					newCalendar.add(Calendar.HOUR_OF_DAY, -(currentTime - 13));

					newDate = newCalendar.getTime();
					XTimeExtension.instance().assignTimestamp(myEvent, newDate);
					eventList.add(myEvent);

				}
			} else {
				XTimeExtension.instance().assignTimestamp(myEvent, newDate);
				eventList.add(myEvent);
			}
		}

	}

	/**
	 * Based on the complete date and a certain duration, we obtain a start date
	 * 
	 * @param servT
	 *            Service Time
	 * @return Start Date
	 */

	private Date estimateStartDates(Long servT) {
		long st = servT.longValue();
		Calendar myCalendar = Calendar.getInstance();
		myCalendar.setTime(cDate);

		int a = (int) st;
		myCalendar.add(Calendar.MINUTE, -a);
		Date cDate = myCalendar.getTime();

		return cDate;

	}

	private ComparablePair<String, Date> getIdDate(String caseId, Date timeStamp) {
		return new ComparablePair<String, Date>(caseId, timeStamp);
	}

	public XTrace getTrace() {
		return trace;
	}

	public int getAddevents() {
		return count;
	}

	public int getRemoveEvents() {
		return removeCount;
	}

}"
AddStMain.java,log,"package org.processmining.plugins.loginsertstart;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.List;
import java.util.Set;
import java.util.TreeSet;

import org.deckfour.xes.extension.std.XLifecycleExtension;
import org.deckfour.xes.extension.std.XOrganizationalExtension;
import org.deckfour.xes.extension.std.XTimeExtension;
import org.deckfour.xes.info.XLogInfoFactory;
import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.framework.util.collection.ComparablePair;
import org.processmining.plugins.log.logfilters.LogFilter;
import org.processmining.plugins.log.logfilters.LogFilterException;
import org.processmining.plugins.log.logfilters.XTraceEditor;

/**
 * Check the log and see if any start events exist or not in the event log and
 * then calls the class to add the add the missing start events.
 * 
 * @author jnakatumba
 * 
 */

public class AddStMain {

	private AddStEvents startEvents;

	private List<ComparablePair<String, Date>> resDateList;
	private ArrayList<Date> startDatesList;
	private ComparablePair<String, Date> resDate;
	private Set<String> resNamesList;

	private Integer addCount = 0, removeCount = 0;
	private String displaychoice, outlierChoice;

	private XLog log;

	/**
	 * Initialize the plugin by checking if any start events exist in the log
	 * 
	 * @param context
	 *            The pluginContext in which this plugin is executed.
	 * 
	 * @param log
	 *            The log that needs to be filtered.
	 * 
	 */

	public AddStMain(UIPluginContext context, XLog log, String displayChoice, String outLierChoice) {
		try {
			outlierChoice = outLierChoice;
			displaychoice = displayChoice;
			resDateList = new ArrayList<ComparablePair<String, Date>>();
			startDatesList = new ArrayList<Date>();
			resDate = new ComparablePair<String, Date>(null, null);
			resNamesList = new TreeSet<String>();
			getEditedLog(context, log);
		} catch (LogFilterException e) {
			e.printStackTrace();
		}

	}

	private XLog getEditedLog(final UIPluginContext context, XLog log) throws LogFilterException {
		/**
		 * check if the log has any start events at all
		 */
		for (XTrace trace : log) {
			for (XEvent event : trace) {
				if (XLifecycleExtension.instance().extractTransition(event).equals(""start"")) {
					Date startDate = XTimeExtension.instance().extractTimestamp(event);
					startDatesList.add(startDate);

				} else if (XLifecycleExtension.instance().extractTransition(event).equals(""complete"")) {
					String rName = XOrganizationalExtension.instance().extractResource(event);
					Date cDate = XTimeExtension.instance().extractTimestamp(event);
					resDate = getResDate(rName, cDate);
					resDateList.add(resDate);
					resNamesList.add(rName);

				}
			}
			Collections.sort(resDateList);
		}
		/**
		 * For each trace per log, the start event is added per complete event
		 */
		return this.log = LogFilter.filter(context.getProgress(), 100, log, XLogInfoFactory.createLogInfo(log),
				new XTraceEditor() {
					public XTrace editTrace(XTrace trace) {
						startEvents = new AddStEvents(trace, resDateList, displaychoice, outlierChoice, addCount,
								removeCount);
						trace = startEvents.getTrace();
						addCount = startEvents.getAddevents();
						removeCount = startEvents.getRemoveEvents();
						return trace;
					}

				});

	}

	private ComparablePair<String, Date> getResDate(String rName, Date timeStamp) {
		return new ComparablePair<String, Date>(rName, timeStamp);
	}

	/**
	 * The edited log
	 * 
	 * @return XLog
	 */
	public XLog getLog() {
		return log;
	}

	/**
	 * Number of start events added
	 * 
	 * @return Start Events added
	 */

	public int getAddCounter() {
		return addCount;
	}

	/**
	 * Number of events removed
	 * 
	 * @return No of events removed
	 */
	public int getRemoveCounter() {
		return removeCount;
	}
}
"
AddStPanel.java,log,"package org.processmining.plugins.loginsertstart;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Component;
import java.awt.Dimension;

import javax.swing.BorderFactory;
import javax.swing.BoxLayout;
import javax.swing.ButtonGroup;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JRadioButton;
import javax.swing.JSpinner;
import javax.swing.JSplitPane;
import javax.swing.SpinnerModel;
import javax.swing.SpinnerNumberModel;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;

import org.jfree.chart.ChartPanel;
import org.processmining.contexts.uitopia.UIPluginContext;

import com.fluxicon.slickerbox.components.HeaderBar;

/**
 * Insert Start Panel Class
 * 
 * 
 * @author jnakatumba
 * 
 */

public class AddStPanel extends JPanel {

	private static final long serialVersionUID = 1L;

	private String choice;
	private final ChartPanel chartPanel;
	private JPanel jPanel;
	private final double maxValue;
	private JSpinner jSpinner;
	private JLabel jLabel;
	protected JSplitPane splitPane;
	private JPanel jPanel1;
	private final Color colorBg;
	private String outlierValue;
	private ButtonGroup jButtonGroup;
	private JRadioButton removeOut;
	private JRadioButton noRemove;
	private JRadioButton estimate;

	AddStPanel(UIPluginContext context, ChartPanel chartPanel, Double maxValue) {

		this.maxValue = maxValue;
		this.chartPanel = chartPanel;
		colorBg = new Color(120, 120, 120);

		setLayout(new BorderLayout());

		addPanel();
		context.showConfiguration(""Insert Missing Events"", jPanel1);

	}

	private void addPanel() {

		HeaderBar header = new HeaderBar(""Start Insertion Plugin "");
		header.setHeight(40);

		jLabel = new JLabel(""Upper Bound(minutes)"");
		jPanel1 = new JPanel();

		jSpinner = new JSpinner();

		jButtonGroup = new ButtonGroup();
		removeOut = new JRadioButton();
		noRemove = new JRadioButton();
		estimate = new JRadioButton();

		jButtonGroup.add(removeOut);
		removeOut.setSelected(true);
		removeOut.setText(""Remove Outliers"");

		jButtonGroup.add(noRemove);
		noRemove.setSelected(true);
		noRemove.setText(""Do not Insert Start Events"");

		jButtonGroup.add(estimate);
		estimate.setSelected(true);
		estimate.setText(""Estimate range of Service Time"");

		int min = 0;
		int step = 5;
		int initValue = 50;
		SpinnerModel model = new SpinnerNumberModel(initValue, min, maxValue, step);
		jSpinner = new JSpinner(model);
		jSpinner.setPreferredSize(new Dimension(200, 20));
		jSpinner.setMaximumSize(new Dimension(200, 20));

		jSpinner.addChangeListener(new ChangeListener() {
			public void stateChanged(ChangeEvent e) {
				outlierValue = String.valueOf(jSpinner.getValue());

			}
		});

		//jTextField = new JTextField();
		jPanel = new JPanel();
		jPanel.setLayout(new BoxLayout(jPanel, BoxLayout.PAGE_AXIS));

		/**
		 * jTextField.addActionListener(new ActionListener() {
		 * 
		 * public void actionPerformed(ActionEvent e) { textField =
		 * jTextField.getText();
		 * 
		 * }
		 * 
		 * });
		 */

		removeOut.setAlignmentX(Component.LEFT_ALIGNMENT);
		jPanel.add(removeOut);

		jLabel.setAlignmentX(Component.LEFT_ALIGNMENT);
		jPanel.add(jLabel);

		jSpinner.setMaximumSize(new Dimension(150, 30));
		jSpinner.setAlignmentX(Component.LEFT_ALIGNMENT);
		jPanel.add(jSpinner);

		estimate.setAlignmentX(Component.LEFT_ALIGNMENT);
		jPanel.add(estimate);

		//jTextField.setMaximumSize(new Dimension(150, 30));
		//jTextField.setAlignmentX(Component.LEFT_ALIGNMENT);
		//jPanel.add(jTextField);

		noRemove.setAlignmentX(Component.LEFT_ALIGNMENT);
		jPanel.add(noRemove);

		jPanel1 = new JPanel();
		jPanel1.setBorder(BorderFactory.createEmptyBorder(5, 5, 5, 5));
		jPanel1.setLayout(new BorderLayout());

		splitPane = new JSplitPane();
		splitPane = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT);

		splitPane.setRightComponent(chartPanel);
		splitPane.setLeftComponent(jPanel);
		splitPane.setBackground(colorBg);

		splitPane.setDividerSize(2);
		jPanel1.add(header, BorderLayout.NORTH);
		jPanel1.add(splitPane);

	}

	public String getChoice() {
		if (removeOut.isSelected() == true) {
			choice = outlierValue;

		} else if (noRemove.isSelected() == true) {
			choice = null;

		} else if (estimate.isSelected() == true) {
			choice = ""Estimate Values"";

		}

		return choice;

	}

}
"
AddStPlugin.java,log,"package org.processmining.plugins.loginsertstart;

import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.model.XLog;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginCategory;
import org.processmining.framework.plugin.annotations.PluginVariant;

/**
 * Add missing start events to the log
 * 
 * @author jnakatumba
 * 
 */
@Plugin(name = ""Add Missing Events"", categories = { PluginCategory.Filtering }, parameterLabels = { ""Log"" }, returnLabels = { ""Log (With Start Events)"" }, returnTypes = { AddStVisualizer.class }, userAccessible = true)
public class AddStPlugin {
	/**
	 * This class adds missing start events to the event log
	 * 
	 * @param context
	 *            The pluginContext in which this plugin is executed.
	 * 
	 * @param log
	 *            The log that needs to be filtered.
	 * @return the changed log.
	 */
	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""J. Nakatumba"", email = ""jnakatum@tue.nl"")
	@PluginVariant(variantLabel = ""Default Settings"", requiredParameterLabels = { 0 })
	public static AddStVisualizer filter(final UIPluginContext context, final XLog log) {
		AddSt miner = new AddSt(context, log);
		AddStVisualizer output = miner.mine();

		String name = XConceptExtension.instance().extractName(log);
		context.getFutureResult(0).setLabel(name + ""(With Start Events)"");

		return output;

	}

}
"
AddStSecPanel.java,log,"package org.processmining.plugins.loginsertstart;

import java.awt.BorderLayout;
import java.awt.Component;

import javax.swing.BorderFactory;
import javax.swing.BoxLayout;
import javax.swing.ButtonGroup;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JRadioButton;
import javax.swing.border.Border;
import javax.swing.border.EtchedBorder;
import javax.swing.border.TitledBorder;

import org.processmining.contexts.uitopia.UIPluginContext;

import com.fluxicon.slickerbox.components.HeaderBar;

/**
 * Insert Start First Panel class
 * 
 * @author jnakatumba
 * 
 */

public class AddStSecPanel extends JPanel {
	/**
	 * 
	 */
	private static final long serialVersionUID = 1L;
	private JPanel jPanel;
	private JPanel panel;
	private JLabel jLabel;
	private ButtonGroup jButtonGroup;
	private JRadioButton resourcePer;
	private JRadioButton casePer;
	private JRadioButton averageResCase;
	private String displayChoice;

	public AddStSecPanel(UIPluginContext context) {

		setLayout(new BorderLayout());

		addPanel();

	}

	private void addPanel() {

		HeaderBar header = new HeaderBar(""Start Insertion Plugin Settings"");
		header.setHeight(40);

		jLabel = new JLabel(""Show Outliers Based on:"");

		Border raisedetched = BorderFactory.createEtchedBorder(EtchedBorder.RAISED);

		TitledBorder title;
		title = BorderFactory.createTitledBorder(raisedetched);
		title.setTitleJustification(TitledBorder.CENTER);

		jButtonGroup = new ButtonGroup();
		resourcePer = new JRadioButton();
		casePer = new JRadioButton();
		averageResCase = new JRadioButton();

		jButtonGroup.add(resourcePer);
		resourcePer.setSelected(true);
		resourcePer.setText(""Resource perspective"");

		jButtonGroup.add(casePer);
		casePer.setSelected(true);
		casePer.setText(""Case perspective"");

		jButtonGroup.add(averageResCase);
		averageResCase.setSelected(true);
		averageResCase.setText(""Maximum of Case and Resource Perspectives"");

		jPanel = new JPanel(new BorderLayout());
		panel = new JPanel();

		jPanel.add(header, BorderLayout.NORTH);

		panel.setLayout(new BoxLayout(panel, BoxLayout.PAGE_AXIS));

		jLabel.setAlignmentX(Component.LEFT_ALIGNMENT);
		panel.add(jLabel);

		resourcePer.setAlignmentX(Component.LEFT_ALIGNMENT);
		panel.add(resourcePer);

		casePer.setAlignmentX(Component.LEFT_ALIGNMENT);
		panel.add(casePer);

		averageResCase.setAlignmentX(Component.LEFT_ALIGNMENT);
		panel.add(averageResCase);

		panel.setBorder(title);

		jPanel.add(panel, BorderLayout.CENTER);

	}

	public JPanel getPanel() {
		return jPanel;
	}

	public String getDisplayChoice() {
		if (resourcePer.isSelected() == true) {

			displayChoice = ""Resource perspective"";

		} else if (casePer.isSelected() == true) {
			displayChoice = ""Case perspective"";

		} else if (averageResCase.isSelected() == true) {
			displayChoice = ""Resource/Case perspective"";

		}
		return displayChoice;
	}

}
"
AddStVisualizer.java,log,"package org.processmining.plugins.loginsertstart;

import org.deckfour.xes.model.XLog;
import org.processmining.contexts.uitopia.annotations.Visualizer;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginVariant;

/**
 * 
 * Insert Start Visualizer Class
 * 
 * Visualise the edited log
 * 
 * @author jnakatumba
 * 
 */

@Plugin(name = ""Log visualizer"", returnLabels = { ""Visualized Log"" }, returnTypes = { XLog.class }, parameterLabels = ""log"")
@Visualizer
public class AddStVisualizer {

	private XLog xlog;

	public XLog setLog(XLog log) {
		xlog = log;
		return xlog;

	}

	@PluginVariant(requiredParameterLabels = { 0 }, variantLabel = ""Default Visualization"")
	public static XLog open(PluginContext context, AddStVisualizer output) throws Exception {
		return output.xlog;
	}

}
"
BoxandWhiskerPlot.java,log,"package org.processmining.plugins.loginsertstart;

import java.awt.Color;
import java.awt.Font;
import java.util.ArrayList;
import java.util.List;
import java.util.Set;
import java.util.TreeSet;

import javax.swing.JScrollPane;

import org.jfree.chart.ChartFactory;
import org.jfree.chart.ChartPanel;
import org.jfree.chart.JFreeChart;
import org.jfree.chart.axis.CategoryAxis;
import org.jfree.chart.axis.NumberAxis;
import org.jfree.chart.labels.BoxAndWhiskerToolTipGenerator;
import org.jfree.chart.plot.CategoryPlot;
import org.jfree.chart.renderer.category.BoxAndWhiskerRenderer;
import org.jfree.data.statistics.DefaultBoxAndWhiskerCategoryDataset;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.framework.util.Pair;

/**
 * Box- and Whisker Plot class
 * 
 * @author jnakatumba
 * 
 */

public class BoxandWhiskerPlot {

	private static Color colorBg = new Color(120, 120, 120);

	private ChartPanel chartPanel;
	private final UIPluginContext context;
	private final Set<String> resNamesList;
	private final Set<String> resourceList;
	private String resourceName;
	private final List<Pair<String, List<Double>>> resListPair;
	private List<Double> serviceTimes;
	private final List<Pair<String, Long>> resDurationList;

	private Double maxValue = 0.0;
	private String rChoice;

	private boolean bLegend = true;

	public BoxandWhiskerPlot(UIPluginContext context, List<Pair<String, Long>> resDurationLists, Set<String> resNames) {
		this.context = context;
		resDurationList = resDurationLists;
		resNamesList = resNames;

		resListPair = new ArrayList<Pair<String, List<Double>>>();
		serviceTimes = new ArrayList<Double>();

		resourceList = new TreeSet<String>();
		getOutliers();

		if (resourceList.size() > 40) {
			bLegend = false;
		} else {
			bLegend = true;
		}
		constructBoxandWhisker();

	}

	private void getOutliers() {
		Object[] reList = resNamesList.toArray();
		for (int resIndex = 0; resIndex < resNamesList.size(); resIndex++) {
			resourceName = (String) reList[resIndex];
			getPerResource();
		}
	}

	private void getPerResource() {
		List<Double> valuesList = new ArrayList<Double>();
		Double dValue = 0.0;
		for (int i = 0; i < resDurationList.size(); i++) {
			Pair<String, Long> currentPair = resDurationList.get(i);
			String rName = currentPair.getFirst();
			if (resourceName.equals(rName)) {
				long value = currentPair.getSecond();
				dValue = Double.valueOf(value);
				valuesList.add(dValue);
				resourceList.add(rName);

			}

			if (dValue > maxValue) {
				maxValue = dValue;
			}
		}
		Pair<String, List<Double>> resPair = new Pair<String, List<Double>>(resourceName, valuesList);
		resListPair.add(resPair);

	}

	@SuppressWarnings(""deprecation"")
	private void constructBoxandWhisker() {

		DefaultBoxAndWhiskerCategoryDataset datasets = createSampleDataset();

		JFreeChart chart = ChartFactory.createBoxAndWhiskerChart(""Box and Whisker Chart"", ""Service Time"",
				""Resource Names"", datasets, true);

		chart.setBackgroundPaint(new Color(249, 231, 236));

		chartPanel = new ChartPanel(chart);
		chartPanel.setPreferredSize(new java.awt.Dimension(500, 300));

		CategoryAxis xAxis = new CategoryAxis(""Resources"");
		NumberAxis yAxis = new NumberAxis(""Service Time (minutes)"");
		yAxis.setAutoRangeIncludesZero(false);
		BoxAndWhiskerRenderer renderer = new BoxAndWhiskerRenderer();
		renderer.setToolTipGenerator(new BoxAndWhiskerToolTipGenerator());
		CategoryPlot plot = new CategoryPlot(datasets, xAxis, yAxis, renderer);

		chart = new JFreeChart(null, new Font(""SansSerif"", Font.BOLD, 14), plot, bLegend);
		chartPanel = new ChartPanel(chart);
		JScrollPane scrollPane = new JScrollPane(chartPanel);
		chartPanel.setBackground(colorBg);
		scrollPane.setBackground(colorBg);

		AddStPanel stPanel = new AddStPanel(context, chartPanel, maxValue);
		rChoice = stPanel.getChoice();

	}

	private DefaultBoxAndWhiskerCategoryDataset createSampleDataset() {
		serviceTimes = new ArrayList<Double>();
		DefaultBoxAndWhiskerCategoryDataset dataset = new DefaultBoxAndWhiskerCategoryDataset();
		for (int i = 0; i < resListPair.size(); i++) {
			Pair<String, List<Double>> resList = resListPair.get(i);
			String rName = resList.getFirst();
			serviceTimes = resList.getSecond();
			dataset.add(serviceTimes, rName, """");

		}

		return dataset;

	}

	public String getOutlierRange() {
		return rChoice;
	}

}
"
ObtainDurationsWithoutStart.java,log,"package org.processmining.plugins.loginsertstart;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.List;
import java.util.Set;
import java.util.TreeSet;

import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.extension.std.XLifecycleExtension;
import org.deckfour.xes.extension.std.XOrganizationalExtension;
import org.deckfour.xes.extension.std.XTimeExtension;
import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.processmining.framework.util.Pair;
import org.processmining.framework.util.collection.ComparablePair;

/**
 * Check the log and see if any start events exist or not in the event log.
 * 
 * @author jnakatumba
 * 
 */

public class ObtainDurationsWithoutStart {

	private final Set<String> resNamesList;
	private final List<ComparablePair<String, Date>> resDateList;
	private final List<ComparablePair<String, Date>> cidDateList;

	private Long serviceTime = 0L, currentTimeS = 0L, prevResTimeS = 0L;
	private ComparablePair<String, Date> resDate;
	private ComparablePair<String, Date> cidDate;
	private ComparablePair<String, Date> prevPair, prevPairCase;

	private List<Pair<String, Long>> resDurationList;
	private final List<Pair<String, Long>> resDurationListRes;
	private final List<Pair<String, Long>> resDurationListCase;
	private final List<Pair<String, Long>> resDurationListResAver;
	private Pair<String, Long> resDurPair;
	private String caseId;

	private XEvent myEvent;
	private Date cDate, prevCasDate;;
	private String rName;
	private final String displayChoice;

	/**
	 * Initialize the plugin by checking if any start events exist in the log
	 * 
	 * @param context
	 *            The pluginContext in which this plugin is executed.
	 * 
	 * @param log
	 *            The log that needs to be filtered.
	 * 
	 */

	public ObtainDurationsWithoutStart(XLog log, String choice) {
		displayChoice = choice;

		resDurationList = new ArrayList<Pair<String, Long>>();
		resDurationListRes = new ArrayList<Pair<String, Long>>();
		resDurationListCase = new ArrayList<Pair<String, Long>>();
		resDurationListResAver = new ArrayList<Pair<String, Long>>();

		resNamesList = new TreeSet<String>();
		resDateList = new ArrayList<ComparablePair<String, Date>>();
		cidDateList = new ArrayList<ComparablePair<String, Date>>();

		resDate = new ComparablePair<String, Date>(null, null);
		cidDate = new ComparablePair<String, Date>(null, null);

		for (XTrace trace : log) {
			for (XEvent event : trace) {
				if (XLifecycleExtension.instance().extractTransition(event).equals(""complete"")) {
					String rName = XOrganizationalExtension.instance().extractResource(event);
					Date cDate = XTimeExtension.instance().extractTimestamp(event);
					resDate = getDate(rName, cDate);
					resDateList.add(resDate);
					resNamesList.add(rName);

				}
			}
		}
		Collections.sort(resDateList);

		for (XTrace trace : log) {
			for (XEvent event : trace) {
				if (XLifecycleExtension.instance().extractTransition(event).equals(""complete"")) {
					insertStartEvents(trace, event);
				}
			}
		}

	}

	private void insertStartEvents(XTrace trace, XEvent event) {
		myEvent = event;
		cDate = XTimeExtension.instance().extractTimestamp(myEvent);
		caseId = XConceptExtension.instance().extractName(trace);
		rName = XOrganizationalExtension.instance().extractResource(myEvent);
		getResourceDetails();

		cidDate = getDate(caseId, cDate);
		cidDateList.add(cidDate);

	}

	/**
	 * Check to see if the current resource executed any event before
	 */
	private void getResourceDetails() {
		String rname;
		Date rDate;
		if (resDateList.size() != 0) {
			search: for (int i = 0; i < resDateList.size(); i++) {
				prevPair = resDateList.get(i);
				rname = prevPair.getFirst();
				rDate = prevPair.getSecond();
				if (rname.equals(rName) == true) {
					if (rDate.compareTo(cDate) == 0) {
						if (i != 0) {
							ComparablePair<String, Date> currentP = resDateList.get(i - 1);
							rname = currentP.getFirst();
							if (rname.equals(rName)) {
								rDate = currentP.getSecond();
								prevResTimeS = rDate.getTime();
								currentTimeS = cDate.getTime();
								serviceTime = currentTimeS - prevResTimeS;
								serviceTime = serviceTime / 1000;
								serviceTime = serviceTime / 60;

								long st = serviceTime.longValue();

								resDurPair = new Pair<String, Long>(rName, st);
								resDurationListRes.add(resDurPair);
								getServiceTimesOnCase();
								break search;

							}
							getServiceTimesOnCase();
							break search;
						}
					}
				}
			}
		}

	}

	/**
	 * Checks the information based on the case perspective and then edits the
	 * event with the new information obtained.
	 */

	private void getServiceTimesOnCase() {
		int listSize = cidDateList.size();
		if ((listSize != 0) && (listSize > 1)) {
			prevPairCase = cidDateList.get(listSize - 1);
			prevCasDate = prevPairCase.getSecond();
			if (prevCasDate.compareTo(cDate) < 0) {
				currentTimeS = cDate.getTime();
				Long prevCasTimeS = prevCasDate.getTime();

				serviceTime = currentTimeS - Math.max(prevCasTimeS, prevResTimeS);
				serviceTime = serviceTime / 1000;
				serviceTime = serviceTime / 60;

				long st = serviceTime.longValue();
				resDurPair = new Pair<String, Long>(rName, st);
				resDurationListResAver.add(resDurPair);

				serviceTime = currentTimeS - prevCasTimeS;
				serviceTime = serviceTime / 1000;
				serviceTime = serviceTime / 60;

				long stC = serviceTime.longValue();
				resDurPair = new Pair<String, Long>(rName, stC);
				resDurationListCase.add(resDurPair);

			}
		}

	}

	public List<Pair<String, Long>> getResDateDetails() {

		if (displayChoice.equals(""Resource perspective"")) {
			resDurationList = resDurationListRes;

		} else if (displayChoice.equals(""Case perspective"")) {
			resDurationList = resDurationListCase;

		} else if (displayChoice.equals(""Resource/Case perspective"")) {
			resDurationList = resDurationListResAver;
		}
		return resDurationList;
	}

	public Set<String> getResNames() {
		return resNamesList;
	}

	private ComparablePair<String, Date> getDate(String rName, Date timeStamp) {
		return new ComparablePair<String, Date>(rName, timeStamp);
	}

}
"
ObtainDurationWithStart.java,log,"package org.processmining.plugins.loginsertstart;

import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.Set;
import java.util.TreeSet;

import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.extension.std.XLifecycleExtension;
import org.deckfour.xes.extension.std.XOrganizationalExtension;
import org.deckfour.xes.extension.std.XTimeExtension;
import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.util.Pair;

/**
 * Check the log and see if any start events exist or not in the event log.
 * 
 * @author jnakatumba
 * 
 */

public class ObtainDurationWithStart {
	private final ArrayList<Date> startDatesList;
	private final List<Pair<String, Long>> resDurationList;
	private final Set<String> resNamesList;
	private Pair<String, Long> resDurPair;
	private final XLog log;

	/**
	 * Initialize the plugin by checking if any start events exist in the log
	 * 
	 * @param context
	 *            The pluginContext in which this plugin is executed.
	 * 
	 * @param log
	 *            The log that needs to be filtered.
	 * 
	 */

	public ObtainDurationWithStart(PluginContext context, XLog log) {
		this.log = log;
		resDurationList = new ArrayList<Pair<String, Long>>();
		startDatesList = new ArrayList<Date>();
		resNamesList = new TreeSet<String>();
		getEditedLog();

	}

	private void getEditedLog() {
		String rNamest = null;
		String caseId = null;
		String aName = null;
		Date startDate = null;
		for (XTrace trace : log) {
			for (XEvent event : trace) {
				String eventType = XLifecycleExtension.instance().extractTransition(event);
				if (eventType.equals(""start"")) {
					startDate = XTimeExtension.instance().extractTimestamp(event);
					caseId = XConceptExtension.instance().extractName(trace);
					aName = XConceptExtension.instance().extractName(event);
					rNamest = XOrganizationalExtension.instance().extractResource(event);

				} else if (eventType.equals(""complete"")) {
					String cid = XConceptExtension.instance().extractName(trace);
					String aNameC = XConceptExtension.instance().extractName(event);
					Date compDate = XTimeExtension.instance().extractTimestamp(event);
					if (caseId != null) {
						if (cid.equals(caseId)) {
							if (aName != null) {
								if (aName.equals(aNameC)) {
									startDatesList.add(startDate);
									long stTime = startDate.getTime();
									long compsTime = compDate.getTime();
									long serviceTimes = compsTime - stTime;
									serviceTimes = serviceTimes / 1000;
									serviceTimes = serviceTimes / 60;

									resDurPair = new Pair<String, Long>(rNamest, serviceTimes);
									resDurationList.add(resDurPair);
									resNamesList.add(rNamest);

								}

							}

						}
					}

				}
			}
		}

	}

	public List<Pair<String, Long>> getResDateDetails() {
		return resDurationList;
	}

	public Set<String> getResNames() {
		return resNamesList;
	}

}
"
EventLogArray.java,log,"package org.processmining.log.models;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;

import org.deckfour.xes.model.XLog;
import org.deckfour.xes.out.XSerializer;
import org.processmining.framework.annotations.AuthoredType;
import org.processmining.framework.annotations.Icon;
import org.processmining.framework.plugin.PluginContext;

@AuthoredType(typeName = ""Event log array"", affiliation = AuthoredType.TUE, author = ""H.M.W. Verbeek"", email = ""h.m.w.verbeek@tue.nl"")
@Icon(icon = ""resourcetype_ela_30x35.png"")
public interface EventLogArray {

	/**
	 * Initializes the event log array.
	 */
	void init();

	/**
	 * Adds the given log to the array.
	 * 
	 * @param log
	 *            The given log.
	 * @return The index of the added log in the array.
	 */
	int addLog(XLog log);

	/**
	 * Removes the first occurrence of the given log from the array,
	 * 
	 * @param log
	 *            The given log.
	 * @return The index of the removed log, if present. -1 if not present.
	 */
	int removeLog(XLog log);

	/**
	 * Adds the given log at the given index to the array.
	 * 
	 * @param index
	 *            The given index.
	 * @param log
	 *            The given log.
	 */
	void addLog(int index, XLog log);

	/**
	 * Removes the log from the given index.
	 * 
	 * @param index
	 *            The given index.
	 */
	void removeLog(int index);

	/**
	 * Returns the log at the given index.
	 * 
	 * @param index The given index.
	 * @return The log at the given index, if valid. null if not valid.
	 */
	XLog getLog(int index);
	
	int getSize();
	
	public void importFromStream(PluginContext context, InputStream input, String parent) throws Exception;
	public void exportToFile(PluginContext context, File file, XSerializer logSerializer) throws IOException;
}
"
EventLogArrayFactory.java,log,"package org.processmining.log.models.impl;

import org.processmining.log.models.EventLogArray;

public class EventLogArrayFactory {

	public static EventLogArray createEventLogArray() {
		return new EventLogArrayImpl();
	}
	
}
"
EventLogArrayImpl.java,log,"package org.processmining.log.models.impl;

import java.io.File;
import java.io.FileOutputStream;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStream;
import java.io.Writer;

import org.deckfour.xes.model.XLog;
import org.deckfour.xes.out.XSerializer;
import org.deckfour.xes.out.XesXmlSerializer;
import org.processmining.basicutils.models.impl.ObjectArrayImpl;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.log.models.EventLogArray;
import org.processmining.plugins.log.OpenLogFilePlugin;

import com.csvreader.CsvWriter;

public class EventLogArrayImpl extends ObjectArrayImpl<XLog> implements EventLogArray {

	@Deprecated 
	public int addLog(XLog log) {
		return addElement(log);
	}

	@Deprecated
	public int removeLog(XLog log) {
		return removeElement(log);
	}

	@Deprecated
	public void addLog(int index, XLog log) {
		addElement(log);
	}

	@Deprecated
	public void removeLog(int index) {
		removeElement(index);
	}

	@Deprecated
	public XLog getLog(int index) {
		return getElement(index);
	}

	public void importFromStream(PluginContext context, InputStream input, String parent) throws Exception {
		importFromStream(context, input, parent, new OpenLogFilePlugin());
	}

	public void exportToFile(PluginContext context, File file, XSerializer logSerializer) throws IOException {
		Writer fileWriter = new FileWriter(file);
		CsvWriter csvWriter = new CsvWriter(fileWriter, ',');
		int n = 1;
		for (XLog log: list) {
			String fileName = file.getName();
			File dir = file.getParentFile();
			String prefix = fileName.substring(0, fileName.indexOf("".""));
			File netFile = File.createTempFile(prefix + ""."" + n + ""."", ""."" + logSerializer.getSuffices()[0], dir);
			csvWriter.write(netFile.getName());
			csvWriter.endRecord();
			System.out.println(""Exporting Accepting Petri Net to "" + netFile.getName());
			FileOutputStream out = new FileOutputStream(netFile);
			logSerializer.serialize(log, out);
			out.close();
			n++;
		}
		csvWriter.close();
	}

	public void exportToFile(PluginContext context, File file) throws Exception {
		exportToFile(context, file, new XesXmlSerializer());
	}


}
"
LogFrequencyArrayImpl.java,log,"package org.processmining.log.models.impl;

import org.deckfour.xes.extension.std.XConceptExtension;
import org.processmining.log.models.EventLogArray;
import org.processmining.log.models.LogFrequency;
import org.processmining.log.models.LogFrequencyArray;

public class LogFrequencyArrayImpl implements LogFrequencyArray {

	private String label;
	private LogFrequency[] subFrequencies;
	private int index;
	private int factor;
	private int buckets = 20;

	public LogFrequencyArrayImpl(EventLogArray logs) {
		label = null;
		if (logs.getSize() > 0) {
			label = XConceptExtension.instance().extractName(logs.getLog(0));
		}
		if (label == null) {
			label = ""<Not specified>"";
		}
		factor = (logs.getLog(0).size() / buckets) + (logs.getLog(0).size() % buckets > 0 ? 1 : 0);
		subFrequencies = new LogFrequency[logs.getSize()];
		for (int i = 0; i < logs.getSize(); i++) {
			subFrequencies[i] = LogFrequencyFactory.createLogFrequency(logs.getLog(i));
		}
		index = -1;
	}

	public String toHTMLString(boolean includeHTMLTags) {
		StringBuffer buf = new StringBuffer();
		if (includeHTMLTags) {
			buf.append(""<html>"");
		}
		buf.append(""<h1>"");
		buf.append(label);
		buf.append(""</h1>"");
		buf.append(""<table>"");
		buf.append(""<tr><th>Frequency</th>"");
		for (int i = 0; i < subFrequencies.length ; i++) {
			buf.append(""<th>Log "" + (i + 1) + ""</th>"");
			
		}
		buf.append(""</tr>"");
		for (int i = 0; i < buckets; i++) {
			buf.append(""<tr><th>"");
			buf.append(i * factor + 1);
			buf.append(""</th>"");
			for (int j = 0; j < subFrequencies.length ; j++) {
				buf.append(""<td>"" + subFrequencies[j].get(i * factor + 1) + ""</td>"");
			}
			buf.append(""</tr>"");
		}
		buf.append(""</table>"");
		if (includeHTMLTags) {
			buf.append(""</html>"");
		}
		return buf.toString();
	}

	public void set(int index) {
		this.index = index;
	}

	public void add(int frequency) {
		subFrequencies[index].add(frequency);
	}

	public int get(int frequency) {
		// TODO Auto-generated method stub
		return subFrequencies[index].get(frequency);
	}
}
"
LogFrequencyFactory.java,log,"package org.processmining.log.models.impl;

import org.deckfour.xes.model.XLog;
import org.processmining.log.models.EventLogArray;
import org.processmining.log.models.LogFrequency;
import org.processmining.log.models.LogFrequencyArray;


public class LogFrequencyFactory {

	public static LogFrequency createLogFrequency(XLog log) {
		return new LogFrequencyImpl(log);
	}

	public static LogFrequencyArray createLogFrequencyArray(EventLogArray logs) {
		return new LogFrequencyArrayImpl(logs);
	}
}
"
LogFrequencyImpl.java,log,"package org.processmining.log.models.impl;

import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.model.XLog;
import org.processmining.log.models.LogFrequency;

public class LogFrequencyImpl implements LogFrequency {

	private String label;
	private int[] frequencies;
	private int factor;
	private int buckets = 20;
	
	public LogFrequencyImpl(XLog log) {
		label = XConceptExtension.instance().extractName(log);
		if (label == null) {
			label = ""<Not specified>"";
		}
		factor = (log.size() / buckets) + (log.size() % buckets > 0 ? 1 : 0);
		frequencies = new int[buckets];
		for (int i = 0; i < buckets; i++) {
			frequencies[i] = 0;
		}
	}
	
	public String toHTMLString(boolean includeHTMLTags) {
		StringBuffer buf = new StringBuffer();
		if (includeHTMLTags) {
			buf.append(""<html>"");
		}
		buf.append(""<h1>"");
		buf.append(label);
		buf.append(""</h1>"");
		buf.append(""<table>"");
		buf.append(""<tr><th>Frequency</th><th>Log</th></tr>"");
		for (int i = 0 ; i < buckets ; i++) {
			buf.append(""<tr><th>"");
			buf.append(i * factor + 1);
			buf.append(""</th><td>"");
			buf.append(frequencies[i]);
			buf.append(""</td></tr>"");
		}
		buf.append(""</table>"");
		if (includeHTMLTags) {
			buf.append(""</html>"");
		}
		return buf.toString();
	}

	public void add(int frequency) {
		frequencies[(frequency - 1) / factor] += frequency;
	}

	public int get(int frequency) {
		return frequencies[(frequency - 1) / factor];
	}
}
"
XEventClassifierListImpl.java,log,"package org.processmining.log.models.impl;

import java.util.ArrayList;

import org.deckfour.xes.classification.XEventClassifier;
import org.processmining.log.models.XEventClassifierList;

public class XEventClassifierListImpl extends ArrayList<XEventClassifier> implements XEventClassifierList {

	/**
	 * 
	 */
	private static final long serialVersionUID = 2050835582426869158L;

}
"
LogCentrality.java,log,"package org.processmining.log.models;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.deckfour.xes.classification.XEventClassifier;
import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.log.parameters.LogCentralityFilterParameters;
import org.processmining.log.parameters.LogCentralityParameters;

public class LogCentrality {

	private XLog log;
	private XEventClassifier classifier;
	private Map<List<String>, Double> centralityMap;
	private List<Double> centralities;
	private Map<Set<List<String>>, Integer> cache;

	public LogCentrality(XLog log) {
		this.log = log;
		this.classifier = null;
		this.cache = null;
	}

	public XLog getLog() {
		return log;
	}
	
	public XEventClassifier getClassifier() {
		return classifier;
	}
	
	public List<Double> getCentralities() {
		return centralities;
	}
	
	public void setClassifier(PluginContext context, LogCentralityParameters parameters) {
		if (context != null) {
			context.getProgress().setValue(0);
		}
		if (this.classifier == null || !this.classifier.equals(parameters.getClassifier())) {
			this.classifier = parameters.getClassifier();
			this.centralityMap = new HashMap<List<String>, Double>();
			this.centralities = new ArrayList<Double>();
			this.cache = new HashMap<Set<List<String>>, Integer>();

			for (XTrace trace : log) {
				List<String> traceId = getTraceId(trace, classifier);
				if (!centralityMap.containsKey(traceId)) {
					centralityMap.put(traceId, getTraceCentrality(trace, log, classifier));
				}
				centralities.add(centralityMap.get(traceId));
				if (context != null) {
					context.getProgress().inc();
				}
			}
			Collections.sort(centralities);
			this.cache = null;
		}
	}

	public int size() {
		return log.size();
	}
	
	public XLog filter(PluginContext context, LogCentralityFilterParameters parameters) {
		XLog log = (XLog) this.log.clone();
		int index = (parameters.getPercentage() * centralities.size()) / 100;
		if (index >= centralities.size()) {
			index = centralities.size() - 1;
		}
		Double threshold = centralities.get(index);
		Set<XTrace> removedTraces = new HashSet<XTrace>();
		for (XTrace trace : log) {
			if (parameters.isFilterIn() == (centralityMap.get(getTraceId(trace, classifier)) > threshold)) {
				removedTraces.add(trace);
			}
			if (context != null) {
				context.getProgress().inc();
			}
		}
		for (XTrace trace : removedTraces) {
			log.remove(trace);
		}
		return log;
	}

	private List<String> getTraceId(XTrace trace, XEventClassifier classifier) {
		List<String> traceId = new ArrayList<String>();
		for (XEvent event : trace) {
			traceId.add(classifier.getClassIdentity(event));
		}
		return traceId;
	}

	private double getTraceCentrality(XTrace trace, XLog log, XEventClassifier classifier) {
		int totalSquareDistance = 0;
		for (XTrace otherTrace : log) {
			int distance = getTraceDistance(trace, otherTrace, classifier);
			totalSquareDistance += (distance * distance);
		}
		return Math.sqrt(totalSquareDistance);
	}

	private int getTraceDistance(XTrace trace1, XTrace trace2, XEventClassifier classifier) {
		List<String> activities1 = new ArrayList<String>();
		List<String> activities2 = new ArrayList<String>();
		for (XEvent event : trace1) {
			activities1.add(classifier.getClassIdentity(event));
		}
		for (XEvent event : trace2) {
			activities2.add(classifier.getClassIdentity(event));
		}
		return getTraceDistance(activities1, activities2, 0, 0);
	}

	private int getTraceDistance(List<String> activities1, List<String> activities2, int index1, int index2) {
		int distance = 0;
		if (index1 >= activities1.size()) {
			distance = activities2.size() - index2;
		} else if (index2 >= activities2.size()) {
			distance = activities1.size() - index1;
		} else {
			Set<List<String>> activities = new HashSet<List<String>>();
			activities.add(activities1);
			activities.add(activities2);
			if (cache.containsKey(activities)) {
				distance = cache.get(activities);
			} else {
				if (activities1.get(index1).equals(activities2.get(index2))) {
					distance = getTraceDistance(activities1, activities2, index1 + 1, index2 + 1);
				} else {
					int distance1 = 1 + getTraceDistance(activities1, activities2, index1 + 1, index2);
					int distance2 = 1 + getTraceDistance(activities1, activities2, index1, index2 + 1);
					if (distance1 < distance2) {
						distance = distance1;
					} else {
						distance = distance2;
					}
				}
				cache.put(activities, distance);
			}
		}
		return distance;
	}
}
"
LogCheckerReport.java,log,"package org.processmining.log.models;

import org.processmining.framework.util.HTMLToString;

public class LogCheckerReport implements HTMLToString {

	private String report;
	
	public LogCheckerReport() {
		report = """";
	}
	
	public void add(String message) {
		report += message;
	}
	
	public String toHTMLString(boolean includeHTMLTags) {
		return includeHTMLTags ? ""<html>"" + report + ""</html>"" : report;
	}

}
"
LogFrequency.java,log,"package org.processmining.log.models;

import org.processmining.framework.util.HTMLToString;

public interface LogFrequency extends HTMLToString {

	public void add(int frequency);

	public int get(int index);
}
"
LogFrequencyArray.java,log,"package org.processmining.log.models;

public interface LogFrequencyArray extends LogFrequency {

	public void set(int i);
	
}
"
XEventClassifierList.java,log,"package org.processmining.log.models;

import java.util.List;

import org.deckfour.xes.classification.XEventClassifier;

public interface XEventClassifierList extends List<XEventClassifier> {

}
"
AbstractLogFilterParameters.java,log,"package org.processmining.log.parameters;

import org.deckfour.xes.classification.XEventClassifier;
import org.processmining.basicutils.parameters.impl.PluginParametersImpl;

public abstract class AbstractLogFilterParameters extends PluginParametersImpl implements LogFilterParameters {

	private XEventClassifier classifier;

	public AbstractLogFilterParameters(XEventClassifier classifier) {
		super();
		setClassifier(classifier);
	}

	public AbstractLogFilterParameters(AbstractLogFilterParameters parameters) {
		super(parameters);
		setClassifier(parameters.getClassifier());
	}

	public XEventClassifier getClassifier() {
		return classifier;
	}

	public void setClassifier(XEventClassifier classifier) {
		this.classifier = classifier;
	}

	public boolean equals(Object object) {
		if (object instanceof AbstractLogFilterParameters) {
			AbstractLogFilterParameters parameters = (AbstractLogFilterParameters) object;
			return super.equals(parameters) 
					&& getClassifier().equals(parameters.getClassifier());
		}
		return false;
	}
}
"
ClassifierParameter.java,log,"package org.processmining.log.parameters;

import org.deckfour.xes.classification.XEventClassifier;

public interface ClassifierParameter {

	public void setClassifier(XEventClassifier classifier);
	public XEventClassifier getClassifier();
}
"
HighFrequencyFilterParameters.java,log,"package org.processmining.log.parameters;

import org.deckfour.xes.model.XLog;
import org.processmining.log.utils.XUtils;

public class HighFrequencyFilterParameters extends AbstractLogFilterParameters {

	private int frequencyThreshold;

	private int distanceThreshold;

	public HighFrequencyFilterParameters(XLog log) {
		super(XUtils.getDefaultClassifier(log));
		/*
		 * Keep at least 50% of the log. This determines the set of
		 * most-occurring traces.
		 */
		setFrequencyThreshold(50);
		/*
		 * Keep a trace if its distance to a most-occurring trace is less than
		 * 3.
		 */
		setDistanceThreshold(3);
	}

	public HighFrequencyFilterParameters(HighFrequencyFilterParameters parameters) {
		super(parameters);
		setFrequencyThreshold(parameters.getFrequencyThreshold());
		setDistanceThreshold(parameters.getDistanceThreshold());
	}

	public int getFrequencyThreshold() {
		return frequencyThreshold;
	}

	public void setFrequencyThreshold(int frequencyThreshold) {
		this.frequencyThreshold = frequencyThreshold;
	}

	public int getDistanceThreshold() {
		return distanceThreshold;
	}

	public void setDistanceThreshold(int distanceThreshold) {
		this.distanceThreshold = distanceThreshold;
	}

	public boolean equals(Object object) {
		if (object instanceof HighFrequencyFilterParameters) {
			HighFrequencyFilterParameters parameters = (HighFrequencyFilterParameters) object;
			return super.equals(parameters) && 
					getFrequencyThreshold() == parameters.getFrequencyThreshold() && 
					getDistanceThreshold() == parameters.getDistanceThreshold();
		}
		return false;
	}
}
"
LogCentralityFilterParameters.java,log,"package org.processmining.log.parameters;

import org.processmining.basicutils.parameters.impl.PluginParametersImpl;
import org.processmining.log.models.LogCentrality;


public class LogCentralityFilterParameters extends PluginParametersImpl {

	private int percentage;
	private boolean filterIn;

	public LogCentralityFilterParameters(LogCentrality centrality) {
		super();
		setPercentage(80);
		setFilterIn(true);
	}

	public LogCentralityFilterParameters(LogCentralityFilterParameters parameters) {
		super(parameters);
		setPercentage(parameters.getPercentage());
		setFilterIn(parameters.isFilterIn());
	}
	
	public void setPercentage(int percentage) {
		this.percentage = percentage;
	}

	public int getPercentage() {
		return percentage;
	}

	public void setFilterIn(boolean filterIn) {
		this.filterIn = filterIn;
	}

	public boolean isFilterIn() {
		return filterIn;
	}

	public boolean equals(Object object) {
		if (object instanceof LogCentralityFilterParameters) {
			LogCentralityFilterParameters parameters = (LogCentralityFilterParameters) object;
			return super.equals(parameters) &&
					getPercentage() == parameters.getPercentage() &&
					isFilterIn() == parameters.isFilterIn();
		}
		return false;
	}

}
"
LogCentralityParameters.java,log,"package org.processmining.log.parameters;

import org.deckfour.xes.model.XLog;
import org.processmining.log.utils.XUtils;

public class LogCentralityParameters extends AbstractLogFilterParameters {

	public LogCentralityParameters(XLog log) {
		super(XUtils.getDefaultClassifier(log));
	}

	public LogCentralityParameters(LogCentralityParameters parameters) {
		super(parameters);
	}

	public boolean equals(Object object) {
		if (object instanceof LogCentralityParameters) {
			LogCentralityParameters parameters = (LogCentralityParameters) object;
			return super.equals(parameters);
		}
		return false;
	}
}
"
LogCheckerParameters.java,log,"package org.processmining.log.parameters;

import java.util.EnumSet;

import org.processmining.log.logchecks.LogCheckType;

public class LogCheckerParameters {

	private EnumSet<LogCheckType> logChecks;

	public EnumSet<LogCheckType> getLogChecks() {
		return logChecks;
	}

	public void setLogChecks(EnumSet<LogCheckType> logChecks) {
		this.logChecks = logChecks;
	}
	
}
"
LogFilterParameters.java,log,"package org.processmining.log.parameters;

import org.processmining.basicutils.parameters.PluginParameters;


public interface LogFilterParameters extends PluginParameters, ClassifierParameter {


}
"
LogFrequencyParameters.java,log,"package org.processmining.log.parameters;

import org.deckfour.xes.model.XLog;
import org.processmining.log.utils.XUtils;

public class LogFrequencyParameters extends AbstractLogFilterParameters {

	public LogFrequencyParameters(XLog log) {
		super(XUtils.getDefaultClassifier(log));
	}
	
	public LogFrequencyParameters(LogFrequencyParameters parameters) {
		super(parameters);
	}

	public boolean equals(Object object) {
		if (object instanceof LogFrequencyParameters) {
			LogFrequencyParameters parameters = (LogFrequencyParameters) object;
			return super.equals(parameters);
		}
		return false;
	}
}
"
LowFrequencyFilterParameters.java,log,"package org.processmining.log.parameters;

import org.deckfour.xes.model.XLog;
import org.processmining.log.utils.XUtils;

public class LowFrequencyFilterParameters extends AbstractLogFilterParameters {

	private int threshold;

	public LowFrequencyFilterParameters(XLog log) {
		super(XUtils.getDefaultClassifier(log));
		/*
		 * The least-occurring traces that make up at least 5% of the log will be removed.
		 */
		setThreshold(5); 
	}
	
	public LowFrequencyFilterParameters(LowFrequencyFilterParameters parameters) {
		super(parameters);
		setThreshold(parameters.getThreshold());
	}

	public int getThreshold() {
		return threshold;
	}

	public void setThreshold(int threshold) {
		this.threshold = threshold;
	}

	public boolean equals(Object object) {
		if (object instanceof LowFrequencyFilterParameters) {
			LowFrequencyFilterParameters parameters = (LowFrequencyFilterParameters) object;
			return super.equals(parameters) &&
					getThreshold() == parameters.getThreshold();
		}
		return false;
	}
}
"
LowOccurrencesFilterParameters.java,log,"package org.processmining.log.parameters;

import org.deckfour.xes.model.XLog;
import org.processmining.log.utils.XUtils;

public class LowOccurrencesFilterParameters extends AbstractLogFilterParameters {

	private int threshold;

	public LowOccurrencesFilterParameters(XLog log) {
		super(XUtils.getDefaultClassifier(log));
		/*
		 * Traces that occur at least 2 times will be retained.
		 */
		setThreshold(2);
	}
	
	public LowOccurrencesFilterParameters(LowOccurrencesFilterParameters parameters) {
		super(parameters);
		setThreshold(parameters.getThreshold());
	}
	
	public int getThreshold() {
		return threshold;
	}

	public void setThreshold(int threshold) {
		this.threshold = threshold;
	}
	
	public boolean equals(Object object) {
		if (object instanceof LowOccurrencesFilterParameters) {
			LowOccurrencesFilterParameters parameters = (LowOccurrencesFilterParameters) object;
			return super.equals(parameters) &&
					getThreshold() == parameters.getThreshold();
		}
		return false;
	}
}
"
MergeLogsParameters.java,log,"package org.processmining.log.parameters;

import java.util.Date;

public class MergeLogsParameters {

	private String traceId;
	private String dateFormat;
	private Date fromDate;
	private Date toDate;
	private Date specificDate;
	private String requiredWords;
	private String forbiddenWords;
	private int minMatches;
	private boolean maxMatch;
	private boolean multi;
	private int related;
	

	public MergeLogsParameters() {
		setTraceId(null);
		setDateFormat(""MM/dd/yyyy HH:mm"");
		setFromDate(null);
		setToDate(null);
		setSpecificDate(null);
		setRequiredWords(null);
		setForbiddenWords(null);
		setMinMatches(0);
		setMaxMatch(true);
		setMulti(false);
		setRelated(0);
	}
	
	public String getTraceId() {
		return traceId;
	}

	public void setTraceId(String id) {
		this.traceId = id;
	}

	public String getDateFormat() {
		return dateFormat;
	}

	public void setDateFormat(String dateFormat) {
		this.dateFormat = dateFormat;
	}

	public Date getFromDate() {
		return fromDate;
	}

	public void setFromDate(Date fromDate) {
		this.fromDate = fromDate;
	}

	public Date getToDate() {
		return toDate;
	}

	public void setToDate(Date toDate) {
		this.toDate = toDate;
	}

	public Date getSpecificDate() {
		return specificDate;
	}

	public void setSpecificDate(Date specificDate) {
		this.specificDate = specificDate;
	}

	public String getForbiddenWords() {
		return forbiddenWords;
	}

	public void setForbiddenWords(String remove) {
		this.forbiddenWords = remove;
	}

	public int getRelated() {
		return related;
	}

	public void setRelated(int related) {
		this.related = related;
	}

	public int getMinMatches() {
		return minMatches;
	}

	public void setMinMatches(int minMatches) {
		this.minMatches = minMatches;
	}

	public boolean isMaxMatch() {
		return maxMatch;
	}

	public void setMaxMatch(boolean maxMatch) {
		this.maxMatch = maxMatch;
	}

	public boolean isMulti() {
		return multi;
	}

	public void setMulti(boolean multi) {
		this.multi = multi;
	}

	public String getRequiredWords() {
		return requiredWords;
	}

	public void setRequiredWords(String requiredWords) {
		this.requiredWords = requiredWords;
	}
}
"
MinerParameter.java,log,"package org.processmining.log.parameters;

public interface MinerParameter {

	public void setMiner(String miner);
	public String getMiner();
}
"
SplitLogParameters.java,log,"package org.processmining.log.parameters;

import org.deckfour.xes.model.XAttribute;
import org.deckfour.xes.model.XAttributeLiteral;
import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;

public class SplitLogParameters {

	private String key;

	public SplitLogParameters(XLog log) {
		for (XTrace trace : log) {
			for (XEvent event : trace) {
				for (XAttribute attribute : event.getAttributes().values()) {
					if (attribute instanceof XAttributeLiteral) {
						setKey(attribute.getKey());
						break;
					}
				}
			}
		}
	}
	
	public String getKey() {
		return key;
	}

	public void setKey(String key) {
		this.key = key;
	}
}
"
UpdateParameter.java,log,"package org.processmining.log.parameters;

public interface UpdateParameter {

	public void update();
}
"
SaxHandlerGlobalEventAttributesParser.java,log,"package org.processmining.log.parsers;

import java.util.List;
import java.util.Vector;

import org.xml.sax.Attributes;
import org.xml.sax.SAXException;
import org.xml.sax.helpers.DefaultHandler;

public class SaxHandlerGlobalEventAttributesParser extends DefaultHandler {

	private static final String TAG = ""global"", KEY = ""key"", SCOPE = ""scope"", EVENT = ""event"";

	private final List<String> globals = new Vector<String>();

	private boolean isInGlobalEvent = false;

	@Override
	public void startElement(String uri, String local, String qName, Attributes attributes) throws SAXException {
		if (isInGlobalEvent == false) {
			if (qName.toLowerCase().equals(TAG)) {
				String scope = attributes.getValue(SCOPE);
				if (scope != null && scope.equals(EVENT)) {
					isInGlobalEvent = true;
				}
			}
		} else {
			if (qName.toLowerCase().equals(TAG))
				throw new SAXException();
			String key = attributes.getValue(KEY);
			if (key != null)
				globals.add(key);
		}
	}
	
	@Override
	public void endElement(String uri, String local, String qName) {
		if(isInGlobalEvent)
			if(qName.toLowerCase().equals(TAG))
				isInGlobalEvent = false;
	}
	
	public List<String> getGlobalEventAttributes(){
		return globals;
	}

}
"
SaxHandlerXEventClassifierParser.java,log,"package org.processmining.log.parsers;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;

import org.deckfour.xes.classification.XEventAttributeClassifier;
import org.deckfour.xes.classification.XEventClassifier;
import org.processmining.log.models.XEventClassifierList;
import org.processmining.log.models.impl.XEventClassifierListImpl;
import org.xml.sax.Attributes;
import org.xml.sax.SAXException;
import org.xml.sax.helpers.DefaultHandler;

/**
 * This parser tries to read the classifiers contained in a log, based on the
 * global event attributes. In order to find the classifiers, the elements of
 * the list of globals are checked if they are contained in the classifier
 * definition. This is done greedily based on the global´s sting length:
 * longest first. If globals are contained in the classifier definition, then we
 * return the corresponding XEventClassifier.
 * 
 * @author abolt *
 */
public class SaxHandlerXEventClassifierParser extends DefaultHandler {

	private static final String CLASSIFIER_TAG = ""classifier"", CLASSIFIER_TAG_ATTRIBUTE_NAME = ""name"",
			CLASSIFIER_TAG_ATTRIBUTEKEY = ""keys"";

	private final XEventClassifierList classifierList = new XEventClassifierListImpl();

	public XEventClassifierList getClassifierList() {
		return classifierList;
	}

	private final List<String> globalEventAttributes;
	private XEventClassifier current = null;
	private boolean insideClassifierTag = false;

	public SaxHandlerXEventClassifierParser(List<String> globalEventAttributes) {
		Collections.sort(globalEventAttributes, new Comparator<String>() {
			public int compare(String o1, String o2) {
				return o2.length() - o1.length();
			}
		});
		this.globalEventAttributes = globalEventAttributes;
	}

	@Override
	public void startElement(String uri, String local, String qName, Attributes attributes) throws SAXException {
		if (!insideClassifierTag) {
			if (qName.toLowerCase().equals(CLASSIFIER_TAG)) {
				insideClassifierTag = true;
				String name = attributes.getValue(CLASSIFIER_TAG_ATTRIBUTE_NAME) == null ? """"
						: attributes.getValue(CLASSIFIER_TAG_ATTRIBUTE_NAME);
				String keys = attributes.getValue(CLASSIFIER_TAG_ATTRIBUTEKEY) == null ? """"
						: attributes.getValue(CLASSIFIER_TAG_ATTRIBUTEKEY);
				List<String> parsedKeys = getGlobalsInClassifier(globalEventAttributes, keys);
				if (parsedKeys != null) {
					current = new XEventAttributeClassifier(name, parsedKeys.toArray(new String[parsedKeys.size()]));
				} else {
					current = null;
				}
			}
		} else {
			if (qName.toLowerCase().equals(CLASSIFIER_TAG)) {
				throw new SAXException(""Nested xml tag in classifier tag."");
			}
			// the code here is actually not described by the standard, so we  disable this for now.
			//			if (qName.toLowerCase().equals(STRING_TAG) && attributes.getValue(STRING_TAG_ATTRIBUTE_KEY) != null) {
			//				if (attributes.getValue(STRING_TAG_ATTRIBUTE_KEY).equals(CLASSIFIER_TAG_ATTRIBUTE_NAME)) {
			//					if (attributes.getValue(STRING_TAG_ATTRIBUTE_VALUE) != null) {
			//						current.setName(attributes.getValue(STRING_TAG_ATTRIBUTE_VALUE));
			//					}
			//				} else if (attributes.getValue(STRING_TAG_ATTRIBUTE_KEY).equals(CLASSIFIER_TAG_ATTRIBUTEKEY)) {
			//					if (attributes.getValue(STRING_TAG_ATTRIBUTE_VALUE) != null) {
			//						List<String> parsedKeys = getGlobalsInClassifier(globalEventAttributes,
			//								attributes.getValue(STRING_TAG_ATTRIBUTE_VALUE));
			//						current = new XEventAttributeClassifier(current.name(),
			//								parsedKeys.toArray(new String[parsedKeys.size()]));
			//					}
			//				}
			//			}
		}
	}

	@Override
	public void endElement(String uri, String local, String qName) {
		if (qName.toLowerCase().equals(CLASSIFIER_TAG)) {
			insideClassifierTag = false;
			if (current != null) {
				classifierList.add(current);
			}
		}

	}

	private List<String> getGlobalsInClassifier(List<String> globals, String keysInClassifier) {
		List<String> classifierKeys = new ArrayList<String>();
		for (String globalElement : globalEventAttributes) {
			if (keysInClassifier.contains(globalElement)) {
				classifierKeys.add(globalElement);
				// This will replace all matches, but since the list is ordered greedily, it should not replace strings used by other globals
				keysInClassifier = keysInClassifier.replace(globalElement, """");
			}
		}
		keysInClassifier = keysInClassifier.replace("" "", """");
		keysInClassifier = keysInClassifier.replace(""'"", """");
		return keysInClassifier.isEmpty() ? classifierKeys : null;
	}

}
"
ExportEventLogArrayAsCompressedMXMLPlugin.java,log,"package org.processmining.log.plugins;

import java.io.File;
import java.io.IOException;

import org.deckfour.xes.out.XMxmlGZIPSerializer;
import org.processmining.contexts.uitopia.annotations.UIExportPlugin;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.log.models.EventLogArray;

@Plugin(name = ""ELA export (Event Log Array)"", returnLabels = {}, returnTypes = {}, parameterLabels = {
		""Event Log Array (Compressed MXML)"", ""File"" }, userAccessible = true)
@UIExportPlugin(description = ""Event Log Array (Compressed MXML)"", extension = ""ela"")
public class ExportEventLogArrayAsCompressedMXMLPlugin {

	@PluginVariant(variantLabel = ""ELA export to compressed MXML files (Event Log Array)"", requiredParameterLabels = { 0, 1 })
	public void exportMxmlGz(PluginContext context, EventLogArray eventLogs, File file) throws IOException {
		eventLogs.exportToFile(context, file, new XMxmlGZIPSerializer());
	}

}
"
ExportEventLogArrayAsCompressedXESPlugin.java,log,"package org.processmining.log.plugins;

import java.io.File;
import java.io.IOException;

import org.deckfour.xes.out.XesXmlGZIPSerializer;
import org.processmining.contexts.uitopia.annotations.UIExportPlugin;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.log.models.EventLogArray;

@Plugin(name = ""ELA export (Event Log Array)"", returnLabels = {}, returnTypes = {}, parameterLabels = {
		""Event Log Array (Compressed XES)"", ""File"" }, userAccessible = true)
@UIExportPlugin(description = ""Event Log Array (Compressed XES)"", extension = ""ela"")
public class ExportEventLogArrayAsCompressedXESPlugin {

	@PluginVariant(variantLabel = ""ELA export to compressed XES files (Event Log Array)"", requiredParameterLabels = { 0, 1 })
	public void exportXes(PluginContext context, EventLogArray eventLogs, File file) throws IOException {
		eventLogs.exportToFile(context, file, new XesXmlGZIPSerializer());
	}

}
"
ExportEventLogArrayAsMXMLPlugin.java,log,"package org.processmining.log.plugins;

import java.io.File;
import java.io.IOException;

import org.deckfour.xes.out.XMxmlSerializer;
import org.processmining.contexts.uitopia.annotations.UIExportPlugin;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.log.models.EventLogArray;

@Plugin(name = ""ELA export (Event Log Array)"", returnLabels = {}, returnTypes = {}, parameterLabels = {
		""Event Log Array (MXML)"", ""File"" }, userAccessible = true)
@UIExportPlugin(description = ""Event Log Array (MXML)"", extension = ""ela"")
public class ExportEventLogArrayAsMXMLPlugin {

	@PluginVariant(variantLabel = ""ELA export to MXML files (Event Log Array)"", requiredParameterLabels = { 0, 1 })
	public void exportMxml(PluginContext context, EventLogArray eventLogs, File file) throws IOException {
		eventLogs.exportToFile(context, file, new XMxmlSerializer());
	}
}
"
ExportEventLogArrayAsXESPlugin.java,log,"package org.processmining.log.plugins;

import java.io.File;
import java.io.IOException;

import org.deckfour.xes.out.XesXmlSerializer;
import org.processmining.contexts.uitopia.annotations.UIExportPlugin;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.log.models.EventLogArray;

@Plugin(name = ""ELA export (Event Log Array)"", returnLabels = {}, returnTypes = {}, parameterLabels = {
		""Event Log Array (XES)"", ""File"" }, userAccessible = true)
@UIExportPlugin(description = ""Event Log Array (XES)"", extension = ""ela"")
public class ExportEventLogArrayAsXESPlugin {

	@PluginVariant(variantLabel = ""ELA export to XES files (Event Log Array)"", requiredParameterLabels = { 0, 1 })
	public void exportXesGz(PluginContext context, EventLogArray eventLogs, File file) throws IOException {
		eventLogs.exportToFile(context, file, new XesXmlSerializer());
	}

}
"
HighFrequencyFilterArrayPlugin.java,log,"package org.processmining.log.plugins;

import org.deckfour.uitopia.api.event.TaskListener.InteractionResult;
import org.deckfour.xes.model.XLog;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginCategory;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.log.dialogs.HighFrequencyFilterDialog;
import org.processmining.log.help.HighFrequencyFilterArrayHelp;
import org.processmining.log.models.EventLogArray;
import org.processmining.log.models.impl.EventLogArrayFactory;
import org.processmining.log.parameters.HighFrequencyFilterParameters;

@Plugin(name = ""Filter In High-Frequency Traces (Multiple Logs)"", categories = { PluginCategory.Filtering }, parameterLabels = { ""Event Logs"" }, returnLabels = { ""Filtered Logs"" }, returnTypes = { EventLogArray.class }, userAccessible = true, help = HighFrequencyFilterArrayHelp.TEXT)
public class HighFrequencyFilterArrayPlugin {

	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""Eric Verbeek"", email = ""h.m.w.verbeek@tue.nl"", website = ""www.processmining.org"", pack=""Log"")
	@PluginVariant(variantLabel = ""Filter In High-Frequency Traces (Multiple Logs), UI"", requiredParameterLabels = { 0 })
	public EventLogArray runUI(UIPluginContext context, EventLogArray logs) {
		if (logs.getSize() > 0) {
			XLog log = logs.getLog(0);
			HighFrequencyFilterParameters parameters = new HighFrequencyFilterParameters(log);
			HighFrequencyFilterDialog dialog = new HighFrequencyFilterDialog(log, parameters);
			InteractionResult result = context.showWizard(""Configure High-Frequency Filter"", true, true, dialog);
			if (result != InteractionResult.FINISHED) {
				return null;
			}
			EventLogArray filteredLogs = EventLogArrayFactory.createEventLogArray();
			filteredLogs.init();
			for (int i = 0; i < logs.getSize(); i++) {
				parameters.displayMessage(""[HighFrequencyFilterArrayPlugin] Filtering log "" + i + "" of "" + logs.getSize());
				filteredLogs.addLog((new HighFrequencyFilterPlugin()).run(context, logs.getLog(i), parameters));
			}
			return filteredLogs;
		}
		return null;
	}

	/**
	 * @deprecated Use runUI instead.
	 */
	@Deprecated
	public EventLogArray publicUIArray(UIPluginContext context, EventLogArray logs) {
		return runUI(context, logs);
	}

	@PluginVariant(variantLabel = ""Filter In High-Frequency Traces (Multiple Logs), Parameters"", requiredParameterLabels = { 0 })
	public EventLogArray run(PluginContext context, EventLogArray logs,
			HighFrequencyFilterParameters parameters) {
		if (logs.getSize() > 0) {
			EventLogArray filteredLogs = EventLogArrayFactory.createEventLogArray();
			filteredLogs.init();
			for (int i = 0; i < logs.getSize(); i++) {
				parameters.displayMessage(""[HighFrequencyFilterArrayPlugin] Filtering log "" + i + "" of "" + logs.getSize());
				filteredLogs.addLog((new HighFrequencyFilterPlugin()).run(context, logs.getLog(i), parameters));
			}
			return filteredLogs;
		}
		return null;
	}

	/**
	 * @deprecated Use run instead.
	 */
	@Deprecated
	public EventLogArray publicParameters(PluginContext context, EventLogArray logs,
			HighFrequencyFilterParameters parameters) {
		return run(context, logs, parameters);
	}
	
	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""Eric Verbeek"", email = ""h.m.w.verbeek@tue.nl"", website = ""www.processmining.org"", pack=""Log"")
	@PluginVariant(variantLabel = ""Filter In High-Frequency Traces (Multiple Logs), Default"", requiredParameterLabels = { 0 })
	public EventLogArray runDefault(PluginContext context, EventLogArray logs) {
		if (logs.getSize() > 0) {
			HighFrequencyFilterParameters parameters = new HighFrequencyFilterParameters(logs.getLog(0));
			EventLogArray filteredLogs = EventLogArrayFactory.createEventLogArray();
			filteredLogs.init();
			for (int i = 0; i < logs.getSize(); i++) {
				parameters.displayMessage(""[HighFrequencyFilterArrayPlugin] Filtering log "" + i + "" of "" + logs.getSize());
				filteredLogs.addLog((new HighFrequencyFilterPlugin()).run(context, logs.getLog(i), parameters));
			}
			return filteredLogs;
		}
		return null;
	}

	/**
	 * @deprecated Use runDefault instead.
	 */
	@Deprecated
	public EventLogArray publicDefault(PluginContext context, EventLogArray logs) {
		return runDefault(context, logs);
	}
}
"
HighFrequencyFilterPlugin.java,log,"package org.processmining.log.plugins;

import java.util.Collection;

import org.deckfour.uitopia.api.event.TaskListener.InteractionResult;
import org.deckfour.xes.model.XLog;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.connections.ConnectionCannotBeObtained;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginCategory;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.log.algorithms.HighFrequencyFilterAlgorithm;
import org.processmining.log.connections.HighFrequencyFilterConnection;
import org.processmining.log.dialogs.HighFrequencyFilterDialog;
import org.processmining.log.help.HighFrequencyFilterHelp;
import org.processmining.log.parameters.HighFrequencyFilterParameters;

@Plugin(name = ""Filter In High-Frequency Traces (Single Log)"", categories = { PluginCategory.Filtering }, parameterLabels = { ""Event Log"" }, returnLabels = { ""Filtered Log"" }, returnTypes = { XLog.class }, userAccessible = true, help = HighFrequencyFilterHelp.TEXT)
public class HighFrequencyFilterPlugin {

	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""Eric Verbeek"", email = ""h.m.w.verbeek@tue.nl"", website = ""www.processmining.org"", pack=""Log"")
	@PluginVariant(variantLabel = ""Filter In High-Frequency Traces (Single Log), UI"", requiredParameterLabels = { 0 })
	public XLog runUI(UIPluginContext context, XLog log) {
		HighFrequencyFilterParameters parameters = new HighFrequencyFilterParameters(log);
		HighFrequencyFilterDialog dialog = new HighFrequencyFilterDialog(log, parameters);
		InteractionResult result = context.showWizard(""Configure High-Frequency Filter"", true, true, dialog);
		if (result != InteractionResult.FINISHED) {
			return null;
		}
		return runConnections(context, log, parameters);
	}

	/**
	 * @deprecated Use runUI() instead.
	 */
	@Deprecated
	public XLog publicUI(UIPluginContext context, XLog log) {
		return runUI(context, log);
	}

	@PluginVariant(variantLabel = ""Filter In High-Frequency Traces (Single Log), Parameters"", requiredParameterLabels = { 0 })
	public XLog run(PluginContext context, XLog log, HighFrequencyFilterParameters parameters) {
		return runConnections(context, log, parameters);
	}

	/**
	 * @deprecated Use run() instead.
	 */
	@Deprecated
	public XLog publicParameters(PluginContext context, XLog log, HighFrequencyFilterParameters parameters) {
		return run(context, log, parameters);
	}

	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""Eric Verbeek"", email = ""h.m.w.verbeek@tue.nl"", website = ""www.processmining.org"", pack=""Log"")
	@PluginVariant(variantLabel = ""Filter In High-Frequency Traces (Single Log), Default"", requiredParameterLabels = { 0 })
	public XLog runDefault(PluginContext context, XLog log) {
		HighFrequencyFilterParameters parameters = new HighFrequencyFilterParameters(log);
		return runConnections(context, log, parameters);
	}

	/**
	 * @deprecated Use runDefault() instead.
	 */
	@Deprecated
	public XLog publicDefault(PluginContext context, XLog log) {
		return runDefault(context, log);
	}

	private XLog runConnections(PluginContext context, XLog log, HighFrequencyFilterParameters parameters) {
		if (parameters.isTryConnections()) {
			Collection<HighFrequencyFilterConnection> connections;
			try {
				connections = context.getConnectionManager().getConnections(HighFrequencyFilterConnection.class,
						context, log);
				for (HighFrequencyFilterConnection connection : connections) {
					if (connection.getObjectWithRole(HighFrequencyFilterConnection.LOG).equals(log)
							&& connection.getParameters().equals(parameters)) {
						return connection.getObjectWithRole(HighFrequencyFilterConnection.FILTEREDLOG);
					}
				}
			} catch (ConnectionCannotBeObtained e) {
			}
		}
		XLog filteredLog = (new HighFrequencyFilterAlgorithm()).apply(context, log, parameters);
		if (parameters.isTryConnections()) {
			context.getConnectionManager().addConnection(
					new HighFrequencyFilterConnection(log, filteredLog, parameters));
		}
		return filteredLog;
	}
}
"
ImportEventLogArrayPlugin.java,log,"package org.processmining.log.plugins;

import java.io.File;
import java.io.InputStream;

import javax.swing.filechooser.FileFilter;
import javax.swing.filechooser.FileNameExtensionFilter;

import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.model.XLog;
import org.processmining.contexts.uitopia.annotations.UIImportPlugin;
import org.processmining.framework.abstractplugins.AbstractImportPlugin;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.log.models.EventLogArray;
import org.processmining.log.models.impl.EventLogArrayFactory;

@Plugin(name = ""Import Event Log Array from ELA file"", parameterLabels = { ""Filename"" }, returnLabels = { ""Event Log Array"" }, returnTypes = { EventLogArray.class })
@UIImportPlugin(description = ""ELA Event Log Array files"", extensions = { ""ela"" })
public class ImportEventLogArrayPlugin extends AbstractImportPlugin {

	protected FileFilter getFileFilter() {
		return new FileNameExtensionFilter(""ELA files"", ""ela"");
	}

	protected Object importFromStream(PluginContext context, InputStream input, String filename, long fileSizeInBytes)
			throws Exception {
		EventLogArray logs = EventLogArrayFactory.createEventLogArray();
		File file = getFile();
		String parent = (file == null ? null : file.getParent());
		logs.importFromStream(context, input, parent);
		setLabel(context, logs, filename);
		return logs;
	}

	/*
	 * Sets a proper default name for the event log array.
	 */
	private void setLabel(PluginContext context, EventLogArray logs, String filename) {
		String prefix = null;
		String postfix = null;
		boolean allSame = true;
		for (int i = 0; i < logs.getSize(); i++) {
			XLog log = logs.getLog(i);
			String name = XConceptExtension.instance().extractName(log);
			if (name != null) {
				if (prefix == null) {
					prefix = name;
				} else {
					if (!name.equals(prefix)) {
						allSame = false;
						prefix = greatestCommonPrefix(prefix, name);
					}
				}
				if (postfix == null) {
					postfix = name;
				} else {
					if (!name.equals(postfix)) {
						allSame = false;
						postfix = new StringBuilder(greatestCommonPrefix(
								new StringBuilder(prefix).reverse().toString(), new StringBuilder(name).reverse()
										.toString())).reverse().toString();
					}
				}
			}
		}
		if ((prefix != null && prefix.length() > 0) || (postfix != null && postfix.length() > 0)) {
			StringBuffer buf = new StringBuffer();
			if (prefix != null) {
				buf.append(prefix);
			}
			if (!allSame) {
				buf.append("" ... "");
				if (postfix != null) {
					buf.append(postfix);
				}
			}
			context.getFutureResult(0).setLabel(buf.toString());
		} else {
			context.getFutureResult(0).setLabel(""Event log array from file '"" + filename + ""'"");
		}
	}

	private String greatestCommonPrefix(String a, String b) {
		int minLength = Math.min(a.length(), b.length());
		for (int i = 0; i < minLength; i++) {
			if (a.charAt(i) != b.charAt(i)) {
				return a.substring(0, i);
			}
		}
		return a.substring(0, minLength);
	}
}
"
ImportXEventClassifierListPlugin.java,log,"package org.processmining.log.plugins;

import java.io.InputStream;

import javax.xml.parsers.SAXParser;
import javax.xml.parsers.SAXParserFactory;

import org.processmining.contexts.uitopia.annotations.UIImportPlugin;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.log.models.XEventClassifierList;
import org.processmining.log.parsers.SaxHandlerGlobalEventAttributesParser;
import org.processmining.log.parsers.SaxHandlerXEventClassifierParser;
import org.processmining.plugins.log.OpenLogFilePlugin;

@Plugin(name = ""Import XEvent Classifiers list form event log"", parameterLabels = { ""Filename"" }, returnLabels = {
		""XEventClassifier List"" }, returnTypes = {
				XEventClassifierList.class }, help = ""This plugin performs a lightweight read of the XLog and retrieves the available XEventClassifiers as a list. This plugins is mainly used by RapidProM"")
@UIImportPlugin(description = ""Import XEvent Classifiers list form event log"", extensions = { ""xes"", ""zip"", ""gz"" })
public class ImportXEventClassifierListPlugin extends OpenLogFilePlugin {
	protected XEventClassifierList importFromStream(PluginContext context, InputStream input, String filename,
			long fileSizeInBytes) throws Exception {
		SAXParserFactory saxFactory = SAXParserFactory.newInstance();
		try {
			saxFactory.setValidating(false);
			saxFactory.setNamespaceAware(false);
			saxFactory.setSchema(null);
		} catch (UnsupportedOperationException e) {

		}
		InputStream is = getInputStream(getFile());
		SAXParser globalsParser = saxFactory.newSAXParser();
		SaxHandlerGlobalEventAttributesParser globalsHandler = new SaxHandlerGlobalEventAttributesParser();
		globalsParser.parse(is, globalsHandler);
		is.close();

		is = getInputStream(getFile());
		SAXParser classifiersParser = saxFactory.newSAXParser();
		SaxHandlerXEventClassifierParser classifiersHandler = new SaxHandlerXEventClassifierParser(
				globalsHandler.getGlobalEventAttributes());
		classifiersParser.parse(is, classifiersHandler);
		is.close();

		return classifiersHandler.getClassifierList();
	}
}
"
LogCentralityFilterPlugin.java,log,"package org.processmining.log.plugins;

import java.util.Collection;

import org.deckfour.uitopia.api.event.TaskListener.InteractionResult;
import org.deckfour.xes.model.XLog;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.connections.ConnectionCannotBeObtained;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginCategory;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.log.algorithms.LogCentralityFilterAlgorithm;
import org.processmining.log.connections.LogCentralityFilterConnection;
import org.processmining.log.dialogs.LogCentralityFilterDialog;
import org.processmining.log.help.LogCentralityFilterHelp;
import org.processmining.log.models.LogCentrality;
import org.processmining.log.parameters.LogCentralityFilterParameters;

@Plugin(name = ""Happify Log"", categories = { PluginCategory.Filtering }, parameterLabels = { ""Happifiable Log"", ""Parameters"" }, returnLabels = { ""Happified Log"" }, returnTypes = { XLog.class }, help = LogCentralityFilterHelp.TEXT)
public class LogCentralityFilterPlugin extends LogCentralityFilterAlgorithm {

	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""H.M.W. Verbeek"", email = ""h.m.w.verbeek@tue.nl"", pack=""Log"")
	@PluginVariant(variantLabel = ""Happify Log, UI"", requiredParameterLabels = { 0 })
	public XLog runDialog(UIPluginContext context, LogCentrality centrality) {
		LogCentralityFilterParameters parameters = new LogCentralityFilterParameters(centrality);
		LogCentralityFilterDialog dialog = new LogCentralityFilterDialog(context, centrality, parameters);
		InteractionResult result = context.showWizard(""Configure Happification of Log"", true, true, dialog);
		if (result != InteractionResult.FINISHED) {
			return null;
		}
		return runConnections(context, centrality, parameters);
	}
	
	@PluginVariant(variantLabel = ""Happify Log, Parameters"", requiredParameterLabels = { 0, 1 })
	public XLog runParameters(PluginContext context, LogCentrality centrality, LogCentralityFilterParameters parameters) {
		return runConnections(context, centrality, parameters);
	}
	
	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""H.M.W. Verbeek"", email = ""h.m.w.verbeek@tue.nl"", pack=""Log"")
	@PluginVariant(variantLabel = ""Happify Log, Default"", requiredParameterLabels = { 0 })
	public XLog runDefault(PluginContext context, LogCentrality centrality) {
		LogCentralityFilterParameters parameters = new LogCentralityFilterParameters(centrality);
		return runConnections(context, centrality, parameters);
	}
	
	private XLog runConnections(PluginContext context, LogCentrality centrality, LogCentralityFilterParameters parameters) {
		if (parameters.isTryConnections()) {
			Collection<LogCentralityFilterConnection> connections;
			try {
				connections = context.getConnectionManager().getConnections(
						LogCentralityFilterConnection.class, context, centrality);
				for (LogCentralityFilterConnection connection : connections) {
					if (connection.getObjectWithRole(LogCentralityFilterConnection.LOGCENTRALITY)
							.equals(centrality) && connection.getParameters().equals(parameters)) {
						return connection
								.getObjectWithRole(LogCentralityFilterConnection.LOG);
					}
				}
			} catch (ConnectionCannotBeObtained e) {
			}
		}
		XLog filteredLog = apply(context, centrality, parameters);
		if (parameters.isTryConnections()) {
			context.getConnectionManager().addConnection(
					new LogCentralityFilterConnection(filteredLog, centrality, parameters));
		}
		return filteredLog;
	}
}
"
LogCentralityPlugin.java,log,"package org.processmining.log.plugins;

import java.util.Collection;

import org.deckfour.uitopia.api.event.TaskListener.InteractionResult;
import org.deckfour.xes.model.XLog;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.connections.ConnectionCannotBeObtained;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginCategory;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.log.algorithms.LogCentralityAlgorithm;
import org.processmining.log.connections.LogCentralityConnection;
import org.processmining.log.dialogs.LogCentralityDialog;
import org.processmining.log.help.LogCentralityHelp;
import org.processmining.log.models.LogCentrality;
import org.processmining.log.parameters.LogCentralityParameters;

@Plugin(name = ""Create Happifiable Log"", categories = { PluginCategory.Enhancement }, parameterLabels = { ""Event Log"", ""Parameters"" }, returnLabels = { ""Happifiable Log"" }, returnTypes = { LogCentrality.class }, help = LogCentralityHelp.TEXT)
public class LogCentralityPlugin extends LogCentralityAlgorithm {

	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""H.M.W. Verbeek"", email = ""h.m.w.verbeek@tue.nl"", pack=""Log"")
	@PluginVariant(variantLabel = ""Create Happifiable Log, UI"", requiredParameterLabels = { 0 })
	public LogCentrality runUI(UIPluginContext context, XLog log) {
		LogCentralityParameters parameters = new LogCentralityParameters(log);
		LogCentrality centrality = new LogCentrality(log);
		LogCentralityDialog dialog = new LogCentralityDialog(context, log, centrality, parameters);
		InteractionResult result = context.showWizard(""Configure Creation of Happifiable Log"", true, true, dialog);
		if (result != InteractionResult.FINISHED) {
			return null;
		}
		return runConnections(context, log, centrality, parameters);
	}
	
	/**
	 * @deprecated Use runUI() instead.
	 */
	@Deprecated
	public LogCentrality runDialog(UIPluginContext context, XLog log) {
		return runUI(context, log);
	}
	
	@PluginVariant(variantLabel = ""Create Happifiable Log, Parameters"", requiredParameterLabels = { 0, 1 })
	public LogCentrality run(PluginContext context, XLog log, LogCentralityParameters parameters) {
		LogCentrality centrality = new LogCentrality(log);
		return runConnections(context, log, centrality, parameters);
	}
	
	/**
	 * @deprecated Use runUI() instead.
	 */
	@Deprecated
	public LogCentrality runParameters(PluginContext context, XLog log, LogCentralityParameters parameters) {
		return run(context, log, parameters);
	}
	
	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""H.M.W. Verbeek"", email = ""h.m.w.verbeek@tue.nl"", pack=""Log"")
	@PluginVariant(variantLabel = ""Create Happifiable Log, Default"", requiredParameterLabels = { 0 })
	public LogCentrality runDefault(PluginContext context, XLog log) {
		LogCentralityParameters parameters = new LogCentralityParameters(log);
		LogCentrality centrality = new LogCentrality(log);
		return runConnections(context, log, centrality, parameters);
	}
	
	private LogCentrality runConnections(PluginContext context, XLog log, LogCentrality centrality, LogCentralityParameters parameters) {
		if (parameters.isTryConnections()) {
			Collection<LogCentralityConnection> connections;
			try {
				connections = context.getConnectionManager().getConnections(
						LogCentralityConnection.class, context, log);
				for (LogCentralityConnection connection : connections) {
					if (connection.getObjectWithRole(LogCentralityConnection.LOG)
							.equals(log) && connection.getParameters().equals(parameters)) {
						return connection
								.getObjectWithRole(LogCentralityConnection.LOGCENTRALITY);
					}
				}
			} catch (ConnectionCannotBeObtained e) {
			}
		}
		LogCentrality logCentrality = apply(context, log, centrality, parameters);
		if (parameters.isTryConnections()) {
			context.getConnectionManager().addConnection(
					new LogCentralityConnection(log, logCentrality, parameters));
		}
		return logCentrality;
	}
}
"
LogCentralityVisualizerPlugin.java,log,"package org.processmining.log.plugins;

import javax.swing.JComponent;

import org.deckfour.xes.info.XLogInfo;
import org.deckfour.xes.info.XLogInfoFactory;
import org.processmining.contexts.uitopia.annotations.Visualizer;
import org.processmining.framework.connections.ConnectionCannotBeObtained;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.log.algorithms.LogCentralityVisualizerAlgorithm;
import org.processmining.log.models.LogCentrality;

public class LogCentralityVisualizerPlugin extends LogCentralityVisualizerAlgorithm {

	@Plugin(name = ""Log Summary"", parameterLabels = ""Happifiable Log"", returnTypes = JComponent.class, returnLabels = ""Log Visualization"", userAccessible = false, mostSignificantResult = 1, help = ""Provides an overview of the centralized log"")
	@Visualizer(name = ""Log Summary"")
	public JComponent visualizeLog(PluginContext context, LogCentrality centrality) throws ConnectionCannotBeObtained {
		XLogInfo info = XLogInfoFactory.createLogInfo(centrality.getLog(), centrality.getClassifier());
		JComponent component = context.tryToFindOrConstructFirstNamedObject(JComponent.class, ""  Log Summary"", null,
				null, centrality.getLog(), info);
		return component;
	}

	@Plugin(name = ""Trace Happiness"", parameterLabels = ""Happifiable Log"", returnTypes = JComponent.class, returnLabels = ""Log Visualization"", userAccessible = false, mostSignificantResult = 1, help = ""Provides an overview of the centralized log"")
	@Visualizer(name = ""Trace Happiness Visualizer"")
	public JComponent visualize(PluginContext context, LogCentrality centrality) {
		return apply(centrality, null);
	}

}
"
LogCheckerPlugin.java,log,"package org.processmining.log.plugins;

import java.util.EnumSet;

import org.deckfour.xes.model.XLog;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.framework.util.HTMLToString;
import org.processmining.log.algorithms.LogCheckerAlgorithm;
import org.processmining.log.help.LogCheckerHelp;
import org.processmining.log.logchecks.LogCheckType;
import org.processmining.log.models.LogCheckerReport;
import org.processmining.log.parameters.LogCheckerParameters;

@Plugin(name = ""Check Log"", categories = {}, parameterLabels = { ""Log"", ""Parameters"" }, returnLabels = {
		""Log Check Report"" }, returnTypes = { HTMLToString.class }, help = LogCheckerHelp.TEXT)
public class LogCheckerPlugin extends LogCheckerAlgorithm {

	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""Eric Verbeek"", email = ""h.m.w.verbeek@tue.nl"", website = ""www.processmining.org"")
	@PluginVariant(variantLabel = ""Check Log, default"", requiredParameterLabels = { 0 })
	public LogCheckerReport runDefault(PluginContext context, XLog log) {
		LogCheckerParameters parameters = new LogCheckerParameters();
		parameters.setLogChecks(EnumSet.of(
				LogCheckType.LOG_CHECK_EVENT_CLASSIFIERS_GLOBAL,
				LogCheckType.LOG_CHECK_GLOBAL_ATTRIBUTE, 
				LogCheckType.LOG_CHECK_CONSISTENT_TYPES));
		return apply(context, log, parameters);
	}
}
"
LogFrequencyArrayPlugin.java,log,"package org.processmining.log.plugins;

import org.deckfour.uitopia.api.event.TaskListener.InteractionResult;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.log.dialogs.LogFrequencyDialog;
import org.processmining.log.help.LogFrequencyArrayHelp;
import org.processmining.log.models.EventLogArray;
import org.processmining.log.models.LogFrequencyArray;
import org.processmining.log.parameters.LogFrequencyParameters;

@Plugin(name = ""Create Frequency Distributions"", parameterLabels = { ""Event Logs"" }, returnLabels = { ""Log Frequency Distribution"" }, returnTypes = { LogFrequencyArray.class }, userAccessible = true, help = LogFrequencyArrayHelp.TEXT)
public class LogFrequencyArrayPlugin {

	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""Eric Verbeek"", email = ""h.m.w.verbeek@tue.nl"", website = ""www.processmining.org"")
	@PluginVariant(variantLabel = ""Create Frequency Distributions, UI"", requiredParameterLabels = { 0 })
	public LogFrequencyArray runUI(UIPluginContext context, EventLogArray logs) {
		LogFrequencyParameters parameters = new LogFrequencyParameters(logs.getLog(0));
		LogFrequencyDialog dialog = new LogFrequencyDialog(logs.getLog(0), parameters);
		InteractionResult result = context.showWizard(""Configure Frequency Distributions (classifier)"", true, true,
				dialog);
		if (result != InteractionResult.FINISHED) {
			return null;
		}
		return (new LogFrequencyArrayPlugin()).run(context, logs, parameters);
	}

	/**
	 * @deprecated Use runUI() instead.
	 */
	@Deprecated
	public LogFrequencyArray publicUI(UIPluginContext context, EventLogArray logs) {
		return runUI(context, logs);
		
	}
	@PluginVariant(variantLabel = ""Create Frequency Distributions, Parameters"", requiredParameterLabels = { 0 })
	public LogFrequencyArray run(PluginContext context, EventLogArray logs, LogFrequencyParameters parameters) {
		return (new LogFrequencyArrayPlugin()).run(context, logs, parameters);
	}

	/**
	 * @deprecated Use run() instead.
	 */
	@Deprecated
	public LogFrequencyArray publicParameters(PluginContext context, EventLogArray logs, LogFrequencyParameters parameters) {
		return run(context, logs, parameters);
	}
	
	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""Eric Verbeek"", email = ""h.m.w.verbeek@tue.nl"", website = ""www.processmining.org"")
	@PluginVariant(variantLabel = ""Create Frequency Distributions, Default"", requiredParameterLabels = { 0 })
	public LogFrequencyArray runDefault(PluginContext context, EventLogArray logs) {
		LogFrequencyParameters parameters = new LogFrequencyParameters(logs.getLog(0));
		return (new LogFrequencyArrayPlugin()).run(context, logs, parameters);
	}
	
	/**
	 * @deprecated Use runDefault() instead.
	 */
	@Deprecated
	public LogFrequencyArray publicDefault(PluginContext context, EventLogArray logs) {
		return runDefault(context, logs);
	}
}
"
LogFrequencyPlugin.java,log,"package org.processmining.log.plugins;

import java.util.Collection;

import org.deckfour.uitopia.api.event.TaskListener.InteractionResult;
import org.deckfour.xes.model.XLog;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.connections.ConnectionCannotBeObtained;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.log.algorithms.LogFrequencyAlgorithm;
import org.processmining.log.connections.LogFrequencyConnection;
import org.processmining.log.dialogs.LogFrequencyDialog;
import org.processmining.log.help.LogFrequencyHelp;
import org.processmining.log.models.LogFrequency;
import org.processmining.log.parameters.LogFrequencyParameters;

@Plugin(name = ""Create Frequency Distribution"", parameterLabels = { ""Event Log"" }, returnLabels = { ""Log Frequency Distribution"" }, returnTypes = { LogFrequency.class }, userAccessible = true, help = LogFrequencyHelp.TEXT)
public class LogFrequencyPlugin {

	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""Eric Verbeek"", email = ""h.m.w.verbeek@tue.nl"", website = ""www.processmining.org"")
	@PluginVariant(variantLabel = ""Create Frequency Distribution, UI"", requiredParameterLabels = { 0 })
	public LogFrequency runUI(UIPluginContext context, XLog log) {
		LogFrequencyParameters parameters = new LogFrequencyParameters(log);
		LogFrequencyDialog dialog = new LogFrequencyDialog(log, parameters);
		InteractionResult result = context.showWizard(""Configure Frequency Distribution (classifier)"", true, true,
				dialog);
		if (result != InteractionResult.FINISHED) {
			return null;
		}
		return runConnections(context, log, parameters);
	}

	/**
	 * @deprecated Use runUI() instead.
	 */
	@Deprecated
	public LogFrequency publicUI(UIPluginContext context, XLog log) {
		return runUI(context, log);
	}
	
	@PluginVariant(variantLabel = ""Create Frequency Distribution, Parameters"", requiredParameterLabels = { 0 })
	public LogFrequency run(PluginContext context, XLog log, LogFrequencyParameters parameters) {
		return runConnections(context, log, parameters);
	}

	/**
	 * @deprecated Use run() instead.
	 */
	@Deprecated
	public LogFrequency publicParameters(PluginContext context, XLog log, LogFrequencyParameters parameters) {
		return run(context, log, parameters);
	}
	
	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""Eric Verbeek"", email = ""h.m.w.verbeek@tue.nl"", website = ""www.processmining.org"")
	@PluginVariant(variantLabel = ""Create Frequency Distribution, Default"", requiredParameterLabels = { 0 })
	public LogFrequency runDefault(PluginContext context, XLog log) {
		LogFrequencyParameters parameters = new LogFrequencyParameters(log);
		return runConnections(context, log, parameters);
	}

	/**
	 * @deprecated Use runDefault() instead.
	 */
	@Deprecated
	public LogFrequency publicDefault(PluginContext context, XLog log) {
		return runDefault(context, log);
	}

	private LogFrequency runConnections(PluginContext context, XLog log, LogFrequencyParameters parameters) {
		if (parameters.isTryConnections()) {
			Collection<LogFrequencyConnection> connections;
			try {
				connections = context.getConnectionManager().getConnections(
						LogFrequencyConnection.class, context, log);
				for (LogFrequencyConnection connection : connections) {
					if (connection.getObjectWithRole(LogFrequencyConnection.LOG)
							.equals(log) && connection.getParameters().equals(parameters)) {
						return connection
								.getObjectWithRole(LogFrequencyConnection.LOGFREQUENCY);
					}
				}
			} catch (ConnectionCannotBeObtained e) {
			}
		}
		LogFrequency logFrequency = (new LogFrequencyAlgorithm()).apply(context, log, parameters);
		if (parameters.isTryConnections()) {
			context.getConnectionManager().addConnection(
					new LogFrequencyConnection(log, logFrequency, parameters));
		}
		return logFrequency;
	}
}
"
LowFrequencyFilterArrayPlugin.java,log,"package org.processmining.log.plugins;

import org.deckfour.uitopia.api.event.TaskListener.InteractionResult;
import org.deckfour.xes.model.XLog;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginCategory;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.log.algorithms.LowFrequencyFilterAlgorithm;
import org.processmining.log.dialogs.LowFrequencyFilterDialog;
import org.processmining.log.help.LowFrequencyFilterArrayHelp;
import org.processmining.log.models.EventLogArray;
import org.processmining.log.models.impl.EventLogArrayFactory;
import org.processmining.log.parameters.LowFrequencyFilterParameters;

@Plugin(name = ""Filter Out Low-Frequency Traces (Multiple Logs)"", categories = { PluginCategory.Filtering }, parameterLabels = { ""Event Logs"" }, returnLabels = { ""Filtered Logs"" }, returnTypes = { EventLogArray.class }, userAccessible = true, help = LowFrequencyFilterArrayHelp.TEXT)
public class LowFrequencyFilterArrayPlugin {

	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""Eric Verbeek"", email = ""h.m.w.verbeek@tue.nl"", website = ""www.processmining.org"")
	@PluginVariant(variantLabel = ""Filter Out Low-Frequency Traces (Multiple Logs), UI"", requiredParameterLabels = { 0 })
	public EventLogArray runUI(UIPluginContext context, EventLogArray logs) {
		if (logs.getSize() > 0) {
			XLog log = logs.getLog(0);
			LowFrequencyFilterParameters parameters = new LowFrequencyFilterParameters(log);
			LowFrequencyFilterDialog dialog = new LowFrequencyFilterDialog(log, parameters);
			InteractionResult result = context.showWizard(""Configure Low-Frequency Filter"", true, true, dialog);
			if (result != InteractionResult.FINISHED) {
				return null;
			}
			EventLogArray filteredLogs = EventLogArrayFactory.createEventLogArray();
			filteredLogs.init();
			for (int i = 0; i < logs.getSize(); i++) {
				filteredLogs.addLog((new LowFrequencyFilterPlugin()).run(context, logs.getLog(i), parameters));
			}
			return filteredLogs;
		}
		return null;
	}

	/**
	 * @deprecated Use runUI instead.
	 */
	@Deprecated
	public EventLogArray publicUIArray(UIPluginContext context, EventLogArray logs) {
		return runUI(context, logs);
	}
	
	@PluginVariant(variantLabel = ""Filter Out Low-Frequency Traces (Multiple Logs), Parameters"", requiredParameterLabels = { 0 })
	public EventLogArray run(PluginContext context, EventLogArray logs,
			LowFrequencyFilterParameters parameters) {
		if (logs.getSize() > 0) {
			EventLogArray filteredLogs = EventLogArrayFactory.createEventLogArray();
			filteredLogs.init();
			for (int i = 0; i < logs.getSize(); i++) {
				filteredLogs.addLog((new LowFrequencyFilterAlgorithm()).apply(context, logs.getLog(i), parameters));
			}
			return filteredLogs;
		}
		return null;
	}

	/**
	 * @deprecated Use run instead.
	 */
	@Deprecated
	public EventLogArray publicParameters(PluginContext context, EventLogArray logs,
			LowFrequencyFilterParameters parameters) {
		return run(context, logs, parameters);
	}
	
	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""Eric Verbeek"", email = ""h.m.w.verbeek@tue.nl"", website = ""www.processmining.org"")
	@PluginVariant(variantLabel = ""Filter Out Low-Frequency Traces (Multiple Logs), Default"", requiredParameterLabels = { 0 })
	public EventLogArray runDefault(PluginContext context, EventLogArray logs) {
		if (logs.getSize() > 0) {
			LowFrequencyFilterParameters parameters = new LowFrequencyFilterParameters(logs.getLog(0));
			EventLogArray filteredLogs = EventLogArrayFactory.createEventLogArray();
			filteredLogs.init();
			for (int i = 0; i < logs.getSize(); i++) {
				filteredLogs.addLog((new LowFrequencyFilterAlgorithm()).apply(context, logs.getLog(i), parameters));
			}
			return filteredLogs;
		}
		return null;
	}

	/**
	 * @deprecated Use runDefault instead.
	 */
	@Deprecated
	public EventLogArray publicDefault(PluginContext context, EventLogArray logs) {
		return runDefault(context, logs);
	}
}
"
LowFrequencyFilterPlugin.java,log,"package org.processmining.log.plugins;

import java.util.Collection;

import org.deckfour.uitopia.api.event.TaskListener.InteractionResult;
import org.deckfour.xes.model.XLog;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.connections.ConnectionCannotBeObtained;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginCategory;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.log.algorithms.LowFrequencyFilterAlgorithm;
import org.processmining.log.connections.LowFrequencyFilterConnection;
import org.processmining.log.dialogs.LowFrequencyFilterDialog;
import org.processmining.log.help.LowFrequencyFilterHelp;
import org.processmining.log.parameters.LowFrequencyFilterParameters;

@Plugin(name = ""Filter Out Low-Frequency Traces (Single Log)"", categories = { PluginCategory.Filtering }, parameterLabels = {""Event Log""}, returnLabels = { ""Filtered Log"" }, returnTypes = {XLog.class }, userAccessible = true, help = LowFrequencyFilterHelp.TEXT)
public class LowFrequencyFilterPlugin {

	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""Eric Verbeek"", email = ""h.m.w.verbeek@tue.nl"", website = ""www.processmining.org"")
	@PluginVariant(variantLabel = ""Filter Out Low-Frequency Traces (Single Log), UI"", requiredParameterLabels = { 0 })
	public XLog runUI(UIPluginContext context, XLog log) {
		LowFrequencyFilterParameters parameters = new LowFrequencyFilterParameters(log);
		LowFrequencyFilterDialog dialog = new LowFrequencyFilterDialog(log, parameters);
		InteractionResult result = context.showWizard(""Configure Low-Frequency Filter"", true, true, dialog);
		if (result != InteractionResult.FINISHED) {
			return null;
		}
		return runConnections(context, log, parameters);
	}
	
	/**
	 * @deprecated Use runUI instead.
	 */
	@Deprecated
	public XLog publicUI(UIPluginContext context, XLog log) {
		return runUI(context, log);
	}
	
	@PluginVariant(variantLabel = ""Filter Out Low-Frequency Traces (Single Log), Parameters"", requiredParameterLabels = { 0 })
	public XLog run(PluginContext context, XLog log, LowFrequencyFilterParameters parameters) {
		return runConnections(context, log, parameters);
	}
	
	/**
	 * @deprecated Use run instead.
	 */
	@Deprecated
	public XLog publicParameters(PluginContext context, XLog log, LowFrequencyFilterParameters parameters) {
		return run(context, log, parameters);
	}
	
	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""Eric Verbeek"", email = ""h.m.w.verbeek@tue.nl"", website = ""www.processmining.org"")
	@PluginVariant(variantLabel = ""Filter Out Low-Frequency Traces (Single Log), Default"", requiredParameterLabels = { 0 })
	public XLog runDefault(PluginContext context, XLog log) {
		LowFrequencyFilterParameters parameters = new LowFrequencyFilterParameters(log);
		return runConnections(context, log, parameters);
	}

	/**
	 * @deprecated Use run instead.
	 */
	@Deprecated
	public XLog publicDefault(PluginContext context, XLog log) {
		return runDefault(context, log);
	}
	
	private XLog runConnections(PluginContext context, XLog log, LowFrequencyFilterParameters parameters) {
		if (parameters.isTryConnections()) {
			Collection<LowFrequencyFilterConnection> connections;
			try {
				connections = context.getConnectionManager().getConnections(
						LowFrequencyFilterConnection.class, context, log);
				for (LowFrequencyFilterConnection connection : connections) {
					if (connection.getObjectWithRole(LowFrequencyFilterConnection.LOG)
							.equals(log) && connection.getParameters().equals(parameters)) {
						return connection
								.getObjectWithRole(LowFrequencyFilterConnection.FILTEREDLOG);
					}
				}
			} catch (ConnectionCannotBeObtained e) {
			}
		}
		XLog filteredLog = (new LowFrequencyFilterAlgorithm()).apply(context, log, parameters);
		if (parameters.isTryConnections()) {
			context.getConnectionManager().addConnection(
					new LowFrequencyFilterConnection(log, filteredLog, parameters));
		}
		return filteredLog;
	}
}
"
LowOccurrencesFilterArrayPlugin.java,log,"package org.processmining.log.plugins;

import org.deckfour.uitopia.api.event.TaskListener.InteractionResult;
import org.deckfour.xes.model.XLog;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginCategory;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.log.dialogs.LowOccurrencesFilterDialog;
import org.processmining.log.help.LowOccurrencesFilterArrayHelp;
import org.processmining.log.models.EventLogArray;
import org.processmining.log.models.impl.EventLogArrayFactory;
import org.processmining.log.parameters.LowOccurrencesFilterParameters;

@Plugin(name = ""Filter Out Low-Occurrence Traces (Multiple Logs)"", categories = { PluginCategory.Filtering }, parameterLabels = { ""Event Logs"" }, returnLabels = { ""Filtered Logs"" }, returnTypes = { EventLogArray.class }, userAccessible = true, help = LowOccurrencesFilterArrayHelp.TEXT)
public class LowOccurrencesFilterArrayPlugin {

	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""Eric Verbeek"", email = ""h.m.w.verbeek@tue.nl"", website = ""www.processmining.org"")
	@PluginVariant(variantLabel = ""Filter Out Low-Occurrence Traces (Multiple Logs), UI"", requiredParameterLabels = { 0 })
	public EventLogArray runUI(UIPluginContext context, EventLogArray logs) {
		if (logs.getSize() > 0) {
			XLog log = logs.getLog(0);
			LowOccurrencesFilterParameters parameters = new LowOccurrencesFilterParameters(log);
			LowOccurrencesFilterDialog dialog = new LowOccurrencesFilterDialog(log, parameters);
			InteractionResult result = context.showWizard(""Configure Low-Occurrence Filter"", true, true, dialog);
			if (result != InteractionResult.FINISHED) {
				return null;
			}
			EventLogArray filteredLogs = EventLogArrayFactory.createEventLogArray();
			filteredLogs.init();
			for (int i = 0; i < logs.getSize(); i++) {
				filteredLogs.addLog((new LowOccurrencesFilterPlugin()).run(context, logs.getLog(i), parameters));
			}
			return filteredLogs;
		}
		return null;
	}

	/**
	 * @deprecated Use runUI instead.
	 */
	@Deprecated
	public EventLogArray publicUIArray(UIPluginContext context, EventLogArray logs) {
		return runUI(context, logs);
	}
	
	@PluginVariant(variantLabel = ""Filter Out Low-Occurrence Traces (Multiple Logs), Parameters"", requiredParameterLabels = { 0 })
	public EventLogArray run(PluginContext context, EventLogArray logs,
			LowOccurrencesFilterParameters parameters) {
		if (logs.getSize() > 0) {
			EventLogArray filteredLogs = EventLogArrayFactory.createEventLogArray();
			filteredLogs.init();
			for (int i = 0; i < logs.getSize(); i++) {
				filteredLogs.addLog((new LowOccurrencesFilterPlugin()).run(context, logs.getLog(i), parameters));
			}
			return filteredLogs;
		}
		return null;
	}

	/**
	 * @deprecated Use run instead.
	 */
	@Deprecated
	public EventLogArray publicParameters(UIPluginContext context, EventLogArray logs,
			LowOccurrencesFilterParameters parameters) {
		return run(context, logs, parameters);
	}
	
	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""Eric Verbeek"", email = ""h.m.w.verbeek@tue.nl"", website = ""www.processmining.org"")
	@PluginVariant(variantLabel = ""Filter Out Low-Occurrence Traces (Multiple Logs), Default"", requiredParameterLabels = { 0 })
	public EventLogArray runDefault(PluginContext context, EventLogArray logs) {
		if (logs.getSize() > 0) {
			LowOccurrencesFilterParameters parameters = new LowOccurrencesFilterParameters(logs.getLog(0));
			EventLogArray filteredLogs = EventLogArrayFactory.createEventLogArray();
			filteredLogs.init();
			for (int i = 0; i < logs.getSize(); i++) {
				filteredLogs.addLog((new LowOccurrencesFilterPlugin()).run(context, logs.getLog(i), parameters));
			}
			return filteredLogs;
		}
		return null;
	}

	/**
	 * @deprecated Use runDefault instead.
	 */
	@Deprecated
	public EventLogArray publicDefault(UIPluginContext context, EventLogArray logs) {
		return runDefault(context, logs);
	}
	
}
"
LowOccurrencesFilterPlugin.java,log,"package org.processmining.log.plugins;

import java.util.Collection;

import org.deckfour.uitopia.api.event.TaskListener.InteractionResult;
import org.deckfour.xes.model.XLog;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.connections.ConnectionCannotBeObtained;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginCategory;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.log.algorithms.LowOccurrencesFilterAlgorithm;
import org.processmining.log.connections.LowOccurrencesFilterConnection;
import org.processmining.log.dialogs.LowOccurrencesFilterDialog;
import org.processmining.log.help.LowOccurrencesFilterHelp;
import org.processmining.log.parameters.LowOccurrencesFilterParameters;

@Plugin(name = ""Filter Out Low-Occurrence Traces (Single Log)"", categories = { PluginCategory.Filtering }, parameterLabels = { ""Event Log"" }, returnLabels = { ""Filtered Log"" }, returnTypes = { XLog.class }, userAccessible = true, help = LowOccurrencesFilterHelp.TEXT)
public class LowOccurrencesFilterPlugin {

	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""Eric Verbeek"", email = ""h.m.w.verbeek@tue.nl"", website = ""www.processmining.org"")
	@PluginVariant(variantLabel = ""Filter Out Low-Occurrence Traces (Single Log), UI"", requiredParameterLabels = { 0 })
	public XLog runUI(UIPluginContext context, XLog log) {
		LowOccurrencesFilterParameters parameters = new LowOccurrencesFilterParameters(log);
		LowOccurrencesFilterDialog dialog = new LowOccurrencesFilterDialog(log, parameters);
		InteractionResult result = context.showWizard(""Configure Low-Occurrence Filter"", true, true, dialog);
		if (result != InteractionResult.FINISHED) {
			return null;
		}
		return runConnections(context, log, parameters);
	}

	/**
	 * @deprecated Use runUI instead.
	 */
	@Deprecated
	public XLog publicUI(UIPluginContext context, XLog log) {
		return runUI(context, log);
	}
	
	@PluginVariant(variantLabel = ""Filter Out Low-Occurrence Traces (Single Log), Parameters"", requiredParameterLabels = { 0 })
	public XLog run(PluginContext context, XLog log, LowOccurrencesFilterParameters parameters) {
		return runConnections(context, log, parameters);
	}

	/**
	 * @deprecated Use run instead.
	 */
	@Deprecated
	public XLog publicParameters(UIPluginContext context, XLog log, LowOccurrencesFilterParameters parameters) {
		return run(context, log, parameters);
	}
	
	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""Eric Verbeek"", email = ""h.m.w.verbeek@tue.nl"", website = ""www.processmining.org"")
	@PluginVariant(variantLabel = ""Filter Out Low-Occurrence Traces (Single Log), Default"", requiredParameterLabels = { 0 })
	public XLog runDefault(PluginContext context, XLog log) {
		LowOccurrencesFilterParameters parameters = new LowOccurrencesFilterParameters(log);
		return runConnections(context, log, parameters);
	}
	
	/**
	 * @deprecated Use runDefault instead.
	 */
	@Deprecated
	public XLog publicDefault(UIPluginContext context, XLog log) {
		return runDefault(context, log);
	}
	
	private XLog runConnections(PluginContext context, XLog log, LowOccurrencesFilterParameters parameters) {
		if (parameters.isTryConnections()) {
			Collection<LowOccurrencesFilterConnection> connections;
			try {
				connections = context.getConnectionManager().getConnections(
						LowOccurrencesFilterConnection.class, context, log);
				for (LowOccurrencesFilterConnection connection : connections) {
					if (connection.getObjectWithRole(LowOccurrencesFilterConnection.LOG)
							.equals(log) && connection.getParameters().equals(parameters)) {
						return connection
								.getObjectWithRole(LowOccurrencesFilterConnection.FILTEREDLOG);
					}
				}
			} catch (ConnectionCannotBeObtained e) {
			}
		}
		XLog filteredLog = (new LowOccurrencesFilterAlgorithm()).apply(context, log, parameters);
		if (parameters.isTryConnections()) {
			context.getConnectionManager().addConnection(
					new LowOccurrencesFilterConnection(log, filteredLog, parameters));
		}
		return filteredLog;
	}

}
"
MergeLogsPlugin.java,log,"package org.processmining.log.plugins;

import org.deckfour.uitopia.api.event.TaskListener.InteractionResult;
import org.deckfour.xes.model.XLog;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginCategory;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.log.algorithms.MergeLogsAlgorithm;
import org.processmining.log.dialogs.MergeLogsDialog;
import org.processmining.log.help.MergeLogsHelp;
import org.processmining.log.parameters.MergeLogsParameters;

@Plugin(name = ""Merge logs"", categories = { PluginCategory.Filtering }, parameterLabels = { ""Main Log"", ""Sub log"", ""Parameters"" }, 
returnLabels = { ""Merged logs"" }, returnTypes = { XLog.class }, help = MergeLogsHelp.TEXT)
public class MergeLogsPlugin extends MergeLogsAlgorithm {

	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""H.M.W. Verbeek"", email = ""h.m.w.verbeek@tue.nl"")
	@PluginVariant(variantLabel = ""Decomposed Discovery, UI"", requiredParameterLabels = { 0, 1 })
	public XLog runUI(UIPluginContext context, XLog mainLog, XLog subLog) {
		MergeLogsParameters parameters = new MergeLogsParameters();
		MergeLogsDialog dialog = new MergeLogsDialog(parameters, mainLog);
		InteractionResult result = context.showWizard(""Configure merge"", true, true, dialog);
		if (result != InteractionResult.FINISHED) {
			context.getFutureResult(0).cancel(true);
			return null;
		}
		return run(context, mainLog, subLog, parameters);
	}

	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""H.M.W. Verbeek"", email = ""h.m.w.verbeek@tue.nl"")
	@PluginVariant(variantLabel = ""Merge logs, Default"", requiredParameterLabels = { 0, 1 })
	public XLog run(PluginContext context, XLog mainLog, XLog subLog) {
		MergeLogsParameters parameters = new MergeLogsParameters();

		XLog log = apply(context, mainLog, subLog, parameters);

		return log;
	}

	@PluginVariant(variantLabel = ""Merge logs, Parameters"", requiredParameterLabels = { 0, 1, 2 })
	public XLog run(PluginContext context, XLog mainLog, XLog subLog,
			MergeLogsParameters parameters) {

		XLog log = apply(context, mainLog, subLog, parameters);

		return log;
	}
}
"
SplitLogPlugin.java,log,"package org.processmining.log.plugins;

import org.deckfour.uitopia.api.event.TaskListener.InteractionResult;
import org.deckfour.xes.model.XLog;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginCategory;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.log.algorithms.SplitLogAlgorithm;
import org.processmining.log.dialogs.SplitLogDialog;
import org.processmining.log.help.SplitLogHelp;
import org.processmining.log.parameters.SplitLogParameters;

@Plugin(name = ""Split traces"", categories = { PluginCategory.Filtering }, parameterLabels = { ""Log"", ""Parameters"" }, 
returnLabels = { ""Log containing splitted traces"" }, returnTypes = { XLog.class }, help = SplitLogHelp.TEXT)
public class SplitLogPlugin extends SplitLogAlgorithm {

	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""H.M.W. Verbeek"", email = ""h.m.w.verbeek@tue.nl"")
	@PluginVariant(variantLabel = ""Split traces, UI"", requiredParameterLabels = { 0 })
	public XLog runUI(UIPluginContext context, XLog log) {
		SplitLogParameters parameters = new SplitLogParameters(log);
		SplitLogDialog dialog = new SplitLogDialog(parameters, log);
		InteractionResult result = context.showWizard(""Configure split"", true, true, dialog);
		if (result != InteractionResult.FINISHED) {
			context.getFutureResult(0).cancel(true);
			return null;
		}
		return run(context, log, parameters);
	}

	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""H.M.W. Verbeek"", email = ""h.m.w.verbeek@tue.nl"")
	@PluginVariant(variantLabel = ""Merge logs, Default"", requiredParameterLabels = { 0 })
	public XLog run(PluginContext context, XLog log) {
		SplitLogParameters parameters = new SplitLogParameters(log);

		XLog splittedLog = apply(context, log, parameters);

		return splittedLog;
	}

	@PluginVariant(variantLabel = ""Merge logs, Parameters"", requiredParameterLabels = { 0, 1 })
	public XLog run(PluginContext context, XLog log,
			SplitLogParameters parameters) {

		XLog splittedLog = apply(context, log, parameters);

		return splittedLog;
	}
}
"
RepairAttributeDataType.java,log,"package org.processmining.log.repair;

import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.Dimension;
import java.text.DateFormat;
import java.text.ParsePosition;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.ListIterator;
import java.util.Map;
import java.util.Map.Entry;
import java.util.regex.Pattern;

import javax.swing.DefaultCellEditor;
import javax.swing.DefaultComboBoxModel;
import javax.swing.DefaultListCellRenderer;
import javax.swing.JComboBox;
import javax.swing.JComponent;
import javax.swing.JLabel;
import javax.swing.JList;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JTable;
import javax.swing.table.DefaultTableCellRenderer;
import javax.swing.table.DefaultTableModel;
import javax.swing.table.TableCellRenderer;
import javax.swing.table.TableColumnModel;

import org.deckfour.uitopia.api.event.TaskListener.InteractionResult;
import org.deckfour.xes.factory.XFactory;
import org.deckfour.xes.factory.XFactoryRegistry;
import org.deckfour.xes.model.XAttribute;
import org.deckfour.xes.model.XAttributeBoolean;
import org.deckfour.xes.model.XAttributeContinuous;
import org.deckfour.xes.model.XAttributeDiscrete;
import org.deckfour.xes.model.XAttributeLiteral;
import org.deckfour.xes.model.XAttributeMap;
import org.deckfour.xes.model.XAttributeTimestamp;
import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.Progress;
import org.processmining.framework.util.ui.widgets.ProMScrollPane;
import org.processmining.framework.util.ui.widgets.helper.ProMUIHelper;
import org.processmining.framework.util.ui.widgets.helper.UserCancelledException;
import org.processmining.log.formats.StandardDateFormats;

import com.google.common.collect.ImmutableList;
import com.google.common.collect.Iterables;
import com.google.common.collect.Ordering;

/**
 * Tries to automatically guess the data type of all XES attributes and updates
 * the log accordingly.
 * <p>
 * PLEASE NOTE: This filter will update the original XLog instead of creating a
 * new XLog, to be able to process huge logs without exhausting the available
 * memory.
 * 
 * @author F. Mannhardt
 * 
 */
public final class RepairAttributeDataType {

	private static class ReviewTable {

		private Map<String, Class<? extends XAttribute>> attributeDataType;
		private final JTable datatypeTable;
		private final DefaultTableModel tableModel;

		@SuppressWarnings({ ""unchecked"", ""serial"" })
		public ReviewTable(final Map<String, Class<? extends XAttribute>> attributeDataType) {
			super();
			this.attributeDataType = attributeDataType;
			this.tableModel = new DefaultTableModel() {

				public void setValueAt(Object aValue, int row, int column) {
					super.setValueAt(aValue, row, column);
					attributeDataType.put(getColumnName(column), (Class<? extends XAttribute>) aValue);
				}

			};

			for (String attributeKey : Ordering.natural().immutableSortedCopy(attributeDataType.keySet())) {
				Class<? extends XAttribute> dataType = attributeDataType.get(attributeKey);
				tableModel.addColumn(attributeKey, new Class[] { dataType });
			}

			this.datatypeTable = new JTable(tableModel);
			JComboBox<Class<? extends XAttribute>> comboBox = new JComboBox<>(
					new DefaultComboBoxModel<Class<? extends XAttribute>>(new Class[] { XAttributeBoolean.class,
							XAttributeContinuous.class, XAttributeDiscrete.class, XAttributeLiteral.class,
							XAttributeTimestamp.class }));
			comboBox.setRenderer(new DefaultListCellRenderer() {

				@SuppressWarnings(""rawtypes"")
				public Component getListCellRendererComponent(JList<?> list, Object value, int index,
						boolean isSelected, boolean cellHasFocus) {
					JLabel superComponent = (JLabel) super.getListCellRendererComponent(list, value, index, isSelected,
							cellHasFocus);
					superComponent.setText(((Class) value).getSimpleName());
					return superComponent;
				}

			});
			datatypeTable.setDefaultEditor(Object.class, new DefaultCellEditor(comboBox));
			datatypeTable.setDefaultRenderer(Object.class, new DefaultTableCellRenderer() {

				@SuppressWarnings(""rawtypes"")
				public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected,
						boolean hasFocus, int row, int column) {
					JLabel c = (JLabel) super.getTableCellRendererComponent(table, value, isSelected, hasFocus, row,
							column);
					c.setText(((Class) value).getSimpleName());
					return c;
				}

			});

			datatypeTable.setAutoResizeMode(JTable.AUTO_RESIZE_OFF);
			resizeColumnWidth(datatypeTable);
		}

		public Map<String, Class<? extends XAttribute>> getDataTypeMap() {
			return attributeDataType;
		}

		public JComponent getDatatypeTable() {
			JPanel workaroundPanel = new JPanel(new BorderLayout());
			ProMScrollPane scrollPane = new ProMScrollPane(datatypeTable);
			scrollPane.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);
			scrollPane.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_NEVER);
			workaroundPanel.add(scrollPane, BorderLayout.CENTER);
			workaroundPanel.setPreferredSize(new Dimension(400, 200));
			return workaroundPanel;
		}

		public void resizeColumnWidth(JTable table) {
			final TableColumnModel columnModel = table.getColumnModel();
			for (int column = 0; column < table.getColumnCount(); column++) {
				int width = 150; // Min width
				for (int row = 0; row < table.getRowCount(); row++) {
					TableCellRenderer renderer = table.getCellRenderer(row, column);
					Component comp = table.prepareRenderer(renderer, row, column);
					width = Math.max(comp.getPreferredSize().width * 2, width);
				}
				columnModel.getColumn(column).setPreferredWidth(width);
			}
		}

	}

	public interface ReviewCallback {
		Map<String, Class<? extends XAttribute>> reviewDataTypes(
				Map<String, Class<? extends XAttribute>> guessedDataTypes);
	}

	public RepairAttributeDataType() {
		super();
	}

	public void doRepairEventAttributes(PluginContext context, XLog log, Iterable<? extends DateFormat> dateFormats) {
		doRepairEventAttributes(context, log, dateFormats, null);
	}

	public void doRepairEventAttributes(PluginContext context, XLog log, Iterable<? extends DateFormat> dateFormats,
			ReviewCallback reviewCallback) {

		Progress progBar = context.getProgress();
		progBar.setMinimum(0);
		progBar.setMaximum(log.size() * 2); // two pass
		progBar.setValue(0);

		Map<String, Class<? extends XAttribute>> guessedDataType = new HashMap<>();

		// Determine best datatype
		for (XTrace trace : log) {
			for (XEvent event : trace) {
				buildDataTypeMap(event.getAttributes(), guessedDataType, dateFormats);
			}
			if (progBar.isCancelled()) {
				return;
			}
			progBar.inc();
		}

		boolean isDefinite = false;

		if (reviewCallback != null) {
			guessedDataType = reviewCallback.reviewDataTypes(guessedDataType);
			isDefinite = true; // Always obey user input
		}

		XFactory factory = XFactoryRegistry.instance().currentDefault();
		ListIterator<XTrace> traceIterator = log.listIterator();

		while (traceIterator.hasNext()) {

			XTrace trace = traceIterator.next();
			ListIterator<XEvent> eventIterator = trace.listIterator();

			while (eventIterator.hasNext()) {
				int eventIndex = eventIterator.nextIndex();
				XEvent event = eventIterator.next();
				XAttributeMap eventAttr = event.getAttributes();
				repairAttributes(context, factory, eventAttr, dateFormats, guessedDataType, isDefinite);
				trace.set(eventIndex, event);
			}
			if (progBar.isCancelled()) {
				return;
			}
			progBar.inc();
		}

	}

	public void doRepairTraceAttributes(PluginContext context, XLog log, Iterable<? extends DateFormat> dateFormats) {
		doRepairTraceAttributes(context, log, dateFormats, null);
	}

	public void doRepairTraceAttributes(PluginContext context, XLog log, Iterable<? extends DateFormat> dateFormats,
			ReviewCallback reviewCallback) {

		Progress progBar = context.getProgress();
		progBar.setMinimum(0);
		progBar.setMaximum(log.size() * 2); // two pass
		progBar.setValue(0);

		Map<String, Class<? extends XAttribute>> guessedDataType = new HashMap<>();

		// Determine best datatype
		for (XTrace trace : log) {
			buildDataTypeMap(trace.getAttributes(), guessedDataType, dateFormats);
			if (progBar.isCancelled()) {
				return;
			}
			progBar.inc();
		}

		boolean isDefinite = false;

		if (reviewCallback != null) {
			guessedDataType = reviewCallback.reviewDataTypes(guessedDataType);
			isDefinite = true;
		}

		XFactory factory = XFactoryRegistry.instance().currentDefault();

		ListIterator<XTrace> traceIterator = log.listIterator();

		while (traceIterator.hasNext()) {

			XTrace trace = traceIterator.next();
			XAttributeMap traceAttr = trace.getAttributes();
			repairAttributes(context, factory, traceAttr, dateFormats, guessedDataType, isDefinite);

			if (progBar.isCancelled()) {
				return;
			}
			progBar.inc();
		}

	}

	/**
	 * Shows a wizard that allows the user to specify an additional custom date
	 * format.
	 * 
	 * @param context
	 * @return a set of DateFormats including the user specified format
	 */
	public static Iterable<? extends DateFormat> queryDateFormats(UIPluginContext context) {

		try {
			String dateFormat = ProMUIHelper
					.queryForString(
							context,
							""Specify a custom DateFormat pattern (Format as defined in Java SimpleDateFormat) that is used to parse literal attributes that contain dates (LEAVE BLANK OR CANCEL TO USE DEFAULTS)"");
			SimpleDateFormat userDateFormat;
			if (dateFormat != null && !dateFormat.isEmpty()) {
				try {
					userDateFormat = new SimpleDateFormat(dateFormat);
					return Iterables.concat(ImmutableList.of(userDateFormat),
							StandardDateFormats.getStandardDateFormats());
				} catch (IllegalArgumentException e) {
					JOptionPane.showMessageDialog(null, e.getMessage(), ""Wrong Date Format"", JOptionPane.ERROR_MESSAGE);
				}
			}
		} catch (UserCancelledException e) {
		}

		return StandardDateFormats.getStandardDateFormats();
	}

	/**
	 * 
	 * 
	 * @param context
	 * @param attributeDataType
	 * @return
	 */
	public static Map<String, Class<? extends XAttribute>> queryCustomDataTypes(UIPluginContext context,
			Map<String, Class<? extends XAttribute>> attributeDataType) {
		ReviewTable reviewPanel = new ReviewTable(attributeDataType);
		InteractionResult reviewResult = context.showConfiguration(
				""Review/Adjust the automatically determined data types"", reviewPanel.getDatatypeTable());
		if (reviewResult == InteractionResult.FINISHED) {
			return reviewPanel.getDataTypeMap();
		}
		return attributeDataType;
	}

	private static void repairAttributes(PluginContext context, XFactory factory, XAttributeMap attributes,
			Iterable<? extends DateFormat> dateFormats, Map<String, Class<? extends XAttribute>> attributeDataType,
			boolean isDefinite) {
		// Use entrySet here, to avoid a lot of 'put' operations, maybe the underlying map can optimize the replacement operation using 'entry.setValue'
		Iterator<Entry<String, XAttribute>> traceAttr = attributes.entrySet().iterator();
		while (traceAttr.hasNext()) {
			Entry<String, XAttribute> entry = traceAttr.next();

			if (!isExtensionAttribute(entry.getValue())) {
				if (!(entry.getValue() instanceof XAttributeTimestamp)) {
					Class<? extends XAttribute> dataType = attributeDataType.get(entry.getKey());
					if (dataType != null) {
						try {
							XAttribute newAttribute = createAttribute(dataType, entry, factory, dateFormats);
							if (newAttribute != null) {
								entry.setValue(newAttribute);
							} else {
								throw new RuntimeException(String.format(
										""Could convert of attribute %s to %s NULL value returned."", entry.getKey(),
										dataType));
							}
						} catch (UnexpectedDataTypeException e) {
							if (isDefinite) {
								// remove non-matching entries
								traceAttr.remove();
								context.log(""Removing non-matching value "" + entry.getValue().toString());
							} else {
								throw new RuntimeException(String.format(
										""Could convert of attribute %s to data type %s."", entry.getKey(), dataType), e);
							}
						}
					} else {
						throw new RuntimeException(String.format(
								""Could not find datatype of attribute %s. Available data types are %s."",
								entry.getKey(), attributeDataType));
					}
				}
			}
		}
	}

	private static boolean isExtensionAttribute(XAttribute value) {
		return value.getExtension() != null;
	}

	private static void buildDataTypeMap(XAttributeMap attributes,
			Map<String, Class<? extends XAttribute>> attributeDataType, Iterable<? extends DateFormat> dateFormats) {
		for (XAttribute attribute : attributes.values()) {

			if (!(attribute instanceof XAttributeTimestamp)) {

				try {
					String value = getAttrAsString(attribute);
					Class<? extends XAttribute> currentDataType = inferDataType(value, dateFormats);
					Class<? extends XAttribute> lastDataType = attributeDataType.get(attribute.getKey());

					if (lastDataType == null) {
						// First occurrence
						attributeDataType.put(attribute.getKey(), currentDataType);
					} else if (!lastDataType.equals(currentDataType)) {
						// Stored data type does not match new occurrence

						if (checkChangeBothWays(currentDataType, lastDataType, XAttributeBoolean.class,
								XAttributeDiscrete.class)) {
							// Mixed Boolean (e.g. 0,1) & Integer -> XAttributeDiscrete
							if (lastDataType != XAttributeDiscrete.class) {
								attributeDataType.put(attribute.getKey(), XAttributeDiscrete.class);
							}
						} else if (checkChangeBothWays(currentDataType, lastDataType, XAttributeBoolean.class,
								XAttributeContinuous.class)) {
							// Mixed Boolean  (e.g. 0,1) & Float -> XAttributeContinuous
							if (lastDataType != XAttributeContinuous.class) {
								attributeDataType.put(attribute.getKey(), XAttributeContinuous.class);
							}
						} else if (checkChangeBothWays(currentDataType, lastDataType, XAttributeDiscrete.class,
								XAttributeContinuous.class)) {
							// Mixed Integer & Float -> XAttributeContinuous
							if (lastDataType != XAttributeContinuous.class) {
								attributeDataType.put(attribute.getKey(), XAttributeContinuous.class);
							}
						} else {
							// Fallback to Literal
							if (lastDataType != XAttributeLiteral.class) {
								attributeDataType.put(attribute.getKey(), XAttributeLiteral.class);
							}
						}
					}
				} catch (UnexpectedDataTypeException e) {
					// Ignore this attribute
				}

			}

		}
	}

	private static boolean checkChangeBothWays(Class<? extends XAttribute> dataType,
			Class<? extends XAttribute> lastDataType, Class<? extends XAttribute> class1,
			Class<? extends XAttribute> class2) {
		return (class1.equals(lastDataType) && class2.equals(dataType))
				|| (class2.equals(lastDataType) && class1.equals(dataType));
	}

	private static XAttribute createAttribute(Class<? extends XAttribute> dataType, Entry<String, XAttribute> entry,
			XFactory factory, Iterable<? extends DateFormat> dateFormats) throws UnexpectedDataTypeException {
		if (XAttributeDiscrete.class.equals(dataType)) {
			return factory.createAttributeDiscrete(entry.getKey(), getAttrAsLong(entry.getValue()), null);
		} else if (XAttributeContinuous.class.equals(dataType)) {
			return factory.createAttributeContinuous(entry.getKey(), getAttrAsDouble(entry.getValue()), null);
		} else if (XAttributeBoolean.class.equals(dataType)) {
			return factory.createAttributeBoolean(entry.getKey(), getAttrAsBoolean(entry.getValue()), null);
		} else if (XAttributeLiteral.class.equals(dataType)) {
			return factory.createAttributeLiteral(entry.getKey(), getAttrAsString(entry.getValue()), null);
		} else if (XAttributeTimestamp.class.equals(dataType)) {
			return factory.createAttributeTimestamp(entry.getKey(), getAttrAsDate(entry.getValue(), dateFormats), null);
		} else {
			throw new IllegalArgumentException(String.format(""Unexpected Attribute %s: Type %s instead %s"",
					entry.getValue(), entry.getValue().getClass().getSimpleName(), dataType.getSimpleName()));
		}
	}

	private static Date getAttrAsDate(XAttribute value, Iterable<? extends DateFormat> dateFormats)
			throws UnexpectedDataTypeException {
		if (value instanceof XAttributeLiteral) {
			Date date = tryParseDate(((XAttributeLiteral) value).getValue(), dateFormats);
			if (date == null) {
				throw new UnexpectedDataTypeException(""Unexpected date format "" + value);
			}
			return date;
		} else {
			throw new UnexpectedDataTypeException(""Unexpected attribute type "" + value);
		}
	}

	private static Date tryParseDate(String value, Iterable<? extends DateFormat> dateFormats) {
		ParsePosition pos = new ParsePosition(0);
		for (DateFormat formatter : dateFormats) {
			pos.setIndex(0);
			Date date = formatter.parse(value, pos);
			if (date != null && pos.getIndex() == value.length()) {
				return date;
			}
		}
		return null;
	}

	private static String getAttrAsString(XAttribute value) throws UnexpectedDataTypeException {
		if (value instanceof XAttributeDiscrete) {
			return Long.toString(((XAttributeDiscrete) value).getValue());
		} else if (value instanceof XAttributeContinuous) {
			return Double.toString(((XAttributeContinuous) value).getValue());
		} else if (value instanceof XAttributeBoolean) {
			return Boolean.toString(((XAttributeBoolean) value).getValue());
		} else if (value instanceof XAttributeLiteral) {
			return ((XAttributeLiteral) value).getValue();
		} else {
			throw new UnexpectedDataTypeException(""Unexpected attribute type "" + value);
		}
	}

	private static boolean getAttrAsBoolean(XAttribute value) throws UnexpectedDataTypeException {
		if (value instanceof XAttributeBoolean) {
			return ((XAttributeBoolean) value).getValue();
		} else if (value instanceof XAttributeLiteral) {
			String val = ((XAttributeLiteral) value).getValue();
			if (""0"".equals(val) || ""N"".equalsIgnoreCase(val)) {
				return false;
			} else if (""1"".equals(val) || ""J"".equalsIgnoreCase(val) || ""Y"".equalsIgnoreCase(val)) {
				return true;
			} else {
				return Boolean.valueOf(val);
			}
		} else if (value instanceof XAttributeDiscrete) {
			long val = ((XAttributeDiscrete) value).getValue();
			if (val != 0 && val != 1) {
				throw new UnexpectedDataTypeException(""Unexpected value "" + val);
			}
			return Boolean.valueOf(val == 0 ? false : true);
		} else {
			throw new UnexpectedDataTypeException(""Unexpected attribute type "" + value);
		}
	}

	private static double getAttrAsDouble(XAttribute value) throws UnexpectedDataTypeException {
		try {
			if (value instanceof XAttributeDiscrete) {
				return ((XAttributeDiscrete) value).getValue();
			} else if (value instanceof XAttributeContinuous) {
				return ((XAttributeContinuous) value).getValue();
			} else if (value instanceof XAttributeLiteral) {
				return Double.valueOf(((XAttributeLiteral) value).getValue());
			} else {
				throw new UnexpectedDataTypeException(""Unexpected attribute type "" + value);
			}
		} catch (NumberFormatException e) {
			throw new UnexpectedDataTypeException(e);
		}
	}

	private static long getAttrAsLong(XAttribute value) throws UnexpectedDataTypeException {
		try {
			if (value instanceof XAttributeDiscrete) {
				return ((XAttributeDiscrete) value).getValue();
			} else if (value instanceof XAttributeLiteral) {
				return Long.valueOf(((XAttributeLiteral) value).getValue());
			} else {
				throw new UnexpectedDataTypeException(""Unexpected attribute type "" + value);
			}
		} catch (NumberFormatException e) {
			throw new UnexpectedDataTypeException(e);
		}
	}

	private static Pattern DISCRETE_PATTERN = Pattern.compile(""(-)?[0-9]{1,19}"");
	private static Pattern CONTINUOUS_PATTERN = Pattern
			.compile(""((-)?[0-9]*\\.[0-9]+)|((-)?[0-9]+(\\.[0-9]+)?(e|E)\\+[0-9]+)"");
	private static Pattern BOOLEAN_PATTERN = Pattern.compile(""(true)|(false)|(TRUE)|(FALSE)|(0)|(1)|(Y)|(N)|(J)"");

	private static Class<? extends XAttribute> inferDataType(String value, Iterable<? extends DateFormat> dateFormats) {
		if (BOOLEAN_PATTERN.matcher(value).matches()) {
			return XAttributeBoolean.class;
		} else if (DISCRETE_PATTERN.matcher(value).matches()) {
			try {
				Long.parseLong(value);
				return XAttributeDiscrete.class;
			} catch (NumberFormatException e) {
				return XAttributeLiteral.class;
			}
		} else if (CONTINUOUS_PATTERN.matcher(value).matches()) {
			return XAttributeContinuous.class;
		} else if (tryParseDate(value, dateFormats) != null) {
			return XAttributeTimestamp.class;
		} else {
			return XAttributeLiteral.class;
		}
	}

}
"
RepairGlobalAttributesPlugin.java,log,"package org.processmining.log.repair;

import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.ListIterator;
import java.util.Set;

import org.deckfour.xes.classification.XEventAttributeClassifier;
import org.deckfour.xes.classification.XEventClassifier;
import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.extension.std.XCostExtension;
import org.deckfour.xes.extension.std.XLifecycleExtension;
import org.deckfour.xes.extension.std.XOrganizationalExtension;
import org.deckfour.xes.extension.std.XTimeExtension;
import org.deckfour.xes.model.XAttribute;
import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.deckfour.xes.util.XAttributeUtils;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginCategory;
import org.processmining.framework.plugin.annotations.PluginLevel;
import org.processmining.framework.util.ui.widgets.helper.ProMUIHelper;
import org.processmining.framework.util.ui.widgets.helper.UserCancelledException;

import com.google.common.base.Function;
import com.google.common.base.Predicate;
import com.google.common.collect.Collections2;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Iterables;

public final class RepairGlobalAttributesPlugin {

	private static final Function<XAttribute, XAttribute> PROTOTYPE_TRANSFORMER = new Function<XAttribute, XAttribute>() {

		public XAttribute apply(XAttribute firstAttr) {
			return XAttributeUtils.derivePrototype(firstAttr);
		}
	};

	public interface GlobalInfo {
		
		Collection<XAttribute> getEventAttributes();

		Collection<XAttribute> getTraceAttributes();
		
	}

	@Plugin(name = ""Repair Log: Globals, Classifiers, Extensions (In Place)"", level = PluginLevel.Regular, parameterLabels = { ""Event Log"" },//
			returnLabels = {}, returnTypes = {}, userAccessible = true, mostSignificantResult = -1, categories = { PluginCategory.Enhancement }, //
	help = ""Repairs the Event Log by detecting which attributes are global, updating the information about global attributes, adding possible classifiers, and adding correct extensions to certain attributes (time:timestamp, etc). This plug-ins changes the input event log to be able to deal with large event logs!"")
	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""F. Mannhardt"", email = ""f.mannhardt@tue.nl"")
	public void repairLogInPlace(PluginContext context, XLog log) {

		context.getProgress().setMinimum(0);
		context.getProgress().setMaximum(log.size());
		doRepairLog(log);
	}

	@Plugin(name = ""Repair Log: Globals, Classifiers, Extensions"", level = PluginLevel.PeerReviewed, parameterLabels = { ""Event Log"" }, //
			returnLabels = { ""Repaired Log with Globals"" }, returnTypes = { XLog.class }, userAccessible = true, mostSignificantResult = 1, categories = { PluginCategory.Enhancement }, //
	help = ""Repairs the Event Log by detecting which attributes are global, updating the information about global attributes, adding possible classifiers, and adding correct extensions to certain attributes (time:timestamp, etc)."")
	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""F. Mannhardt"", email = ""f.mannhardt@tue.nl"")
	public XLog repairLog(PluginContext context, XLog log) {

		context.getProgress().setMinimum(0);
		context.getProgress().setMaximum(log.size());

		XLog newLog = (XLog) log.clone();

		doRepairLog(newLog);

		return newLog;
	}

	@Plugin(name = ""Repair Log: Globals, Classifiers, Extensions (In Place)"", level = PluginLevel.Regular, parameterLabels = { ""Event Log"" }, returnLabels = {}, returnTypes = {}, userAccessible = true, mostSignificantResult = -1, categories = { PluginCategory.Enhancement }, //
	help = ""Repairs the Event Log by detecting which attributes are global, updating the information about global attributes, adding possible classifiers, and adding correct extensions to certain attributes (time:timestamp, etc). This plug-ins changes the input event log to be able to deal with large event logs!"")
	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""F. Mannhardt"", email = ""f.mannhardt@tue.nl"")
	public void repairLogInPlaceUI(UIPluginContext context, XLog log) {

		context.getProgress().setMinimum(0);
		context.getProgress().setMaximum(log.size());

		try {
			doRepairLogUI(context, log);
		} catch (UserCancelledException e) {
			context.getFutureResult(0).cancel(false);
		}
	}

	@Plugin(name = ""Repair Log: Globals, Classifiers, Extensions"", level = PluginLevel.PeerReviewed, parameterLabels = { ""Event Log"" }, returnLabels = { ""Repaired Log with Globals"" }, returnTypes = { XLog.class }, userAccessible = true, mostSignificantResult = 1, categories = { PluginCategory.Enhancement }, //
	help = ""Repairs the Event Log by detecting which attributes are global, updating the information about global attributes, adding possible classifiers, and adding correct extensions to certain attributes (time:timestamp, etc)."")
	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""F. Mannhardt"", email = ""f.mannhardt@tue.nl"")
	public XLog repairLogUI(UIPluginContext context, XLog log) {

		context.getProgress().setMinimum(0);
		context.getProgress().setMaximum(log.size());

		XLog newLog = (XLog) log.clone();

		try {
			doRepairLogUI(context, newLog);
		} catch (UserCancelledException e) {
			context.getFutureResult(0).cancel(false);
		}

		return newLog;
	}

	public void doRepairLogUI(UIPluginContext context, XLog log) throws UserCancelledException {

		GlobalInfo globals = detectGlobals(log);

		final Set<String> classifierAttribute = ImmutableSet
				.copyOf(ProMUIHelper.queryForObjects(context,
						""Which of the following global attributes should be added as classifier?"",
						Iterables.transform(globals.getEventAttributes(), new Function<XAttribute, String>() {

							public String apply(XAttribute a) {
								return a.getKey();
							}
						})));

		doRepairLog(log, globals, new Predicate<XAttribute>() {

			public boolean apply(XAttribute a) {
				return classifierAttribute.contains(a.getKey());
			}
		});
	}

	public static void doRepairLog(XLog log) {
		doRepairLog(log, detectGlobals(log), new Predicate<XAttribute>() {

			public boolean apply(XAttribute a) {
				return isClassifierAttribute(a);
			}
		});
	}

	public static void doRepairLog(XLog log, GlobalInfo info, Predicate<XAttribute> useForClassifier) {
		for (XAttribute attr : info.getEventAttributes()) {
			if (useForClassifier.apply(attr)) {
				if (!hasClassifier(attr, log.getClassifiers())) {
					log.getClassifiers().add(new XEventAttributeClassifier(attr.getKey(), attr.getKey()));
				}
			}
			switch (attr.getKey()) {
				case XConceptExtension.KEY_NAME :
				case XConceptExtension.KEY_INSTANCE :
					if (!log.getExtensions().contains(XConceptExtension.instance())) {
						log.getExtensions().add(XConceptExtension.instance());
					}
					break;
				case XTimeExtension.KEY_TIMESTAMP :
					if (!log.getExtensions().contains(XTimeExtension.instance())) {
						log.getExtensions().add(XTimeExtension.instance());
					}
					break;
				case XLifecycleExtension.KEY_MODEL :
				case XLifecycleExtension.KEY_TRANSITION :
					if (!log.getExtensions().contains(XLifecycleExtension.instance())) {
						log.getExtensions().add(XLifecycleExtension.instance());
					}
					break;
				case XOrganizationalExtension.KEY_GROUP :
				case XOrganizationalExtension.KEY_RESOURCE :
				case XOrganizationalExtension.KEY_ROLE :
					if (!log.getExtensions().contains(XOrganizationalExtension.instance())) {
						log.getExtensions().add(XOrganizationalExtension.instance());
					}
					break;
				case XCostExtension.KEY_AMOUNT :
				case XCostExtension.KEY_CURRENCY :
				case XCostExtension.KEY_DRIVER :
				case XCostExtension.KEY_TOTAL :
				case XCostExtension.KEY_TYPE :
					if (!log.getExtensions().contains(XCostExtension.instance())) {
						log.getExtensions().add(XCostExtension.instance());
					}
					break;
			}
			if (!hasGlobalAttribute(attr, log.getGlobalEventAttributes())) {
				log.getGlobalEventAttributes().add(attr);
			}
		}

		for (XAttribute attr : info.getTraceAttributes()) {
			if (!hasGlobalAttribute(attr, log.getGlobalTraceAttributes())) {
				log.getGlobalTraceAttributes().add(attr);
			}
		}
	}

	private static boolean hasGlobalAttribute(XAttribute attribute, List<XAttribute> globalAttributes) {
		for (XAttribute globalAttribute : globalAttributes) {
			if (globalAttribute.getKey().equals(attribute.getKey())) {
				return true;
			}
		}
		return false;
	}

	private static boolean hasClassifier(XAttribute attrribute, List<XEventClassifier> classifierList) {
		for (XEventClassifier classifier : classifierList) {
			for (String key : classifier.getDefiningAttributeKeys()) {
				if (key.equals(attrribute.getKey())) {
					return true;
				}
			}
		}
		return false;
	}

	private static boolean isClassifierAttribute(XAttribute attribute) {
		switch (attribute.getKey()) {
			case XConceptExtension.KEY_INSTANCE :
			case XTimeExtension.KEY_TIMESTAMP :
			case XLifecycleExtension.KEY_MODEL :
			case XLifecycleExtension.KEY_TRANSITION :
			case XCostExtension.KEY_AMOUNT :
			case XCostExtension.KEY_CURRENCY :
			case XCostExtension.KEY_DRIVER :
			case XCostExtension.KEY_TOTAL :
			case XCostExtension.KEY_TYPE :
				return false;
		}
		return true;
	}

	public static GlobalInfo detectGlobals(XLog log) {

		Set<XAttribute> eventAttributes = new HashSet<>();
		Set<XAttribute> traceAttributes = new HashSet<>();

		for (ListIterator<XTrace> logIter = log.listIterator(); logIter.hasNext();) {
			int traceIndex = logIter.nextIndex();
			XTrace trace = logIter.next();
			if (traceIndex == 0) {
				traceAttributes.addAll(trace.getAttributes().values());
			} else {
				Iterator<XAttribute> it = traceAttributes.iterator();
				while (it.hasNext()) {
					if (!trace.getAttributes().containsKey(it.next().getKey())) {
						it.remove();
					}
				}
			}
			for (ListIterator<XEvent> eventIter = trace.listIterator(); eventIter.hasNext();) {
				int eventIndex = eventIter.nextIndex();
				XEvent event = eventIter.next();
				if (traceIndex == 0 && eventIndex == 0) {
					eventAttributes.addAll(event.getAttributes().values());
				} else {
					Iterator<XAttribute> it = eventAttributes.iterator();
					while (it.hasNext()) {
						if (!event.getAttributes().containsKey(it.next().getKey())) {
							it.remove();
						}
					}
				}
			}
		}

		final Collection<XAttribute> defaultEventAttributes = Collections2.transform(eventAttributes,
				PROTOTYPE_TRANSFORMER);
		final Collection<XAttribute> defaultTraceAttributes = Collections2.transform(traceAttributes,
				PROTOTYPE_TRANSFORMER);

		return new GlobalInfo() {

			public Collection<XAttribute> getEventAttributes() {
				return defaultEventAttributes;
			}

			public Collection<XAttribute> getTraceAttributes() {
				return defaultTraceAttributes;
			}

		};
	}

}
"
UnexpectedDataTypeException.java,log,"package org.processmining.log.repair;

public final class UnexpectedDataTypeException extends Exception {

	private static final long serialVersionUID = 1L;

	public UnexpectedDataTypeException() {
	}

	public UnexpectedDataTypeException(String message) {
		super(message);
	}

	public UnexpectedDataTypeException(Throwable cause) {
		super(cause);
	}

	public UnexpectedDataTypeException(String message, Throwable cause) {
		super(message, cause);
	}

}
"
ResourceType.java,log,"package org.processmining.models;

import org.deckfour.xes.model.XLog;
import org.processmining.contexts.uitopia.model.ProMResourceTypeInformation;

public class ResourceType {
	static {
		ProMResourceTypeInformation.getInstance().setInfoFor(XLog.class, ""Event Log"",
				""Eindhoven University of Technology"", ""h.m.w.verbeek@tue.nl"", ""Eric Verbeek"",
				""http://www.processmining.org"", ""resourcetype_log_30x35.png"");

	}
}
"
MergeLogsUtils.java,log,"package org.processmining.log.utils;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;

import org.processmining.log.parameters.MergeLogsParameters;

public class MergeLogsUtils {
	
	public static Date getDate(MergeLogsParameters parameters, String date) {
		SimpleDateFormat dateFormat = new SimpleDateFormat(parameters.getDateFormat());
		dateFormat.setLenient(false);
		try {
			return dateFormat.parse(date.trim());
		} catch (ParseException pe) {
			return null;
		}
		
	}

}
"
TraceVariant.java,log,"package org.processmining.log.utils;

import java.util.List;

/**
 * Trace variant which should override {@link #equals(Object)} and
 * {@link #hashCode()} to provide an equivalence relation for traces. A standard
 * implementation based on the classification of events is provided in
 * {@link TraceVariantByClassifier}.
 * 
 * @author F. Mannhardt
 *
 * @param <E>
 *            what constitutes an event
 */
public interface TraceVariant<E> {

	/**
	 * @return the list of events as viewed by this variant
	 */
	List<E> getEvents();

}"
TraceVariantByClassifier.java,log,"package org.processmining.log.utils;

import java.util.Iterator;

import org.deckfour.xes.classification.XEventClass;
import org.deckfour.xes.classification.XEventClasses;
import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XTrace;

import com.google.common.base.Function;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.Lists;
import com.google.common.primitives.Ints;

public final class TraceVariantByClassifier implements TraceVariant<XEventClass> {

	private final XTrace trace;
	private final XEventClasses eventClasses;

	public TraceVariantByClassifier(XTrace trace, XEventClasses eventClasses) {
		this.trace = trace;
		this.eventClasses = eventClasses;
	}

	public ImmutableList<XEventClass> getEvents() {
		return ImmutableList.copyOf(Lists.transform(trace, new Function<XEvent, XEventClass>() {

			public XEventClass apply(XEvent e) {
				return eventClasses.getClassOf(e);
			}
		}));
	}

	public int hashCode() {
		int hashCode = 1;
		for (XEvent e : trace) {
			XEventClass eventClass = eventClasses.getClassOf(e);
			hashCode = 31 * hashCode + (e == null ? 0 : Ints.hashCode(eventClass.getIndex()));
		}
		return hashCode;
	}

	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (getClass() != obj.getClass())
			return false;
		TraceVariantByClassifier other = (TraceVariantByClassifier) obj;
		if (trace == null) {
			if (other.trace != null)
				return false;
		} else if (!isEqualVariant(trace, other.trace))
			return false;
		return true;
	}

	private boolean isEqualVariant(XTrace t1, XTrace t2) {
		if (t1 == t2) {
			return true;
		}

		Iterator<XEvent> it1 = t1.iterator();
		Iterator<XEvent> it2 = t2.iterator();

		while (it1.hasNext() && it2.hasNext()) {
			XEventClass cl1 = eventClasses.getClassOf(it1.next());
			XEventClass cl2 = eventClasses.getClassOf(it2.next());
			if (cl1.getIndex() != cl2.getIndex()) {
				return false;
			}
		}
		return !(it1.hasNext() || it2.hasNext());
	}

}"
XLogBuilder.java,log,"/*
 * Copyright (c) 2014 F. Mannhardt (f.mannhardt@tue.nl)
 * 
 * LICENSE:
 * 
 * This code is free software; you can redistribute it and/or modify it under
 * the terms of the GNU Lesser General Public License as published by the Free
 * Software Foundation; either version 3 of the License, or (at your option) any
 * later version.
 * 
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
 * details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA
 */
package org.processmining.log.utils;

import java.util.Date;

import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.factory.XFactory;
import org.deckfour.xes.factory.XFactoryRegistry;
import org.deckfour.xes.model.XAttribute;
import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;

/**
 * Fluent-style builder for create a XLog in an easy way. Get an instance by
 * calling {@link XLogBuilder#newInstance()}, then it can be used as follows: 

 * <pre>
 * {@code
 *  XLog log = XLogBuilder.newInstance()
 *	 	.startLog(""logName"")
 *		.addTrace(""traceName"", 2)
 *		.addAttribute(""traceAttribute"", ""test"")
 *			.addEvent(""Event1"")
 *			.addAttribute(""eventAttribute"", 21)
 *			.addEvent(""Event2"")
 *			.addEvent(""Event3"")
 *			.addEvent(""Event4"", 2)
 *		.build();
 * }
 * </pre>
 * Please note that a {@link XLogBuilder} instance is design to be used to 
 * create one log only. 
 * 
 * @author F. Mannhardt
 * 
 */
public class XLogBuilder {

	public static XLogBuilder newInstance() {
		return new XLogBuilder();
	}

	private XFactory factory = XFactoryRegistry.instance().currentDefault();
	private final XConceptExtension conceptInstance = XConceptExtension.instance();

	private XLog log = null;

	private XTrace currentTrace = null;
	private int currentTraceMultiplicity = 1;

	private XEvent currentEvent = null;
	private int currentEventMultiplicity;

	public XLogBuilder startLog(String name) {
		log = factory.createLog();
		if (log != null) {
			conceptInstance.assignName(log, name);
		}
		return this;
	}

	public XLogBuilder addTrace(String name) {
		return addTrace(name, 1);
	}

	public XLogBuilder addTrace(String name, int numberOfTraces) {
		if (log == null) {
			throw new IllegalStateException(""Please call 'startLog' first!"");
		}
		if (currentEvent != null) {
			addCurrentEventToTrace();
		}
		if (currentTrace != null) {
			addCurrentTraceToLog();
			currentEvent = null;
		}
		currentTrace = factory.createTrace();
		if (name != null) {
			conceptInstance.assignName(currentTrace, name);
		}
		currentTraceMultiplicity = numberOfTraces;
		return this;
	}

	private void addCurrentTraceToLog() {
		log.add(currentTrace);
		if (currentTraceMultiplicity > 1) {
			for (int i = 0; i < currentTraceMultiplicity - 1; i++) {
				XTrace clone = (XTrace) currentTrace.clone();
				String name = conceptInstance.extractName(clone);
				if (name != null) {
					conceptInstance.assignName(clone, name.concat(""-"").concat(String.valueOf(i+1)));
				}
				log.add(clone);
			}
		}
	}

	public XLogBuilder addEvent(String name) {
		addEvent(name, 1);
		return this;
	}

	public XLogBuilder addEvent(String name, int numberOfEvents) {
		if (currentTrace == null) {
			throw new IllegalStateException(""Please call 'addTrace' first!"");
		}
		if (currentEvent != null) {
			addCurrentEventToTrace();
		}
		currentEvent = factory.createEvent();
		conceptInstance.assignName(currentEvent, name);
		currentEventMultiplicity = numberOfEvents;
		return this;
	}

	private void addCurrentEventToTrace() {
		currentTrace.add(currentEvent);
		if (currentEventMultiplicity > 1) {
			for (int i = 0; i < currentEventMultiplicity - 1; i++) {
				currentTrace.add((XEvent) currentEvent.clone());
			}
		}
	}
	
	/**
	 * Add the given attribute
	 * 
	 * @param attribute
	 * @return {@link XLogBuilder}
	 */
	public XLogBuilder addAttribute(XAttribute attribute) {
		addAttributeInternal(attribute.getKey(), attribute);
		return this;
	}
	
	/**
	 * @param name
	 * @param value
	 * @return
	 */
	public XLogBuilder addAttribute(String name, boolean value) {
		XAttribute attribute = factory.createAttributeBoolean(name, value, null);
		addAttributeInternal(name, attribute);
		return this;
	}

	/**
	 * @param name
	 * @param value
	 * @return the {@link XLogBuilder} itself
	 */
	public XLogBuilder addAttribute(String name, long value) {
		XAttribute attribute = factory.createAttributeDiscrete(name, value, null);
		addAttributeInternal(name, attribute);
		return this;
	}

	/**
	 * @param name
	 * @param value
	 * @return the {@link XLogBuilder} itself
	 */
	public XLogBuilder addAttribute(String name, String value) {
		XAttribute attribute = factory.createAttributeLiteral(name, value, null);
		addAttributeInternal(name, attribute);
		return this;
	}

	/**
	 * @param name
	 * @param value
	 * @return the {@link XLogBuilder} itself
	 */
	public XLogBuilder addAttribute(String name, Date value) {
		XAttribute attribute = factory.createAttributeTimestamp(name, value, null);
		addAttributeInternal(name, attribute);
		return this;
	}

	/**
	 * @param name
	 * @param value
	 * @return the {@link XLogBuilder} itself
	 */
	public XLogBuilder addAttribute(String name, double value) {
		XAttribute attribute = factory.createAttributeContinuous(name, value, null);
		addAttributeInternal(name, attribute);
		return this;
	}
	
	public XLogBuilder setFactory(XFactory factory) {
		this.factory = factory;
		return this;
	}

	private void addAttributeInternal(String name, XAttribute attribute) {
		if (currentEvent == null && currentTrace == null) {
			throw new IllegalStateException(""Please call 'addEvent' or 'addTrace' first!"");
		}

		if (currentEvent == null) {
			// Trace Attributes			
			currentTrace.getAttributes().put(name, attribute);
		} else {
			// Event Attributes
			currentEvent.getAttributes().put(name, attribute);
		}
	}

	/**
	 * Builds and returns the XLog. This is only to be used once! 
	 * 
	 * @return the final XLog
	 */ 
	public XLog build() {
		if (currentEvent != null) {
			addCurrentEventToTrace();
		}
		if (currentTrace != null) {
			addCurrentTraceToLog();
		}
		return log;
	}

}
"
XUtils.java,log,"/*
 * Copyright (c) 2014 F. Mannhardt (f.mannhardt@tue.nl)
 * 
 * LICENSE:
 * 
 * This code is free software; you can redistribute it and/or modify it under
 * the terms of the GNU Lesser General Public License as published by the Free
 * Software Foundation; either version 3 of the License, or (at your option) any
 * later version.
 * 
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
 * details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA
 */
package org.processmining.log.utils;

import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.UnsupportedEncodingException;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.NavigableSet;
import java.util.Set;
import java.util.TreeSet;

import org.deckfour.xes.classification.XEventAndClassifier;
import org.deckfour.xes.classification.XEventClass;
import org.deckfour.xes.classification.XEventClasses;
import org.deckfour.xes.classification.XEventClassifier;
import org.deckfour.xes.classification.XEventLifeTransClassifier;
import org.deckfour.xes.classification.XEventNameClassifier;
import org.deckfour.xes.extension.XExtension;
import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.extension.std.XCostExtension;
import org.deckfour.xes.extension.std.XLifecycleExtension;
import org.deckfour.xes.extension.std.XOrganizationalExtension;
import org.deckfour.xes.extension.std.XTimeExtension;
import org.deckfour.xes.factory.XFactory;
import org.deckfour.xes.factory.XFactoryRegistry;
import org.deckfour.xes.id.XID;
import org.deckfour.xes.in.XesXmlParser;
import org.deckfour.xes.info.XLogInfo;
import org.deckfour.xes.info.impl.XLogInfoImpl;
import org.deckfour.xes.model.XAttributable;
import org.deckfour.xes.model.XAttribute;
import org.deckfour.xes.model.XAttributeBoolean;
import org.deckfour.xes.model.XAttributeContainer;
import org.deckfour.xes.model.XAttributeContinuous;
import org.deckfour.xes.model.XAttributeDiscrete;
import org.deckfour.xes.model.XAttributeID;
import org.deckfour.xes.model.XAttributeList;
import org.deckfour.xes.model.XAttributeLiteral;
import org.deckfour.xes.model.XAttributeMap;
import org.deckfour.xes.model.XAttributeTimestamp;
import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.deckfour.xes.out.XSerializer;
import org.deckfour.xes.out.XesXmlGZIPSerializer;
import org.deckfour.xes.out.XesXmlSerializer;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.plugins.utils.ProvidedObjectHelper;

import com.google.common.base.Function;
import com.google.common.collect.ImmutableListMultimap;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Iterables;
import com.google.common.collect.ListMultimap;
import com.google.common.collect.Multimaps;
import com.google.common.collect.SetMultimap;

/**
 * Commonly used methods for handling XES logs
 * 
 * @author F. Mannhardt
 *
 */
public final class XUtils {

	private XUtils() {
		//only for static methods
	}

	/**
	 * The invisible activity. Activity to be used for mapping silent
	 * transitions on.
	 */
	public final static XEventClass INVISIBLEACTIVITY = new XEventClass(""[invisible]"", 0);

	/**
	 * The move-on-model activity. Activity to be used for mapping transition on
	 * that are not covered by the log at hand. As such, they will always have
	 * to be a move-on-model.
	 */
	public final static XEventClass MOVEONMODELACTIVITY = new XEventClass(""[move on model]"", 0);

	public static final XEventClassifier STANDARDCLASSIFIER = new XEventAndClassifier(new XEventNameClassifier(),
			new XEventLifeTransClassifier());

	/**
	 * Returns whether the attribute key matches one of the registered standard
	 * extensions of XES.
	 * 
	 * @param attribute
	 * @return whether the attribute is one of the standard extension attributes
	 */
	public static boolean isStandardExtensionAttribute(XAttribute attribute) {
		// Lets hope that the JIT is clever enough to transform this to a hash table
		switch (attribute.getKey()) {
			case XConceptExtension.KEY_NAME :
			case XConceptExtension.KEY_INSTANCE :
			case XTimeExtension.KEY_TIMESTAMP :
			case XLifecycleExtension.KEY_MODEL :
			case XLifecycleExtension.KEY_TRANSITION :
			case XOrganizationalExtension.KEY_GROUP :
			case XOrganizationalExtension.KEY_RESOURCE :
			case XOrganizationalExtension.KEY_ROLE :
			case XCostExtension.KEY_AMOUNT :
			case XCostExtension.KEY_CURRENCY :
			case XCostExtension.KEY_DRIVER :
			case XCostExtension.KEY_TOTAL :
			case XCostExtension.KEY_TYPE :
				return true;
		}
		return false;
	}

	/**
	 * Added by Eric Verbeek
	 * 
	 * Returns a default classifier to use with an event log. If the log
	 * contains classifiers, then the first classifier is returned. Otherwise,
	 * the standard MXML classifier is constructed and returned.
	 * 
	 * @param log
	 * @return A default classifier to use with the provided log.
	 */
	public static XEventClassifier getDefaultClassifier(XLog log) {
		if (log.getClassifiers().isEmpty()) {
			return STANDARDCLASSIFIER;
		}
		return log.getClassifiers().get(0);
	}

	/**
	 * Returns both the event classifiers defined by the XLog, as well as the
	 * three standard classifiers {@link XLogInfoImpl#NAME_CLASSIFIER},
	 * {@link XLogInfoImpl#RESOURCE_CLASSIFIER} and
	 * {@link XLogInfoImpl#STANDARD_CLASSIFIER}.
	 * 
	 * @param log
	 * @return a list of event classifiers that can be used on the log
	 */
	public static List<XEventClassifier> getStandardAndLogDefinedEventClassifiers(XLog log) {
		List<XEventClassifier> classList = new ArrayList<>(log.getClassifiers());
		if (!classList.contains(XLogInfoImpl.RESOURCE_CLASSIFIER)) {
			classList.add(XLogInfoImpl.RESOURCE_CLASSIFIER);
		}
		if (!classList.contains(XLogInfoImpl.STANDARD_CLASSIFIER)) {
			classList.add(XLogInfoImpl.STANDARD_CLASSIFIER);
		}
		if (!classList.contains(XLogInfoImpl.NAME_CLASSIFIER)) {
			classList.add(0, XLogInfoImpl.NAME_CLASSIFIER);
		}
		return classList;
	}

	/**
	 * Returns the event name.
	 * 
	 * @param element
	 * @return the value of the ""concept:name"" attribute or ""null""
	 */
	public static String getConceptName(XAttributable element) {
		return XConceptExtension.instance().extractName(element);
	}

	public static void assignConceptName(XLog log, String name) {
		XConceptExtension.instance().assignName(log, name);
	}

	public static void assignConceptName(XEvent event, String name) {
		XConceptExtension.instance().assignName(event, name);
	}

	public static void assignConceptName(XTrace trace, String name) {
		XConceptExtension.instance().assignName(trace, name);
	}

	/**
	 * Returns the event time.
	 * 
	 * @param event
	 * @return the value of the ""time:timestamp"" attribute or ""null""
	 */
	public static Date getTimestamp(XEvent event) {
		return XTimeExtension.instance().extractTimestamp(event);
	}

	public static void assignTimestamp(XEvent event, Date timestamp) {
		XTimeExtension.instance().assignTimestamp(event, timestamp);
	}

	public static void assignTimestamp(XEvent event, long timestamp) {
		XTimeExtension.instance().assignTimestamp(event, timestamp);
	}

	public static XLog loadLog(String string) throws UnsupportedEncodingException, Exception {
		return loadLog(new ByteArrayInputStream(string.getBytes(StandardCharsets.UTF_8)));
	}

	public static XLog loadLog(File file) throws FileNotFoundException, Exception {
		return loadLog(new FileInputStream(file));
	}

	public static XLog loadLog(InputStream is) throws Exception {
		XesXmlParser xmlParser = new XesXmlParser();
		return Iterables.getFirst(xmlParser.parse(is), null);
	}

	public static void saveLog(XLog log, File file) throws FileNotFoundException, IOException {
		saveLogPlain(log, file);
	}

	public static void saveLogPlain(XLog log, File file) throws FileNotFoundException, IOException {
		saveLogWithSerializer(log, file, new XesXmlSerializer());
	}

	public static void saveLogGzip(XLog log, File file) throws FileNotFoundException, IOException {
		saveLogWithSerializer(log, file, new XesXmlGZIPSerializer());
	}

	public static void saveLogWithSerializer(XLog log, File file, XSerializer logSerializer)
			throws FileNotFoundException, IOException {
		try (FileOutputStream out = new FileOutputStream(file)) {
			logSerializer.serialize(log, out);
		}
	}

	public static boolean containsEventWithName(String eventName, XTrace trace) {
		for (XEvent xEvent : trace) {
			if (eventName.equals(getConceptName(xEvent))) {
				return true;
			}
		}
		return false;
	}

	public static XEvent getLatestEventWithName(String eventName, XTrace trace) {
		XEvent latestEvent = null;
		for (XEvent xEvent : trace) {
			if (eventName.equals(getConceptName(xEvent))) {
				latestEvent = xEvent;
			}
		}
		return latestEvent;
	}

	public static NavigableSet<String> getAllEventNamesSorted(XLog log) {
		NavigableSet<String> eventNames = new TreeSet<>();
		for (XTrace trace : log) {
			for (XEvent event : trace) {
				eventNames.add(getConceptName(event));
			}
		}
		return eventNames;
	}

	public static String stringifyEvent(XEvent e, XEventClassifier classifier) {
		return classifier.getClassIdentity(e);
	}

	public static String stringifyEvent(XEvent e) {
		return stringifyEvent(e, new XEventNameClassifier());
	}

	public static String stringifyTrace(XTrace t, XEventClassifier classifier) {
		StringBuilder sBuilder = new StringBuilder(""["");
		Iterator<XEvent> iterator = t.iterator();
		while (iterator.hasNext()) {
			sBuilder.append(stringifyEvent(iterator.next(), classifier));
			if (iterator.hasNext()) {
				sBuilder.append("","");
			}
		}
		sBuilder.append(""]"");
		return sBuilder.toString();
	}

	public static String stringifyTrace(XTrace t) {
		return stringifyTrace(t, new XEventNameClassifier());
	}

	public static String stringifyLog(XLog l, XEventClassifier classifier) {
		StringBuilder sBuilder = new StringBuilder(""["");
		Iterator<XTrace> iterator = l.iterator();
		while (iterator.hasNext()) {
			sBuilder.append(stringifyTrace(iterator.next(), classifier));
			if (iterator.hasNext()) {
				sBuilder.append("",\n"");
			}
		}
		sBuilder.append(""]"");
		return sBuilder.toString();
	}

	public static String stringifyLog(XLog l) {
		return stringifyLog(l, new XEventNameClassifier());
	}

	public static String stringifyAttributes(XAttributeMap map) {
		StringBuilder sBuilder = new StringBuilder(""{"");
		Iterator<XAttribute> iterator = map.values().iterator();
		while (iterator.hasNext()) {
			XAttribute a = iterator.next();
			sBuilder.append(a.getKey() + "" -> "" + a.toString());
			if (iterator.hasNext()) {
				sBuilder.append("",\n"");
			}
		}
		sBuilder.append(""}"");
		return sBuilder.toString();
	}

	/**
	 * Creates a deep clone of the {@link XAttribute} with the same value, but a
	 * changed key.
	 * 
	 * @param oldAttribute
	 * @param newKey
	 * @return copy of the supplied attribute
	 */
	public static XAttribute cloneAttributeWithChangedKey(XAttribute oldAttribute, String newKey) {
		return cloneAttributeWithChangedKeyWithFactory(oldAttribute, newKey,
				XFactoryRegistry.instance().currentDefault());
	}

	/**
	 * Creates a deep clone of the {@link XAttribute} with the same value, but a
	 * changed key.
	 * 
	 * @param oldAttribute
	 * @param newKey
	 * @param factory
	 * @return copy of the supplied attribute
	 */
	public static XAttribute cloneAttributeWithChangedKeyWithFactory(XAttribute oldAttribute, String newKey,
			XFactory factory) {
		if (oldAttribute instanceof XAttributeList) {
			XAttributeList newAttribute = factory.createAttributeList(newKey, oldAttribute.getExtension());
			for (XAttribute a : ((XAttributeList) oldAttribute).getCollection()) {
				newAttribute.addToCollection(a);
			}
			return newAttribute;
		} else if (oldAttribute instanceof XAttributeContainer) {
			XAttributeContainer newAttribute = factory.createAttributeContainer(newKey, oldAttribute.getExtension());
			for (XAttribute a : ((XAttributeContainer) oldAttribute).getCollection()) {
				newAttribute.addToCollection(a);
			}
			return newAttribute;
		} else if (oldAttribute instanceof XAttributeLiteral) {
			return factory.createAttributeLiteral(newKey, ((XAttributeLiteral) oldAttribute).getValue(),
					oldAttribute.getExtension());
		} else if (oldAttribute instanceof XAttributeBoolean) {
			return factory.createAttributeBoolean(newKey, ((XAttributeBoolean) oldAttribute).getValue(),
					oldAttribute.getExtension());
		} else if (oldAttribute instanceof XAttributeContinuous) {
			return factory.createAttributeContinuous(newKey, ((XAttributeContinuous) oldAttribute).getValue(),
					oldAttribute.getExtension());
		} else if (oldAttribute instanceof XAttributeDiscrete) {
			return factory.createAttributeDiscrete(newKey, ((XAttributeDiscrete) oldAttribute).getValue(),
					oldAttribute.getExtension());
		} else if (oldAttribute instanceof XAttributeTimestamp) {
			return factory.createAttributeTimestamp(newKey, ((XAttributeTimestamp) oldAttribute).getValue(),
					oldAttribute.getExtension());
		} else if (oldAttribute instanceof XAttributeID) {
			return factory.createAttributeID(newKey, ((XAttributeID) oldAttribute).getValue(),
					oldAttribute.getExtension());
		} else {
			throw new IllegalArgumentException(""Unexpected attribute type!"");
		}
	}

	/**
	 * Creates a deep clone of the supplied event log without classifiers
	 * 
	 * @param log
	 * @return a clone of the supplied log
	 */
	public static XLog cloneLogWithoutClassifier(XLog log) {
		XLog clone = (XLog) log.clone();
		clone.getClassifiers().clear();
		return clone;
	}

	/**
	 * Creates a deep clone of the supplied event log without globals
	 * 
	 * @param log
	 * @return a clone of the supplied log
	 */
	public static XLog cloneLogWithoutGlobals(XLog log) {
		XLog clone = (XLog) log.clone();
		clone.getGlobalTraceAttributes().clear();
		clone.getGlobalEventAttributes().clear();
		return clone;
	}

	/**
	 * Creates a deep clone of the supplied event log without globals and
	 * without classifiers
	 * 
	 * @param log
	 * @return a clone of the supplied log
	 */
	public static XLog cloneLogWithoutGlobalsAndClassifiers(XLog log) {
		XLog clone = (XLog) log.clone();
		clone.getClassifiers().clear();
		clone.getGlobalTraceAttributes().clear();
		clone.getGlobalEventAttributes().clear();
		return clone;
	}

	/**
	 * Creates a new log with attributes and meta data (classifiers, globals,
	 * extension) from the oldLog.
	 * 
	 * @param oldLog
	 * @return
	 */
	public static XLog createLogFrom(XLog oldLog) {
		return createLogFrom(oldLog, XFactoryRegistry.instance().currentDefault());
	}

	/**
	 * Creates a new log with attributes and meta data (classifiers, globals,
	 * extension) from the oldLog.
	 * 
	 * @param oldLog
	 * @param factory
	 * @return
	 */
	public static XLog createLogFrom(XLog oldLog, XFactory factory) {
		XLog newLog = factory.createLog((XAttributeMap) oldLog.getAttributes().clone());
		newLog.getClassifiers().addAll(oldLog.getClassifiers());
		newLog.getExtensions().addAll(oldLog.getExtensions());
		for (XAttribute attr : oldLog.getGlobalEventAttributes()) {
			newLog.getGlobalEventAttributes().add((XAttribute) attr.clone());
		}
		for (XAttribute attr : oldLog.getGlobalTraceAttributes()) {
			newLog.getGlobalTraceAttributes().add((XAttribute) attr.clone());
		}
		return newLog;
	}

	/**
	 * Copies the meta data (classifiers, globals, extension) from the oldLog to
	 * the newLog.
	 * 
	 * @param oldLog
	 * @param newLog
	 */
	public static void copyLogMetadata(XLog oldLog, XLog newLog) {
		newLog.getClassifiers().addAll(oldLog.getClassifiers());
		newLog.getExtensions().addAll(oldLog.getExtensions());
		for (XAttribute attr : oldLog.getGlobalEventAttributes()) {
			newLog.getGlobalEventAttributes().add((XAttribute) attr.clone());
		}
		for (XAttribute attr : oldLog.getGlobalTraceAttributes()) {
			newLog.getGlobalTraceAttributes().add((XAttribute) attr.clone());
		}
	}

	/**
	 * Checks whether both objects implement the same XAttribute interface
	 * 
	 * @param obj1
	 * @param obj2
	 * @return
	 */
	public static boolean isSameType(XAttribute obj1, XAttribute obj2) {
		if (obj1 instanceof XAttributeList && obj2 instanceof XAttributeList) {
			return true;
		}
		if (obj1 instanceof XAttributeContainer && obj2 instanceof XAttributeContainer) {
			return true;
		}
		if (obj1 instanceof XAttributeLiteral && obj2 instanceof XAttributeLiteral) {
			return true;
		}
		if (obj1 instanceof XAttributeBoolean && obj2 instanceof XAttributeBoolean) {
			return true;
		}
		if (obj1 instanceof XAttributeContinuous && obj2 instanceof XAttributeContinuous) {
			return true;
		}
		if (obj1 instanceof XAttributeDiscrete && obj2 instanceof XAttributeDiscrete) {
			return true;
		}
		if (obj1 instanceof XAttributeTimestamp && obj2 instanceof XAttributeTimestamp) {
			return true;
		}		
		if (obj1 instanceof XAttributeID && obj2 instanceof XAttributeID) {
			return true;
		}	
		return false;
	}

	/**
	 * Returns the value of the {@link XAttribute} as {@link Object}
	 * 
	 * @param attribute
	 * @return value of the attribute
	 */
	public static Object getAttributeValue(XAttribute attribute) {
		if (attribute instanceof XAttributeList) {
			return ((XAttributeList) attribute).getCollection();
		} else if (attribute instanceof XAttributeContainer) {
			return ((XAttributeContainer) attribute).getCollection();
		} else if (attribute instanceof XAttributeLiteral) {
			return ((XAttributeLiteral) attribute).getValue();
		} else if (attribute instanceof XAttributeBoolean) {
			return ((XAttributeBoolean) attribute).getValue();
		} else if (attribute instanceof XAttributeContinuous) {
			return ((XAttributeContinuous) attribute).getValue();
		} else if (attribute instanceof XAttributeDiscrete) {
			return ((XAttributeDiscrete) attribute).getValue();
		} else if (attribute instanceof XAttributeTimestamp) {
			return ((XAttributeTimestamp) attribute).getValue();
		} else if (attribute instanceof XAttributeID) {
			return ((XAttributeID) attribute).getValue();
		} else {
			throw new IllegalArgumentException(""Unexpected attribute type!"");
		}
	}

	/**
	 * Returns the Java class of the {@link XAttribute} value.
	 * 
	 * @param attribute
	 * @return class of the attribute
	 */
	public static Class<?> getAttributeClass(XAttribute attribute) {
		if (attribute instanceof XAttributeLiteral) {
			return String.class;
		} else if (attribute instanceof XAttributeBoolean) {
			return Boolean.class;
		} else if (attribute instanceof XAttributeContinuous) {
			return Double.class;
		} else if (attribute instanceof XAttributeDiscrete) {
			return Long.class;
		} else if (attribute instanceof XAttributeTimestamp) {
			return Date.class;
		} else if (attribute instanceof XAttributeID) {
			return XID.class;
		} else {
			throw new IllegalArgumentException(""Unexpected attribute type!"");
		}
	}

	/**
	 * Creates an appropriate {@link XAttribute}, decided on the type of the
	 * parameter atttributeValue.
	 * 
	 * @param attributeName
	 * @param attributeValue
	 * @return
	 */
	public static XAttribute createAttribute(String attributeName, Object attributeValue) {
		return createAttributeWithFactory(attributeName, attributeValue, XFactoryRegistry.instance().currentDefault());
	}

	/**
	 * Creates an appropriate {@link XAttribute}, decided on the type of the
	 * parameter atttributeValue.
	 * 
	 * @param attributeName
	 * @param attributeValue
	 * @param factory
	 * @return
	 */
	public static XAttribute createAttributeWithFactory(String attributeName, Object attributeValue, XFactory factory) {
		return createAttributeWithFactory(attributeName, attributeValue, null, factory);
	}

	/**
	 * Creates an appropriate {@link XAttribute}, deciding by the type of the
	 * parameter atttributeValue.
	 * 
	 * @param attributeName
	 * @param attributeValue
	 * @param extension
	 * @return a {@link XAttribute} with correct type
	 */
	public static XAttribute createAttribute(String attributeName, Object attributeValue, XExtension extension) {
		return createAttributeWithFactory(attributeName, attributeValue, extension,
				XFactoryRegistry.instance().currentDefault());
	}

	/**
	 * Creates an appropriate {@link XAttribute}, deciding by the type of the
	 * parameter atttributeValue.
	 * 
	 * @param attributeName
	 * @param attributeValue
	 * @param extension
	 * @param factory
	 * @return a {@link XAttribute} with correct type
	 */
	private static XAttribute createAttributeWithFactory(String attributeName, Object attributeValue,
			XExtension extension, XFactory factory) {
		if (attributeValue instanceof Double || attributeValue instanceof Float) {
			return factory.createAttributeContinuous(attributeName, ((Number) attributeValue).doubleValue(), extension);
		} else if (attributeValue instanceof Integer || attributeValue instanceof Long) {
			return factory.createAttributeDiscrete(attributeName, ((Number) attributeValue).longValue(), extension);
		} else if (attributeValue instanceof Date) {
			return factory.createAttributeTimestamp(attributeName, ((Date) attributeValue), extension);
		} else if (attributeValue instanceof Boolean) {
			return factory.createAttributeBoolean(attributeName, ((Boolean) attributeValue), extension);
		} else {
			return factory.createAttributeLiteral(attributeName, attributeValue.toString(), extension);
		}
	}

	/**
	 * Adds multiple {@link XAttribute} to the supplied {@link XAttributable}.
	 * 
	 * @param attributable
	 * @param attributes
	 */
	public static void putAttributes(XAttributable attributable, Iterable<XAttribute> attributes) {
		for (XAttribute a : attributes) {
			putAttribute(attributable, a);
		}
	}

	/**
	 * Adds a single {@link XAttribute} to the supplied {@link XAttributable}.
	 * 
	 * @param attributable
	 * @param attribute
	 */
	public static void putAttribute(XAttributable attributable, XAttribute attribute) {
		attributable.getAttributes().put(attribute.getKey(), attribute);
	}

	/**
	 * Rename the XLog with the label for the ProM provided object
	 * 
	 * @param context
	 * @param log
	 * @return the old name
	 */
	public static String renameLogWithProMLabel(PluginContext context, XLog log) {
		String originalName = getConceptName(log);
		String promLabel = ProvidedObjectHelper.getProvidedObjectLabel(context, log);
		/*
		 * HV: Check whether promLabel equals null. This can happen if the log
		 * at hand is not a provided object.
		 */
		if (promLabel != null && !promLabel.equals(originalName)) {
			XConceptExtension.instance().assignName(log, promLabel);
		}
		return originalName;
	}

	/**
	 * Obtain the event classes from the supplied collection of traces using the
	 * specified classifier. Uses the {@link XEvent} cached in the
	 * {@link XLogInfo} if available and in case the trace are, in fact, a
	 * {@link XLog}.
	 * 
	 * @param classifier
	 * @param traces
	 * @return
	 */
	public static XEventClasses createEventClasses(XEventClassifier classifier, Iterable<XTrace> traces) {
		if (traces instanceof XLog) {
			XLog log = (XLog) traces;
			XLogInfo existingLogInfo = log.getInfo(classifier);
			if (existingLogInfo != null) {
				return existingLogInfo.getEventClasses();
			}
		}
		return deriveEventClasses(classifier, traces);
	}

	private static XEventClasses deriveEventClasses(XEventClassifier classifier, Iterable<XTrace> traces) {
		XEventClasses classes = new XEventClasses(classifier);
		for (XTrace trace : traces) {
			classes.register(trace);
		}
		classes.harmonizeIndices();
		return classes;
	}

	public static Set<String> getEventAttributeKeys(Iterable<XTrace> traces) {
		Set<String> attributeKeys = new HashSet<>();
		for (XTrace t : traces) {
			for (XEvent e : t) {
				attributeKeys.addAll(e.getAttributes().keySet());
			}
		}
		return attributeKeys;
	}

	public static Map<String, Class<?>> getEventAttributeTypes(Iterable<XTrace> traces) {
		Map<String, Class<?>> attributeTypes = new HashMap<String, Class<?>>();
		for (XTrace t : traces) {
			for (XEvent e : t) {
				for (XAttribute a : e.getAttributes().values()) {
					fillAttributeType(attributeTypes, a);
				}
			}
		}
		return attributeTypes;
	}

	public static Set<String> getTraceAttributeKeys(Iterable<XTrace> traces) {
		Set<String> attributeKeys = new HashSet<>();
		for (XTrace t : traces) {
			attributeKeys.addAll(t.getAttributes().keySet());
		}
		return attributeKeys;
	}

	public static Map<String, Class<?>> getTraceAttributeTypes(Iterable<XTrace> traces) {
		Map<String, Class<?>> attributeTypes = new HashMap<String, Class<?>>();
		for (XTrace t : traces) {
			for (XAttribute a : t.getAttributes().values()) {
				fillAttributeType(attributeTypes, a);
			}
		}
		return attributeTypes;
	}

	private static void fillAttributeType(Map<String, Class<?>> attributeTypes, XAttribute attribute) {
		if (!attributeTypes.containsKey(attribute.getKey())) {
			attributeTypes.put(attribute.getKey(), getAttributeClass(attribute));
		}
	}

	/**
	 * Groups traces in a {@link ListMultimap} by their event classification. A
	 * {@link ListMultimap} instead of an {@link SetMultimap} is returned as the
	 * input traces are not required to be a {@link Set}.
	 * 
	 * @param traces
	 * @param classifier
	 * @return
	 */
	public static ImmutableListMultimap<TraceVariantByClassifier, XTrace> getVariantsByClassifier(
			Iterable<XTrace> traces, XEventClassifier classifier) {
		final XEventClasses eventClasses = XUtils.createEventClasses(new XEventNameClassifier(), traces);
		return getVariantsByClassifier(traces, eventClasses);
	}

	public static int countVariantsByClassifier(Iterable<XTrace> traces, XEventClassifier classifier) {
		final XEventClasses eventClasses = XUtils.createEventClasses(new XEventNameClassifier(), traces);
		return countVariantsByClassifier(traces, eventClasses);
	}

	/**
	 * Groups traces in a {@link ListMultimap} by their event classification. A
	 * {@link ListMultimap} instead of an {@link SetMultimap} is returned as the
	 * input traces are not required to be a {@link Set}.
	 * 
	 * @param traces
	 * @param eventClasses
	 * @return
	 */
	public static ImmutableListMultimap<TraceVariantByClassifier, XTrace> getVariantsByClassifier(
			Iterable<XTrace> traces, final XEventClasses eventClasses) {
		return getVariants(traces, new Function<XTrace, TraceVariantByClassifier>() {

			public TraceVariantByClassifier apply(XTrace trace) {
				return new TraceVariantByClassifier(trace, eventClasses);
			}

		});
	}

	public static int countVariantsByClassifier(Iterable<XTrace> traces, final XEventClasses eventClasses) {
		return countVariants(traces, new Function<XTrace, TraceVariantByClassifier>() {

			public TraceVariantByClassifier apply(XTrace trace) {
				return new TraceVariantByClassifier(trace, eventClasses);
			}

		});
	}

	/**
	 * Groups traces in a {@link ListMultimap} by a generic {@link Function}. A
	 * {@link ListMultimap} instead of an {@link SetMultimap} is returned as the
	 * input traces are not required to be a {@link Set}.
	 * 
	 * @param traces
	 * @param variantFunction
	 * @return
	 */
	public static <T extends TraceVariant<E>, E> ImmutableListMultimap<T, XTrace> getVariants(Iterable<XTrace> traces,
			Function<XTrace, T> variantFunction) {
		return Multimaps.index(traces, variantFunction);
	}

	public static <T extends TraceVariant<?>> int countVariants(Iterable<XTrace> traces,
			Function<XTrace, T> variantFunction) {
		return ImmutableSet.copyOf(Iterables.transform(traces, variantFunction)).size();
	}

}"
IdentitiesMissingException.java,log,"package org.processmining.log.xes.extensions.id;

import java.util.Collection;

import org.deckfour.xes.model.XAttributable;

public class IdentitiesMissingException extends Exception {

	/**
	 * 
	 */
	private static final long serialVersionUID = 8593596865075088429L;
	
	private Collection<XAttributable> missing;

	public IdentitiesMissingException() {
		super(""Not all elements in the log have an identifier"");
	}
	
	public IdentitiesMissingException(Collection<XAttributable> missing) {
		this();
		
		this.missing = missing;
	}
	
}
"
IdentityConnection.java,log,"package org.processmining.log.xes.extensions.id;

import java.util.HashMap;
import java.util.Map;

import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.id.XID;
import org.deckfour.xes.model.XAttributable;
import org.deckfour.xes.model.XLog;
import org.processmining.framework.connections.impl.AbstractConnection;


/**
 * This class provides a mapping for the identity of XAttributeable elements. 
 * Given an ID, it returns the corresponding XAttributeable element.
 * 
 * TODO 
 * 
 * @author jvdwerf
 *
 */
public class IdentityConnection extends AbstractConnection {

	private final Map<String,XAttributable> idmapping;
	
	private final String LOG = ""LOG"";
	
	public IdentityConnection(XLog log) throws IdentitiesMissingException {
		super(""Identity connection for "" + 
				(XConceptExtension.instance().extractName(log) == null ? log.toString() : XConceptExtension.instance().extractName(log))				
		);
		
		IdentityMappingVisitor visitor = new IdentityMappingVisitor();
		log.accept(visitor);
		if (!visitor.allLogElementsHaveIdentifier()) {
			throw new IdentitiesMissingException(visitor.getElementsWithoutIdentity());
		}
		this.idmapping = visitor.getMapping();
		
		put(LOG, log);
	}
	
	
	
	public IdentityConnection(XLog log, Map<String,XAttributable> idmapping) {
		super(""Identity connection for "" + 
				(XConceptExtension.instance().extractName(log) == null ? log.toString() : XConceptExtension.instance().extractName(log))				
		);
		
		this.idmapping = new HashMap<String, XAttributable>(idmapping);
		
		put(LOG, log);
	}
	
	public XAttributable getElement(String id) {
		return idmapping.get(id);
	}
	
	public XAttributable getElement(XID id) {
		return getElement(id.toString());
	}
	
	public XLog getLog() {
		return (XLog) this.get(LOG);
	}
	
}
"
IdentityMappingVisitor.java,log,"package org.processmining.log.xes.extensions.id;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.deckfour.xes.extension.std.XIdentityExtension;
import org.deckfour.xes.id.XID;
import org.deckfour.xes.model.XAttributable;
import org.deckfour.xes.model.XAttribute;
import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.deckfour.xes.model.XVisitor;

/**
 * This visitor creates a mapping for the identities.
 * @author jvdwerf
 *
 */
class IdentityMappingVisitor extends XVisitor {

	private Map<String, XAttributable> idmap;
	private List<XAttributable> missing;
	
	//these are just standard
	public boolean precondition() { 
		return true; 
	}
	
	public void init(XLog log) {
		idmap = new HashMap<String, XAttributable>();
		missing = new ArrayList<XAttributable>();
	}
	
	public Map<String, XAttributable> getMapping() {
		return idmap;
	}
	
	public Collection<XAttributable> getElementsWithoutIdentity() {
		return missing;
	}
	
	public boolean allLogElementsHaveIdentifier() {
		return (missing.size() == 0);
	}
	
	@Override
	public void visitLogPre(XLog log) {
		visitXAttributable(log);
	}
	
	@Override
	public void visitTracePre(XTrace trace, XLog log) {
		visitXAttributable(trace);
	}
	
	@Override
	public void visitEventPre(XEvent event, XTrace trace) {
		visitXAttributable(event);
	}
	
	@Override
	public void visitAttributePre(XAttribute attr, XAttributable parent) {
		if (attr.getKey().equals(XIdentityExtension.KEY_ID)) {
			return;
		}
		
		visitXAttributable(attr);
	}
	
	private void visitXAttributable(XAttributable target) {
		XID id = XIdentityExtension.instance().extractID(target);
		if (id != null) {
			idmap.put(id.toString(), target);
		} else {
			missing.add(target);
		}
	}
}"
XPathExecutor.java,log,"package org.processmining.log.xpath.engine.ui;

import java.io.IOException;

import javax.swing.JComponent;

import org.deckfour.xes.model.XLog;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.contexts.uitopia.annotations.Visualizer;
import org.processmining.framework.connections.ConnectionCannotBeObtained;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.log.xes.extensions.id.IdentitiesMissingException;

/**
 * 
 * ""Vizualises"" a log so that XPath queries can be executed.
 * 
 * @author jvdwerf
 *
 */

public class XPathExecutor {

	@Visualizer(name = ""XPath executor"")
	@Plugin(name = ""XPath executor"", parameterLabels = ""XLog Event Log"", returnTypes = JComponent.class, returnLabels = ""XPath executor"", userAccessible = false)
	public JComponent showXPathExecutor(UIPluginContext context, XLog source) {

		try {
			return new XPathExecutorPanel(context, source);
		} catch (IdentitiesMissingException e) {
			try {
				XLog log = context.tryToFindOrConstructFirstNamedObject(XLog.class, ""Add identity attribute"", null,
						null, source);
				return new XPathExecutorPanel(context, log);
			} catch (ConnectionCannotBeObtained e1) {
			} catch (IdentitiesMissingException e1) {
				e1.printStackTrace();
			} catch (IOException e1) {
				e1.printStackTrace();
			}
		} catch (IOException e) {
			e.printStackTrace();
		}

		context.getFutureResult(0).cancel(true);
		return null;
	}
}
"
XPathExecutorPanel.java,log,"package org.processmining.log.xpath.engine.ui;

import java.awt.BorderLayout;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.InputMethodEvent;
import java.awt.event.InputMethodListener;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.List;
import java.util.Stack;
import java.util.logging.Level;
import java.util.logging.Logger;

import javax.swing.JButton;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.event.TableModelListener;
import javax.swing.table.DefaultTableCellRenderer;
import javax.swing.table.TableModel;

import org.deckfour.xes.extension.std.XIdentityExtension;
import org.deckfour.xes.model.XAttributable;
import org.deckfour.xes.model.XAttribute;
import org.deckfour.xes.model.XAttributeMap;
import org.deckfour.xes.model.XLog;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.util.Pair;
import org.processmining.framework.util.ui.widgets.ProMHeaderPanel;
import org.processmining.framework.util.ui.widgets.ProMSplitPane;
import org.processmining.framework.util.ui.widgets.ProMTable;
import org.processmining.framework.util.ui.widgets.ProMTextArea;
import org.processmining.framework.util.ui.widgets.ProMTextField;
import org.processmining.log.xes.extensions.id.IdentitiesMissingException;
import org.processmining.log.xpath.engine.XPathEngine;

import com.fluxicon.slickerbox.factory.SlickerFactory;

import net.sf.saxon.s9api.SaxonApiException;

public class XPathExecutorPanel extends JPanel {

	/**
	 * 
	 */
	private static final long serialVersionUID = 8961837431111952562L;

	private final XLog _log;
	private final PluginContext _context;

	private XPathEngine _engine;

	private ProMSplitPane splitter;
	private ProMTextArea errorText;
	private JPanel topPanel;
	private JPanel queryPanel;
	private ProMTextField queryText;
	private ProMTextField relQueryText;
	private JPanel buttonPanel;
	private JButton queryButton;
	private JButton clearButton;
	private JLabel resultCounter;

	private JPanel queryHistory;
	private JButton prevQuery;
	private JButton nextQuery;

	private ProMTable table;

	private Stack<Pair<String, String>> queryPast = new Stack<Pair<String, String>>();
	private Stack<Pair<String, String>> queryFuture = new Stack<Pair<String, String>>();

	private JPanel bottomPanel;
	private ProMSplitPane bottomSplitter;
	private JPanel bottomRight;

	private Logger logging;

	public XPathExecutorPanel(final PluginContext context, final XLog log)
			throws IdentitiesMissingException, IOException {
		_log = log;
		_context = context;

		_engine = new XPathEngine(_context, _log);

		logging = Logger.getLogger(""XPathExecutor"");
		logging.setLevel(Level.FINEST);

		initializeUI();
	}

	public XLog getLog() {
		return _log;
	}

	public PluginContext getContext() {
		return _context;
	}

	protected XPathEngine getEngine() {
		return _engine;
	}

	private void initializeUI() {
		this.setLayout(new BorderLayout());

		setTopPanel();
		setBottomPanel();
		setSplitter();
	}

	private void setTopPanel() {
		topPanel = new JPanel(new BorderLayout());

		setQueryPanel();
		topPanel.add(queryPanel, BorderLayout.CENTER);

		buttonPanel = new JPanel();
		queryButton = SlickerFactory.instance().createButton(""Query"");
		queryButton.addActionListener(new ActionListener() {

			public void actionPerformed(ActionEvent e) {
				executeQuery(queryText.getText(), relQueryText.getText());
			}
		});

		clearButton = SlickerFactory.instance().createButton(""Clear"");
		clearButton.addActionListener(new ActionListener() {

			public void actionPerformed(ActionEvent e) {
				executeClear();
			}
		});

		resultCounter = SlickerFactory.instance().createLabel("""");

		buttonPanel.add(queryButton);
		buttonPanel.add(clearButton);
		buttonPanel.add(resultCounter);
		topPanel.add(buttonPanel, BorderLayout.SOUTH);
	}

	private void setBottomPanel() {

		bottomPanel = new JPanel(new BorderLayout());

		bottomRight = new JPanel(new BorderLayout());
		errorText = new ProMTextArea(false);

		bottomSplitter = new ProMSplitPane(ProMSplitPane.HORIZONTAL_SPLIT);
		bottomSplitter.setLeftComponent(errorText);
		bottomSplitter.setRightComponent(bottomRight);

		bottomPanel.add(bottomSplitter);
	}

	private void setSplitter() {

		splitter = new ProMSplitPane(ProMSplitPane.VERTICAL_SPLIT);
		splitter.setTopComponent(topPanel);
		splitter.setBottomComponent(bottomPanel);
		add(splitter, BorderLayout.CENTER);
	}

	private void setQueryPanel() {
		queryPanel = new JPanel(new BorderLayout());

		JPanel qr = new JPanel(new BorderLayout());

		queryText = new ProMTextField();
		queryText.setText(""//trace"");
		relQueryText = new ProMTextField();

		InputMethodListener l = new InputMethodListener() {

			public void inputMethodTextChanged(InputMethodEvent event) {
				if (event.getCommittedCharacterCount() > 0) {
					resetQueryFuture();
				}
			}

			public void caretPositionChanged(InputMethodEvent event) {
			}
		};

		queryText.addInputMethodListener(l);
		relQueryText.addInputMethodListener(l);

		qr.add(queryText, BorderLayout.NORTH);
		qr.add(relQueryText, BorderLayout.SOUTH);

		queryPanel.add(qr, BorderLayout.CENTER);

		queryHistory = new JPanel(new BorderLayout());

		prevQuery = SlickerFactory.instance().createButton(""<"");
		prevQuery.addActionListener(new ActionListener() {

			public void actionPerformed(ActionEvent e) {
				setPrevQuery();
			}
		});

		nextQuery = SlickerFactory.instance().createButton("">"");
		nextQuery.setEnabled(false);
		nextQuery.addActionListener(new ActionListener() {

			public void actionPerformed(ActionEvent e) {
				setNextQuery();
			}
		});

		queryHistory.add(prevQuery, BorderLayout.NORTH);
		queryHistory.add(nextQuery, BorderLayout.SOUTH);

		queryPanel.add(queryHistory, BorderLayout.EAST);
	}

	private boolean queryChanged = false;

	public boolean isQueryChanged() {
		return queryChanged;
	}

	private void setPrevQuery() {

		if (!queryPast.isEmpty()) {
			queryFuture.push(new Pair<String, String>(queryText.getText(), relQueryText.getText()));

			Pair<String, String> pop = queryPast.pop();
			queryText.setText(pop.getFirst());
			relQueryText.setText(pop.getSecond());
		}

		prevQuery.setEnabled(!(queryPast.isEmpty()));
		nextQuery.setEnabled(true);

		queryChanged = false;
	}

	private void setNextQuery() {
		if (!queryFuture.isEmpty()) {
			queryPast.push(new Pair<String, String>(queryText.getText(), relQueryText.getText()));

			Pair<String, String> pop = queryFuture.pop();
			queryText.setText(pop.getFirst());
			relQueryText.setText(pop.getSecond());
		}

		nextQuery.setEnabled(!(queryFuture.isEmpty()));
		prevQuery.setEnabled(true);

		queryChanged = false;
	}

	private void resetQueryFuture() {
		queryFuture.clear();
		nextQuery.setEnabled(false);
	}

	private void executeClear() {
		queryText.setText("""");
		relQueryText.setText("""");
		errorText.setText("""");
		resultCounter.setText("""");
		bottomSplitter.setLeftComponent(errorText);
		bottomSplitter.setRightComponent(bottomRight);

		repaint();
	}

	private void executeQuery(String query, String relQuery) {
		queryPast.add(new Pair<String, String>(query, relQuery));

		long start = Calendar.getInstance().getTimeInMillis();
		logging.log(Level.INFO, ""start query '"" + query + ""'"");

		//get solution
		SolutionTable solTable = null;

		String error = """";

		if (relQuery.equals("""")) {
			List<XAttributable> solution = null;
			try {
				solution = getEngine().query(query, true);
			} catch (SaxonApiException e) {
				error = e.getMessage();
			}

			if (solution != null) {

				solTable = new SolutionTable(false);
				solTable.setSingleSolution(solution);

			}

		} else {

			List<Pair<XAttributable, XAttributable>> solution = null;
			try {
				solution = getEngine().query(query, relQuery, true);
			} catch (SaxonApiException e) {
				error = e.getMessage();
			}

			if (solution != null) {
				solTable = new SolutionTable(true);
				solTable.setPairSolution(solution);
			}
		}

		long end = Calendar.getInstance().getTimeInMillis();
		logging.log(Level.INFO, ""end query. Duration: '"" + (end - start) + "" ms"");

		if (solTable == null) {

			errorText.setText(error);
			resultCounter.setText(""Errors found"");
			bottomSplitter.setLeftComponent(errorText);
			bottomSplitter.setRightComponent(bottomRight);

		} else {
			//populate result table
			table = new ProMTable(solTable);
			table.getTable().setDefaultRenderer(XAttributable.class, new XAttributableRenderer());

			table.getTable().addMouseListener(new MouseListener() {

				public void mouseReleased(MouseEvent e) {
				}

				public void mousePressed(MouseEvent e) {
				}

				public void mouseExited(MouseEvent e) {
				}

				public void mouseEntered(MouseEvent e) {
				}

				public void mouseClicked(MouseEvent e) {
					int row = table.getTable().rowAtPoint(e.getPoint());
					int col = table.getTable().columnAtPoint(e.getPoint());

					if ((row >= 0 && row <= table.getTable().getRowCount())
							&& (col >= 0 && col <= table.getTable().getColumnCount())) {
						setPropertiesTable(table.getValueAt(row, col));
					}
				}
			});

			bottomSplitter.setLeftComponent(table);
			bottomSplitter.setRightComponent(bottomRight);
			resultCounter.setText(""Solutions found: "" + solTable.getRowCount());
		}

		repaint();
	}

	private void setPropertiesTable(Object value) {
		if (value instanceof XAttributable) {
			XAttributable parent = (XAttributable) value;

			ProMHeaderPanel php;
			if (value instanceof XAttribute) {
				XAttribute attr = (XAttribute) parent;
				php = new ProMHeaderPanel(""Attribute: "" + attr.getKey() + "" (value: "" + attr.toString() + "")"");
			} else {
				php = new ProMHeaderPanel(value.getClass().getSimpleName());
			}

			ProMTable propTable = new ProMTable(new PropertiesTable(parent));
			propTable.getTable().setDefaultRenderer(XAttribute.class, new XAttributeRender());
			php.add(propTable);
			bottomSplitter.setRightComponent(php);
		}
	}

	private class PropertiesTable implements TableModel {

		private XAttributeMap attrMap;
		private List<String> keys;

		public PropertiesTable(XAttributable parent) {

			attrMap = parent.getAttributes();
			keys = new ArrayList<String>(attrMap.keySet());

		}

		public int getRowCount() {
			return keys.size();
		}

		public int getColumnCount() {
			return 2;
		}

		public String getColumnName(int columnIndex) {
			switch (columnIndex) {
				case 0 :
					return ""Attribute"";
				case 1 :
					return ""Value"";
				default :
					return ""ERROR FIELD"";
			}
		}

		public Class<?> getColumnClass(int columnIndex) {
			switch (columnIndex) {
				case 0 :
					return String.class;
				case 1 :
					return XAttribute.class;
				default :
					return null;
			}
		}

		public boolean isCellEditable(int rowIndex, int columnIndex) {
			return false;
		}

		public Object getValueAt(int rowIndex, int columnIndex) {
			switch (columnIndex) {
				case 0 :
					return keys.get(rowIndex);
				case 1 :
					return attrMap.get(keys.get(rowIndex));
			}
			return null;
		}

		public void setValueAt(Object aValue, int rowIndex, int columnIndex) {
		}

		public void addTableModelListener(TableModelListener l) {
		}

		public void removeTableModelListener(TableModelListener l) {
		}

	}

	private class XAttributeRender extends DefaultTableCellRenderer {

		private static final long serialVersionUID = -4820042181333426306L;

		public void setValue(Object value) {
			if (value == null) {
				super.setValue(""Not set"");
			} else {
				if (value instanceof XAttribute) {
					super.setValue(value);
				} else {
					super.setValue(value);
				}
			}
		}

	}

	private class XAttributableRenderer extends DefaultTableCellRenderer {

		private static final long serialVersionUID = -4649231822102709523L;

		public void setValue(Object value) {
			if (value instanceof XAttributable) {
				super.setValue(XIdentityExtension.instance().extractID((XAttributable) value));
			} else {
				super.setValue(value);
			}
		}
	}

	private class SolutionTable implements TableModel {

		private List<Pair<XAttributable, XAttributable>> pairSolution;

		private boolean pairs;

		List<XAttributable> sol;

		public SolutionTable(boolean pairs) {
			this.pairs = pairs;
		}

		public void setPairSolution(List<Pair<XAttributable, XAttributable>> solution) {
			pairSolution = solution;
		}

		public void setSingleSolution(List<XAttributable> solution) {
			sol = solution;
		}

		public int getRowCount() {
			if (pairs)
				return pairSolution.size();
			else
				return sol.size();
		}

		public int getColumnCount() {
			if (pairs) {
				return 2;
			} else {
				return 1;
			}
		}

		public String getColumnName(int columnIndex) {
			switch (columnIndex) {
				case 0 :
					return ""First"";
				case 1 :
					return ""Second"";
				default :
					return ""Wrong"";
			}
		}

		public Class<?> getColumnClass(int columnIndex) {
			return XAttributable.class;
		}

		public boolean isCellEditable(int rowIndex, int columnIndex) {
			return false;
		}

		public Object getValueAt(int rowIndex, int columnIndex) {
			XAttributable attr = null;

			if (pairs) {
				Pair<XAttributable, XAttributable> item = pairSolution.get(rowIndex);

				if (item == null) {
					return null;
				}

				switch (columnIndex) {
					case 0 :
						attr = item.getFirst();
						break;
					case 1 :
						attr = item.getSecond();
						break;
				}

			} else {
				attr = sol.get(rowIndex);
			}
			return attr;

			//if (attr == null)
			//	return null;
			//else
			//	return XIdentityExtension.instance().extractID(attr);
		}

		public void setValueAt(Object aValue, int rowIndex, int columnIndex) {
		}

		public void addTableModelListener(TableModelListener l) {
		}

		public void removeTableModelListener(TableModelListener l) {
		}

	}

}
"
XPathEngine.java,log,"package org.processmining.log.xpath.engine;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.Set;

import org.deckfour.xes.extension.std.XIdentityExtension;
import org.deckfour.xes.model.XAttributable;
import org.deckfour.xes.model.XLog;
import org.processmining.framework.connections.ConnectionCannotBeObtained;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.PluginParameterBinding;
import org.processmining.framework.plugin.events.Logger.MessageLevel;
import org.processmining.framework.util.Pair;
import org.processmining.log.xes.extensions.id.IdentitiesMissingException;
import org.processmining.log.xes.extensions.id.IdentityConnection;
import org.processmining.plugins.log.exporting.ExportLogXes;

import net.sf.saxon.s9api.Axis;
import net.sf.saxon.s9api.DocumentBuilder;
import net.sf.saxon.s9api.Processor;
import net.sf.saxon.s9api.QName;
import net.sf.saxon.s9api.SaxonApiException;
import net.sf.saxon.s9api.WhitespaceStrippingPolicy;
import net.sf.saxon.s9api.XPathCompiler;
import net.sf.saxon.s9api.XPathSelector;
import net.sf.saxon.s9api.XdmItem;
import net.sf.saxon.s9api.XdmNode;
import net.sf.saxon.s9api.XdmSequenceIterator;

public class XPathEngine {

	private XLog log;
	private PluginContext context;
	private IdentityConnection idConnection;
	private XdmNode logXMLDoc;
	private XPathCompiler xpath;
	private File logFile;

	private String logNameSpace = ""http://www.xes-standard.org/"";

	private static QName KEYNAME = new QName(""key"");
	private static QName VALUENAME = new QName(""value"");
	private static QName IDNode = new QName("""", ""http://www.xes-standard.org/"", ""id"");

	public void setLogNameSpace(String namespace) {
		logNameSpace = namespace;

		IDNode = new QName("""", namespace, ""id"");
	}

	public String getLogNameSpace() {
		return logNameSpace;
	}

	public XPathEngine(PluginContext context, XLog log) throws IdentitiesMissingException, IOException {
		this.context = context;
		setLog(log);

		init();
	}

	public XLog getLog() {
		return log;
	}

	private void setLog(XLog log) throws IdentitiesMissingException {
		this.log = log;

		//get the connection
		try {
			Collection<IdentityConnection> cons = context.getConnectionManager()
					.getConnections(IdentityConnection.class, context, log);
			//context.log(""I found: "" + cons.size() + "" connections"", MessageLevel.DEBUG );

			for (IdentityConnection con : cons) {
				idConnection = con;
				break;
			}

		} catch (ConnectionCannotBeObtained e) {
			//context.log(""No connection found :-( We need to create one"", MessageLevel.DEBUG );
			idConnection = new IdentityConnection(log);

			context.addConnection(idConnection);
		}

	}

	private void init() throws IOException {
		//transform the log into a XES XML file

		PluginContext child = context.createChildContext(""export xes"");
		logFile = File.createTempFile(""ProM"", "".xes"");

		context.log(""Created temporary file: "" + logFile.getAbsolutePath(), MessageLevel.DEBUG);

		Set<PluginParameterBinding> plugins = context.getPluginManager().getPluginsAcceptingOrdered(child.getClass(),
				false, log.getClass(), File.class);

		//export log to temporary file
		(new ExportLogXes()).export(null, log, logFile);

		//and load the generated document in the XPath engine
		Processor proc = new Processor(false);
		xpath = proc.newXPathCompiler();
		xpath.declareNamespace("""", getLogNameSpace());

		DocumentBuilder builder = proc.newDocumentBuilder();
		builder.setLineNumbering(true);
		builder.setWhitespaceStrippingPolicy(WhitespaceStrippingPolicy.ALL);

		try {
			logXMLDoc = builder.build(logFile);

		} catch (SaxonApiException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

	}

	public List<Pair<XAttributable, XAttributable>> query(String query, String relQuery) {

		try {
			return query(query, relQuery, false);
		} catch (SaxonApiException e) {
		}

		return null;
	}

	public List<Pair<XAttributable, XAttributable>> query(String query, String relQuery, boolean throwException)
			throws SaxonApiException {
		try {
			return query(logXMLDoc, query, relQuery);
		} catch (SaxonApiException e) {
			if (throwException) {
				throw e;
			}
		}
		return null;
	}

	protected List<Pair<XAttributable, XAttributable>> query(XdmNode startNode, String query, String relQuery)
			throws SaxonApiException {
		List<Pair<XAttributable, XAttributable>> results = new ArrayList<Pair<XAttributable, XAttributable>>();

		XPathSelector selector;

		selector = xpath.compile(query).load();

		selector.setContextItem(startNode);

		int counter = 0;

		for (XdmItem item : selector) {
			XAttributable first = getItem(item);

			//now create a second selector
			XPathSelector relSel = xpath.compile(relQuery).load();
			relSel.setContextItem(item);

			for (XdmItem relItem : relSel) {
				XAttributable second = getItem(relItem);

				results.add(new Pair<XAttributable, XAttributable>(first, second));
				counter++;
			}

		}

		System.out.println(""Counter: "" + counter);

		return results;
	}

	/**
	 * Main function that actually queries the log object.
	 * 
	 * @param query
	 * @return
	 */
	public List<XAttributable> query(String query) {
		try {
			return query(query, false);
		} catch (SaxonApiException e) {
		}
		return null;
	}

	public List<XAttributable> query(String query, boolean throwException) throws SaxonApiException {
		try {
			return query(logXMLDoc, query);
		} catch (SaxonApiException e) {
			if (throwException) {
				throw e;
			}
		}

		return null;
	}

	protected List<XAttributable> query(XdmNode startNode, String query) throws SaxonApiException {
		//execute the query. Look whether the internal things have an ID...
		XPathSelector selector;

		selector = xpath.compile(query).load();

		selector.setContextItem(startNode);

		List<XAttributable> result = new ArrayList<XAttributable>();

		int counter = 0;

		for (XdmItem item : selector) {
			//check whether each element has an id.
			//if you find an id, use it :-)

			XAttributable target = getItem(item);
			counter++;
			if (target != null) {
				result.add(target);
			}
		}
		System.out.println(""Counter <single>: "" + counter);
		System.out.println(""   in result set: "" + result.size());

		return result;
	}

	public void close() {
		//remove the log file
		logFile.delete();
	}

	public void finalize() {
		close();
	}

	private XAttributable getItem(XdmItem item) {
		if (item instanceof XdmNode) {
			return getItem((XdmNode) item);
		}
		return null;
	}

	private XAttributable getItem(XdmNode node) {
		//get the type of this element, if it is an id node,
		//get the key, and if the key equals identity:id
		if (node.getNodeName().getLocalName().equals(""id"")) {
			if (node.getAttributeValue(KEYNAME) != null
					&& node.getAttributeValue(KEYNAME).equals(XIdentityExtension.KEY_ID)) {
				return idConnection.getElement(node.getAttributeValue(VALUENAME));
			}
		} else {
			XdmSequenceIterator iterator = node.axisIterator(Axis.CHILD, IDNode);
			while (iterator.hasNext()) {

				XAttributable item = getItem(iterator.next());
				if (item != null) {
					return item;
				}
			}
		}

		return null;
	}

}
"
XSLTTransformer.java,log,"package org.processmining.log.xsl.transformer;

import javax.xml.transform.Source;

import net.sf.saxon.s9api.Processor;
import net.sf.saxon.s9api.SaxonApiException;
import net.sf.saxon.s9api.XsltCompiler;
import net.sf.saxon.s9api.XsltExecutable;

public class XSLTTransformer {

	
	
	private void executeXSLT(Source xslt) {
		
        try {
        	Processor proc = new Processor(false);
            XsltCompiler comp = proc.newXsltCompiler();
            
        	XsltExecutable exp = comp.compile(xslt);
			
			
			
		} catch (SaxonApiException e) {

			e.printStackTrace();
		}
        
		
	}
	
}
"
LogPartitionerAlgorithm.java,log-skeleton,"package org.processmining.logskeleton.algorithms;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.deckfour.xes.classification.XEventClassifier;
import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.factory.XFactoryRegistry;
import org.deckfour.xes.model.XAttributeList;
import org.deckfour.xes.model.XAttributeMap;
import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.processmining.log.models.EventLogArray;
import org.processmining.log.models.impl.EventLogArrayFactory;

public class LogPartitionerAlgorithm {

	private void partition(EventLogArray logs, Set<String> positiveFilters, Set<String> negativeFilters, XEventClassifier classifier) {
		XLog log = logs.getLog(logs.getSize() - 1);
		XLog filteredLog = XFactoryRegistry.instance().currentDefault()
				.createLog((XAttributeMap) log.getAttributes().clone());
		XLog discardedLog = XFactoryRegistry.instance().currentDefault().createLog(log.getAttributes());
		for (XTrace trace : log) {
			boolean ok = true;
			Set<String> toMatch = new HashSet<String>(positiveFilters);
			for (XEvent event : trace) {
				String activity = classifier.getClassIdentity(event);
				if (negativeFilters.contains(activity)) {
					ok = false;
					;
				}
				toMatch.remove(activity);
			}
			if (ok && toMatch.isEmpty()) {
				filteredLog.add(trace);
			} else {
				discardedLog.add(trace);
			}
		}
		logs.removeLog(logs.getSize() - 1);

		logs.addLog(filteredLog);
		logs.addLog(discardedLog);
	}

	public EventLogArray apply(XLog log, XEventClassifier classifier) {
		String name = XConceptExtension.instance().extractName(log);
		Set<String> activities = new HashSet<String>();
		for (XTrace trace : log) {
			for (XEvent event : trace) {
				activities.add(classifier.getClassIdentity(event));
			}
		}
		List<String> activityList = new ArrayList<String>(activities);
		Collections.sort(activityList);
		String line= """";
		for (String activity : activityList) {
			line = line + activity + "","";
		}
		line = line + ""#"";
		System.out.println(line);
		EventLogArray logs = EventLogArrayFactory.createEventLogArray();
		logs.addLog(log);
		Set<String> positiveFilters = new HashSet<String>();
		while (!log.isEmpty()) {
			Map<Set<String>, Double> scores = new HashMap<Set<String>, Double>();
			double maxScore = 0;
			Set<String> negativeFilters = new HashSet<String>();
			for (XTrace trace : log) {
				Set<String> score = new HashSet<String>();
				for (XEvent event : trace) {
					score.add(classifier.getClassIdentity(event));
				}
				if (!scores.containsKey(score)) {
					scores.put(score, 1.0 / (trace.size() + 1));
				} else {
					scores.put(score, scores.get(score) + (1.0 / (trace.size() + 1)));
				}
				if (scores.get(score) > maxScore) {
					maxScore = scores.get(score);
				}
			}
			List<String> bestScore = null;
			XAttributeList list = XFactoryRegistry.instance().currentDefault().createAttributeList(""activities"", null);
			for (Set<String> score : scores.keySet()) {
				if (bestScore == null && scores.get(score) == maxScore) {
					bestScore = new ArrayList<String>(score);
					Collections.sort(bestScore);
					negativeFilters.addAll(activityList);
					negativeFilters.removeAll(score);
					for (String s : bestScore) {
						list.addToCollection(XFactoryRegistry.instance().currentDefault()
								.createAttributeLiteral(XConceptExtension.KEY_NAME, s, XConceptExtension.instance()));
					}
				}
			}
			partition(logs, positiveFilters, negativeFilters, classifier);
			log = logs.getLog(logs.getSize() - 2);
			XConceptExtension.instance().assignName(log, name + "" @"" + (logs.getSize() - 1) + "" |"" + log.size() + ""| "" + bestScore);
			line= """";
			for (String activity : activityList) {
				if (bestScore.contains(activity)) {
					line = line + ""1,"";
				} else {
					line = line + ""0,"";
				}
			}
			line = line + log.size();
			System.out.println(line);
			log.getAttributes().put(""activities"", list);
			log = logs.getLog(logs.getSize() - 1);
		}
		return logs;
	}

}
"
LogPreprocessorAlgorithm.java,log-skeleton,"package org.processmining.logskeleton.algorithms;

import org.processmining.framework.plugin.PluginContext;
import org.processmining.logskeleton.models.ClassificationProblem;

public class LogPreprocessorAlgorithm {

	public ClassificationProblem preprocess(PluginContext context, ClassificationProblem problem) {
		return problem;
	}
	
	public String toString() {
		return ""None"";
	}
}
"
LogSkeletonBuilderAlgorithm.java,log-skeleton,"package org.processmining.logskeleton.algorithms;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.deckfour.xes.classification.XEventClassifier;
import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.factory.XFactoryRegistry;
import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.processmining.log.models.EventLogArray;
import org.processmining.log.models.impl.EventLogArrayFactory;
import org.processmining.logskeleton.models.LogSkeleton;
import org.processmining.logskeleton.models.LogSkeletonCount;

public class LogSkeletonBuilderAlgorithm {

	public LogSkeleton apply(XLog log, XEventClassifier classifier) {
		LogSkeletonCount countModel = count(log, classifier);
		countModel.print(""Count model"");
		EventLogArray logs = split(log);
		Collection<LogSkeletonCount> counts = createCounts(logs, classifier);
		LogSkeleton constraintModel = new LogSkeleton(countModel);
		addSameCounts(counts, constraintModel);
		createCausalDependencies(log, classifier, countModel, constraintModel);
		String label = XConceptExtension.instance().extractName(log);
		constraintModel.setLabel(label == null ? ""<not specified>"" : label);
		return constraintModel;
	}

	public LogSkeletonCount count(XLog log, XEventClassifier classifier) {
		LogSkeletonCount model = new LogSkeletonCount();
		for (XTrace trace : log) {
			String activity;
			String prevActivity = LogSkeletonCount.STARTEVENT;
			model.inc(prevActivity);
			for (XEvent event : trace) {
				activity = classifier.getClassIdentity(event);
				model.inc(activity);
				model.inc(prevActivity, activity);
				prevActivity = activity;
			}
			activity = LogSkeletonCount.ENDEVENT;
			model.inc(activity);
			model.inc(prevActivity, activity);
		}
		return model;
	}

	private EventLogArray split(XLog log) {
		int N = log.size();
		EventLogArray logs = EventLogArrayFactory.createEventLogArray();
		for (int i = 0; i < N; i++) {
			logs.addLog(i, XFactoryRegistry.instance().currentDefault().createLog());
		}
		int i = 0;
		for (XTrace trace : log) {
			logs.getLog(i).add(trace);
			i++;
			if (i == N) {
				i = 0;
			}
		}
		return logs;
	}

	private Collection<LogSkeletonCount> createCounts(EventLogArray logs, XEventClassifier classifier) {
		Collection<LogSkeletonCount> models = new ArrayList<LogSkeletonCount>();
		for (int i = 0; i < logs.getSize(); i++) {
			XLog log = logs.getLog(i);
			models.add(count(log, classifier));
		}
		return models;
	}

	private void addSameCounts(Collection<LogSkeletonCount> countModels, LogSkeleton constraintModel) {
		Map<List<Integer>, Set<String>> map = new HashMap<List<Integer>, Set<String>>();
		Set<String> activities = new HashSet<String>();
		for (LogSkeletonCount countModel : countModels) {
			activities.addAll(countModel.getActivities());
		}
		for (String activity : activities) {
			List<Integer> count = new ArrayList<Integer>();
			for (LogSkeletonCount countModel : countModels) {
				count.add(countModel.get(activity));
			}
			if (map.containsKey(count)) {
				map.get(count).add(activity);
			} else {
				Set<String> newCount = new HashSet<String>();
				newCount.add(activity);
				map.put(count, newCount);
			}
		}

		boolean changed = true;
		int size = map.keySet().isEmpty() ? 0 : map.keySet().iterator().next().size();
		for (int noiseLevel = 0; noiseLevel < 21; noiseLevel++) {
			Map<List<Integer>, Set<String>> map2 = new HashMap<List<Integer>, Set<String>>();
			for (List<Integer> c : map.keySet()) {
				map2.put(c, new HashSet<String>(map.get(c)));
			}
			while (changed) {
				changed = false;
				for (List<Integer> c1 : map2.keySet()) {
					for (List<Integer> c2 : map2.keySet()) {
						int distance = distance(c1, c2);
						if (!map2.get(c1).equals(map2.get(c2)) && 100 * distance(c1, c2) < noiseLevel * size) {
							map2.get(c1).addAll(map2.get(c2));
							map2.get(c2).addAll(map2.get(c1));
							changed = true;
						}
					}
				}
			}

			for (Set<String> sameCount : map2.values()) {
				constraintModel.addSameCount(noiseLevel, sameCount);
			}
			map = map2;
			changed = true;
		}
	}

	private int distance(List<Integer> c1, List<Integer> c2) {
		int distance = 0;
		int size = Math.min(c1.size(), c2.size());
		for (int i = 0; i < size; i++) {
			distance += Math.abs(c1.get(i) - c2.get(i));
		}
		return distance;
	}

	private void createCausalDependencies(XLog log, XEventClassifier classifier, LogSkeletonCount model, LogSkeleton constraintModel) {
		for (XTrace trace : log) {
			List<String> postset = new ArrayList<String>();
			postset.add(LogSkeletonCount.STARTEVENT);
			for (XEvent event : trace) {
				postset.add(classifier.getClassIdentity(event));
			}
			postset.add(LogSkeletonCount.ENDEVENT);
			Set<String> preset = new HashSet<String>();
			String prevActivity = null;
			while (!postset.isEmpty()) {
				if (prevActivity != null) {
					preset.add(prevActivity);
				}
				String activity = postset.remove(0);
				constraintModel.addPrePost(activity, preset, postset);
				prevActivity = activity;
			}
		}
		constraintModel.cleanPrePost();
	}
}
"
LogSkeletonCheckerAlgorithm.java,log-skeleton,"package org.processmining.logskeleton.algorithms;

import java.util.Set;

import org.deckfour.xes.classification.XEventClassifier;
import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.factory.XFactoryRegistry;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.processmining.logskeleton.models.LogSkeleton;
import org.processmining.logskeleton.models.LogSkeletonCount;

public class LogSkeletonCheckerAlgorithm {

	public XLog apply(LogSkeleton skeleton, XLog log, XEventClassifier classifier, Set<String> messages, boolean[] checks) {
		XLog classifiedLog = XFactoryRegistry.instance().currentDefault().createLog();
		XLog traceLog = XFactoryRegistry.instance().currentDefault().createLog();
		LogSkeletonBuilderAlgorithm algorithm = new LogSkeletonBuilderAlgorithm();
		
		for (XTrace trace : log) {
			traceLog.clear();
			traceLog.add(trace);
			LogSkeletonCount traceModel = algorithm.count(traceLog, classifier);
			traceModel.print(""Trace "" + XConceptExtension.instance().extractName(trace));
			if (skeleton.check(trace, traceModel, messages, checks)) {
				classifiedLog.add(trace);
			}
		}
		return classifiedLog;
	}
}
"
LogSkeletonClassifierAlgorithm.java,log-skeleton,"package org.processmining.logskeleton.algorithms;

import java.util.HashSet;
import java.util.List;
import java.util.Set;

import org.deckfour.xes.classification.XEventClassifier;
import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.factory.XFactory;
import org.deckfour.xes.factory.XFactoryRegistry;
import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.logskeleton.models.ClassificationProblem;
import org.processmining.logskeleton.models.LogSkeleton;
import org.processmining.logskeleton.models.LogSkeletonCount;
import org.processmining.logskeleton.plugins.LogSkeletonBuilderPlugin;
import org.processmining.logskeleton.plugins.LogSkeletonCheckerPlugin;

public class LogSkeletonClassifierAlgorithm {

	public XLog apply(PluginContext context, XLog trainingLog, XLog testLog, XEventClassifier classifier, LogPreprocessorAlgorithm preprocessor) {
		String name = XConceptExtension.instance().extractName(trainingLog);

		ClassificationProblem problem = new ClassificationProblem(trainingLog, testLog);

		/*
		 * Preprocess the logs.
		 */
		problem = preprocessor.preprocess(context, problem);
		XLog filteredTrainingLog = problem.getTrainingLog();
		XLog filteredTestLog = problem.getTestLog();
		

		/*
		 * Build the log skeleton.
		 */
		LogSkeletonBuilderPlugin createPlugin = new LogSkeletonBuilderPlugin();
		LogSkeleton model = createPlugin.run(context, filteredTrainingLog);
		context.getProvidedObjectManager().createProvidedObject(""Model for "" + name, model, LogSkeleton.class, context);

		/*
		 * Use the log skeleton to classify the test traces.
		 */
		System.out.println(""[LogSkeletonClassifierAlgorithm] Classify "" + name + "" ======"");
		XLog classifiedTestLog = classify(context, model, filteredTrainingLog, filteredTestLog, classifier, name);
		context.getProvidedObjectManager().createProvidedObject(""Classified Log "" + name, classifiedTestLog,
				XLog.class, context);

		/*
		 * Return the log containing all assumed positive test traces.
		 */
		return classifiedTestLog;
	}

	private static XLog classify(PluginContext context, LogSkeleton trainingModel, XLog trainingLog, XLog testLog,
			XEventClassifier classifier, String name) {
		LogSkeletonBuilderPlugin createPlugin = new LogSkeletonBuilderPlugin();
		LogSkeletonCheckerPlugin checkPlugin = new LogSkeletonCheckerPlugin();
		Set<String> messages = new HashSet<String>();
		boolean[] checks = new boolean[] { true, true, false };
		XLog classifiedTestLog = checkPlugin.run(context, trainingModel, testLog, messages, checks);
		Set<String> positiveTestTraces = new HashSet<String>();
		int threshold = 0;
		for (XTrace trace : classifiedTestLog) {
			positiveTestTraces.add(XConceptExtension.instance().extractName(trace));
		}
		for (String message : messages) {
			System.out.println(""[LogSkeletonClassifierAlgorithm] "" + message);
		}
		for (int i = 0; i < 3; i++) {
			checks[0] = (i == 0);
			checks[1] = (i == 1);
			checks[2] = (i == 2);
			for (String activity : trainingModel.getActivities()) {
				if (positiveTestTraces.size() <= threshold) {
					continue;
				}
				if (activity == LogSkeletonCount.STARTEVENT || activity == LogSkeletonCount.ENDEVENT) {
					continue;
				}
				if (!trainingModel.getSameCounts(activity).iterator().next().equals(activity)) {
					continue;
				}

				for (int f = 0; f < 2; f++) {
					if (positiveTestTraces.size() <= threshold) {
						continue;
					}
					Set<String> positiveFilters = new HashSet<String>();
					Set<String> negativeFilters = new HashSet<String>();
					if (f == 0) {
						positiveFilters.add(activity);
					} else {
						negativeFilters.add(activity);
					}
										System.out.println(""[LogSkeletonClassifierAlgorithm] Positive = "" + positiveFilters + "", Negative = "" + negativeFilters);
					XLog filteredTrainingLog = filter(trainingLog, classifier, positiveFilters, negativeFilters);
					XLog filteredTestLog = filter(testLog, classifier, positiveFilters, negativeFilters);
					if (filteredTestLog.isEmpty() || filteredTrainingLog.isEmpty() || filteredTrainingLog.size() < 16) {
						continue;
					}
					//					System.out.println(""[PDC2017TestPlugin] Remaining traces 1: "" + filteredTrainingLog.size());
					LogSkeleton filteredTrainingModel = createPlugin.run(context, filteredTrainingLog);
					messages = new HashSet<String>();
					XLog classifiedFilteredTestLog = checkPlugin.run(context, filteredTrainingModel, filteredTestLog,
							messages, checks);
					for (XTrace subTrace : filteredTestLog) {
						//						if (positiveTestTraces.size() <= threshold) {
						//							continue;
						//						}
						if (!classifiedFilteredTestLog.contains(subTrace)) {
							String caseId = XConceptExtension.instance().extractName(subTrace);
							if (positiveTestTraces.remove(caseId)) {
								System.out.println(""[LogSkeletonClassifierAlgoritmm] Case ""
										+ XConceptExtension.instance().extractName(subTrace)
										+ "" excluded by positive filter "" + positiveFilters + "" and negative filter ""
										+ negativeFilters + "", support = "" + filteredTrainingLog.size());
								for (String message : messages) {
									System.out.println(""[LogSkeletonClassifierAlgoritmm] "" + message);
								}
							}
						}
					}
				}
			}
			for (String activity : trainingModel.getActivities()) {
				if (positiveTestTraces.size() <= threshold) {
					continue;
				}
				if (activity == LogSkeletonCount.STARTEVENT || activity == LogSkeletonCount.ENDEVENT) {
					continue;
				}
				if (!trainingModel.getSameCounts(activity).iterator().next().equals(activity)) {
					continue;
				}
				for (String activity2 : trainingModel.getActivities()) {
					if (positiveTestTraces.size() <= threshold) {
						continue;
					}
					if (activity2 == LogSkeletonCount.STARTEVENT || activity2 == LogSkeletonCount.ENDEVENT) {
						continue;
					}
					if (!trainingModel.getSameCounts(activity2).iterator().next().equals(activity2)) {
						continue;
					}
					if (trainingModel.getSameCounts(activity).contains(activity2)) {
						continue;
					}
					for (int f = 0; f < 4; f++) {
						if (positiveTestTraces.size() <= threshold) {
							continue;
						}
						Set<String> positiveFilters = new HashSet<String>();
						Set<String> negativeFilters = new HashSet<String>();
						if (f == 0 || f == 1) {
							positiveFilters.add(activity);
						} else {
							negativeFilters.add(activity);
						}
						if (f == 0 || f == 2) {
							positiveFilters.add(activity2);
						} else {
							negativeFilters.add(activity2);
						}
												System.out.println(""[LogSkeletonClassifierAlgorithm] Positive = "" + positiveFilters + "", Negative = "" + negativeFilters);
						XLog filteredTrainingLog = filter(trainingLog, classifier, positiveFilters, negativeFilters);
						XLog filteredTestLog = filter(testLog, classifier, positiveFilters, negativeFilters);
						if (filteredTestLog.isEmpty() || filteredTrainingLog.isEmpty()
								|| filteredTrainingLog.size() < 16) {
							continue;
						}
						//						System.out.println(""[PDC2017TestPlugin] Remaining traces 2: "" + filteredTrainingLog.size());
						LogSkeleton filteredTrainingModel = createPlugin.run(context, filteredTrainingLog);
						messages = new HashSet<String>();
						XLog classifiedFilteredTestLog = checkPlugin.run(context, filteredTrainingModel,
								filteredTestLog, messages, checks);
						for (XTrace subTrace : filteredTestLog) {
							//							if (positiveTestTraces.size() <= threshold) {
							//								continue;
							//							}
							if (!classifiedFilteredTestLog.contains(subTrace)) {
								String caseId = XConceptExtension.instance().extractName(subTrace);
								if (positiveTestTraces.remove(caseId)) {
									System.out.println(""[LogSkeletonClassifierAlgoritmm] Case ""
											+ XConceptExtension.instance().extractName(subTrace)
											+ "" excluded by positive filter "" + positiveFilters
											+ "" and negative filter "" + negativeFilters + "", support = ""
											+ filteredTrainingLog.size());
									for (String message : messages) {
										System.out.println(""[LogSkeletonClassifierAlgoritmm] "" + message);
									}
								}
							}
						}
					}
				}
			}
			for (String activity : trainingModel.getActivities()) {
				if (positiveTestTraces.size() <= threshold) {
					continue;
				}
				if (activity == LogSkeletonCount.STARTEVENT || activity == LogSkeletonCount.ENDEVENT) {
					continue;
				}
				if (!trainingModel.getSameCounts(activity).iterator().next().equals(activity)) {
					continue;
				}
				for (String activity2 : trainingModel.getActivities()) {
					if (positiveTestTraces.size() <= threshold) {
						continue;
					}
					if (activity2 == LogSkeletonCount.STARTEVENT || activity2 == LogSkeletonCount.ENDEVENT) {
						continue;
					}
					if (!trainingModel.getSameCounts(activity2).iterator().next().equals(activity2)) {
						continue;
					}
					if (trainingModel.getSameCounts(activity).contains(activity2)) {
						continue;
					}
					for (String activity3 : trainingModel.getActivities()) {
						if (positiveTestTraces.size() <= threshold) {
							continue;
						}
						if (activity3 == LogSkeletonCount.STARTEVENT || activity3 == LogSkeletonCount.ENDEVENT) {
							continue;
						}
						if (!trainingModel.getSameCounts(activity3).iterator().next().equals(activity3)) {
							continue;
						}
						if (trainingModel.getSameCounts(activity).contains(activity3)) {
							continue;
						}
						if (trainingModel.getSameCounts(activity2).contains(activity3)) {
							continue;
						}
						for (int f = 0; f < 8; f++) {
							if (positiveTestTraces.size() <= threshold) {
								continue;
							}
							Set<String> positiveFilters = new HashSet<String>();
							Set<String> negativeFilters = new HashSet<String>();
							if (f == 0 || f == 1 || f == 2 || f == 3) {
								positiveFilters.add(activity);
							} else {
								negativeFilters.add(activity);
							}
							if (f == 0 || f == 1 || f == 4 || f == 5) {
								positiveFilters.add(activity2);
							} else {
								negativeFilters.add(activity2);
							}
							if (f == 0 || f == 2 || f == 4 || f == 6) {
								positiveFilters.add(activity3);
							} else {
								negativeFilters.add(activity3);
							}
														System.out.println(""[LogSkeletonClassifierAlgorithm] Positive = "" + positiveFilters + "", Negative = "" + negativeFilters);
							XLog filteredTrainingLog = filter(trainingLog, classifier, positiveFilters, negativeFilters);
							XLog filteredTestLog = filter(testLog, classifier, positiveFilters, negativeFilters);
							if (filteredTestLog.isEmpty() || filteredTrainingLog.isEmpty()
									|| filteredTrainingLog.size() < 16) {
								continue;
							}
							//						System.out.println(""[PDC2017TestPlugin] Remaining traces 2: "" + filteredTrainingLog.size());
							LogSkeleton filteredTrainingModel = createPlugin.run(context, filteredTrainingLog);
							messages = new HashSet<String>();
							XLog classifiedFilteredTestLog = checkPlugin.run(context, filteredTrainingModel,
									filteredTestLog, messages, checks);
							for (XTrace subTrace : filteredTestLog) {
								//							if (positiveTestTraces.size() <= threshold) {
								//								continue;
								//							}
								if (!classifiedFilteredTestLog.contains(subTrace)) {
									String caseId = XConceptExtension.instance().extractName(subTrace);
									if (positiveTestTraces.remove(caseId)) {
										System.out.println(""[LogSkeletonClassifierAlgoritmm] Case ""
												+ XConceptExtension.instance().extractName(subTrace)
												+ "" excluded by positive filter "" + positiveFilters
												+ "" and negative filter "" + negativeFilters + "", support = ""
												+ filteredTrainingLog.size());
										for (String message : messages) {
											System.out.println(""[LogSkeletonClassifierAlgoritmm] "" + message);
										}
									}
								}
							}
						}

					}
				}
			}
		}
		XLog newClassifiedTestLog = XFactoryRegistry.instance().currentDefault().createLog();
		XConceptExtension.instance().assignName(newClassifiedTestLog, name + "" (classified)"");
		for (XTrace trace : classifiedTestLog) {
			if (positiveTestTraces.contains(XConceptExtension.instance().extractName(trace))) {
				newClassifiedTestLog.add(trace);
			}
		}
		return newClassifiedTestLog;
	}

	private static XLog filter(XLog log, XEventClassifier classifier, Set<String> positiveFilters, Set<String> negativeFilters) {
		XLog filteredLog = XFactoryRegistry.instance().currentDefault().createLog();
		for (XTrace trace : log) {
			boolean ok = true;
			Set<String> toMatch = new HashSet<String>(positiveFilters);
			for (XEvent event : trace) {
				String activity = classifier.getClassIdentity(event);
				if (negativeFilters.contains(activity)) {
					ok = false;
					;
				}
				toMatch.remove(activity);
			}
			if (ok && toMatch.isEmpty()) {
				filteredLog.add(trace);
			}
		}
		return filteredLog;
	}

	private static void addTrace(XLog log, List<String> activities) {
		XFactory factory = XFactoryRegistry.instance().currentDefault();
		XTrace trace = factory.createTrace();
		for (String activity : activities) {
			XEvent event = factory.createEvent();
			XConceptExtension.instance().assignName(event, activity);
			trace.add(event);
		}
		log.add(trace);
	}

}
"
SplitterAlgorithm.java,log-skeleton,"package org.processmining.logskeleton.algorithms;

import org.deckfour.xes.classification.XEventClassifier;
import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.factory.XFactoryRegistry;
import org.deckfour.xes.model.XAttributeLiteral;
import org.deckfour.xes.model.XAttributeMap;
import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.deckfour.xes.model.impl.XAttributeLiteralImpl;
import org.processmining.logskeleton.classifiers.LogSkeletonClassifier;
import org.processmining.logskeleton.parameters.SplitterParameters;

public class SplitterAlgorithm {

	public XLog apply(XLog log, XEventClassifier classifier, SplitterParameters parameters) {
		XLog filteredLog = XFactoryRegistry.instance().currentDefault()
				.createLog((XAttributeMap) log.getAttributes().clone());
		for (XTrace trace : log) {
			XTrace filteredTrace = XFactoryRegistry.instance().currentDefault().createTrace(trace.getAttributes());
			int milestone = 0;
			for (XEvent event : trace) {
				String activity = classifier.getClassIdentity(event);
				if (activity.equals(parameters.getDuplicateActivity())) {
					XEvent filteredEvent = (XEvent) event.clone(); //XFactoryRegistry.instance().currentDefault().createEvent();
					if (event.getAttributes().containsKey(LogSkeletonClassifier.SUFFIX)) {
						((XAttributeLiteral) filteredEvent.getAttributes().get(LogSkeletonClassifier.SUFFIX)).setValue(event.getAttributes().get(LogSkeletonClassifier.SUFFIX)+ ""."" + milestone);
					} else {
						filteredEvent.getAttributes().put(LogSkeletonClassifier.SUFFIX, new XAttributeLiteralImpl(LogSkeletonClassifier.SUFFIX, ""."" + milestone));
					}
					filteredTrace.add(filteredEvent);
				} else {
					filteredTrace.add(event);
				}
				if (parameters.getMilestoneActivities().contains(activity)) {
					if (milestone == 0) {
						milestone++;
					}
				}
			}
			filteredLog.add(filteredTrace);
		}
		//		System.out.println(""[SplitterAlgorithm] Split log contains "" + filteredLog.size() + "" traces"");
		return filteredLog;
	}

	public XLog apply7B(XLog log, XEventClassifier classifier) {
		XLog filteredLog = XFactoryRegistry.instance().currentDefault()
				.createLog((XAttributeMap) log.getAttributes().clone());
		for (XTrace trace : log) {
			XTrace filteredTrace = XFactoryRegistry.instance().currentDefault().createTrace(trace.getAttributes());
			for (int i = 0; i < trace.size(); i++) {
				if (i == trace.size() - 1 && classifier.getClassIdentity(trace.get(i)).equals(""b"")) {
					XEvent filteredEvent = (XEvent) trace.get(i).clone();
					trace.get(i).getAttributes().put(LogSkeletonClassifier.SUFFIX, new XAttributeLiteralImpl(LogSkeletonClassifier.SUFFIX, "".1""));
					filteredTrace.add(filteredEvent);
				} else if (i == trace.size() - 2 && classifier.getClassIdentity(trace.get(i)).equals(""b"")
						&& classifier.getClassIdentity(trace.get(i + 1)).equals(""s"")) {
					XEvent filteredEvent = (XEvent) trace.get(i).clone();
					trace.get(i).getAttributes().put(LogSkeletonClassifier.SUFFIX, new XAttributeLiteralImpl(LogSkeletonClassifier.SUFFIX, "".1""));
					filteredTrace.add(filteredEvent);
				} else if (classifier.getClassIdentity(trace.get(i)).equals(""b"")) {
					XEvent filteredEvent = (XEvent) trace.get(i).clone();
					trace.get(i).getAttributes().put(LogSkeletonClassifier.SUFFIX, new XAttributeLiteralImpl(LogSkeletonClassifier.SUFFIX, "".0""));
					filteredTrace.add(filteredEvent);
				} else {
					filteredTrace.add(trace.get(i));
				}
			}
			filteredLog.add(filteredTrace);
		}
		//		System.out.println(""[SplitterAlgorithm] Split log contains "" + filteredLog.size() + "" traces"");
		return filteredLog;
	}

	public XLog apply20194(XLog log) {
		XLog filteredLog = XFactoryRegistry.instance().currentDefault()
				.createLog((XAttributeMap) log.getAttributes().clone());
		for (XTrace trace : log) {
			XTrace filteredTrace = XFactoryRegistry.instance().currentDefault().createTrace(trace.getAttributes());

			for (int i = 0; i < trace.size(); i++) {
				XEvent filteredEvent = XFactoryRegistry.instance().currentDefault().createEvent();
				XConceptExtension.instance().assignName(filteredEvent,
						XConceptExtension.instance().extractName(trace.get(i)));
				if (XConceptExtension.instance().extractName(trace.get(i)).equals(""c"")) {
					if (i == 4 || i == 5) {
						XConceptExtension.instance().assignName(filteredEvent, ""c.0"");
					} else if (i + 1 < trace.size() && new String("" w f ac ag aj r "").contains("" "" + XConceptExtension.instance().extractName(trace.get(i + 1)) + "" "")) {
						XConceptExtension.instance().assignName(filteredEvent, ""c.3"");
					} else if (i + 1 < trace.size() && XConceptExtension.instance().extractName(trace.get(i + 1)).equals(""as"")) {
						XConceptExtension.instance().assignName(filteredEvent, ""c.1"");
					} else {
						XConceptExtension.instance().assignName(filteredEvent, ""c.2"");
					}
				} else if (XConceptExtension.instance().extractName(trace.get(i)).equals(""t"")) {
					if (new String("" am c b q "").contains("" "" + XConceptExtension.instance().extractName(trace.get(i - 1)) + "" "")) {
						XConceptExtension.instance().assignName(filteredEvent, ""t.0"");
					} else {
						XConceptExtension.instance().assignName(filteredEvent, ""t.1"");
					}
				} else if (XConceptExtension.instance().extractName(trace.get(i)).equals(""ad"")) {
					if (i == trace.size() - 1) {
						XConceptExtension.instance().assignName(filteredEvent, ""ad.1"");
					} else {
						XConceptExtension.instance().assignName(filteredEvent, ""ad.0"");
					}
				} else if (XConceptExtension.instance().extractName(trace.get(i)).equals(""as"")) {
					if (XConceptExtension.instance().extractName(trace.get(i - 1)).equals(""c"")) {
						XConceptExtension.instance().assignName(filteredEvent, ""as.0"");
					} else {
						XConceptExtension.instance().assignName(filteredEvent, ""as.1"");
					}
				} else if (XConceptExtension.instance().extractName(trace.get(i)).equals(""e"")) {
					if (XConceptExtension.instance().extractName(trace.get(i - 1)).equals(""l"")) {
						XConceptExtension.instance().assignName(filteredEvent, ""e.0"");
					} else {
						XConceptExtension.instance().assignName(filteredEvent, ""e.1"");
					}
				} else if (XConceptExtension.instance().extractName(trace.get(i)).equals(""aj"")) {
					if (i == 0 || i == 1) {
						XConceptExtension.instance().assignName(filteredEvent, ""aj.0"");
					} else {
						XConceptExtension.instance().assignName(filteredEvent, ""aj.1"");
					}
				} else if (XConceptExtension.instance().extractName(trace.get(i)).equals(""f"")) {
					if (i == 6) {
						XConceptExtension.instance().assignName(filteredEvent, ""f.0"");
					} else {
						XConceptExtension.instance().assignName(filteredEvent, ""f.1"");
					}
				} else if (XConceptExtension.instance().extractName(trace.get(i)).equals(""w"")) {
					if (i == 6) {
						XConceptExtension.instance().assignName(filteredEvent, ""w.0"");
					} else {
						XConceptExtension.instance().assignName(filteredEvent, ""w.1"");
					}
				} else if (XConceptExtension.instance().extractName(trace.get(i)).equals(""r"")) {
					if (XConceptExtension.instance().extractName(trace.get(i - 1)).equals(""as"")) {
						XConceptExtension.instance().assignName(filteredEvent, ""r.0"");
					} else {
						XConceptExtension.instance().assignName(filteredEvent, ""r.1"");
					}
				}
				filteredTrace.add(filteredEvent);
			}
			filteredLog.add(filteredTrace);
		}
		//		System.out.println(""[SplitterAlgorithm] Split log contains "" + filteredLog.size() + "" traces"");
		return filteredLog;
	}
	
}
"
LogSkeletonClassifier.java,log-skeleton,"package org.processmining.logskeleton.classifiers;

import org.deckfour.xes.classification.XEventClassifier;
import org.deckfour.xes.classification.XEventNameClassifier;
import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XVisitor;

public class LogSkeletonClassifier implements XEventClassifier {

	private XEventClassifier prefixClassifier;
	public final static String SUFFIX = "".suffix"";
	
	public LogSkeletonClassifier() {
		this(new XEventNameClassifier());
	}
	
	public LogSkeletonClassifier(XEventClassifier classifier) {
		this.prefixClassifier = classifier;
	}
	
	public void accept(XVisitor arg0, XLog arg1) {
	}

	public String getClassIdentity(XEvent event) {
		if (event.getAttributes().containsKey(SUFFIX)) {
			return prefixClassifier.getClassIdentity(event) + event.getAttributes().get(SUFFIX).toString();
		}
		return prefixClassifier.getClassIdentity(event);
	}

	public String[] getDefiningAttributeKeys() {
		return prefixClassifier.getDefiningAttributeKeys();
	}

	public String name() {
		return null;
	}

	public boolean sameEventClass(XEvent arg0, XEvent arg1) {
		return false;
	}

	public void setName(String arg0) {
	}

}
"
ClassificationProblem.java,log-skeleton,"package org.processmining.logskeleton.models;

import org.deckfour.xes.model.XLog;

public class ClassificationProblem {

	private XLog trainingLog;
	private XLog testLog;
	
	public ClassificationProblem(XLog trainingLog, XLog testLog) {
		this.trainingLog = trainingLog;
		this.testLog = testLog;
	}
	
	public XLog getTrainingLog() {
		return trainingLog;
	}
	
	public void setTrainingLog(XLog trainingLog) {
		this.trainingLog = trainingLog;
	}

	public XLog getTestLog() {
		return testLog;
	}

	public void setTestLog(XLog testLog) {
		this.testLog = testLog;
	}
	
}
"
LogSkeleton.java,log-skeleton,"package org.processmining.logskeleton.models;

import java.awt.Color;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XTrace;
import org.processmining.framework.annotations.AuthoredType;
import org.processmining.framework.annotations.Icon;
import org.processmining.framework.util.HTMLToString;
import org.processmining.logskeleton.parameters.LogSkeletonBrowser;
import org.processmining.logskeleton.parameters.LogSkeletonBrowserParameters;
import org.processmining.plugins.graphviz.dot.Dot;
import org.processmining.plugins.graphviz.dot.DotEdge;
import org.processmining.plugins.graphviz.dot.DotNode;

import com.csvreader.CsvReader;
import com.csvreader.CsvWriter;

@AuthoredType(typeName = ""Log skeleton"", affiliation = AuthoredType.TUE, author = ""H.M.W. Verbeek"", email = ""h.m.w.verbeek@tue.nl"")
@Icon(icon = ""rotule_30x35.png"")
public class LogSkeleton implements HTMLToString {

	/*
	 * Holds the counters and the directly-follows relation.
	 */
	private LogSkeletonCount countModel;

	/*
	 * The equivalence relation. If S is an element of sameCounts, then all
	 * elements of S are equivalent.
	 */
	private Collection<Collection<String>> sameCounts;
	private Map<Integer, Collection<Collection<String>>> sameCountsNoise;

	/*
	 * The precedence relation. If precedence.get(a).contains(b), then if a
	 * occurs, some b must occur before.
	 */
	private Map<String, ThresholdSet> precedences;

	/*
	 * The response relation. If response.get(a).contains(b), then if a occurs,
	 * some b must occur after.
	 */
	private Map<String, ThresholdSet> responses;

	private Map<String, ThresholdSet> notPrecedences;
	private Map<String, ThresholdSet> notResponses;

	/*
	 * The not co-existence relation. If notCoExistence.get(a).contains(b), then
	 * if a occurs, b may not occur (before or after).
	 */
	private Map<String, ThresholdSet> notCoExistences;

	private Set<String> required;
	private Set<String> forbidden;
	private List<List<String>> splitters;
	private String label;

	private int equivalenceThreshold;
	private int precedenceThreshold;
	private int responseThreshold;
	private int notCoExistenceeThreshold;

	//	private Map<List<String>, List<Integer>> distances;

	public LogSkeleton() {
		this(new LogSkeletonCount());
	}

	@SuppressWarnings(""unchecked"")
	public LogSkeleton(LogSkeletonCount countModel) {
		this.countModel = countModel;
		//		sameCounts = new HashSet<Collection<String>>();
		sameCountsNoise = new HashMap<Integer, Collection<Collection<String>>>();
		for (int noiseLevel = 0; noiseLevel < 21; noiseLevel++) {
			sameCountsNoise.put(noiseLevel, new HashSet<Collection<String>>());
		}
		sameCounts = sameCountsNoise.get(0);
		precedences = new HashMap<String, ThresholdSet>();
		responses = new HashMap<String, ThresholdSet>();
		notPrecedences = new HashMap<String, ThresholdSet>();
		notResponses = new HashMap<String, ThresholdSet>();
		notCoExistences = new HashMap<String, ThresholdSet>();
		required = new HashSet<String>();
		forbidden = new HashSet<String>();
		splitters = new ArrayList<List<String>>();
		label = null;
		setEquivalenceThreshold(100);
		setPrecedenceThreshold(100);
		setResponseThreshold(100);
		setNotCoExistenceThreshold(100);
	}

	public void addSameCount(Collection<String> activities) {
		List<String> orderedActivities = new ArrayList<String>(activities);
		Collections.sort(orderedActivities);
		sameCounts.add(orderedActivities);
	}

	public void addSameCount(int noiseLevel, Collection<String> activities) {
		List<String> orderedActivities = new ArrayList<String>(activities);
		Collections.sort(orderedActivities);
		sameCountsNoise.get(noiseLevel).add(orderedActivities);
	}

	public Collection<String> getSameCounts(String activity) {
		for (Collection<String> sameCount : sameCounts) {
			if (sameCount.contains(activity)) {
				return sameCount;
			}
		}
		return null;
	}

	public void addPrePost(String activity, Collection<String> pre, Collection<String> post) {
		Set<String> preset = new HashSet<String>(pre);
		Set<String> postset = new HashSet<String>(post);
		if (!precedences.containsKey(activity)) {
			precedences.put(activity, new ThresholdSet(countModel.getActivities(), precedenceThreshold));
		}
		if (!responses.containsKey(activity)) {
			responses.put(activity, new ThresholdSet(countModel.getActivities(), responseThreshold));
		}
		if (!notPrecedences.containsKey(activity)) {
			notPrecedences.put(activity, new ThresholdSet(countModel.getActivities(), precedenceThreshold));
		}
		if (!notResponses.containsKey(activity)) {
			notResponses.put(activity, new ThresholdSet(countModel.getActivities(), responseThreshold));
		}
		if (!notCoExistences.containsKey(activity)) {
			notCoExistences.put(activity, new ThresholdSet(countModel.getActivities(), notCoExistenceeThreshold));
		}
		precedences.get(activity).addAll(preset);
		responses.get(activity).addAll(postset);
		Set<String> negPreset = new HashSet<String>(countModel.getActivities());
		negPreset.removeAll(preset);
		notPrecedences.get(activity).addAll(negPreset);
		Set<String> negPostset = new HashSet<String>(countModel.getActivities());
		negPostset.removeAll(postset);
		notResponses.get(activity).addAll(negPostset);
		Set<String> prepostset = new HashSet<String>(countModel.getActivities());
		prepostset.removeAll(preset);
		prepostset.removeAll(postset);
		notCoExistences.get(activity).addAll(prepostset);
	}

	public void cleanPrePost() {
		for (String activity : precedences.keySet()) {
			precedences.get(activity).reset();
		}
		for (String activity : responses.keySet()) {
			responses.get(activity).reset();
		}
		for (String activity : notPrecedences.keySet()) {
			notPrecedences.get(activity).reset();
		}
		for (String activity : notResponses.keySet()) {
			notResponses.get(activity).reset();
		}
		for (String activity : notCoExistences.keySet()) {
			notPrecedences.get(activity).removeAll(notCoExistences.get(activity));
			notResponses.get(activity).removeAll(notCoExistences.get(activity));
		}
		Map<String, Set<String>> precedences2 = new HashMap<String, Set<String>>();
		Map<String, Set<String>> responses2 = new HashMap<String, Set<String>>();
		Map<String, Set<String>> negPrecedences2 = new HashMap<String, Set<String>>();
		Map<String, Set<String>> negResponses2 = new HashMap<String, Set<String>>();
		for (String activity : countModel.getActivities()) {
			precedences2.put(activity, new HashSet<String>(precedences.get(activity)));
			responses2.put(activity, new HashSet<String>(responses.get(activity)));
			negPrecedences2.put(activity, new HashSet<String>(notPrecedences.get(activity)));
			negResponses2.put(activity, new HashSet<String>(notResponses.get(activity)));
		}
		for (String activity : countModel.getActivities()) {
			cleanPrePost(activity, precedences, precedences2);
			cleanPrePost(activity, responses, responses2);
			cleanPrePost(activity, notPrecedences, negPrecedences2);
			cleanPrePost(activity, notResponses, negResponses2);
		}
	}

	private void cleanPrePost(String activity, Map<String, ThresholdSet> map, Map<String, Set<String>> map2) {
		Set<String> mappedActivities = map2.get(activity);
		Set<String> mappedMappedActivities = new HashSet<String>();
		for (String mappedActivity : mappedActivities) {
			for (String mappedMappedActivity : map2.get(mappedActivity)) {
				if (!map2.get(mappedMappedActivity).contains(mappedActivity)) {
					mappedMappedActivities.add(mappedMappedActivity);
				}
			}
		}
//		System.out.println(""[LogSkeleton] "" + activity + "" "" + mappedMappedActivities);
		map.get(activity).removeAll(mappedMappedActivities);
	}

	private boolean checkSameCounts(LogSkeletonCount model, Set<String> messages, String caseId) {
		boolean ok = true;
		for (Collection<String> sameCount : sameCounts) {
			Set<Integer> counts = new HashSet<Integer>();
			for (String activity : sameCount) {
				counts.add(model.get(activity));
			}
			if (counts.size() != 1) {
				messages.add(""[LogSkeleton] Case "" + caseId + "": Always Together fails for "" + sameCount);
				ok = false;
			}
		}
		return ok;
	}

	private boolean checkTransitionCounts(LogSkeletonCount model, Set<String> messages, String caseId) {
		return countModel.checkTransitionCounts(model, messages, caseId);
	}

	private boolean checkCausalDependencies(XTrace trace, Set<String> messages) {
		String caseId = XConceptExtension.instance().extractName(trace);
		List<String> postset = new ArrayList<String>();
		postset.add(LogSkeletonCount.STARTEVENT);
		for (XEvent event : trace) {
			postset.add(XConceptExtension.instance().extractName(event));
		}
		postset.add(LogSkeletonCount.ENDEVENT);
		List<String> preset = new ArrayList<String>();
		String prevActivity = null;
		while (!postset.isEmpty()) {
			if (prevActivity != null) {
				preset.add(prevActivity);
			}
			String activity = postset.remove(0);
			if (precedences.containsKey(activity) && !preset.containsAll(precedences.get(activity))) {
				Set<String> missing = new HashSet<String>(precedences.get(activity));
				missing.removeAll(preset);
				messages.add(""[LogSkeleton] Case "" + caseId + "": Precedence fails for "" + activity + "", missing are ""
						+ missing);
				return false;
			}
			if (responses.containsKey(activity) && !postset.containsAll(responses.get(activity))) {
				Set<String> missing = new HashSet<String>(responses.get(activity));
				missing.removeAll(postset);
				messages.add(""[LogSkeleton] Case "" + caseId + "": Response fails for "" + activity + "", missing are ""
						+ missing);
				return false;
			}
			Set<String> notPreset = new HashSet<String>(countModel.getActivities());
			notPreset.removeAll(preset);
			if (notPrecedences.containsKey(activity) && !notPreset.containsAll(notPrecedences.get(activity))) {
				Set<String> present = new HashSet<String>(notPrecedences.get(activity));
				present.removeAll(notPreset);
				messages.add(""[LogSkeleton] Case "" + caseId + "": Not Precedence fails for "" + activity + "", present are ""
						+ present);
				return false;
			}
			Set<String> notPostset = new HashSet<String>(countModel.getActivities());
			notPostset.removeAll(postset);
			if (notResponses.containsKey(activity) && !notPostset.containsAll(notResponses.get(activity))) {
				Set<String> present = new HashSet<String>(notResponses.get(activity));
				present.removeAll(notPostset);
				messages.add(""[LogSkeleton] Case "" + caseId + "": Not Response fails for "" + activity + "", present are ""
						+ present);
				return false;
			}
			prevActivity = activity;
		}
		return true;
	}

	public boolean check(XTrace trace, LogSkeletonCount model, Set<String> messages, boolean[] checks) {
		boolean ok = true;
		if (checks[0]) {
			ok = ok && checkSameCounts(model, messages, XConceptExtension.instance().extractName(trace));
			if (!ok) {
				return false;
			}
		}
		if (checks[1]) {
			ok = ok && checkCausalDependencies(trace, messages);
			if (!ok) {
				return false;
			}
		}
		if (checks[2]) {
			ok = ok && checkTransitionCounts(model, messages, XConceptExtension.instance().extractName(trace));
			if (!ok) {
				return false;
			}
		}
		return ok;
	}

	public String toHTMLString(boolean includeHTMLTags) {
		StringBuffer buf = new StringBuffer();
		List<String> sorted;
		if (includeHTMLTags) {
			buf.append(""<html>"");
		}
		buf.append(""<h1>Causal relations</h1><table>"");
		buf.append(
				""<tr><th>Activity</th><th>Sibling activities</th><th>Count</th><th>Precedence</th><th>Response</th><th>Not co-occurrence</th></tr>"");
		for (String activity : countModel.getActivities()) {
			// Activity
			buf.append(""<tr><td>"" + activity + ""</td>"");
			// Sibling activities and count
			for (Collection<String> siblings : sameCounts) {
				if (siblings.contains(activity)) {
					// Activities
					sorted = new ArrayList<String>(siblings);
					Collections.sort(sorted);
					sorted.remove(activity);
					buf.append(""<td>"" + sorted + ""</td>"");
					// Count
					buf.append(""<td>"" + countModel.get(activity) + ""</td>"");
				}
			}
			// Precedence
			sorted = new ArrayList<String>(precedences.get(activity));
			Collections.sort(sorted);
			buf.append(""<td>"" + sorted + ""</td>"");
			// Response
			sorted = new ArrayList<String>(responses.get(activity));
			Collections.sort(sorted);
			buf.append(""<td>"" + sorted + ""</td>"");
			// Not co-occurrence
			sorted = new ArrayList<String>(countModel.getActivities());
			sorted.removeAll(notCoExistences.get(activity));
			Collections.sort(sorted);
			buf.append(""<td>"" + sorted + ""</td>"");
		}
		buf.append(""</table>"");
		if (includeHTMLTags) {
			buf.append(""</html>"");
		}
		return buf.toString();
	}

	public Dot visualize(LogSkeletonBrowserParameters parameters) {
		Map<String, DotNode> map = new HashMap<String, DotNode>();
		Dot graph = new Dot();
		//		graph.setOption(""concentrate"", ""true"");
		//		graph.setKeepOrderingOfChildren(true);
		// Set312 color scheme, with white as last resort.
		String[] set312Colors = new String[] { ""#8dd3c7"", ""#ffffb3"", ""#bebada"", ""#fb8072"", ""#80b1d3"", ""#fdb462"",
				""#b3de69"", ""#fccde5"", ""#d9d9d9"", ""#bc80bd"", ""#ccebc5"", ""#ffed6f"" };
		//		String[] colors = new String[] { ""#8dd3c7"", ""#ffffb3"", ""#bebada"", ""#fb8072"", ""#80b1d3"", ""#fdb462"", ""#b3de69"",
		//				""#fccde5"", ""#d9d9d9"", ""#bc80bd"", ""#ccebc5"", ""#ffed6f"", ""#8dd3c7:#ffffb3"", ""#bebada:#fb8072"",
		//				""#80b1d3:#fdb462"", ""#b3de69:#fccde5"", ""#d9d9d9:#bc80bd"", ""#ccebc5:#ffed6f"", ""#ffffb3:#bebada"",
		//				""#fb8072:#80b1d3"", ""#fdb462:#b3de69"", ""#fccde5:#d9d9d9"", ""#bc80bd:#ccebc5"", ""#ffed6f:#8dd3c7"", ""white"" };
		String[] colors = new String[100];
		for (int i = 0; i < 99; i++) {
			int m = i / 12;
			int d = i % 12;
			if (m == 0) {
				// Basic color, no gradient.
				colors[i] = set312Colors[i];
			} else {
				// Extended color, gradient.
				colors[i] = set312Colors[d] + "":"" + set312Colors[(d + m) % 12];
			}
		}
		// Fall-back color
		colors[99] = ""white"";

		int colorIndex = 0;
		Map<String, String> colorMap = new HashMap<String, String>();

		Set<String> activities = new HashSet<String>(parameters.getActivities());

		setPrecedenceThreshold(parameters.getPrecedenceThreshold());
		setResponseThreshold(parameters.getResponseThreshold());
		setNotCoExistenceThreshold(parameters.getNotCoExistenceThreshold());

		if (parameters.isUseNeighbors()) {
			for (String fromActivity : countModel.getActivities()) {
				for (String toActivity : countModel.getActivities()) {
					if (parameters.getActivities().contains(fromActivity)
							|| parameters.getActivities().contains(toActivity)) {
						if (parameters.getVisualizers().contains(LogSkeletonBrowser.ALWAYSAFTER)) {
							if (responses.get(fromActivity).contains(toActivity)) {
								activities.add(fromActivity);
								activities.add(toActivity);
							}
						}
						if (parameters.getVisualizers().contains(LogSkeletonBrowser.ALWAYSBEFORE)) {
							if (precedences.get(toActivity).contains(fromActivity)) {
								activities.add(fromActivity);
								activities.add(toActivity);
							}
						}
						if (parameters.getVisualizers().contains(LogSkeletonBrowser.NEVERAFTER)) {
							if (notResponses.get(fromActivity).contains(toActivity)) {
								activities.add(fromActivity);
								activities.add(toActivity);
							}
						}
						if (parameters.getVisualizers().contains(LogSkeletonBrowser.NEVERBEFORE)) {
							if (notPrecedences.get(toActivity).contains(fromActivity)) {
								activities.add(fromActivity);
								activities.add(toActivity);
							}
						}
						//						if (parameters.getVisualizers().contains(LogSkeletonBrowser.OFTENNEXT)) {
						//							if (countModel.get(toActivity, fromActivity) == 0
						//									&& (5 * countModel.get(fromActivity, toActivity) > countModel.get(fromActivity))) {
						//								activities.add(fromActivity);
						//								activities.add(toActivity);
						//							}
						//						}
						//						if (parameters.getVisualizers().contains(LogSkeletonBrowser.OFTENPREVIOUS)) {
						//							if (countModel.get(toActivity, fromActivity) == 0
						//									&& (5 * countModel.get(fromActivity, toActivity) > countModel.get(toActivity))) {
						//								activities.add(fromActivity);
						//								activities.add(toActivity);
						//							}
						//						}
						if (parameters.getVisualizers().contains(LogSkeletonBrowser.NEVERTOGETHER)) {
							if (!fromActivity.equals(toActivity)) {
								if (fromActivity.compareTo(toActivity) >= 0
										&& (!parameters.isUseEquivalenceClass()
												|| fromActivity.equals(getSameCounts(fromActivity).iterator().next()))
										&& (!parameters.isUseEquivalenceClass()
												|| toActivity.equals(getSameCounts(toActivity).iterator().next()))
										&& notCoExistences.get(fromActivity).contains(toActivity)) {
									activities.add(fromActivity);
									activities.add(toActivity);
								}
							}
						}
						//						if (parameters.getVisualizers().contains(LogSkeletonBrowser.NEXTONEWAY)) {
						//							if (countModel.get(fromActivity, toActivity) > 0
						//									&& countModel.get(toActivity, fromActivity) == 0) {
						//								activities.add(fromActivity);
						//								activities.add(toActivity);
						//							}
						//						}
						//						if (parameters.getVisualizers().contains(LogSkeletonBrowser.NEXTBOTHWAYS)) {
						//							if (fromActivity.compareTo(toActivity) <= 0) {
						//								if (countModel.get(fromActivity, toActivity) > 0
						//										&& countModel.get(toActivity, fromActivity) > 0) {
						//									activities.add(fromActivity);
						//									activities.add(toActivity);
						//								}
						//							}
						//						}
					}
				}
			}
		}

		for (String activity : activities) {
			String colorActivity = getSameCounts(activity).iterator().next();
			String activityColor = colorMap.get(colorActivity);
			if (activityColor == null) {
				activityColor = colors[colorIndex];
				colorMap.put(colorActivity, activityColor);
				if (colorIndex < colors.length - 1) {
					colorIndex++;
				}
			}
			String interval = """" + countModel.getMin(activity);
			if (countModel.getMax(activity) > countModel.getMin(activity)) {
				interval += "".."" + countModel.getMax(activity);
			}
			int border = 0;
			if (parameters.getActivities().contains(activity)) {
				border = 1;
			}

			DotNode node = graph.addNode(""<<table align=\""center\"" bgcolor=\"""" + activityColor + ""\"" border=\"""" + border
					+ ""\"" cellborder=\""0\"" cellpadding=\""2\"" columns=\""*\"" style=\""rounded\""><tr><td colspan=\""3\""><font point-size=\""24\""><b>""
					+ encodeHTML(activity) + ""</b></font></td></tr><hr/><tr><td>"" + colorActivity + ""</td><td>""
					+ countModel.get(activity) + ""</td>"" + ""<td>"" + interval + ""</td>"" + ""</tr></table>>"");
			node.setOption(""shape"", ""none"");
			//			DotNode node = graph.addNode(activity + ""\n"" + countModel.get(activity));
			//			node.setLabel(""<"" + encodeHTML(activity) + "">"");
			map.put(activity, node);
		}

		String defaultColor = darker(""#d9d9d9"");
		String almostNeverColor = ""#fdb462"";
		String neverColor = darker(almostNeverColor);
		String almostAlwaysColor = ""#80b1d3"";
		String alwaysColor = darker(almostAlwaysColor);
		String almostAlwaysNotColor = ""#fb8072"";
		String alwaysNotColor = darker(almostAlwaysNotColor);

		for (String fromActivity : activities) {
			for (String toActivity : activities) {
				if (parameters.getActivities().contains(fromActivity)
						|| parameters.getActivities().contains(toActivity)) {
					String tailDecorator = null;
					String headDecorator = null;
					String tailLabel = null;
					String headLabel = null;
					String tailArrow = null;
					String headArrow = null;
					String headColor = null;
					String tailColor = null;
					boolean isAsymmetric = true;
					if (parameters.getVisualizers().contains(LogSkeletonBrowser.ALWAYSAFTER)) {
						if (tailDecorator == null && responses.get(fromActivity).contains(toActivity)) {
							tailDecorator = ""noneinv"";
//							headArrow = ""normal"";
							tailColor = alwaysColor;
							int threshold = responses.get(fromActivity).getMaxThreshold(toActivity);
							if (threshold < 100) {
								tailLabel = ""."" + threshold;
								tailColor = almostAlwaysColor;
							}
							//							System.out.println(""[LogSkeleton] tailLabel = "" + tailLabel);
						}
					}
					if (parameters.getVisualizers().contains(LogSkeletonBrowser.ALWAYSBEFORE)) {
						if (headDecorator == null && precedences.get(toActivity).contains(fromActivity)) {
							headDecorator = ""normal"";
//							headArrow = ""normal"";
							headColor = alwaysColor;
							int threshold = precedences.get(toActivity).getMaxThreshold(fromActivity);
							if (threshold < 100) {
								headLabel = ""."" + threshold;
								headColor = almostAlwaysColor;
							}
							//							System.out.println(""[LogSkeleton] headLabel = "" + headLabel);
						}
					}
					//					if (parameters.getVisualizers().contains(LogSkeletonBrowser.OFTENNEXT)) {
					//						if (tailDecorator == null && countModel.get(toActivity, fromActivity) == 0
					//								&& (5 * countModel.get(fromActivity, toActivity) > countModel.get(fromActivity))) {
					//							tailDecorator = ""odot"";
					//							headArrow = ""normal"";
					//							headLabel = """" + countModel.get(fromActivity, toActivity);
					//						}
					//					}
					//					if (parameters.getVisualizers().contains(LogSkeletonBrowser.OFTENPREVIOUS)) {
					//						if (headDecorator == null && countModel.get(toActivity, fromActivity) == 0
					//								&& (5 * countModel.get(fromActivity, toActivity) > countModel.get(toActivity))) {
					//							headDecorator = ""odot"";
					//							headArrow = ""normal"";
					//							headLabel = """" + countModel.get(fromActivity, toActivity);
					//						}
					//					}
					if (parameters.getVisualizers().contains(LogSkeletonBrowser.NEVERTOGETHER)) {
						if (!fromActivity.equals(toActivity)) {
							if (headDecorator == null && fromActivity.compareTo(toActivity) >= 0
									&& (!parameters.isUseEquivalenceClass()
											|| fromActivity.equals(getSameCounts(fromActivity).iterator().next()))
									&& (!parameters.isUseEquivalenceClass()
											|| toActivity.equals(getSameCounts(toActivity).iterator().next()))
									&& notCoExistences.get(toActivity).contains(fromActivity)) {
								headDecorator = ""nonetee"";
								//								dummy = true;
								isAsymmetric = false;
								headColor = neverColor;
								int threshold = notCoExistences.get(toActivity).getMaxThreshold(fromActivity);
								if (threshold < 100) {
									headLabel = ""."" + threshold;
									headColor = almostNeverColor;
								}
							}
							if (tailDecorator == null && fromActivity.compareTo(toActivity) >= 0
									&& (!parameters.isUseEquivalenceClass()
											|| fromActivity.equals(getSameCounts(fromActivity).iterator().next()))
									&& (!parameters.isUseEquivalenceClass()
											|| toActivity.equals(getSameCounts(toActivity).iterator().next()))
									&& notCoExistences.get(fromActivity).contains(toActivity)) {
								tailDecorator = ""nonetee"";
								//								dummy = true;
								isAsymmetric = false;
								tailColor = neverColor;
								int threshold = notCoExistences.get(fromActivity).getMaxThreshold(toActivity);
								if (threshold < 100) {
									tailLabel = ""."" + threshold;
									tailColor = almostNeverColor;
								}
							}
						}
					}
					if (parameters.getVisualizers().contains(LogSkeletonBrowser.NEVERAFTER)) {
						if (!fromActivity.equals(toActivity) && headDecorator == null
								&& notResponses.get(toActivity).contains(fromActivity) 
								/*&& !notResponses.get(fromActivity).contains(toActivity)*/) {
							headDecorator = ""noneinvtee"";
//							tailArrow = ""normal"";
							headColor = alwaysNotColor;
							int threshold = notResponses.get(toActivity).getMaxThreshold(fromActivity);
							if (threshold < 100) {
								headLabel = ""."" + threshold;
								headColor = almostAlwaysNotColor;
							}
							//							System.out.println(""[LogSkeleton] tailLabel = "" + tailLabel);
						}
					}
					if (parameters.getVisualizers().contains(LogSkeletonBrowser.NEVERBEFORE)) {
						if (!fromActivity.equals(toActivity) && tailDecorator == null
								&& notPrecedences.get(fromActivity).contains(toActivity)
								/*&& !notPrecedences.get(toActivity).contains(fromActivity)*/) {
							tailDecorator = ""teenormal"";
//							tailArrow = ""normal"";
							tailColor = alwaysNotColor;
							int threshold = notPrecedences.get(fromActivity).getMaxThreshold(toActivity);
							if (threshold < 100) {
								tailLabel = ""."" + threshold;
								tailColor = almostAlwaysNotColor;
							}
							//							System.out.println(""[LogSkeleton] tailLabel = "" + tailLabel);
						}
					}
					//					if (parameters.getVisualizers().contains(LogSkeletonBrowser.NEXTONEWAY)) {
					//						if (tailDecorator == null && countModel.get(fromActivity, toActivity) > 0
					//								&& countModel.get(toActivity, fromActivity) == 0) {
					//							tailDecorator = ""odot"";
					//							if (headLabel == null) {
					//								headLabel = """" + countModel.get(fromActivity, toActivity);
					//							}
					//							if (headArrow == null) {
					//								headArrow = ""normal"";
					//							}
					//						}
					//					}
					//					if (parameters.getVisualizers().contains(LogSkeletonBrowser.NEXTBOTHWAYS)) {
					//						if (fromActivity.compareTo(toActivity) <= 0) {
					//							if (tailDecorator == null && countModel.get(fromActivity, toActivity) > 0
					//									&& countModel.get(toActivity, fromActivity) > 0) {
					//								tailDecorator = ""odot"";
					//								if (headLabel == null) {
					//									headLabel = """" + countModel.get(fromActivity, toActivity);
					//								}
					//								if (headArrow == null) {
					//									headArrow = ""normal"";
					//								}
					//							}
					//							if (headDecorator == null && countModel.get(fromActivity, toActivity) > 0
					//									&& countModel.get(toActivity, fromActivity) > 0) {
					//								headDecorator = ""odot"";
					//								if (tailLabel == null) {
					//									tailLabel = """" + countModel.get(toActivity, fromActivity);
					//								}
					//								if (tailArrow == null) {
					//									tailArrow = ""vee"";
					//								}
					//							}
					//						}
					//					}
					if (tailDecorator != null || headDecorator != null || tailArrow != null || headArrow != null) {
						DotEdge arc = graph.addEdge(map.get(fromActivity), map.get(toActivity));
						arc.setOption(""dir"", ""both"");
						if (tailDecorator == null) {
							tailDecorator = """";
						}
						if (tailArrow == null) {
							tailArrow = ""none"";
						}
						if (headDecorator == null) {
							headDecorator = """";
						}
						if (headArrow == null) {
							headArrow = ""none"";
						}
						arc.setOption(""arrowtail"", tailDecorator + tailArrow);
						arc.setOption(""arrowhead"", headDecorator + headArrow);
						if (parameters.isUseFalseConstraints() && !isAsymmetric) {
							arc.setOption(""constraint"", ""false"");
						}
						if (parameters.isUseEdgeColors() && (headColor != null || tailColor != null)) {
							String color = (tailColor == null ? defaultColor : tailColor) + "";0.5:""
									+ (headColor == null ? defaultColor : headColor) + "";0.5"";
							arc.setOption(""color"", color);
						}
						//						arc.setOption(""constraint"", ""true"");
						if (parameters.isUseHeadTailLabels()) {
							if (headLabel != null) {
								arc.setOption(""headlabel"", headLabel);
							}
							if (tailLabel != null) {
								arc.setOption(""taillabel"", tailLabel);
							}
						} else if (headLabel != null || tailLabel != null) {
							String label = """";
							if (tailLabel != null) {
								label += tailLabel;
							}
							label += ""&rarr;"";
							if (headLabel != null) {
								label += headLabel;
							}
							arc.setLabel(label);
						}
					}
				}
			}
		}

		if (parameters.isUseHyperArcs())

		{
			/*
			 * Sort the arcs to get a (more) deterministic result.
			 */
			List<DotEdge> candidateArcs = new ArrayList<DotEdge>(graph.getEdges());
			Collections.sort(candidateArcs, new Comparator<DotEdge>() {

				public int compare(DotEdge o1, DotEdge o2) {
					int c = o1.getSource().getLabel().compareTo(o2.getSource().getLabel());
					if (c == 0) {
						c = o1.getTarget().getLabel().compareTo(o2.getTarget().getLabel());
					}
					return c;
				}

			});

			/*
			 * Iterate over all arcs in the (current!) graph.
			 * 
			 * Note that the graph may change in the process.
			 */
			while (!candidateArcs.isEmpty()) {
				/*
				 * Get the next arc.
				 */
				DotEdge arc = candidateArcs.iterator().next();
				/*
				 * For now, only do this for always-arcs. Includes always-not (not response, not precendence) arcs.
				 */
				if (arc.getOption(""arrowtail"").contains(""inv"") || arc.getOption(""arrowhead"").contains(""inv"")
						|| arc.getOption(""arrowtail"").contains(""inv"") 
						|| arc.getOption(""arrowhead"").contains(""normal"")) {
					/*
					 * Get the cluster for this arc.
					 */
					DotNode sourceNode = arc.getSource();
					DotNode targetNode = arc.getTarget();
					Set<DotNode> sourceNodes = new HashSet<DotNode>();
					sourceNodes.add(sourceNode);
					Set<DotNode> targetNodes = new HashSet<DotNode>();
					targetNodes.add(targetNode);
					boolean changed = true;
					while (changed) {
						changed = false;
						for (DotEdge anotherArc : graph.getEdges()) {
							if (isEqual(arc, anotherArc)) {
								if (sourceNodes.contains(anotherArc.getSource())) {
									changed = changed || targetNodes.add(anotherArc.getTarget());
								}
								if (targetNodes.contains(anotherArc.getTarget())) {
									changed = changed || sourceNodes.add(anotherArc.getSource());
								}
							}
						}
					}

					/*
					 * Get a biggest maximal clique in the cluster.
					 */
					Set<DotEdge> arcs = getMaximalClique(graph, sourceNodes, targetNodes, arc.getOption(""arrowtail""),
							arc.getOption(""arrowhead""), arc.getLabel(), arc, new HashSet<List<Set<DotNode>>>());

					if (arcs != null) {
						/*
						 * A maximal clique was found. Update the sources and
						 * targets to this clique.
						 */
						sourceNodes.clear();
						targetNodes.clear();
						for (DotEdge a : arcs) {
							sourceNodes.add(a.getSource());
							targetNodes.add(a.getTarget());
						}
						//						System.out.println(""[LogSkeleton] "" + sourceNodes + "" -> "" + targetNodes);
						/*
						 * Add a connector node to the graph.
						 */
						DotNode connector = graph.addNode("""");
						connector.setOption(""shape"", ""point"");
						/*
						 * Add arcs from and to the new connector node.
						 */
						for (DotNode node : sourceNodes) {
							DotEdge a = graph.addEdge(node, connector);
							a.setOption(""dir"", ""both"");
							a.setOption(""arrowtail"", arc.getOption(""arrowtail""));
							a.setOption(""arrowhead"", ""none"");
							if (arc.getOption(""taillabel"") != null) {
								a.setOption(""taillabel"", arc.getOption(""taillabel""));
							}
							if (arc.getLabel() != null) {
								String[] labels2 = arc.getLabel().split(""&rarr;"");
								if (labels2.length == 2) {
									System.out.println(""[LogSkeleton] set label1 "" + labels2[0]);
									a.setLabel(labels2[0]);
								} else {
									a.setLabel(arc.getLabel());
								}
							}
							if (arc.getOption(""color"") != null) {
								String[] colors2 = arc.getOption(""color"").split(""[;:]"");
								if (colors2.length == 4) {
									System.out.println(""[LogSkeleton] set color1 "" + colors[0]);
									a.setOption(""color"", colors2[0]);
								} else {
									a.setOption(""color"", arc.getOption(""color""));
								}
							}
							candidateArcs.add(a);
						}
						for (DotNode node : targetNodes) {
							DotEdge a = graph.addEdge(connector, node);
							a.setOption(""dir"", ""both"");
							a.setOption(""arrowtail"", ""none"");
							a.setOption(""arrowhead"", arc.getOption(""arrowhead""));
							if (arc.getOption(""headlabel"") != null) {
								a.setOption(""headlabel"", arc.getOption(""headlabel""));
							}
							if (arc.getLabel() != null) {
								String[] labels2 = arc.getLabel().split(""&rarr;"");
								if (labels2.length == 2) {
									System.out.println(""[LogSkeleton] set label2 "" + labels2[1]);
									a.setLabel(labels2[1]);
								} else {
									a.setLabel(arc.getLabel());
								}
							}
							if (arc.getOption(""color"") != null) {
								String[] colors2 = arc.getOption(""color"").split(""[;:]"");
								if (colors2.length == 4) {
									System.out.println(""[LogSkeleton] set color2 "" + colors[2]);
									a.setOption(""color"", colors2[2]);
								} else {
									a.setOption(""color"", arc.getOption(""color""));
								}
							}
							candidateArcs.add(a);
						}
						/*
						 * Remove the old arcs, they have now been replaced with
						 * the newly added connector node and arcs.
						 */
						for (DotEdge anotherArc : arcs) {
							graph.removeEdge(anotherArc);
						}
						candidateArcs.removeAll(arcs);
						/*
						 * Sort the arcs again, as some have been added.
						 */
						Collections.sort(candidateArcs, new Comparator<DotEdge>() {

							public int compare(DotEdge o1, DotEdge o2) {
								int c = o1.getSource().getLabel().compareTo(o2.getSource().getLabel());
								if (c == 0) {
									c = o1.getTarget().getLabel().compareTo(o2.getTarget().getLabel());
								}
								return c;
							}

						});
					} else {
						/*
						 * No maximal clique was found, leave the arc as-is.
						 */
						candidateArcs.remove(arc);
					}
				} else {
					/*
					 * Not an always-arc, leave the arc as-is.
					 */
					candidateArcs.remove(arc);
				}
			}
		}

		graph.setOption(""labelloc"", ""b"");
		graph.setOption(""nodesep"", ""0.5"");
		//		String label = ""Event Log: "" + (this.label == null ? ""<not specified>"" : this.label) + ""\\l"";
		//		if (!required.isEmpty()) {
		//			label += ""Required Activities Filters: "" + required + ""\\l"";
		//		}
		//		if (!forbidden.isEmpty()) {
		//			label += ""Forbidden Activities Filters: "" + forbidden + ""\\l"";
		//		}
		//		if (!splitters.isEmpty()) {
		//			label += ""Activity Splitters: "" + splitters + ""\\l"";
		//		}
		List<String> selectedActivities = new ArrayList<String>(parameters.getActivities());
		Collections.sort(selectedActivities);
		//		label += ""Show Activities: "" + activities + ""\\l"";
		//		label += ""Show Constraints: "" + parameters.getVisualizers() + ""\\l"";
		String label = ""<table bgcolor=\""gold\"" cellborder=\""0\"" cellpadding=\""0\"" columns=\""3\"" style=\""rounded\"">"";
		label +=

				encodeHeader(""Skeleton Configuration"");
		label += encodeRow(""Event Log"", this.label == null ? ""<not specified>"" : this.label);
		if (!required.isEmpty()) {
			label += encodeRow(""Required Activities Filter"", required.toString());
		}
		if (!forbidden.isEmpty()) {
			label += encodeRow(""Forbidden Activities Filter"", forbidden.toString());
		}
		if (!splitters.isEmpty()) {
			label += encodeRow(""Activity Splitters"", splitters.toString());
		}
		label += encodeRow(""View Activities"", selectedActivities.toString());
		label += encodeRow(""View Constraints"", parameters.getVisualizers().toString());
		if (equivalenceThreshold < 100) {
			label += encodeRow(""Noise Threshold"", """" + (100 - equivalenceThreshold) + ""%"");
		}
		label += ""</table>"";
		graph.setOption(""fontsize"", ""8.0"");
		graph.setOption(""label"", ""<"" + label + "">"");
		//		graph.setOption(""labeljust"", ""l"");
		return graph;
	}

	private String darker(String color) {
		Color darkerColor = Color.decode(color).darker();
		return ""#"" + Integer.toHexString(darkerColor.getRed()) + Integer.toHexString(darkerColor.getGreen())
				+ Integer.toHexString(darkerColor.getBlue());
	}

	private boolean isEqual(DotEdge e1, DotEdge e2) {
		if (!isEqual(e1.getOption(""arrowtail""), e2.getOption(""arrowtail""))) {
			return false;
		}
		if (!isEqual(e1.getOption(""arrowhead""), e2.getOption(""arrowhead""))) {
			return false;
		}
		if (!isEqual(e1.getOption(""headlabel""), e2.getOption(""headlabel""))) {
			return false;
		}
		if (!isEqual(e1.getOption(""taillabel""), e2.getOption(""taillabel""))) {
			return false;
		}
		if (!isEqual(e1.getLabel(), e2.getLabel())) {
			return false;
		}
		return true;
	}

	private boolean isEqual(String s1, String s2) {
		if (s1 == null) {
			return s2 == null;
		}
		return s1.equals(s2);
	}

	private Set<DotEdge> getMaximalClique(Dot graph, Set<DotNode> sourceNodes, Set<DotNode> targetNodes,
			String arrowtail, String arrowhead, String label, DotEdge baseArc, Set<List<Set<DotNode>>> checkedNodes) {
		/*
		 * Make sure a clique is not too small.
		 */
		if (sourceNodes.size() < 2) {
			/*
			 * A single source. Do not look for a maximal clique.
			 */
			return null;
		}
		if (targetNodes.size() < 2) {
			/*
			 * A single target. Do not look for a maximal clique.
			 */
			return null;
		}
		/*
		 * Keep track of which combinations of sources and targets have already
		 * been checked. This prevents checking the same combinations many times
		 * over.
		 */
		List<Set<DotNode>> checked = new ArrayList<Set<DotNode>>();
		checked.add(new HashSet<DotNode>(sourceNodes));
		checked.add(new HashSet<DotNode>(targetNodes));
		checkedNodes.add(checked);
		/*
		 * Collect all matching arcs that go from some source to some target.
		 */
		Set<DotEdge> arcs = new HashSet<DotEdge>();
		for (DotEdge arc : graph.getEdges()) {
			if (isEqual(arc, baseArc)) {
				if (sourceNodes.contains(arc.getSource()) && targetNodes.contains(arc.getTarget())) {
					arcs.add(arc);
				}
			}
		}
		/*
		 * Check whether a maximal clique.
		 */
		if (arcs.size() == sourceNodes.size() * targetNodes.size()) {
			/*
			 * Yes.
			 */
			return arcs;
		}
		/*
		 * No, look for maximal cliques that have one node (source or target)
		 * less.
		 */
		Set<DotEdge> bestArcs = null; // Best solution so far.
		if (sourceNodes.size() > targetNodes.size()) {
			/*
			 * More sources than targets. Removing a source yields a possible
			 * bigger clique than removing a target. So, first try to remove a
			 * source, and only then try to remove a target.
			 */
			if (sourceNodes.size() > 2) {
				/*
				 * Try to find a maximal clique with one source removed. Sort
				 * the source nodes first to get a (more) deterministic result.
				 */
				List<DotNode> sortedSourceNodes = new ArrayList<DotNode>(sourceNodes);
				Collections.sort(sortedSourceNodes, new Comparator<DotNode>() {

					public int compare(DotNode o1, DotNode o2) {
						return o1.getLabel().compareTo(o2.getLabel());
					}

				});
				for (DotNode srcNode : sortedSourceNodes) {
					if (bestArcs == null || (sourceNodes.size() - 1) * targetNodes.size() > bestArcs.size()) {
						/*
						 * May result in a bigger clique than the best found so
						 * far. First, remove the node from the sources.
						 */
						Set<DotNode> nodes = new HashSet<DotNode>(sourceNodes);
						nodes.remove(srcNode);
						/*
						 * Check whether this combination of sources and targets
						 * was checked before.
						 */
						checked = new ArrayList<Set<DotNode>>();
						checked.add(nodes);
						checked.add(targetNodes);
						if (!checkedNodes.contains(checked)) {
							/*
							 * No, it was not. Check now.
							 */
							arcs = getMaximalClique(graph, nodes, targetNodes, arrowtail, arrowhead, label, baseArc,
									checkedNodes);
							if (bestArcs == null || (arcs != null && bestArcs.size() < arcs.size())) {
								/*
								 * Found a bigger maximal clique than the best
								 * found so far. Update.
								 */
								bestArcs = arcs;
							}
						}
					}
				}
			}
			if (targetNodes.size() > 2) {
				List<DotNode> sortedTargetNodes = new ArrayList<DotNode>(targetNodes);
				Collections.sort(sortedTargetNodes, new Comparator<DotNode>() {

					public int compare(DotNode o1, DotNode o2) {
						return o1.getLabel().compareTo(o2.getLabel());
					}

				});
				for (DotNode tgtNode : sortedTargetNodes) {
					if (bestArcs == null || sourceNodes.size() * (targetNodes.size() - 1) > bestArcs.size()) {
						Set<DotNode> nodes = new HashSet<DotNode>(targetNodes);
						nodes.remove(tgtNode);
						checked = new ArrayList<Set<DotNode>>();
						checked.add(sourceNodes);
						checked.add(nodes);
						if (!checkedNodes.contains(checked)) {
							arcs = getMaximalClique(graph, sourceNodes, nodes, arrowtail, arrowhead, label, baseArc,
									checkedNodes);
							if (bestArcs == null || (arcs != null && bestArcs.size() < arcs.size())) {
								bestArcs = arcs;
							}
						}
					}
				}
			}
		} else {
			/*
			 * The other way around.
			 */
			if (targetNodes.size() > 2) {
				List<DotNode> sortedTargetNodes = new ArrayList<DotNode>(targetNodes);
				Collections.sort(sortedTargetNodes, new Comparator<DotNode>() {

					public int compare(DotNode o1, DotNode o2) {
						return o1.getLabel().compareTo(o2.getLabel());
					}

				});
				for (DotNode tgtNode : sortedTargetNodes) {
					if (bestArcs == null || sourceNodes.size() * (targetNodes.size() - 1) > bestArcs.size()) {
						Set<DotNode> nodes = new HashSet<DotNode>(targetNodes);
						nodes.remove(tgtNode);
						checked = new ArrayList<Set<DotNode>>();
						checked.add(sourceNodes);
						checked.add(nodes);
						if (!checkedNodes.contains(checked)) {
							arcs = getMaximalClique(graph, sourceNodes, nodes, arrowtail, arrowhead, label, baseArc,
									checkedNodes);
							if (bestArcs == null || (arcs != null && bestArcs.size() < arcs.size())) {
								bestArcs = arcs;
							}
						}
					}
				}
			}
			if (sourceNodes.size() > 2) {
				List<DotNode> sortedSourceNodes = new ArrayList<DotNode>(sourceNodes);
				Collections.sort(sortedSourceNodes, new Comparator<DotNode>() {

					public int compare(DotNode o1, DotNode o2) {
						return o1.getLabel().compareTo(o2.getLabel());
					}

				});
				for (DotNode srcNode : sortedSourceNodes) {
					if (bestArcs == null || (sourceNodes.size() - 1) * targetNodes.size() > bestArcs.size()) {
						Set<DotNode> nodes = new HashSet<DotNode>(sourceNodes);
						nodes.remove(srcNode);
						checked = new ArrayList<Set<DotNode>>();
						checked.add(nodes);
						checked.add(targetNodes);
						if (!checkedNodes.contains(checked)) {
							arcs = getMaximalClique(graph, nodes, targetNodes, arrowtail, arrowhead, label, baseArc,
									checkedNodes);
							if (bestArcs == null || (arcs != null && bestArcs.size() < arcs.size())) {
								bestArcs = arcs;
							}
						}
					}
				}
			}
		}
		/*
		 * Return the biggest maximal clique found. Equals null if none found.
		 */
		return bestArcs;
	}

	private String encodeHeader(String title) {
		return ""<tr><td colspan=\""3\""><b>"" + encodeHTML(title) + ""</b></td></tr><hr/>"";
	}

	private String encodeRow(String label, String value) {
		return encodeRow(label, value, 0);
	}

	private String encodeRow(String label, String value, int padding) {
		return ""<tr><td align=\""right\""><i>"" + label + ""</i></td><td> : </td><td align=\""left\"">"" + encodeHTML(value)
				+ ""</td></tr>"";
	}

	private String encodeHTML(String s) {
		String s2 = s;
		if (s.length() > 2 && s.startsWith(""["") && s.endsWith(""]"")) {
			s2 = s.substring(1, s.length() - 1);
		}
		return s2.replaceAll(""&"", ""&amp;"").replaceAll(""\\<"", ""&lt;"").replaceAll(""\\>"", ""&gt;"");
	}

	public Dot createGraph(LogSkeletonBrowser visualizer) {
		LogSkeletonBrowserParameters parameters = new LogSkeletonBrowserParameters();
		parameters.getActivities().addAll(countModel.getActivities());
		parameters.getVisualizers().add(visualizer);
		return visualize(parameters);
	}

	public Dot createGraph(Set<LogSkeletonBrowser> visualizers) {
		LogSkeletonBrowserParameters parameters = new LogSkeletonBrowserParameters();
		parameters.getActivities().addAll(countModel.getActivities());
		parameters.getVisualizers().addAll(visualizers);
		return visualize(parameters);
	}

	public Dot createGraph(LogSkeletonBrowserParameters parameters) {
		return visualize(parameters);
	}

	public Collection<String> getActivities() {
		return countModel.getActivities();
	}

	public Set<String> getRequired() {
		return required;
	}

	public void setRequired(Set<String> required) {
		this.required = required;
	}

	public Set<String> getForbidden() {
		return forbidden;
	}

	public void setForbidden(Set<String> forbidden) {
		this.forbidden = forbidden;
	}

	public List<List<String>> getSplitters() {
		return splitters;
	}

	public void setSplitters(List<List<String>> splitters) {
		this.splitters = splitters;
	}

	public String getLabel() {
		return label;
	}

	public void setLabel(String label) {
		this.label = label;
	}

	public void exportToFile(CsvWriter writer) throws IOException {
		writer.write(label);
		writer.endRecord();
		countModel.exportToFile(writer);
		writer.write(""equivalence"");
		for (int noise = 0; noise < 21; noise++) {
			writer.write("""" + sameCountsNoise.get(noise).size());
		}
		for (int noise = 0; noise < 21; noise++) {
			writer.endRecord();
			for (Collection<String> activities : sameCountsNoise.get(noise)) {
				for (String activity : activities) {
					writer.write(activity);
				}
				writer.endRecord();
			}
		}
		writer.write(""precedence"");
		writer.write("""" + precedences.size());
		writer.endRecord();
		for (String activity : precedences.keySet()) {
			writer.write(activity);
			precedences.get(activity).exportToFile(writer);
			writer.endRecord();
		}
		writer.write(""response"");
		writer.write("""" + responses.size());
		writer.endRecord();
		for (String activity : responses.keySet()) {
			writer.write(activity);
			responses.get(activity).exportToFile(writer);
			writer.endRecord();
		}
		writer.write(""not precedence"");
		writer.write("""" + notPrecedences.size());
		writer.endRecord();
		for (String activity : notPrecedences.keySet()) {
			writer.write(activity);
			notPrecedences.get(activity).exportToFile(writer);
			writer.endRecord();
		}
		writer.write(""not response"");
		writer.write("""" + notResponses.size());
		writer.endRecord();
		for (String activity : notResponses.keySet()) {
			writer.write(activity);
			notResponses.get(activity).exportToFile(writer);
			writer.endRecord();
		}
		writer.write(""not co-occurrence"");
		writer.write("""" + notCoExistences.size());
		writer.endRecord();
		for (String activity : notCoExistences.keySet()) {
			writer.write(activity);
			notCoExistences.get(activity).exportToFile(writer);
			writer.endRecord();
		}
		writer.write(""required"");
		writer.write(required.isEmpty() ? ""0"" : ""1"");
		writer.endRecord();
		if (!required.isEmpty()) {
			for (String activity : required) {
				writer.write(activity);
			}
			writer.endRecord();
		}
		writer.write(""forbidden"");
		writer.write(forbidden.isEmpty() ? ""0"" : ""1"");
		writer.endRecord();
		if (!forbidden.isEmpty()) {
			for (String activity : forbidden) {
				writer.write(activity);
			}
			writer.endRecord();
		}
		writer.write(""splitters"");
		writer.write("""" + splitters.size());
		writer.endRecord();
		for (List<String> splitter : splitters) {
			for (String activity : splitter) {
				writer.write(activity);
			}
			writer.endRecord();
		}
		writer.endRecord();
	}

	public void importFromStream(CsvReader reader) throws IOException {
		if (reader.readRecord()) {
			label = reader.get(0);
		}
		sameCountsNoise = new HashMap<Integer, Collection<Collection<String>>>();
		for (int noise = 0; noise < 21; noise++) {
			sameCountsNoise.put(noise, new HashSet<Collection<String>>());
		}
		sameCounts = sameCountsNoise.get(0);
		countModel.importFromStream(reader);
		if (reader.readRecord()) {
			if (reader.get(0).equals(""always together"")) {
				int rows = Integer.valueOf(reader.get(1));
				for (int row = 0; row < rows; row++) {
					if (reader.readRecord()) {
						List<String> orderedActivities = new ArrayList<String>();
						for (int column = 0; column < reader.getColumnCount(); column++) {
							orderedActivities.add(reader.get(column));
						}
						Collections.sort(orderedActivities);
						for (int noise = 0; noise < 21; noise++) {
							sameCountsNoise.get(noise).add(orderedActivities);
						}
					}
				}
			} else if (reader.get(0).equals(""equivalence"")) {
				int rows[] = new int[21];
				for (int noise = 0; noise < 21; noise++) {
					rows[noise] = Integer.valueOf(reader.get(noise + 1));
				}
				for (int noise = 0; noise < 21; noise++) {
					for (int row = 0; row < rows[noise]; row++) {
						if (reader.readRecord()) {
							List<String> orderedActivities = new ArrayList<String>();
							for (int column = 0; column < reader.getColumnCount(); column++) {
								orderedActivities.add(reader.get(column));
							}
							Collections.sort(orderedActivities);
							sameCountsNoise.get(noise).add(orderedActivities);
						}
					}
				}
			}
		}
		precedences = new HashMap<String, ThresholdSet>();
		if (reader.readRecord()) {
			if (reader.get(0).equals(""always before"")) {
				int rows = Integer.valueOf(reader.get(1));
				for (int row = 0; row < rows; row++) {
					if (reader.readRecord()) {
						String activity = reader.get(0);
						Set<String> activities = new HashSet<String>();
						for (int column = 1; column < reader.getColumnCount(); column++) {
							activities.add(reader.get(column));
						}
						precedences.put(activity, new ThresholdSet(countModel.getActivities(), precedenceThreshold));
						precedences.get(activity).addAll(activities);
					}
				}
			} else if (reader.get(0).equals(""precedence"")) {
				int rows = Integer.valueOf(reader.get(1));
				for (int row = 0; row < rows; row++) {
					if (reader.readRecord()) {
						String activity = reader.get(0);
						precedences.put(activity, new ThresholdSet(countModel.getActivities(), precedenceThreshold));
						precedences.get(activity).importFromFile(reader);
					}
				}
			}
		}
		responses = new HashMap<String, ThresholdSet>();
		if (reader.readRecord()) {
			if (reader.get(0).equals(""always after"")) {
				int rows = Integer.valueOf(reader.get(1));
				for (int row = 0; row < rows; row++) {
					if (reader.readRecord()) {
						String activity = reader.get(0);
						Set<String> activities = new HashSet<String>();
						for (int column = 1; column < reader.getColumnCount(); column++) {
							activities.add(reader.get(column));
						}
						responses.put(activity, new ThresholdSet(countModel.getActivities(), responseThreshold));
						responses.get(activity).addAll(activities);
					}
				}
			} else if (reader.get(0).equals(""response"")) {
				int rows = Integer.valueOf(reader.get(1));
				for (int row = 0; row < rows; row++) {
					if (reader.readRecord()) {
						String activity = reader.get(0);
						responses.put(activity, new ThresholdSet(countModel.getActivities(), responseThreshold));
						responses.get(activity).importFromFile(reader);
					}
				}
			}
		}
		notPrecedences = new HashMap<String, ThresholdSet>();
		if (reader.readRecord()) {
			if (reader.get(0).equals(""not precedence"")) {
				int rows = Integer.valueOf(reader.get(1));
				for (int row = 0; row < rows; row++) {
					if (reader.readRecord()) {
						String activity = reader.get(0);
						notPrecedences.put(activity, new ThresholdSet(countModel.getActivities(), precedenceThreshold));
						notPrecedences.get(activity).importFromFile(reader);
					}
				}
			}
		}
		notResponses = new HashMap<String, ThresholdSet>();
		if (reader.readRecord()) {
			if (reader.get(0).equals(""not response"")) {
				int rows = Integer.valueOf(reader.get(1));
				for (int row = 0; row < rows; row++) {
					if (reader.readRecord()) {
						String activity = reader.get(0);
						notResponses.put(activity, new ThresholdSet(countModel.getActivities(), responseThreshold));
						notResponses.get(activity).importFromFile(reader);
					}
				}
			}
		}
		if (reader.readRecord()) {
			if (reader.get(0).equals(""sometimes before"")) {
				Map<String, Set<String>> anyPresets = new HashMap<String, Set<String>>();
				Map<String, Set<String>> anyPostsets = new HashMap<String, Set<String>>();
				int rows = Integer.valueOf(reader.get(1));
				for (int row = 0; row < rows; row++) {
					if (reader.readRecord()) {
						String activity = reader.get(0);
						Set<String> activities = new HashSet<String>();
						for (int column = 1; column < reader.getColumnCount(); column++) {
							activities.add(reader.get(column));
						}
						anyPresets.put(activity, activities);
					}
				}
				if (reader.readRecord()) {
					if (reader.get(0).equals(""sometimes after"")) {
						rows = Integer.valueOf(reader.get(1));
						for (int row = 0; row < rows; row++) {
							if (reader.readRecord()) {
								String activity = reader.get(0);
								Set<String> activities = new HashSet<String>();
								for (int column = 1; column < reader.getColumnCount(); column++) {
									activities.add(reader.get(column));
								}
								anyPostsets.put(activity, activities);
							}
						}
					}
				}
				notCoExistences = new HashMap<String, ThresholdSet>();
				for (String activity : countModel.getActivities()) {
					Set<String> prepostset = new HashSet<String>();
					if (anyPresets.containsKey(activity)) {
						prepostset.addAll(anyPresets.get(activity));
					}
					if (anyPostsets.containsKey(activity)) {
						prepostset.addAll(anyPostsets.get(activity));
					}
					notCoExistences.put(activity,
							new ThresholdSet(countModel.getActivities(), notCoExistenceeThreshold));
					notCoExistences.get(activity).addAll(countModel.getActivities());
					notCoExistences.get(activity).removeAll(prepostset);
				}
			} else if (reader.get(0).equals(""not co-occurrence"")) {
				int rows = Integer.valueOf(reader.get(1));
				for (int row = 0; row < rows; row++) {
					if (reader.readRecord()) {
						String activity = reader.get(0);
						notCoExistences.put(activity,
								new ThresholdSet(countModel.getActivities(), notCoExistenceeThreshold));
						notCoExistences.get(activity).importFromFile(reader);
					}
				}
			}
		}
		required = new HashSet<String>();
		if (reader.readRecord()) {
			if (reader.get(0).equals(""required"")) {
				int rows = Integer.valueOf(reader.get(1));
				for (int row = 0; row < rows; row++) {
					if (reader.readRecord()) {
						for (int column = 0; column < reader.getColumnCount(); column++) {
							required.add(reader.get(column));
						}
					}
				}
			}
		}
		forbidden = new HashSet<String>();
		if (reader.readRecord()) {
			if (reader.get(0).equals(""forbidden"")) {
				int rows = Integer.valueOf(reader.get(1));
				for (int row = 0; row < rows; row++) {
					if (reader.readRecord()) {
						for (int column = 0; column < reader.getColumnCount(); column++) {
							forbidden.add(reader.get(column));
						}
					}
				}
			}
		}
		splitters = new ArrayList<List<String>>();
		if (reader.readRecord()) {
			if (reader.get(0).equals(""splitters"")) {
				int rows = Integer.valueOf(reader.get(1));
				for (int row = 0; row < rows; row++) {
					if (reader.readRecord()) {
						List<String> splitter = new ArrayList<String>();
						for (int column = 0; column < reader.getColumnCount(); column++) {
							splitter.add(reader.get(column));
						}
						splitters.add(splitter);
					}
				}
			}
		}
	}

	public Set<String> getAlwaysBefore(String activity) {
		if (precedences.containsKey(activity)) {
			return new HashSet<String>(precedences.get(activity));
		}
		return new HashSet<String>();
	}

	public Set<String> getAlwaysAfter(String activity) {
		if (responses.containsKey(activity)) {
			return new HashSet<String>(responses.get(activity));
		}
		return new HashSet<String>();
	}

	public void setPrecedenceThreshold(int precedenceThreshold) {
		this.precedenceThreshold = precedenceThreshold;
		for (String activity : precedences.keySet()) {
			precedences.get(activity).setThreshold(precedenceThreshold);
		}
		for (String activity : notPrecedences.keySet()) {
			notPrecedences.get(activity).setThreshold(precedenceThreshold);
		}
	}

	public int getResponseThreshold() {
		return responseThreshold;
	}

	public void setResponseThreshold(int responseThreshold) {
		this.responseThreshold = responseThreshold;
		for (String activity : responses.keySet()) {
			responses.get(activity).setThreshold(responseThreshold);
		}
		for (String activity : notResponses.keySet()) {
			notResponses.get(activity).setThreshold(responseThreshold);
		}
	}

	public int getNotCoExistenceThreshold() {
		return notCoExistenceeThreshold;
	}

	public void setNotCoExistenceThreshold(int notCoOccurencethreshold) {
		this.notCoExistenceeThreshold = notCoOccurencethreshold;
		for (String activity : notCoExistences.keySet()) {
			notCoExistences.get(activity).setThreshold(notCoOccurencethreshold);
		}
	}

	public boolean hasManyNotCoExistenceArcs(LogSkeletonBrowserParameters parameters) {
		int nr = 0;
		for (String fromActivity : countModel.getActivities()) {
			for (String toActivity : countModel.getActivities()) {
				if (!fromActivity.equals(toActivity)) {
					if (fromActivity.compareTo(toActivity) >= 0
							&& (!parameters.isUseEquivalenceClass()
									|| fromActivity.equals(getSameCounts(fromActivity).iterator().next()))
							&& (!parameters.isUseEquivalenceClass()
									|| toActivity.equals(getSameCounts(toActivity).iterator().next()))
							&& notCoExistences.get(fromActivity).contains(toActivity)) {
						nr++;
					}
				}
			}
		}
		/*
		 * Return whether there are too many Not Co-Existence constraints to
		 * show by default. THe first visualization should be reasonably fast.
		 * In case of too many Not Co-Existence constraints, this first
		 * visualization takes ages.
		 */
		return nr > 100;
	}

	public int getEquivalenceThreshold() {
		return equivalenceThreshold;
	}

	public void setEquivalenceThreshold(int equivalenceThreshold) {
		this.equivalenceThreshold = equivalenceThreshold;
		sameCounts = sameCountsNoise.get(100 - equivalenceThreshold);
	}
}
"
LogSkeletonCount.java,log-skeleton,"package org.processmining.logskeleton.models;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import com.csvreader.CsvReader;
import com.csvreader.CsvWriter;

public class LogSkeletonCount {

	/*
	 * The names to use for the start and end events.
	 */
	public final static String STARTEVENT = ""|>"";
	public final static String ENDEVENT = ""[]"";

	/*
	 * Counts how many times an activity occurred in the entire log. 
	 * If activityCounts.get(a) == 4, then activity a occurred 4 times in the log.
	 */
	private Map<String, Integer> activityCounts;
	
	/*
	 * Counts the minimal number of times an activity occurs in any trace. 
	 * If activityMinCounts.get(a) == 1, then a occurs at least once in every trace in the log.
	 */
	private Map<String, Integer> activityMinCounts;
	
	/*
	 * Counts the maximal number of times an activity occurs in any trace. 
	 * If activityMinCounts.get(a) == 2, then a occurs at most twice in every trace in the log.
	 */
	private Map<String, Integer> activityMaxCounts;
	
	/*
	 * The directly follows relation. If ab is a list containing first a and then b, and if transitionCounts.get(ab) == 5, 
	 * then a was 5 times directly followed by b in the log. Note that the lists (like ab) have always length 2. 
	 */
	private Map<List<String>, Integer> transitionCounts;

	public LogSkeletonCount() {
		activityCounts = new HashMap<String, Integer>();
		activityMinCounts = new HashMap<String, Integer>();
		activityMaxCounts = new HashMap<String, Integer>();
		transitionCounts = new HashMap<List<String>, Integer>();
	}

	public boolean checkTransitionCounts(LogSkeletonCount model, Set<String> messages, String caseId) {
		for (List<String> transition : model.transitionCounts.keySet()) {
			if (!transitionCounts.keySet().contains(transition)) {
				messages.add(""[LogSkeletonCount] Case "" + caseId + "": Next fails for "" + transition);
				return false;
			}
			if (transitionCounts.get(transition) < model.transitionCounts.get(transition)) {
				messages.add(""[LogSkeletonCount] Case "" + caseId + "": Next fails for "" + transition);
				return false;
			}
		}
		return true;
	}

	public Integer get(String activity) {
		return activityCounts.containsKey(activity) ? activityCounts.get(activity) : 0;
	}

	public Integer getMin(String activity) {
		return activityMinCounts.containsKey(activity) ? activityMinCounts.get(activity) : 0;
	}

	public Integer getMax(String activity) {
		return activityMaxCounts.containsKey(activity) ? activityMaxCounts.get(activity) : 0;
	}

	public Integer get(String fromActivity, String toActivity) {
		List<String> transition = getTransition(fromActivity, toActivity);
		return transitionCounts.containsKey(transition) ? transitionCounts.get(transition) : 0;
	}

	public Collection<String> getTo(String fromActivity) {
		Collection<String> toActivities = new HashSet<String>();
		for (List<String> transition : transitionCounts.keySet()) {
			if (transition.get(0).equals(fromActivity)) {
				toActivities.add(transition.get(1));
			}
		}
		return toActivities;
	}

	public Collection<String> getFrom(String toActivity) {
		Collection<String> fromActivities = new HashSet<String>();
		for (List<String> transition : transitionCounts.keySet()) {
			if (transition.get(1).equals(toActivity)) {
				fromActivities.add(transition.get(0));
			}
		}
		return fromActivities;
	}

	public void add(String activity, Integer number) {
		if (activityCounts.containsKey(activity)) {
			activityCounts.put(activity, activityCounts.get(activity) + number);
		} else {
			activityCounts.put(activity, number);
		}
	}

	public void add(String fromActivity, String toActivity, Integer number) {
		List<String> transition = getTransition(fromActivity, toActivity);
		if (transitionCounts.containsKey(transition)) {
			transitionCounts.put(transition, transitionCounts.get(transition) + number);
		} else {
			transitionCounts.put(transition, number);
		}
	}

	private Map<String, Integer> traceActivities = new HashMap<String, Integer>();

	private void updateMinMax() {
		if (!activityMinCounts.isEmpty()) {
			for (String activity : traceActivities.keySet()) {
				if (!activityMinCounts.containsKey(activity)) {
					activityMinCounts.put(activity, 0);
				}
			}
			for (String activity : activityMinCounts.keySet()) {
				if (!traceActivities.containsKey(activity)) {
					activityMinCounts.put(activity, 0);
				}
			}
		}
		for (String activity : traceActivities.keySet()) {
			if (activityMinCounts.containsKey(activity)) {
				activityMinCounts.put(activity,
						Math.min(activityMinCounts.get(activity), traceActivities.get(activity)));
			} else {
				activityMinCounts.put(activity, traceActivities.get(activity));
			}
			if (activityMaxCounts.containsKey(activity)) {
				activityMaxCounts.put(activity,
						Math.max(activityMaxCounts.get(activity), traceActivities.get(activity)));
			} else {
				activityMaxCounts.put(activity, traceActivities.get(activity));

			}
		}
		traceActivities.clear();
	}

	public void inc(String activity) {
		add(activity, 1);
		if (traceActivities.containsKey(activity)) {
			traceActivities.put(activity, traceActivities.get(activity) + 1);
		} else {
			traceActivities.put(activity, 1);
		}
		if (activity.equals(ENDEVENT)) {
			updateMinMax();
		}
	}

	public void inc(String fromActivity, String toActivity) {
		add(fromActivity, toActivity, 1);
	}

	public Collection<String> getActivities() {
		List<String> ordered = new ArrayList<String>(activityCounts.keySet());
		Collections.sort(ordered);
		return ordered;
	}

	private List<String> getTransition(String fromActivity, String toActivity) {
		List<String> transition = new ArrayList<String>(2);
		transition.add(0, fromActivity);
		transition.add(1, toActivity);
		return transition;
	}

	public void print(String name) {
		//		System.out.println(""[PDC2017CountModel] Activity counts for "" + name);
		for (String activity : activityCounts.keySet()) {
			//			System.out.println(""[LogSkeletonCount] "" + activity + "": "" + activityCounts.get(activity));
		}
		//		System.out.println(""[PC2017CountModel] Transitions counts for "" + name);
		for (List<String> transition : transitionCounts.keySet()) {
			//			System.out.println(""[LogSkeletonCount] "" + transition + "": "" + transitionCounts.get(transition));
		}
	}

	public void exportToFile(CsvWriter writer) throws IOException {
		writer.write(""activity counts"");
		writer.write("""" + activityCounts.keySet().size());
		writer.endRecord();
		for (String activity : activityCounts.keySet()) {
			writer.write(activity);
			writer.write("""" + activityCounts.get(activity));
			writer.write("""" + activityMinCounts.get(activity));
			writer.write("""" + activityMaxCounts.get(activity));
			writer.endRecord();
		}
		writer.write(""transition counts"");
		writer.write("""" + transitionCounts.keySet().size());
		writer.endRecord();
		for (List<String> transitionList : transitionCounts.keySet()) {
			for (String transition : transitionList) {
				writer.write(transition);
			}
			writer.write("""" + transitionCounts.get(transitionList));
			writer.endRecord();
		}
	}

	public void importFromStream(CsvReader reader) throws IOException {
		activityCounts = new HashMap<String, Integer>();
		if (reader.readRecord()) {
			if (reader.get(0).equals(""activity counts"")) {
				int rows = Integer.valueOf(reader.get(1));
				for (int row = 0; row < rows; row++) {
					if (reader.readRecord()) {
						activityCounts.put(reader.get(0), Integer.valueOf(reader.get(1)));
						activityMinCounts.put(reader.get(0), Integer.valueOf(reader.get(2)));
						activityMaxCounts.put(reader.get(0), Integer.valueOf(reader.get(3)));
					}
				}
			}
		}
		transitionCounts = new HashMap<List<String>, Integer>();
		if (reader.readRecord()) {
			if (reader.get(0).equals(""transition counts"")) {
				int rows = Integer.valueOf(reader.get(1));
				for (int row = 0; row < rows; row++) {
					if (reader.readRecord()) {
						List<String> transitions = new ArrayList<String>();
						for (int column = 0; column < reader.getColumnCount() - 1; column++) {
							transitions.add(reader.get(column));
						}
						transitionCounts.put(transitions, Integer.valueOf(reader.get(reader.getColumnCount() - 1)));
					}
				}
			}
		}
	}
}
"
ThresholdSet.java,log-skeleton,"package org.processmining.logskeleton.models;

import java.io.IOException;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;

import com.csvreader.CsvReader;
import com.csvreader.CsvWriter;

public class ThresholdSet implements Set<String> {

	private Map<String, Integer> countMap;
	private Map<String, Integer> totalMap;
	private int threshold;
	
	public ThresholdSet(Collection<String> set, int threshold) {
		countMap = new HashMap<String, Integer>();
		totalMap = new HashMap<String, Integer>();
		for (String activity : set) {
			countMap.put(activity, 0);
			totalMap.put(activity, 0);
		}
		this.threshold = threshold; 
	}

	public int size() {
		int size = 0;
		for (String activity : countMap.keySet()) {
			if (contains(activity)) {
				size++;
			}
		}
		return size;
	}
	
	public boolean isEmpty() {
		return size() == 0;
	}
	
	public boolean contains(Object o) {
		return (countMap.get(o) * 100 >= totalMap.get(o) * threshold);
	}

	public Iterator<String> iterator() {
		Set<String> set = new HashSet<String>();
		for (String activity : countMap.keySet()) {
			if (contains(activity)) {
				set.add(activity);
			}
		}
		return set.iterator();
	}
	
	public Object[] toArray() {
		// Not supported
		return null;
	}
	
	public <String> String[] toArray(String[] a) {
		// Not supported
		return null;
	}
	
	public boolean add(String e) {
		// Not supported
		return false;
	}
	
	public boolean remove(Object o) {
		// Not supported
		return false;
	}
	
	public boolean containsAll(Collection<?> c) {
		Set<String> set = new HashSet<String>();
		for (String activity : countMap.keySet()) {
			if (contains(activity)) {
				set.add(activity);
			}
		}
		return set.containsAll(c);
	}
	
	public boolean addAll(Collection<? extends String> c) {
		return retainAll(c);
	}
	
	public boolean retainAll(Collection<?> c) {
		for (String activity : countMap.keySet()) {
			if (c.contains(activity)) {
				countMap.put(activity, countMap.get(activity) + 1);
			}
			totalMap.put(activity, totalMap.get(activity) + 1);
		}
		return true;
	}
	
	public boolean removeAll(Collection<?> c) {
		for (String activity : countMap.keySet()) {
			if (c.contains(activity)) {
				countMap.put(activity, -Math.abs(countMap.get(activity))); 
			}
		}
		return true;
	}
	
	public void clear() {
		// Not supported		
	}

	public void reset() {
		for (String activity : countMap.keySet()) {
			countMap.put(activity, Math.abs(countMap.get(activity)));
		}
	}
	
	public void setThreshold(int threshold) {
		this.threshold = threshold;
	}
	
	public int getThreshold() {
		return threshold;
	}
	
	public int getMaxThreshold(Object o) {
		return countMap.get(o) * 100 / totalMap.get(o);
	}
	
	public void exportToFile(CsvWriter writer) throws IOException {
		writer.write("""" + threshold);
		for (String activity : countMap.keySet()) {
			writer.write("""" + activity);
			writer.write("""" + countMap.get(activity));
			writer.write("""" + totalMap.get(activity));
		}
	}
	
	public void importFromFile(CsvReader reader) throws IOException {
		threshold = Integer.valueOf(reader.get(1));
		for (int column = 2; column + 2 < reader.getColumnCount(); column += 3) {
			String activity = reader.get(column);
			int count = Integer.valueOf(reader.get(column + 1));
			int total = Integer.valueOf(reader.get(column + 2));
			countMap.put(activity, count);
			totalMap.put(activity, total);
		}
	}
}
"
LogSkeletonBrowser.java,log-skeleton,"package org.processmining.logskeleton.parameters;

public enum LogSkeletonBrowser {
	
//	ALWAYSTOGETHER(""Always Together""),
	ALWAYSAFTER(""Response""),
	ALWAYSBEFORE(""Precedence""),
	NEVERAFTER(""Not Response""),
	NEVERBEFORE(""Not Precedence""),
	NEVERTOGETHER(""Not Co-Existence"");
//	OFTENNEXT(""Often Next""),
//	OFTENPREVIOUS(""Often Previous""),
//	NEVERTOGETHERSELF(""Never Together (Self)""),
//	SOMETIMESBEFORE(""Sometimes Before""),
//	SOMETIMESAFTER(""Sometimes After""),
//	NEXTONEWAY(""Next (One Way)""),
//	NEXTBOTHWAYS(""Next (Both Ways)"");
	
	private String label;

	private LogSkeletonBrowser(String label) {
		this.label = label;
	}
	
	public String toString() {
		return label;
	}
}
"
LogSkeletonBrowserParameters.java,log-skeleton,"package org.processmining.logskeleton.parameters;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

public class LogSkeletonBrowserParameters {

	private Set<String> activities;
	private List<LogSkeletonBrowser> visualizers;
	private boolean useHyperArcs;
	private boolean useFalseConstraints;
	private boolean useEdgeColors;
	private boolean useEquivalenceClass;
	private boolean useNeighbors;
	private boolean useHeadTailLabels;
	private int precedenceThreshold;
	private int responseThreshold;
	private int notCoExistenceThreshold;

	public LogSkeletonBrowserParameters() {
		activities = new HashSet<String>();
		visualizers = new ArrayList<LogSkeletonBrowser>();
		/* 
		 * By default, do not use hyper arcs as finding the hyper arcs may take considerable time. 
		 */
		setUseHyperArcs(false);
		setUseFalseConstraints(true);
		setUseEdgeColors(true);
		setUseEquivalenceClass(true);
		setUseNeighbors(true);
		setUseHeadTailLabels(true);
		setPrecedenceThreshold(100);
		setResponseThreshold(100);
		setNotCoExistenceThreshold(100);
	}
	
	public Set<String> getActivities() {
		return activities;
	}

	public List<LogSkeletonBrowser> getVisualizers() {
		return visualizers;
	}

	public boolean isUseHyperArcs() {
		return useHyperArcs;
	}

	public void setUseHyperArcs(boolean useHyperArcs) {
		this.useHyperArcs = useHyperArcs;
	}

	public boolean isUseFalseConstraints() {
		return useFalseConstraints;
	}

	public void setUseFalseConstraints(boolean useFalseConstraints) {
		this.useFalseConstraints = useFalseConstraints;
	}

	public boolean isUseNeighbors() {
		return useNeighbors;
	}

	public void setUseNeighbors(boolean useNeighbors) {
		this.useNeighbors = useNeighbors;
	}

	public boolean isUseEdgeColors() {
		return useEdgeColors;
	}

	public void setUseEdgeColors(boolean useEdgeColors) {
		this.useEdgeColors = useEdgeColors;
	}

	public boolean isUseEquivalenceClass() {
		return useEquivalenceClass;
	}

	public void setUseEquivalenceClass(boolean useEquivalenceClass) {
		this.useEquivalenceClass = useEquivalenceClass;
	}

	public int getPrecedenceThreshold() {
		return precedenceThreshold;
	}

	public void setPrecedenceThreshold(int threshold) {
		this.precedenceThreshold = threshold;
	}

	public int getResponseThreshold() {
		return responseThreshold;
	}

	public void setResponseThreshold(int threshold) {
		this.responseThreshold = threshold;
	}

	public int getNotCoExistenceThreshold() {
		return notCoExistenceThreshold;
	}

	public void setNotCoExistenceThreshold(int threshold) {
		this.notCoExistenceThreshold = threshold;
	}

	public boolean isUseHeadTailLabels() {
		return useHeadTailLabels;
	}

	public void setUseHeadTailLabels(boolean useHeadTailLabels) {
		this.useHeadTailLabels = useHeadTailLabels;
	}
}
"
SplitterParameters.java,log-skeleton,"package org.processmining.logskeleton.parameters;

import java.util.HashSet;
import java.util.Set;

public class SplitterParameters {

	private Set<String> milestoneActivities;
	private String recurrentActivity;
	
	public SplitterParameters() {
		milestoneActivities = new HashSet<String>();
	}
	public Set<String> getMilestoneActivities() {
		return milestoneActivities;
	}
	
	public String getDuplicateActivity() {
		return recurrentActivity;
	}
	
	public void setDuplicateActivity(String duplicateActivity) {
		this.recurrentActivity = duplicateActivity;
	}
}
"
PDC2016TestDialog.java,log-skeleton,"package org.processmining.logskeleton.pdc2016.dialogs;

import info.clearthought.layout.TableLayout;
import info.clearthought.layout.TableLayoutConstants;

import java.awt.Dimension;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashSet;
import java.util.List;

import javax.swing.DefaultListModel;
import javax.swing.JComponent;
import javax.swing.ListSelectionModel;
import javax.swing.event.ListSelectionEvent;
import javax.swing.event.ListSelectionListener;

import org.processmining.framework.util.ui.widgets.ProMList;
import org.processmining.logskeleton.pdc2016.parameters.PDC2016TestParameters;
import org.processmining.pdc2016.algorithms.PDC2016Set;

public class PDC2016TestDialog extends JComponent {

	/**
	 * 
	 */
	private static final long serialVersionUID = -4347149448035402690L;
	
	public PDC2016TestDialog(final PDC2016TestParameters parameters) {
		double size[][] = { { TableLayoutConstants.FILL, TableLayoutConstants.FILL },
				{ TableLayoutConstants.FILL } };
		setLayout(new TableLayout(size));
		setOpaque(false);

		DefaultListModel<PDC2016Set> setListModel = new DefaultListModel<PDC2016Set>();
		int[] selectedIndices = new int[parameters.getSets().size()];
		int i = 0;
		int j = 0;
		List<PDC2016Set> sortedSets = new ArrayList<PDC2016Set>();
		sortedSets.addAll(parameters.getAllSets());
		Collections.sort(sortedSets, new Comparator<PDC2016Set>() {
			public int compare(PDC2016Set set1, PDC2016Set set2) {
				return set1.toString().compareTo(set2.toString());
			}
		});
		for (PDC2016Set set : sortedSets) {
			setListModel.addElement(set);
			if (parameters.getSets().contains(set)) {
				selectedIndices[j++] = i;
			}
			i++;
		}
		final ProMList<PDC2016Set> setList = new ProMList<PDC2016Set>(""Select log set(s)"", setListModel);
		setList.setSelectionMode(ListSelectionModel.MULTIPLE_INTERVAL_SELECTION);
		setList.setSelectedIndices(selectedIndices);
		setList.addListSelectionListener(new ListSelectionListener() {
			public void valueChanged(ListSelectionEvent e) {
				List<PDC2016Set> selectedSets = setList.getSelectedValuesList();
				parameters.setSets(new HashSet<PDC2016Set>(selectedSets));
			}
		});
		setList.setPreferredSize(new Dimension(100, 100));
		add(setList, ""0, 0"");

		DefaultListModel<Integer> nrListModel = new DefaultListModel<Integer>();
		selectedIndices = new int[parameters.getAllNrs().size()];
		i = 0;
		j = 0;
		for (int nr : parameters.getAllNrs()) {
			nrListModel.addElement(nr);
			if (parameters.getNrs().contains(nr)) {
				selectedIndices[j++] = i;
			}
			i++;
		}
		final ProMList<Integer> nrList = new ProMList<Integer>(""Select log number(s)"", nrListModel);
		nrList.setSelectionMode(ListSelectionModel.MULTIPLE_INTERVAL_SELECTION);
		nrList.setSelectedIndices(selectedIndices);
		nrList.addListSelectionListener(new ListSelectionListener() {
			public void valueChanged(ListSelectionEvent e) {
				List<Integer> selectedNrs = nrList.getSelectedValuesList();
				parameters.setNrs(new HashSet<Integer>(selectedNrs));
			}
		});
		nrList.setPreferredSize(new Dimension(100, 100));
		add(nrList, ""1, 0"");
		
	}
}
"
PDC2016TestModel.java,log-skeleton,"package org.processmining.logskeleton.pdc2016.models;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.processmining.framework.util.HTMLToString;
import org.processmining.logskeleton.pdc2016.parameters.PDC2016TestParameters;
import org.processmining.pdc2016.algorithms.PDC2016Set;

public class PDC2016TestModel implements HTMLToString {

	private List<Integer> numbers;
	private List<XLog> cal1Logs;
	private List<XLog> cal2Logs;
	private List<XLog> testLogs;
	private PDC2016TestParameters parameters;

	public PDC2016TestModel(PDC2016TestParameters parameters) {
		numbers = new ArrayList<Integer>();
		cal1Logs = new ArrayList<XLog>();
		cal2Logs = new ArrayList<XLog>();
		testLogs = new ArrayList<XLog>();
		this.parameters = parameters;
	}

	public void add(int i, XLog cal1Log, XLog cal2Log, XLog testLog) {
		numbers.add(i);
		if (cal1Log != null) {
			cal1Logs.add(cal1Log);
		}
		if (cal2Log != null) {
			cal2Logs.add(cal2Log);
		}
		if (testLog != null) {
			testLogs.add(testLog);
		}
	}

	public String toHTMLString(boolean includeHTMLTags) {
		StringBuffer buf = new StringBuffer();
		if (includeHTMLTags) {
			buf.append(""<html>"");
		}
		List<XLog> logs;
		for (int l = 0; l < 3; l++) {
			if (l == 0 && cal1Logs.isEmpty()) {
				continue;
			}
			if (l == 1 && cal2Logs.isEmpty()) {
				continue;
			}
			if (l == 2 && testLogs.isEmpty()) {
				continue;
			}
			if (l == 0) {
				buf.append(""<h1>""+ PDC2016Set.CAL1 + ""?</h1>"");
				logs = cal1Logs;
			} else if (l == 1) {
				buf.append(""<h1>""+ PDC2016Set.CAL2 + ""?</h1>"");
				logs = cal2Logs;
			} else {
				buf.append(""<h1>""+ PDC2016Set.TEST + ""?</h1>"");
				logs = testLogs;
			}
			buf.append(""<table><tr><th></th>"");
			for (int n = 1; n < 21; n++) {
				buf.append(""<th>trace_"" + n + ""</th>"");
			}
			buf.append(""<th>#True</th>"");
			buf.append(""</tr>"");
			for (int i = 0; i < numbers.size(); i++) {
				Set<String> acceptedTraces = new HashSet<String>();
				for (XTrace trace : logs.get(i)) {
					acceptedTraces.add(XConceptExtension.instance().extractName(trace));
				}
				buf.append(""<tr><td>model_"" + numbers.get(i) + ""</td>"");
				for (int n = 1; n < 21; n++) {
					buf.append(""<td>"" + (acceptedTraces.contains("""" + n) ? ""TRUE"" : ""FALSE"") + ""</td>"");
				}
				buf.append(""<td>"" + logs.get(i).size() + ""</td>"");
				buf.append(""</tr>"");
			}
			buf.append(""</table>"");
		}
		if (includeHTMLTags) {
			buf.append(""</html>"");
		}
		return buf.toString();
	}

}
"
PDC2016TestParameters.java,log-skeleton,"package org.processmining.logskeleton.pdc2016.parameters;

import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;

import org.processmining.pdc2016.algorithms.PDC2016Set;

public class PDC2016TestParameters {

	private Set<PDC2016Set> sets;
	private Set<PDC2016Set> allSets;
	private Set<Integer> nrs;
	private Set<Integer> allNrs;

	public PDC2016TestParameters() {

		sets = new HashSet<PDC2016Set>();
		allSets = new HashSet<PDC2016Set>();
		sets.addAll(Arrays.asList(PDC2016Set.values()));
		allSets.addAll(Arrays.asList(PDC2016Set.values()));
		sets.remove(PDC2016Set.TRAIN);
		allSets.remove(PDC2016Set.TRAIN);
		
		nrs = new HashSet<Integer>();
		allNrs = new HashSet<Integer>();
		for(int i = 1; i < 11; i++) {
			nrs.add(i);
			allNrs.add(i);
		}

	}

	public Set<PDC2016Set> getSets() {
		return sets;
	}

	public void setSets(Set<PDC2016Set> sets) {
		this.sets = sets;
	}

	public Set<PDC2016Set> getAllSets() {
		return allSets;
	}

	public void setAllSets(Set<PDC2016Set> allSets) {
		this.allSets = allSets;
	}

	public Set<Integer> getNrs() {
		return nrs;
	}

	public void setNrs(Set<Integer> nrs) {
		this.nrs = nrs;
	}

	public Set<Integer> getAllNrs() {
		return allNrs;
	}

	public void setAllNrs(Set<Integer> allNrs) {
		this.allNrs = allNrs;
	}
}
"
PDC2016TestPlugin.java,log-skeleton,"package org.processmining.logskeleton.pdc2016.plugins;

import org.deckfour.uitopia.api.event.TaskListener.InteractionResult;
import org.deckfour.xes.classification.XEventClassifier;
import org.deckfour.xes.classification.XEventNameClassifier;
import org.deckfour.xes.model.XLog;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.logskeleton.algorithms.LogPreprocessorAlgorithm;
import org.processmining.logskeleton.algorithms.LogSkeletonClassifierAlgorithm;
import org.processmining.logskeleton.classifiers.LogSkeletonClassifier;
import org.processmining.logskeleton.pdc2016.dialogs.PDC2016TestDialog;
import org.processmining.logskeleton.pdc2016.models.PDC2016TestModel;
import org.processmining.logskeleton.pdc2016.parameters.PDC2016TestParameters;
import org.processmining.pdc2016.algorithms.PDC2016LogAlgorithm;
import org.processmining.pdc2016.algorithms.PDC2016Set;
import org.processmining.pdc2016.parameters.PDC2016Parameters;

@Plugin(name = ""PDC 2016 Test"", parameterLabels = {}, returnLabels = { ""Results"" }, returnTypes = { PDC2016TestModel.class })
public class PDC2016TestPlugin {

	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""H.M.W. Verbeek"", email = ""h.m.w.verbeek@tue.nl"")
	@PluginVariant(variantLabel = ""Default"", requiredParameterLabels = {})
	public static PDC2016TestModel run(final UIPluginContext context) {
		PDC2016TestParameters testParameters = new PDC2016TestParameters();
		PDC2016TestDialog testDialog = new PDC2016TestDialog(testParameters);
		InteractionResult result = context.showWizard(""Select test parameters"", true, true, testDialog);
		if (result != InteractionResult.FINISHED) {
			context.getFutureResult(0).cancel(true);
			return null;
		}
		PDC2016TestModel testModel = new PDC2016TestModel(testParameters);
		PDC2016Parameters parameters = new PDC2016Parameters();
		PDC2016LogAlgorithm logAlgorithm = new PDC2016LogAlgorithm();
		
		XEventClassifier classifier = new LogSkeletonClassifier(new XEventNameClassifier());

		try {
			for (int i : testParameters.getNrs()) {
				parameters.setNr(i);
				parameters.setSet(PDC2016Set.TRAIN);
				XLog trainingLog = logAlgorithm.apply(context, parameters);
				parameters.setSet(PDC2016Set.CAL1);
				XLog testLogMay = testParameters.getSets().contains(PDC2016Set.CAL1) ? logAlgorithm.apply(context, parameters) : null;
				parameters.setSet(PDC2016Set.CAL2);
				XLog testLogJune = testParameters.getSets().contains(PDC2016Set.CAL2) ? logAlgorithm.apply(context, parameters) : null;
				parameters.setSet(PDC2016Set.TEST);
				XLog testLogFinal = testParameters.getSets().contains(PDC2016Set.TEST) ? logAlgorithm.apply(context, parameters) : null;

				LogSkeletonClassifierAlgorithm classifierAlgorithm = new LogSkeletonClassifierAlgorithm();

				XLog classifiedTestLogCal1 = null;
				XLog classifiedTestLogCal2 = null;
				XLog classifiedTestLogTest = null;

				// Classify the logs
				if (testParameters.getSets().contains(PDC2016Set.CAL1)) {
					System.out.println(""[PDC2016TestPlugin] Classify PDC2016 "" + PDC2016Set.CAL1 + "" number "" + i);
					classifiedTestLogCal1 = classifierAlgorithm.apply(context, trainingLog, testLogMay, classifier, 
							new LogPreprocessorAlgorithm());
					context.getProvidedObjectManager().createProvidedObject(""PDC2016 "" + PDC2016Set.CAL1 + "" number "" + i,
							classifiedTestLogCal1, XLog.class, context);
				}
				if (testParameters.getSets().contains(PDC2016Set.CAL2)) {
					System.out.println(""[PDC2016TestPlugin] Classify PDC2016 "" + PDC2016Set.CAL2 + "" number "" + i);
					classifiedTestLogCal2 = classifierAlgorithm.apply(context, trainingLog, testLogJune, classifier, 
							new LogPreprocessorAlgorithm());
					context.getProvidedObjectManager().createProvidedObject(""PDC2016 "" + PDC2016Set.CAL2 + "" number "" + i,
							classifiedTestLogCal2, XLog.class, context);
				}
				if (testParameters.getSets().contains(PDC2016Set.TEST)) {
					System.out.println(""[PDC2016TestPlugin] Classify PDC2016 "" + PDC2016Set.TEST + "" number "" + i);
					classifiedTestLogTest = classifierAlgorithm.apply(context, trainingLog, testLogFinal, classifier, 
							new LogPreprocessorAlgorithm());
					context.getProvidedObjectManager().createProvidedObject(""PDC2016 "" + PDC2016Set.TEST + "" number "" + i,
							classifiedTestLogTest, XLog.class, context);
				}
				testModel.add(i, classifiedTestLogCal1, classifiedTestLogCal2, classifiedTestLogTest);
			}
			return testModel;
		} catch (Exception e) {
			e.printStackTrace();
		}
		return null;
	}

}
"
PDC2017LogPreprocessorAlgorithm.java,log-skeleton,"package org.processmining.logskeleton.pdc2017.algorithms;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.factory.XFactory;
import org.deckfour.xes.factory.XFactoryRegistry;
import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.logskeleton.algorithms.LogPreprocessorAlgorithm;
import org.processmining.logskeleton.models.ClassificationProblem;
import org.processmining.logskeleton.pdc2017.plugins.PDC2017Log10FilterPlugin;
import org.processmining.logskeleton.pdc2017.plugins.PDC2017Log10SplitterPlugin;
import org.processmining.logskeleton.pdc2017.plugins.PDC2017Log1FilterPlugin;
import org.processmining.logskeleton.pdc2017.plugins.PDC2017Log2FilterPlugin;
import org.processmining.logskeleton.pdc2017.plugins.PDC2017Log2SplitterPlugin;
import org.processmining.logskeleton.pdc2017.plugins.PDC2017Log4SplitterPlugin;
import org.processmining.logskeleton.pdc2017.plugins.PDC2017Log5FilterPlugin;
import org.processmining.logskeleton.pdc2017.plugins.PDC2017Log5SplitterPlugin;
import org.processmining.logskeleton.pdc2017.plugins.PDC2017Log7SplitterPlugin;
import org.processmining.logskeleton.pdc2017.plugins.PDC2017Log9FilterPlugin;
import org.processmining.logskeleton.pdc2017.plugins.PDC2017Log9SplitterPlugin;

public class PDC2017LogPreprocessorAlgorithm extends LogPreprocessorAlgorithm {

	private boolean useFilters;
	private boolean useExtenders;
	private boolean useSplitters;
	
	public PDC2017LogPreprocessorAlgorithm(boolean useFilters, boolean useExtenders, boolean useSplitters) {
		this.useFilters = useFilters;
		this.useExtenders = useExtenders;
		this.useSplitters = useSplitters;
	}
	
	public PDC2017LogPreprocessorAlgorithm() {
		this.useFilters = true;
		this.useExtenders = true;
		this.useSplitters = true;
	}
	
	public ClassificationProblem preprocess(PluginContext context, ClassificationProblem problem) {

		String name = XConceptExtension.instance().extractName(problem.getTrainingLog());

		if (useFilters) {
			/*
			 * Filter out the assumed noise.
			 */
			System.out.println(""====== Filter "" + name + "" ======"");
			if (name.equals(""log1"")) {
				problem.setTrainingLog((new PDC2017Log1FilterPlugin()).run(context, problem.getTrainingLog()));
			} else if (name.equals(""log2"")) {
				problem.setTrainingLog((new PDC2017Log2FilterPlugin()).run(context, problem.getTrainingLog()));
			} else if (name.equals(""log5"")) {
				problem.setTrainingLog((new PDC2017Log5FilterPlugin()).run(context, problem.getTrainingLog()));
			} else if (name.equals(""log9"")) {
				problem.setTrainingLog((new PDC2017Log9FilterPlugin()).run(context, problem.getTrainingLog()));
			} else if (name.equals(""log10"")) {
				problem.setTrainingLog((new PDC2017Log10FilterPlugin()).run(context, problem.getTrainingLog()));
			}
		}

		if (useExtenders) {
			/*
			 * Extend log with assumed false negatives from test log. Assumption
			 * is here that the test log is not that complete :-(.
			 */
			if (name.equals(""log1"")) {
				addTrace(
						problem.getTrainingLog(),
						new ArrayList<String>(Arrays.asList(""g"", ""w"", ""p"", ""c"", ""v"", ""m"", ""b"", ""u"", ""t"", ""s"", ""f"", ""r"",
								""l"", ""k"", ""j"")));
			} else if (name.equals(""log6"")) {
				addTrace(problem.getTrainingLog(), new ArrayList<String>(Arrays.asList(""d"", ""n"", ""a"", ""f"", ""k"")));
				addTrace(problem.getTrainingLog(),
						new ArrayList<String>(Arrays.asList(""c"", ""t"", ""q"", ""c"", ""a"", ""t"", ""r"")));
			}
		}

		if (useSplitters) {
			/*
			 * Split the assumed reoccurring activities.
			 */
			System.out.println(""====== Split "" + name + "" ======"");
			if (name.equals(""log2"")) {
				PDC2017Log2SplitterPlugin splitter = new PDC2017Log2SplitterPlugin();
				problem.setTrainingLog(splitter.run(context, problem.getTrainingLog()));
				problem.setTestLog(splitter.run(context, problem.getTestLog()));
			} else if (name.equals(""log4"")) {
				PDC2017Log4SplitterPlugin splitter = new PDC2017Log4SplitterPlugin();
				problem.setTrainingLog(splitter.run(context, problem.getTrainingLog()));
				problem.setTestLog(splitter.run(context, problem.getTestLog()));
			} else if (name.equals(""log5"")) {
				PDC2017Log5SplitterPlugin splitter = new PDC2017Log5SplitterPlugin();
				problem.setTrainingLog(splitter.run(context, problem.getTrainingLog()));
				problem.setTestLog(splitter.run(context, problem.getTestLog()));
			} else if (name.equals(""log7"")) {
				PDC2017Log7SplitterPlugin splitter = new PDC2017Log7SplitterPlugin();
				problem.setTrainingLog(splitter.run(context, problem.getTrainingLog()));
				problem.setTestLog(splitter.run(context, problem.getTestLog()));
			} else if (name.equals(""log9"")) {
				PDC2017Log9SplitterPlugin splitter = new PDC2017Log9SplitterPlugin();
				problem.setTrainingLog(splitter.run(context, problem.getTrainingLog()));
				problem.setTestLog(splitter.run(context, problem.getTestLog()));
			} else if (name.equals(""log10"")) {
				PDC2017Log10SplitterPlugin splitter = new PDC2017Log10SplitterPlugin();
				problem.setTrainingLog(splitter.run(context, problem.getTrainingLog()));
				problem.setTestLog(splitter.run(context, problem.getTestLog()));
			}
		}

		return problem;
	}

	public String toString() {
		if (useFilters && useExtenders && useSplitters) {
			return ""PDC 2017"";
		}
		List<String> selected = new ArrayList<String>();
		if (useFilters) {
			selected.add(""Filter"");
		}
		if (useExtenders) {
			selected.add(""Extend"");
		}
		if (useSplitters) {
			selected.add(""Split"");
		}
		return ""PDC 2017 "" + selected;
	}

	private static void addTrace(XLog log, List<String> activities) {
		XFactory factory = XFactoryRegistry.instance().currentDefault();
		XTrace trace = factory.createTrace();
		for (String activity : activities) {
			XEvent event = factory.createEvent();
			XConceptExtension.instance().assignName(event, activity);
			trace.add(event);
		}
		log.add(trace);
	}

}
"
PDC2017TestDialog.java,log-skeleton,"package org.processmining.logskeleton.pdc2017.dialogs;

import info.clearthought.layout.TableLayout;
import info.clearthought.layout.TableLayoutConstants;

import java.awt.Dimension;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashSet;
import java.util.List;

import javax.swing.DefaultListModel;
import javax.swing.JComponent;
import javax.swing.ListSelectionModel;
import javax.swing.event.ListSelectionEvent;
import javax.swing.event.ListSelectionListener;

import org.processmining.framework.util.ui.widgets.ProMList;
import org.processmining.logskeleton.algorithms.LogPreprocessorAlgorithm;
import org.processmining.logskeleton.pdc2017.parameters.PDC2017TestParameters;
import org.processmining.pdc2017.algorithms.PDC2017Set;

public class PDC2017TestDialog extends JComponent {

	/**
	 * 
	 */
	private static final long serialVersionUID = 378756044807568628L;
	
	public PDC2017TestDialog(final PDC2017TestParameters parameters) {
		double size[][] = { { TableLayoutConstants.FILL, TableLayoutConstants.FILL, TableLayoutConstants.FILL },
				{ TableLayoutConstants.FILL } };
		setLayout(new TableLayout(size));
		setOpaque(false);

		DefaultListModel<PDC2017Set> setListModel = new DefaultListModel<PDC2017Set>();
		int[] selectedIndices = new int[parameters.getSets().size()];
		int i = 0;
		int j = 0;
		List<PDC2017Set> sortedSets = new ArrayList<PDC2017Set>();
		sortedSets.addAll(parameters.getAllSets());
		Collections.sort(sortedSets, new Comparator<PDC2017Set>() {
			public int compare(PDC2017Set set1, PDC2017Set set2) {
				return set1.toString().compareTo(set2.toString());
			}
		});
		for (PDC2017Set set : sortedSets) {
			setListModel.addElement(set);
			if (parameters.getSets().contains(set)) {
				selectedIndices[j++] = i;
			}
			i++;
		}
		final ProMList<PDC2017Set> setList = new ProMList<PDC2017Set>(""Select log set(s)"", setListModel);
		setList.setSelectionMode(ListSelectionModel.MULTIPLE_INTERVAL_SELECTION);
		setList.setSelectedIndices(selectedIndices);
		setList.addListSelectionListener(new ListSelectionListener() {
			public void valueChanged(ListSelectionEvent e) {
				List<PDC2017Set> selectedSets = setList.getSelectedValuesList();
				parameters.setSets(new HashSet<PDC2017Set>(selectedSets));
			}
		});
		setList.setPreferredSize(new Dimension(100, 100));
		add(setList, ""0, 0"");

		DefaultListModel<Integer> nrListModel = new DefaultListModel<Integer>();
		selectedIndices = new int[parameters.getAllNrs().size()];
		i = 0;
		j = 0;
		for (int nr : parameters.getAllNrs()) {
			nrListModel.addElement(nr);
			if (parameters.getNrs().contains(nr)) {
				selectedIndices[j++] = i;
			}
			i++;
		}
		final ProMList<Integer> nrList = new ProMList<Integer>(""Select log number(s)"", nrListModel);
		nrList.setSelectionMode(ListSelectionModel.MULTIPLE_INTERVAL_SELECTION);
		nrList.setSelectedIndices(selectedIndices);
		nrList.addListSelectionListener(new ListSelectionListener() {
			public void valueChanged(ListSelectionEvent e) {
				List<Integer> selectedNrs = nrList.getSelectedValuesList();
				parameters.setNrs(new HashSet<Integer>(selectedNrs));
			}
		});
		nrList.setPreferredSize(new Dimension(100, 100));
		add(nrList, ""1, 0"");
		
		DefaultListModel<LogPreprocessorAlgorithm> preprocessors = new DefaultListModel<LogPreprocessorAlgorithm>();
		selectedIndices = new int[1];
		i = 0;
		j = 0;
		List<LogPreprocessorAlgorithm> sortedPreprocessors = new ArrayList<LogPreprocessorAlgorithm>();
		sortedPreprocessors.addAll(parameters.getAllPreprocessors());
		Collections.sort(sortedPreprocessors, new Comparator<LogPreprocessorAlgorithm>() {
			public int compare(LogPreprocessorAlgorithm prep1, LogPreprocessorAlgorithm prep2) {
				return prep1.toString().compareTo(prep2.toString());
			}
		});
		for (LogPreprocessorAlgorithm preprocessor : sortedPreprocessors) {
			preprocessors.addElement(preprocessor);
			if (parameters.getPreprocessor().equals(preprocessor)) {
				selectedIndices[j++] = i;
			}
			i++;
		}
		final ProMList<LogPreprocessorAlgorithm> preprocessorList = new ProMList<LogPreprocessorAlgorithm>(""Select preprocessor"", preprocessors);
		preprocessorList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
		preprocessorList.setSelectedIndices(selectedIndices);
		preprocessorList.addListSelectionListener(new ListSelectionListener() {
			public void valueChanged(ListSelectionEvent e) {
				List<LogPreprocessorAlgorithm> selectedPreprocessors = preprocessorList.getSelectedValuesList();
				if (selectedPreprocessors.size() == 1) {
					parameters.setPreprocessor(selectedPreprocessors.iterator().next());
				}
			}
		});
		preprocessorList.setPreferredSize(new Dimension(100, 100));
		add(preprocessorList, ""2, 0"");

	}
}
"
PDC2017TestModel.java,log-skeleton,"package org.processmining.logskeleton.pdc2017.models;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.processmining.framework.util.HTMLToString;
import org.processmining.logskeleton.pdc2017.parameters.PDC2017TestParameters;
import org.processmining.pdc2017.algorithms.PDC2017Set;

public class PDC2017TestModel implements HTMLToString {

	private List<Integer> numbers;
	private List<XLog> cal1Logs;
	private List<XLog> cal2Logs;
	private List<XLog> testLogs;
	private PDC2017TestParameters parameters;

	public PDC2017TestModel(PDC2017TestParameters parameters) {
		numbers = new ArrayList<Integer>();
		cal1Logs = new ArrayList<XLog>();
		cal2Logs = new ArrayList<XLog>();
		testLogs = new ArrayList<XLog>();
		this.parameters = parameters;
	}

	public void add(int i, XLog cal1Log, XLog cal2Log, XLog testLog) {
		numbers.add(i);
		if (cal1Log != null) {
			cal1Logs.add(cal1Log);
		}
		if (cal2Log != null) {
			cal2Logs.add(cal2Log);
		}
		if (testLog != null) {
			testLogs.add(testLog);
		}
	}

	public String toHTMLString(boolean includeHTMLTags) {
		StringBuffer buf = new StringBuffer();
		if (includeHTMLTags) {
			buf.append(""<html>"");
		}
		List<XLog> logs;
		for (int l = 0; l < 3; l++) {
			if (l == 0 && cal1Logs.isEmpty()) {
				continue;
			}
			if (l == 1 && cal2Logs.isEmpty()) {
				continue;
			}
			if (l == 2 && testLogs.isEmpty()) {
				continue;
			}
			if (l == 0) {
				buf.append(""<h1>""+ PDC2017Set.CAL1 + ""? using "" + parameters.getPreprocessor() + ""</h1>"");
				logs = cal1Logs;
			} else if (l == 1) {
				buf.append(""<h1>""+ PDC2017Set.CAL2 + ""? using "" + parameters.getPreprocessor() + ""</h1>"");
				logs = cal2Logs;
			} else {
				buf.append(""<h1>""+ PDC2017Set.TEST + ""? using "" + parameters.getPreprocessor() + ""</h1>"");
				logs = testLogs;
			}
			buf.append(""<table><tr><th></th>"");
			for (int n = 1; n < 21; n++) {
				buf.append(""<th>trace_"" + n + ""</th>"");
			}
			buf.append(""<th>#True</th>"");
			buf.append(""</tr>"");
			for (int i = 0; i < numbers.size(); i++) {
				Set<String> acceptedTraces = new HashSet<String>();
				for (XTrace trace : logs.get(i)) {
					acceptedTraces.add(XConceptExtension.instance().extractName(trace));
				}
				buf.append(""<tr><td>model_"" + numbers.get(i) + ""</td>"");
				for (int n = 1; n < 21; n++) {
					buf.append(""<td>"" + (acceptedTraces.contains("""" + n) ? ""TRUE"" : ""FALSE"") + ""</td>"");
				}
				buf.append(""<td>"" + logs.get(i).size() + ""</td>"");
				buf.append(""</tr>"");
			}
			buf.append(""</table>"");
		}
		if (includeHTMLTags) {
			buf.append(""</html>"");
		}
		return buf.toString();
	}

}
"
PDC2017TestParameters.java,log-skeleton,"package org.processmining.logskeleton.pdc2017.parameters;

import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;

import org.processmining.logskeleton.algorithms.LogPreprocessorAlgorithm;
import org.processmining.logskeleton.pdc2017.algorithms.PDC2017LogPreprocessorAlgorithm;
import org.processmining.pdc2017.algorithms.PDC2017Set;

public class PDC2017TestParameters {

	private Set<PDC2017Set> sets;
	private Set<PDC2017Set> allSets;
	private LogPreprocessorAlgorithm preprocessor;
	private Set<LogPreprocessorAlgorithm> allPreprocessors;
	private Set<Integer> nrs;
	private Set<Integer> allNrs;

	public PDC2017TestParameters() {

		sets = new HashSet<PDC2017Set>();
		allSets = new HashSet<PDC2017Set>();
		sets.addAll(Arrays.asList(PDC2017Set.values()));
		allSets.addAll(Arrays.asList(PDC2017Set.values()));
		sets.remove(PDC2017Set.TRAIN);
		allSets.remove(PDC2017Set.TRAIN);
		
		nrs = new HashSet<Integer>();
		allNrs = new HashSet<Integer>();
		for(int i = 1; i < 11; i++) {
			nrs.add(i);
			allNrs.add(i);
		}

		preprocessor = new PDC2017LogPreprocessorAlgorithm();
		allPreprocessors = new HashSet<LogPreprocessorAlgorithm>();
		allPreprocessors.add(new LogPreprocessorAlgorithm());
		allPreprocessors.add(preprocessor);
		allPreprocessors.add(new PDC2017LogPreprocessorAlgorithm(false, false, true));
		allPreprocessors.add(new PDC2017LogPreprocessorAlgorithm(true, false, false));
		allPreprocessors.add(new PDC2017LogPreprocessorAlgorithm(true, false, true));
		allPreprocessors.add(new PDC2017LogPreprocessorAlgorithm(false, true, false));
		allPreprocessors.add(new PDC2017LogPreprocessorAlgorithm(false, true, true));
		allPreprocessors.add(new PDC2017LogPreprocessorAlgorithm(true, true, false));
	}

	public Set<PDC2017Set> getSets() {
		return sets;
	}

	public void setSets(Set<PDC2017Set> sets) {
		this.sets = sets;
	}

	public LogPreprocessorAlgorithm getPreprocessor() {
		return preprocessor;
	}

	public void setPreprocessor(LogPreprocessorAlgorithm preprocessor) {
		this.preprocessor = preprocessor;
	}

	public Set<PDC2017Set> getAllSets() {
		return allSets;
	}

	public void setAllSets(Set<PDC2017Set> allSets) {
		this.allSets = allSets;
	}

	public Set<LogPreprocessorAlgorithm> getAllPreprocessors() {
		return allPreprocessors;
	}

	public void setAllPreprocessors(Set<LogPreprocessorAlgorithm> allPreprocessors) {
		this.allPreprocessors = allPreprocessors;
	}

	public Set<Integer> getNrs() {
		return nrs;
	}

	public void setNrs(Set<Integer> nrs) {
		this.nrs = nrs;
	}

	public Set<Integer> getAllNrs() {
		return allNrs;
	}

	public void setAllNrs(Set<Integer> allNrs) {
		this.allNrs = allNrs;
	}

}
"
PDC2017Log10FilterPlugin.java,log-skeleton,"package org.processmining.logskeleton.pdc2017.plugins;

import org.deckfour.xes.classification.XEventClassifier;
import org.deckfour.xes.classification.XEventNameClassifier;
import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.factory.XFactoryRegistry;
import org.deckfour.xes.model.XAttributeMap;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.logskeleton.algorithms.LogSkeletonBuilderAlgorithm;
import org.processmining.logskeleton.classifiers.LogSkeletonClassifier;
import org.processmining.logskeleton.models.LogSkeletonCount;

@Plugin(name = ""PDC 2017 Log 10 Filter"", parameterLabels = { ""Event Log 10"" }, returnLabels = { ""Filtered Log 10"" }, returnTypes = { XLog.class }, userAccessible = true, help = ""PDC 2017 Plug-in"")
public class PDC2017Log10FilterPlugin {

	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""H.M.W. Verbeek"", email = ""h.m.w.verbeek@tue.nl"")
	@PluginVariant(variantLabel = ""Default"", requiredParameterLabels = { 0 })
	public XLog run(PluginContext context, XLog log) {
		LogSkeletonBuilderAlgorithm skeletonBuilder = new LogSkeletonBuilderAlgorithm();
		XLog filteredLog = XFactoryRegistry.instance().currentDefault()
				.createLog((XAttributeMap) log.getAttributes().clone());
		XConceptExtension.instance().assignName(filteredLog,
				XConceptExtension.instance().extractName(log) + "" | filter: d=1"");
		XLog traceLog = XFactoryRegistry.instance().currentDefault().createLog((XAttributeMap) log.getAttributes().clone());
		XEventClassifier classifier = new LogSkeletonClassifier(new XEventNameClassifier());

		for (XTrace trace : log) {
			traceLog.clear();
			traceLog.add(trace);
			LogSkeletonCount count = skeletonBuilder.count(traceLog, classifier);
			if (count.get(""d"") != 1) {
				continue;
			}
			filteredLog.add(trace);
		}
		return filteredLog;
	}
}
"
PDC2017Log10SplitterPlugin.java,log-skeleton,"package org.processmining.logskeleton.pdc2017.plugins;

import org.deckfour.xes.classification.XEventClassifier;
import org.deckfour.xes.classification.XEventNameClassifier;
import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.model.XLog;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.logskeleton.algorithms.SplitterAlgorithm;
import org.processmining.logskeleton.classifiers.LogSkeletonClassifier;
import org.processmining.logskeleton.parameters.SplitterParameters;

@Plugin(name = ""PDC 2017 Log 10 Splitter"", parameterLabels = { ""Event Log 10"" }, returnLabels = { ""Split Log 10"" }, returnTypes = { XLog.class }, userAccessible = true, help = ""PDC 2017 Plug-in"")
public class PDC2017Log10SplitterPlugin extends SplitterAlgorithm {

	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""H.M.W. Verbeek"", email = ""h.m.w.verbeek@tue.nl"")
	@PluginVariant(variantLabel = ""Default"", requiredParameterLabels = { 0 })
	public XLog run(PluginContext context, XLog log) {
		SplitterParameters parameters = new SplitterParameters();
		XEventClassifier classifier = new LogSkeletonClassifier(new XEventNameClassifier());

		// Split o over j
		parameters.getMilestoneActivities().clear();
		parameters.getMilestoneActivities().add(""j"");
		parameters.setDuplicateActivity(""o"");
		XLog filteredLog = apply(log, classifier, parameters);
		// Split i over j
		parameters.getMilestoneActivities().clear();
		parameters.getMilestoneActivities().add(""j"");
		parameters.setDuplicateActivity(""i"");
		filteredLog = apply(filteredLog, classifier, parameters);
		// Split q over q
		parameters.getMilestoneActivities().clear();
		parameters.getMilestoneActivities().add(""q"");
		parameters.setDuplicateActivity(""q"");
		filteredLog = apply(filteredLog, classifier, parameters);
		// Split j over j
		parameters.getMilestoneActivities().clear();
		parameters.getMilestoneActivities().add(""j"");
		parameters.setDuplicateActivity(""j"");
		filteredLog = apply(filteredLog, classifier, parameters);
		// Split g over q.1
		parameters.getMilestoneActivities().clear();
		parameters.getMilestoneActivities().add(""q.1"");
		parameters.setDuplicateActivity(""g"");
		filteredLog = apply(filteredLog, classifier, parameters);
		// Split o.1 over o.1
		parameters.getMilestoneActivities().clear();
		parameters.getMilestoneActivities().add(""o.1"");
		parameters.setDuplicateActivity(""o.1"");
		filteredLog = apply(filteredLog, classifier, parameters);
		// Split q.1 over q.1
		parameters.getMilestoneActivities().clear();
		parameters.getMilestoneActivities().add(""q.1"");
		parameters.setDuplicateActivity(""q.1"");
		filteredLog = apply(filteredLog, classifier, parameters);
		XConceptExtension.instance().assignName(
				filteredLog,
				XConceptExtension.instance().extractName(log)
						+ "" | split: [o, j], [i, j], [q, q], [j, j], [g, q.1], [o.1, o.1], [q.1, q.1]"");
		return filteredLog;
	}

}
"
PDC2017Log1FilterPlugin.java,log-skeleton,"package org.processmining.logskeleton.pdc2017.plugins;

import org.deckfour.xes.classification.XEventClassifier;
import org.deckfour.xes.classification.XEventNameClassifier;
import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.factory.XFactoryRegistry;
import org.deckfour.xes.model.XAttributeMap;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.logskeleton.algorithms.LogSkeletonBuilderAlgorithm;
import org.processmining.logskeleton.classifiers.LogSkeletonClassifier;
import org.processmining.logskeleton.models.LogSkeletonCount;

@Plugin(name = ""PDC 2017 Log 1 Filter"", parameterLabels = { ""Event Log 1"" }, returnLabels = { ""Filtered Log 1"" }, returnTypes = { XLog.class }, userAccessible = true, help = ""PDC 2017 Plug-in"")
public class PDC2017Log1FilterPlugin {

	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""H.M.W. Verbeek"", email = ""h.m.w.verbeek@tue.nl"")
	@PluginVariant(variantLabel = ""Default"", requiredParameterLabels = { 0 })
	public XLog run(PluginContext context, XLog log) {
		LogSkeletonBuilderAlgorithm skeletonBuilder = new LogSkeletonBuilderAlgorithm();
		XLog filteredLog = XFactoryRegistry.instance().currentDefault()
				.createLog((XAttributeMap) log.getAttributes().clone());
		XConceptExtension.instance().assignName(filteredLog,
				XConceptExtension.instance().extractName(log) + "" | filter: f=j, f+d=1, b=l, c=s, d=o, d=h"");
		XLog traceLog = XFactoryRegistry.instance().currentDefault().createLog((XAttributeMap) log.getAttributes().clone());
		XEventClassifier classifier = new LogSkeletonClassifier(new XEventNameClassifier());

		for (XTrace trace : log) {
			traceLog.clear();
			traceLog.add(trace);
			LogSkeletonCount count = skeletonBuilder.count(traceLog, classifier);
			if (count.get(""f"") != count.get(""j"")) {
				continue;
			}
			if (count.get(""f"") + count.get(""d"") != 1) {
				continue;
			}
			if (count.get(""b"") != count.get(""l"")) {
				continue;
			}
			if (count.get(""c"") != count.get(""s"")) {
				continue;
			}
			if (count.get(""d"") != count.get(""o"") || count.get(""d"") != count.get(""h"")) {
				continue;
			}
			//			if (count.get(""d"") != count.get(""o"")) {
			//				continue;
			//			}
			filteredLog.add(trace);
		}
		return filteredLog;
	}
}
"
PDC2017Log2FilterPlugin.java,log-skeleton,"package org.processmining.logskeleton.pdc2017.plugins;

import org.deckfour.xes.classification.XEventClassifier;
import org.deckfour.xes.classification.XEventNameClassifier;
import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.factory.XFactoryRegistry;
import org.deckfour.xes.model.XAttributeMap;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.logskeleton.algorithms.LogSkeletonBuilderAlgorithm;
import org.processmining.logskeleton.classifiers.LogSkeletonClassifier;
import org.processmining.logskeleton.models.LogSkeletonCount;

@Plugin(name = ""PDC 2017 Log 2 Filter"", parameterLabels = { ""Event Log 2"" }, returnLabels = { ""Filtered Log 2"" }, returnTypes = { XLog.class }, userAccessible = true, help = ""PDC 2017 Plug-in"")
public class PDC2017Log2FilterPlugin {

	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""H.M.W. Verbeek"", email = ""h.m.w.verbeek@tue.nl"")
	@PluginVariant(variantLabel = ""Default"", requiredParameterLabels = { 0 })
	public XLog run(PluginContext context, XLog log) {
		LogSkeletonBuilderAlgorithm skeletonBuilder = new LogSkeletonBuilderAlgorithm();
		XLog filteredLog = XFactoryRegistry.instance().currentDefault().createLog((XAttributeMap) log.getAttributes().clone());
		XConceptExtension.instance().assignName(filteredLog,
				XConceptExtension.instance().extractName(log) + "" | filter: k=1, d=1, b=i+e"");
		XLog traceLog = XFactoryRegistry.instance().currentDefault().createLog((XAttributeMap) log.getAttributes().clone());
		XEventClassifier classifier = new LogSkeletonClassifier(new XEventNameClassifier());

		for (XTrace trace : log) {
			traceLog.clear();
			traceLog.add(trace);
			LogSkeletonCount count = skeletonBuilder.count(traceLog, classifier);
			if (count.get(""k"") != 1 || count.get(""d"") != 1) {
				continue;
			}
			if (count.get(""b"") != count.get(""i"") + count.get(""e"")) {
				continue;
			}
			filteredLog.add(trace);
		}
		return filteredLog;
	}
}
"
PDC2017Log2SplitterPlugin.java,log-skeleton,"package org.processmining.logskeleton.pdc2017.plugins;

import org.deckfour.xes.classification.XEventClassifier;
import org.deckfour.xes.classification.XEventNameClassifier;
import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.model.XLog;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.logskeleton.algorithms.SplitterAlgorithm;
import org.processmining.logskeleton.classifiers.LogSkeletonClassifier;
import org.processmining.logskeleton.parameters.SplitterParameters;

@Plugin(name = ""PDC 2017 Log 2 Splitter"", parameterLabels = { ""Event Log 2"" }, returnLabels = { ""Split Log 2"" }, returnTypes = { XLog.class }, userAccessible = true, help = ""PDC 2017 Plug-in"")
public class PDC2017Log2SplitterPlugin extends SplitterAlgorithm {

	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""H.M.W. Verbeek"", email = ""h.m.w.verbeek@tue.nl"")
	@PluginVariant(variantLabel = ""Default"", requiredParameterLabels = { 0 })
	public XLog run(PluginContext context, XLog log) {
		SplitterParameters parameters = new SplitterParameters();
		XLog filteredLog = log;
		XEventClassifier classifier = new LogSkeletonClassifier(new XEventNameClassifier());

		// Split a over itself
		parameters.getMilestoneActivities().clear();
		parameters.getMilestoneActivities().add(""a"");
		parameters.setDuplicateActivity(""a"");
		filteredLog = apply(filteredLog, classifier, parameters);
		// Split s over itself
		parameters.getMilestoneActivities().clear();
		parameters.getMilestoneActivities().add(""s"");
		parameters.setDuplicateActivity(""s"");
		filteredLog = apply(filteredLog, classifier, parameters);
		// Done
		XConceptExtension.instance().assignName(filteredLog,
				XConceptExtension.instance().extractName(log) + "" | split: [a, a], [s, s]"");
		return filteredLog;
	}
}
"
PDC2017Log4SplitterPlugin.java,log-skeleton,"package org.processmining.logskeleton.pdc2017.plugins;

import org.deckfour.xes.classification.XEventClassifier;
import org.deckfour.xes.classification.XEventNameClassifier;
import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.model.XLog;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.logskeleton.algorithms.SplitterAlgorithm;
import org.processmining.logskeleton.classifiers.LogSkeletonClassifier;
import org.processmining.logskeleton.parameters.SplitterParameters;

@Plugin(name = ""PDC 2017 Log 4 Splitter"", parameterLabels = { ""Event Log 4"" }, returnLabels = { ""Split Log 4"" }, returnTypes = { XLog.class }, userAccessible = true, help = ""PDC 2017 Plug-in"")
public class PDC2017Log4SplitterPlugin extends SplitterAlgorithm {

	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""H.M.W. Verbeek"", email = ""h.m.w.verbeek@tue.nl"")
	@PluginVariant(variantLabel = ""Default"", requiredParameterLabels = { 0 })
	public XLog run(PluginContext context, XLog log) {
		SplitterParameters parameters = new SplitterParameters();
		XEventClassifier classifier = new LogSkeletonClassifier(new XEventNameClassifier());

		// Split t over l
		parameters.getMilestoneActivities().clear();
		parameters.getMilestoneActivities().add(""l"");
		parameters.setDuplicateActivity(""t"");
		XLog filteredLog = apply(log, classifier, parameters);
		// Split r over b
		parameters.getMilestoneActivities().clear();
		parameters.getMilestoneActivities().add(""b"");
		parameters.setDuplicateActivity(""r"");
		filteredLog = apply(filteredLog, classifier, parameters);
		// Split m over b
		parameters.getMilestoneActivities().clear();
		parameters.getMilestoneActivities().add(""b"");
		parameters.setDuplicateActivity(""m"");
		filteredLog = apply(filteredLog, classifier, parameters);
		// Done
		XConceptExtension.instance().assignName(filteredLog,
				XConceptExtension.instance().extractName(log) + "" | split: [t, l], [r, b], [m, b]"");
		return filteredLog;
	}

}
"
PDC2017Log5FilterPlugin.java,log-skeleton,"package org.processmining.logskeleton.pdc2017.plugins;

import org.deckfour.xes.classification.XEventClassifier;
import org.deckfour.xes.classification.XEventNameClassifier;
import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.factory.XFactoryRegistry;
import org.deckfour.xes.model.XAttributeMap;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.logskeleton.algorithms.LogSkeletonBuilderAlgorithm;
import org.processmining.logskeleton.classifiers.LogSkeletonClassifier;
import org.processmining.logskeleton.models.LogSkeletonCount;

@Plugin(name = ""PDC 2017 Log 5 Filter"", parameterLabels = { ""Event Log 5"" }, returnLabels = { ""Filtered Log 5"" }, returnTypes = { XLog.class }, userAccessible = true, help = ""PDC 2017 Plug-in"")
public class PDC2017Log5FilterPlugin {

	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""H.M.W. Verbeek"", email = ""h.m.w.verbeek@tue.nl"")
	@PluginVariant(variantLabel = ""Default"", requiredParameterLabels = { 0 })
	public XLog run(PluginContext context, XLog log) {
		LogSkeletonBuilderAlgorithm skeletonBuilder = new LogSkeletonBuilderAlgorithm();
		XLog filteredLog = XFactoryRegistry.instance().currentDefault().createLog((XAttributeMap) log.getAttributes().clone());
		XConceptExtension.instance().assignName(filteredLog,
				XConceptExtension.instance().extractName(log) + "" | filter: f=1"");
		XLog traceLog = XFactoryRegistry.instance().currentDefault().createLog((XAttributeMap) log.getAttributes().clone());
		XEventClassifier classifier = new LogSkeletonClassifier(new XEventNameClassifier());

		for (XTrace trace : log) {
			traceLog.clear();
			traceLog.add(trace);
			LogSkeletonCount count = skeletonBuilder.count(traceLog, classifier);
			if (count.get(""f"") != 1) {
				continue;
			}
			filteredLog.add(trace);
		}
		return filteredLog;
	}
}
"
PDC2017Log5SplitterPlugin.java,log-skeleton,"package org.processmining.logskeleton.pdc2017.plugins;

import org.deckfour.xes.classification.XEventClassifier;
import org.deckfour.xes.classification.XEventNameClassifier;
import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.model.XLog;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.logskeleton.algorithms.SplitterAlgorithm;
import org.processmining.logskeleton.classifiers.LogSkeletonClassifier;
import org.processmining.logskeleton.parameters.SplitterParameters;

@Plugin(name = ""PDC 2017 Log 5 Splitter"", parameterLabels = { ""Event Log 5"" }, returnLabels = { ""Split Log 5"" }, returnTypes = { XLog.class }, userAccessible = true, help = ""PDC 2017 Plug-in"")
public class PDC2017Log5SplitterPlugin extends SplitterAlgorithm {

	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""H.M.W. Verbeek"", email = ""h.m.w.verbeek@tue.nl"")
	@PluginVariant(variantLabel = ""Default"", requiredParameterLabels = { 0 })
	public XLog run(PluginContext context, XLog log) {
		SplitterParameters parameters = new SplitterParameters();
		XLog filteredLog = log;
		XEventClassifier classifier = new LogSkeletonClassifier(new XEventNameClassifier());

		// Split a over itself
		parameters.getMilestoneActivities().clear();
		parameters.getMilestoneActivities().add(""a"");
		parameters.setDuplicateActivity(""a"");
		filteredLog = apply(filteredLog, classifier, parameters);
		// Split i over itself
		parameters.getMilestoneActivities().clear();
		parameters.getMilestoneActivities().add(""i"");
		parameters.setDuplicateActivity(""i"");
		filteredLog = apply(filteredLog, classifier, parameters);
		// Split g over itself
		parameters.getMilestoneActivities().clear();
		parameters.getMilestoneActivities().add(""g"");
		parameters.setDuplicateActivity(""g"");
		filteredLog = apply(filteredLog, classifier, parameters);
		// Split i.1 over itself
		parameters.getMilestoneActivities().clear();
		parameters.getMilestoneActivities().add(""i.1"");
		parameters.setDuplicateActivity(""i.1"");
		filteredLog = apply(filteredLog, classifier, parameters);
		// Split g over itself
		parameters.getMilestoneActivities().clear();
		parameters.getMilestoneActivities().add(""g.1"");
		parameters.setDuplicateActivity(""g.1"");
		filteredLog = apply(filteredLog, classifier, parameters);
		// Done
		XConceptExtension.instance().assignName(
				filteredLog,
				XConceptExtension.instance().extractName(log)
						+ "" | split: [a, a], [i, i], [g, g], [i.1, i,1], [g.1, g.1]"");
		return filteredLog;
	}
}
"
PDC2017Log7SplitterPlugin.java,log-skeleton,"package org.processmining.logskeleton.pdc2017.plugins;

import org.deckfour.xes.classification.XEventClassifier;
import org.deckfour.xes.classification.XEventNameClassifier;
import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.model.XLog;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.logskeleton.algorithms.SplitterAlgorithm;
import org.processmining.logskeleton.classifiers.LogSkeletonClassifier;
import org.processmining.logskeleton.parameters.SplitterParameters;

@Plugin(name = ""PDC 2017 Log 7 Splitter"", parameterLabels = { ""Event Log 7""}, returnLabels = { ""Split Log 7"" }, returnTypes = { XLog.class }, userAccessible = true, help = ""PDC 2017 Plug-in"")
public class PDC2017Log7SplitterPlugin extends SplitterAlgorithm {

	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""H.M.W. Verbeek"", email = ""h.m.w.verbeek@tue.nl"")
	@PluginVariant(variantLabel = ""Default"", requiredParameterLabels = { 0 })
	public XLog run(PluginContext context, XLog log) {
		SplitterParameters parameters = new SplitterParameters();
		XEventClassifier classifier = new LogSkeletonClassifier(new XEventNameClassifier());

		// Split n over f
		parameters.getMilestoneActivities().clear();
		parameters.getMilestoneActivities().add(""f"");
		parameters.setDuplicateActivity(""n"");
		XLog filteredLog = apply(log, classifier, parameters);
		// Split h over i
		parameters.getMilestoneActivities().clear();
		parameters.getMilestoneActivities().add(""i"");
		parameters.setDuplicateActivity(""h"");
		filteredLog = apply(filteredLog, classifier, parameters);
		// Split c over i
		parameters.getMilestoneActivities().clear();
		parameters.getMilestoneActivities().add(""i"");
		parameters.setDuplicateActivity(""c"");
		filteredLog = apply(filteredLog, classifier, parameters);
		// Split h.0 over c.0
		parameters.getMilestoneActivities().clear();
		parameters.getMilestoneActivities().add(""c.0"");
//		parameters.getMilestoneActivities().add(""h.0"");
		parameters.setDuplicateActivity(""h.0"");
		filteredLog = apply(filteredLog, classifier, parameters);
		// Split p over e
		parameters.getMilestoneActivities().clear();
		parameters.getMilestoneActivities().add(""e"");
		parameters.setDuplicateActivity(""p"");
		filteredLog = apply(filteredLog, classifier, parameters);
		// Split c.0 over h.0.0
		parameters.getMilestoneActivities().clear();
		parameters.getMilestoneActivities().add(""h.0.0"");
		parameters.setDuplicateActivity(""c.0"");
		filteredLog = apply(filteredLog, classifier, parameters);
		// Done, except for b...
		XConceptExtension.instance().assignName(
				filteredLog,
				XConceptExtension.instance().extractName(log)
						+ "" | split: [n, f], [h, i], [c,i], [h.0, c.0], [p, e], [c.0, h.0.0], 7B"");
		return apply7B(filteredLog, classifier);
	}

}
"
PDC2017Log9FilterPlugin.java,log-skeleton,"package org.processmining.logskeleton.pdc2017.plugins;

import org.deckfour.xes.classification.XEventClassifier;
import org.deckfour.xes.classification.XEventNameClassifier;
import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.factory.XFactoryRegistry;
import org.deckfour.xes.model.XAttributeMap;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.logskeleton.algorithms.LogSkeletonBuilderAlgorithm;
import org.processmining.logskeleton.classifiers.LogSkeletonClassifier;
import org.processmining.logskeleton.models.LogSkeletonCount;

@Plugin(name = ""PDC 2017 Log 9 Filter"", parameterLabels = { ""Event Log 9""}, returnLabels = { ""Filtered Log 9"" }, returnTypes = { XLog.class }, userAccessible = true, help = ""PDC 2017 Plug-in"")
public class PDC2017Log9FilterPlugin {

	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""H.M.W. Verbeek"", email = ""h.m.w.verbeek@tue.nl"")
	@PluginVariant(variantLabel = ""Default"", requiredParameterLabels = { 0 })
	public XLog run(PluginContext context, XLog log) {
		LogSkeletonBuilderAlgorithm skeletonBuilder = new LogSkeletonBuilderAlgorithm();
		XLog filteredLog = XFactoryRegistry.instance().currentDefault().createLog((XAttributeMap) log.getAttributes().clone());
		XConceptExtension.instance().assignName(
				filteredLog,
				XConceptExtension.instance().extractName(log)
						+ "" | filter: c+f=1, c+l=1"");
		XLog traceLog = XFactoryRegistry.instance().currentDefault().createLog((XAttributeMap) log.getAttributes().clone());
		XEventClassifier classifier = new LogSkeletonClassifier(new XEventNameClassifier());
		for (XTrace trace : log) {
			traceLog.clear();
			traceLog.add(trace);
			LogSkeletonCount count = skeletonBuilder.count(traceLog, classifier);
			if (count.get(""c"") + count.get(""f"") != 1) {
				continue;
			} else if (count.get(""c"") + count.get(""l"") != 1) {
				continue;
			}
			filteredLog.add(trace);
		}
		return filteredLog;
	}
}
"
PDC2017Log9SplitterPlugin.java,log-skeleton,"package org.processmining.logskeleton.pdc2017.plugins;

import org.deckfour.xes.classification.XEventClassifier;
import org.deckfour.xes.classification.XEventNameClassifier;
import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.model.XLog;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.logskeleton.algorithms.SplitterAlgorithm;
import org.processmining.logskeleton.classifiers.LogSkeletonClassifier;
import org.processmining.logskeleton.parameters.SplitterParameters;

@Plugin(name = ""PDC 2017 Log 9 Splitter"", parameterLabels = { ""Event Log 9""}, returnLabels = { ""Split Log 9"" }, returnTypes = { XLog.class }, userAccessible = true, help = ""PDC 2017 Plug-in"")
public class PDC2017Log9SplitterPlugin extends SplitterAlgorithm {

	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""H.M.W. Verbeek"", email = ""h.m.w.verbeek@tue.nl"")
	@PluginVariant(variantLabel = ""Default"", requiredParameterLabels = { 0 })
	public XLog run(PluginContext context, XLog log) {
		SplitterParameters parameters = new SplitterParameters();
		XEventClassifier classifier = new LogSkeletonClassifier(new XEventNameClassifier());

		// Split t over v
		parameters.getMilestoneActivities().clear();
		parameters.getMilestoneActivities().add(""v"");
		parameters.setDuplicateActivity(""t"");
		XLog filteredLog = apply(log, classifier, parameters);
		// Split ad over k
		parameters.getMilestoneActivities().clear();
		parameters.getMilestoneActivities().add(""k"");
		parameters.setDuplicateActivity(""ad"");
		filteredLog = apply(filteredLog, classifier, parameters);
		// Split ad.0 over ad.0
		parameters.getMilestoneActivities().clear();
		parameters.getMilestoneActivities().add(""ad.0"");
		parameters.setDuplicateActivity(""ad.0"");
		filteredLog = apply(filteredLog, classifier, parameters);
		// Split k over b
		parameters.getMilestoneActivities().clear();
		parameters.getMilestoneActivities().add(""b"");
		parameters.setDuplicateActivity(""k"");
		filteredLog = apply(filteredLog, classifier, parameters);
		// Split z over ad.1
		parameters.getMilestoneActivities().clear();
		parameters.getMilestoneActivities().add(""ad.1"");
		parameters.setDuplicateActivity(""z"");
		filteredLog = apply(filteredLog, classifier, parameters);
		// Split h over z.1
		parameters.getMilestoneActivities().clear();
		parameters.getMilestoneActivities().add(""z.1"");
		parameters.setDuplicateActivity(""h"");
		filteredLog = apply(filteredLog, classifier, parameters);
		// Split p over b
		parameters.getMilestoneActivities().clear();
		parameters.getMilestoneActivities().add(""b"");
		parameters.setDuplicateActivity(""p"");
		filteredLog = apply(filteredLog, classifier, parameters);
		// Split o over o
		parameters.getMilestoneActivities().clear();
		parameters.getMilestoneActivities().add(""o"");
		parameters.setDuplicateActivity(""o"");
		filteredLog = apply(filteredLog, classifier, parameters);
		XConceptExtension.instance().assignName(
				filteredLog,
				XConceptExtension.instance().extractName(log)
						+ "" | split: [t, v], [ad, k], [ad.0, ad.0], [k, b], [z, ad.1], [h, z.1], [p, b], [o, o]"");
		return filteredLog;
	}

}
"
PDC2017TestPlugin.java,log-skeleton,"package org.processmining.logskeleton.pdc2017.plugins;

import org.deckfour.uitopia.api.event.TaskListener.InteractionResult;
import org.deckfour.xes.classification.XEventClassifier;
import org.deckfour.xes.classification.XEventNameClassifier;
import org.deckfour.xes.model.XLog;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.logskeleton.algorithms.LogPreprocessorAlgorithm;
import org.processmining.logskeleton.algorithms.LogSkeletonClassifierAlgorithm;
import org.processmining.logskeleton.classifiers.LogSkeletonClassifier;
import org.processmining.logskeleton.pdc2017.dialogs.PDC2017TestDialog;
import org.processmining.logskeleton.pdc2017.models.PDC2017TestModel;
import org.processmining.logskeleton.pdc2017.parameters.PDC2017TestParameters;
import org.processmining.pdc2017.algorithms.PDC2017LogAlgorithm;
import org.processmining.pdc2017.algorithms.PDC2017Set;
import org.processmining.pdc2017.parameters.PDC2017Parameters;

@Plugin(name = ""PDC 2017 Test"", parameterLabels = {}, returnLabels = { ""Results"" }, returnTypes = { PDC2017TestModel.class })
public class PDC2017TestPlugin {

	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""H.M.W. Verbeek"", email = ""h.m.w.verbeek@tue.nl"")
	@PluginVariant(variantLabel = ""Default"", requiredParameterLabels = {})
	public static PDC2017TestModel run(final UIPluginContext context) {
		PDC2017TestParameters testParameters = new PDC2017TestParameters();
		PDC2017TestDialog testDialog = new PDC2017TestDialog(testParameters);
		InteractionResult result = context.showWizard(""Select test parameters"", true, true, testDialog);
		if (result != InteractionResult.FINISHED) {
			context.getFutureResult(0).cancel(true);
			return null;
		}
		PDC2017TestModel testModel = new PDC2017TestModel(testParameters);
		PDC2017Parameters parameters = new PDC2017Parameters();
		PDC2017LogAlgorithm logAlgorithm = new PDC2017LogAlgorithm();

		XEventClassifier classifier = new LogSkeletonClassifier(new XEventNameClassifier());

		try {
			for (int i : testParameters.getNrs()) {
				parameters.setNr(i);
				parameters.setSet(PDC2017Set.TRAIN);
				XLog trainingLog = logAlgorithm.apply(context, parameters);
				parameters.setSet(PDC2017Set.CAL1);
				XLog testLogMay = testParameters.getSets().contains(PDC2017Set.CAL1) ? logAlgorithm.apply(context,
						parameters) : null;
				parameters.setSet(PDC2017Set.CAL2);
				XLog testLogJune = testParameters.getSets().contains(PDC2017Set.CAL2) ? logAlgorithm.apply(context,
						parameters) : null;
				parameters.setSet(PDC2017Set.TEST);
				XLog testLogFinal = testParameters.getSets().contains(PDC2017Set.TEST) ? logAlgorithm.apply(context,
						parameters) : null;

				LogSkeletonClassifierAlgorithm classifierAlgorithm = new LogSkeletonClassifierAlgorithm();
				LogPreprocessorAlgorithm preprocessor = testParameters.getPreprocessor();

				XLog classifiedTestLogCal1 = null;
				XLog classifiedTestLogCal2 = null;
				XLog classifiedTestLogTest = null;

				// Classify the logs
				if (testParameters.getSets().contains(PDC2017Set.CAL1)) {
					System.out.println(""[PDC2017TestPlugin] Classify PDC2017 "" + PDC2017Set.CAL1 + "" number "" + i);
					classifiedTestLogCal1 = classifierAlgorithm.apply(context, trainingLog, testLogMay, classifier, preprocessor);
					context.getProvidedObjectManager().createProvidedObject(""PDC2017 "" + PDC2017Set.CAL1 + "" number "" + i,
							classifiedTestLogCal1, XLog.class, context);
				}
				if (testParameters.getSets().contains(PDC2017Set.CAL2)) {
					System.out.println(""[PDC2017TestPlugin] Classify PDC2017 "" + PDC2017Set.CAL2 + "" number "" + i);
					classifiedTestLogCal2 = classifierAlgorithm.apply(context, trainingLog, testLogJune, classifier, preprocessor);
					context.getProvidedObjectManager().createProvidedObject(""PDC2017 "" + PDC2017Set.CAL2 + "" number "" + i,
							classifiedTestLogCal2, XLog.class, context);
				}
				if (testParameters.getSets().contains(PDC2017Set.TEST)) {
					System.out.println(""[PDC2017TestPlugin] Classify PDC2017 "" + PDC2017Set.TEST + "" number "" + i);
					classifiedTestLogTest = classifierAlgorithm.apply(context, trainingLog, testLogFinal, classifier, preprocessor);
					context.getProvidedObjectManager().createProvidedObject(""PDC2017 "" + PDC2017Set.TEST + "" number "" + i,
							classifiedTestLogTest, XLog.class, context);
				}
				testModel.add(i, classifiedTestLogCal1, classifiedTestLogCal2, classifiedTestLogTest);
			}
			return testModel;
		} catch (Exception e) {
			e.printStackTrace();
		}
		return null;
	}

}
"
PDC2019Log1FilterPlugin.java,log-skeleton,"package org.processmining.logskeleton.pdc2019.plugins;

import org.deckfour.xes.classification.XEventClassifier;
import org.deckfour.xes.classification.XEventNameClassifier;
import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.factory.XFactoryRegistry;
import org.deckfour.xes.model.XAttributeMap;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.logskeleton.algorithms.LogSkeletonBuilderAlgorithm;
import org.processmining.logskeleton.classifiers.LogSkeletonClassifier;
import org.processmining.logskeleton.models.LogSkeletonCount;

@Plugin(name = ""PDC 2019 Log 1 Filter"", parameterLabels = { ""Event Log 1"" }, returnLabels = { ""Filtered Log 1"" }, returnTypes = { XLog.class }, userAccessible = true, help = ""PDC 2019 Plug-in"")
public class PDC2019Log1FilterPlugin {

	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""H.M.W. Verbeek"", email = ""h.m.w.verbeek@tue.nl"")
	@PluginVariant(variantLabel = ""Default"", requiredParameterLabels = { 0 })
	public XLog run(PluginContext context, XLog log) {
		LogSkeletonBuilderAlgorithm skeletonBuilder = new LogSkeletonBuilderAlgorithm();
		XLog filteredLog = XFactoryRegistry.instance().currentDefault()
				.createLog((XAttributeMap) log.getAttributes().clone());
		XConceptExtension.instance().assignName(filteredLog,
				XConceptExtension.instance().extractName(log) + "" | filter: ai=o, ai+x+f=1, an+aj=1, ab+n+ah=an, ac+ak=1, ag=1, ad+ap+m=v"");
		XLog traceLog = XFactoryRegistry.instance().currentDefault().createLog((XAttributeMap) log.getAttributes().clone());
		XEventClassifier classifier = new LogSkeletonClassifier(new XEventNameClassifier());

		for (XTrace trace : log) {
			traceLog.clear();
			traceLog.add(trace);
			LogSkeletonCount count = skeletonBuilder.count(traceLog, classifier);
			if (count.get(""ai"") != count.get(""o"")) {
				continue;
			}
			if (count.get(""ai"") + count.get(""x"") + count.get(""f"") != 1) {
				continue;
			}
			if (count.get(""an"") + count.get(""aj"") != 1) {
				continue;
			}
			if (count.get(""ab"") + count.get(""n"") + count.get(""ah"") != count.get(""an"")) {
				continue;
			}
			if (count.get(""ac"") + count.get(""ak"") != 1) {
				continue;
			}
			if (count.get(""ag"") != 1) {
				continue;
			}
			if (count.get(""ad"") + count.get(""ap"") + count.get(""m"") != count.get(""v"")) {
				continue;
			}
			filteredLog.add(trace);
		}
		return filteredLog;
	}
}
"
PDC2019Log2FilterPlugin.java,log-skeleton,"package org.processmining.logskeleton.pdc2019.plugins;

import org.deckfour.xes.classification.XEventClassifier;
import org.deckfour.xes.classification.XEventNameClassifier;
import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.factory.XFactoryRegistry;
import org.deckfour.xes.model.XAttributeMap;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.logskeleton.algorithms.LogSkeletonBuilderAlgorithm;
import org.processmining.logskeleton.classifiers.LogSkeletonClassifier;
import org.processmining.logskeleton.models.LogSkeletonCount;

@Plugin(name = ""PDC 2019 Log 2 Filter"", parameterLabels = { ""Event Log 1"" }, returnLabels = { ""Filtered Log 2"" }, returnTypes = { XLog.class }, userAccessible = true, help = ""PDC 2019 Plug-in"")
public class PDC2019Log2FilterPlugin {

	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""H.M.W. Verbeek"", email = ""h.m.w.verbeek@tue.nl"")
	@PluginVariant(variantLabel = ""Default"", requiredParameterLabels = { 0 })
	public XLog run(PluginContext context, XLog log) {
		LogSkeletonBuilderAlgorithm skeletonBuilder = new LogSkeletonBuilderAlgorithm();
		XLog filteredLog = XFactoryRegistry.instance().currentDefault()
				.createLog((XAttributeMap) log.getAttributes().clone());
		XConceptExtension.instance().assignName(filteredLog,
				XConceptExtension.instance().extractName(log) + "" | filter: ai=1"");
		XLog traceLog = XFactoryRegistry.instance().currentDefault().createLog((XAttributeMap) log.getAttributes().clone());
		XEventClassifier classifier = new LogSkeletonClassifier(new XEventNameClassifier());

		for (XTrace trace : log) {
			traceLog.clear();
			traceLog.add(trace);
			LogSkeletonCount count = skeletonBuilder.count(traceLog, classifier);
			if (count.get(""ai"") != 1) {
				continue;
			}
			filteredLog.add(trace);
		}
		return filteredLog;
	}
}
"
PDC2019Log3FilterPlugin.java,log-skeleton,"package org.processmining.logskeleton.pdc2019.plugins;

import org.deckfour.xes.classification.XEventClassifier;
import org.deckfour.xes.classification.XEventNameClassifier;
import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.factory.XFactoryRegistry;
import org.deckfour.xes.model.XAttributeMap;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.logskeleton.algorithms.LogSkeletonBuilderAlgorithm;
import org.processmining.logskeleton.classifiers.LogSkeletonClassifier;
import org.processmining.logskeleton.models.LogSkeletonCount;

@Plugin(name = ""PDC 2019 Log 3 Filter"", parameterLabels = { ""Event Log 1"" }, returnLabels = { ""Filtered Log 3"" }, returnTypes = { XLog.class }, userAccessible = true, help = ""PDC 2019 Plug-in"")
public class PDC2019Log3FilterPlugin {

	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""H.M.W. Verbeek"", email = ""h.m.w.verbeek@tue.nl"")
	@PluginVariant(variantLabel = ""Default"", requiredParameterLabels = { 0 })
	public XLog run(PluginContext context, XLog log) {
		LogSkeletonBuilderAlgorithm skeletonBuilder = new LogSkeletonBuilderAlgorithm();
		XLog filteredLog = XFactoryRegistry.instance().currentDefault()
				.createLog((XAttributeMap) log.getAttributes().clone());
		XConceptExtension.instance().assignName(filteredLog,
				XConceptExtension.instance().extractName(log) + "" | filter: ..."");
		XLog traceLog = XFactoryRegistry.instance().currentDefault().createLog((XAttributeMap) log.getAttributes().clone());
		XEventClassifier classifier = new LogSkeletonClassifier(new XEventNameClassifier());

		for (XTrace trace : log) {
			traceLog.clear();
			traceLog.add(trace);
			LogSkeletonCount count = skeletonBuilder.count(traceLog, classifier);
			if (count.get(""al"") != count.get(""l"")) {
				continue;
			}
			if (count.get(""ap"") != count.get(""j"")) {
				continue;
			}
			if (count.get(""ad"") != count.get(""i"")) {
				continue;
			}
			if (count.get(""b"") != count.get(""u"")) {
				continue;
			}
			if (count.get(""aq"") != count.get(""ar"")) {
				continue;
			}
			if (count.get(""e"") != count.get(""t"")) {
				continue;
			}
			if (count.get(""d"") != count.get(""o"")) {
				continue;
			}
			if (count.get(""w"") != count.get(""ag"")) {
				continue;
			}
			filteredLog.add(trace);
		}
		return filteredLog;
	}
}
"
PDC2019Log4CheckerPlugin.java,log-skeleton,"package org.processmining.logskeleton.pdc2019.plugins;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.factory.XFactoryRegistry;
import org.deckfour.xes.model.XAttributeMap;
import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.pdc2019.algorithms.PDC2019LogAlgorithm;
import org.processmining.pdc2019.algorithms.PDC2019Set;
import org.processmining.pdc2019.parameters.PDC2019Parameters;

@Plugin(name = ""PDC 2019 Log 4 Checker"", parameterLabels = {}, returnLabels = { ""Checked Log 4"" }, returnTypes = {
		XLog.class }, userAccessible = true, help = ""PDC 2019 Plug-in"")
public class PDC2019Log4CheckerPlugin {

	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""H.M.W. Verbeek"", email = ""h.m.w.verbeek@tue.nl"")
	@PluginVariant(variantLabel = ""Default"", requiredParameterLabels = {})
	public XLog run(PluginContext context) {
		try {
			PDC2019LogAlgorithm algorithm = new PDC2019LogAlgorithm();
			PDC2019Parameters parameters = new PDC2019Parameters();
			parameters.setSet(PDC2019Set.TRAIN);
			parameters.setNr(4);
			Map<List<String>, Long> traceCounts = new HashMap<List<String>, Long>();
			XLog log = algorithm.apply(context, parameters);
			for (XTrace trace : log) {
				List<String> activities = new ArrayList<String>();
				for (XEvent event : trace) {
					activities.add(XConceptExtension.instance().extractName(event));
				}
				long count = 1 + (traceCounts.containsKey(activities) ? traceCounts.get(activities) : 0);
				traceCounts.put(activities, count);
			}
			parameters.setSet(PDC2019Set.CAL2);
			log = algorithm.apply(context, parameters);
			XLog newLog = XFactoryRegistry.instance().currentDefault()
					.createLog((XAttributeMap) log.getAttributes().clone());
			for (XTrace trace : log) {
				XTrace newTrace = XFactoryRegistry.instance().currentDefault()
						.createTrace((XAttributeMap) trace.getAttributes().clone());
				List<String> activities = new ArrayList<String>();
				for (XEvent event : trace) {
					XEvent newEvent = XFactoryRegistry.instance().currentDefault()
							.createEvent((XAttributeMap) event.getAttributes().clone());
					newTrace.add(newEvent);
					activities.add(XConceptExtension.instance().extractName(event));
				}
				newTrace.getAttributes().put(""count"", XFactoryRegistry.instance().currentDefault()
						.createAttributeDiscrete(""count"", traceCounts.containsKey(activities) ? traceCounts.get(activities) : -1, null));
				for (List<String> key : traceCounts.keySet()) {
					if (key.size() >= activities.size()) {
						boolean isPrefix = true;
						for (int i = 0; i < activities.size(); i++) {
							if (!key.get(i).equals(activities.get(i))) {
								isPrefix = false;
							}
						}
						if (isPrefix) {
							newTrace.getAttributes().put(""prefix"", XFactoryRegistry.instance().currentDefault()
									.createAttributeLiteral(""prefix"", activities.toString(), null));
						}
					}
				}
				newLog.add(newTrace);
			}
			return newLog;
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return null;
	}

}
"
PDC2019Log4FilterPlugin.java,log-skeleton,"package org.processmining.logskeleton.pdc2019.plugins;

import org.deckfour.xes.classification.XEventClassifier;
import org.deckfour.xes.classification.XEventNameClassifier;
import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.factory.XFactoryRegistry;
import org.deckfour.xes.model.XAttributeMap;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.logskeleton.algorithms.LogSkeletonBuilderAlgorithm;
import org.processmining.logskeleton.classifiers.LogSkeletonClassifier;
import org.processmining.logskeleton.models.LogSkeletonCount;

@Plugin(name = ""PDC 2019 Log 4 Filter"", parameterLabels = { ""Event Log 4"" }, returnLabels = { ""Filtered Log 4"" }, returnTypes = { XLog.class }, userAccessible = true, help = ""PDC 2019 Plug-in"")
public class PDC2019Log4FilterPlugin {

	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""H.M.W. Verbeek"", email = ""h.m.w.verbeek@tue.nl"")
	@PluginVariant(variantLabel = ""Default"", requiredParameterLabels = { 0 })
	public XLog run(PluginContext context, XLog log) {
		LogSkeletonBuilderAlgorithm skeletonBuilder = new LogSkeletonBuilderAlgorithm();
		XLog filteredLog = XFactoryRegistry.instance().currentDefault()
				.createLog((XAttributeMap) log.getAttributes().clone());
		XConceptExtension.instance().assignName(filteredLog,
				XConceptExtension.instance().extractName(log) + "" | filter: 2019-4"");
		XLog traceLog = XFactoryRegistry.instance().currentDefault().createLog((XAttributeMap) log.getAttributes().clone());
		XEventClassifier classifier = new LogSkeletonClassifier(new XEventNameClassifier());

		for (XTrace trace : log) {
			traceLog.clear();
			traceLog.add(trace);
			LogSkeletonCount count = skeletonBuilder.count(traceLog, classifier);
			if (count.get(""al"") != count.get(""at"") + count.get(""n"")) {
				continue;
			}
			if (count.get(""al"") + count.get(""e.1"") + count.get(""as.1"") + count.get(""d"") + count.get(""u"") + count.get(""t.1"") + count.get(""ad.1"") != 1) {
				continue;
			}
			filteredLog.add(trace);
		}
		return filteredLog;
	}
}
"
PDC2019Log4SplitterPlugin.java,log-skeleton,"package org.processmining.logskeleton.pdc2019.plugins;

import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.model.XLog;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.logskeleton.algorithms.SplitterAlgorithm;

@Plugin(name = ""PDC 2019 Log 4 Splitter"", parameterLabels = { ""Event Log 4""}, returnLabels = { ""Split Log 4"" }, returnTypes = { XLog.class }, userAccessible = true, help = ""PDC 2017 Plug-in"")
public class PDC2019Log4SplitterPlugin extends SplitterAlgorithm {

	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""H.M.W. Verbeek"", email = ""h.m.w.verbeek@tue.nl"")
	@PluginVariant(variantLabel = ""Default"", requiredParameterLabels = { 0 })
	public XLog run(PluginContext context, XLog log) {
		XLog filteredLog = apply20194(log);
		XConceptExtension.instance().assignName(
				filteredLog,
				XConceptExtension.instance().extractName(log)
						+ "" | split: 2019-4"");
		return filteredLog;
	}

}
"
PDC2019Log9SplitterPlugin.java,log-skeleton,"package org.processmining.logskeleton.pdc2019.plugins;

import org.deckfour.xes.classification.XEventClassifier;
import org.deckfour.xes.classification.XEventNameClassifier;
import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.model.XLog;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.logskeleton.algorithms.SplitterAlgorithm;
import org.processmining.logskeleton.classifiers.LogSkeletonClassifier;
import org.processmining.logskeleton.parameters.SplitterParameters;

@Plugin(name = ""PDC 2019 Log 9 Splitter"", parameterLabels = { ""Event Log 9""}, returnLabels = { ""Split Log 9"" }, returnTypes = { XLog.class }, userAccessible = true, help = ""PDC 2017 Plug-in"")
public class PDC2019Log9SplitterPlugin extends SplitterAlgorithm {

	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""H.M.W. Verbeek"", email = ""h.m.w.verbeek@tue.nl"")
	@PluginVariant(variantLabel = ""Default"", requiredParameterLabels = { 0 })
	public XLog run(PluginContext context, XLog log) {
		SplitterParameters parameters = new SplitterParameters();
		XEventClassifier classifier = new LogSkeletonClassifier(new XEventNameClassifier());

		// Split t over v
		parameters.getMilestoneActivities().clear();
		parameters.getMilestoneActivities().add(""s"");
		parameters.setDuplicateActivity(""s"");
		XLog filteredLog = apply(log, classifier, parameters);
		// Split ad over k
		parameters.getMilestoneActivities().clear();
		parameters.getMilestoneActivities().add(""o"");
		parameters.setDuplicateActivity(""w"");
		filteredLog = apply(filteredLog, classifier, parameters);
		// Split ad.0 over ad.0
		parameters.getMilestoneActivities().clear();
		parameters.getMilestoneActivities().add(""o"");
		parameters.setDuplicateActivity(""al"");
		filteredLog = apply(filteredLog, classifier, parameters);
		// Split k over b
		parameters.getMilestoneActivities().clear();
		parameters.getMilestoneActivities().add(""ai"");
		parameters.setDuplicateActivity(""ai"");
		filteredLog = apply(filteredLog, classifier, parameters);
		// Split z over ad.1
		parameters.getMilestoneActivities().clear();
		parameters.getMilestoneActivities().add(""ai.1"");
		parameters.setDuplicateActivity(""z"");
		filteredLog = apply(filteredLog, classifier, parameters);
		// Split h over z.1
		parameters.getMilestoneActivities().clear();
		parameters.getMilestoneActivities().add(""z.0"");
		parameters.setDuplicateActivity(""d"");
		filteredLog = apply(filteredLog, classifier, parameters);
		// Split p over b
		parameters.getMilestoneActivities().clear();
		parameters.getMilestoneActivities().add(""q"");
		parameters.setDuplicateActivity(""q"");
		filteredLog = apply(filteredLog, classifier, parameters);
		// Split o over o
		parameters.getMilestoneActivities().clear();
		parameters.getMilestoneActivities().add(""ai.1"");
		parameters.setDuplicateActivity(""ai.1"");
		filteredLog = apply(filteredLog, classifier, parameters);
		// Split o over o
		parameters.getMilestoneActivities().clear();
		parameters.getMilestoneActivities().add(""aj"");
		parameters.setDuplicateActivity(""aj"");
		filteredLog = apply(filteredLog, classifier, parameters);
		// Split o over o
		parameters.getMilestoneActivities().clear();
		parameters.getMilestoneActivities().add(""ac"");
		parameters.setDuplicateActivity(""ac"");
		filteredLog = apply(filteredLog, classifier, parameters);
		// Split o over o
		parameters.getMilestoneActivities().clear();
		parameters.getMilestoneActivities().add(""n"");
		parameters.setDuplicateActivity(""n"");
		filteredLog = apply(filteredLog, classifier, parameters);
		// Split o over o
		parameters.getMilestoneActivities().clear();
		parameters.getMilestoneActivities().add(""z.1"");
		parameters.setDuplicateActivity(""c"");
		filteredLog = apply(filteredLog, classifier, parameters);
		XConceptExtension.instance().assignName(
				filteredLog,
				XConceptExtension.instance().extractName(log)
						+ "" | split: ..."");
		return filteredLog;
	}

}
"
LogPartitionerPlugin.java,log-skeleton,"package org.processmining.logskeleton.plugins;

import org.deckfour.xes.classification.XEventClassifier;
import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.model.XLog;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.log.models.EventLogArray;
import org.processmining.logskeleton.algorithms.LogPartitionerAlgorithm;
import org.processmining.logskeleton.classifiers.LogSkeletonClassifier;

@Plugin(name = ""Partition Log on Activity Sets"", icon = ""prom_duck_300.png"", url = ""http://www.win.tue.nl/~hverbeek"", parameterLabels = {
		""Event log"" }, returnLabels = { ""Event Log Array"" }, returnTypes = {
				EventLogArray.class }, userAccessible = true, help = ""Filter Event Log on Log Skeleton"")
public class LogPartitionerPlugin extends LogPartitionerAlgorithm {

	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""H.M.W. Verbeek"", email = ""h.m.w.verbeek@tue.nl"")
	@PluginVariant(variantLabel = ""Default"", requiredParameterLabels = { 0 })
	public EventLogArray run(PluginContext context, XLog log) {
		return run(context, log, new LogSkeletonClassifier());
	}

	public EventLogArray run(PluginContext context, XLog log, XEventClassifier classifier) {
		EventLogArray logs = apply(log, classifier);
		for (int i = 0; i < logs.getSize(); i++) {
			context.getProvidedObjectManager().createProvidedObject(
					XConceptExtension.instance().extractName(logs.getLog(i)), logs.getLog(i), XLog.class, context);
		}
		return logs;
	}

}
"
LogSkeletonBrowserPlugin.java,log-skeleton,"package org.processmining.logskeleton.plugins;

import java.awt.Dimension;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import javax.swing.DefaultListModel;
import javax.swing.JCheckBox;
import javax.swing.JComponent;
import javax.swing.JFrame;
import javax.swing.JPanel;
import javax.swing.ListSelectionModel;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
import javax.swing.event.ListSelectionEvent;
import javax.swing.event.ListSelectionListener;

import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.contexts.uitopia.annotations.Visualizer;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.framework.util.ui.widgets.ProMList;
import org.processmining.logskeleton.models.LogSkeleton;
import org.processmining.logskeleton.parameters.LogSkeletonBrowser;
import org.processmining.logskeleton.parameters.LogSkeletonBrowserParameters;
import org.processmining.plugins.graphviz.visualisation.DotPanel;

import com.fluxicon.slickerbox.components.NiceSlider;
import com.fluxicon.slickerbox.components.NiceSlider.Orientation;
import com.fluxicon.slickerbox.components.SlickerButton;
import com.fluxicon.slickerbox.factory.SlickerFactory;

import info.clearthought.layout.TableLayout;
import info.clearthought.layout.TableLayoutConstants;

@Plugin(name = ""Log Skeleton Browser"", parameterLabels = { ""Log Skeleton"" }, returnLabels = {
		""Log Skeleton Browser"" }, returnTypes = {
				JComponent.class }, userAccessible = true, help = ""Log Skeleton Browser"")
@Visualizer
public class LogSkeletonBrowserPlugin {

	private LogSkeleton model;
	private LogSkeletonBrowserParameters parameters = new LogSkeletonBrowserParameters();
	private JComponent leftDotPanel = null;
	private JComponent rightDotPanel = null;
	private JPanel mainPanel = null;

	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""H.M.W. Verbeek"", email = ""h.m.w.verbeek@tue.nl"")
	@PluginVariant(variantLabel = ""Default"", requiredParameterLabels = { 0 })
	public JComponent run(UIPluginContext context, final LogSkeleton model) {

		this.model = model;

		mainPanel = new JPanel();
		double size[][] = { { TableLayoutConstants.FILL, 250 }, { TableLayoutConstants.FILL, TableLayoutConstants.FILL,
				TableLayoutConstants.FILL, 30, 30, 30, 30, 30, 30, 30, 30 } };
		mainPanel.setLayout(new TableLayout(size));
		mainPanel.setOpaque(false);

		DefaultListModel<String> activities = new DefaultListModel<String>();
		int[] selectedIndices = new int[model.getActivities().size()];
		int i = 0;
		for (String activity : model.getActivities()) {
			activities.addElement(activity);
			selectedIndices[i] = i;
			i++;
		}
		final ProMList<String> activityList = new ProMList<String>(""View Activities"", activities);
		activityList.setSelectionMode(ListSelectionModel.MULTIPLE_INTERVAL_SELECTION);
		activityList.setSelectedIndices(selectedIndices);
		parameters.getActivities().addAll(model.getActivities());
		activityList.addListSelectionListener(new ListSelectionListener() {
			public void valueChanged(ListSelectionEvent e) {
				List<String> selectedActivities = activityList.getSelectedValuesList();
				if (!selectedActivities.equals(parameters.getActivities())) {
					System.out.println(""[LogSkeletonBrowserPlugin] Selected nodes = "" + selectedActivities);
					parameters.getActivities().clear();
					parameters.getActivities().addAll(selectedActivities);
					updateRight();
				}
			}
		});
		activityList.setPreferredSize(new Dimension(100, 100));
		mainPanel.add(activityList, ""1, 0, 1, 1"");

		boolean doNotUseNotCoExistence = model.hasManyNotCoExistenceArcs(parameters);

		List<LogSkeletonBrowser> list = Arrays.asList(LogSkeletonBrowser.values());
		DefaultListModel<LogSkeletonBrowser> visualizers = new DefaultListModel<LogSkeletonBrowser>();
		for (LogSkeletonBrowser visualizer : list) {
			visualizers.addElement(visualizer);
		}
		final ProMList<LogSkeletonBrowser> visualizerList = new ProMList<LogSkeletonBrowser>(""View Constraints"",
				visualizers);
		visualizerList.setSelectionMode(ListSelectionModel.MULTIPLE_INTERVAL_SELECTION);
		List<LogSkeletonBrowser> selectedVisualizers = new ArrayList<LogSkeletonBrowser>();
		selectedIndices = new int[doNotUseNotCoExistence ? 4 : 5];
		//		selectedVisualizers.add(LogSkeletonBrowser.ALWAYSTOGETHER);
		//		selectedIndices[0] = list.indexOf(LogSkeletonBrowser.ALWAYSTOGETHER);
		selectedVisualizers.add(LogSkeletonBrowser.ALWAYSBEFORE);
		selectedIndices[0] = list.indexOf(LogSkeletonBrowser.ALWAYSBEFORE);
		selectedVisualizers.add(LogSkeletonBrowser.ALWAYSAFTER);
		selectedIndices[1] = list.indexOf(LogSkeletonBrowser.ALWAYSAFTER);
		selectedVisualizers.add(LogSkeletonBrowser.NEVERBEFORE);
		selectedIndices[2] = list.indexOf(LogSkeletonBrowser.NEVERBEFORE);
		selectedVisualizers.add(LogSkeletonBrowser.NEVERAFTER);
		selectedIndices[3] = list.indexOf(LogSkeletonBrowser.NEVERAFTER);
		if (!doNotUseNotCoExistence) {
			/*
			 * Only include in the first visualization if not too many Not Co-Existence constraints.
			 */
			selectedVisualizers.add(LogSkeletonBrowser.NEVERTOGETHER);
			selectedIndices[4] = list.indexOf(LogSkeletonBrowser.NEVERTOGETHER);
		}
		visualizerList.setSelectedIndices(selectedIndices);
		parameters.getVisualizers().addAll(selectedVisualizers);
		visualizerList.addListSelectionListener(new ListSelectionListener() {
			public void valueChanged(ListSelectionEvent e) {
				List<LogSkeletonBrowser> selectedVisualizers = visualizerList.getSelectedValuesList();
				if (!selectedVisualizers.equals(parameters.getVisualizers())) {
					System.out.println(""[LogSkeletonBrowserPlugin] Selected edges = "" + selectedVisualizers);
					parameters.getVisualizers().clear();
					parameters.getVisualizers().addAll(selectedVisualizers);
					updateRight();
				}
			}
		});
		visualizerList.setPreferredSize(new Dimension(100, 100));
		mainPanel.add(visualizerList, ""1, 2"");

		final JCheckBox checkBox = SlickerFactory.instance().createCheckBox(""Use Hyper Arcs (may be slow...)"", false);
		checkBox.setSelected(parameters.isUseHyperArcs());
		checkBox.addActionListener(new ActionListener() {

			public void actionPerformed(ActionEvent e) {
				parameters.setUseHyperArcs(checkBox.isSelected());
				updateRight();
			}

		});
		checkBox.setOpaque(false);
		checkBox.setPreferredSize(new Dimension(100, 30));
		mainPanel.add(checkBox, ""1, 4"");

		final JCheckBox checkBoxFalseConstraints = SlickerFactory.instance().createCheckBox(""Use False Constraints"",
				false);
		checkBoxFalseConstraints.setSelected(parameters.isUseFalseConstraints());
		checkBoxFalseConstraints.addActionListener(new ActionListener() {

			public void actionPerformed(ActionEvent e) {
				parameters.setUseFalseConstraints(checkBoxFalseConstraints.isSelected());
				updateRight();
			}

		});
		checkBoxFalseConstraints.setOpaque(false);
		checkBoxFalseConstraints.setPreferredSize(new Dimension(100, 30));
		mainPanel.add(checkBoxFalseConstraints, ""1, 5"");

		final JCheckBox checkBoxEdgeColors = SlickerFactory.instance().createCheckBox(""Use Edge Colors"", false);
		checkBoxEdgeColors.setSelected(parameters.isUseEdgeColors());
		checkBoxEdgeColors.addActionListener(new ActionListener() {

			public void actionPerformed(ActionEvent e) {
				parameters.setUseEdgeColors(checkBoxEdgeColors.isSelected());
				updateRight();
			}

		});
		checkBoxEdgeColors.setOpaque(false);
		checkBoxEdgeColors.setPreferredSize(new Dimension(100, 30));
		mainPanel.add(checkBoxEdgeColors, ""1, 6"");

		final JCheckBox checkBoxEquivalenceClass = SlickerFactory.instance().createCheckBox(""Use Equivalence Class"",
				false);
		checkBoxEquivalenceClass.setSelected(parameters.isUseEquivalenceClass());
		checkBoxEquivalenceClass.addActionListener(new ActionListener() {

			public void actionPerformed(ActionEvent e) {
				parameters.setUseEquivalenceClass(checkBoxEquivalenceClass.isSelected());
				updateRight();
			}

		});
		checkBoxEquivalenceClass.setOpaque(false);
		checkBoxEquivalenceClass.setPreferredSize(new Dimension(100, 30));
		mainPanel.add(checkBoxEquivalenceClass, ""1, 7"");

		final JCheckBox checkBoxLabels = SlickerFactory.instance().createCheckBox(""Use Head/Tail Labels"", false);
		checkBoxLabels.setSelected(parameters.isUseHeadTailLabels());
		checkBoxLabels.addActionListener(new ActionListener() {

			public void actionPerformed(ActionEvent e) {
				parameters.setUseHeadTailLabels(checkBoxLabels.isSelected());
				updateRight();
			}

		});
		checkBoxLabels.setOpaque(false);
		checkBoxLabels.setPreferredSize(new Dimension(100, 30));
		mainPanel.add(checkBoxLabels, ""1, 8"");

		final JCheckBox checkBoxNeighbors = SlickerFactory.instance().createCheckBox(""Show Neighbors"", false);
		checkBoxNeighbors.setSelected(parameters.isUseNeighbors());
		checkBoxNeighbors.addActionListener(new ActionListener() {

			public void actionPerformed(ActionEvent e) {
				parameters.setUseNeighbors(checkBoxNeighbors.isSelected());
				updateRight();
			}

		});
		checkBoxNeighbors.setOpaque(false);
		checkBoxNeighbors.setPreferredSize(new Dimension(100, 30));
		mainPanel.add(checkBoxNeighbors, ""1, 9"");

		final NiceSlider noiseLevelSlider = SlickerFactory.instance().createNiceIntegerSlider(""Noise Level in %"",
				0, 20, 100 - parameters.getPrecedenceThreshold(), Orientation.HORIZONTAL);
		noiseLevelSlider.addChangeListener(new ChangeListener() {

			public void stateChanged(ChangeEvent e) {
				int value = 100 - noiseLevelSlider.getSlider().getValue();
				model.setEquivalenceThreshold(value);
				parameters.setPrecedenceThreshold(value);
				parameters.setResponseThreshold(value);
				model.setPrecedenceThreshold(value);
				model.setResponseThreshold(value);
				parameters.setNotCoExistenceThreshold(value);
				model.setNotCoExistenceThreshold(value);
				model.cleanPrePost();
				updateRight();
			}
		});
		noiseLevelSlider.setPreferredSize(new Dimension(100, 30));
		mainPanel.add(noiseLevelSlider, ""1, 3"");

//		final NiceSlider notCoExistenceThresholdSlider = SlickerFactory.instance().createNiceIntegerSlider(
//				""NCE Threshold"", 80, 100, parameters.getPrecedenceThreshold(), Orientation.HORIZONTAL);
//		notCoExistenceThresholdSlider.addChangeListener(new ChangeListener() {
//
//			public void stateChanged(ChangeEvent e) {
//				parameters.setNotCoExistenceThreshold(notCoExistenceThresholdSlider.getSlider().getValue());
//				model.setNotCoExistenceThreshold(notCoExistenceThresholdSlider.getSlider().getValue());
//				updateRight();
//			}
//		});
//		notCoExistenceThresholdSlider.setPreferredSize(new Dimension(100, 30));
//		mainPanel.add(notCoExistenceThresholdSlider, ""1, 10"");
//
		final SlickerButton button = new SlickerButton(""View Log Skeleton in New Window"");
		button.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				updateLeft();
			}

		});
		mainPanel.add(button, ""1, 10"");

		//		updateLeft();
		updateRight();
		return mainPanel;
	}

	private void updateLeft() {
		//		if (leftDotPanel != null) {
		//			mainPanel.remove(leftDotPanel);
		//		}
		model.setPrecedenceThreshold(parameters.getPrecedenceThreshold());
		model.setResponseThreshold(parameters.getResponseThreshold());
		model.setNotCoExistenceThreshold(parameters.getNotCoExistenceThreshold());
		leftDotPanel = new DotPanel(model.createGraph(parameters));
		//		mainPanel.add(leftDotPanel, ""0, 0, 0, 3"");
		//		mainPanel.validate();
		//		mainPanel.repaint();
		JFrame frame = new JFrame();
		frame.add(leftDotPanel);
		frame.setTitle(""Log Skeleton Viewer on "" + model.getLabel());
		frame.setSize(1024, 768);
		frame.setVisible(true);
	}

	private void updateRight() {
		if (rightDotPanel != null) {
			mainPanel.remove(rightDotPanel);
		}
		rightDotPanel = new DotPanel(model.visualize(parameters));
		mainPanel.add(rightDotPanel, ""0, 0, 0, 10"");
		mainPanel.validate();
		mainPanel.repaint();

	}
}"
LogSkeletonBuilderPlugin.java,log-skeleton,"package org.processmining.logskeleton.plugins;

import org.deckfour.xes.classification.XEventClassifier;
import org.deckfour.xes.model.XLog;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.logskeleton.algorithms.LogSkeletonBuilderAlgorithm;
import org.processmining.logskeleton.classifiers.LogSkeletonClassifier;
import org.processmining.logskeleton.models.LogSkeleton;

@Plugin(name = ""Build Log Skeleton from Event Log"", icon = ""prom_duck_300.png"", url = ""http://www.win.tue.nl/~hverbeek"", parameterLabels = { ""Event log""}, returnLabels = { ""Log Skeleton"" }, returnTypes = { LogSkeleton.class }, userAccessible = true, help = ""Create Log Skeleton from Event Log"")
public class LogSkeletonBuilderPlugin extends LogSkeletonBuilderAlgorithm  {

	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""H.M.W. Verbeek"", email = ""h.m.w.verbeek@tue.nl"")
	@PluginVariant(variantLabel = ""Default"", requiredParameterLabels = { 0 })
	public LogSkeleton run(PluginContext context, XLog log) {
		return apply(log, new LogSkeletonClassifier());
	}

	public LogSkeleton run(PluginContext context, XLog log, XEventClassifier classifier) {
		return apply(log, classifier);
	}
}
"
LogSkeletonCheckerPlugin.java,log-skeleton,"package org.processmining.logskeleton.plugins;

import java.util.HashSet;
import java.util.Set;

import org.deckfour.xes.classification.XEventClassifier;
import org.deckfour.xes.model.XLog;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.logskeleton.algorithms.LogSkeletonCheckerAlgorithm;
import org.processmining.logskeleton.classifiers.LogSkeletonClassifier;
import org.processmining.logskeleton.models.LogSkeleton;

@Plugin(name = ""Filter Event Log on Log Skeleton"", icon = ""prom_duck_300.png"", url = ""http://www.win.tue.nl/~hverbeek"", parameterLabels = { ""Log Skeleton"", ""Event log""}, returnLabels = { ""Filtered Event Log"" }, returnTypes = { XLog.class }, userAccessible = true, help = ""Filter Event Log on Log Skeleton"")
public class LogSkeletonCheckerPlugin extends LogSkeletonCheckerAlgorithm {

	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""H.M.W. Verbeek"", email = ""h.m.w.verbeek@tue.nl"")
	@PluginVariant(variantLabel = ""Default"", requiredParameterLabels = { 0, 1 })
	public XLog run(PluginContext context, LogSkeleton model, XLog log) {
		return run(context, model, log, new LogSkeletonClassifier());
	}

	public XLog run(PluginContext context, LogSkeleton model, XLog log, XEventClassifier classifier) {
		boolean[] checks = new boolean[] { true, true, true };
		return run(context, model, log, classifier, new HashSet<String>(), checks);
	}

	public XLog run(PluginContext context, LogSkeleton model, XLog log, Set<String> messages, boolean[] checks) {
		XEventClassifier classifier = new LogSkeletonClassifier();
		return run(context, model, log, classifier, messages, checks);
	}

	public XLog run(PluginContext context, LogSkeleton model, XLog log, XEventClassifier classifier, Set<String> messages, boolean[] checks) {
		return apply(model, log, classifier, messages, checks);
	}
}
"
LogSkeletonClassifierPlugin.java,log-skeleton,"package org.processmining.logskeleton.plugins;

import org.deckfour.xes.classification.XEventClassifier;
import org.deckfour.xes.model.XLog;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.logskeleton.algorithms.LogPreprocessorAlgorithm;
import org.processmining.logskeleton.algorithms.LogSkeletonClassifierAlgorithm;
import org.processmining.logskeleton.classifiers.LogSkeletonClassifier;

@Plugin(name = ""Classify Test Log using Log Skeleton"", icon = ""prom_duck_300.png"", url = ""http://www.win.tue.nl/~hverbeek"", parameterLabels = { ""Training Event log"", ""Test Event Log""}, returnLabels = { ""Classified Event Log"" }, returnTypes = { XLog.class }, userAccessible = true, help = ""Filter Event Log on Log Skeleton"")
public class LogSkeletonClassifierPlugin extends LogSkeletonClassifierAlgorithm {

	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""H.M.W. Verbeek"", email = ""h.m.w.verbeek@tue.nl"")
	@PluginVariant(variantLabel = ""Default"", requiredParameterLabels = { 0, 1 })
	public XLog run(PluginContext context, XLog trainingLog, XLog testLog) {
		return run(context, trainingLog, testLog, new LogSkeletonClassifier());
	}

	public XLog run(PluginContext context, XLog trainingLog, XLog testLog, XEventClassifier classifier) {
		return apply(context, trainingLog, testLog, classifier, new LogPreprocessorAlgorithm());
	}

}
"
LogSkeletonExportPlugin.java,log-skeleton,"package org.processmining.logskeleton.plugins;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.Writer;

import org.processmining.contexts.uitopia.annotations.UIExportPlugin;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.logskeleton.models.LogSkeleton;

import com.csvreader.CsvWriter;

@Plugin(name = ""Export Log Skeleton"", returnLabels = {}, returnTypes = {}, parameterLabels = {
		""Log Skeleton"", ""File"" }, userAccessible = true)
@UIExportPlugin(description = ""Log Skeleton"", extension = ""lsk"")
public class LogSkeletonExportPlugin {
	
	@PluginVariant(variantLabel = ""Export Log Skeleton"", requiredParameterLabels = { 0, 1 })
	public void export(PluginContext context, LogSkeleton logSkeleton, File file) throws IOException {
		Writer fileWriter = new FileWriter(file);
		CsvWriter csvWriter = new CsvWriter(fileWriter, ',');
		logSkeleton.exportToFile(csvWriter);
		csvWriter.close();
	}
}
"
LogSkeletonFilterBrowserPlugin.java,log-skeleton,"package org.processmining.logskeleton.plugins;

import java.awt.Component;
import java.awt.Dimension;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import javax.swing.DefaultListModel;
import javax.swing.JComponent;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.ListSelectionModel;
import javax.swing.SwingConstants;
import javax.swing.event.ListSelectionEvent;
import javax.swing.event.ListSelectionListener;

import org.deckfour.xes.classification.XEventClassifier;
import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.factory.XFactoryRegistry;
import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.contexts.uitopia.annotations.Visualizer;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.framework.util.ui.widgets.ProMList;
import org.processmining.framework.util.ui.widgets.ProMTextField;
import org.processmining.framework.util.ui.widgets.WidgetColors;
import org.processmining.logskeleton.algorithms.LogSkeletonBuilderAlgorithm;
import org.processmining.logskeleton.algorithms.SplitterAlgorithm;
import org.processmining.logskeleton.classifiers.LogSkeletonClassifier;
import org.processmining.logskeleton.models.LogSkeleton;
import org.processmining.logskeleton.parameters.SplitterParameters;

import com.fluxicon.slickerbox.components.RoundedPanel;
import com.fluxicon.slickerbox.components.SlickerButton;

import info.clearthought.layout.TableLayout;
import info.clearthought.layout.TableLayoutConstants;

@Plugin(name = ""Log Skeleton Filter and Browser"", parameterLabels = { ""Event Log"" }, returnLabels = { ""Log Skeleton Filter and Browser"" }, returnTypes = { JComponent.class }, userAccessible = true, help = ""Log Skeleton Filter and Browser"")
@Visualizer
public class LogSkeletonFilterBrowserPlugin {

	private UIPluginContext context;
	private XLog log;
	private JComponent rightPanel = null;
	private JPanel mainPanel = null;
	private List<List<String>> splitters;
	private Set<String> positiveFilters;
	private Set<String> negativeFilters;
	
	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""H.M.W. Verbeek"", email = ""h.m.w.verbeek@tue.nl"")
	@PluginVariant(variantLabel = ""Default"", requiredParameterLabels = { 0 })
	public JComponent run(UIPluginContext context, XLog log) {
		return run(context, log, new LogSkeletonClassifier());
	}
	
	public JComponent run(UIPluginContext context, XLog log, XEventClassifier classifier) {
		this.context = context;
		this.log = log;
		
		mainPanel = new JPanel();
		double size[][] = { { 250, TableLayoutConstants.FILL }, { TableLayoutConstants.FILL } };
		mainPanel.setLayout(new TableLayout(size));
		mainPanel.setOpaque(false);

		splitters = new ArrayList<List<String>>();
		positiveFilters = new HashSet<String>();
		negativeFilters = new HashSet<String>();

		mainPanel.add(getControlPanel(classifier), ""0, 0"");

		update(classifier);

		provideInfo(log, classifier);
		
		return mainPanel;
	}

	private void provideInfo(XLog log, XEventClassifier classifier) {
		Map<Set<String>, Double> scores = new HashMap<Set<String>, Double>();
		double maxScore = 0;
		for (XTrace trace : log) {
			Set<String> score = new HashSet<String>();
			for (XEvent event : trace) {
				score.add(classifier.getClassIdentity(event));
			}
			if (!scores.containsKey(score)) {
				scores.put(score, 1.0 / (trace.size() + 1));
			} else {
				scores.put(score, scores.get(score) + (1.0 / (trace.size() + 1)));
			}
			if (scores.get(score) > maxScore) {
				maxScore = scores.get(score);
			}
		}
		for (Set<String> count : scores.keySet()) {
			if (scores.get(count) == maxScore) {
				System.out.println(""[LogSkeletonFilterBrowserPlugin] "" + maxScore + "": "" + count);
			}
		}
	}
	
	private void update(XEventClassifier classifier) {
		SplitterAlgorithm splitterAlgorithm = new SplitterAlgorithm();
		SplitterParameters splitterParameters = new SplitterParameters();
		XLog filteredLog = log;

		if (!positiveFilters.isEmpty() || !negativeFilters.isEmpty()) {
			filteredLog = filter(filteredLog, classifier, positiveFilters, negativeFilters);
		}
		for (List<String> splitter : splitters) {
			splitterParameters.setDuplicateActivity(splitter.get(0));
			splitterParameters.getMilestoneActivities().clear();
			for (int i = 1; i < splitter.size(); i++) {
				splitterParameters.getMilestoneActivities().add(splitter.get(i));
			}
			filteredLog = splitterAlgorithm.apply(filteredLog, classifier, splitterParameters);
		}
		LogSkeletonBuilderAlgorithm discoveryAlgorithm = new LogSkeletonBuilderAlgorithm();
		context.getProvidedObjectManager().createProvidedObject(XConceptExtension.instance().extractName(filteredLog) + "" Split"", filteredLog, XLog.class, context);
		LogSkeleton model = discoveryAlgorithm.apply(filteredLog, classifier);
		model.setRequired(positiveFilters);
		model.setForbidden(negativeFilters);
		model.setSplitters(splitters);
		LogSkeletonBrowserPlugin visualizerPlugin = new LogSkeletonBrowserPlugin();
		if (rightPanel != null) {
			mainPanel.remove(rightPanel);
		}
		rightPanel = visualizerPlugin.run(context, model);
		mainPanel.add(rightPanel, ""1, 0"");
		mainPanel.validate();
		mainPanel.repaint();
	}

	private XLog filter(XLog log, XEventClassifier classifier, Set<String> positiveFilters, Set<String> negativeFilters) {
		XLog filteredLog = XFactoryRegistry.instance().currentDefault().createLog(log.getAttributes());
		XLog discardedLog = XFactoryRegistry.instance().currentDefault().createLog(log.getAttributes());
		for (XTrace trace : log) {
			boolean ok = true;
			Set<String> toMatch = new HashSet<String>(positiveFilters);
			for (XEvent event : trace) {
				String activity = classifier.getClassIdentity(event);
				if (negativeFilters.contains(activity)) {
					ok = false;
					;
				}
				toMatch.remove(activity);
			}
			if (ok && toMatch.isEmpty()) {
				filteredLog.add(trace);
			} else {
				discardedLog.add(trace);
			}
		}
		context.getProvidedObjectManager().createProvidedObject(XConceptExtension.instance().extractName(filteredLog) + "" In"", filteredLog, XLog.class, context);
		context.getProvidedObjectManager().createProvidedObject(XConceptExtension.instance().extractName(discardedLog) + "" Out"", discardedLog, XLog.class, context);
		return filteredLog;
	}

	private List<String> getActivities(XLog log, XEventClassifier classifier) {
		Set<String> activities = new HashSet<String>();
		for (XTrace trace : log) {
			for (XEvent event : trace) {
				String activity = classifier.getClassIdentity(event);
				activities.add(activity);
			}
		}
		List<String> activityList = new ArrayList<String>(activities);
		Collections.sort(activityList);
		return activityList;
	}

	private JComponent getControlPanel(final XEventClassifier classifier) {
		JPanel controlPanel = new JPanel();
		List<String> activities = getActivities(log, classifier);
		double size[][] = { { TableLayoutConstants.FILL },
				{ TableLayoutConstants.FILL, TableLayoutConstants.FILL, TableLayoutConstants.FILL, 30 } };
		controlPanel.setLayout(new TableLayout(size));
		controlPanel.setOpaque(false);
		controlPanel.setBackground(WidgetColors.COLOR_LIST_BG);
		controlPanel.setForeground(WidgetColors.COLOR_LIST_FG);

		DefaultListModel<String> requiredActivityModel = new DefaultListModel<String>();
		for (String activity : activities) {
			requiredActivityModel.addElement(activity);
		}
		final ProMList<String> requiredActivityList = new ProMList<String>(""Required Activities Filter"", requiredActivityModel);
		requiredActivityList.setSelectionMode(ListSelectionModel.MULTIPLE_INTERVAL_SELECTION);
		requiredActivityList.addListSelectionListener(new ListSelectionListener() {
			public void valueChanged(ListSelectionEvent e) {
				List<String> selectedActivities = requiredActivityList.getSelectedValuesList();
				positiveFilters.clear();
				positiveFilters.addAll(selectedActivities);
			}
		});
		requiredActivityList.setPreferredSize(new Dimension(100, 100));
		controlPanel.add(requiredActivityList, ""0, 0"");

		DefaultListModel<String> forbiddenActivityModel = new DefaultListModel<String>();
		for (String activity : activities) {
			forbiddenActivityModel.addElement(activity);
		}
		final ProMList<String> forbiddenActivityList = new ProMList<String>(""Forbidden Activities Filter"",
				forbiddenActivityModel);
		forbiddenActivityList.setSelectionMode(ListSelectionModel.MULTIPLE_INTERVAL_SELECTION);
		forbiddenActivityList.addListSelectionListener(new ListSelectionListener() {
			public void valueChanged(ListSelectionEvent e) {
				List<String> selectedActivities = forbiddenActivityList.getSelectedValuesList();
				negativeFilters.clear();
				negativeFilters.addAll(selectedActivities);
			}
		});
		forbiddenActivityList.setPreferredSize(new Dimension(100, 100));
		controlPanel.add(forbiddenActivityList, ""0, 1"");

		RoundedPanel splitterPanel = new RoundedPanel(10, 5, 0);
		splitterPanel.setPreferredSize(new Dimension(100, 100));
		double splitterSize[][] = {
				{ TableLayoutConstants.FILL, TableLayoutConstants.FILL },
				{ 30, TableLayoutConstants.FILL, TableLayoutConstants.FILL,
						TableLayoutConstants.FILL, TableLayoutConstants.FILL, TableLayoutConstants.FILL,
						TableLayoutConstants.FILL, TableLayoutConstants.FILL, TableLayoutConstants.FILL,
						TableLayoutConstants.FILL, TableLayoutConstants.FILL } };
		splitterPanel.setLayout(new TableLayout(splitterSize));
		splitterPanel.setBackground(WidgetColors.COLOR_ENCLOSURE_BG);
		splitterPanel.setForeground(WidgetColors.COLOR_LIST_FG);

		splitterPanel.setOpaque(false);
		JLabel splitterLabel = new JLabel(""Activity Splitters"");
		splitterLabel.setOpaque(false);
		splitterLabel.setForeground(WidgetColors.COLOR_LIST_SELECTION_FG);
		splitterLabel.setFont(splitterLabel.getFont().deriveFont(13f));
		splitterLabel.setAlignmentX(Component.CENTER_ALIGNMENT);
		splitterLabel.setHorizontalAlignment(SwingConstants.CENTER);
		splitterLabel.setHorizontalTextPosition(SwingConstants.CENTER);

		splitterPanel.add(splitterLabel, ""0, 0, 1, 0"");
		final ProMTextField inputs[][] = new ProMTextField[2][10];
		for (int row = 0; row < 10; row++) {
			for (int col = 0; col < 2; col++) {
				inputs[col][row] = new ProMTextField("""", (col == 0 ? ""Split Activity "" : ""Over Activity "") + (1 + col + 2*row));
				splitterPanel.add(inputs[col][row], """" + col + "", "" + (row + 1));
			}
		}
		controlPanel.add(splitterPanel, ""0, 2"");

		final SlickerButton button = new SlickerButton(""Apply Settings"");
		button.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				splitters = new ArrayList<List<String>>();
				for (int row = 0; row < 10; row++) {
					List<String> filter = new ArrayList<String>();
					for (int col = 0; col < 2; col++) {
						filter.add(inputs[col][row].getText());
					}
					if (!filter.get(0).isEmpty() && !filter.get(1).isEmpty()) {
						System.out.println(""[LogSkeletonFilterBrowserPlugin] Filter added: "" + filter);
						splitters.add(filter);
					}
				}
				update(classifier);
			}

		});
		controlPanel.add(button, ""0, 3"");

		return controlPanel;
	}

}
"
LogSkeletonImportPlugin.java,log-skeleton,"package org.processmining.logskeleton.plugins;

import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.Reader;

import javax.swing.filechooser.FileFilter;
import javax.swing.filechooser.FileNameExtensionFilter;

import org.processmining.contexts.uitopia.annotations.UIImportPlugin;
import org.processmining.framework.abstractplugins.AbstractImportPlugin;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.logskeleton.models.LogSkeleton;

import com.csvreader.CsvReader;

@Plugin(name = ""Import Log Skeleton"", parameterLabels = { ""Filename"" }, returnLabels = { ""Log Skeleton"" }, returnTypes = { LogSkeleton.class })
@UIImportPlugin(description = ""Log Skeleton files"", extensions = { ""lsk"" })
public class LogSkeletonImportPlugin extends AbstractImportPlugin {

	protected FileFilter getFileFilter() {
		return new FileNameExtensionFilter(""Log Skeleton files"", ""lsk"");
	}

	protected Object importFromStream(PluginContext context, InputStream input, String filename, long fileSizeInBytes)
			throws Exception {
		Reader streamReader = new InputStreamReader(input);
		CsvReader csvReader = new CsvReader(streamReader);
		LogSkeleton logSkeleton = new LogSkeleton();
		logSkeleton.importFromStream(csvReader);
		return logSkeleton;
	}
	
}
"
LogSkeletonVisualizerPlugin.java,log-skeleton,"package org.processmining.logskeleton.plugins;

import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

import javax.swing.JComponent;
import javax.swing.JPanel;

import org.deckfour.xes.classification.XEventAttributeClassifier;
import org.deckfour.xes.classification.XEventClassifier;
import org.deckfour.xes.model.XLog;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.contexts.uitopia.annotations.Visualizer;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.framework.util.ui.widgets.ProMTextField;
import org.processmining.logskeleton.classifiers.LogSkeletonClassifier;

import com.fluxicon.slickerbox.components.SlickerButton;

import info.clearthought.layout.TableLayout;
import info.clearthought.layout.TableLayoutConstants;

@Plugin(name = ""Log Skeleton Visualizer"", parameterLabels = { ""Event Log"" }, returnLabels = { ""Log Skeleton Visualizer"" }, returnTypes = { JComponent.class }, userAccessible = true, help = ""Log Skeleton Visualizer"")
@Visualizer
public class LogSkeletonVisualizerPlugin {

	private UIPluginContext context;
	private XLog log;
	private XEventClassifier classifier;
	private JComponent mainPanel;
	private JComponent bottomPanel = null;
	
	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""H.M.W. Verbeek"", email = ""h.m.w.verbeek@tue.nl"")
	@PluginVariant(variantLabel = ""Default"", requiredParameterLabels = { 0 })
	public JComponent run(UIPluginContext context, XLog log) {
		this.context = context;
		this.log = log;
		
		mainPanel = new JPanel();
		double size[][] = { { TableLayoutConstants.FILL }, { 30, TableLayoutConstants.FILL } };
		mainPanel.setLayout(new TableLayout(size));
		mainPanel.setOpaque(false);

		classifier = new LogSkeletonClassifier();

		mainPanel.add(getControlPanel(), ""0, 0"");

		update();

		return mainPanel;
	}
	
	private void update() {
		LogSkeletonFilterBrowserPlugin filterBrowser = new LogSkeletonFilterBrowserPlugin();
		if (bottomPanel != null) {
			mainPanel.remove(bottomPanel);
		}
		bottomPanel = filterBrowser.run(context, log, classifier);
		mainPanel.add(bottomPanel, ""0, 1"");
		mainPanel.validate();
		mainPanel.repaint();
	}
	
	private JComponent getControlPanel() {
		JPanel controlPanel = new JPanel();
		double size[][] = { { 250, TableLayoutConstants.FILL }, { TableLayoutConstants.FILL } };
		controlPanel.setLayout(new TableLayout(size));
		controlPanel.setOpaque(false);
		
		String[] keys = classifier.getDefiningAttributeKeys();
		String text = """";
		String sep = """";
		for (int i = 0; i < keys.length; i++) {
			text += sep + keys[i];
			sep = "" "";
		}
		final ProMTextField input = new ProMTextField(text);
		controlPanel.add(input, ""1, 0"");

		final SlickerButton button = new SlickerButton(""Apply Classifier"");
		button.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				String keys[] = input.getText().split("" "");
				classifier = new LogSkeletonClassifier(new XEventAttributeClassifier(""classifier"", keys));
				update();
			}

		});
		controlPanel.add(button, ""0, 0"");

		return controlPanel;
	}
}
"
AbstractGraph.java,model,"package org.processmining.models.graphbased;

import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;

public class AbstractGraph extends AbstractGraphElement {

	protected final NodeID id = new NodeID();

	public AbstractGraph() {
		super();
	}

	public boolean equals(Object o) {
		if (!(o instanceof AbstractGraph)) {
			return false;
		}
		AbstractGraph net = (AbstractGraph) o;
		return net.id.equals(id);
	}

	protected synchronized <T> T removeNodeFromCollection(Collection<T> collection, T object) {
		for (T toRemove : collection) {
			if (toRemove.equals(object)) {
				collection.remove(toRemove);
				graphElementRemoved(object);
				return toRemove;
			}
		}
		return null;
	}

	/**
	 * Returns the edges from source to target, contained in the given
	 * collection
	 * 
	 * @param <T>
	 *            The type of edges
	 * @param source
	 *            the source node
	 * @param target
	 *            the target node
	 * @param collection
	 *            the collection of edges to search through
	 * @return
	 */
	protected <T extends AbstractGraphEdge<?, ?>> Collection<T> getEdges(AbstractGraphNode source,
			AbstractGraphNode target, Collection<T> collection) {
		Collection<T> s2t = new HashSet<T>();
		for (T a : collection) {
			if (a.getSource().equals(source) && a.getTarget().equals(target)) {
				s2t.add(a);
			}
		}
		return Collections.unmodifiableCollection(s2t);

	}

	protected synchronized <T extends AbstractGraphEdge<?, ?>> T removeFromEdges(AbstractGraphNode source,
			AbstractGraphNode target, Collection<T> collection) {
		for (T a : collection) {
			if (a.getSource().equals(source) && a.getTarget().equals(target)) {
				collection.remove(a);
				graphElementRemoved(a);
				return a;
			}
		}
		return null;
	}

	public int hashCode() {
		return id.hashCode();
	}

	public synchronized void graphElementAdded(Object element) {
		//		isLayedOut = false;
		//		elementsAdded.add(element);
	}

	public synchronized void graphElementRemoved(Object element) {
		//		elementsRemoved.add(element);
	}

	public synchronized void graphElementChanged(Object element) {
		//		elementsChanged.add(element);
	}

}
"
AbstractGraphEdge.java,model,"package org.processmining.models.graphbased;

import org.processmining.models.graphbased.directed.AbstractDirectedGraphEdge;

public abstract class AbstractGraphEdge<S, T> extends AbstractGraphElement implements
		Comparable<AbstractGraphEdge<S, T>> {

	protected final int hash;
	protected final S source;
	protected final T target;

	public AbstractGraphEdge(S source, T target) {
		super();
		this.source = source;
		this.target = target;
		this.hash = source.hashCode() + 37 * target.hashCode();
	}

	public int hashCode() {
		// Hashcode based on source and target, which
		// respects contract that this.equals(o) implies
		// this.hashCode()==o.hashCode()
		return hash;
	}

	public boolean equals(Object o) {
		if (!(this.getClass().equals(o.getClass()))) {
			return false;
		}
		AbstractDirectedGraphEdge<?, ?> edge = (AbstractDirectedGraphEdge<?, ?>) o;

		return edge.source.equals(source) && edge.target.equals(target);

	}

	public S getSource() {
		return source;
	}

	public T getTarget() {
		return target;
	}

}
"
AbstractGraphElement.java,model,"package org.processmining.models.graphbased;

public abstract class AbstractGraphElement implements AttributeMapOwner {

	private final AttributeMap map;

	public AbstractGraphElement() {
		map = new AttributeMap();
	}

	public String getLabel() {
		return map.get(AttributeMap.LABEL, ""no label"");
	}

	public AttributeMap getAttributeMap() {
		return map;
	}

	public String toString() {
		return getLabel();
	}

}
"
AbstractGraphNode.java,model,"package org.processmining.models.graphbased;

public abstract class AbstractGraphNode extends AbstractGraphElement {

	private final NodeID id = new NodeID();

	public AbstractGraphNode() {
		super();
	}

	public int hashCode() {
		return getId().hashCode();
	}

	public boolean equals(Object o) {
		if (!(o instanceof AbstractGraphNode)) {
			return false;
		}
		AbstractGraphNode node = (AbstractGraphNode) o;
		return node.getId().equals(getId());
	}

	public NodeID getId() {
		return id;
	}

}
"
AttributeMap.java,model,"package org.processmining.models.graphbased;

import java.util.LinkedHashMap;
import java.util.Map;
import java.util.Set;

public class AttributeMap {
	private final static String PREFIX = ""ProM_Vis_attr_"";

	public enum ArrowType {
		ARROWTYPE_CLASSIC(PREFIX + ""arrow_classic""), //
		ARROWTYPE_TECHNICAL(PREFIX + ""arrow_tech""), //
		ARROWTYPE_SIMPLE(PREFIX + ""arrow_simple""), //
		ARROWTYPE_DIAMOND(PREFIX + ""arrow_diamond""), //
		ARROWTYPE_CIRCLE(PREFIX + ""arrow_circle""), //
		ARROWTYPE_LINE(PREFIX + ""arrow_line""), //
		ARROWTYPE_DOUBLELINE(PREFIX + ""arrow_double""), //
		ARROWTYPE_NONE(PREFIX + ""arrow_none""), //
		ARROW_CROSS(PREFIX + ""arrow_cross""), //
		ARROW_TECHNICAL_CIRCLE(PREFIX + ""arrow_technical_circle"");

		ArrowType(String s) {
		}
	}

	public final static String SHAPE = PREFIX + ""shape"";
	public static final String SHAPEDECORATOR = PREFIX + ""ShapeDecorator"";

	public final static String FILLCOLOR = PREFIX + ""fillcolor"";
	public final static String GRADIENTCOLOR = PREFIX + ""gradientcolor"";
	public final static String ICON = PREFIX + ""icon"";
	public final static String BORDERWIDTH = PREFIX + ""border"";
	public final static String LABEL = PREFIX + ""label"";
	public final static String TOOLTIP = PREFIX + ""tooltip"";

	public final static String EDGESTART = PREFIX + ""edgestart"";
	public final static String EDGESTARTFILLED = PREFIX + ""edgeStartFilled"";

	public final static String EDGEEND = PREFIX + ""edge end"";
	public final static String EDGEENDFILLED = PREFIX + ""edgeEndFilled"";

	public final static String EDGEMIDDLE = PREFIX + ""edge middle"";
	public final static String EDGEMIDDLEFILLED = PREFIX + ""edgeMiddleFilled"";

	public final static String LABELVERTICALALIGNMENT = PREFIX + ""labelVerticalAlignment"";
	public final static String EDGECOLOR = PREFIX + ""edgeColor""; // added by arya
	public final static String STROKECOLOR = PREFIX + ""strokeColor""; // added by arya

	public final static String INSET = PREFIX + ""inset""; // added by jribeiro
	public final static String STROKE = PREFIX + ""stroke""; // added by jribeiro
	public final static String DASHPATTERN = PREFIX + ""dashPattern""; // added by jribeiro
	public final static String DASHOFFSET = PREFIX + ""dashOffset""; // added by jribeiro
	public final static String LABELCOLOR = PREFIX + ""labelColor""; // added by jribeiro
	public final static String LABELALONGEDGE = PREFIX + ""labelAlongEdge""; // added by jribeiro

	/**
	 * A Float representing the linewidth of a line.
	 */
	public final static String LINEWIDTH = PREFIX + ""lineWidth"";
	public final static String NUMLINES = PREFIX + ""numLines"";

	public final static String STYLE = PREFIX + ""style"";

	public final static String POLYGON_POINTS = PREFIX + ""polygonpoints"";

	public static final String SQUAREBB = PREFIX + ""squareBB"";
	public static final String RESIZABLE = PREFIX + ""resizable"";
	public static final String AUTOSIZE = PREFIX + ""autosize"";
	public static final String SHOWLABEL = PREFIX + ""showLabel"";
	public static final String MOVEABLE = PREFIX + ""movable""; // added by arya

	/**
	 * This should be set to SwingConstants.SOUTH, SwingConstants.WEST and so
	 * on. SwingConstants.NORTH means the graph prefers drawn Top-Down
	 * SwingConstants.WEST means the graph prefers drawn Left to Right
	 */
	public static final String PREF_ORIENTATION = PREFIX + ""orientation"";
	public static final String LABELHORIZONTALALIGNMENT = PREFIX + ""horizontal alignment"";
	public static final String SIZE = ""size"";
	public static final String PORTOFFSET = ""portoffset"";

	/**
	 * The value of this attribute should be an array of type Point2D[]
	 * (size>0), as used in the method GraphConstants.setExtraLabelPositions()
	 */
	public static final String EXTRALABELPOSITIONS = ""Label positions"";
	/**
	 * The value of this attribute should be an array of type String[] (size>0),
	 * as used in the method GraphConstants.setExtraLabels()
	 */
	public static final String EXTRALABELS = ""Extra Labels"";

	/**
	 * Renderer to be used.
	 */
	public static final String RENDERER = ""Renderer"";

	private final Map<String, Object> mapping = new LinkedHashMap<String, Object>();

	public AttributeMap() {
	}

	public Object get(String key) {
		return mapping.get(key);
	}

	@SuppressWarnings(""unchecked"")
	public <T> T get(String key, T defaultValue) {
		synchronized (mapping) {
			Object o = mapping.get(key);
			if (o != null) {
				return (T) o;
			}
			if (mapping.containsKey(key)) {
				return null;
			} else {
				return defaultValue;
			}
		}
	}

	public void clear() {
		mapping.clear();
	}

	public Set<String> keySet() {
		return mapping.keySet();
	}

	/**
	 * This method updates the map and signals the owner. The origin is passed
	 * in this update, to make sure that no unnecessary updates are performed
	 * 
	 * @param key
	 * @param value
	 * @param origin
	 * @return
	 */
	public boolean put(String key, Object value) {
		Object old;
		synchronized (mapping) {
			old = mapping.get(key);
			mapping.put(key, value);
		}
		if (value == old) {
			return false;
		}
		if ((value == null) || (old == null) || !value.equals(old)) {
			return true;
		}
		return false;
	}

	public void remove(String key) {
		synchronized (mapping) {
			mapping.remove(key);
		}
	}

	public boolean containsKey(String key) {
		return mapping.containsKey(key);
	}

}"
AttributeMapOwner.java,model,"package org.processmining.models.graphbased;

public interface AttributeMapOwner {

	AttributeMap getAttributeMap();

}
"
AbstractDirectedGraph.java,model,"package org.processmining.models.graphbased.directed;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.Map;

import org.processmining.framework.util.Cast;
import org.processmining.models.graphbased.AbstractGraph;

public abstract class AbstractDirectedGraph<N extends DirectedGraphNode, E extends DirectedGraphEdge<? extends N, ? extends N>>
		extends AbstractGraph implements DirectedGraph<N, E> {

	private final Map<DirectedGraphNode, Collection<E>> inEdgeMap = new LinkedHashMap<DirectedGraphNode, Collection<E>>();;
	private final Map<DirectedGraphNode, Collection<E>> outEdgeMap = new LinkedHashMap<DirectedGraphNode, Collection<E>>();;

	public AbstractDirectedGraph() {
		super();
	}

	public AbstractDirectedGraph<?, ?> getGraph() {
		return this;
	}

	protected abstract AbstractDirectedGraph<N, E> getEmptyClone();

	/**
	 * The returned mapping satisfies:
	 * map.keySet().containsAll(graph.getNodes()) and
	 * map.keySet().containsAll(graph.getEdges())
	 * 
	 * @param graph
	 * @return
	 */
	protected abstract Map<? extends DirectedGraphElement, ? extends DirectedGraphElement> cloneFrom(
			DirectedGraph<N, E> graph);

	@SuppressWarnings(""unchecked"")
	public abstract void removeEdge(DirectedGraphEdge edge);

	protected void removeSurroundingEdges(N node) {
		for (E edge : getInEdges(node)) {
			removeEdge(edge);
		}
		for (E edge : getOutEdges(node)) {
			removeEdge(edge);
		}
	}

	protected void checkAddEdge(N source, N target) {
		Collection<N> nodes = getNodes();
		if (!nodes.contains(source) || !nodes.contains(target)) {
			throw new IllegalArgumentException(""Cannot add an arc between "" + source.toString() + "" and ""
					+ target.toString() + "", since one of these nodes is not in the graph."");
		}

	}

	public Collection<E> getInEdges(DirectedGraphNode node) {
		Collection<E> col = inEdgeMap.get(node);
		if (col == null) {
			return Collections.emptyList();
		} else {
			return new ArrayList<E>(col);
		}
	}

	public Collection<E> getOutEdges(DirectedGraphNode node) {
		Collection<E> col = outEdgeMap.get(node);
		if (col == null) {
			return Collections.emptyList();
		} else {
			return new ArrayList<E>(col);
		}
	}

	@Override
	public void graphElementAdded(Object element) {
		if (element instanceof DirectedGraphNode) {
			DirectedGraphNode node = (DirectedGraphNode) element;
			synchronized (inEdgeMap) {
				inEdgeMap.put(node, new LinkedHashSet<E>());
			}
			synchronized (outEdgeMap) {
				outEdgeMap.put(node, new LinkedHashSet<E>());
			}
		}
		if (element instanceof DirectedGraphEdge<?, ?>) {
			E edge = Cast.<E>cast(element);
			synchronized (inEdgeMap) {
				Collection<E> collection = inEdgeMap.get(edge.getTarget());
				collection.add(edge);
			}
			synchronized (outEdgeMap) {
				Collection<E> collection = outEdgeMap.get(edge.getSource());
				collection.add(edge);
			}
		}
		super.graphElementAdded(element);
	}

	public void graphElementRemoved(Object element) {
		if (element instanceof DirectedGraphNode) {
			DirectedGraphNode node = (DirectedGraphNode) element;
			synchronized (inEdgeMap) {
				inEdgeMap.remove(node);
			}
			synchronized (outEdgeMap) {
				outEdgeMap.remove(node);
			}
		}
		if (element instanceof DirectedGraphEdge<?, ?>) {
			E edge = Cast.<E>cast(element);
			synchronized (inEdgeMap) {
				Collection<E> collection = inEdgeMap.get(edge.getTarget());
				collection.remove(element);
			}
			synchronized (outEdgeMap) {
				Collection<E> collection = outEdgeMap.get(edge.getSource());
				collection.remove(element);
			}
		}
		super.graphElementRemoved(element);
	}

	public void graphElementChanged(Object element) {
		super.graphElementChanged(element);
	}

	public int compareTo(DirectedGraph<N, E> o) {
		if (!(o instanceof AbstractDirectedGraph<?, ?>)) {
			return getLabel().compareTo(o.getLabel());
		}
		AbstractDirectedGraph<?, ?> graph = (AbstractDirectedGraph<?, ?>) o;
		return id.compareTo(graph.id);
	}
}"
AbstractDirectedGraphEdge.java,model,"package org.processmining.models.graphbased.directed;

import org.processmining.models.graphbased.AbstractGraphEdge;

public abstract class AbstractDirectedGraphEdge<S extends AbstractDirectedGraphNode, T extends AbstractDirectedGraphNode>
		extends AbstractGraphEdge<S, T> implements DirectedGraphEdge<S, T> {

	private final AbstractDirectedGraph<?, ?> graph;

	public AbstractDirectedGraphEdge(S source, T target) {
		super(source, target);
		assert (source.getGraph() == target.getGraph());
		this.graph = source.getGraph();
	}

	public AbstractDirectedGraph<?, ?> getGraph() {
		return graph;
	}

	public int compareTo(AbstractGraphEdge<S, T> edge) {
		int c;
		c = getClass().getName().compareTo(edge.getClass().getName());
		if (c != 0) {
			return c;
		}
		c = source.compareTo(edge.getSource());
		if (c != 0) {
			return c;
		}
		return target.compareTo(edge.getTarget());
	}

}
"
AbstractDirectedGraphNode.java,model,"package org.processmining.models.graphbased.directed;

import org.processmining.models.graphbased.AbstractGraphNode;

public abstract class AbstractDirectedGraphNode extends AbstractGraphNode implements DirectedGraphNode {

	public AbstractDirectedGraphNode() {
		super();
	}

	public abstract AbstractDirectedGraph<?, ?> getGraph();

	public int compareTo(DirectedGraphNode node) {
		int comp = getId().compareTo(node.getId());
		//		assert (Math.abs(comp) == Math.abs(getLabel().compareTo(getLabel())));
		return comp;

	}

}
"
ComponentFactory.java,model,"package org.processmining.models.graphbased.directed.analysis;

import java.util.Collection;
import java.util.HashSet;
import java.util.TreeSet;

import org.processmining.models.graphbased.directed.DirectedGraph;
import org.processmining.models.graphbased.directed.DirectedGraphEdge;
import org.processmining.models.graphbased.directed.DirectedGraphNode;

public class ComponentFactory {

	/**
	 * Computes strongly connected components for the given directed graph.
	 * 
	 * @param <N>
	 *            Node type of the graph
	 * @param <E>
	 *            Edge type of the graph
	 * @param graph
	 *            The graph to componentize
	 * @return The set of strongly connected components of the graph
	 */
	public static <N extends DirectedGraphNode, E extends DirectedGraphEdge<? extends N, ? extends N>> Collection<Collection<N>> componentize(
			DirectedGraph<N, E> graph) {
		/**
		 * The set of nodes to still componentize.
		 */
		Collection<N> toDo = new HashSet<N>(graph.getNodes());
		/**
		 * The set of components found so far.
		 */
		Collection<Collection<N>> components = new HashSet<Collection<N>>();
		/**
		 * Until no nodes need componentizing...
		 */
//		System.out.println(""E: "" + graph.getEdges().size());
//		System.out.println(""N: "" + graph.getNodes().size());
		while (!toDo.isEmpty()) {
			/**
			 * Take a node, and create a component for it.
			 */
			N node = toDo.iterator().next();
			toDo.remove(node);
			Collection<N> component = new TreeSet<N>();
			component.add(node);
			/**
			 * Add the successors of this node, if possible (that is, if there
			 * is some path from the successor to the selected node.
			 */
			HashSet<N> reDo = new HashSet<N>();
			Collection<E> edges = graph.getOutEdges(node);
			for (E edge : edges) {
				N succNode = edge.getTarget();
				checkForComponent(graph, succNode, component, toDo, reDo);
			}
			/**
			 * Add the component.
			 */
//			System.out.println(""REDO: "" + reDo.size() + ""    "" + System.currentTimeMillis());
			components.add(component);
			toDo.addAll(reDo);
//			System.out.println(""TODO: "" + toDo.size() + ""    "" + System.currentTimeMillis());
		}
		return components;
	}

	/**
	 * Add all nodes reachable from the given node from which some node in the
	 * given component is reachable.
	 * 
	 * @param <N>
	 *            The type of nodes in the graph
	 * @param <E>
	 *            The type of edges in the graph
	 * @param graph
	 *            The given graph
	 * @param node
	 *            The given node
	 * @param component
	 *            The component
	 * @param toDo
	 *            The nodes to consider
	 */
	private static <N extends DirectedGraphNode, E extends DirectedGraphEdge<? extends N, ? extends N>> void checkForComponent(
			DirectedGraph<N, E> graph, N node, Collection<N> component, Collection<N> toDo, Collection<N> reDo) {
		/**
		 * Check whether this node should be considered
		 */
		if (toDo.contains(node)) {
			/**
			 * Node is being considered now...
			 */
			toDo.remove(node);
			/**
			 * Check all successors...
			 */
			boolean added = false;
			Collection<E> edges = graph.getOutEdges(node);
			for (E edge : edges) {
				N succNode = edge.getTarget();
				if (component.contains(succNode)) {
					/**
					 * Found a successor with a path to the component. Hence
					 * there is a path from this node to the componetn as well.
					 * Add it.
					 */
					added = true;
					component.add(node);
				} else {
					checkForComponent(graph, succNode, component, toDo, reDo);
				}
			}
			/**
			 * Node has not been added to component. Hence, it should be
			 * reconsidered in the future.
			 */
			if (!added) {
				reDo.add(node);
			}
		}
	}

	/**
	 * Checks whether a component is terminal, that is, whether it has no
	 * outgoing edges.
	 * 
	 * @param <N>
	 *            The type of nodes in the graph
	 * @param <E>
	 *            The type of edges in the graph
	 * @param graph
	 *            The given graph
	 * @param component
	 *            The given component
	 * @return Whether the component is terminal
	 */
	public static <N extends DirectedGraphNode, E extends DirectedGraphEdge<? extends N, ? extends N>> boolean isTerminal(
			DirectedGraph<N, E> graph, Collection<N> component) {
		for (N node : component) {
			Collection<E> edges = graph.getOutEdges(node);
			for (E edge : edges) {
				if (!component.contains(edge.getTarget())) {
					/**
					 * Found an edge leaving the component, hence it is not
					 * terminal.
					 */
					return false;
				}
			}
		}
		/**
		 * No edges leave the component, hence it is temrinal.
		 */
		return true;
	}
}
"
ShortestPathFactory.java,model,"/**
 * 
 */
package org.processmining.models.graphbased.directed.analysis;

import java.util.Arrays;
import java.util.Collection;
import java.util.HashSet;
import java.util.Set;

import org.processmining.models.graphbased.directed.DirectedGraph;
import org.processmining.models.graphbased.directed.DirectedGraphEdge;
import org.processmining.models.graphbased.directed.DirectedGraphNode;

/**
 * This class generate a shortest path from one node in a directed graph to
 * another.
 * 
 * @author arya
 * @email arya.adriansyah@gmail.com
 * @version Dec 12, 2008
 */
public class ShortestPathFactory {
	public static int UNLIMITEDMAX = Integer.MAX_VALUE;

	private ShortestPathFactory() {

	}

	/**
	 * Calculate shortest distance from a node to every other node in the graph.
	 * Algorithm in use is Dijkstra's algorithm written in Introduction to
	 * Algorithm, chapter 25.
	 * 
	 * @param source
	 * @param graph
	 * @return
	 */
	private static <N extends DirectedGraphNode, E extends DirectedGraphEdge<? extends N, ? extends N>> int[][] calculateShortestDistanceDijkstra(
			N source, DirectedGraph<N, E> graph, ShortestPathInfo<N, E> shortestPathInfo) {

		// start of Dijkstra's algorithm
		Set<N> S = new HashSet<N>(); // to store set of vertices whose final shortest-path weights from the source have already been determined
		Set<N> Q = new HashSet<N>(); // to store queue that contains all the vertices in V - S, V is total vertices in graph

		int[] d = new int[graph.getNodes().size()]; // to store shortest-path estimate
		Arrays.fill(d, ShortestPathFactory.UNLIMITEDMAX);

		int[] phi = new int[d.length];
		Arrays.fill(phi, -1); // -1 means that no node is before this node in a shortest path

		// initialize single source, as well as complete all mapping
		for (N node : graph.getNodes()) {
			Q.add(node);
		}

		// init source node
		d[shortestPathInfo.getIndexOf(source)] = 0;

		// start loop
		while (!Q.isEmpty()) {
			N currentNode = extractMin(d, Q, shortestPathInfo);
			if (currentNode == null) {
				break;
			} else {
				S.add(currentNode);
				Q.remove(currentNode);

				// update each vertex connected to indexMin 
				int currentNodeIndex = shortestPathInfo.getIndexOf(currentNode);
				Collection<E> edges = graph.getOutEdges(currentNode);
				for (E edge : edges) {
					// do RELAX. Please notice that the weight of an arc is always 1 in our case 
					if (d[shortestPathInfo.getIndexOf(edge.getTarget())] > (d[currentNodeIndex] + 1)) {
						d[shortestPathInfo.getIndexOf(edge.getTarget())] = d[currentNodeIndex] + 1;
						phi[shortestPathInfo.getIndexOf(edge.getTarget())] = currentNodeIndex;
					}

				}
			}
		}

		// result consist of 2 array : 1st array for shortestpath distance, 2nd array for nodes listing
		int[][] result = new int[2][];
		result[0] = d;
		result[1] = phi;
		return result;
	}

	private static <N extends DirectedGraphNode, E extends DirectedGraphEdge<? extends N, ? extends N>> N extractMin(
			int[] d, Set<N> q, ShortestPathInfo<N, E> shortestPathInfo) {

		int minValue = ShortestPathFactory.UNLIMITEDMAX;
		N resultNode = null;

		// find the minimum value
		for (N node : q) {
			int currentNodeIndex = shortestPathInfo.getIndexOf(node);
			if ((d[currentNodeIndex] <= minValue) && (d[currentNodeIndex] != ShortestPathFactory.UNLIMITEDMAX)) {
				minValue = d[currentNodeIndex];
				resultNode = node;
			}
		}
		return resultNode;
	}

	public static <N extends DirectedGraphNode, E extends DirectedGraphEdge<? extends N, ? extends N>> ShortestPathInfo<N, E> calculateAllShortestDistanceDijkstra(
			DirectedGraph<N, E> graph) {

		// create shortest path info
		ShortestPathInfo<N, E> shortestPathInfo = new ShortestPathInfo<N, E>(graph);

		// insert distances to shortest path info
		for (N node : graph.getNodes()) {
			int[][] temp = calculateShortestDistanceDijkstra(node, graph, shortestPathInfo);
			int currentNodeIndex = shortestPathInfo.getIndexOf(node);
			for (int i = 0; i < temp[0].length; i++) {
				if (temp[0][i] != ShortestPathFactory.UNLIMITEDMAX) {
					shortestPathInfo.setShortestPathLength(currentNodeIndex, i, temp[0][i]);
					shortestPathInfo.setLastOnShortestPath(currentNodeIndex, i, temp[1][i]);
				}
			}
			shortestPathInfo.setShortestPathLength(currentNodeIndex, currentNodeIndex, 0); // set distance to itself with zero
		}

		return shortestPathInfo;
	}
}
"
ShortestPathInfo.java,model,"package org.processmining.models.graphbased.directed.analysis;

import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import org.processmining.models.graphbased.directed.DirectedGraph;
import org.processmining.models.graphbased.directed.DirectedGraphEdge;
import org.processmining.models.graphbased.directed.DirectedGraphNode;

public class ShortestPathInfo<N extends DirectedGraphNode, E extends DirectedGraphEdge<? extends N, ? extends N>> {

	public final static int NOPATH = -1;

	private final DirectedGraph<N, E> graph;
	private final Map<N, Integer> map;
	private final int[][] lengths;
	private final int[][] lastNodeInShortestPath;

	ShortestPathInfo(DirectedGraph<N, E> graph) {
		this.graph = graph;
		int n = graph.getNodes().size();
		int i = 0;
		map = new HashMap<N, Integer>(n, 1F);
		for (N node : graph.getNodes()) {
			map.put(node, i++);
		}
		lengths = new int[n][];
		lastNodeInShortestPath = new int[n][];
		for (i = 0; i < n; i++) {
			lengths[i] = new int[n];
			lastNodeInShortestPath[i] = new int[n];
			Arrays.fill(lengths[i], ShortestPathInfo.NOPATH);
			Arrays.fill(lastNodeInShortestPath[i], -1);
		}
	}

	public int getShortestPathLength(N source, N target) {
		assert (map.get(source) != null);
		assert (map.get(target) != null);
		return lengths[map.get(source)][map.get(target)];
	}

	void setShortestPathLength(N source, N target, int length) {
		assert (map.get(source) != null);
		assert (map.get(target) != null);
		assert ((length == ShortestPathInfo.NOPATH) || (length >= 0));
		lengths[map.get(source)][map.get(target)] = length;
	}

	int getIndexOf(N node) {
		assert (map.get(node) != null);
		return map.get(node);
	}

	void setShortestPathLength(int sourceIndex, int targetIndex, int length) {
		assert (0 <= sourceIndex) && (sourceIndex < lengths.length);
		assert (0 <= targetIndex) && (targetIndex < lengths.length);
		assert ((length == ShortestPathInfo.NOPATH) || (length >= 0));
		lengths[sourceIndex][targetIndex] = length;
	}

	/**
	 * Returns the shortest path from the source to the target. If
	 * source.equals(target), then a list of length 1 is returned. Otherwise,
	 * the list returned contains the nodes from source to target that make up
	 * the path, including source as the first node and target as the last node.
	 * 
	 * If no path exist, an empty list is returned.
	 * 
	 * @param source
	 * @param target
	 * @return
	 */
	public List<N> getShortestPath(N source, N target) {
		int sourceIndex = getIndexOf(source);
		int targetIndex = getIndexOf(target);

		// check if target has a previous node in the shortest path
		List<N> result = new LinkedList<N>();
		result.add(target);
		while (lastNodeInShortestPath[sourceIndex][targetIndex] >= 0) {
			// find a node which is mapped to previousNodeInShortesPath[sourceIndex][targetIndex]
			N temp = getNodeFromIndex(lastNodeInShortestPath[sourceIndex][targetIndex]);
			if (temp != null) {
				result.add(temp);
				targetIndex = lastNodeInShortestPath[sourceIndex][targetIndex];
			} else {
				return Collections.emptyList();
			}
		}
		if (targetIndex == sourceIndex) {
			Collections.reverse(result);
			return result;
		} else {
			return Collections.emptyList();
		}
	}

	private N getNodeFromIndex(int index) {
		if (!map.containsValue(index)) {
			return null;
		} else {
			for (N node : graph.getNodes()) {
				if (map.get(node) == index) {
					return node;
				}
			}
			return null;
		}
	}

	void setLastOnShortestPath(int fromNodeIndex, int toNodeIndex, int lastNodeIndex) {
		assert (0 <= fromNodeIndex) && (fromNodeIndex < lengths.length);
		assert (0 <= toNodeIndex) && (toNodeIndex < lengths.length);
		assert (-1 <= lastNodeIndex) && (lastNodeIndex < lengths.length);
		assert (lengths[fromNodeIndex][toNodeIndex] >= 0);
		assert ((lengths[fromNodeIndex][toNodeIndex] > 0) || (lastNodeIndex == -1));
		lastNodeInShortestPath[fromNodeIndex][toNodeIndex] = lastNodeIndex;
	}
}
"
BoundaryDirectedGraphNode.java,model,"package org.processmining.models.graphbased.directed;

/**
 * Interface to represent a node that can be drawn on the boundary of another
 * node (e.g.: an exception on a BPMN activity.) The other node will be a
 * ContainingDirectedGraphNode.
 * 
 * @author Remco Dijkman
 * 
 */
public interface BoundaryDirectedGraphNode extends DirectedGraphNode {

	DirectedGraphNode getBoundingNode();

}
"
ContainableDirectedGraphElement.java,model,"package org.processmining.models.graphbased.directed;

import org.processmining.models.graphbased.AttributeMapOwner;

/**
 * Interface to represent a directed graph element that can be the child of a
 * node. (E.g.: a task in a subprocess.)
 * 
 * @author Remco Dijkman
 * 
 */
public interface ContainableDirectedGraphElement extends AttributeMapOwner {

	ContainingDirectedGraphNode getParent();

}
"
ContainingDirectedGraphNode.java,model,"package org.processmining.models.graphbased.directed;

import java.util.Set;

import org.processmining.models.graphbased.Expandable;

/**
 * Interface to represent a directed graph node that contain other elements.
 * 
 * @author Remco Dijkman
 * 
 */
public interface ContainingDirectedGraphNode extends DirectedGraphNode, Expandable {

	Set<? extends ContainableDirectedGraphElement> getChildren();

	void addChild(ContainableDirectedGraphElement child);
}
"
DirectedGraph.java,model,"package org.processmining.models.graphbased.directed;

import java.util.Collection;
import java.util.Set;

public interface DirectedGraph<N extends DirectedGraphNode, E extends DirectedGraphEdge<? extends N, ? extends N>>
		extends DirectedGraphElement, Comparable<DirectedGraph<N, E>> {

	Set<N> getNodes();

	Set<E> getEdges();

	Collection<E> getInEdges(DirectedGraphNode node);

	Collection<E> getOutEdges(DirectedGraphNode node);

	/**
	 * Removes the given edge from the graph.
	 * 
	 * @param edge
	 */
	@SuppressWarnings(""unchecked"")
	void removeEdge(DirectedGraphEdge edge);

	void removeNode(DirectedGraphNode cell);

}
"
DirectedGraphEdge.java,model,"package org.processmining.models.graphbased.directed;

import java.util.Collection;

public interface DirectedGraphEdge<S extends DirectedGraphNode, T extends DirectedGraphNode> extends
		DirectedGraphElement {

	/**
	 * Implementations of this class should also implement DirectedGraphEdge<N,
	 * ?>
	 * 
	 * @author bfvdonge
	 * 
	 * @param <N>
	 */
	public static interface MultipleSources<N extends DirectedGraphNode> {
		/**
		 * returns all target nodes of this DirectedGraphEdge, including the
		 * node returned by getSource() of DirectedGraphEdge.
		 * 
		 * @return
		 */
		Collection<N> getSources();
	}

	/**
	 * Implementations of this class should also implement DirectedGraphEdge<?,
	 * N>
	 * 
	 * @author bfvdonge
	 * 
	 * @param <N>
	 */
	public static interface MultipleTargets<N extends DirectedGraphNode> {

		/**
		 * returns all target nodse of this DirectedGraphEdge, including the
		 * node returned by getTarget() of DirectedGraphEdge.
		 * 
		 * @return
		 */
		Collection<N> getTargets();
	}

	S getSource();

	T getTarget();

}
"
DirectedGraphElement.java,model,"package org.processmining.models.graphbased.directed;

import org.processmining.models.graphbased.AttributeMapOwner;

/**
 * Main interface for elements of a directed graph. Elements are nodes and
 * edges. All implementing classes of this interface should implement an equals
 * method based on some globally unique ID.
 * 
 * @author bfvdonge
 * 
 */
public interface DirectedGraphElement extends AttributeMapOwner, Cloneable {

	String getLabel();

	DirectedGraph<?, ?> getGraph();

	boolean equals(Object o);

	int hashCode();
}"
DirectedGraphElementWeights.java,model,"package org.processmining.models.graphbased.directed;

import java.util.ArrayList;
import java.util.HashMap;

public class DirectedGraphElementWeights extends HashMap<Object, Integer> {

	/**
	 * 
	 */
	private static final long serialVersionUID = 6950324561008737936L;

	public DirectedGraphElementWeights() {
	}

	/**
	 * Add the given weight to the given object, which will typically be a node
	 * identifier.
	 * 
	 * @param nodeId
	 *            The node identifier
	 * @param weight
	 *            The weight to add
	 */
	public void add(Object nodeId, int weight) {
		if (keySet().contains(nodeId)) {
			put(nodeId, get(nodeId) + weight);
		} else {
			put(nodeId, weight);
		}
	}

	/**
	 * Returns the current weight of the given object, which will typically be a
	 * node identifier. Returns the given default weight if no current weight is
	 * found.
	 * 
	 * @param nodeId
	 *            The node identifier
	 * @param defaultWeight
	 *            The default weight
	 * @return The weight of the node with the given identifier
	 */
	public int get(Object nodeId, int defaultWeight) {
		if (keySet().contains(nodeId)) {
			return get(nodeId);
		}
		return defaultWeight;
	}

	/**
	 * Adds the given weight to the edge identified by its source identifier,
	 * target identifier, and its own identifier. Note that the combination of
	 * these three should be unique.
	 * 
	 * @param sourceId
	 *            The source node identifier
	 * @param targetId
	 *            The target node identifier
	 * @param edgeId
	 *            The edge identifier
	 * @param weight
	 *            The weight to add
	 */
	public void add(Object sourceId, Object targetId, Object edgeId, int weight) {
		ArrayList<Object> list = new ArrayList<Object>(3);
		list.add(sourceId);
		list.add(targetId);
		list.add(edgeId);
		if (keySet().contains(list)) {
			put(list, get(list) + weight);
		} else {
			put(list, weight);
		}
	}

	/**
	 * Returns the current weight of the edge identified by its source
	 * identifier, target identifier, and its own identifier. Returns the
	 * default weight if no current weight is found.
	 * 
	 * @param sourceId
	 *            The source node identifier
	 * @param targetId
	 *            The target node identifier
	 * @param edgeId
	 *            The edge identifier
	 * @param defaultWeight
	 *            The default weight
	 * @return The weight of the edge identified by its source identifier,
	 *         target identifier, and its own identifier
	 */
	public int get(Object sourceId, Object targetId, Object edgeId, int defaultWeight) {
		ArrayList<Object> list = new ArrayList<Object>(3);
		list.add(sourceId);
		list.add(targetId);
		list.add(edgeId);
		if (keySet().contains(list)) {
			return get(list);
		}
		return defaultWeight;
	}
}
"
DirectedGraphNode.java,model,"package org.processmining.models.graphbased.directed;

import org.processmining.models.graphbased.NodeID;

public interface DirectedGraphNode extends DirectedGraphElement, Comparable<DirectedGraphNode> {

	NodeID getId();

}
"
GraphIterator.java,model,"package org.processmining.models.graphbased.directed.utils;

import java.util.Collection;
import java.util.HashSet;

import org.processmining.models.graphbased.directed.DirectedGraph;
import org.processmining.models.graphbased.directed.DirectedGraphEdge;
import org.processmining.models.graphbased.directed.DirectedGraphNode;

public class GraphIterator {

	public static <N extends DirectedGraphNode, E extends DirectedGraphEdge<? extends N, ? extends N>> Collection<N> getDirectSuccessors(
			final N node, DirectedGraph<N, E> graph) {
		return getDepthFirstSuccessors(node, graph, new EdgeAcceptor<N, E>() {
			public boolean acceptEdge(E edge, int depth) {
				return depth == 0;
			}
		}, new NodeAcceptor<N>() {
			public boolean acceptNode(N node, int depth) {
				return true;
			}
		});
	}

	public static <N extends DirectedGraphNode, E extends DirectedGraphEdge<? extends N, ? extends N>> Collection<N> getDepthFirstSuccessors(
			N node, DirectedGraph<N, E> graph, EdgeAcceptor<N, E> edgeAcceptor, NodeAcceptor<N> nodeAcceptor) {
		Collection<N> result = new HashSet<N>();
		HashSet<N> seen = new HashSet<N>();
		getDepthFirstSuccessors(node, graph, result, edgeAcceptor, nodeAcceptor, 0, seen);
		return result;

	}

	private static <N extends DirectedGraphNode, E extends DirectedGraphEdge<? extends N, ? extends N>> void getDepthFirstSuccessors(
			N node, DirectedGraph<N, E> graph, Collection<N> result, EdgeAcceptor<N, E> edgeAcceptor,
			NodeAcceptor<N> nodeAcceptor, final int depth, final HashSet<N> seen) {

		for (E edge : graph.getOutEdges(node)) {
			if (edgeAcceptor.acceptEdge(edge, depth)) {
				N target = edge.getTarget();
				if (nodeAcceptor.acceptNode(target, depth)) {
					result.add(target);
				}
				if (!seen.contains(target)) {
					seen.add(target);
					getDepthFirstSuccessors(target, graph, result, edgeAcceptor, nodeAcceptor, depth + 1, seen);
					seen.remove(target);
				}
			}
		}
	}

	public static <N extends DirectedGraphNode, E extends DirectedGraphEdge<? extends N, ? extends N>> Collection<N> getDirectPredecessors(
			final N node, DirectedGraph<N, E> graph) {
		return getDepthFirstPredecessors(node, graph, new EdgeAcceptor<N, E>() {
			public boolean acceptEdge(E edge, int depth) {
				return depth == 0;
			}
		}, new NodeAcceptor<N>() {
			public boolean acceptNode(N node, int depth) {
				return true;
			}
		});
	}

	public static <N extends DirectedGraphNode, E extends DirectedGraphEdge<? extends N, ? extends N>> Collection<N> getDepthFirstPredecessors(
			N node, DirectedGraph<N, E> graph, EdgeAcceptor<N, E> edgeAcceptor, NodeAcceptor<N> nodeAcceptor) {
		Collection<N> result = new HashSet<N>();
		HashSet<N> seen = new HashSet<N>();
		getDepthFirstPredecessors(node, graph, result, edgeAcceptor, nodeAcceptor, 0, seen);
		return result;

	}

	private static <N extends DirectedGraphNode, E extends DirectedGraphEdge<? extends N, ? extends N>> void getDepthFirstPredecessors(
			N node, DirectedGraph<N, E> graph, Collection<N> result, EdgeAcceptor<N, E> edgeAcceptor,
			NodeAcceptor<N> nodeAcceptor, final int depth, final HashSet<N> seen) {

		for (E edge : graph.getInEdges(node)) {
			if (edgeAcceptor.acceptEdge(edge, depth)) {
				N source = edge.getSource();
				if (nodeAcceptor.acceptNode(source, depth)) {
					result.add(source);
				}
				if (!seen.contains(source)) {
					seen.add(source);
					getDepthFirstPredecessors(source, graph, result, edgeAcceptor, nodeAcceptor, depth + 1, seen);
					seen.remove(source);
				}
			}
		}
	}

	public interface EdgeAcceptor<N, E extends DirectedGraphEdge<? extends N, ? extends N>> {
		/**
		 * Used while searching. If this method returns false for a certain
		 * edge, then this edge is not traversed in the search.
		 * 
		 * @param edge
		 * @return
		 */
		public boolean acceptEdge(E edge, int depth);
	}

	public interface NodeAcceptor<T extends DirectedGraphNode> {
		/**
		 * Used while searching. If this method returns false for a certain
		 * node, then this node is not added to the search result and the search
		 * does not continue along this node.
		 * 
		 * @param edge
		 * @return
		 */
		public boolean acceptNode(T node, int depth);
	}

}
"
Node.java,model,"package org.processmining.models.graphbased.directed.utils;

import java.util.ArrayList;
import java.util.List;

// taken from
// http://sujitpal.blogspot.com/2006/05/java-data-structure-generic-tree.html
// 27th August 2008
// modified for ProM by Arya Adriansyah (arya.adriansyah@gmail.com)

/**
 * Represents a node of the Tree<T> class. The Node<T> is also a container, and
 * can be thought of as instrumentation to determine the location of the type T
 * in the Tree<T>.
 */
public class Node<T> {

	private T data;
	private List<Node<T>> children;
	private Node<T> parent;

	/**
	 * Default ctor.
	 */
	public Node() {
		super();
		setParent(null);
	}

	/**
	 * Convenience ctor to create a Node<T> with an instance of T.
	 * 
	 * @param data
	 *            an instance of T.
	 */
	public Node(T data) {
		this();
		setData(data);
		setParent(null);
	}

	/**
	 * Return the children of Node<T>. The Tree<T> is represented by a single
	 * root Node<T> whose children are represented by a List<Node<T>>. Each of
	 * these Node<T> elements in the List can have children. The getChildren()
	 * method will return the children of a Node<T>.
	 * 
	 * @return the children of Node<T>
	 */
	public List<Node<T>> getChildren() {
		if (this.children == null) {
			return new ArrayList<Node<T>>();
		}
		return this.children;
	}

	/**
	 * Sets the children of a Node<T> object. See docs for getChildren() for
	 * more information.
	 * 
	 * @param children
	 *            the List<Node<T>> to set.
	 */
	public void setChildren(List<Node<T>> children) {
		this.children = children;
	}

	/**
	 * Returns the number of immediate children of this Node<T>.
	 * 
	 * @return the number of immediate children.
	 */
	public int getNumberOfChildren() {
		if (children == null) {
			return 0;
		}
		return children.size();
	}

	/**
	 * Adds a child to the list of children for this Node<T>. The addition of
	 * the first child will create a new List<Node<T>>.
	 * 
	 * @param child
	 *            a Node<T> object to set.
	 */
	public void addChild(Node<T> child) {
		if (children == null) {
			children = new ArrayList<Node<T>>();
		}
		children.add(child);
	}

	/**
	 * Inserts a Node<T> at the specified position in the child list. Will *
	 * throw an ArrayIndexOutOfBoundsException if the index does not exist.
	 * 
	 * @param index
	 *            the position to insert at.
	 * @param child
	 *            the Node<T> object to insert.
	 * @throws IndexOutOfBoundsException
	 *             if thrown.
	 */
	public void insertChildAt(int index, Node<T> child) throws IndexOutOfBoundsException {
		if (index == getNumberOfChildren()) {
			// this is really an append
			addChild(child);
			return;
		} else {
			children.get(index); //just to throw the exception, and stop here
			children.add(index, child);
		}
	}

	/**
	 * Remove the Node<T> element at index index of the List<Node<T>>.
	 * 
	 * @param index
	 *            the index of the element to delete.
	 * @throws IndexOutOfBoundsException
	 *             if thrown.
	 */
	public void removeChildAt(int index) throws IndexOutOfBoundsException {
		children.remove(index);
	}

	public T getData() {
		return this.data;
	}

	public void setData(T data) {
		this.data = data;
	}

	public String toString() {
		StringBuilder sb = new StringBuilder();
		sb.append(""{"").append(getData().toString()).append("",["");
		int i = 0;
		for (Node<T> e : getChildren()) {
			if (i > 0) {
				sb.append("","");
			}
			sb.append(e.getData().toString());
			i++;
		}
		sb.append(""]"").append(""}"");
		return sb.toString();
	}

	public Node<T> getParent() {
		return parent;
	}

	public void setParent(Node<T> parent) {
		this.parent = parent;
	}
}
"
AbstractDirectedHypergraph.java,model,"package org.processmining.models.graphbased.directedhypergraph;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Set;

import org.processmining.models.graphbased.AbstractGraph;

public abstract class AbstractDirectedHypergraph<N extends DirectedHypergraphNode, I extends DirectedIncomingHyperedge<? extends N, ? extends N>, O extends DirectedOutgoingHyperedge<? extends N, ? extends N>>
		extends AbstractGraph implements DirectedHypergraph<N, I, O> {

	public AbstractDirectedHypergraph() {
		super();
	}

	public AbstractDirectedHypergraph<?, ?, ?> getGraph() {
		return this;
	}

	protected abstract AbstractDirectedHypergraph<N, I, O> getEmptyClone();

	protected abstract void cloneFrom(AbstractDirectedHypergraph<N, I, O> graph);

	@SuppressWarnings(""unchecked"")
	public abstract void removeEdge(DirectedIncomingHyperedge edge);

	@SuppressWarnings(""unchecked"")
	public abstract void removeEdge(DirectedOutgoingHyperedge edge);

	protected void checkAddEdge(N source, Set<N> targets) {
		Collection<N> nodes = getNodes();
		if (!nodes.contains(source) && !nodes.containsAll(targets)) {
			throw new IllegalArgumentException(""Cannot add an edge between "" + source.toString() + "" and ""
					+ targets.toString() + "", since one of these nodes is not in the graph."");
		}

	}

	protected void checkAddEdge(Set<N> sources, N target) {
		Collection<N> nodes = getNodes();
		if (!nodes.containsAll(sources) && !nodes.contains(target)) {
			throw new IllegalArgumentException(""Cannot add an edge between "" + sources.toString() + "" and ""
					+ target.toString() + "", since one of these nodes is not in the graph."");
		}

	}

	public Collection<I> getIncomingInEdges(DirectedHypergraphNode node) {
		Collection<I> edges = new ArrayList<I>();
		for (I edge : getInEdges()) {
			if (edge.getTarget().equals(node)) {
				edges.add(edge);
			}
		}
		return edges;
	}

	public Collection<O> getOutgoingOutEdges(DirectedHypergraphNode node) {
		Collection<O> edges = new ArrayList<O>();
		for (O edge : getOutEdges()) {
			if (edge.getSource().equals(node)) {
				edges.add(edge);
			}
		}
		return edges;

	}

	public Collection<O> getIncomingOutEdges(DirectedHypergraphNode node) {
		Collection<O> edges = new ArrayList<O>();
		for (O edge : getOutEdges()) {
			if (edge.getTargets().contains(node)) {
				edges.add(edge);
			}
		}
		return edges;
	}

	public Collection<I> getOutgoingInEdges(DirectedHypergraphNode node) {
		Collection<I> edges = new ArrayList<I>();
		for (I edge : getInEdges()) {
			if (edge.getSources().contains(node)) {
				edges.add(edge);
			}
		}
		return edges;
	}

	public int compareTo(DirectedHypergraph<N, I, O> o) {
		if (!(o instanceof AbstractDirectedHypergraph<?, ?, ?>)) {
			return getLabel().compareTo(o.getLabel());
		}
		AbstractDirectedHypergraph<?, ?, ?> graph = (AbstractDirectedHypergraph<?, ?, ?>) o;
		return id.compareTo(graph.id);
	}

}
"
AbstractDirectedHypergraphNode.java,model,"package org.processmining.models.graphbased.directedhypergraph;

import java.awt.Dimension;

import org.processmining.models.graphbased.AbstractGraphNode;
import org.processmining.models.graphbased.AttributeMap;

public class AbstractDirectedHypergraphNode extends AbstractGraphNode implements DirectedHypergraphNode {

	private final AbstractDirectedHypergraph<?, ?, ?> graph;

	public AbstractDirectedHypergraphNode(String label, AbstractDirectedHypergraph<?, ?, ?> graph) {
		super();
		this.graph = graph;
		getAttributeMap().put(AttributeMap.LABEL, label);
		getAttributeMap().put(AttributeMap.SIZE, new Dimension(50, 50));
	}

	public DirectedHypergraph<?, ?, ?> getGraph() {
		return graph;
	}



	public int compareTo(DirectedHypergraphNode node) {
		if (node instanceof AbstractDirectedHypergraphNode) {
			return getId().compareTo(((AbstractDirectedHypergraphNode) node).getId());
		}
		return getLabel().compareTo(node.getLabel());

	}

}
"
AbstractDirectedIncomingHyperedge.java,model,"package org.processmining.models.graphbased.directedhypergraph;

import java.util.Iterator;
import java.util.Set;
import java.util.SortedSet;
import java.util.TreeSet;

import org.processmining.framework.util.Cast;
import org.processmining.models.graphbased.AbstractGraphEdge;
import org.processmining.models.graphbased.AttributeMap;

public abstract class AbstractDirectedIncomingHyperedge<S extends AbstractDirectedHypergraphNode, T extends AbstractDirectedHypergraphNode>
		extends AbstractGraphEdge<Set<S>, T> implements DirectedIncomingHyperedge<S, T> {

	private final AbstractDirectedHypergraph<?, ?, ?> graph;

	public AbstractDirectedIncomingHyperedge(Set<S> sources, T target, String label) {
		super(sources, target);
		// DO NOT uncomment the next line. It is not valid,
		// but the idea is clear.
		// assert(for (source:sources) {source.getGraph() ==
		// target.getGraph()});
		assert (target.getGraph() instanceof AbstractDirectedHypergraph<?, ?, ?>);
		this.graph = Cast.<AbstractDirectedHypergraph<?, ?, ?>>cast(target.getGraph());
		getAttributeMap().put(AttributeMap.LABEL, label);
	}

	public AbstractDirectedHypergraph<?, ?, ?> getGraph() {
		return graph;
	}

	public int compareTo(AbstractGraphEdge<Set<S>, T> edge) {
		int c;
		c = getClass().getName().compareTo(edge.getClass().getName());
		if (c != 0) {
			return c;
		}
		// Check for same target
		c = target.compareTo(edge.getTarget());
		if (c != 0) {
			return c;
		}
		// Check for same sources size
		c = source.size() - edge.getSource().size();
		if ((c != 0) || (source.size() == 0)) {
			return c;
		}
		SortedSet<S> sources = new TreeSet<S>(source);
		SortedSet<S> edgeSources = new TreeSet<S>(edge.getSource());
		Iterator<S> it = sources.iterator();
		Iterator<S> it2 = edgeSources.iterator();
		do {
			c = (it.next().compareTo(it2.next()));
		} while ((c == 0) && it.hasNext());
		return c;
	}

	public Set<S> getSources() {
		return getSource();
	}
}
"
AbstractDirectedOutgoingHyperedge.java,model,"package org.processmining.models.graphbased.directedhypergraph;

import java.util.Iterator;
import java.util.Set;
import java.util.SortedSet;
import java.util.TreeSet;

import org.processmining.framework.util.Cast;
import org.processmining.models.graphbased.AbstractGraphEdge;
import org.processmining.models.graphbased.AttributeMap;

public abstract class AbstractDirectedOutgoingHyperedge<S extends AbstractDirectedHypergraphNode, T extends AbstractDirectedHypergraphNode>
		extends AbstractGraphEdge<S, Set<T>> implements DirectedOutgoingHyperedge<S, T> {

	private final AbstractDirectedHypergraph<?, ?, ?> graph;

	public AbstractDirectedOutgoingHyperedge(S source, Set<T> targets, String label) {
		super(source, targets);
		// DO NOT uncomment the next line. It is not valid,
		// but the idea is clear.
		// assert(for (source:sources) {source.getGraph() ==
		// target.getGraph()});
		assert (source.getGraph() instanceof AbstractDirectedHypergraph<?, ?, ?>);
		this.graph = Cast.<AbstractDirectedHypergraph<?, ?, ?>>cast(source.getGraph());
		getAttributeMap().put(AttributeMap.LABEL, label);
	}

	public AbstractDirectedHypergraph<?, ?, ?> getGraph() {
		return graph;
	}

	public int compareTo(AbstractGraphEdge<S, Set<T>> edge) {
		int c;
		c = getClass().getName().compareTo(edge.getClass().getName());
		if (c != 0) {
			return c;
		}
		// Check for same source
		c = source.compareTo(edge.getSource());
		if (c != 0) {
			return c;
		}
		// Check for same sources size
		c = target.size() - edge.getTarget().size();
		if ((c != 0) || (target.size() == 0)) {
			return c;
		}
		SortedSet<T> targets = new TreeSet<T>(target);
		SortedSet<T> edgeTargets = new TreeSet<T>(edge.getTarget());
		Iterator<T> it = targets.iterator();
		Iterator<T> it2 = edgeTargets.iterator();
		do {
			c = (it.next().compareTo(it2.next()));
		} while ((c == 0) && it.hasNext());
		return c;
	}

	public Set<T> getTargets() {
		return getTarget();
	}
}
"
DirectedHypergraph.java,model,"package org.processmining.models.graphbased.directedhypergraph;

import java.util.Collection;

public interface DirectedHypergraph<N extends DirectedHypergraphNode, I extends DirectedIncomingHyperedge<? extends N, ? extends N>, O extends DirectedOutgoingHyperedge<? extends N, ? extends N>>
		extends DirectedHypergraphElement, Comparable<DirectedHypergraph<N, I, O>> {

	Collection<N> getNodes();

	Collection<I> getInEdges();

	Collection<O> getOutEdges();

	Collection<I> getIncomingInEdges(DirectedHypergraphNode node);

	Collection<O> getOutgoingOutEdges(DirectedHypergraphNode node);

	Collection<O> getIncomingOutEdges(DirectedHypergraphNode node);

	Collection<I> getOutgoingInEdges(DirectedHypergraphNode node);

	@SuppressWarnings(""unchecked"")
	void removeEdge(DirectedIncomingHyperedge edge);

	@SuppressWarnings(""unchecked"")
	void removeEdge(DirectedOutgoingHyperedge edge);

}
"
DirectedHypergraphElement.java,model,"package org.processmining.models.graphbased.directedhypergraph;

import org.processmining.models.graphbased.AttributeMapOwner;

public interface DirectedHypergraphElement extends AttributeMapOwner, Cloneable {

	String getLabel();

	DirectedHypergraph<?, ?, ?> getGraph();

	boolean equals(Object o);

	int hashCode();
}"
DirectedHypergraphNode.java,model,"package org.processmining.models.graphbased.directedhypergraph;

public interface DirectedHypergraphNode extends DirectedHypergraphElement, Comparable<DirectedHypergraphNode> {

}
"
DirectedIncomingHyperedge.java,model,"package org.processmining.models.graphbased.directedhypergraph;

import java.util.Set;

/**
 * represents edges going from multiple sources towards one target
 * 
 * @author bfvdonge
 * 
 * @param <S>
 * @param <T>
 */
public interface DirectedIncomingHyperedge<S extends DirectedHypergraphNode, T extends DirectedHypergraphNode> extends
		DirectedHypergraphElement {

	Set<S> getSources();

	T getTarget();

}
"
DirectedOutgoingHyperedge.java,model,"package org.processmining.models.graphbased.directedhypergraph;

import java.util.Set;

/**
 * represents edges going from a source towards multiple targets
 * 
 * @author bfvdonge
 * 
 * @param <S>
 * @param <T>
 */
public interface DirectedOutgoingHyperedge<S extends DirectedHypergraphNode, T extends DirectedHypergraphNode> extends
		DirectedHypergraphElement {

	S getSource();

	Set<T> getTargets();

}"
EdgeID.java,model,"package org.processmining.models.graphbased;

import java.io.Serializable;
import java.util.UUID;

public class EdgeID implements Comparable<EdgeID>, Serializable {

	private static final long serialVersionUID = -6457455085857447745L;

	private final UUID id = UUID.randomUUID();

	public int compareTo(EdgeID edge) {
		return id.compareTo(edge.id);
	}

	public String toString() {
		return ""node "" + id;
	}

	public boolean equals(Object o) {
		if (!(o instanceof EdgeID)) {
			return false;
		}
		EdgeID edgeID = (EdgeID) o;
		return edgeID.id.equals(id);
	}

	public int hashCode() {
		return id.hashCode();
	}

}
"
Expandable.java,model,"package org.processmining.models.graphbased;

import java.awt.Dimension;

public interface Expandable extends AttributeMapOwner {

	Dimension getCollapsedSize();

	//	ExpansionListener.ListenerList getExpansionListeners();
	//
	//	void expand();
	//
	//	void collapse();
	//
	//	boolean isCollapsed();
	//
	//	boolean isExpanded();
}
"
ExpansionListener.java,model,"package org.processmining.models.graphbased;

import java.util.EventListener;

import org.processmining.framework.plugin.events.ProMEventListenerList;

public interface ExpansionListener extends EventListener {

	void nodeExpanded(Expandable source);

	void nodeCollapsed(Expandable source);

	public class ListenerList extends ProMEventListenerList<ExpansionListener> {
		public void fireNodeExpanded(Expandable source) {
			for (ExpansionListener listener : getListeners()) {
				listener.nodeExpanded(source);
			}
		}

		public void fireNodeCollapsed(Expandable source) {
			for (ExpansionListener listener : getListeners()) {
				listener.nodeCollapsed(source);
			}
		}

	}

}
"
NodeID.java,model,"package org.processmining.models.graphbased;

import java.io.Serializable;
import java.util.UUID;

public class NodeID implements Comparable<NodeID>, Serializable {

	private static final long serialVersionUID = -6457455085857447745L;

	private final UUID id = UUID.randomUUID();

	public int compareTo(NodeID node) {
		return id.compareTo(node.id);
	}

	public String toString() {
		return ""node "" + id;
	}

	public boolean equals(Object o) {
		if (!(o instanceof NodeID)) {
			return false;
		}
		NodeID nodeID = (NodeID) o;
		return nodeID.id.equals(id);
	}

	public int hashCode() {
		return id.hashCode();
	}

}
"
AbstractUndirectedEdge.java,model,"package org.processmining.models.graphbased.undirected;

import org.processmining.framework.util.Cast;
import org.processmining.models.graphbased.AbstractGraphEdge;
import org.processmining.models.graphbased.AttributeMap;

public abstract class AbstractUndirectedEdge<T extends UndirectedGraphNode> extends AbstractGraphEdge<T, T> implements
		UndirectedGraphEdge<T> {

	private final AbstractUndirectedGraph<?, ?> graph;

	public AbstractUndirectedEdge(T source, T target, String label) {
		super(source, target);
		assert (source.getGraph() == target.getGraph());
		assert (source.getGraph() instanceof AbstractUndirectedGraph<?, ?>);
		this.graph = Cast.<AbstractUndirectedGraph<?, ?>>cast(source.getGraph());
		getAttributeMap().put(AttributeMap.LABEL, label);
	}

	public UndirectedGraph<?, ?> getGraph() {
		return graph;
	}

}
"
AbstractUndirectedGraph.java,model,"package org.processmining.models.graphbased.undirected;

import java.util.ArrayList;
import java.util.Collection;

import org.processmining.models.graphbased.AbstractGraph;

public abstract class AbstractUndirectedGraph<N extends UndirectedGraphNode, E extends UndirectedGraphEdge<? extends N>>
		extends AbstractGraph implements UndirectedGraph<N, E> {

	public AbstractUndirectedGraph() {
		super();
	}

	public AbstractUndirectedGraph<?, ?> getGraph() {
		return this;
	}

	protected abstract AbstractUndirectedGraph<N, E> getEmptyClone();

	protected abstract void cloneFrom(UndirectedGraph<N, E> graph);

	@SuppressWarnings(""unchecked"")
	public abstract void removeEdge(UndirectedGraphEdge edge);

	protected void checkAddEdge(N source, N target) {
		Collection<N> nodes = getNodes();
		if (!nodes.contains(source) && !nodes.contains(target)) {
			throw new IllegalArgumentException(""Cannot add an arc between "" + source.toString() + "" and ""
					+ target.toString() + "", since one of these nodes is not in the graph."");
		}

	}

	public Collection<E> getEdges(UndirectedGraphNode node) {
		Collection<E> edges = new ArrayList<E>();
		for (E edge : getEdges()) {
			if (edge.getTarget().equals(node) || edge.getSource().equals(node)) {
				edges.add(edge);
			}
		}
		return edges;
	}

	public int compareTo(UndirectedGraph<N, E> o) {
		if (!(o instanceof AbstractUndirectedGraph<?, ?>)) {
			return getLabel().compareTo(o.getLabel());
		}
		AbstractUndirectedGraph<?, ?> graph = (AbstractUndirectedGraph<?, ?>) o;
		return id.compareTo(graph.id);
	}

}
"
AbstractUndirectedNode.java,model,"package org.processmining.models.graphbased.undirected;

import org.processmining.models.graphbased.AbstractGraphNode;
import org.processmining.models.graphbased.AttributeMap;

public abstract class AbstractUndirectedNode extends AbstractGraphNode implements UndirectedGraphNode {

	private final AbstractUndirectedGraph<?, ?> graph;

	public AbstractUndirectedNode(String label, AbstractUndirectedGraph<?, ?> graph) {
		super();
		this.graph = graph;
		getAttributeMap().put(AttributeMap.LABEL, label);
	}

	public UndirectedGraph<?, ?> getGraph() {
		return graph;
	}

	public int compareTo(UndirectedGraphNode node) {
		if (node instanceof AbstractUndirectedNode) {
			return getId().compareTo(((AbstractUndirectedNode) node).getId());
		} else {
			return getLabel().compareTo(node.getLabel());
		}
	}

}
"
UndirectedGraph.java,model,"package org.processmining.models.graphbased.undirected;

import java.util.Collection;

public interface UndirectedGraph<N extends UndirectedGraphNode, E extends UndirectedGraphEdge<? extends N>> extends
		UndirectedGraphElement, Comparable<UndirectedGraph<N, E>> {

	Collection<N> getNodes();

	Collection<E> getEdges();

	Collection<E> getEdges(UndirectedGraphNode node);

	@SuppressWarnings(""unchecked"")
	void removeEdge(UndirectedGraphEdge edge);

}
"
UndirectedGraphEdge.java,model,"package org.processmining.models.graphbased.undirected;

public interface UndirectedGraphEdge<T extends UndirectedGraphNode> extends UndirectedGraphElement {

	T getSource();

	T getTarget();

}
"
UndirectedGraphElement.java,model,"package org.processmining.models.graphbased.undirected;

import org.processmining.models.graphbased.AttributeMapOwner;

public interface UndirectedGraphElement extends AttributeMapOwner, Cloneable {

	String getLabel();

	UndirectedGraph<?, ?> getGraph();

	boolean equals(Object o);

	int hashCode();

}
"
UndirectedGraphNode.java,model,"package org.processmining.models.graphbased.undirected;

public interface UndirectedGraphNode extends UndirectedGraphElement, Comparable<UndirectedGraphNode> {

}
"
ViewSpecificAttributeMap.java,model,"package org.processmining.models.graphbased;

import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

public class ViewSpecificAttributeMap {

	public static final ViewSpecificAttributeMap EMPTYMAP = new ViewSpecificAttributeMap();

	private final Map<AttributeMapOwner, AttributeMap> maps = new HashMap<AttributeMapOwner, AttributeMap>();

	public Object get(AttributeMapOwner owner, String key) {
		AttributeMap map = maps.get(owner);
		if ((map == null) || !map.containsKey(key)) {
			map = owner.getAttributeMap();
		}
		return map.get(key);

	}

	@SuppressWarnings(""unchecked"")
	public <T> T get(AttributeMapOwner owner, String key, T defaultValue) {
		AttributeMap map = maps.get(owner);
		if (map != null) {
			if (map.containsKey(key)) {
				Object o = map.get(key);
				if (o == null) {
					return null;
				}
				return (T) map.get(key);
			}
		}
		map = owner.getAttributeMap();
		if (map.containsKey(key)) {
			Object o = map.get(key);
			if (o == null) {
				return null;
			}
			return (T) map.get(key);
		} else {
			return defaultValue;
		}
	}

	public void clearViewSpecific(AttributeMapOwner owner) {
		AttributeMap map = maps.get(owner);
		if (map != null) {
			for (String key : map.keySet()) {
				putViewSpecific(owner, key, null);
			}
		}
		maps.remove(owner);
	}

	public Set<String> keySet(AttributeMapOwner owner) {
		Set<String> result = new HashSet<String>(owner.getAttributeMap().keySet());
		AttributeMap map = maps.get(owner);
		if (map != null) {
			result.addAll(map.keySet());
		}
		return result;
	}

	/**
	 * This method updates the map and signals the owner. The origin is passed
	 * in this update, to make sure that no unnecessary updates are performed
	 * 
	 * @param key
	 * @param value
	 * @param origin
	 * @return
	 */
	public boolean putViewSpecific(AttributeMapOwner owner, String key, Object value) {
		AttributeMap map = getMapFor(owner);
		Object old = map.get(key);
		map.put(key, value);
		if (value == old) {
			return false;
		}
		if ((value == null) || (old == null) || !value.equals(old)) {
			return true;
		}
		return false;
	}

	public void removeViewSpecific(AttributeMapOwner owner, String key) {
		AttributeMap map = maps.get(owner);
		if (map == null) {
			return;
		}
		map.remove(key);
	}

	public Set<AttributeMapOwner> keySet() {
		return maps.keySet();
	}

	public AttributeMap getMapFor(AttributeMapOwner node) {
		AttributeMap m = maps.get(node);
		if (m == null) {
			m = new AttributeMap();
			maps.put(node, m);
		}
		return m;
	}

	public ViewSpecificAttributeMap createClone() {
		ViewSpecificAttributeMap map = new ViewSpecificAttributeMap();
		for (AttributeMapOwner owner : maps.keySet()) {
			for (String key : maps.get(owner).keySet()) {
				map.putViewSpecific(owner, key, maps.get(owner).get(key));
			}
		}
		return map;
	}
}
"
GraphLayoutConnection.java,model,"package org.processmining.models.connections;

import java.awt.Dimension;
import java.awt.geom.Dimension2D;
import java.awt.geom.Point2D;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.List;

import org.jgraph.graph.GraphConstants;
import org.processmining.framework.connections.DynamicConnection;
import org.processmining.framework.connections.impl.AbstractConnection;
import org.processmining.models.graphbased.AttributeMap;
import org.processmining.models.graphbased.AttributeMapOwner;
import org.processmining.models.graphbased.Expandable;
import org.processmining.models.graphbased.ExpansionListener;
import org.processmining.models.graphbased.ExpansionListener.ListenerList;
import org.processmining.models.graphbased.ViewSpecificAttributeMap;
import org.processmining.models.graphbased.directed.DirectedGraph;
import org.processmining.models.graphbased.directed.DirectedGraphElement;

public class GraphLayoutConnection extends AbstractConnection implements DynamicConnection {

	/**
	 * A List<java.awt.geom.Point2D> of points, which are the inner points of
	 * the spline.
	 * 
	 */
	protected final static String EDGEPOINTS = ""edgepoints"";

	public boolean setEdgePoints(AttributeMapOwner owner, List<Point2D> edgepoints) {
		return map.putViewSpecific(owner, EDGEPOINTS, edgepoints);
	}

	public List<Point2D> getEdgePoints(AttributeMapOwner owner) {
		return map.get(owner, EDGEPOINTS, Collections.<Point2D>emptyList());
	}

	/**
	 * a get on size returns a java.awt.geom.Dimension2D.
	 */
	protected static final String SIZE = ""size"";

	public boolean setSize(AttributeMapOwner owner, Dimension2D size) {
		return map.putViewSpecific(owner, SIZE, size);
	}

	public Dimension getSize(AttributeMapOwner owner) {
		return map.get(owner, SIZE, new Dimension(100, 100));
	}

	/**
	 * a get on size returns a java.awt.geom.Point2D.
	 */
	protected static final String POSITION = ""position"";

	public boolean setPosition(AttributeMapOwner owner, Point2D position) {
		return map.putViewSpecific(owner, POSITION, position);
	}

	public Point2D getPosition(AttributeMapOwner owner) {
		return map.get(owner, POSITION, null);
	}

	protected static final String COLLAPSED = ""collapsed"";

	public boolean collapse(AttributeMapOwner owner) {
		return map.putViewSpecific(owner, COLLAPSED, false);
	}

	public boolean expand(AttributeMapOwner owner) {
		return map.putViewSpecific(owner, COLLAPSED, true);
	}

	public boolean isCollapsed(AttributeMapOwner owner) {
		return map.get(owner, COLLAPSED, false);
	}

	protected final static String PORTOFFSET = ""portOffset"";

	public boolean setPortOffset(AttributeMapOwner owner, Point2D position) {
		return map.putViewSpecific(owner, PORTOFFSET, position);
	}

	public Point2D getPortOffset(AttributeMapOwner owner) {
		return map.get(owner, PORTOFFSET, new Point2D.Double(GraphConstants.PERMILLE / 2, GraphConstants.PERMILLE / 2));
	}

	public static interface Listener {
		public void layoutConnectionUpdated(AttributeMapOwner... owners);
	}

	public static final String GRAPH = ""graph"";
	private boolean layedOut = false;
	private final ViewSpecificAttributeMap map;
	private transient ExpansionListener.ListenerList expListeners = new ExpansionListener.ListenerList();
	private transient List<Listener> listeners = new ArrayList<Listener>();

	public GraphLayoutConnection(GraphLayoutConnection cloneFrom) {
		super(cloneFrom.getLabel());
		this.map = cloneFrom.map.createClone();
		put(GRAPH, cloneFrom.get(GRAPH));
		this.layedOut = cloneFrom.layedOut;

	}

	public GraphLayoutConnection(DirectedGraph<?, ?> graph) {
		super(""Layout information for "" + graph.getLabel());
		this.map = new ViewSpecificAttributeMap();
		put(GRAPH, graph);

		for (AttributeMapOwner node : graph.getNodes()) {
			setSize(node, node.getAttributeMap().get(AttributeMap.SIZE, new Dimension(50, 50)));
			setPortOffset(
					node,
					node.getAttributeMap().get(AttributeMap.PORTOFFSET,
							new Point2D.Double(GraphConstants.PERMILLE / 2, GraphConstants.PERMILLE / 2)));
		}

	}

	public DirectedGraph<?, ?> getGraph() {
		return (DirectedGraph<?, ?>) get(GRAPH);
	}

	//	public ViewSpecificAttributeMap getMap() {
	//		return map;
	//	}

	public void setLayedOut(boolean layedOut) {
		this.layedOut = layedOut;
		updatedAttributes();
	}

	public boolean isLayedOut() {
		return layedOut;
	}

	public void expandAll() {
		List<Expandable> updated = new ArrayList<Expandable>();
		for (AttributeMapOwner owner : map.keySet()) {
			if (owner instanceof Expandable) {
				updated.add((Expandable) owner);
			}
		}
		expandAll(updated);
	}

	public void collapseAll() {
		List<Expandable> updated = new ArrayList<Expandable>();
		for (AttributeMapOwner owner : map.keySet()) {
			if (owner instanceof Expandable) {
				updated.add((Expandable) owner);
			}
		}
		collapseAll(updated);
	}

	public void expandAll(Collection<Expandable> toExpand) {
		for (Expandable owner : toExpand) {
			expand(owner, false);
		}
		updatedAttributes(toExpand.toArray(new Expandable[0]));
	}

	public void collapseAll(Collection<Expandable> toCollapse) {
		for (Expandable owner : toCollapse) {
			collapse(owner, false);
		}
		updatedAttributes(toCollapse.toArray(new Expandable[0]));
	}

	public void expand(Expandable expandable) {
		expand(expandable, true);
	}

	public void collapse(Expandable expandable) {
		collapse(expandable, true);
	}

	void expand(Expandable expandable, boolean update) {
		expListeners.fireNodeExpanded(expandable);
	}

	void collapse(Expandable expandable, boolean update) {
		expListeners.fireNodeCollapsed(expandable);
	}

	public ExpansionListener.ListenerList getExpansionListeners() {
		return expListeners;
	}

	public void addListener(Listener listener) {
		listeners.add(listener);
	}

	public void removeListener(Listener listener) {
		listeners.remove(listener);
	}

	public void updatedAttributes(AttributeMapOwner... owners) {
		for (Listener l : listeners) {
			l.layoutConnectionUpdated(owners);
		}
		super.updated();
	}

	private Object readResolve() {
		this.expListeners = new ListenerList();
		listeners = new ArrayList<Listener>();
		return this;

	}

	protected static final String MULTIGRAPHELEMENTS = ""multigraphelements"";

	public boolean setMultiGraphElements(AttributeMapOwner owner, List<DirectedGraphElement> tempGraphElements) {
		return map.putViewSpecific(owner, MULTIGRAPHELEMENTS, tempGraphElements);
	}

	public List<DirectedGraphElement> getMultiGraphElements(AttributeMapOwner owner) {
		return map.get(owner, MULTIGRAPHELEMENTS, Collections.<DirectedGraphElement>emptyList());
	}

}
"
ExecutionInformation.java,model,"package org.processmining.models.semantics;

public interface ExecutionInformation {

}
"
ExtendedSemantics.java,model,"package org.processmining.models.semantics;

public interface ExtendedSemantics<S, T> extends Semantics<S, T> {

	ExecutionInformation executeTransition(T toExecute);

}
"
IllegalTransitionException.java,model,"package org.processmining.models.semantics;

public class IllegalTransitionException extends Exception {

	private static final long serialVersionUID = -3136219267846046893L;

	public IllegalTransitionException(Object trans, Object state) {
		super(""Cannot execute transition "" + trans + "" in state "" + state);
	}

	public <S> IllegalTransitionException(Object trans, Object state, String reason) {
		super(""Cannot execute transition "" + trans + "" in state "" + state + "" Reason: "" + reason);
	}
}
"
Semantics.java,model,"package org.processmining.models.semantics;

import java.io.Serializable;
import java.util.Collection;

public interface Semantics<S, T> extends Serializable {

	void setCurrentState(S currentState);

	S getCurrentState();

	Collection<T> getExecutableTransitions();

	ExecutionInformation executeExecutableTransition(T toExecute) throws IllegalTransitionException;

	/**
	 * Initializes this semantics. Note that the set of transitions is
	 * considered read only, i.e. no changes can be made to it by a
	 * Semantics<S,T> implementation. However, the initial state is not read
	 * only.
	 * 
	 * @param transitions
	 * @param initialState
	 */
	void initialize(Collection<T> transitions, S initialState);
}
"
AbstractShape.java,model,"package org.processmining.models.shapes;

import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;

public abstract class AbstractShape implements Shape {

	protected Point2D intersection(Point2D a1, Point2D a2, Point2D b1, Point2D b2) {

		double ua_t = (b2.getX() - b1.getX()) * (a1.getY() - b1.getY()) - (b2.getY() - b1.getY())
				* (a1.getX() - b1.getX());
		double ub_t = (a2.getX() - a1.getX()) * (a1.getY() - b1.getY()) - (a2.getY() - a1.getY())
				* (a1.getX() - b1.getX());
		double u_b = (b2.getY() - b1.getY()) * (a2.getX() - a1.getX()) - (b2.getX() - b1.getX())
				* (a2.getY() - a1.getY());

		if (u_b != 0) {
			double ua = ua_t / u_b;
			double ub = ub_t / u_b;

			if ((0 <= ua) && (ua <= 1) && (0 <= ub) && (ub <= 1)) {
				return new Point2D.Double(a1.getX() + ua * (a2.getX() - a1.getX()), a1.getY() + ua
						* (a2.getY() - a1.getY()));
			}
		}
		return null;
	}

	public Point2D getPerimeterPoint(Rectangle2D bounds, Point2D source, Point2D p) {

		double x = bounds.getX();
		double y = bounds.getY();
		double width = bounds.getWidth() - 1;
		double height = bounds.getHeight() - 1;

		double xCenter = x + width / 2;
		double yCenter = y + height / 2;
		double dx = p.getX() - xCenter; // Compute Angle
		double dy = p.getY() - yCenter;
		double alpha = Math.atan2(dy, dx);
		double xout = 0, yout = 0;
		double pi = Math.PI;
		double pi2 = Math.PI / 2.0;
		double beta = pi2 - alpha;
		double t = Math.atan2(height, width);
		if ((alpha < -pi + t) || (alpha > pi - t)) { // Left edge
			xout = x;
			yout = yCenter - width * Math.tan(alpha) / 2;
		} else if (alpha < -t) { // Top Edge
			yout = y;
			xout = xCenter - height * Math.tan(beta) / 2;
		} else if (alpha < t) { // Right Edge
			xout = x + width;
			yout = yCenter + width * Math.tan(alpha) / 2;
		} else { // Bottom Edge
			yout = y + height;
			xout = xCenter + height * Math.tan(beta) / 2;
		}
		return new Point2D.Double(xout, yout);
	}

}
"
Decorated.java,model,"package org.processmining.models.shapes;

import java.awt.Graphics2D;

public interface Decorated {

	public void decorate(Graphics2D g2d, double x, double y, double width, double height);

}
"
Diamond.java,model,"package org.processmining.models.shapes;

import java.awt.geom.Point2D;

public class Diamond extends Polygon {

	protected Point2D[] getPoints(double x, double y, double width, double height) {
		Point2D[] points = new Point2D[4];
		points[0] = new Point2D.Double(x, y + (height - 1) / 2);
		points[1] = new Point2D.Double(x + (width - 1) / 2, y);
		points[2] = new Point2D.Double(x + (width - 1), y + (height - 1) / 2);
		points[3] = new Point2D.Double(x + (width - 1) / 2, y + (height - 1));
		return points;
	}

}
"
Ellipse.java,model,"package org.processmining.models.shapes;

import java.awt.Point;
import java.awt.geom.Ellipse2D;
import java.awt.geom.GeneralPath;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;

public class Ellipse implements Shape {

	public Ellipse() {
	}

	public GeneralPath getPath(double x, double y, double width, double height) {
		GeneralPath path = new GeneralPath();

		Ellipse2D e = new Ellipse2D.Double(x, y, width - 1, height - 1);

		path.append(e, false);

		return path;
	}

	public Point2D getPerimeterPoint(Rectangle2D bounds, Point2D source, Point2D p) {

		double x = bounds.getX();
		double y = bounds.getY();
		double a = (bounds.getWidth() - 1) / 2;
		double b = (bounds.getHeight() - 1) / 2;

		// x0,y0 - center of ellipse
		double x0 = x + a;
		double y0 = y + b;

		// x1, y1 - point
		double x1 = p.getX();
		double y1 = p.getY();

		// calculate straight line equation through point and ellipse center
		// y = d * x + h
		double dx = x1 - x0;
		double dy = y1 - y0;

		if (dx == 0) {
			return new Point((int) x0, (int) (y0 + b * dy / Math.abs(dy)));
		}

		double d = dy / dx;
		double h = y0 - d * x0;

		// calculate intersection
		double e = a * a * d * d + b * b;
		double f = -2 * x0 * e;
		double g = a * a * d * d * x0 * x0 + b * b * x0 * x0 - a * a * b * b;

		double det = Math.sqrt(f * f - 4 * e * g);

		// two solutions (perimeter points)
		double xout1 = (-f + det) / (2 * e);
		double xout2 = (-f - det) / (2 * e);
		double yout1 = d * xout1 + h;
		double yout2 = d * xout2 + h;

		double dist1Squared = Math.pow((xout1 - x1), 2) + Math.pow((yout1 - y1), 2);
		double dist2Squared = Math.pow((xout2 - x1), 2) + Math.pow((yout2 - y1), 2);

		// correct solution
		double xout, yout;

		if (dist1Squared < dist2Squared) {
			xout = xout1;
			yout = yout1;
		} else {
			xout = xout2;
			yout = yout2;
		}

		return new Point2D.Double(xout, yout);
	}

}
"
Gate.java,model,"package org.processmining.models.shapes;

import java.awt.geom.GeneralPath;
import java.awt.geom.QuadCurve2D;

public class Gate extends AbstractShape {

	public final static int RIGHT = 0;
	public final static int TOP = 2;
	public final static int LEFT = 4;
	public final static int BOTTOM = 6;

	private final int direction;

	public Gate(int direction) {
		this.direction = direction;
	}

	public GeneralPath getPath(double x, double y, double width, double height) {

		// Width and height have correct ratio;
		GeneralPath path = new GeneralPath();
		double[] points = new double[] { x, y, x + width, y, x + width, y + height, x, y + height };
		double[] midpts = new double[] { x + width, y + height / 2., x + width / 2., y, x, y + height / 2.,
				x + width / 2., y };

		int d = direction;
		path.moveTo(points[d % 8], points[d % 8]);

		//		path.curveTo(points[d++ % 8], points[d++ % 8], points[d++ % 8], points[d++ % 8], points[d++ % 8],
		//				points[d++ % 8]);

		QuadCurve2D curve = new QuadCurve2D.Double(points[d++ % 8], points[d++ % 8], points[d++ % 8], points[d++ % 8],
				midpts[direction], midpts[direction + 1]);
		path.append(curve, true);

		curve = new QuadCurve2D.Double(midpts[direction], midpts[direction + 1], points[d++ % 8], points[d++ % 8],
				points[d++ % 8], points[d++ % 8]);
		path.append(curve, true);

		path.lineTo(points[d++ % 8], points[d++ % 8]);

		return path;
	}
}
"
Hexagon.java,model,"package org.processmining.models.shapes;

import java.awt.geom.Point2D;

public class Hexagon extends Polygon {

	private final double cornerOffset;

	public Hexagon(double cornerOffset) {
		this.cornerOffset = cornerOffset;
	}

	protected Point2D[] getPoints(double x, double y, double width, double height) {
		Point2D[] points = new Point2D[6];
		double offset = width * cornerOffset;

		points[0] = new Point2D.Double(x + offset, y);
		points[1] = new Point2D.Double(x, y + (height - 1) / 2);
		points[2] = new Point2D.Double(x + offset, y + height - 1);
		points[3] = new Point2D.Double(x + width - 1 - offset, y + height - 1);
		points[4] = new Point2D.Double(x + width - 1, y + (height - 1) / 2);
		points[5] = new Point2D.Double(x + width - 1 - offset, y);
		return points;
	}

}
"
Octagon.java,model,"package org.processmining.models.shapes;

import java.awt.geom.Point2D;

public class Octagon extends Polygon {

	private final double cornerOffset;

	public Octagon(double cornerOffset) {
		this.cornerOffset = cornerOffset;
	}

	protected Point2D[] getPoints(double x, double y, double width, double height) {
		Point2D[] points = new Point2D[8];
		double offset = width * cornerOffset;

		points[0] = new Point2D.Double(x + offset, y);
		points[1] = new Point2D.Double(x, y + (height - 1) / 3);
		points[2] = new Point2D.Double(x, y + 2 * (height - 1) / 3);
		points[3] = new Point2D.Double(x + offset, y + height - 1);
		points[4] = new Point2D.Double(x + width - 1 - offset, y + height - 1);
		points[5] = new Point2D.Double(x + width - 1, y + 2 * (height - 1) / 3);
		points[6] = new Point2D.Double(x + width - 1, y + (height - 1) / 3);
		points[7] = new Point2D.Double(x + width - 1 - offset, y);
		return points;
	}

}"
Polygon.java,model,"package org.processmining.models.shapes;

import java.awt.geom.GeneralPath;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;

public abstract class Polygon extends AbstractShape {

	public Point2D getPerimeterPoint(Rectangle2D bounds, Point2D source, Point2D p) {
		// Use a linde from centerPoint to p, juist like ellipse. This is
		// an ""estimate"", but the centerpoint is sure to be inside the perimiter

		double x = bounds.getX();
		double y = bounds.getY();
		double height = bounds.getHeight();
		double width = bounds.getWidth();

		// x0,y0 - center of ellipse
		Point2D center = new Point2D.Double(x + (width + 1) / 2, y + (height + 1) / 2);

		Point2D[] points = getPoints(x, y, width, height);

		Point2D point = null;

		for (int i = 0; i < points.length; i++) {
			point = intersection(p, center, points[i], points[(i + 1) % points.length]);
			if (point != null) {
				return point;
			}
		}

		return point;
	}

	protected abstract Point2D[] getPoints(double x, double y, double width, double height);

	public GeneralPath getPath(double x, double y, double width, double height) {
		// Width and height have correct ratio;
		GeneralPath path = new GeneralPath();

		Point2D[] points = getPoints(x, y, width, height);

		path.moveTo((float) points[0].getX(), (float) points[0].getY());
		for (int i = 1; i < points.length; i++) {
			path.lineTo((float) points[i].getX(), (float) points[i].getY());
		}
		path.closePath();
		return path;

	}

}
"
Rectangle.java,model,"package org.processmining.models.shapes;

import java.awt.geom.GeneralPath;
import java.awt.geom.Rectangle2D;
import java.awt.geom.RoundRectangle2D;

public class Rectangle extends AbstractShape {

	private final boolean rounded;

	public Rectangle() {
		this(false);
	}

	public Rectangle(boolean rounded) {
		this.rounded = rounded;
	}

	public GeneralPath getPath(double x, double y, double width, double height) {

		java.awt.Shape rect;
		if (rounded) {
			double m = Math.max(width, height) * .125;
			rect = new RoundRectangle2D.Double(x, y, width - 1, height - 1, m, m);
		} else {
			rect = new Rectangle2D.Double(x, y, width - 1, height - 1);
		}
		// Width and height have correct ratio;
		GeneralPath path = new GeneralPath();
		path.append(rect, false);
		return path;

	}

}
"
RoundedRect.java,model,"/**
 * 
 */
package org.processmining.models.shapes;

import java.awt.geom.GeneralPath;
import java.awt.geom.RoundRectangle2D;

/**
 * @author Arya Adriansyah
 * @email a.adriansyah@tue.nl
 * @version Apr 5, 2010
 * 
 */
public class RoundedRect extends AbstractShape {

	public GeneralPath getPath(double x, double y, double width, double height) {
		double m = Math.max(width, height) * .125;

		// Width and height have correct ratio;
		GeneralPath path = new GeneralPath();

		// main border
		java.awt.Shape rect = new RoundRectangle2D.Double(x, y, width, height, m, m);
		path.append(rect, false);

		return path;
	}

}
"
Shape.java,model,"package org.processmining.models.shapes;

import java.awt.geom.GeneralPath;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;

public interface Shape {

	public GeneralPath getPath(double x, double y, double width, double height);

	public Point2D getPerimeterPoint(Rectangle2D bounds, Point2D source, Point2D p);

}
"
HelloWorld.java,plugin,"package org.processmining.plugins;

import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;

public class HelloWorld {
        @Plugin(
                name = ""My Hello World Plugin"", 
                parameterLabels = {}, 
                returnLabels = { ""Hello world string"" }, 
                returnTypes = { String.class }, 
                userAccessible = true, 
                help = ""Produces the string: 'Hello world'""
        )
        @UITopiaVariant(
                affiliation = ""My company"", 
                author = ""My name"", 
                email = ""My e-mail address""
        )
        public static String helloWorld(PluginContext context) {
                return ""Hello World"";
        }
}"
ShowPackageOverviewPlugin.java,plugin,"package org.processmining.plugins;

import java.util.Collection;
import java.util.List;

import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.contexts.uitopia.annotations.UIExportPlugin;
import org.processmining.contexts.uitopia.annotations.UIImportPlugin;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.contexts.uitopia.annotations.Visualizer;
import org.processmining.contexts.uitopia.packagemanager.PMController;
import org.processmining.contexts.uitopia.packagemanager.PMPackage;
import org.processmining.framework.boot.Boot;
import org.processmining.framework.packages.PackageDescriptor;
import org.processmining.framework.plugin.PluginDescriptor;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginLevel;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.framework.util.HTMLToString;

@Plugin(name = ""Show Package Overview"", parameterLabels = {}, level= PluginLevel.BulletProof, returnLabels = { ""Release info"" }, returnTypes = { HTMLToString.class }, userAccessible = true)
public class ShowPackageOverviewPlugin implements HTMLToString {

	private Collection<PluginDescriptor> pluginDescriptors;

	private ShowPackageOverviewPlugin(UIPluginContext context) {
		pluginDescriptors = context.getPluginManager().getAllPlugins();
	}

	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""H.M.W. Verbeek"", email = ""h.m.w.verbeek@tue.nl"")
	@PluginVariant(variantLabel = ""Default"", requiredParameterLabels = {})
	public static HTMLToString info(final UIPluginContext context) {
		return new ShowPackageOverviewPlugin(context);
	}

	@Override
	public String toHTMLString(boolean includeHTMLTags) {
		StringBuffer buffer = new StringBuffer();

		if (includeHTMLTags) {
			buffer.append(""<html>"");
		}
		buffer.append(""<h1>ProM Package Overview</h1>"");

		PMController packageController = new PMController(Boot.Level.NONE);
		List<? extends PMPackage> uptodatePackages = packageController.getToUninstallPackages();
		List<? extends PMPackage> outofdatePackages = packageController.getToUpdatePackages();
		buffer.append(""<h2>Installed packages</h2>"");
		buffer.append(""<table>"");
		buffer.append(""<tr><th>Package</th><th>Dependency</th><th>Version</th><th>Author</th></tr>"");
		for (PMPackage pack : uptodatePackages) {
			buffer.append(""<tr>"");
			buffer.append(""<td>"" + pack.getPackageName() + ""</td>"");
			buffer.append(""<td></td>"");
			buffer.append(""<td>"" + pack.getVersion() + ""</td>"");
			buffer.append(""<td>"" + pack.getAuthorName() + ""</td>"");
			buffer.append(""</tr>"");
			for (String s : pack.getDependencies()) {
				buffer.append(""<tr><td></td><td>"" + s + ""</td><td></td><td></td></tr>"");
			}
		}
		buffer.append(""</table>"");
		buffer.append(""<h3>Updates available</h3>"");
		buffer.append(""<table>"");
		buffer.append(""<tr><th>Package name</th><th>Dependency names</th><th>Version number</th><th>Author name</th></tr>"");
		for (PMPackage pack : outofdatePackages) {
			buffer.append(""<tr>"");
			buffer.append(""<td>"" + pack.getPackageName() + ""</td>"");
			buffer.append(""<td></td>"");
			buffer.append(""<td>"" + pack.getVersion() + ""</td>"");
			buffer.append(""<td>"" + pack.getAuthorName() + ""</td>"");
			buffer.append(""</tr>"");
			for (String s : pack.getDependencies()) {
				buffer.append(""<tr><td></td><td>"" + s + ""</td><td></td><td></td></tr>"");
			}
		}
		buffer.append(""</table>"");

		buffer.append(""<h2>Available plug-ins</h2>"");
		buffer.append(""<table>"");
		buffer.append(""<tr><th>Plug-in name</th><th>UITopia</th><th>UITopia name</th><th>Package name</th><th>Author name</th></tr>"");
		for (PluginDescriptor pluginDescriptor : pluginDescriptors) {
			String uiName = null;
			boolean isUITopia = false;
			UITopiaVariant variant = pluginDescriptor.getAnnotation(UITopiaVariant.class);
			if (variant != null) {
				uiName = variant.uiLabel();
				isUITopia = true;
				buffer.append(""<tr>"");
				buffer.append(""<td>"" + pluginDescriptor.getName() + ""</td>"");
				buffer.append(""<td>Plug-in</td>"");
				buffer.append(""<td>"" + (uiName == null ? """" : uiName) + ""</td>"");
				String packName = null;
				PackageDescriptor packageDescriptor = pluginDescriptor.getPackage();
				if (packageDescriptor != null) {
					packName = packageDescriptor.getName();
				}
				buffer.append(""<td>"" + (packName == null ? """" : packName) + ""</td>"");
				buffer.append(""<td>"" + variant.author() + ""</td>"");
				buffer.append(""</tr>"");
			}
			Visualizer visualizer = pluginDescriptor.getAnnotation(Visualizer.class);
			if (visualizer != null) {
				uiName = visualizer.name();
				isUITopia = true;
				buffer.append(""<tr>"");
				buffer.append(""<td>"" + pluginDescriptor.getName() + ""</td>"");
				buffer.append(""<td>Visualizer</td>"");
				buffer.append(""<td>"" + (uiName == null ? """" : uiName) + ""</td>"");
				String packName = null;
				String authorName = null;
				PackageDescriptor packageDescriptor = pluginDescriptor.getPackage();
				if (packageDescriptor != null) {
					packName = packageDescriptor.getName();
					authorName = packageDescriptor.getAuthor();
				}
				buffer.append(""<td>"" + (packName == null ? """" : packName) + ""</td>"");
				buffer.append(""<td>"" + (authorName == null ? """" : authorName) + ""</td>"");
				buffer.append(""</tr>"");
			}
			UIImportPlugin importPlugin = pluginDescriptor.getAnnotation(UIImportPlugin.class);
			if (importPlugin != null) {
				uiName = pluginDescriptor.getName();
				isUITopia = true;
				buffer.append(""<tr>"");
				buffer.append(""<td>"" + pluginDescriptor.getName() + ""</td>"");
				buffer.append(""<td>Import</td>"");
				buffer.append(""<td>"" + (uiName == null ? """" : uiName) + ""</td>"");
				String packName = null;
				String authorName = null;
				PackageDescriptor packageDescriptor = pluginDescriptor.getPackage();
				if (packageDescriptor != null) {
					packName = packageDescriptor.getName();
					authorName = packageDescriptor.getAuthor();
				}
				buffer.append(""<td>"" + (packName == null ? """" : packName) + ""</td>"");
				buffer.append(""<td>"" + (authorName == null ? """" : authorName) + ""</td>"");
				buffer.append(""</tr>"");
			}
			UIExportPlugin exportPlugin = pluginDescriptor.getAnnotation(UIExportPlugin.class);
			if (exportPlugin != null) {
				uiName = pluginDescriptor.getName();
				isUITopia = true;
				buffer.append(""<tr>"");
				buffer.append(""<td>"" + pluginDescriptor.getName() + ""</td>"");
				buffer.append(""<td>Export</td>"");
				buffer.append(""<td>"" + (uiName == null ? """" : uiName) + ""</td>"");
				String packName = null;
				String authorName = null;
				PackageDescriptor packageDescriptor = pluginDescriptor.getPackage();
				if (packageDescriptor != null) {
					packName = packageDescriptor.getName();
					authorName = packageDescriptor.getAuthor();
				}
				buffer.append(""<td>"" + (packName == null ? """" : packName) + ""</td>"");
				buffer.append(""<td>"" + (authorName == null ? """" : authorName) + ""</td>"");
				buffer.append(""</tr>"");
			}
			for (int i = 0; i < pluginDescriptor.getNumberOfMethods(); i++) {
				variant = pluginDescriptor.getAnnotation(UITopiaVariant.class, i);
				if (variant != null) {
					uiName = variant.uiLabel();
					isUITopia = true;
					buffer.append(""<tr>"");
					buffer.append(""<td>"" + pluginDescriptor.getName() + ""</td>"");
					buffer.append(""<td>Plug-in variant</td>"");
					buffer.append(""<td>"" + (uiName == null ? """" : uiName) + ""</td>"");
					String packName = null;
					PackageDescriptor packageDescriptor = pluginDescriptor.getPackage();
					if (packageDescriptor != null) {
						packName = packageDescriptor.getName();
					}
					buffer.append(""<td>"" + (packName == null ? """" : packName) + ""</td>"");
					buffer.append(""<td>"" + variant.author() + ""</td>"");
					buffer.append(""</tr>"");
				}
			}
			if (!isUITopia) {
				buffer.append(""<tr>"");
				buffer.append(""<td>"" + pluginDescriptor.getName() + ""</td>"");
				buffer.append(""<td></td>"");
				buffer.append(""<td>"" + (uiName == null ? """" : uiName) + ""</td>"");
				String packName = null;
				String authorName = null;
				PackageDescriptor packageDescriptor = pluginDescriptor.getPackage();
				if (packageDescriptor != null) {
					packName = packageDescriptor.getName();
					authorName = packageDescriptor.getAuthor();
				}
				buffer.append(""<td>"" + (packName == null ? """" : packName) + ""</td>"");
				buffer.append(""<td>"" + (authorName == null ? """" : authorName) + ""</td>"");
				buffer.append(""</tr>"");
			}
		}
		buffer.append(""</table>"");
		if (includeHTMLTags) {
			buffer.append(""</html>"");
		}
		return buffer.toString();
	}
}
"
License.java,saxon,"package org.processmining.saxon;

public class License {
	
	public static String VALUE = ""MPL"";

}
"
ContextMenuCreator.java,widget,"package org.processmining.models.jgraph;

import java.util.Collection;

import javax.swing.JPopupMenu;

import org.processmining.models.graphbased.directed.DirectedGraph;
import org.processmining.models.graphbased.directed.DirectedGraphElement;

public interface ContextMenuCreator {

	JPopupMenu createMenuFor(DirectedGraph<?, ?> graph, Collection<DirectedGraphElement> selectedElements);

}
"
DirectedGraphEdgeForMultiGraph.java,widget,"package org.processmining.models.jgraph;

import java.awt.geom.Point2D;
import java.util.Arrays;

import org.processmining.models.graphbased.AbstractGraphElement;
import org.processmining.models.graphbased.AttributeMap;
import org.processmining.models.graphbased.directed.DirectedGraph;
import org.processmining.models.graphbased.directed.DirectedGraphEdge;
import org.processmining.models.graphbased.directed.DirectedGraphNode;

public final class DirectedGraphEdgeForMultiGraph extends AbstractGraphElement implements
		DirectedGraphEdge<DirectedGraphNode, DirectedGraphNode>, DirectedGraphElementForMultiEdge {
	private final DirectedGraphNode source;
	private final DirectedGraphNode target;
	private final DirectedGraphEdge<?, ?> e;
	private boolean toIntermediate;

	public DirectedGraphEdgeForMultiGraph(DirectedGraphNode source, DirectedGraphNodeForMultiGraph intermediate,
			DirectedGraphEdge<?, ?> e) {
		this.source = source;
		this.target = intermediate;
		this.e = e;
		copyAttributes(true, e.getAttributeMap());
	}

	public DirectedGraphEdgeForMultiGraph(DirectedGraphNodeForMultiGraph intermediate, DirectedGraphNode target,
			DirectedGraphEdge<?, ?> e) {
		this.source = intermediate;
		this.target = target;
		this.e = e;
		copyAttributes(false, e.getAttributeMap());
	}

	protected void copyAttributes(boolean toIntermediate, AttributeMap sourceMap) {

		this.toIntermediate = toIntermediate;
		if (sourceMap.containsKey(AttributeMap.STYLE))
			getAttributeMap().put(AttributeMap.STYLE, sourceMap.get(AttributeMap.STYLE));
		if (sourceMap.containsKey(AttributeMap.LINEWIDTH))
			getAttributeMap().put(AttributeMap.LINEWIDTH, sourceMap.get(AttributeMap.LINEWIDTH));
		if (sourceMap.containsKey(AttributeMap.DASHPATTERN))
			getAttributeMap().put(AttributeMap.DASHPATTERN, sourceMap.get(AttributeMap.DASHPATTERN));
		if (sourceMap.containsKey(AttributeMap.DASHOFFSET))
			getAttributeMap().put(AttributeMap.DASHOFFSET, sourceMap.get(AttributeMap.DASHOFFSET));
		if (sourceMap.containsKey(AttributeMap.LABELCOLOR))
			getAttributeMap().put(AttributeMap.LABELCOLOR, sourceMap.get(AttributeMap.LABELCOLOR));

		if (sourceMap.containsKey(AttributeMap.NUMLINES))
			getAttributeMap().put(AttributeMap.NUMLINES, sourceMap.get(AttributeMap.NUMLINES));
		if (sourceMap.containsKey(AttributeMap.LINEWIDTH))
			getAttributeMap().put(AttributeMap.LINEWIDTH, sourceMap.get(AttributeMap.LINEWIDTH));

		if (sourceMap.containsKey(AttributeMap.EDGECOLOR))
			getAttributeMap().put(AttributeMap.EDGECOLOR, sourceMap.get(AttributeMap.EDGECOLOR));

		if (toIntermediate) {
			if (sourceMap.containsKey(AttributeMap.EDGESTART))
				getAttributeMap().put(AttributeMap.EDGESTART, sourceMap.get(AttributeMap.EDGESTART));
			if (sourceMap.containsKey(AttributeMap.EDGESTARTFILLED))
				getAttributeMap().put(AttributeMap.EDGESTARTFILLED, sourceMap.get(AttributeMap.EDGESTARTFILLED));
			if (source == e.getSource()) {
				// draw the middle shape only once if the source is indeed the edge main source
				if (sourceMap.containsKey(AttributeMap.EDGEMIDDLE))
					getAttributeMap().put(AttributeMap.EDGEEND, sourceMap.get(AttributeMap.EDGEMIDDLE));
				if (sourceMap.containsKey(AttributeMap.EDGEMIDDLEFILLED))
					getAttributeMap().put(AttributeMap.EDGEENDFILLED, sourceMap.get(AttributeMap.EDGEMIDDLEFILLED));
			}
		} else {
			if (sourceMap.containsKey(AttributeMap.EDGEEND))
				getAttributeMap().put(AttributeMap.EDGEEND, sourceMap.get(AttributeMap.EDGEEND));
			if (sourceMap.containsKey(AttributeMap.EDGEENDFILLED))
				getAttributeMap().put(AttributeMap.EDGEENDFILLED, sourceMap.get(AttributeMap.EDGEENDFILLED));
		}

		if (sourceMap.containsKey(AttributeMap.EXTRALABELPOSITIONS)) {
			assert ((Point2D[]) sourceMap.get(AttributeMap.EXTRALABELPOSITIONS)).length == ((String[]) sourceMap
					.get(AttributeMap.EXTRALABELS)).length;
			Point2D[] points = (Point2D[]) sourceMap.get(AttributeMap.EXTRALABELPOSITIONS);
			String[] labels = (String[]) sourceMap.get(AttributeMap.EXTRALABELS);
			if (toIntermediate) {
				getAttributeMap().put(AttributeMap.EXTRALABELPOSITIONS,
						Arrays.copyOfRange(points, 0, points.length / 2));
				getAttributeMap().put(AttributeMap.EXTRALABELS, Arrays.copyOfRange(labels, 0, points.length / 2));
			} else {
				getAttributeMap().put(AttributeMap.EXTRALABELPOSITIONS,
						Arrays.copyOfRange(points, points.length / 2, points.length));
				getAttributeMap().put(AttributeMap.EXTRALABELS,
						Arrays.copyOfRange(labels, points.length / 2, points.length));
			}
		}
	}

	public String getLabel() {
		return source.getLabel() + ""->"" + target.getLabel();
	}

	public DirectedGraph<?, ?> getGraph() {
		return source.getGraph();
	}

	public DirectedGraphNode getSource() {
		return source;
	}

	public DirectedGraphNode getTarget() {
		return target;
	}

	public int hashCode() {
		return e.hashCode() * 31 + (toIntermediate ? source.hashCode() : target.hashCode());
	}

	public boolean equals(Object o) {
		if (o instanceof DirectedGraphEdgeForMultiGraph) {
			DirectedGraphEdgeForMultiGraph edge = (DirectedGraphEdgeForMultiGraph) o;
			return (edge.e.equals(e) && toIntermediate ? edge.source.equals(source) : edge.target.equals(target));
		}
		return false;
	}

	public boolean isToIntermediate() {
		return toIntermediate;
	}

	public DirectedGraphEdge<?, ?> getMultiEdge() {
		return e;
	}
}"
DirectedGraphElementForMultiEdge.java,widget,"package org.processmining.models.jgraph;

import org.processmining.models.graphbased.directed.DirectedGraphEdge;

public interface DirectedGraphElementForMultiEdge {

	public DirectedGraphEdge<?,?> getMultiEdge();
}
"
DirectedGraphNodeForMultiGraph.java,widget,"package org.processmining.models.jgraph;

import java.awt.Dimension;

import org.processmining.models.graphbased.AbstractGraphElement;
import org.processmining.models.graphbased.AttributeMap;
import org.processmining.models.graphbased.NodeID;
import org.processmining.models.graphbased.directed.DirectedGraph;
import org.processmining.models.graphbased.directed.DirectedGraphEdge;
import org.processmining.models.graphbased.directed.DirectedGraphNode;
import org.processmining.models.shapes.Rectangle;

public final class DirectedGraphNodeForMultiGraph extends AbstractGraphElement implements DirectedGraphNode,
		DirectedGraphElementForMultiEdge {
	private final DirectedGraphEdge<?, ?> e;
	private NodeID id = new NodeID();

	public DirectedGraphNodeForMultiGraph(DirectedGraphEdge<?, ?> e) {
		this.e = e;
		getAttributeMap().put(AttributeMap.SHAPE, new Rectangle());
		getAttributeMap().put(AttributeMap.BORDERWIDTH, 1);
		getAttributeMap().put(AttributeMap.DASHPATTERN, new float[] { 0f, 10f });

		if (e.getAttributeMap().get(AttributeMap.SHOWLABEL, false)) {
			getAttributeMap().put(AttributeMap.INSET, 0);
			getAttributeMap().put(AttributeMap.AUTOSIZE, true);
			getAttributeMap().put(AttributeMap.SHOWLABEL, true);

		} else {
			getAttributeMap().put(AttributeMap.SHOWLABEL, false);
			getAttributeMap().put(AttributeMap.SIZE, new Dimension(5, 5));
			getAttributeMap().put(AttributeMap.RESIZABLE, false);
		}
	}

	public int compareTo(DirectedGraphNode o) {
		throw new RuntimeException(""Not implemented!"");
	}

	public String getLabel() {
		return e.getLabel();
	}

	public DirectedGraph<?, ?> getGraph() {
		return e.getGraph();
	}

	public NodeID getId() {
		return id;
	}

	public int hashCode() {
		return e.hashCode();
	}

	public boolean equals(Object o) {
		return (o instanceof DirectedGraphNodeForMultiGraph && ((DirectedGraphNodeForMultiGraph) o).e.equals(e));
	}

	public DirectedGraphEdge<?, ?> getMultiEdge() {
		return e;
	}

}"
ProMGraphCell.java,widget,"package org.processmining.models.jgraph.elements;

import java.awt.Color;
import java.awt.geom.Dimension2D;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;

import javax.swing.SwingConstants;

import org.jgraph.graph.DefaultGraphCell;
import org.jgraph.graph.GraphConstants;
import org.processmining.framework.util.Cleanable;
import org.processmining.models.connections.GraphLayoutConnection;
import org.processmining.models.graphbased.AttributeMap;
import org.processmining.models.graphbased.Expandable;
import org.processmining.models.graphbased.directed.DirectedGraphNode;
import org.processmining.models.jgraph.ModelOwner;
import org.processmining.models.jgraph.ProMGraphModel;
import org.processmining.models.jgraph.views.JGraphShapeView;

public class ProMGraphCell extends DefaultGraphCell implements Cleanable, ModelOwner, ProMGraphElement {

	private static final long serialVersionUID = -5170284747077744754L;
	private DirectedGraphNode node;
	private ProMGraphModel model;
	private JGraphShapeView view;
	private GraphLayoutConnection layoutConnection;

	public ProMGraphCell(DirectedGraphNode node, ProMGraphModel model, GraphLayoutConnection layoutConnection) {
		super(node.getLabel());
		this.node = node;
		this.model = model;
		this.layoutConnection = layoutConnection;
		// update();
		GraphConstants.setConstrained(getAttributes(), node.getAttributeMap().get(AttributeMap.SQUAREBB, false));
		GraphConstants.setSizeable(getAttributes(), node.getAttributeMap().get(AttributeMap.RESIZABLE, true));
		GraphConstants.setResize(getAttributes(), node.getAttributeMap().get(AttributeMap.AUTOSIZE, false));
		GraphConstants.setHorizontalAlignment(getAttributes(), SwingConstants.CENTER);
		GraphConstants.setInset(getAttributes(), node.getAttributeMap().get(AttributeMap.INSET, 20));
		GraphConstants.setLineWidth(
				getAttributes(),
				new Float(node.getAttributeMap().get(AttributeMap.LINEWIDTH,
						GraphConstants.getLineWidth(getAttributes()))));
		GraphConstants.setForeground(getAttributes(), node.getAttributeMap().get(AttributeMap.LABELCOLOR, Color.black));
		GraphConstants.setOrientation(getAttributes(),
				node.getAttributeMap().get(AttributeMap.PREF_ORIENTATION, SwingConstants.NORTH));

		Dimension2D dim;
		Point2D pos;

		if (node instanceof Expandable) {
			dim = ((Expandable) node).getCollapsedSize();
			pos = layoutConnection.getPosition(node);
		} else {
			dim = layoutConnection.getSize(node);
			pos = layoutConnection.getPosition(node);
		}
		if (pos == null) {
			pos = new Point2D.Double(10, 10);
		}
		Rectangle2D rect = new Rectangle2D.Double(pos.getX(), pos.getY(), dim.getWidth(), dim.getHeight());
		GraphConstants.setBounds(getAttributes(), rect);

	}

	public void updateViewsFromMap() {
		assert (view != null);
		// Update the dimension / position
		Dimension2D dim = layoutConnection.getSize(node);
		Point2D pos = layoutConnection.getPosition(node);
		if (pos == null) {
			pos = new Point2D.Double(10, 10);
		}

		Rectangle2D rect = new Rectangle2D.Double(pos.getX(), pos.getY(), dim.getWidth(), dim.getHeight());
		Rectangle2D bounds = view.getBounds();//GraphConstants.getBounds(getAttributes());

		boolean boundsChanged = !rect.equals(bounds);
		if (boundsChanged) {
			//			GraphConstants.setBounds(getAttributes(), rect);
			view.setBounds(rect);
		}
	}

	public DirectedGraphNode getNode() {
		return node;
	}

	public String getUserObject() {
		return (String) super.getUserObject();
	}

	public void setView(JGraphShapeView view) {
		this.view = view;
	}

	public void cleanUp() {
		for (Object o : getChildren()) {
			if (o instanceof Cleanable) {
				Cleanable p = (Cleanable) o;
				p.cleanUp();
			}
		}
		removeAllChildren();
		if (view != null) {
			view.cleanUp();
		}
		view = null;
		model = null;
		node = null;
		layoutConnection = null;

	}

	// This method is called by all other addPort methods.
	@Override
	public ProMGraphPort addPort(Point2D offset, Object userObject) {
		ProMGraphPort port = new ProMGraphPort(userObject, model, layoutConnection);
		if (offset == null) {
			add(port);
		} else {
			GraphConstants.setOffset(port.getAttributes(), offset);
			add(port);
		}
		return port;
	}

	public String getLabel() {
		return node.getLabel();
	}

	public int hashCode() {
		return node.hashCode();
	}

	public ProMGraphModel getModel() {
		return model;
	}

	public JGraphShapeView getView() {
		return view;
	}

	/**
	 * This implementation of equals seems to be required by JGraph. Changing it
	 * to anything more meaningful will introduce very strange results.
	 */
	public boolean equals(Object o) {
		return o == this;
	}

}
"
ProMGraphEdge.java,widget,"package org.processmining.models.jgraph.elements;

import java.awt.Color;
import java.awt.geom.Point2D;
import java.util.ArrayList;
import java.util.List;

import org.jgraph.graph.DefaultEdge;
import org.jgraph.graph.GraphConstants;
import org.processmining.framework.util.Cleanable;
import org.processmining.models.connections.GraphLayoutConnection;
import org.processmining.models.graphbased.AttributeMap;
import org.processmining.models.graphbased.AttributeMap.ArrowType;
import org.processmining.models.graphbased.directed.DirectedGraphEdge;
import org.processmining.models.jgraph.ModelOwner;
import org.processmining.models.jgraph.ProMGraphModel;
import org.processmining.models.jgraph.ProMLoopRouting;
import org.processmining.models.jgraph.views.JGraphEdgeView;

public class ProMGraphEdge extends DefaultEdge implements Cleanable, ModelOwner, ProMGraphElement {

	public static final int ARROW_TECHNICAL_CIRCLE = 10;
	public static final int ARROW_CROSS = 11;

	public static final String LINEMIDDLE = ""lineMiddle"";
	public static final String MIDDLEFILL = ""middleFill"";
	public static final String NUMBERLINES = ""numberLines"";
	public static final String LINEWIDTH = ""lineWidth"";

	private static final long serialVersionUID = 663907031594522244L;

	private ProMGraphModel model;
	private JGraphEdgeView view;
	private final List<Point2D> internalPoints = new ArrayList<Point2D>(0);
	private DirectedGraphEdge<?, ?> edge;
	private final GraphLayoutConnection layoutConnection;

	public ProMGraphEdge(DirectedGraphEdge<?, ?> edge, ProMGraphModel model, GraphLayoutConnection layoutConnection) {
		super(edge.getLabel());
		this.layoutConnection = layoutConnection;

		GraphConstants.setRouting(getAttributes(), ProMLoopRouting.ROUTER);
		GraphConstants.setLabelPosition(getAttributes(), new Point2D.Double(GraphConstants.PERMILLE / 2, 0));
		GraphConstants.setLabelAlongEdge(getAttributes(), edge.getAttributeMap()
				.get(AttributeMap.LABELALONGEDGE, false));
		GraphConstants.setLineStyle(getAttributes(),
				edge.getAttributeMap().get(AttributeMap.STYLE, GraphConstants.STYLE_SPLINE));
		//GraphConstants.setLineStyle(getAttributes(), GraphConstants.STYLE_SPLINE);
		GraphConstants.setLineWidth(
				getAttributes(),
				new Float(edge.getAttributeMap().get(AttributeMap.LINEWIDTH,
						GraphConstants.getLineWidth(getAttributes()))));

		float[] pattern = edge.getAttributeMap().get(AttributeMap.DASHPATTERN, new float[0]);
		if (pattern.length > 0f) {

			GraphConstants.setDashPattern(getAttributes(), pattern);
			GraphConstants.setDashOffset(getAttributes(), edge.getAttributeMap().get(AttributeMap.DASHOFFSET, 0f));
		}

		GraphConstants.setForeground(getAttributes(), edge.getAttributeMap().get(AttributeMap.LABELCOLOR, Color.black));

		ArrowType type = edge.getAttributeMap().get(AttributeMap.EDGESTART, ArrowType.ARROWTYPE_NONE);
		int arrow = extractArrowType(type);
		GraphConstants.setLineBegin(getAttributes(), arrow);
		GraphConstants.setBeginFill(getAttributes(), edge.getAttributeMap().get(AttributeMap.EDGESTARTFILLED, true));

		type = edge.getAttributeMap().get(AttributeMap.EDGEEND, ArrowType.ARROWTYPE_NONE);
		arrow = extractArrowType(type);
		GraphConstants.setLineEnd(getAttributes(), arrow);
		GraphConstants.setEndFill(getAttributes(), edge.getAttributeMap().get(AttributeMap.EDGEENDFILLED, true));

		type = edge.getAttributeMap().get(AttributeMap.EDGEMIDDLE, ArrowType.ARROWTYPE_NONE);
		arrow = extractArrowType(type);
		getAttributes().put(LINEMIDDLE, arrow);
		getAttributes().put(MIDDLEFILL, edge.getAttributeMap().get(AttributeMap.EDGEMIDDLEFILLED, true));
		getAttributes().put(NUMBERLINES, edge.getAttributeMap().get(AttributeMap.NUMLINES, 1));
		getAttributes().put(LINEWIDTH, edge.getAttributeMap().get(AttributeMap.LINEWIDTH, 1.0f));

		if (edge.getAttributeMap().containsKey(AttributeMap.EXTRALABELPOSITIONS)) {
			assert ((Point2D[]) edge.getAttributeMap().get(AttributeMap.EXTRALABELPOSITIONS)).length == ((String[]) edge
					.getAttributeMap().get(AttributeMap.EXTRALABELS)).length;
			Point2D[] points = (Point2D[]) edge.getAttributeMap().get(AttributeMap.EXTRALABELPOSITIONS);
			String[] labels = (String[]) edge.getAttributeMap().get(AttributeMap.EXTRALABELS);
			GraphConstants.setExtraLabelPositions(getAttributes(), points);
			GraphConstants.setExtraLabels(getAttributes(), labels);

		}

		this.edge = edge;
		this.model = model;

		internalPoints.addAll(layoutConnection.getEdgePoints(edge));

	}

	protected int extractArrowType(ArrowType type) {
		int arrow = GraphConstants.ARROW_NONE;
		if (type == ArrowType.ARROWTYPE_CLASSIC) {
			arrow = GraphConstants.ARROW_CLASSIC;
		} else if (type == ArrowType.ARROWTYPE_CIRCLE) {
			arrow = GraphConstants.ARROW_CIRCLE;
		} else if (type == ArrowType.ARROWTYPE_DIAMOND) {
			arrow = GraphConstants.ARROW_DIAMOND;
		} else if (type == ArrowType.ARROWTYPE_DOUBLELINE) {
			arrow = GraphConstants.ARROW_DOUBLELINE;
		} else if (type == ArrowType.ARROWTYPE_LINE) {
			arrow = GraphConstants.ARROW_LINE;
		} else if (type == ArrowType.ARROWTYPE_SIMPLE) {
			arrow = GraphConstants.ARROW_SIMPLE;
		} else if (type == ArrowType.ARROWTYPE_TECHNICAL) {
			arrow = GraphConstants.ARROW_TECHNICAL;
		} else if (type == ArrowType.ARROW_CROSS) {
			arrow = ARROW_CROSS;
		} else if (type == ArrowType.ARROW_TECHNICAL_CIRCLE) {
			arrow = ARROW_TECHNICAL_CIRCLE;
		}
		return arrow;
	}

	@SuppressWarnings(""unchecked"")
	public void updateViewsFromMap() {
		assert (view != null);
		// Update should not be called before any view is created,

		// Note that List is of type List<Point2D>, until list.add is called
		// later
		List list = new ArrayList(layoutConnection.getEdgePoints(edge));
		boolean pointsChanged = !internalPoints.equals(list);
		if (pointsChanged) {
			internalPoints.clear();
			List points = view.getPoints();
			internalPoints.addAll(list);
			list.add(0, points.get(0));
			list.add(points.get(points.size() - 1));
			view.setPoints(list);
		}
	}

	public List<Point2D> getInternalPoints() {
		return internalPoints;
	}

	public String toString() {
		return edge.toString();
	}

	public DirectedGraphEdge<?, ?> getEdge() {
		return edge;
	}

	public String getUserObject() {
		return (String) super.getUserObject();
	}

	public ProMGraphPort getSource() {
		return (ProMGraphPort) super.getSource();
	}

	public ProMGraphPort getTarget() {
		return (ProMGraphPort) super.getTarget();
	}

	public void setView(JGraphEdgeView view) {
		this.view = view;
	}

	public JGraphEdgeView getView() {
		return view;
	}

	public void cleanUp() {
		if (view != null) {
			view.cleanUp();
		}
		internalPoints.clear();
		model = null;
		view = null;
		edge = null;
	}

	public String getLabel() {
		return edge.getLabel();
	}

	public int hashCode() {
		return edge.hashCode();
	}

	/**
	 * This implementation of equals seems to be required by JGraph. Changing it
	 * to anything more meaningful will introduce very strange results.
	 */
	public boolean equals(Object o) {
		return o == this;
	}

	public ProMGraphModel getModel() {
		return model;
	}

}
"
ProMGraphElement.java,widget,"package org.processmining.models.jgraph.elements;

import java.util.Map;

import org.jgraph.graph.CellView;

public interface ProMGraphElement {

	CellView getView();

	void updateViewsFromMap();

	Map getAttributes();
}
"
ProMGraphPort.java,widget,"package org.processmining.models.jgraph.elements;

import java.awt.Dimension;
import java.awt.geom.Point2D;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

import org.jgraph.graph.DefaultPort;
import org.jgraph.graph.GraphConstants;
import org.processmining.framework.util.Cleanable;
import org.processmining.models.connections.GraphLayoutConnection;
import org.processmining.models.graphbased.directed.BoundaryDirectedGraphNode;
import org.processmining.models.jgraph.ModelOwner;
import org.processmining.models.jgraph.ProMGraphModel;
import org.processmining.models.jgraph.views.JGraphPortView;

public class ProMGraphPort extends DefaultPort implements Cleanable, ModelOwner, ProMGraphElement {

	private static final long serialVersionUID = 34423826783834456L;
	private JGraphPortView view;
	private ProMGraphModel model;
	private boolean isBoundaryNode = false;
	private BoundaryDirectedGraphNode node;
	private final GraphLayoutConnection layoutConnection;

	public ProMGraphPort(Object userObject, ProMGraphModel model, GraphLayoutConnection layoutConnection) {
		super(userObject);
		this.model = model;
		this.layoutConnection = layoutConnection;
		if (userObject != null && userObject instanceof BoundaryDirectedGraphNode) {
			node = (BoundaryDirectedGraphNode) userObject;
			layoutConnection.getPortOffset(node);
			Dimension size = layoutConnection.getSize(node);
			Point2D offset = layoutConnection.getPortOffset(node);

			GraphConstants.setSize(getAttributes(), size);
			GraphConstants.setOffset(getAttributes(), offset);
			isBoundaryNode = true;
		}
	}

	@SuppressWarnings(""unchecked"")
	public void cleanUp() {
		view = null;
		setUserObject(null);
		Iterator<Object> edge = edges();
		List<Object> edges = new ArrayList<Object>();
		while (edge.hasNext()) {
			edges.add(edge.next());
		}
		for (Object e : edges) {
			removeEdge(e);
		}
		model = null;
	}

	public void setView(JGraphPortView view) {
		this.view = view;
	}

	public JGraphPortView getView() {
		return view;
	}

	public ProMGraphModel getModel() {
		return model;
	}

	public void updateViewsFromMap() {
		assert (view != null);

		if ((getUserObject() instanceof BoundaryDirectedGraphNode) ? ((BoundaryDirectedGraphNode) getUserObject())
				.getBoundingNode() != null : false) {

			// Update the port size
			// Note: the width and the height of a port should always be equal 			
			Dimension size = layoutConnection.getSize(node);
			Dimension currSize = new Dimension((int) view.getBounds().getWidth(), (int) view.getBounds().getHeight());// GraphConstants.getSize(getAttributes());
			if (!size.equals(currSize)) {
				//				GraphConstants.setSize(getAttributes(), size);
				view.setPortSize((int) size.getWidth());
			}

			Point2D offset = layoutConnection.getPortOffset(node);
			//			Point2D currOffset = new Point2D.Double(view.getBounds().getX(), view.getBounds().getY()); // GraphConstants.getOffset(getAttributes());
			Point2D currOffset = GraphConstants.getOffset(view.getAttributes());
			if (!offset.equals(currOffset)) {
				//				GraphConstants.setOffset(getAttributes(), offset);
				GraphConstants.setOffset(view.getAttributes(), offset);
			}
		}
	}

	/**
	 * This implementation of equals seems to be required by JGraph. Changing it
	 * to anything more meaningful will introduce very strange results.
	 */
	public boolean equals(Object o) {
		return o == this;
	}

	public boolean isBoundaryNode() {
		return isBoundaryNode;
	}

	public BoundaryDirectedGraphNode getBoundingNode() {
		return node;
	}

}
"
ProMCellViewFactory.java,widget,"package org.processmining.models.jgraph.factory;

import java.util.ArrayList;
import java.util.List;

import org.jgraph.graph.DefaultCellViewFactory;
import org.jgraph.graph.Edge;
import org.jgraph.graph.EdgeView;
import org.jgraph.graph.GraphConstants;
import org.jgraph.graph.Port;
import org.jgraph.graph.PortView;
import org.jgraph.graph.VertexView;
import org.processmining.framework.util.Cast;
import org.processmining.models.graphbased.ViewSpecificAttributeMap;
import org.processmining.models.jgraph.elements.ProMGraphCell;
import org.processmining.models.jgraph.elements.ProMGraphEdge;
import org.processmining.models.jgraph.elements.ProMGraphPort;
import org.processmining.models.jgraph.views.JGraphEdgeView;
import org.processmining.models.jgraph.views.JGraphPortView;
import org.processmining.models.jgraph.views.JGraphShapeView;

public class ProMCellViewFactory extends DefaultCellViewFactory {

	private static final long serialVersionUID = -2424217390990685801L;
	private final boolean isPIP;
	private final ViewSpecificAttributeMap viewSpecificAttributes;

	public ProMCellViewFactory(boolean isPIP, ViewSpecificAttributeMap viewSpecificAttributes) {
		this.isPIP = isPIP;
		this.viewSpecificAttributes = viewSpecificAttributes;
	}

	@Override
	protected VertexView createVertexView(Object v) {
		ProMGraphCell cell = (ProMGraphCell) v;
		JGraphShapeView view = new JGraphShapeView(cell, isPIP, viewSpecificAttributes);
		cell.setView(view);
		return view;
	}

	@Override
	@Deprecated
	protected EdgeView createEdgeView(Edge e) {
		return createEdgeView((Object) e);
	}

	@SuppressWarnings({ ""rawtypes"", ""unchecked"" })
	@Override
	protected EdgeView createEdgeView(Object e) {
		ProMGraphEdge cell = Cast.<ProMGraphEdge>cast(e);

		List list = new ArrayList(cell.getInternalPoints());
		list.add(0, cell.getSource().getView());
		list.add(cell.getTarget().getView());
		GraphConstants.setPoints(cell.getAttributes(), list);

		JGraphEdgeView view = new JGraphEdgeView(cell, isPIP, viewSpecificAttributes);
		cell.setView(view);
		return view;
	}

	@Override
	@Deprecated
	protected PortView createPortView(Port e) {
		return createPortView((Object) e);
	}

	@Override
	protected PortView createPortView(Object e) {
		ProMGraphPort cell = Cast.<ProMGraphPort>cast(e);
		JGraphPortView view = new JGraphPortView(cell, isPIP, viewSpecificAttributes);
		cell.setView(view);
		cell.updateViewsFromMap();
		return view;
	}

}
"
JGraphFoldingManager.java,widget,"package org.processmining.models.jgraph;

import java.awt.Component;
import java.awt.event.MouseEvent;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;

import javax.swing.event.MouseInputAdapter;

import org.jgraph.JGraph;
import org.jgraph.graph.CellView;
import org.processmining.framework.util.Pair;
import org.processmining.models.connections.GraphLayoutConnection;
import org.processmining.models.graphbased.Expandable;
import org.processmining.models.graphbased.directed.DirectedGraphNode;
import org.processmining.models.jgraph.renderers.ProMGroupShapeRenderer;
import org.processmining.models.jgraph.views.JGraphShapeView;

/**
 * Mananges the folding and unfolding of groups
 */
public class JGraphFoldingManager extends MouseInputAdapter {

	private final GraphLayoutConnection layoutConnection;

	public JGraphFoldingManager(GraphLayoutConnection layoutConnection) {
		super();
		this.layoutConnection = layoutConnection;

	}

	/**
	 * Called when the mouse button is released to see if a collapse or expand
	 * request has been made
	 */
	public void mouseReleased(MouseEvent e) {
		if (e.getSource() instanceof JGraph) {
			final JGraph graph = (JGraph) e.getSource();
			Pair<Expandable, CellView> pair = getGroupByFoldingHandle(graph, e.getPoint());
			if (pair != null) {
				if (pair.getSecond().isLeaf()) {
					layoutConnection.expand(pair.getFirst());
					layoutConnection.updated();
				} else {
					layoutConnection.collapse(pair.getFirst());
					layoutConnection.updated();
				}
			}
			e.consume();
		}
	}

	/**
	 * Called when the mouse button is released to see if a collapse or expand
	 * request has been made
	 */
	public static Pair<Expandable, CellView> getGroupByFoldingHandle(JGraph graph, Point2D pt) {
		CellView[] views = graph.getGraphLayoutCache().getCellViews();
		for (int i = 0; i < views.length; i++) {
			Point2D containerPoint = graph.fromScreen((Point2D) pt.clone());
			if (views[i].getBounds().contains(containerPoint.getX(), containerPoint.getY())) {
				Rectangle2D rectBounds = views[i].getBounds();
				containerPoint.setLocation(containerPoint.getX() - rectBounds.getX(), containerPoint.getY()
						- rectBounds.getY());
				Component renderer = views[i].getRendererComponent(graph, false, false, false);
				if (renderer instanceof ProMGroupShapeRenderer) {
					DirectedGraphNode node = ((JGraphShapeView) views[i]).getNode();
					boolean isGroup = (node instanceof Expandable);
					if (isGroup) {
						ProMGroupShapeRenderer group = (ProMGroupShapeRenderer) renderer;
						if (group.inHitRegion(containerPoint)) {
							return new Pair<Expandable, CellView>((Expandable) node, views[i]);
						}
					}
				}
			}
		}
		return null;
	}

}
"
SelectionListener.java,widget,"package org.processmining.models.jgraph.listeners;

import java.util.Collection;

public interface SelectionListener<N, E> {

	void SelectionChanged(SelectionChangeEvent<N, E> event);

	public static class SelectionChangeEvent<N, E> {
		private final Collection<N> addedNodes;
		private final Collection<E> addedEdges;
		private final Collection<N> removedNodes;
		private final Collection<E> removedEdges;

		public SelectionChangeEvent(Collection<N> addedNodes, Collection<E> addedEdges, Collection<N> removedNodes,
				Collection<E> removedEdges) {
			this.addedNodes = addedNodes;
			this.addedEdges = addedEdges;
			this.removedNodes = removedNodes;
			this.removedEdges = removedEdges;
		}

		public Collection<N> getAddedNodes() {
			return addedNodes;
		}

		public Collection<E> getAddedEdges() {
			return addedEdges;
		}

		public Collection<N> getRemovedNodes() {
			return removedNodes;
		}

		public Collection<E> getRemovedEdges() {
			return removedEdges;
		}

		public String toString() {
			return ""N:+"" + addedNodes + "" -"" + removedNodes + ""  E:+"" + addedEdges + "" -"" + removedEdges;
		}

	}
}
"
ModelOwner.java,widget,"package org.processmining.models.jgraph;

public interface ModelOwner {

	public ProMGraphModel getModel();

}
"
ProMGraphModel.java,widget,"package org.processmining.models.jgraph;

import java.awt.geom.Rectangle2D;
import java.util.Map;

import org.jgraph.event.GraphModelEvent;
import org.jgraph.graph.CellView;
import org.jgraph.graph.ConnectionSet;
import org.jgraph.graph.DefaultGraphModel;
import org.jgraph.graph.GraphLayoutCache;
import org.jgraph.graph.ParentMap;
import org.processmining.models.graphbased.directed.DirectedGraph;
import org.processmining.models.graphbased.directed.DirectedGraphEdge;
import org.processmining.models.graphbased.directed.DirectedGraphNode;

public class ProMGraphModel extends DefaultGraphModel implements ModelOwner {

	private static final long serialVersionUID = 9097862538097193482L;
	private final DirectedGraph<? extends DirectedGraphNode, ? extends DirectedGraphEdge<? extends DirectedGraphNode, ? extends DirectedGraphNode>> graph;

	public ProMGraphModel(
			DirectedGraph<? extends DirectedGraphNode, ? extends DirectedGraphEdge<? extends DirectedGraphNode, ? extends DirectedGraphNode>> graph) {
		this.graph = graph;
	}

	public DirectedGraph<? extends DirectedGraphNode, ? extends DirectedGraphEdge<? extends DirectedGraphNode, ? extends DirectedGraphNode>> getGraph() {
		return graph;
	}

	public String toString() {
		return graph.toString();
	}

	public ProMGraphModel getModel() {
		return this;
	}

	/**
	 * Invoke this method after you've changed how the cells are to be
	 * represented in the graph.
	 */
	public void cellsChanged(final Object[] cells, final Rectangle2D dirtyRegion) {
		if (cells != null) {
			fireGraphChanged(this, new GraphModelEvent.GraphModelChange() {

				public Object[] getInserted() {
					return null;
				}

				public Object[] getRemoved() {
					return null;
				}

				public Map<?, ?> getPreviousAttributes() {
					return null;
				}

				public ConnectionSet getConnectionSet() {
					return null;
				}

				public ConnectionSet getPreviousConnectionSet() {
					return null;
				}

				public ParentMap getParentMap() {
					return null;
				}

				public ParentMap getPreviousParentMap() {
					return null;
				}

				public void putViews(GraphLayoutCache view, CellView[] cellViews) {
				}

				public CellView[] getViews(GraphLayoutCache view) {
					return null;
				}

				public Object getSource() {
					return this;
				}

				public Object[] getChanged() {
					return cells;
				}

				public Map<?, ?> getAttributes() {
					return null;
				}

				public Object[] getContext() {
					return null;
				}

				public Rectangle2D getDirtyRegion() {
					return dirtyRegion;
				}

				public void setDirtyRegion(Rectangle2D dirty) {
				}

			});
		}
	}

}
"
ProMJGraph.java,widget,"package org.processmining.models.jgraph;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.event.MouseEvent;
import java.awt.geom.Dimension2D;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Vector;

import javax.swing.JComponent;
import javax.swing.ToolTipManager;

import org.jgraph.JGraph;
import org.jgraph.event.GraphLayoutCacheEvent;
import org.jgraph.event.GraphLayoutCacheListener;
import org.jgraph.event.GraphModelEvent;
import org.jgraph.event.GraphModelListener;
import org.jgraph.event.GraphSelectionEvent;
import org.jgraph.event.GraphSelectionListener;
import org.jgraph.graph.CellView;
import org.jgraph.graph.ConnectionSet;
import org.jgraph.graph.DefaultGraphModel;
import org.jgraph.graph.DefaultPort;
import org.jgraph.graph.GraphConstants;
import org.jgraph.graph.GraphLayoutCache;
import org.jgraph.graph.ParentMap;
import org.processmining.framework.util.Cast;
import org.processmining.framework.util.Cleanable;
import org.processmining.framework.util.ui.scalableview.ScalableComponent;
import org.processmining.models.connections.GraphLayoutConnection;
import org.processmining.models.connections.GraphLayoutConnection.Listener;
import org.processmining.models.graphbased.AttributeMap;
import org.processmining.models.graphbased.AttributeMapOwner;
import org.processmining.models.graphbased.Expandable;
import org.processmining.models.graphbased.ExpansionListener;
import org.processmining.models.graphbased.ViewSpecificAttributeMap;
import org.processmining.models.graphbased.directed.BoundaryDirectedGraphNode;
import org.processmining.models.graphbased.directed.ContainableDirectedGraphElement;
import org.processmining.models.graphbased.directed.ContainingDirectedGraphNode;
import org.processmining.models.graphbased.directed.DirectedGraph;
import org.processmining.models.graphbased.directed.DirectedGraphEdge;
import org.processmining.models.graphbased.directed.DirectedGraphEdge.MultipleSources;
import org.processmining.models.graphbased.directed.DirectedGraphEdge.MultipleTargets;
import org.processmining.models.graphbased.directed.DirectedGraphElement;
import org.processmining.models.graphbased.directed.DirectedGraphNode;
import org.processmining.models.jgraph.elements.ProMGraphCell;
import org.processmining.models.jgraph.elements.ProMGraphEdge;
import org.processmining.models.jgraph.elements.ProMGraphElement;
import org.processmining.models.jgraph.elements.ProMGraphPort;
import org.processmining.models.jgraph.factory.ProMCellViewFactory;

import com.jgraph.layout.JGraphFacade;
import com.jgraph.layout.JGraphLayout;

public class ProMJGraph extends JGraph implements GraphModelListener, GraphLayoutCacheListener, GraphSelectionListener,
		Cleanable, ExpansionListener, ScalableComponent, Listener {

	private static final long serialVersionUID = -8477633603192312230L;

	public static final String PIPVIEWATTRIBUTE = ""signalPIPView"";

	private final ProMGraphModel model;
	private final Map<DirectedGraphNode, ProMGraphCell> nodeMap = new HashMap<>();
	private final Map<BoundaryDirectedGraphNode, ProMGraphPort> boundaryNodeMap = new HashMap<>();
	private final Map<DirectedGraphEdge<?, ?>, ProMGraphEdge> edgeMap = new HashMap<>();
	private final Map<DirectedGraphEdge<?, ?>, Collection<ProMGraphElement>> multiEdgeMap = new HashMap<>();

	private JGraphLayout layout;

	private final ViewSpecificAttributeMap viewSpecificAttributes;

	private final boolean isPIP;

	private final GraphLayoutConnection layoutConnection;

	public ProMJGraph(ProMGraphModel model, ViewSpecificAttributeMap viewSpecificAttributes,
			GraphLayoutConnection layoutConnection) {
		this(model, false, viewSpecificAttributes, layoutConnection);
	}

	public ProMJGraph(ProMGraphModel model, boolean isPIP, ViewSpecificAttributeMap viewSpecificAttributes,
			GraphLayoutConnection layoutConnection) {
		super(model, new GraphLayoutCache(model, new ProMCellViewFactory(isPIP, viewSpecificAttributes), true));
		this.layoutConnection = layoutConnection;
		layoutConnection.addListener(this);
		getGraphLayoutCache().setShowsInvisibleEditedCells(false);
		this.isPIP = isPIP;
		this.viewSpecificAttributes = viewSpecificAttributes;

		getGraphLayoutCache().setMovesChildrenOnExpand(true);
		// Strange: setResizesParentsOnCollapse has to be set to FALSE!
		getGraphLayoutCache().setResizesParentsOnCollapse(false);
		getGraphLayoutCache().setMovesParentsOnCollapse(true);

		this.model = model;

		setHighlightColor(Color.ORANGE);
		setLockedHandleColor(Color.RED);

		setAntiAliased(true);
		setDisconnectable(false);
		setConnectable(false);
		setGridEnabled(false);
		setDoubleBuffered(true);
		setSelectionEnabled(!isPIP);
		setMoveBelowZero(false);
		setPortsVisible(true);
		setPortsScaled(true);

		DirectedGraph<?, ?> net = model.getGraph();

		List<DirectedGraphNode> todo = new ArrayList<DirectedGraphNode>(net.getNodes());
		List<Object> toInsert = new ArrayList<Object>();
		while (!todo.isEmpty()) {
			Iterator<DirectedGraphNode> it = todo.iterator();
			while (it.hasNext()) {
				DirectedGraphNode n = it.next();
				if (n instanceof BoundaryDirectedGraphNode) {
					DirectedGraphNode m = ((BoundaryDirectedGraphNode) n).getBoundingNode();
					if ((m != null) && !nodeMap.containsKey(m)) {
						// first make sure the bounding node is added
						continue;
					} else if (m != null) {
						// add as port
						addPort((BoundaryDirectedGraphNode) n, m);
						it.remove();
						continue;
					}
				}
				if (n instanceof ContainableDirectedGraphElement) {
					ContainingDirectedGraphNode c = Cast.<ContainableDirectedGraphElement>cast(n).getParent();
					if ((c != null) && !nodeMap.containsKey(c)) {
						// if parent is not added yet, then continue
						continue;
					} else if (c == null) {
						toInsert.add(addCell(n));
					} else {
						addCell(n);
					}
				} else {
					toInsert.add(addCell(n));
				}

				it.remove();
			}
		}

		//		getGraphLayoutCache().insert(toInsert.toArray());

		//		getGraphLayoutCache().insert(boundaryNodeMap.values().toArray());
		for (DirectedGraphEdge<?, ?> e : net.getEdges()) {
			if (e instanceof ContainableDirectedGraphElement) {
				ContainingDirectedGraphNode m = Cast.<ContainableDirectedGraphElement>cast(e).getParent();
				if (m == null) {
					if (e instanceof MultipleSources<?> || e instanceof MultipleTargets<?>) {
						toInsert.addAll(addMultiEdge(e));
					} else {
						toInsert.add(addEdge(e));
					}
				} else {
					if (e instanceof MultipleSources<?> || e instanceof MultipleTargets<?>) {
						addMultiEdge(e);
					} else {
						addEdge(e);

					}
				}
			} else {
				if (e instanceof MultipleSources<?> || e instanceof MultipleTargets<?>) {

					toInsert.addAll(addMultiEdge(e));
				} else {
					toInsert.add(addEdge(e));
				}
			}
		}
		getGraphLayoutCache().insert(toInsert.toArray());
		// Add the listeners, only AFTER copying the graph.

		registerAsListener();
		layoutConnection.getExpansionListeners().add(this);

		if (!isPIP) {
			addMouseListener(new JGraphFoldingManager(layoutConnection));
		}

		ToolTipManager.sharedInstance().registerComponent(this);
	}

	/**
	 * Returns the <code>GraphModel</code> that is providing the data.
	 * 
	 * @return the model that is providing the data
	 */
	public ProMGraphModel getModel() {
		return (ProMGraphModel) graphModel;
	}

	public void cleanUp() {

		List<Cleanable> cells = new ArrayList<Cleanable>(nodeMap.values());
		cells.addAll(boundaryNodeMap.values());
		cells.addAll(edgeMap.values());
		// multiEdgeMap elements are contained in other maps as well.

		getGraphLayoutCache().removeCells(cells.toArray());

		for (Cleanable cell : cells) {
			cell.cleanUp();
		}

		model.removeGraphModelListener(this);
		removeGraphSelectionListener(this);
		getGraphLayoutCache().removeGraphLayoutCacheListener(this);
		ToolTipManager.sharedInstance().unregisterComponent(this);

		removeAll();
		setVisible(false);
		setEnabled(false);
		setLayout(null);
		setGraphLayoutCache(null);

	}

	private ProMGraphCell addCell(DirectedGraphNode node) {
		ProMGraphCell cell = new ProMGraphCell(node, model, layoutConnection);

		cell.addPort();
		((DefaultPort) cell.getChildAt(0)).setUserObject(""default port"");

		// getting the size
		nodeMap.put(node, cell);

		// if the node is contained in another node, its cell must be contained in the cell of that node
		if (node instanceof ContainableDirectedGraphElement) {
			ContainingDirectedGraphNode parent = Cast.<ContainableDirectedGraphElement>cast(node).getParent();
			if (parent != null) {
				ProMGraphCell parentNode = nodeMap.get(parent);
				parentNode.add(cell);
				cell.setParent(parentNode);
			}
		}

		return cell;
	}

	private ProMGraphPort addPort(BoundaryDirectedGraphNode node, DirectedGraphNode boundingNode) {
		ProMGraphCell cell = nodeMap.get(boundingNode);
		ProMGraphPort port = cell.addPort(new Point2D.Float(10, 10), node);
		assert (port.getParent() == cell);

		boundaryNodeMap.put(node, port);

		return port;
	}

	private ProMGraphEdge addEdge(DirectedGraphEdge<?, ?> e) {
		ProMGraphEdge edge = new ProMGraphEdge(e, model, layoutConnection);
		// For now, assume a single port.
		ProMGraphPort srcPort;
		if ((e.getSource() instanceof BoundaryDirectedGraphNode)
				&& ((BoundaryDirectedGraphNode) e.getSource()).getBoundingNode() != null) {
			srcPort = boundaryNodeMap.get(e.getSource());
		} else {
			srcPort = (ProMGraphPort) nodeMap.get(e.getSource()).getChildAt(0);
		}
		ProMGraphPort tgtPort;
		if ((e.getTarget() instanceof BoundaryDirectedGraphNode)
				&& ((BoundaryDirectedGraphNode) e.getTarget()).getBoundingNode() != null) {
			tgtPort = boundaryNodeMap.get(e.getTarget());
		} else {
			tgtPort = (ProMGraphPort) nodeMap.get(e.getTarget()).getChildAt(0);
		}

		edge.setSource(srcPort);
		edge.setTarget(tgtPort);

		srcPort.addEdge(edge);
		tgtPort.addEdge(edge);

		edgeMap.put(e, edge);

		// if the edge is contained in a node, its cell must be contained in the cell of that node
		if (e instanceof ContainableDirectedGraphElement) {
			ContainingDirectedGraphNode parent = Cast.<ContainableDirectedGraphElement>cast(e).getParent();
			if (parent != null) {
				nodeMap.get(parent).add(edge);
				assert (edge.getParent() == nodeMap.get(parent));
			}
		}

		return edge;
	}

	private Collection<ProMGraphElement> addMultiEdge(final DirectedGraphEdge<?, ?> e) {
		assert e instanceof MultipleSources || e instanceof MultipleTargets;

		Collection<ProMGraphElement> elements = new ArrayList<>();

		Collection<DirectedGraphNode> sources;
		if (e instanceof MultipleSources<?>) {
			sources = new ArrayList<>(((MultipleSources<?>) e).getSources().size());
			sources.addAll(((MultipleSources<?>) e).getSources());
		} else {
			sources = new ArrayList<>(1);
			sources.add(e.getSource());
		}

		Collection<DirectedGraphNode> targets;
		if (e instanceof MultipleTargets<?>) {
			targets = new ArrayList<>(((MultipleTargets<?>) e).getTargets().size());
			targets.addAll(((MultipleTargets<?>) e).getTargets());
		} else {
			targets = new ArrayList<>(1);
			targets.add(e.getTarget());
		}
		List<DirectedGraphElement> tempGraphElements = new ArrayList<DirectedGraphElement>(1 + targets.size()
				+ sources.size());
		layoutConnection.setMultiGraphElements(e, tempGraphElements);
		multiEdgeMap.put(e, elements);

		if (targets.size() == 1 && sources.size() == 1) {
			elements.add(addEdge(e));
			return elements;
		}

		final DirectedGraphNodeForMultiGraph intermediate = new DirectedGraphNodeForMultiGraph(e);

		layoutConnection.setSize(intermediate,
				intermediate.getAttributeMap().get(AttributeMap.SIZE, new Dimension(50, 50)));
		layoutConnection.setPortOffset(
				intermediate,
				intermediate.getAttributeMap().get(AttributeMap.PORTOFFSET,
						new Point2D.Double(GraphConstants.PERMILLE / 2, GraphConstants.PERMILLE / 2)));

		tempGraphElements.add(intermediate);
		elements.add(addCell(intermediate));

		for (final DirectedGraphNode source : sources) {
			DirectedGraphEdge<?, ?> tmpEdge = new DirectedGraphEdgeForMultiGraph(source, intermediate, e);
			tempGraphElements.add(tmpEdge);
			ProMGraphEdge edge = addEdge(tmpEdge);// new ProMGraphEdge(tmpEdge, model, layoutConnection);
			elements.add(edge);

			ProMGraphPort srcPort;
			if ((tmpEdge.getSource() instanceof BoundaryDirectedGraphNode)
					&& ((BoundaryDirectedGraphNode) tmpEdge.getSource()).getBoundingNode() != null) {
				srcPort = boundaryNodeMap.get(tmpEdge.getSource());
			} else {
				srcPort = (ProMGraphPort) nodeMap.get(tmpEdge.getSource()).getChildAt(0);
			}
			ProMGraphPort tgtPort = (ProMGraphPort) nodeMap.get(tmpEdge.getTarget()).getChildAt(0);

			edge.setSource(srcPort);
			edge.setTarget(tgtPort);

			srcPort.addEdge(edge);
			tgtPort.addEdge(edge);

			// if the edge is contained in a node, its cell must be contained in the cell of that node
			if (e instanceof ContainableDirectedGraphElement) {
				ContainingDirectedGraphNode parent = Cast.<ContainableDirectedGraphElement>cast(e).getParent();
				if (parent != null) {
					nodeMap.get(parent).add(edge);
					assert (edge.getParent() == nodeMap.get(parent));
				}
			}

		}

		for (final DirectedGraphNode target : targets) {
			DirectedGraphEdge<?, ?> tmpEdge = new DirectedGraphEdgeForMultiGraph(intermediate, target, e);
			tempGraphElements.add(tmpEdge);

			ProMGraphEdge edge = addEdge(tmpEdge);//ProMGraphEdge edge = new ProMGraphEdge(tmpEdge, model, layoutConnection);
			elements.add(edge);

			ProMGraphPort srcPort = (ProMGraphPort) nodeMap.get(tmpEdge.getSource()).getChildAt(0);

			ProMGraphPort tgtPort;
			if ((tmpEdge.getTarget() instanceof BoundaryDirectedGraphNode)
					&& ((BoundaryDirectedGraphNode) tmpEdge.getTarget()).getBoundingNode() != null) {
				tgtPort = boundaryNodeMap.get(tmpEdge.getTarget());
			} else {
				tgtPort = (ProMGraphPort) nodeMap.get(tmpEdge.getTarget()).getChildAt(0);
			}
			edge.setSource(srcPort);
			edge.setTarget(tgtPort);

			srcPort.addEdge(edge);
			tgtPort.addEdge(edge);

			// if the edge is contained in a node, its cell must be contained in the cell of that node
			if (e instanceof ContainableDirectedGraphElement) {
				ContainingDirectedGraphNode parent = Cast.<ContainableDirectedGraphElement>cast(e).getParent();
				if (parent != null) {
					nodeMap.get(parent).add(edge);
					assert (edge.getParent() == nodeMap.get(parent));
				}
			}
		}

		return elements;
	}

	public void update(Object... elements) {
		updateElements(Arrays.asList(elements));
	}

	public void update(Set<?> elements) {
		updateElements(elements);
	}

	private void updateElements(Collection<?> elements) {

		// For each updated element, find the corresponding view of the corresponding cell and copy the
		// attributes that matter, i.e. size/position/points.

		//The order in which cells, ports and edges are added matters:
		//Cells first, ports second and edges third (because ports are attached to cells and edges to ports.)
		Vector<ProMGraphElement> cellsToAdd = new Vector<ProMGraphElement>();
		Vector<ProMGraphElement> portsToAdd = new Vector<ProMGraphElement>();
		Vector<ProMGraphElement> edgesToAdd = new Vector<ProMGraphElement>();
		Vector<CellView> cellViewsToAdd = new Vector<CellView>();
		Vector<CellView> portViewsToAdd = new Vector<CellView>();
		Vector<CellView> edgeViewsToAdd = new Vector<CellView>();

		for (Object element : elements) {
			if ((element instanceof BoundaryDirectedGraphNode) ? ((BoundaryDirectedGraphNode) element)
					.getBoundingNode() != null : false) {
				ProMGraphPort cell = boundaryNodeMap.get(element);
				if (cell != null) {
					// An update on a cell that does not exist in the view should not be done.
					portsToAdd.add(cell);
					portViewsToAdd.add(cell.getView());
				}
			} else if (element instanceof DirectedGraphNode) {
				ProMGraphCell cell = nodeMap.get(element);
				if (cell != null) {
					// An update on a cell that does not exist in the view should not be done.
					cellsToAdd.add(cell);
					cellViewsToAdd.add(cell.getView());
				}
			} else if (element instanceof MultipleSources || element instanceof MultipleTargets) {
				Collection<ProMGraphElement> cells = multiEdgeMap.get(element);
				if (cells != null) {
					// An update on a cell that does not exist in the view should not be done.
					for (ProMGraphElement cell : cells) {
						if (cell instanceof ProMGraphCell) {
							// An update on a cell that does not exist in the view should not be done.
							cellsToAdd.add(cell);
							cellViewsToAdd.add(cell.getView());
						} else {
							edgesToAdd.add(cell);
							edgeViewsToAdd.add(cell.getView());
						}
					}
				}
			} else if (element instanceof DirectedGraphEdge<?, ?>) {
				ProMGraphEdge cell = edgeMap.get(element);
				if (cell != null) {
					// An update on a cell that does not exist in the view should not be done.
					edgesToAdd.add(cell);
					edgeViewsToAdd.add(cell.getView());
				}
			} else if (element instanceof DirectedGraph<?, ?>) {
				// graph has changed
			} else {
				assert (false);
			}
		}

		Vector<CellView> views = cellViewsToAdd;
		views.addAll(portViewsToAdd);
		views.addAll(edgeViewsToAdd);
		Vector<ProMGraphElement> cells = cellsToAdd;
		cells.addAll(portsToAdd);
		cells.addAll(edgesToAdd);
		Rectangle2D oldBound = GraphLayoutCache.getBounds(views.toArray(new CellView[0]));
		for (ProMGraphElement cell : cells) {
			cell.updateViewsFromMap();
		}
		if (oldBound != null) {
			Rectangle2D.union(oldBound, GraphLayoutCache.getBounds(views.toArray(new CellView[0])), oldBound);
		}
		//		repaint(oldBound.getBounds());
		getGraphLayoutCache().cellViewsChanged(views.toArray(new CellView[0]));
		// HV: Refresh the graph to show the changes.
		this.refresh();
	}

	public String toString() {
		return model.toString();
	}

	public void graphChanged(GraphModelEvent e) {
		handleChange(e.getChange());
		changeHandled();
		for (UpdateListener l : updateListeners) {
			l.updated();
		}
	}

	/**
	 * Might be overridden to signal that a change was handled
	 */
	protected void changeHandled() {
		layoutConnection.updated();
	}

	private void handleChange(GraphLayoutCacheEvent.GraphLayoutCacheChange change) {
		// A change originated in from the graph. This needs to be reflected in
		// the layoutConnection (if applicable)
		synchronized (model) {
			boolean signalChange = false;
			Object[] changed = change.getChanged();

			Set<AttributeMapOwner> changedOwners = new HashSet<AttributeMapOwner>();
			Set<ProMGraphEdge> edges = new HashSet<ProMGraphEdge>();
			for (Object o : changed) {
				if (o instanceof ProMGraphCell) {
					// handle a change for a cell
					ProMGraphCell cell = (ProMGraphCell) o;

					DirectedGraphNode node = cell.getNode();

					Rectangle2D rect;
					if (change.getSource() instanceof ProMGraphModel) {
						rect = GraphConstants.getBounds(cell.getAttributes());
					} else {
						rect = cell.getView().getBounds();
					}

					if (handleNodeChange(cell, node, rect)) {
						changedOwners.add(node);
						signalChange = true;
					}
				}
				if (o instanceof ProMGraphEdge) {
					edges.add((ProMGraphEdge) o);
				}
			}
			for (ProMGraphEdge cell : edges) {
				// handle a change for a cell
				DirectedGraphEdge<?, ?> edge = cell.getEdge();

				List<?> points;
				if (change.getSource() instanceof ProMGraphModel) {
					points = GraphConstants.getPoints(cell.getAttributes());
				} else {
					points = cell.getView().getPoints();
				}

				if (handleEdgeChange(cell, edge, points)) {
					changedOwners.add(edge);
					signalChange = true;
				}
			}
			if (signalChange && !isPIP) {
				layoutConnection.updatedAttributes(changedOwners.toArray(new AttributeMapOwner[0]));
			}
		}
	}

	private boolean handleNodeChange(ProMGraphCell cell, DirectedGraphNode node, Rectangle2D rect) {
		boolean changed = false;

		//		// get the view's bounds and put them in the attributemap
		//		Rectangle2D rect = cell.getView().getBounds();
		//		rect = GraphConstants.getBounds(cell.getAttributes());

		if (rect != null) {
			// SIZE
			Dimension2D size = new Dimension((int) rect.getWidth(), (int) rect.getHeight());
			changed |= layoutConnection.setSize(node, size);

			// POSITION
			Point2D pos = new Point2D.Double(rect.getX(), rect.getY());
			changed |= layoutConnection.setPosition(node, pos);

		}

		return changed;
	}

	private boolean handleEdgeChange(ProMGraphEdge cell, DirectedGraphEdge<?, ?> edge, List<?> points) {
		boolean changed = false;

		List<Point2D> list = new ArrayList<Point2D>(3);
		if (points != null) {
			for (int i = 1; i < points.size() - 1; i++) {
				Point2D point = (Point2D) points.get(i);
				list.add(new Point2D.Double(point.getX(), point.getY()));
			}
		}
		changed |= layoutConnection.setEdgePoints(edge, list);

		return changed;
	}

	public void graphLayoutCacheChanged(GraphLayoutCacheEvent e) {
		handleChange(e.getChange());
		changeHandled();
		for (UpdateListener l : updateListeners) {
			l.updated();
		}
	}

	public void valueChanged(GraphSelectionEvent e) {
		// Ignore for now
	}

	@Override
	public String getToolTipText(MouseEvent event) {
		// get first cell under the mouse pointer's position
		Object cell = getFirstCellForLocation(event.getX(), event.getY());

		ViewSpecificAttributeMap map = getViewSpecificAttributes();

		// determine what is being pointed to by the mouse pointer
		if (cell instanceof ProMGraphCell) {
			// mouse is pointing to a node or a port on that node
			ProMGraphCell c = ((ProMGraphCell) cell);
			return map.get(c.getNode(), AttributeMap.TOOLTIP, c.getLabel());
		} else if (cell instanceof ProMGraphEdge) {
			ProMGraphEdge e = ((ProMGraphEdge) cell);
			return map.get(e.getEdge(), AttributeMap.TOOLTIP, e.getLabel());
		}

		return null;
	}

	// returns the original origin
	@SuppressWarnings({ ""unchecked"", ""rawtypes"" })
	public void repositionToOrigin() {

		//		facade.translateCells(facade.getVertices(), 100.0, 100.0);
		//		facade.translateCells(facade.getEdges(), 100.0, 100.0);
		//		getGraphLayoutCache().edit(facade.createNestedMap(true, false));
		/*
		 * Second, pull everything back to (2,2). Works like a charm, even when
		 * a hack...
		 */

		//TODO Doesn't correctly handle collapsed nodes.

		JGraphFacade facade = new JGraphFacade(this);
		facade.setIgnoresHiddenCells(true);
		facade.setIgnoresCellsInGroups(false);
		facade.setIgnoresUnconnectedCells(false);

		double x = facade.getGraphOrigin().getX();
		double y = facade.getGraphOrigin().getY();

		ArrayList cells = new ArrayList();
		cells.addAll(facade.getVertices());
		cells.addAll(facade.getEdges());
		facade.translateCells(cells, 2.0 - x, 2.0 - y);
		Map map = facade.createNestedMap(true, false);
		getGraphLayoutCache().edit(map);

	}

	public DirectedGraph<? extends DirectedGraphNode, ? extends DirectedGraphEdge<? extends DirectedGraphNode, ? extends DirectedGraphNode>> getProMGraph() {
		return model.getGraph();
	}

	private void registerAsListener() {
		model.addGraphModelListener(this);
		addGraphSelectionListener(this);
		getGraphLayoutCache().addGraphLayoutCacheListener(this);
	}

	public int hashCode() {
		return model.getGraph().hashCode();
	}

	public JGraphLayout getUpdateLayout() {
		return layout;
	}

	public GraphLayoutConnection getLayoutConnection() {
		return layoutConnection;
	}

	public void setUpdateLayout(JGraphLayout layout) {
		this.layout = layout;
	}

	public ViewSpecificAttributeMap getViewSpecificAttributes() {
		return viewSpecificAttributes;
	}

	public void nodeCollapsed(Expandable source) {
		ProMGraphCell cell = (nodeMap.get(source));
		// Before calling collapse, set the size of cell to the collapsed size

		Point2D pos = layoutConnection.getPosition(source);
		if (pos == null) {
			pos = new Point2D.Double(10, 10);
		}

		Dimension size = source.getCollapsedSize();

		Rectangle2D bounds = GraphConstants.getBounds(cell.getAttributes());
		bounds.setFrame(pos.getX(), pos.getY(), size.getWidth(), size.getHeight());
		getGraphLayoutCache().collapse(DefaultGraphModel.getDescendants(model, new Object[] { cell }).toArray());
	}

	public void nodeExpanded(Expandable source) {
		ProMGraphCell cell = (nodeMap.get(source));
		getGraphLayoutCache().expand(DefaultGraphModel.getDescendants(model, new Object[] { cell }).toArray());
	}

	public JComponent getComponent() {
		// for interface Scalable
		return this;
	}

	Set<UpdateListener> updateListeners = new HashSet<UpdateListener>();

	public void addUpdateListener(UpdateListener listener) {
		updateListeners.add(listener);
	}

	public void removeUpdateListener(UpdateListener listener) {
		updateListeners.remove(listener);
	}

	public void layoutConnectionUpdated(AttributeMapOwner... owners) {
		update((Object[]) owners);
	}

}

class Change implements GraphModelEvent.GraphModelChange {

	private final Collection<Object> added;
	private final Collection<Object> removed;
	private final Collection<Object> changed;
	private final ProMGraphModel source;
	private final Rectangle2D dirtyRegion;

	public Change(ProMGraphModel source, Collection<Object> added, Collection<Object> removed,
			Collection<Object> changed, Rectangle2D dirtyRegion) {
		this.source = source;
		this.added = added;
		this.removed = removed;
		this.changed = changed;
		this.dirtyRegion = dirtyRegion;

	}

	public ConnectionSet getConnectionSet() {
		return null;
	}

	public ParentMap getParentMap() {
		return null;
	}

	public ConnectionSet getPreviousConnectionSet() {
		return null;
	}

	public ParentMap getPreviousParentMap() {
		return null;
	}

	public CellView[] getViews(GraphLayoutCache view) {
		return null;
	}

	public void putViews(GraphLayoutCache view, CellView[] cellViews) {

	}

	public Map<?, ?> getAttributes() {
		return null;
	}

	public Object[] getChanged() {
		return changed.toArray();
	}

	public Object[] getContext() {
		return null;
	}

	public Rectangle2D getDirtyRegion() {
		return dirtyRegion;
	}

	public Object[] getInserted() {
		return added.toArray();
	}

	public Map<?, ?> getPreviousAttributes() {
		return null;
	}

	public Object[] getRemoved() {
		return removed.toArray();
	}

	public Object getSource() {
		return source;
	}

	public void setDirtyRegion(Rectangle2D dirty) {

	}

}"
ProMJGraphVisualizer.java,widget,"package org.processmining.models.jgraph;

import java.util.Collection;
import java.util.Map;

import javax.swing.SwingConstants;

import org.processmining.framework.connections.Connection;
import org.processmining.framework.connections.ConnectionCannotBeObtained;
import org.processmining.framework.connections.ConnectionID;
import org.processmining.framework.connections.ConnectionManager;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.util.ui.scalableview.ScalableViewPanel;
import org.processmining.framework.util.ui.scalableview.interaction.ExportInteractionPanel;
import org.processmining.framework.util.ui.scalableview.interaction.PIPInteractionPanel;
import org.processmining.framework.util.ui.scalableview.interaction.ZoomInteractionPanel;
import org.processmining.models.connections.GraphLayoutConnection;
import org.processmining.models.graphbased.AttributeMap;
import org.processmining.models.graphbased.ViewSpecificAttributeMap;
import org.processmining.models.graphbased.directed.DirectedGraph;
import org.processmining.models.jgraph.visualization.ProMJGraphPanel;

import com.jgraph.layout.JGraphFacade;
import com.jgraph.layout.JGraphLayout;
import com.jgraph.layout.hierarchical.JGraphHierarchicalLayout;

public class ProMJGraphVisualizer {

	protected ProMJGraphVisualizer() {
	};

	private static ProMJGraphVisualizer instance = null;

	public static ProMJGraphVisualizer instance() {
		if (instance == null) {
			instance = new ProMJGraphVisualizer();
		}
		return instance;
	}

	protected GraphLayoutConnection findConnection(PluginContext context, DirectedGraph<?, ?> graph) {
		return findConnection(context.getConnectionManager(), graph);
	}

	protected GraphLayoutConnection findConnection(ConnectionManager manager, DirectedGraph<?, ?> graph) {
		Collection<ConnectionID> cids = manager.getConnectionIDs();
		for (ConnectionID id : cids) {
			Connection c;
			try {
				c = manager.getConnection(id);
			} catch (ConnectionCannotBeObtained e) {
				continue;
			}
			if (c != null && !c.isRemoved() && c instanceof GraphLayoutConnection
					&& c.getObjectWithRole(GraphLayoutConnection.GRAPH) == graph) {
				return (GraphLayoutConnection) c;
			}
		}
		return null;
	}

	public ProMJGraphPanel visualizeGraphWithoutRememberingLayout(DirectedGraph<?, ?> graph) {
		return visualizeGraph(new GraphLayoutConnection(graph), null, graph, new ViewSpecificAttributeMap());
	}

	public ProMJGraphPanel visualizeGraphWithoutRememberingLayout(DirectedGraph<?, ?> graph,
			ViewSpecificAttributeMap map) {
		return visualizeGraph(new GraphLayoutConnection(graph), null, graph, map);
	}

	public ProMJGraphPanel visualizeGraph(PluginContext context, DirectedGraph<?, ?> graph) {
		return visualizeGraph(findConnection(context, graph), context, graph, new ViewSpecificAttributeMap());
	}

	public ProMJGraphPanel visualizeGraph(PluginContext context, DirectedGraph<?, ?> graph, ViewSpecificAttributeMap map) {
		return visualizeGraph(findConnection(context, graph), context, graph, map);
	}

	private ProMJGraphPanel visualizeGraph(GraphLayoutConnection layoutConnection, PluginContext context,
			DirectedGraph<?, ?> graph, ViewSpecificAttributeMap map) {
		boolean newConnection = false;
		if (layoutConnection == null) {
			layoutConnection = createLayoutConnection(graph);
			newConnection = true;
		}

		if (!layoutConnection.isLayedOut()) {
			// shown for the first time.
			layoutConnection.expandAll();
		}
		//		graph.signalViews();

		ProMGraphModel model = new ProMGraphModel(graph);
		ProMJGraph jgraph;
		/*
		 * Make sure that only a single ProMJGraph is created at every time.
		 * The underlying JGrpah code cannot handle creating multiple creations at the same time.
		 */
		synchronized (instance) {
			jgraph = new ProMJGraph(model, map, layoutConnection);
		}

		JGraphLayout layout = getLayout(map.get(graph, AttributeMap.PREF_ORIENTATION, SwingConstants.SOUTH));

		if (!layoutConnection.isLayedOut()) {

			JGraphFacade facade = new JGraphFacade(jgraph);

			facade.setOrdered(false);
			facade.setEdgePromotion(true);
			facade.setIgnoresCellsInGroups(false);
			facade.setIgnoresHiddenCells(false);
			facade.setIgnoresUnconnectedCells(false);
			facade.setDirected(true);
			facade.resetControlPoints();
			if (layout instanceof JGraphHierarchicalLayout) {
				facade.run((JGraphHierarchicalLayout) layout, true);
			} else {
				facade.run(layout, true);
			}

			Map<?, ?> nested = facade.createNestedMap(true, true);

			jgraph.getGraphLayoutCache().edit(nested);
//			jgraph.repositionToOrigin();
			layoutConnection.setLayedOut(true);

		}

		jgraph.setUpdateLayout(layout);

		ProMJGraphPanel panel = new ProMJGraphPanel(jgraph);

		panel.addViewInteractionPanel(new PIPInteractionPanel(panel), SwingConstants.NORTH);
		panel.addViewInteractionPanel(new ZoomInteractionPanel(panel, ScalableViewPanel.MAX_ZOOM), SwingConstants.WEST);
		panel.addViewInteractionPanel(new ExportInteractionPanel(panel), SwingConstants.SOUTH);

		layoutConnection.updated();

		if (newConnection) {
			context.getConnectionManager().addConnection(layoutConnection);
		}

		return panel;

	}

	private GraphLayoutConnection createLayoutConnection(DirectedGraph<?, ?> graph) {
		GraphLayoutConnection c = new GraphLayoutConnection(graph);
		return c;
	}

	protected JGraphLayout getLayout(int orientation) {
		JGraphHierarchicalLayout layout = new JGraphHierarchicalLayout();
		layout.setDeterministic(true);
		layout.setCompactLayout(true);
		layout.setFineTuning(true);
		layout.setParallelEdgeSpacing(15);
		layout.setFixRoots(false);
		
	
		layout.setOrientation(orientation);

		return layout;
	}

}
"
ProMLoopRouting.java,widget,"package org.processmining.models.jgraph;

import java.util.List;

import org.jgraph.graph.DefaultEdge;
import org.jgraph.graph.EdgeView;
import org.jgraph.graph.GraphLayoutCache;

public class ProMLoopRouting extends DefaultEdge.DefaultRouting {

	public static ProMLoopRouting ROUTER = new ProMLoopRouting();

	private static final long serialVersionUID = -1502015269578934172L;

	public List<?> route(GraphLayoutCache cache, EdgeView edge) {
		// No routing is performed ""on the fly"", i.e. all routing information
		// is introduced during the layout phase where all internal control points
		// of edges are set. Hence, the route should just return null.
		return null;
	}
}
"
ProMEdgeRenderer.java,widget,"package org.processmining.models.jgraph.renderers;

import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.GradientPaint;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Shape;
import java.awt.geom.Area;
import java.awt.geom.GeneralPath;
import java.awt.geom.Path2D;
import java.awt.geom.Point2D;
import java.util.Map;

import org.jgraph.graph.CellView;
import org.jgraph.graph.EdgeRenderer;
import org.jgraph.graph.EdgeView;
import org.jgraph.graph.GraphConstants;
import org.processmining.framework.util.Cleanable;
import org.processmining.models.graphbased.AttributeMap;
import org.processmining.models.graphbased.ViewSpecificAttributeMap;
import org.processmining.models.graphbased.directed.DirectedGraphEdge;
import org.processmining.models.jgraph.elements.ProMGraphEdge;
import org.processmining.models.jgraph.views.JGraphEdgeView;

public class ProMEdgeRenderer extends EdgeRenderer implements Cleanable {

	private static final long serialVersionUID = 4470395577059556630L;

	private transient int middleDeco, middleSize;
	private transient boolean middleFill;
	private transient int numLines;
	private transient float lineWidth;

	public void cleanUp() {
		view = null;
	}

	protected void paintLabel(Graphics g, String label, Point2D p, boolean mainLabel) {
		ViewSpecificAttributeMap map = ((JGraphEdgeView) view).getViewSpecificAttributeMap();
		DirectedGraphEdge<?, ?> edge = ((JGraphEdgeView) view).getEdge();
		if (map.get(edge, AttributeMap.SHOWLABEL, false) && !((JGraphEdgeView) view).isPIP()) {
			super.paintLabel(g, mainLabel ? map.get(edge, AttributeMap.LABEL, label) : label, p, mainLabel);
		}
	}

	/**
	 * Returns the label size of the specified view in the given graph.
	 */
	public Dimension getLabelSize(EdgeView view, String label) {
		ViewSpecificAttributeMap map = ((JGraphEdgeView) view).getViewSpecificAttributeMap();
		DirectedGraphEdge<?, ?> edge = ((JGraphEdgeView) view).getEdge();
		if (map.get(edge, AttributeMap.SHOWLABEL, false) && !((JGraphEdgeView) view).isPIP()) {
			return super.getLabelSize(view, map.get(edge, AttributeMap.LABEL, """"));
		} else {
			return new Dimension(0, 0);
		}
	}

	@Override
	protected void installAttributes(final CellView view) {
		super.installAttributes(view);
		Map map = view.getAllAttributes();

		//		JGraphEdgeView v = (JGraphEdgeView) view;
		//		ViewSpecificAttributeMap vMap = v.getViewSpecificAttributeMap();
		//		DirectedGraphEdge<?, ?> edge = v.getEdge();

		lineWidth = (Float) map.get(ProMGraphEdge.LINEWIDTH);

		numLines = (Integer) map.get(ProMGraphEdge.NUMBERLINES);
		middleDeco = (Integer) map.get(ProMGraphEdge.LINEMIDDLE);
		middleSize = 20;
		middleFill = (Boolean) map.get(ProMGraphEdge.MIDDLEFILL) && isFillable(middleDeco);

	}

	@Override
	protected void paintEdge(Graphics g) {
		ViewSpecificAttributeMap map = ((JGraphEdgeView) view).getViewSpecificAttributeMap();
		Color foreground = map.get(((JGraphEdgeView) view).getEdge(), AttributeMap.EDGECOLOR, getForeground());
		setForeground((foreground != null) ? foreground : defaultForeground);
		lineWidth = map.get(((JGraphEdgeView) view).getEdge(), AttributeMap.LINEWIDTH, lineWidth);

		g.setColor(getForeground());
		if (lineWidth > 0) {
			Graphics2D g2 = (Graphics2D) g;
			int c = BasicStroke.CAP_BUTT;
			int j = BasicStroke.JOIN_MITER;
			g2.setStroke(new BasicStroke(lineWidth, c, j));
			if (gradientColor != null && !preview) {
				g2.setPaint(new GradientPaint(0, 0, getBackground(), getWidth(), getHeight(), gradientColor, true));
			}
			if (lineDash != null) // Dash For Line Only
				g2.setStroke(new BasicStroke(lineWidth, c, j, 10.0f, lineDash, dashOffset));
			if (view.lineShape != null) {
				Color color = getForeground();
				drawLine(g2, c, j, color);
			}
			g2.setStroke(new BasicStroke(lineWidth, c, j));
			g2.setColor(getForeground());
			if (view.beginShape != null) {
				if (beginFill) {
					g2.fill(view.beginShape);
					g2.draw(view.beginShape);
				} else {
					g2.setColor(getBackground());
					g2.fill(view.beginShape);
					g2.setColor(getForeground());
					g2.draw(view.beginShape);
				}
			}
			if (view.endShape != null) {
				if (endFill) {
					g2.fill(view.endShape);
					g2.draw(view.endShape);
				} else {
					g2.setColor(getBackground());
					g2.fill(view.endShape);
					g2.setColor(getForeground());
					g2.draw(view.endShape);
				}
			}

			if (((JGraphEdgeView) view).middleShape != null) {
				if (middleFill) {
					g2.fill(((JGraphEdgeView) view).middleShape);
					g2.draw(((JGraphEdgeView) view).middleShape);
				} else {
					g2.setColor(getBackground());
					g2.fill(((JGraphEdgeView) view).middleShape);
					g2.setColor(getForeground());
					g2.draw(((JGraphEdgeView) view).middleShape);
				}
			}

		}
	}

	protected void drawLine(Graphics2D g2, int c, int j, Color color) {
		if (numLines == 1) {
			g2.draw(view.lineShape);
		} else {
			for (int i = 2 * numLines - 1; i > 0; i -= 2) {
				if (lineDash != null) // Dash For Line Only
					g2.setStroke(new BasicStroke(lineWidth * i, c, j, 10.0f, lineDash, dashOffset));
				else
					g2.setStroke(new BasicStroke(lineWidth * i, c, j));
				g2.setColor(color);
				g2.draw(view.lineShape);
				color = switchColor(color);
			}
		}
	}

	@Override
	protected void paintSelection(Graphics g) {
		if (selected) { // Paint Selected
			Graphics2D g2 = (Graphics2D) g;
			int c = BasicStroke.CAP_BUTT;
			int j = BasicStroke.JOIN_MITER;
			g2.setStroke(GraphConstants.SELECTION_STROKE);
			g2.setColor(highlightColor);
			if (view.beginShape != null)
				g2.draw(view.beginShape);
			if (view.lineShape != null)
				//				g2.draw(view.lineShape);
				drawLine(g2, c, j, highlightColor);
			if (view.endShape != null)
				g2.draw(view.endShape);
			//			if (((JGraphEdgeView) view).middleShape != null) {
			//				g2.draw(((JGraphEdgeView) view).middleShape);
			//			}
		}
	}

	private Color switchColor(final Color color) {
		if (color != null) {
			if (color.equals(getForeground())) {
				return getBackground();
			} else {
				return getForeground();
			}
		}
		return getForeground();
	}

	/**
	 * Paint the current view's direction. Sets tmpPoint as a side-effect such
	 * that the invoking method can use it to determine the connection point to
	 * this decoration.
	 * 
	 * @param size
	 *            int
	 * @param style
	 *            int
	 * @param src
	 *            Point2D
	 * @param dst
	 *            Point2D
	 * @return Shape
	 */
	@Override
	protected Shape createLineEnd(final int size, final int style, final Point2D src, final Point2D dst) {
		if (src == null || dst == null) {
			return null;
		}

		switch (style) {
			case ProMGraphEdge.ARROW_TECHNICAL_CIRCLE :
				final Area areaCircle = new Area(super.createLineEnd(size, GraphConstants.ARROW_CIRCLE, src, dst));
				final Shape arrow = super.createLineEnd(size, GraphConstants.ARROW_TECHNICAL, src, dst);
				final Area areaPoly = new Area(arrow);
				areaCircle.add(areaPoly);
				return areaCircle;
			case ProMGraphEdge.ARROW_CROSS :
				final GeneralPath path = new GeneralPath(Path2D.WIND_NON_ZERO, 4);
				path.moveTo((float) (dst.getX() + 5), (float) (dst.getY() + 5));
				path.lineTo((float) (dst.getX() - 5), (float) (dst.getY() - 5));
				path.moveTo((float) (dst.getX() + 5), (float) (dst.getY() - 5));
				path.lineTo((float) (dst.getX() - 5), (float) (dst.getY() + 5));
				return path;
			default :
				return super.createLineEnd(size, style, src, dst);
		}
	}

	@Override
	protected Shape createShape() {
		if (middleDeco != GraphConstants.ARROW_NONE) {
			if (view.getPoints().size() > 1) {
				//				final Point2D p1 = view.getPoint(view.getPoints().size() / 2 - 1);
				//				final Point2D p2;
				//				if ((view.getPoints().size() & 1) == 0) {
				//					// even number of points
				//					p2 = new Point2D.Double((p1.getX() + view.getPoint(view.getPoints().size() / 2).getX()) / 2,
				//							(p1.getY() + view.getPoint(view.getPoints().size() / 2).getY()) / 2);
				//				} else {
				//					p2 = view.getPoint(view.getPoints().size() / 2);
				//				}
				Point2D p1 = view.getPoint(0);
				Point2D p2 = view.getPoint(view.getPoints().size() - 1);
				Point2D p3 = new Point2D.Double(p1.getX() + (p2.getX() - p1.getX()) / 2, p1.getY()
						+ (p2.getY() - p1.getY()) / 2);

				int pi = -1;
				double min = Double.MAX_VALUE;
				for (int i = 1; i < view.getPointCount() - 1; i++) {
					if (view.getPoint(i).distance(p3) < min) {
						min = view.getPoint(i).distance(p3);
						pi = i;
						p1 = view.getPoint(i - 1);
					}
				}
				if (pi >= 0)
					p3 = view.getPoint(pi);

				// We draw at p3 in the direction of p1

				((JGraphEdgeView) view).middleShape = createLineEnd(middleSize, middleDeco, p1, p3);
			}
		}
		return super.createShape();
	}
}
"
ProMGroupShapeRenderer.java,widget,"package org.processmining.models.jgraph.renderers;

/*
 * $Id: JGraphGroupRenderer.java,v 1.1 2005/10/08 13:30:01 david Exp $ Copyright
 * (c) 2001-2005, Gaudenz Alder
 * 
 * All rights reserved.
 * 
 * This file is licensed under the JGraph software license, a copy of which will
 * have been provided to you in the file LICENSE at the root of your
 * installation directory. If you are unable to locate this file please contact
 * JGraph sales for another copy.
 */

import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Component;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Rectangle;
import java.awt.Stroke;
import java.awt.geom.Point2D;

import org.jgraph.JGraph;
import org.jgraph.graph.CellView;
import org.processmining.models.graphbased.Expandable;
import org.processmining.models.graphbased.directed.DirectedGraphNode;
import org.processmining.models.jgraph.views.JGraphShapeView;

/**
 * Renderer for grouped cells, includes '+' '-' to expand/collapse
 */
public class ProMGroupShapeRenderer extends ProMShapeRenderer {

	/**
	 * 
	 */
	private static final long serialVersionUID = -2995081858764785849L;

	/**
	 * Default handle bounds for renderer, '+' or '-'
	 */
	public static Rectangle handle = new Rectangle(0, 0, 20, 20);

	/**
	 * Specifies whether the current view is a rich text value, and if the image
	 * should be stretched.
	 */
	protected boolean isGroup = false;

	/**
	 * Holds the background and foreground of the graph.
	 */
	protected Color handleColor = Color.white, graphForeground = Color.black;


	/**
	 * Overrides the parent implementation to return the value component stored
	 * in the user object instead of this renderer if a value component exists.
	 * This applies some of the values installed to this renderer to the value
	 * component (border, opaque) if the latter is a JComponent.
	 * 
	 * @return Returns a configured renderer for the specified view.
	 */
	public Component getRendererComponent(JGraph graph, CellView view, boolean sel, boolean focus, boolean preview) {
		handleColor = graph.getHandleColor();
		graphForeground = graph.getForeground();
		DirectedGraphNode node = ((JGraphShapeView) view).getNode();
		isGroup = (node instanceof Expandable); //DefaultGraphModel.isGroup(graph.getModel(), view.getCell());
		return super.getRendererComponent(graph, view, sel, focus, preview);
	}

	/**
	 * renderer paint method
	 */
	public void paint(Graphics g) {
		super.paint(g);
		if (isGroup) {
			Graphics2D g2 = (g instanceof Graphics2D ? (Graphics2D) g : null);
			Stroke stroke = (g2 != null ? g2.getStroke() : null);
			if (stroke != null) {
				g2.setStroke(new BasicStroke());
			}
			g.setColor(handleColor);
			g.fill3DRect(handle.x, handle.y, handle.width, handle.height, true);
			g.setColor(graphForeground);
			g.drawRect(handle.x, handle.y, handle.width, handle.height);
			g.drawLine(handle.x + 1, handle.y + handle.height / 2, handle.x + handle.width - 2, handle.y
					+ handle.height / 2);
			if (view.isLeaf()) {
				g.drawLine(handle.x + handle.width / 2, handle.y + 1, handle.x + handle.width / 2, handle.y
						+ handle.height - 2);
			}
			if (stroke != null) {
				g2.setStroke(stroke);
			}
		}
	}

	/**
	 * Detect whether or not a point has hit the group/ungroup image
	 * 
	 * @param pt
	 *            the point to check
	 * @return whether or not the point lies within the handle
	 */
	public boolean inHitRegion(Point2D pt) {
		return handle.contains(pt.getX(), pt.getY());
	}

}
"
ProMPortRenderer.java,widget,"package org.processmining.models.jgraph.renderers;

import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Image;
import java.awt.geom.GeneralPath;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;

import javax.swing.Icon;
import javax.swing.ImageIcon;
import javax.swing.JLabel;
import javax.swing.SwingConstants;

import org.jgraph.graph.DefaultPort;
import org.jgraph.graph.PortRenderer;
import org.jgraph.graph.PortView;
import org.processmining.framework.util.Cleanable;
import org.processmining.models.graphbased.AttributeMap;
import org.processmining.models.graphbased.ViewSpecificAttributeMap;
import org.processmining.models.graphbased.directed.BoundaryDirectedGraphNode;
import org.processmining.models.jgraph.views.JGraphPortView;
import org.processmining.models.jgraph.views.JGraphShapeView;
import org.processmining.models.shapes.Decorated;
import org.processmining.models.shapes.Shape;

public class ProMPortRenderer extends PortRenderer implements Cleanable {

	private static final long serialVersionUID = -4077623888811778878L;

	private static LabelRenderer renderer = new LabelRenderer();

	public ProMPortRenderer() {
		super();
	}

	public void cleanUp() {
		view = null;
	}

	public void paint(Graphics g) {
		renderer.setSize(getWidth(), getHeight());
		renderer.paint(view, selected, g);
	}

	public Point2D getPerimeterPoint(PortView view, Point2D source, Point2D p) {
		return renderer.getPerimeterPoint(view, source, p);

	}
}

class LabelRenderer extends JLabel {

	private static final long serialVersionUID = 4310963545024487311L;

	public void paint(PortView view, boolean selected, Graphics g) {
		Object representedObject = ((DefaultPort) view.getCell()).getUserObject();
		if ((representedObject instanceof BoundaryDirectedGraphNode) ? ((BoundaryDirectedGraphNode) representedObject)
				.getBoundingNode() != null : false) {
			BoundaryDirectedGraphNode node = (BoundaryDirectedGraphNode) representedObject;
			Dimension d = getSize();
			ViewSpecificAttributeMap map = ((JGraphPortView) view).getViewSpecificAttributeMap();

			if (!map.get(node, AttributeMap.SHOWLABEL, true) || ((JGraphPortView) view).isPIP()) {
				setText(null);
			} else {
				setVerticalAlignment(map.get(node, AttributeMap.LABELVERTICALALIGNMENT, SwingConstants.TOP));
				setHorizontalAlignment(map.get(node, AttributeMap.LABELHORIZONTALALIGNMENT, SwingConstants.CENTER));
				String text = map.get(node, AttributeMap.LABEL, getText());
				if (!text.toLowerCase().startsWith(""<html>"")) {
					text = ""<html>"" + text + ""</html>"";
				}
				setText(text);
			}

			Shape shape = map.get(node, AttributeMap.SHAPE, JGraphShapeView.RECTANGLE);
			Decorated shapeDecorator = map.get(node, AttributeMap.SHAPEDECORATOR, null);
			if (shapeDecorator == null && node instanceof Decorated) {
				shapeDecorator = (Decorated) node;
			}

			Icon icon = (Icon) map.get(node, AttributeMap.ICON);
			if (icon != null && icon instanceof ImageIcon) {
				Image image = ((ImageIcon) icon).getImage();
				if (icon.getIconHeight() > d.height || icon.getIconWidth() > d.width) {
					image = image.getScaledInstance(d.height, d.width, Image.SCALE_SMOOTH);
				}
				icon = new ImageIcon(image);
			}
			if (!((JGraphPortView) view).isPIP()) {
				setIcon(icon);
			} else {
				setIcon(null);
			}

			int b = map.get(node, AttributeMap.BORDERWIDTH, 1);
			Graphics2D g2 = (Graphics2D) g;

			boolean tmp = selected;

			GeneralPath path = shape.getPath(b, b, d.width - 2 * b, d.height - 2 * b);

			Color fill = (Color) map.get(node, AttributeMap.FILLCOLOR);
			g.setColor(fill);
			setOpaque(fill != null);
			if (fill != null) {
				g2.fill(path);
			}
			//g.setColor(Color.BLACK);
			g.setColor(map.get(node, AttributeMap.STROKECOLOR, Color.BLACK));
			//		g2.setStroke(new BasicStroke(borderWidth));
			float[] pattern = map.get(node, AttributeMap.DASHPATTERN, new float[0]);
			if (pattern.length > 0f) {

				float offset = map.get(node, AttributeMap.DASHOFFSET, 0f);
				g2.setStroke(new BasicStroke(b, BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER, 10f, pattern, offset));
			} else {
				g2.setStroke(new BasicStroke(b));
			}

			g2.draw(path);

			try {
				setBorder(null);
				setOpaque(false);
				// selected = false;
				super.paint(g);
				if (shapeDecorator != null) {
					shapeDecorator.decorate(g2, b, b, d.width - 2 * b, d.height - 2 * b);
				}
			} finally {
				selected = tmp;
			}
		}
	}

	public Point2D getPerimeterPoint(PortView view, Point2D source, Point2D p) {
		Rectangle2D bounds = view.getBounds();
		double x = bounds.getX();
		double y = bounds.getY();
		double width = bounds.getWidth();
		double height = bounds.getHeight();
		double xCenter = x + width / 2;
		double yCenter = y + height / 2;
		double dx = p.getX() - xCenter; // Compute Angle
		double dy = p.getY() - yCenter;
		double alpha = Math.atan2(dy, dx);
		double xout = 0, yout = 0;
		double pi = Math.PI;
		double pi2 = Math.PI / 2.0;
		double beta = pi2 - alpha;
		double t = Math.atan2(height, width);
		if (alpha < -pi + t || alpha > pi - t) { // Left edge
			xout = x;
			yout = yCenter - width * Math.tan(alpha) / 2;
		} else if (alpha < -t) { // Top Edge
			yout = y;
			xout = xCenter - height * Math.tan(beta) / 2;
		} else if (alpha < t) { // Right Edge
			xout = x + width;
			yout = yCenter + width * Math.tan(alpha) / 2;
		} else { // Bottom Edge
			yout = y + height;
			xout = xCenter + height * Math.tan(beta) / 2;
		}
		return new Point2D.Double(xout, yout);
	}
}"
ProMShapeRenderer.java,widget,"package org.processmining.models.jgraph.renderers;

import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Component;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.GradientPaint;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Image;
import java.awt.Paint;
import java.awt.Rectangle;
import java.awt.Stroke;
import java.awt.geom.AffineTransform;
import java.awt.geom.GeneralPath;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;

import javax.swing.Icon;
import javax.swing.ImageIcon;
import javax.swing.SwingConstants;

import org.jgraph.JGraph;
import org.jgraph.graph.CellView;
import org.jgraph.graph.GraphConstants;
import org.jgraph.graph.VertexRenderer;
import org.processmining.framework.util.Cleanable;
import org.processmining.models.graphbased.AttributeMap;
import org.processmining.models.graphbased.ViewSpecificAttributeMap;
import org.processmining.models.graphbased.directed.DirectedGraphNode;
import org.processmining.models.jgraph.views.JGraphShapeView;
import org.processmining.models.shapes.Decorated;
import org.processmining.models.shapes.Shape;

// ************************************************************************
public class ProMShapeRenderer extends VertexRenderer implements Cleanable {

	static {
		// Change the default font
		GraphConstants.DEFAULTFONT = GraphConstants.DEFAULTFONT.deriveFont(Font.PLAIN);
		GraphConstants.DEFAULTFONT = GraphConstants.DEFAULTFONT.deriveFont(9.0f);
		GraphConstants.DEFAULTFONT = GraphConstants.DEFAULTFONT.deriveFont(AffineTransform.getScaleInstance(0.75, 1.0));
	}

	private static final long serialVersionUID = 9118304969661088440L;
	private static final Stroke SELECTIONSTROKE = new BasicStroke(2f);

	/**
	 * Return a slightly larger preferred size than for a rectangle.
	 */
	public Dimension getPreferredSize() {
		Dimension d = super.getPreferredSize();
		d.setSize(d.getWidth() * 1.4, d.getHeight() * 1.4);
		return d;
	}

	/**
	 */
	public void paint(Graphics g) {
		ViewSpecificAttributeMap map = ((JGraphShapeView) view).getViewSpecificAttributeMap();

		highlightColor = highlightColor != null ? highlightColor : Color.ORANGE;
		lockedHandleColor = lockedHandleColor != null ? lockedHandleColor : Color.RED;
		DirectedGraphNode node = ((JGraphShapeView) view).getNode();
		//		Dimension d = (Dimension) map.get(node,AttributeMap.SIZE);
		//		d.setSize(d.getWidth() * 1.4, d.getHeight() * 1.4);

		Dimension d = (Dimension) map.get(node, AttributeMap.SIZE);
		if (d == null) {
			d = getSize();
		} else {
			Rectangle2D bounds = view.getBounds();
			if (bounds.getWidth() != d.getWidth() || bounds.getHeight() != d.getHeight()) {
				view.setBounds(new Rectangle2D.Double(bounds.getX(), bounds.getY(), d.getWidth(), d.getHeight()));
			}
			setSize(d);
		}

		//assert(d.equals(node.getAttributeMap().get(AttributeMap.SIZE)));

		if (!map.get(node, AttributeMap.SHOWLABEL, true) || ((JGraphShapeView) view).isPIP()) {
			setText(null);
		} else {
			setVerticalAlignment(map.get(node, AttributeMap.LABELVERTICALALIGNMENT, SwingConstants.TOP));
			setHorizontalAlignment(map.get(node, AttributeMap.LABELHORIZONTALALIGNMENT, SwingConstants.CENTER));
			String text = map.get(node, AttributeMap.LABEL, getText());
			if (!text.toLowerCase().startsWith(""<html>"")) {
				text = ""<html>"" + text + ""</html>"";
			}
			setText(text);
		}

		Shape shape = map.get(node, AttributeMap.SHAPE, JGraphShapeView.RECTANGLE);
		Decorated shapeDecorator = map.get(node, AttributeMap.SHAPEDECORATOR, null);
		if (shapeDecorator == null && node instanceof Decorated) {
			shapeDecorator = (Decorated) node;
		}

		Icon icon = (Icon) map.get(node, AttributeMap.ICON);
		if ((icon != null) && (icon instanceof ImageIcon)) {
			Image image = ((ImageIcon) icon).getImage();
			if ((icon.getIconHeight() > d.height) || (icon.getIconWidth() > d.width)) {
				image = image.getScaledInstance(d.height, d.width, Image.SCALE_SMOOTH);
			}
			icon = new ImageIcon(image);
		}
		if (!((JGraphShapeView) view).isPIP()) {
			setIcon(icon);
		} else {
			setIcon(null);
		}

		borderWidth = map.get(node, AttributeMap.BORDERWIDTH, borderWidth);
		int b = borderWidth - 1;
		Graphics2D g2 = (Graphics2D) g;

		boolean tmp = selected;

		GeneralPath path = shape.getPath(b, b, d.width - 2 * b, d.height - 2 * b);

		Color fill = (Color) map.get(((JGraphShapeView) view).getNode(), AttributeMap.FILLCOLOR);
		Color gradient = (Color) map.get(((JGraphShapeView) view).getNode(), AttributeMap.GRADIENTCOLOR);
		if (gradient == null || gradient.equals(fill)) {
			g.setColor(fill);
			setOpaque(fill != null);
		} else {
			Paint paint = new GradientPaint(0, 0, fill, d.width, 0, gradient);
			g2.setPaint(paint);
			setOpaque(paint != null);
		}
		if (fill != null) {
			g2.fill(path);
		}
		//g.setColor(Color.BLACK);
		g.setColor(map.get(node, AttributeMap.STROKECOLOR, Color.BLACK));
		//		g2.setStroke(new BasicStroke(borderWidth));
		float[] pattern = map.get(node, AttributeMap.DASHPATTERN, new float[0]);
		if (pattern.length > 0f) {

			float offset = map.get(node, AttributeMap.DASHOFFSET, 0f);
			g2.setStroke(new BasicStroke(borderWidth, BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER, 10f, pattern,
					offset));
		} else {
			g2.setStroke(new BasicStroke(borderWidth));
		}

		g2.draw(path);

		try {
			setBorder(null);
			setOpaque(false);
			// selected = false;
			super.paint(g);
			if (shapeDecorator != null) {
				shapeDecorator.decorate(g2, b, b, d.width - 2 * b, d.height - 2 * b);
			}

			//			if (isGroup) {
			//				g.setColor(handleColor);
			//				g.fill3DRect(handle.x, handle.y, handle.width, handle.height, true);
			//				g.setColor(graphForeground);
			//				g.drawRect(handle.x, handle.y, handle.width, handle.height);
			//				g.drawLine(handle.x + 1, handle.y + handle.height / 2, handle.x + handle.width - 2, handle.y
			//						+ handle.height / 2);
			//				if (view.isLeaf()) {
			//					g.drawLine(handle.x + handle.width / 2, handle.y + 1, handle.x + handle.width / 2, handle.y
			//							+ handle.height - 2);
			//				}
			//			}

		} finally {
			selected = tmp;
		}
	}

	protected void paintSelectionBorder(Graphics g) {
		Graphics2D g2 = (Graphics2D) g;
		Stroke previousStroke = g2.getStroke();
		g2.setStroke(SELECTIONSTROKE);
		if (childrenSelected || selected) {
			if (childrenSelected) {
				g.setColor(gridColor);
			} else if (hasFocus && selected) {
				g.setColor(lockedHandleColor);
			} else if (selected) {
				g.setColor(highlightColor);
			}
			Dimension d = getSize();
			g.drawRect(0, 0, d.width - 1, d.height - 1);
		}
		g2.setStroke(previousStroke);
	}

	public void cleanUp() {
		view = null;
	}

	/**
	 * Default handle bounds for renderer, '+' or '-'
	 */
	public static Rectangle handle = new Rectangle(0, 0, 7, 7);

	//	/**
	//	 * Specifies whether the current view is a rich text value, and if the image
	//	 * should be stretched.
	//	 */
	//	protected boolean isGroup = false;

	/**
	 * Holds the background and foreground of the graph.
	 */
	protected Color handleColor = Color.white, graphForeground = Color.black;

	/**
	 * Overrides the parent implementation to return the value component stored
	 * in the user object instead of this renderer if a value component exists.
	 * This applies some of the values installed to this renderer to the value
	 * component (border, opaque) if the latter is a JComponent.
	 * 
	 * @return Returns a configured renderer for the specified view.
	 */
	@Override
	public Component getRendererComponent(JGraph graph, CellView view, boolean sel, boolean focus, boolean preview) {
		handleColor = graph.getHandleColor();
		graphForeground = graph.getForeground();
		return super.getRendererComponent(graph, view, sel, focus, preview);
	}

	/**
	 * Detect whether or not a point has hit the group/ungroup image
	 * 
	 * @param pt
	 *            the point to check
	 * @return whether or not the point lies within the handle
	 */
	public boolean inHitRegion(Point2D pt) {
		return handle.contains(pt.getX(), pt.getY());
	}

}
"
JGraphEdgeView.java,widget,"package org.processmining.models.jgraph.views;

import java.awt.Shape;
import java.awt.geom.Point2D;
import java.util.ArrayList;
import java.util.List;

import org.jgraph.graph.EdgeView;
import org.processmining.framework.util.Cleanable;
import org.processmining.models.graphbased.AttributeMap;
import org.processmining.models.graphbased.ViewSpecificAttributeMap;
import org.processmining.models.graphbased.directed.DirectedGraphEdge;
import org.processmining.models.jgraph.elements.ProMGraphEdge;
import org.processmining.models.jgraph.renderers.ProMEdgeRenderer;

public class JGraphEdgeView extends EdgeView implements Cleanable {

	private static final long serialVersionUID = -2874236692967529775L;
	private static ProMEdgeRenderer renderer;
	private DirectedGraphEdge<?, ?> edge;
	private final boolean isPIP;
	private final ViewSpecificAttributeMap viewSpecificAttributes;

	public transient Shape middleShape;

	@SuppressWarnings(""unchecked"")
	public JGraphEdgeView(ProMGraphEdge cell, boolean isPIP, ViewSpecificAttributeMap viewSpecificAttributes) {
		super(cell);
		this.isPIP = isPIP;
		this.viewSpecificAttributes = viewSpecificAttributes;
		edge = cell.getEdge();
		points = new ArrayList(2);
		points.add(cell.getSource().getView());
		points.addAll(cell.getInternalPoints());
		points.add(cell.getTarget().getView());

		groupBounds = null;
	}

	public void setPoints(List<Point2D> list) {
		points = list;
	}

	public ViewSpecificAttributeMap getViewSpecificAttributeMap() {
		return viewSpecificAttributes;
	}

	@Override
	public ProMEdgeRenderer getRenderer() {
		if (renderer == null) {
			renderer = edge.getAttributeMap().get(AttributeMap.RENDERER, null);
			if (renderer == null) {
				renderer = new ProMEdgeRenderer();
			}
		}
		return renderer;
	}

	public void cleanUp() {
		edge = null;
		setCell(null);
		viewSpecificAttributes.clearViewSpecific(edge);
		source = null;
		target = null;
		if (renderer != null) {
			renderer.cleanUp();
			renderer = null;
		}
	}

	public DirectedGraphEdge<?, ?> getEdge() {
		return edge;
	}

	public boolean isPIP() {
		return isPIP;
	}

}
"
JGraphPortView.java,widget,"package org.processmining.models.jgraph.views;

import java.awt.geom.Point2D;

import org.jgraph.graph.EdgeView;
import org.jgraph.graph.PortView;
import org.processmining.framework.util.Cleanable;
import org.processmining.models.graphbased.ViewSpecificAttributeMap;
import org.processmining.models.jgraph.elements.ProMGraphPort;
import org.processmining.models.jgraph.renderers.ProMPortRenderer;

public class JGraphPortView extends PortView implements Cleanable {

	private static final long serialVersionUID = 5279360045457316828L;
	private static ProMPortRenderer renderer;
	private final boolean isPIP;
	private final ViewSpecificAttributeMap viewSpecificAttributes;
	private final ProMGraphPort cell;

	public JGraphPortView(ProMGraphPort cell, boolean isPIP, ViewSpecificAttributeMap viewSpecificAttributes) {
		super(cell);
		this.cell = cell;
		this.isPIP = isPIP;
		this.viewSpecificAttributes = viewSpecificAttributes;

		groupBounds = null;
	}

	@Override
	public ProMPortRenderer getRenderer() {
		if (renderer == null) {
			renderer = new ProMPortRenderer();
		}
		return renderer;
	}

	public ViewSpecificAttributeMap getViewSpecificAttributeMap() {
		return viewSpecificAttributes;
	}

	public void cleanUp() {
		setCell(null);
		parent = null;
		lastParent = null;
		if (renderer != null) {
			renderer.cleanUp();
			renderer = null;
		}
	}

	public boolean isPIP() {
		return isPIP;
	}

	@Override
	public Point2D getLocation(EdgeView edge, Point2D nearest) {
		Point2D pos = super.getLocation(edge, nearest);
		Point2D pos2 = pos;
		if (renderer != null && nearest != null && //
				cell.isBoundaryNode()) {
			pos2 = renderer.getPerimeterPoint(this, pos, nearest);
		}
		return pos2;
	}
}
"
JGraphShapeView.java,widget,"package org.processmining.models.jgraph.views;

import java.awt.Dimension;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;
import java.util.ArrayList;

import org.jgraph.graph.EdgeView;
import org.jgraph.graph.GraphConstants;
import org.jgraph.graph.VertexView;
import org.processmining.framework.util.Cleanable;
import org.processmining.models.graphbased.AttributeMap;
import org.processmining.models.graphbased.ViewSpecificAttributeMap;
import org.processmining.models.graphbased.directed.DirectedGraphNode;
import org.processmining.models.jgraph.elements.ProMGraphCell;
import org.processmining.models.jgraph.renderers.ProMGroupShapeRenderer;
import org.processmining.models.jgraph.renderers.ProMShapeRenderer;
import org.processmining.models.shapes.Rectangle;
import org.processmining.models.shapes.Shape;

public class JGraphShapeView extends VertexView implements Cleanable {

	public final static Shape RECTANGLE = new Rectangle();

	private static final long serialVersionUID = 660416141359812229L;
	private static ProMGroupShapeRenderer renderer;
	private DirectedGraphNode node;
	private Shape shape;

	private final boolean isPIP;

	private final ViewSpecificAttributeMap viewSpecificAttributes;

	@SuppressWarnings(""unchecked"")
	public JGraphShapeView(ProMGraphCell cell, boolean isPIP, ViewSpecificAttributeMap viewSpecificAttributes) {
		super(cell);
		this.isPIP = isPIP;
		this.viewSpecificAttributes = viewSpecificAttributes;
		node = cell.getNode();
		shape = node.getAttributeMap().get(AttributeMap.SHAPE, RECTANGLE);

		GraphConstants.setMoveable(getAttributes(), node.getAttributeMap().get(AttributeMap.MOVEABLE, true));

		groupBounds = null;
		childViews = new ArrayList();
		for (Object child : cell.getChildren()) {
			if (child instanceof ProMGraphCell) {
				ProMGraphCell c2 = (ProMGraphCell) child;
				if (c2.getView() != null) {
					childViews.add(c2.getView());
				}
			}
		}
		setCachedBounds(GraphConstants.getBounds(cell.getAttributes()));

	}

	@Override
	public ProMShapeRenderer getRenderer() {
		if (renderer == null) {
			renderer = node.getAttributeMap().get(AttributeMap.RENDERER, null);
			if (renderer == null) {
				renderer = new ProMGroupShapeRenderer();
			}
		}
		return renderer;
	}

	@Override
	public Point2D getPerimeterPoint(EdgeView edge, Point2D source, Point2D p) {
		if (p == null) {
			p = getCenterPoint(this);
		}
		return shape.getPerimeterPoint(this.getBounds(), source, p);
	}

	public DirectedGraphNode getNode() {
		return node;
	}

	public ViewSpecificAttributeMap getViewSpecificAttributeMap() {
		return viewSpecificAttributes;
	}

	public void cleanUp() {
		viewSpecificAttributes.clearViewSpecific(node);
		setCell(null);
		node = null;
		shape = null;
		if (renderer != null) {
			getRenderer().cleanUp();
			renderer = null;
		}
	}

	public boolean isPIP() {
		return isPIP;
	}

	@Override
	public Rectangle2D getBounds() {
		Dimension d = (Dimension) viewSpecificAttributes.get(node, AttributeMap.SIZE);
		Rectangle2D b = super.getBounds();
		if (d != null && (d.getWidth() != b.getWidth() || d.getHeight() != b.getHeight())) {
			return new Rectangle2D.Double(b.getX(), b.getY(), d.getWidth(), d.getHeight());
		} else {
			return b;
		}
	}

	/**
	 * Sets the bounds of this <code>view</code>. Calls translateView and
	 * scaleView.
	 * 
	 * @param bounds
	 *            the new bounds for this cell view
	 */
	@Override
	public void setBounds(Rectangle2D bounds) {
		super.setBounds(bounds);
		viewSpecificAttributes.putViewSpecific(node, AttributeMap.SIZE, new Dimension((int) bounds.getWidth(),
				(int) bounds.getHeight()));
	}

}
"
ProMJGraphPanel.java,widget,"package org.processmining.models.jgraph.visualization;

import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.InputEvent;
import java.awt.event.MouseEvent;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;

import javax.swing.JLabel;
import javax.swing.SwingConstants;
import javax.swing.SwingUtilities;

import org.jgraph.graph.BasicMarqueeHandler;
import org.processmining.framework.util.ui.scalableview.ScalableViewPanel;
import org.processmining.models.graphbased.directed.DirectedGraphEdge;
import org.processmining.models.graphbased.directed.DirectedGraphElement;
import org.processmining.models.graphbased.directed.DirectedGraphNode;
import org.processmining.models.jgraph.ProMJGraph;
import org.processmining.models.jgraph.elements.ProMGraphCell;
import org.processmining.models.jgraph.elements.ProMGraphEdge;

public class ProMJGraphPanel extends ScalableViewPanel {

	/**
	 * 
	 */
	private static final long serialVersionUID = 8937461038820086748L;

	public ProMJGraphPanel(final ProMJGraph graph) {
		super(graph);

		JLabel label = new JLabel(""<html>&#8629;</html>"");

		addButton(label, new ActionListener() {

			public void actionPerformed(ActionEvent e) {
				graph.repositionToOrigin();
				updated();
			}
		}, SwingConstants.NORTH_WEST);
	}

	@Override
	protected void initialize() {
		getGraph().setTolerance(4);

		getGraph().setMarqueeHandler(new BasicMarqueeHandler() {
			private boolean test(MouseEvent e) {
				return SwingUtilities.isRightMouseButton(e) && ((e.getModifiers() & InputEvent.ALT_MASK) == 0);

			}

			public boolean isForceMarqueeEvent(MouseEvent event) {
				if (test(event)) {
					return true;
				} else {
					return false;
				}
			}

			@Override
			public void mouseReleased(final MouseEvent e) {
				if (test(e)) {
					e.consume();
				} else {
					super.mouseReleased(e);
				}
			}

			@Override
			public void mousePressed(final MouseEvent e) {
				if (test(e)) {
					synchronized (getGraph().getProMGraph()) {
						// Check for selection.
						// If the cell that is being clicked is part of the
						// selection,
						// we use the current selection.
						// otherwise, we use a new selection
						Object cell = getGraph().getFirstCellForLocation(e.getX(), e.getY());

						Collection<DirectedGraphElement> sel;
						if (cell == null) {
							// Nothing selected
							getGraph().clearSelection();
							sel = new ArrayList<DirectedGraphElement>(0);
						} else if (getGraph().getSelectionModel().isCellSelected(cell)) {
							// the current selection contains cell
							// use that selection
							sel = getSelectedElements();
						} else {
							// the current selection does not contain cell.
							// reset the selection to [cell]
							sel = new ArrayList<DirectedGraphElement>(1);
							sel.add(getElementForLocation(e.getX(), e.getY()));
							getGraph().setSelectionCell(cell);
						}

					}
				} else {
					super.mousePressed(e);
				}
			}

		});
		super.initialize();
	}

	public ProMJGraph getGraph() {
		return (ProMJGraph) getComponent();
	}

	public Collection<DirectedGraphElement> getSelectedElements() {
		List<DirectedGraphElement> elements = new ArrayList<DirectedGraphElement>();
		for (Object o : getGraph().getSelectionCells()) {
			if (o instanceof ProMGraphCell) {
				elements.add(((ProMGraphCell) o).getNode());
			} else if (o instanceof ProMGraphEdge) {
				elements.add(((ProMGraphEdge) o).getEdge());
			}
		}
		return elements;
	}

	public Collection<DirectedGraphNode> getSelectedNodes() {
		List<DirectedGraphNode> nodes = new ArrayList<DirectedGraphNode>();
		for (Object o : getGraph().getSelectionCells()) {
			if (o instanceof ProMGraphCell) {
				nodes.add(((ProMGraphCell) o).getNode());
			}
		}
		return nodes;
	}

	public Collection<DirectedGraphEdge<?, ?>> getSelectedEdges() {
		List<DirectedGraphEdge<?, ?>> edges = new ArrayList<DirectedGraphEdge<?, ?>>();
		for (Object o : getGraph().getSelectionCells()) {
			if (o instanceof ProMGraphEdge) {
				edges.add(((ProMGraphEdge) o).getEdge());
			}
		}
		return edges;
	}

	public DirectedGraphElement getElementForLocation(double x, double y) {
		Object cell = getGraph().getFirstCellForLocation(x, y);
		if (cell instanceof ProMGraphCell) {
			return ((ProMGraphCell) cell).getNode();
		}
		if (cell instanceof ProMGraphEdge) {
			return ((ProMGraphEdge) cell).getEdge();
		}
		return null;
	}

}
"
DashedBorder.java,widget,"package org.processmining.framework.util.ui.scalableview;

import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Stroke;

public class DashedBorder extends javax.swing.border.LineBorder {

	/**
	 * 
	 */
	private static final long serialVersionUID = 1357931293759243135L;

	public DashedBorder(Color color) {
		super(color);
	}

	public void paintBorder(java.awt.Component comp, Graphics g, int x1,
			int x2, int y1, int y2) {

		Stroke old = ((Graphics2D) g).getStroke();
		BasicStroke bs = new BasicStroke(5.0f, BasicStroke.CAP_BUTT,
				BasicStroke.JOIN_MITER, 10.0f, new float[] { 15.0f, 30.0f },
				2.0f);
		((Graphics2D) g).setStroke(bs);
		super.paintBorder(comp, g, x1, x2, y1, y2);
		((Graphics2D) g).setStroke(old);
	}
}"
CompoundViewInteractionPanel.java,widget,"package org.processmining.framework.util.ui.scalableview.interaction;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Component;
import java.awt.Dimension;
import java.awt.Point;
import java.awt.event.MouseEvent;
import java.awt.event.MouseMotionListener;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.swing.BorderFactory;
import javax.swing.DefaultListCellRenderer;
import javax.swing.DefaultListModel;
import javax.swing.JComponent;
import javax.swing.JLabel;
import javax.swing.JLayeredPane;
import javax.swing.JList;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.ScrollPaneConstants;
import javax.swing.SwingConstants;

import org.processmining.framework.util.Pair;
import org.processmining.framework.util.ui.scalableview.ScalableComponent;
import org.processmining.framework.util.ui.scalableview.ScalableViewPanel;

import com.fluxicon.slickerbox.factory.SlickerDecorator;
import com.fluxicon.slickerbox.factory.SlickerFactory;

public class CompoundViewInteractionPanel extends JPanel implements ViewInteractionPanel, MouseMotionListener {
	protected final static int BUTTONHEIGHT = (ScalableViewPanel.TAB_HEIGHT * 5) / 6;
	protected final static int BUTTONWIDTH = (ScalableViewPanel.TAB_WIDTH * 5) / 6;

	private static final long serialVersionUID = -4871727332152661398L;
	private final String name;
	private JList list;
	private ScalableComponent scalable;
	private List<ViewInteractionPanel> panelList = new ArrayList<ViewInteractionPanel>();
	private Map<ViewInteractionPanel, Pair<JPanel, JPanel>> panels = new HashMap<ViewInteractionPanel, Pair<JPanel, JPanel>>();
	protected SlickerFactory factory = SlickerFactory.instance();
	private ScalableViewPanel parentPanel;
	private JScrollPane scroll;
	private CompoundListCellRenderer renderer;

	public CompoundViewInteractionPanel(String name) {
		super();
		setLayout(null);
		this.name = name;
		this.list = new JList(new DefaultListModel());
		renderer = new CompoundListCellRenderer(panels);
		list.setCellRenderer(renderer);

		list.setEnabled(false);

		list.addMouseMotionListener(this);
		this.scroll = new JScrollPane(list);
		SlickerDecorator.instance().decorate(scroll, Color.WHITE, Color.GRAY, Color.DARK_GRAY);

		this.list.setOpaque(false);

		// add the title
		JLabel panelTitle = factory.createLabel(name);
		panelTitle.setHorizontalTextPosition(SwingConstants.CENTER);
		panelTitle.setVerticalTextPosition(SwingConstants.CENTER);
		panelTitle.setForeground(Color.WHITE);
		panelTitle.setFont(new java.awt.Font(""Dialog"", java.awt.Font.BOLD, 13));
		panelTitle.setOpaque(false);
		this.add(panelTitle, BorderLayout.NORTH);
		this.setOpaque(false);

		scroll.getViewport().setOpaque(false);
		scroll.setOpaque(false);
		scroll.setBorder(BorderFactory.createEmptyBorder());
		scroll.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);
		scroll.getVerticalScrollBar().setOpaque(false);

		this.add(scroll);

		validate();
		repaint();

	}

	public void mouseDragged(MouseEvent e) {

	}

	private ViewInteractionPanel oldPanel = null;

	public synchronized void mouseMoved(MouseEvent e) {
		Point p = e.getPoint();
		if (e.getComponent() == scroll) {
			Point p2 = scroll.getViewport().getViewPosition();
			p.setLocation(p.getX() - p2.getX(), p.getY() - p2.getY());
		}
		if (oldPanel != null) {
			oldPanel.willChangeVisibility(false);
			JPanel panelOn = panels.get(oldPanel).getFirst();
			JPanel panelOff = panels.get(oldPanel).getSecond();
			panelOn.setEnabled(false);
			panelOn.setVisible(false);
			panelOff.setEnabled(true);
			panelOff.setVisible(true);
			oldPanel = null;

		}
		int x = p.x;
		int y = p.y;
		if (x < 00 || x > BUTTONWIDTH + 50) {
			return;
		}
		int index = y / (BUTTONHEIGHT);
		if (index >= list.getModel().getSize()) {
			return;
		}
		Point offset = CompoundViewInteractionPanel.this.getParent().getLocation();
		ViewInteractionPanel panel = (ViewInteractionPanel) list.getModel().getElementAt(index);

		JPanel panelOn = panels.get(panel).getFirst();
		JPanel panelOff = panels.get(panel).getSecond();

		parentPanel.setSize(panel, panelOn, panelOff);
		panelOn.setPreferredSize(new Dimension(panel.getComponent().getWidth() + 20,
				panel.getComponent().getHeight() + 20));
		int w = panel.getComponent().getWidth() + 20;
		int h = panel.getComponent().getHeight() + 20;
		panelOn.setSize(new Dimension(w, h));
		int l_x = offset.x + BUTTONWIDTH + 40;
		int l_y = offset.y + 10 + index * BUTTONHEIGHT;
		if ((l_x + w > parentPanel.getWidth()) && (offset.x + 10 >= w)) {
			l_x = offset.x - w + 10;

		}
		if ((l_y + h > parentPanel.getHeight()) && (parentPanel.getHeight() >= h)) {
			l_y = parentPanel.getHeight() - h;
		}

		panelOn.setLocation(l_x, l_y);

		oldPanel = panel;
		panel.willChangeVisibility(true);
		panelOn.setEnabled(true);
		panelOn.setVisible(true);
		panelOff.setEnabled(false);
		panelOff.setVisible(false);

	}

	public void updated() {
		for (ViewInteractionPanel p : panelList) {
			p.updated();
		}
	}

	public String getPanelName() {
		return name;
	}

	public JComponent getComponent() {
		return this;
	}

	public void setScalableComponent(ScalableComponent scalable) {
		this.scalable = scalable;
		for (ViewInteractionPanel p : panelList) {
			p.setScalableComponent(scalable);
		}
	}

	public void setParent(ScalableViewPanel parent) {
		parentPanel = parent;
		for (ViewInteractionPanel p : panelList) {
			p.setParent(parent);
			parentPanel.add(panels.get(p).getFirst(), JLayeredPane.MODAL_LAYER);
		}
	}

	public double getHeightInView() {
		return BUTTONHEIGHT * length();
	}

	public double getWidthInView() {
		return BUTTONWIDTH + 10;
	}

	public void willChangeVisibility(boolean to) {
		if (to) {
			scroll.setBounds(0, 0, BUTTONWIDTH + 30, getHeight());
			list.setSize(list.getPreferredSize());
			invalidate();
			repaint();
		} else {
			if (oldPanel != null) {
				// hmm, moved out of the list and out of the panel:
				JPanel panelOn = panels.get(oldPanel).getFirst();
				JPanel panelOff = panels.get(oldPanel).getSecond();
				panelOn.setEnabled(false);
				panelOn.setVisible(false);
				panelOff.setEnabled(true);
				panelOff.setVisible(true);
				oldPanel = null;
			}
		}
	}

	public void addViewInteractionPanel(ViewInteractionPanel panel) {
		JPanel panelOn = factory.createRoundedPanel(15, Color.LIGHT_GRAY);
		JPanel panelOff = factory.createRoundedPanel(15, Color.DARK_GRAY);
		panelOn.setLayout(null);
		panelOff.setLayout(null);

		panelOn.add(panel.getComponent());
		panelOn.setVisible(false);
		panelOn.setEnabled(false);
		panelOff.setVisible(true);
		panelOff.setEnabled(true);
		panelOff.setToolTipText(panel.getPanelName());
		JLabel panelTitle = factory.createLabel(panel.getPanelName());
		panelTitle.setHorizontalTextPosition(SwingConstants.CENTER);
		panelTitle.setVerticalTextPosition(SwingConstants.CENTER);
		panelTitle.setForeground(Color.WHITE);
		panelTitle.setFont(new java.awt.Font(""Dialog"", java.awt.Font.BOLD, 14));
		panelTitle.setBounds(10, 0, BUTTONWIDTH, BUTTONHEIGHT);

		panelOff.add(panelTitle);
		//		panelOff.setBounds(0, 0, 120, BUTTONHEIGHT);
		panelOff.setPreferredSize(new Dimension(BUTTONWIDTH, BUTTONHEIGHT));

		panel.getComponent().setLocation(10, 10);

		panels.put(panel, new Pair<JPanel, JPanel>(panelOn, panelOff));
		panelList.add(panel);
		((DefaultListModel) list.getModel()).addElement(panel);

		panelOn.setLocation(0, 0);
		if (parentPanel != null) {
			parentPanel.add(panelOn, JLayeredPane.MODAL_LAYER);
			panel.setParent(parentPanel);
		}
		if (scalable != null) {
			panel.setScalableComponent(scalable);
		}
		//		this.add(panelOff, JLayeredPane.DRAG_LAYER);

		panel.updated();
	}

	public int length() {
		return panelList.size();
	}
}

class CompoundListCellRenderer extends DefaultListCellRenderer {
	/**
	 * 
	 */
	private static final long serialVersionUID = -808355468668630456L;
	private final Map<ViewInteractionPanel, Pair<JPanel, JPanel>> panels;

	public CompoundListCellRenderer(Map<ViewInteractionPanel, Pair<JPanel, JPanel>> panels) {
		this.panels = panels;
	}

	public Component getListCellRendererComponent(JList component, Object value, int index, boolean isSelected,
			boolean cellHasFocus) {
		ViewInteractionPanel panel = (ViewInteractionPanel) value;
		JPanel off = panels.get(panel).getSecond();
		return off;
	}
}
"
ExportInteractionPanel.java,widget,"package org.processmining.framework.util.ui.scalableview.interaction;

import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

import javax.swing.JComponent;
import javax.swing.JPanel;

import org.freehep.graphicsbase.util.export.ExportDialog;
import org.processmining.framework.util.ui.scalableview.ScalableComponent;
import org.processmining.framework.util.ui.scalableview.ScalableViewPanel;

import com.fluxicon.slickerbox.components.SlickerButton;

import info.clearthought.layout.TableLayout;
import info.clearthought.layout.TableLayoutConstants;

public class ExportInteractionPanel extends JPanel implements ViewInteractionPanel {

	/**
	 * 
	 */
	private static final long serialVersionUID = 1036741994786060955L;
	protected final ScalableViewPanel panel;
	private ScalableComponent scalable;
	private SlickerButton exportButton;

	public ExportInteractionPanel(ScalableViewPanel panel) {
		this.panel = panel;
		double size[][] = { { 10, TableLayoutConstants.FILL, 10 }, { 10, TableLayoutConstants.FILL, 10 } };
		setLayout(new TableLayout(size));
		exportButton = new SlickerButton(""Export view..."");
		exportButton.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				export();
			}
		});
		this.add(exportButton, ""1, 1"");
	}

	private void export() {
		ExportDialog export = new ExportDialog();
		export.showExportDialog(this, ""Export view as ..."", scalable.getComponent(), ""View"");
	}

	public void updated() {
		// TODO Auto-generated method stub

	}

	public String getPanelName() {
		return ""Export"";
	}

	public JComponent getComponent() {
		return this;
	}

	public void setScalableComponent(ScalableComponent scalable) {
		this.scalable = scalable;
	}

	public void setParent(ScalableViewPanel viewPanel) {
	}

	public double getHeightInView() {
		return 50;
	}

	public double getWidthInView() {
		return 100;
	}

	public void willChangeVisibility(boolean to) {
	}
}
"
PIPInteractionPanel.java,widget,"package org.processmining.framework.util.ui.scalableview.interaction;

import java.awt.BasicStroke;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Point;
import java.awt.Stroke;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.awt.event.MouseMotionListener;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;
import java.awt.image.BufferedImage;

import javax.swing.BorderFactory;
import javax.swing.ImageIcon;
import javax.swing.JComponent;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JViewport;
import javax.swing.SwingConstants;
import javax.swing.SwingUtilities;

import org.processmining.framework.util.ui.scalableview.ScalableComponent;
import org.processmining.framework.util.ui.scalableview.ScalableViewPanel;

public class PIPInteractionPanel extends JPanel implements MouseListener, MouseMotionListener, ViewInteractionPanel {

	public static final int PIPSIZE = 250;
	public static final Stroke DEFAULTSTROKE = new BasicStroke(2);

	private static final long serialVersionUID = 5563202305263696868L;

	// new FlowLayout(FlowLayout.LEADING, 0, 0);
	private Rectangle2D rect = new Rectangle2D.Double(0, 0, 0, 0);
	private Stroke stroke = DEFAULTSTROKE;
	private Color color = Color.BLUE;
	private JViewport parentScroll;
	private final ScalableViewPanel panel;

	private JComponent component;

	private ScalableComponent scalable;

	public PIPInteractionPanel(ScalableViewPanel panel) {

		super(new BorderLayout());

		this.setBorder(BorderFactory.createEmptyBorder());
		this.setOpaque(true);

		this.addMouseMotionListener(this);
		this.addMouseListener(this);

		this.parentScroll = panel.getViewport();
		this.panel = panel;

	}

	public synchronized void initializeImage() {
		Dimension size = component.getPreferredSize();
		if (size.getWidth() > 0 && size.getHeight() > 0) {
			if (this.getComponentCount() > 0) {
				this.remove(0);
			}

			double rx = (double) getWidth() / (double) size.width;
			double ry = (double) getHeight() / (double) size.height;
			double r = Math.min(rx, ry);

			BufferedImage image = (BufferedImage) component.createImage(getWidth(), getHeight());
			Graphics2D g2ds = image.createGraphics();

			g2ds.setColor(component.getBackground());
			g2ds.fillRect(0, 0, getWidth(), getHeight());

			double oldScale = scalable.getScale();
			scalable.setScale(r * oldScale);
			component.paint(g2ds);
			scalable.setScale(oldScale);
			g2ds.dispose();

			drawMain(rect.getX(), rect.getY());
			setRect();

			JLabel label = new JLabel(new ImageIcon(image), SwingConstants.LEFT);
			label.setBorder(BorderFactory.createEmptyBorder());
			this.add(label, BorderLayout.NORTH);
			this.invalidate();
			this.repaint();
			repaintNeeded = false;
		}

	}

	public double getVisWidth() {
		return component.getSize().getWidth();
	}

	public double getVisHeight() {
		return component.getSize().getHeight();
	}

	@Override
	public void paint(Graphics g) {

		super.paint(g);
		if (rect != null) {
			Graphics2D g2d = (Graphics2D) g;
			g.setColor(color);
			g2d.setStroke(stroke);
			g2d.draw(rect);
		}
	}

	public Rectangle2D getRect() {
		return rect;
	}

	public void setRect() {
		Rectangle2D rect2 = parentScroll.getViewRect();
		double s = getScale();
		double x = s * Math.max(0, rect2.getX());
		double y = s * Math.max(0, rect2.getY());
		double w = s * Math.min(rect2.getWidth(), getVisWidth());
		double h = s * Math.min(rect2.getHeight(), getVisHeight());
		this.rect = new Rectangle2D.Double(x, y, w, h);
	}

	public synchronized void mouseDragged(MouseEvent evt) {
		if (SwingUtilities.isLeftMouseButton(evt)) {
			// a is the point in the graph where I dragged to
			if (pressPoint == null) {
				// I didn't start dragging inside rectangle.
				return;
			}
			double offsetX = pressPoint.getX() - rect.getX();
			double offsetY = pressPoint.getY() - rect.getY();
			pressPoint = evt.getPoint();
			double x = pressPoint.getX() - offsetX;
			double maxX = getWidth() - rect.getWidth();
			if (x > maxX) {
				x = maxX;
			}
			if (x < 0) {
				x = 0;
			}
			double maxY = getHeight() - rect.getHeight();
			double y = pressPoint.getY() - offsetY;
			if (y > maxY) {
				y = maxY;
			}
			if (y < 0) {
				y = 0;
			}
			drawMain(x, y);

			rect = new Rectangle2D.Double(x, y, rect.getWidth(), rect.getHeight());
		} else if (SwingUtilities.isRightMouseButton(evt)) {
			double endX = Math.max(0, Math.min(evt.getPoint().getX(), getWidth()));
			double endY = Math.max(0, Math.min(evt.getPoint().getY(), getHeight()));

			if (startDragPoint != null) {

				double startX = startDragPoint.getX();
				double startY = startDragPoint.getY();

				double r = ((double) parentScroll.getHeight() / (double) parentScroll.getWidth());
				double w = Math.abs(endX - startX);
				double h = w * r;

				if ((endX >= startX) && (endY >= startY)) {
					if (startY + h > getHeight()) {
						h = getHeight() - startY;
						w = h / r;
					}
					rect = new Rectangle2D.Double(startX, startY, w, h);
				} else if ((endX >= startX) && (endY < startY)) {
					if (startY - h < 0) {
						h = startY;
						w = h / r;
					}
					rect = new Rectangle2D.Double(startX, startY - h, w, h);
				} else if ((endX < startX) && (endY >= startY)) {
					if (startY + h > getHeight()) {
						h = getHeight() - startY;
						w = h / r;
					}
					rect = new Rectangle2D.Double(startX - w, startY, w, h);
				} else {
					if (startY - h < 0) {
						h = startY;
						w = h / r;
					}
					rect = new Rectangle2D.Double(startX - w, startY - h, w, h);
				}
			}
		}
		repaint();
	}

	private Point2D pressPoint = null;
	private Point startDragPoint;
	private Rectangle2D lastRect;
	private boolean repaintNeeded = true;

	public void mouseClicked(MouseEvent e) {
	}

	public void mouseEntered(MouseEvent e) {
	}

	public void mouseExited(MouseEvent e) {
	}

	public void mouseMoved(MouseEvent e) {
	}

	public synchronized void mousePressed(MouseEvent e) {
		// store the point where I clicked the mouse
		if (rect != null) {
			if (SwingUtilities.isLeftMouseButton(e)) {
				pressPoint = null;
				Point2D a = e.getPoint();
				if (rect.contains(a)) {
					pressPoint = a;
				}
				stroke = DEFAULTSTROKE;
				color = Color.BLUE;
			} else if (SwingUtilities.isRightMouseButton(e)) {
				pressPoint = null;
				startDragPoint = null;
				Rectangle2D visRect = new Rectangle2D.Double(0, 0, getWidth(), getHeight());
				if (visRect.contains(e.getPoint())) {
					startDragPoint = e.getPoint();
					lastRect = rect;
					rect = null;
					stroke = new BasicStroke(2.0f, BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER, 10.0f,
							new float[] { 5.0f }, 0.0f);
					color = Color.BLUE;
					repaint();
				}
			}
		}
	}

	public synchronized void mouseReleased(MouseEvent e) {
		if (SwingUtilities.isRightMouseButton(e)) {
			stroke = DEFAULTSTROKE;
			color = Color.BLUE;
			if (rect == null || lastRect == null) {
				return;
			}

			double f = getScale();

			double w = Math.max(parentScroll.getExtentSize().getWidth() * f, lastRect.getWidth()) / lastRect.getWidth();
			double h = Math.max(parentScroll.getExtentSize().getHeight() * f, lastRect.getHeight())
					/ lastRect.getHeight();

			double scaleFactor = rect.getWidth() / lastRect.getWidth() / w;
			scaleFactor = Math.max(scaleFactor, rect.getHeight() / lastRect.getHeight() / h);
			double x = rect.getX();
			double y = rect.getY();

			panel.setScale(panel.getScale() / scaleFactor);

			drawMain(x, y);
			setRect();

		}
	}

	public void drawMain(double x, double y) {
		// The point I have now should be translated back
		// to a point in the main graph.

		double f = getScale();
		int xPos = (int) Math.ceil(x / f);
		int yPos = (int) Math.ceil(y / f);

		if (!panel.getVerticalScrollBar().isShowing()) {
			xPos = xPos - panel.getVerticalScrollBar().getWidth();
			xPos = Math.max(xPos, 0);
		}
		if (!panel.getHorizontalScrollBar().isShowing()) {
			yPos = yPos - panel.getHorizontalScrollBar().getHeight();
			yPos = Math.max(yPos, 0);
		}

		parentScroll.setViewPosition(new Point(xPos, yPos));

	}

	public double getScale() {
		Dimension size = component.getPreferredSize();

		double rx = (double) getWidth() / (double) size.width;
		double ry = (double) getHeight() / (double) size.height;
		double r = Math.min(rx, ry);
		return r;
	}

	public void setScalableComponent(ScalableComponent scalable) {
		this.scalable = scalable;
		this.component = scalable.getComponent();
	}

	public void setParent(ScalableViewPanel parent) {

	}

	public JComponent getComponent() {
		return this;
	}

	public int getPosition() {
		return SwingConstants.NORTH;
	}

	public String getPanelName() {
		return ""PIP"";
	}

	public void updated() {
		repaintNeeded = true;
	}

	public double getHeightInView() {
		Dimension size = component.getPreferredSize();
		double ratio = (size.getWidth() / size.getHeight());
		if (ratio > 1) {
			// wider than heigh, so height depends on width
			return PIPSIZE / ratio;
		}
		return PIPSIZE;
	}

	public double getWidthInView() {
		Dimension size = component.getPreferredSize();
		double ratio = (size.getWidth() / size.getHeight());
		if (ratio < 1) {
			// heigher than wide, so width depends on height
			return PIPSIZE / ratio;
		}
		return PIPSIZE;
	}

	public void willChangeVisibility(boolean to) {
		if (repaintNeeded) {
			initializeImage();
		}
		setRect();
	}

	public void setSize(int width, int height) {
		Dimension oldSize = getSize();
		super.setSize(width, height);
		if (!getSize().equals(oldSize)) {
			repaintNeeded = true;
		}
	}

}
"
ViewInteractionPanel.java,widget,"package org.processmining.framework.util.ui.scalableview.interaction;

import javax.swing.JComponent;

import org.processmining.framework.util.ui.scalableview.ScalableComponent;
import org.processmining.framework.util.ui.scalableview.ScalableComponent.UpdateListener;
import org.processmining.framework.util.ui.scalableview.ScalableViewPanel;

/**
 * This interaction panel is used in the ProMScalableView. It is interacting
 * with the view.
 * 
 * 
 * @author bfvdonge
 * 
 */
public interface ViewInteractionPanel extends UpdateListener {

	/**
	 * Returns the name of the panel. This name is shown in the user interface
	 * when the component is not shown.
	 * 
	 * @return
	 */
	public String getPanelName();

	/**
	 * Returns the component that is shown if this panel is activated by the
	 * user.
	 * 
	 * Most implementations will actually override JComponent and return
	 * <code>this</code> in this method.
	 * 
	 * @return a component
	 */
	public JComponent getComponent();

	/**
	 * This method is called by the ProM scalable view as soon as the panel is
	 * added to this view. The scalable provided can be used for interaction.
	 */
	public void setScalableComponent(ScalableComponent scalable);

	/**
	 * This method is called by the ProM scalable view as soon as the panel is
	 * added to this view. The scalable provided can be used for interaction.
	 * 
	 * @param viewPanel
	 */
	public void setParent(ScalableViewPanel viewPanel);

	/**
	 * Returns the preferred height of this component when shown to the user. A
	 * value between 0 and 1 (including 1) indicates a requested height relative
	 * to the height of the screen.
	 * 
	 * A value greater than 1 indicates a fixed height in pixels .
	 * 
	 * @return
	 */
	public double getHeightInView();

	/**
	 * Returns the preferred width of this component when shown to the user. A
	 * value between 0 and 1 (including 1) indicates a requested width relative
	 * to the width of the screen.
	 * 
	 * A value greater than 1 indicates a fixed width in pixels.
	 * 
	 * @return
	 */
	public double getWidthInView();

	/**
	 * This method is called by the ProMScalableView panel just before the
	 * component of this interaction panel will be shown to the user or hidden
	 * from the user.
	 * 
	 * The height and width of the component are set to what is requested by
	 * getHeightInView() and getWidthInView();
	 * 
	 * @param to
	 *            TODO
	 * 
	 */
	public void willChangeVisibility(boolean to);
}
"
ZoomInteractionPanel.java,widget,"package org.processmining.framework.util.ui.scalableview.interaction;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

import javax.swing.JButton;
import javax.swing.JComponent;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JSlider;
import javax.swing.SwingConstants;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;

import org.processmining.framework.util.ui.scalableview.ScalableComponent;
import org.processmining.framework.util.ui.scalableview.ScalableViewPanel;

import com.fluxicon.slickerbox.factory.SlickerFactory;

public class ZoomInteractionPanel extends JPanel implements ViewInteractionPanel {

	/**
	 * 
	 */
	private static final long serialVersionUID = 8415559591750873766L;
	private final JSlider slider;
	private JLabel sliderMinValue, sliderMaxValue;
	JButton sliderFitValue;
	JLabel sliderValue;

	protected int fitZoom;
	protected ScalableComponent scalable;
	protected final ScalableViewPanel panel;
	protected boolean recalculateFit = true;

	public ZoomInteractionPanel(ScalableViewPanel panel, int maximumZoom) {

		super(null);
		this.panel = panel;

		this.slider = SlickerFactory.instance().createSlider(1);

		this.slider.setMinimum(1);
		this.slider.setMaximum(maximumZoom);
		this.slider.setValue(fitZoom);

		this.slider.addChangeListener(new ChangeListener() {
			public void stateChanged(ChangeEvent e) {
				update();
			}
		});

		this.sliderMinValue = SlickerFactory.instance().createLabel(""0%"");
		this.sliderMaxValue = SlickerFactory.instance().createLabel(maximumZoom + ""%"");
		this.sliderFitValue = SlickerFactory.instance().createButton(""Fit >"");
		this.sliderFitValue.addActionListener(new ActionListener() {

			public void actionPerformed(ActionEvent e) {
				fit();
			}
		});
		this.sliderValue = SlickerFactory.instance().createLabel(fitZoom + ""%"");

		this.sliderMinValue.setHorizontalAlignment(SwingConstants.CENTER);
		this.sliderMaxValue.setHorizontalAlignment(SwingConstants.CENTER);
		this.sliderFitValue.setHorizontalAlignment(SwingConstants.RIGHT);
		this.sliderValue.setHorizontalAlignment(SwingConstants.LEFT);

		this.sliderMinValue.setFont(new java.awt.Font(""Dialog"", java.awt.Font.BOLD, 14));
		this.sliderMaxValue.setFont(new java.awt.Font(""Dialog"", java.awt.Font.BOLD, 14));
		this.sliderFitValue.setFont(new java.awt.Font(""Dialog"", java.awt.Font.BOLD, 14));
		this.sliderValue.setFont(new java.awt.Font(""Dialog"", java.awt.Font.BOLD, 14));

		this.sliderMinValue.setForeground(Color.GRAY);
		this.sliderMaxValue.setForeground(Color.GRAY);
		this.sliderFitValue.setForeground(Color.GRAY);
		this.sliderValue.setForeground(Color.DARK_GRAY);

		this.add(this.slider);
		this.add(this.sliderMinValue);
		this.add(this.sliderMaxValue);
		this.add(this.sliderFitValue);
		this.add(this.sliderValue);

		this.setBackground(Color.LIGHT_GRAY);
	}

	public void setSize(int width, int height) {
		super.setSize(width, height);
		setHeight(height);
	}

	public void setHeight(int height) {

		int sliderHeight = height - 60;

		// this.title.setBounds(0, (int) (height * 0.5) - 25, 30, 50);

		this.slider.setBounds(35, 30, 30, sliderHeight);
		this.sliderMaxValue.setBounds(0, 10, 100, 20);
		this.sliderMinValue.setBounds(0, height - 30, 100, 20);

		int value = this.slider.getValue();
		int span = this.slider.getMaximum() - this.slider.getMinimum();
		int position = 33 + (int) ((float) (this.slider.getMaximum() - this.fitZoom) / (float) span * (sliderHeight - 28));
		this.sliderFitValue.setBounds(0, position, 40, 20);

		if (value == this.fitZoom) {
			this.sliderValue.setBounds(65, position, 60, 20);
		} else {
			position = 33 + (int) ((float) (this.slider.getMaximum() - value) / (float) span * (sliderHeight - 28));
			this.sliderValue.setBounds(65, position, 60, 20);
		}
	}

	private void update() {

		int value = this.slider.getValue();

		int span = this.slider.getMaximum() - this.slider.getMinimum();
		int position = 33 + (int) ((float) (this.slider.getMaximum() - value) / (float) span * (this.slider.getBounds().height - 28));

		this.sliderValue.setText(value + ""%"");
		this.sliderValue.setBounds(65, position, 60, 20);

		scalable.setScale(getZoomValue());

	}

	public double getZoomValue() {
		return this.slider.getValue() / 100.;
	}

	public void setValue(int value) {
		this.slider.setValue(value);
	}

	public void setFitValue(int value) {

		this.fitZoom = value;

		int span = this.slider.getMaximum() - this.slider.getMinimum();
		int position = (int) (33 + Math.floor(((float) (this.slider.getMaximum() - value) / (float) span * (this.slider
				.getBounds().height - 28))));
		this.sliderFitValue.setBounds(0, position, 40, 20);
	}

	public void fit() {
		setValue(fitZoom);
	}

	public void setScalableComponent(ScalableComponent scalable) {
		this.scalable = scalable;
	}

	public void setParent(ScalableViewPanel parent) {

	}

	public JComponent getComponent() {
		return this;
	}

	public int getPosition() {
		return SwingConstants.WEST;
	}

	public String getPanelName() {
		return ""Zoom"";
	}

	public void updated() {
		recalculateFit = true;
	}

	public double getHeightInView() {
		return 0.66;
	}

	public double getWidthInView() {
		return 100;
	}

	protected void computeFitScale() {
		double scale = scalable.getScale();
		Dimension b = scalable.getComponent().getPreferredSize();
		double w = b.getWidth() / scale;
		double h = b.getHeight() / scale;
		double rx = panel.getViewport().getExtentSize().getWidth() / w;
		double ry = panel.getViewport().getExtentSize().getHeight() / h;

		setFitValue((int) (Math.min(rx, ry) * 100));
		recalculateFit = false;
	}

	public void willChangeVisibility(boolean to) {
		setValue((int) Math.floor(100 * scalable.getScale()));
		if (fitZoom <= 0 || recalculateFit) {
			computeFitScale();
		}
	}
}
"
ScalableComponent.java,widget,"package org.processmining.framework.util.ui.scalableview;

import javax.swing.JComponent;

public interface ScalableComponent {

	public static interface UpdateListener {
		/**
		 * This method should be called if the component is updated (layout,
		 * content, etc.)
		 */
		public void updated();
	}

	/**
	 * Returns the component that will be scaled using getScale and setScale
	 * methods
	 * 
	 * Most implementations will actually override JComponent and return
	 * <code>this</code> in this method.
	 * 
	 * @return a component
	 */
	public JComponent getComponent();

	/**
	 * Returns the current scale.
	 * 
	 * @return the current scale as a double
	 */
	public double getScale();

	/**
	 * Sets the current scale.
	 * <p>
	 * 
	 * @param newValue
	 *            the new scale
	 */
	public void setScale(double newScale);

	/**
	 * Adds an updatelistener to this scalable component. This listener will be
	 * updated as soon as the contents of the component change, i.e. if the
	 * component
	 * 
	 * @param listener
	 */
	public void addUpdateListener(UpdateListener listener);

	/**
	 * Removes an updatelistener from this scalable component.
	 * 
	 * @param listener
	 */
	public void removeUpdateListener(UpdateListener listener);

}
"
ScalableViewPanel.java,widget,"package org.processmining.framework.util.ui.scalableview;

import java.awt.Color;
import java.awt.Component;
import java.awt.Container;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.event.ActionListener;
import java.awt.event.ComponentEvent;
import java.awt.event.ComponentListener;
import java.awt.event.MouseEvent;
import java.awt.event.MouseMotionListener;
import java.util.HashMap;
import java.util.Map;
import java.util.Map.Entry;

import javax.swing.BorderFactory;
import javax.swing.JButton;
import javax.swing.JComponent;
import javax.swing.JLabel;
import javax.swing.JLayeredPane;
import javax.swing.JPanel;
import javax.swing.JScrollBar;
import javax.swing.JScrollPane;
import javax.swing.JSlider;
import javax.swing.JViewport;
import javax.swing.SwingConstants;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;

import org.processmining.framework.util.Cleanable;
import org.processmining.framework.util.Pair;
import org.processmining.framework.util.ui.scalableview.ScalableComponent.UpdateListener;
import org.processmining.framework.util.ui.scalableview.interaction.ViewInteractionPanel;

import com.fluxicon.slickerbox.factory.SlickerDecorator;
import com.fluxicon.slickerbox.factory.SlickerFactory;

/**
 * Panel for visualizing components.
 * 
 * @author hverbeek
 * 
 */
public class ScalableViewPanel extends JLayeredPane implements Cleanable, ChangeListener, MouseMotionListener,
		UpdateListener {

	/**
	 * 
	 */
	private static final long serialVersionUID = -7826982030435169712L;

	/**
	 * The maximal zoom factor for the primary view on the transition system.
	 */
	public static final int MAX_ZOOM = 250;

	/**
	 * The access to scalable methods of primary view
	 */
	protected final ScalableComponent scalable;

	/**
	 * The primary view
	 */
	private JComponent component;

	/**
	 * The scroll pane containing the primary view on the transition system.
	 */
	protected JScrollPane scroll;

	private ViewInteractionPanel visiblePanel = null;
	private Map<ViewInteractionPanel, Pair<JPanel, JPanel>> panels = new HashMap<ViewInteractionPanel, Pair<JPanel, JPanel>>();
	private Map<ViewInteractionPanel, Integer> locations = new HashMap<ViewInteractionPanel, Integer>();

	private JButton[] buttons = new JButton[4];

	private int north = 0, south = 0, east = 0, west = 0;

	/**
	 * The bounds for the primary view on the transition system.
	 */
	private Rectangle normalBounds;

	protected SlickerFactory factory;

	protected SlickerDecorator decorator;

	/**
	 * Create a panel for visualizing the given view.
	 * 
	 * @param scalableComponent
	 *            The given graph
	 */
	public ScalableViewPanel(final ScalableComponent scalableComponent) {
		/*
		 * We will not use a layout manager, instead we will set the bounds of
		 * every panel.
		 */
		setLayout(null);
		/*
		 * Register the given view as the primary view, and get the transition
		 * system from the model.
		 */
		this.scalable = scalableComponent;
		component = scalableComponent.getComponent();
		/*
		 * Get some Slickerbox stuff, required by the Look+Feel of some objects.
		 */
		factory = SlickerFactory.instance();
		decorator = SlickerDecorator.instance();

		/*
		 * Create the scroll panel containing the primary view, and register the
		 * created adjustment and mouse listener.
		 */
		scroll = new JScrollPane(getComponent());
		/*
		 * Adjust Look+Feel of scrollbar to Slicker.
		 */
		decorator.decorate(scroll, Color.WHITE, Color.GRAY, Color.DARK_GRAY);
		/*
		 * Create a dashed border for the primary view.
		 */
		scroll.setBorder(new DashedBorder(Color.LIGHT_GRAY));

		/*
		 * Add primary view to the layered pane. The special panels are added to
		 * the drag layer, which keeps them on top even when the underlying
		 * primary view gets updated.
		 */
		add(scroll, JLayeredPane.DEFAULT_LAYER);

		this.addMouseMotionListener(this);
		getComponent().addMouseMotionListener(this);
		scalable.addUpdateListener(this);

		/*
		 * Register a component listener to handle resize events, as the bounds
		 * of many panels depend on the size of this panel.
		 */
		this.addComponentListener(new java.awt.event.ComponentListener() {
			public void componentHidden(ComponentEvent e) {
			}

			public void componentMoved(ComponentEvent e) {
			}

			public void componentShown(ComponentEvent e) {
			}

			public void componentResized(ComponentEvent e) {
				resize();
			}
		});

		this.scroll.addComponentListener(new ComponentListener() {

			public void componentShown(ComponentEvent e) {

			}

			public void componentResized(ComponentEvent e) {
				scroll.removeComponentListener(this);
				scalable.setScale(1);
				double rx = (scroll.getWidth() - scroll.getVerticalScrollBar().getWidth())
						/ scalable.getComponent().getPreferredSize().getWidth();
				double ry = (scroll.getHeight() - scroll.getHorizontalScrollBar().getHeight())
						/ scalable.getComponent().getPreferredSize().getHeight();
				scalable.setScale(Math.min(rx, ry));
			}

			public void componentMoved(ComponentEvent e) {

			}

			public void componentHidden(ComponentEvent e) {

			}
		});

		/*
		 * Wrap up.
		 */
		initialize();
		validate();
		repaint();
	}

	public final static int TAB_HEIGHT = 30;
	public final static int TAB_WIDTH = 120;

	/**
	 * Adds the interaction panel at the given location. Location is one of
	 * SwingConstants.NORTH, SwingConstants.SOUTH, SwingConstants.EAST, or
	 * SwingConstants.WEST
	 * 
	 * @param panel
	 * @param location
	 */
	public synchronized void addViewInteractionPanel(ViewInteractionPanel panel, int location) {
		panel.setScalableComponent(scalable);
		panel.setParent(this);

		JPanel panelOn = factory.createRoundedPanel(15, Color.LIGHT_GRAY);
		JPanel panelOff = factory.createRoundedPanel(15, Color.DARK_GRAY);
		panelOn.setLayout(null);
		panelOff.setLayout(null);

		panelOn.add(panel.getComponent());
		panelOn.setVisible(false);
		panelOn.setEnabled(false);
		panelOff.setVisible(true);
		panelOff.setEnabled(true);
		JLabel panelTitle = factory.createLabel(panel.getPanelName());
		panelTitle.setHorizontalTextPosition(SwingConstants.CENTER);
		panelTitle.setVerticalTextPosition(SwingConstants.CENTER);
		panelTitle.setForeground(Color.WHITE);
		panelTitle.setFont(new java.awt.Font(""Dialog"", java.awt.Font.BOLD, 16));
		panelOff.add(panelTitle);

		panels.put(panel, new Pair<JPanel, JPanel>(panelOn, panelOff));
		locations.put(panel, location);

		switch (location) {
			case SwingConstants.NORTH : {
				panelTitle.setBounds(5, 10, TAB_WIDTH - 15, TAB_HEIGHT);
				panelOn.setLocation(TAB_HEIGHT + 10 + north * TAB_WIDTH, -10);
				panel.getComponent().setLocation(10, 20);
				panelOff.setBounds(TAB_HEIGHT + 10 + north * TAB_WIDTH, -10, TAB_WIDTH - 5, TAB_HEIGHT + 10);
				north++;
				break;
			}
			case SwingConstants.EAST : {
				panelTitle.setBounds(0, 5, TAB_HEIGHT, TAB_WIDTH - 15);
				panelTitle.setUI(new VerticalLabelUI(true));
				panelOn.setLocation(getWidth() - TAB_HEIGHT, TAB_HEIGHT + 10 + east * TAB_WIDTH);
				panelOff.setBounds(getWidth() - TAB_HEIGHT, TAB_HEIGHT + 10 + east * TAB_WIDTH, TAB_HEIGHT + 10,
						TAB_WIDTH - 5);
				panel.getComponent().setLocation(10, 10);
				east++;
				break;
			}
			case SwingConstants.WEST : {
				panelTitle.setBounds(10, 5, TAB_HEIGHT, TAB_WIDTH - 15);
				panelTitle.setUI(new VerticalLabelUI(true));
				panelOn.setLocation(-10, TAB_HEIGHT + 10 + west * TAB_WIDTH);
				panelOff.setBounds(-10, TAB_HEIGHT + 10 + west * TAB_WIDTH, TAB_HEIGHT + 10, TAB_WIDTH - 5);
				panel.getComponent().setLocation(20, 10);
				west++;
				break;
			}
			default : {
				//SOUTH
				panelTitle.setBounds(5, 0, TAB_WIDTH - 15, TAB_HEIGHT);
				panelOn.setLocation(TAB_HEIGHT + 10 + south * TAB_WIDTH, getHeight() - TAB_HEIGHT);
				panelOff.setBounds(TAB_HEIGHT + 10 + south * TAB_WIDTH, getHeight() - TAB_HEIGHT, TAB_WIDTH - 5,
						TAB_HEIGHT + 10);
				panel.getComponent().setLocation(10, 10);
				south++;

			}
		}
		setSize(panel, panelOff, panelOn);
		setLocation(panel, panelOff, panelOn);

		add(panelOn, JLayeredPane.PALETTE_LAYER);
		add(panelOff, JLayeredPane.PALETTE_LAYER);
		panel.updated();
	}

	/**
	 * Remove a previously added interaction panel from the ScalableViewPanel.
	 * 
	 * This can be used to remove an interaction panel from the
	 * ScalableViewPanel. If the interaction panel does not exist, nothing will
	 * be removed.
	 * 
	 * @param panel
	 *            The panel that should be removed.
	 */
	public synchronized void removeViewInteractionPanel(ViewInteractionPanel panel) {

		//Remove the panelOn and panelOff panels from the pane.
		Pair<JPanel, JPanel> pair = panels.remove(panel);
		if (pair != null) {
			remove(pair.getFirst());
			remove(pair.getSecond());
		}

		//Modify the position counters to account for the removed interaction panels.
		Integer location = locations.remove(panel);
		if (location != null) {

			switch (location) {
				case SwingConstants.NORTH :
					north--;
					break;
				case SwingConstants.EAST :
					east--;
					break;
				case SwingConstants.SOUTH :
					south--;
					break;
				case SwingConstants.WEST :
					west--;
					break;
				default :
					System.err.println(""Unknown interaction panel location. No position counters have been updated."");
					break;
			}
		}

		//Repaint to get rid of the old panel tab pictures.
		repaint();
	}

	/**
	 * List all registered interaction panels and their locations.
	 * 
	 * @return Map of interaction panels and their locations.
	 */
	public Map<ViewInteractionPanel, Integer> getViewInteractionPanels() {
		return new HashMap<ViewInteractionPanel, Integer>(locations);
	}

	private boolean isChild(Component c, final Component parent) {
		if (c == parent) {
			return true;
		} else if (c.getParent() == null) {
			return false;
		} else {
			return (c.getParent() == parent) || isChild(c.getParent(), parent);
		}
	}

	public synchronized void mouseMoved(MouseEvent e) {
		Point p = e.getPoint();
		if (e.getComponent() == getComponent()) {
			Point p2 = scroll.getViewport().getViewPosition();
			p.setLocation(p.getX() - p2.getX() + TAB_HEIGHT, p.getY() - p2.getY() + TAB_HEIGHT);
		}
		Component c = findComponentAt(p.x, p.y);
		if (c == null) {
			return;
		}
		if (c == this || isChild(c, getComponent())) {
			turnPanelOff();
		} else {
			// walk through the off panels
			for (Entry<ViewInteractionPanel, Pair<JPanel, JPanel>> entry : panels.entrySet()) {
				JPanel panelOn = entry.getValue().getFirst();
				JPanel panelOff = entry.getValue().getSecond();
				ViewInteractionPanel panel = entry.getKey();
				if (panelOff.getBounds().contains(p)) {
					if (panelOff == c || isParentPanel(c, panelOff)) {

						setSize(entry.getKey(), panelOff, panelOn);
						setLocation(entry.getKey(), panelOff, panelOn);
						turnPanelOff();
						panel.willChangeVisibility(true);
						panelOn.setVisible(true);
						panelOn.setEnabled(true);
						panelOff.setVisible(false);
						panelOff.setEnabled(false);
						visiblePanel = entry.getKey();
					}
				}
			}
		}
	}

	private boolean isParentPanel(Component topmost, JPanel panel) {

		Container c = topmost.getParent();
		while (c != null) {

			if (c == panel) {
				return true;
			}

			c = c.getParent();
		}

		return false;
	}

	private void turnPanelOff() {
		if (visiblePanel != null) {
			JPanel panelOn = panels.get(visiblePanel).getFirst();
			JPanel panelOff = panels.get(visiblePanel).getSecond();
			visiblePanel.willChangeVisibility(false);
			panelOn.setVisible(false);
			panelOn.setEnabled(false);
			panelOff.setVisible(true);
			panelOff.setEnabled(true);
			visiblePanel = null;
		}

	}

	public void mouseDragged(MouseEvent e) {
		// ignore!

	}

	/**
	 * Adds a button to one of the positions on the screen indicated by the
	 * location parameter. Should be SwingConstants.NORTH_EAST,
	 * SwingConstants.SOUTH_EAST SwingConstants.NORTH_WEST,
	 * SwingConstants.SOUTH_WEST
	 * 
	 * @param label
	 * @param listener
	 * @param location
	 */
	public void addButton(JLabel label, ActionListener listener, int location) {
		JButton button = factory.createButton("""");
		label.setHorizontalTextPosition(SwingConstants.CENTER);
		label.setVerticalTextPosition(SwingConstants.CENTER);
		label.setHorizontalAlignment(SwingConstants.CENTER);
		label.setVerticalAlignment(SwingConstants.CENTER);
		label.setFont(new java.awt.Font(""Dialog"", java.awt.Font.BOLD, 18));
		label.setForeground(Color.WHITE);
		label.setBorder(BorderFactory.createEmptyBorder());
		label.setOpaque(false);

		button.setLayout(null);
		button.setBorder(BorderFactory.createEmptyBorder());
		button.add(label);
		button.setToolTipText(""Reposition the graph to the origin"");
		button.addActionListener(listener);

		label.setBounds(0, 0, TAB_HEIGHT - 5, TAB_HEIGHT - 5);

		switch (location) {
			case SwingConstants.NORTH_WEST :
				button.setBounds(0, 0, TAB_HEIGHT, TAB_HEIGHT);
				buttons[0] = button;
				break;
			case SwingConstants.NORTH_EAST :
				button.setBounds(0, getWidth() - TAB_HEIGHT, TAB_HEIGHT, TAB_HEIGHT);
				buttons[1] = button;
				break;
			case SwingConstants.SOUTH_EAST :
				button.setBounds(getHeight() - TAB_HEIGHT, getWidth() - TAB_HEIGHT, TAB_HEIGHT, TAB_HEIGHT);
				buttons[2] = button;
				break;
			default :
				// SOUTH_WEST
				button.setBounds(getHeight() - TAB_HEIGHT, 0, TAB_HEIGHT, TAB_HEIGHT);
				buttons[3] = button;
		}

		this.add(button, JLayeredPane.PALETTE_LAYER);

	}

	protected void initialize() {
		// empty implementation. Can be overridden by subclasses
	}

	public void setSize(ViewInteractionPanel panel, JPanel panelOff, JPanel panelOn) {
		double w = panel.getWidthInView();
		double h = panel.getHeightInView();
		if (w > 1) {
			// fixed width
			w += 20;
		} else {
			// relative width
			w *= scroll.getWidth();
		}
		if (h > 1) {
			// fixed height
			h += 20;
		} else {
			// relative height
			h *= scroll.getHeight();
		}
		w = Math.min(w, scroll.getWidth() - 2 * TAB_HEIGHT);
		h = Math.min(h, scroll.getHeight() - 2 * TAB_HEIGHT);

		panel.getComponent().setSize((int) w, (int) h);
		panelOn.invalidate();
	}

	public void setLocation(ViewInteractionPanel panel, JPanel panelOff, JPanel panelOn) {
		int x = panelOff.getLocation().x;
		int y = panelOff.getLocation().y;
		switch (locations.get(panel)) {
			case SwingConstants.SOUTH : {
				y = panelOff.getLocation().y - panel.getComponent().getHeight() + 10;
			}
				//$FALL-THROUGH$
			case SwingConstants.NORTH : {
				panelOn.setSize(panel.getComponent().getWidth() + 20, panel.getComponent().getHeight() + TAB_HEIGHT);
				break;
			}
			case SwingConstants.EAST : {
				x = panelOff.getLocation().x - panel.getComponent().getWidth() + 10;
			}
				//$FALL-THROUGH$
			default : {
				panelOn.setSize(panel.getComponent().getWidth() + TAB_HEIGHT, panel.getComponent().getHeight() + 20);
			}
		}
		if (x + panelOn.getWidth() > getWidth()) {
			x = Math.max(TAB_HEIGHT, getWidth() - panelOn.getWidth());
		}
		if (y + panelOn.getHeight() > getHeight()) {
			y = Math.max(TAB_HEIGHT, getHeight() - panelOn.getHeight());
		}
		panelOn.setLocation(x, y);
		panelOn.invalidate();
	}

	/**
	 * Resizes the panels base don the current size of the layered pane.
	 */
	private void resize() {
		/*
		 * Get the size of the layered pane.
		 */

		for (Entry<ViewInteractionPanel, Pair<JPanel, JPanel>> entry : panels.entrySet()) {
			JPanel panelOn = entry.getValue().getFirst();
			JPanel panelOff = entry.getValue().getSecond();
			ViewInteractionPanel panel = entry.getKey();

			if (locations.get(panel) == SwingConstants.EAST) {
				//east
				panelOn.setLocation(getWidth() - TAB_HEIGHT, panelOn.getLocation().y);
				panelOff.setBounds(getWidth() - TAB_HEIGHT, panelOff.getLocation().y, TAB_HEIGHT + 10, TAB_WIDTH - 5);
			} else if (locations.get(panel) == SwingConstants.SOUTH) {
				// south
				panelOn.setLocation(panelOn.getLocation().x, getHeight() - TAB_HEIGHT);
				panelOff.setBounds(panelOff.getLocation().x, getHeight() - TAB_HEIGHT, TAB_WIDTH - 5, TAB_HEIGHT + 10);
			}
			setSize(panel, panelOff, panelOn);
			setLocation(panel, panelOff, panelOn);
		}

		for (int i = 1; i < 3; i++) {
			if (buttons[i] == null) {
				continue;
			}
			buttons[i].setLocation(i > 1 ? getHeight() - TAB_HEIGHT : 0, i < 3 ? getWidth() - TAB_HEIGHT : 0);
		}

		normalBounds = new Rectangle(TAB_HEIGHT, TAB_HEIGHT, getWidth() - 2 * TAB_HEIGHT, getHeight() - 2 * TAB_HEIGHT);
		scroll.setBounds(normalBounds);

		updated();
		//		invalidate();

	}

	public JScrollBar getHorizontalScrollBar() {
		return scroll.getHorizontalScrollBar();
	}

	public JScrollBar getVerticalScrollBar() {
		return scroll.getVerticalScrollBar();
	}

	/**
	 * Returns the zoom factor of the primary view.
	 * 
	 * @return The zoom factor of the primary view.
	 */
	public double getScale() {
		return scalable.getScale();
	}

	/**
	 * Sets the zoom factor of the primary view to the given factor.
	 * 
	 * @param d
	 *            The given factor.
	 */
	public void setScale(double d) {
		double b = Math.max(d, 0.01);
		b = Math.min(b, MAX_ZOOM / 100.);
		scalable.setScale(b);
	}

	/**
	 * Clean up.
	 */
	public void cleanUp() {
		/*
		 * Clean up both views.
		 */
		if (getComponent() instanceof Cleanable) {
			((Cleanable) getComponent()).cleanUp();
		}
		scalable.removeUpdateListener(this);
		getComponent().removeMouseMotionListener(this);
	}

	/**
	 * Deals with change events.
	 */
	public void stateChanged(ChangeEvent e) {
		Object source = e.getSource();
		if (source instanceof JSlider) {
			/*
			 * Slider has been changed. Determine and set new zoom factor.
			 */
			scalable.setScale(((JSlider) source).getValue() / 100.0);
			getComponent().repaint();
			/*
			 * Update secondary view accordingly.
			 */
		}
	}

	/**
	 * Deals with garbage collection.
	 */
	@Override
	public void finalize() throws Throwable {
		try {
			/*
			 * We can now clean up.
			 */
			cleanUp();
		} finally {
			super.finalize();
		}
	}

	public void updated() {
		JComponent newComponent = scalable.getComponent();
		if (newComponent != getComponent()) {
			scroll.setViewportView(newComponent);
			if (getComponent() instanceof Cleanable) {
				((Cleanable) getComponent()).cleanUp();
			}
			getComponent().removeMouseMotionListener(this);

			component = newComponent;
			getComponent().addMouseMotionListener(this);
			invalidate();
		}
		for (ViewInteractionPanel panel : panels.keySet()) {
			// HV: Do not call setScalableComponent now, as it changes the originalAttributeMap of the scalable.
			//			panel.setScalableComponent(scalable);
			panel.updated();
		}
	}

	public JViewport getViewport() {
		return scroll.getViewport();
	}

	public void scaleToFit() {
		scalable.setScale(1);
		double rx = scroll.getViewport().getExtentSize().getWidth()
				/ scalable.getComponent().getPreferredSize().getWidth();
		double ry = scroll.getViewport().getExtentSize().getHeight()
				/ scalable.getComponent().getPreferredSize().getHeight();
		scalable.setScale(Math.min(rx, ry));
	}

	public JComponent getComponent() {
		return component;
	}

}
"
VerticalLabelUI.java,widget,"package org.processmining.framework.util.ui.scalableview;

import java.awt.Dimension;
import java.awt.FontMetrics;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Insets;
import java.awt.Rectangle;
import java.awt.geom.AffineTransform;

import javax.swing.Icon;
import javax.swing.JComponent;
import javax.swing.JLabel;
import javax.swing.plaf.basic.BasicLabelUI;

public class VerticalLabelUI extends BasicLabelUI {

	static {
		labelUI = new VerticalLabelUI(false);
	}

	protected boolean clockwise;

	public VerticalLabelUI(boolean clockwise) {
		super();
		this.clockwise = clockwise;
	}

	public Dimension getPreferredSize(JComponent c) {
		Dimension dim = super.getPreferredSize(c);
		return new Dimension(dim.height, dim.width);
	}

	private static Rectangle paintIconR = new Rectangle();
	private static Rectangle paintTextR = new Rectangle();
	private static Rectangle paintViewR = new Rectangle();
	private static Insets paintViewInsets = new Insets(0, 0, 0, 0);

	public void paint(Graphics g, JComponent c) {

		JLabel label = (JLabel) c;
		String text = label.getText();
		Icon icon = (label.isEnabled()) ? label.getIcon() : label
				.getDisabledIcon();

		if ((icon == null) && (text == null)) {
			return;
		}

		FontMetrics fm = g.getFontMetrics();
		paintViewInsets = c.getInsets(paintViewInsets);

		paintViewR.x = paintViewInsets.left;
		paintViewR.y = paintViewInsets.top;

		// Use inverted height & width
		paintViewR.height = c.getWidth()
				- (paintViewInsets.left + paintViewInsets.right);
		paintViewR.width = c.getHeight()
				- (paintViewInsets.top + paintViewInsets.bottom);

		paintIconR.x = paintIconR.y = paintIconR.width = paintIconR.height = 0;
		paintTextR.x = paintTextR.y = paintTextR.width = paintTextR.height = 0;

		String clippedText = layoutCL(label, fm, text, icon, paintViewR,
				paintIconR, paintTextR);

		Graphics2D g2 = (Graphics2D) g;
		AffineTransform tr = g2.getTransform();
		if (clockwise) {
			g2.rotate(Math.PI / 2);
			g2.translate(0, -c.getWidth());
		} else {
			g2.rotate(-Math.PI / 2);
			g2.translate(-c.getHeight(), 0);
		}

		if (icon != null) {
			icon.paintIcon(c, g, paintIconR.x, paintIconR.y);
		}

		if (text != null) {
			int textX = paintTextR.x;
			int textY = paintTextR.y + fm.getAscent();

			if (label.isEnabled()) {
				paintEnabledText(label, g, clippedText, textX, textY);
			} else {
				paintDisabledText(label, g, clippedText, textX, textY);
			}
		}

		g2.setTransform(tr);
	}
}
"
AbstractSelectionPanel.java,widget,"package org.processmining.models.util;

import java.awt.BorderLayout;
import java.awt.Color;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;

import javax.swing.BorderFactory;
import javax.swing.JComponent;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.ScrollPaneConstants;
import javax.swing.SwingConstants;

import org.processmining.framework.util.ui.scalableview.ScalableComponent;
import org.processmining.framework.util.ui.scalableview.interaction.ViewInteractionPanel;
import org.processmining.models.graphbased.AttributeMap;
import org.processmining.models.graphbased.AttributeMapOwner;
import org.processmining.models.graphbased.ViewSpecificAttributeMap;
import org.processmining.models.graphbased.directed.DirectedGraphElement;
import org.processmining.models.jgraph.ProMJGraph;

import com.fluxicon.slickerbox.factory.SlickerDecorator;
import com.fluxicon.slickerbox.factory.SlickerFactory;

public abstract class AbstractSelectionPanel<C extends JComponent> extends JPanel implements ViewInteractionPanel {

	private static final long serialVersionUID = 8436979211504873546L;
	protected ProMJGraph graph;
	protected SlickerFactory factory = SlickerFactory.instance();
	protected SlickerDecorator decorator = SlickerDecorator.instance();

	protected final String title;
	protected ViewSpecificAttributeMap originalSpecificMap;
	protected ViewSpecificAttributeMap viewSpecificMap;
	private Map<DirectedGraphElement, String> selectedNodes = new HashMap<DirectedGraphElement, String>();
	protected final JScrollPane scroll;
	protected final C component;

	public AbstractSelectionPanel(String title, C component) {
		super(new BorderLayout());
		this.title = title;
		this.scroll = new JScrollPane(component);
		this.component = component;
		this.component.setOpaque(false);

		// add the title
		JLabel panelTitle = factory.createLabel(title);
		panelTitle.setHorizontalTextPosition(SwingConstants.CENTER);
		panelTitle.setVerticalTextPosition(SwingConstants.CENTER);
		panelTitle.setForeground(Color.WHITE);
		panelTitle.setFont(new java.awt.Font(""Dialog"", java.awt.Font.BOLD, 16));
		panelTitle.setOpaque(false);
		this.add(panelTitle, BorderLayout.NORTH);
		this.setOpaque(false);

		decorator.decorate(scroll, Color.WHITE, Color.GRAY, Color.DARK_GRAY);
		scroll.getViewport().setOpaque(false);
		scroll.setOpaque(false);
		scroll.setBorder(BorderFactory.createEmptyBorder());
		scroll.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);
		scroll.getVerticalScrollBar().setOpaque(false);

		this.add(scroll, BorderLayout.CENTER);
	}

	public JComponent getComponent() {
		return this;
	}

	public void setScalableComponent(ScalableComponent scalable) {
		if (scalable instanceof ProMJGraph) {
			this.graph = (ProMJGraph) scalable;
			this.viewSpecificMap = graph.getViewSpecificAttributes();

			originalSpecificMap = new ViewSpecificAttributeMap();
			for (AttributeMapOwner o : viewSpecificMap.keySet()) {
				for (String key : viewSpecificMap.keySet(o)) {
					originalSpecificMap.putViewSpecific(o, key, viewSpecificMap.get(o, key));
				}
			}
		} else {
			throw new IllegalArgumentException(""Scalable needs to be instance of ProMJGraph"");
		}
	}

	public double getHeightInView() {
		return 140;
	}

	public double getWidthInView() {
		return 250;
	}

	protected synchronized void unselectAll(boolean signal) {
		if (viewSpecificMap == null) {
			return;
		}
		ArrayList<AttributeMapOwner> toUpdate = new ArrayList<AttributeMapOwner>(viewSpecificMap.keySet());
		for (AttributeMapOwner p : toUpdate) {
			// copy the original keys back into viewSpecific
			viewSpecificMap.clearViewSpecific(p);
			for (String key : originalSpecificMap.keySet(p)) {
				viewSpecificMap.putViewSpecific(p, key, originalSpecificMap.get(p, key));
			}
		}
		selectedNodes.clear();

		if (signal) {
			// HV: Convert toUpdate to a set of AttributeMapOwners, as otherwise the update 
			//     gets an array containing the set as only element, which it does not handle properly.
			graph.update(new HashSet<AttributeMapOwner>(toUpdate));
		}
	}

	public void willChangeVisibility(boolean to) {
		if (to) {
			// HV: Also show if the selection has become empty.
			//			if (!selectedNodes.keySet().isEmpty()) {
			selectElements(new HashMap<DirectedGraphElement, String>(selectedNodes));
			//			}
		}
	}

	protected synchronized <T extends DirectedGraphElement> void selectElements(Map<T, String> labelledSelection) {
		unselectAll(false);
		selectedNodes.putAll(labelledSelection);

		for (DirectedGraphElement p : labelledSelection.keySet()) {
			String newLabel = labelledSelection.get(p);
			String tooltip = p.getAttributeMap().get(AttributeMap.LABEL,
					viewSpecificMap.get(p, AttributeMap.LABEL, newLabel));

			// set the attributes
			viewSpecificMap.putViewSpecific(p, AttributeMap.FILLCOLOR, Color.ORANGE);
			viewSpecificMap.putViewSpecific(p, AttributeMap.LABEL, newLabel);
			viewSpecificMap.putViewSpecific(p, AttributeMap.TOOLTIP, tooltip);
			viewSpecificMap.putViewSpecific(p, AttributeMap.SHOWLABEL, !newLabel.isEmpty());
		}

		// refresh the figure

		graph.update(labelledSelection.keySet());
	}

}
"
ListSelectionPanel.java,widget,"package org.processmining.models.util;

import java.awt.Color;
import java.awt.Component;
import java.awt.FontMetrics;
import java.awt.Graphics;
import java.awt.geom.Rectangle2D;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;

import javax.swing.BorderFactory;
import javax.swing.DefaultListModel;
import javax.swing.DefaultListSelectionModel;
import javax.swing.JComponent;
import javax.swing.JLabel;
import javax.swing.JList;
import javax.swing.ListCellRenderer;
import javax.swing.ListSelectionModel;
import javax.swing.border.Border;
import javax.swing.border.CompoundBorder;
import javax.swing.event.ListSelectionEvent;
import javax.swing.event.ListSelectionListener;

import org.processmining.framework.util.HTMLToString;
import org.processmining.framework.util.Pair;
import org.processmining.framework.util.collection.MultiSet;
import org.processmining.framework.util.ui.scalableview.ScalableViewPanel;
import org.processmining.models.graphbased.directed.DirectedGraphElement;

import com.fluxicon.slickerbox.factory.SlickerDecorator;
import com.fluxicon.slickerbox.factory.SlickerFactory;

public class ListSelectionPanel extends AbstractSelectionPanel<JList> {

	private static final long serialVersionUID = -196246314805797890L;
	static final Pair<Collection<? extends DirectedGraphElement>, String> NONE = new Pair<Collection<? extends DirectedGraphElement>, String>(
			Collections.<DirectedGraphElement>emptySet(), ""None"");
	private String name;

	public ListSelectionPanel(String name, String title, boolean interactive) {
		super(title, new JList());
		this.name = name;

		ListCellRenderer renderer = new ViewListCellRenderer(interactive);
		this.component.setCellRenderer(renderer);
		this.component.setSelectionModel(new ToggleSelectionModel());

		//component.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);

		if (interactive) {
			component.addListSelectionListener(new ListSelectionListener() {

				@SuppressWarnings(""unchecked"")
				public void valueChanged(ListSelectionEvent e) {
					if (e.getValueIsAdjusting()) {
						return;
					}
					ListSelectionModel lsm = component.getSelectionModel();
					int selectedIndex = lsm.getMinSelectionIndex();
					if (selectedIndex < 0) {
						unselectAll(true);
						component.clearSelection();
						return;
					}
					Pair<Collection<? extends DirectedGraphElement>, String> pair = (Pair<Collection<? extends DirectedGraphElement>, String>) component
							.getModel().getElementAt(selectedIndex);
					Collection<? extends DirectedGraphElement> selected = pair.getFirst();

					Map<DirectedGraphElement, String> labelled = new HashMap<DirectedGraphElement, String>(selected
							.size());
					// For multisets, label with occurance count
					if (selected instanceof MultiSet) {
						for (DirectedGraphElement elt : ((MultiSet<DirectedGraphElement>) selected).baseSet()) {
							labelled.put(elt, """" + ((MultiSet<DirectedGraphElement>) selected).occurrences(elt));
						}
					} else {
						for (DirectedGraphElement elt : selected) {
							labelled.put(elt, elt.getLabel());
						}
					}
					selectElements(labelled);

				}

			});
		}

		component.setModel(new DefaultListModel());
		component.setEnabled(false);
		((DefaultListModel) component.getModel()).addElement(NONE);

	}

	public void addElementCollection(Collection<? extends DirectedGraphElement> collection) {
		if (collection instanceof HTMLToString) {
			addElementCollection(collection, ((HTMLToString) collection).toHTMLString(true));
		} else {
			addElementCollection(collection, collection.toString());
		}
	}

	public void addElementCollection(Collection<? extends DirectedGraphElement> collection, String label) {
		Pair<Collection<? extends DirectedGraphElement>, String> pair = new Pair<Collection<? extends DirectedGraphElement>, String>(
				collection, label);
		if (!component.isEnabled()) {
			((DefaultListModel) component.getModel()).removeAllElements();
			component.setEnabled(true);
		}
		if (!((DefaultListModel) component.getModel()).contains(pair)) {
			((DefaultListModel) component.getModel()).addElement(pair);
		}
	}

	public void updated() {
		// Ignore
	}

	public String getPanelName() {
		return name;
	}

	public void setParent(ScalableViewPanel viewPanel) {
		// ignore
	}

}

/**
 * This DefaultSelectionModel subclass enables SINGLE_SELECTION mode and
 * overrides setSelectionInterval so that the first selection update in a
 * gesture (like mouse press, drag, release) toggles the current selection
 * state. A ""gesture"" starts when the first update to the selection model
 * occurs, and the gesture ends when the isAdjusting ListSelectionModel property
 * is set to false.
 */
class ToggleSelectionModel extends DefaultListSelectionModel {
	private static final long serialVersionUID = -8595521046515667658L;
	boolean gestureStarted = false;

	// HV: Allow only a single selection, as only one will be shown.
	public ToggleSelectionModel() {
		super ();
		this.setSelectionMode(SINGLE_SELECTION);
	}
	
	public void setSelectionInterval(int index0, int index1) {
		if (isSelectedIndex(index0) && !gestureStarted) {
			super.removeSelectionInterval(index0, index1);
		} else {
			super.setSelectionInterval(index0, index1);
		}
		gestureStarted = true;
	}

	public void setValueIsAdjusting(boolean isAdjusting) {
		if (isAdjusting == false) {
			gestureStarted = false;
		}
	}
}

class ViewListCellRenderer implements ListCellRenderer {
	/**
	 * 
	 */
	private static final long serialVersionUID = -808355468668630456L;
	private static final CompoundBorder BORDER = BorderFactory.createCompoundBorder(BorderFactory
			.createRaisedBevelBorder(), BorderFactory.createEmptyBorder(2, 5, 2, 5));;
	private static final CompoundBorder SELBORDER = BorderFactory.createCompoundBorder(BorderFactory
			.createLoweredBevelBorder(), BorderFactory.createEmptyBorder(2, 5, 2, 5));

	private final static JLabel LABEL = SlickerFactory.instance().createLabel(""test"");
	private static final Border EMPTYBORDER = BorderFactory.createEmptyBorder(2, 5, 2, 5);
	private final boolean allowsClick;

	public ViewListCellRenderer(boolean allowsClick) {
		this.allowsClick = allowsClick;
		LABEL.setFont(new java.awt.Font(""Dialog"", java.awt.Font.BOLD, 12));

		LABEL.setBorder(EMPTYBORDER);
		LABEL.setOpaque(false);
		SlickerDecorator.instance().decorate(LABEL);
	}

	@SuppressWarnings(""unchecked"")
	public Component getListCellRendererComponent(JList component, Object value, int index, boolean isSelected,
			boolean cellHasFocus) {

		Pair<Collection<? extends DirectedGraphElement>, String> pair = (Pair<Collection<? extends DirectedGraphElement>, String>) value;
		if (pair == ListSelectionPanel.NONE) {
			LABEL.setText(""None"");
			LABEL.setForeground(Color.DARK_GRAY);
			LABEL.setBorder(EMPTYBORDER);
			return LABEL;
		}
		String label = pair.getSecond().trim();
		LABEL.setText(fitLabelToWidth(LABEL, label, component.getWidth()));
		LABEL.setToolTipText(label);
		if (allowsClick) {
			LABEL.setForeground(isSelected ? Color.WHITE : Color.BLACK);
			LABEL.setBorder(isSelected ? SELBORDER : BORDER);
		} else {
			LABEL.setBorder(EMPTYBORDER);
		}

		return LABEL;

	}

	public static String fitLabelToWidth(JComponent c, String label, int maxWidth) {
		FontMetrics metrics = c.getFontMetrics(c.getFont());
		Graphics g = c.getGraphics();
		boolean abbreviated = false;
		int width = Integer.MAX_VALUE;
		while (true) {
			if (label.length() < 2) {
				break;
			}
			String test = label;
			if (abbreviated) {
				test += ""..."";
			}
			Rectangle2D stringBounds = metrics.getStringBounds(test, g);
			width = (int) stringBounds.getWidth();
			if (width > maxWidth) {
				label = label.substring(0, label.length() - 1);
				if (!abbreviated) {
					abbreviated = true;
				}
			} else {
				break;
			}
		}
		if (abbreviated) {
			label += ""..."";
		}
		return label;
	}
}
"
ConnectionManagerHelper.java,widget,"package org.processmining.plugins.utils;

import java.util.ArrayList;
import java.util.Collection;

import org.processmining.framework.connections.Connection;
import org.processmining.framework.connections.ConnectionCannotBeObtained;
import org.processmining.framework.connections.ConnectionID;
import org.processmining.framework.connections.ConnectionManager;

/**
 * Helper methods to work in a 'safer' way with the {@link ConnectionManager} of
 * ProM.
 * 
 * @author F. Mannhardt
 * 
 */
public final class ConnectionManagerHelper {

	private ConnectionManagerHelper() {
		super();
	}

	/**
	 * Returns a collection of connections between the objects specified, such
	 * that the type of the connection is assignable from the given
	 * connectionType. Returns an empty {@link Collection} in case no connection
	 * is available. Does NOT try to automatically create a connection.
	 * 
	 * @param connectionManager
	 * @param connectionType
	 * @param objects
	 * @return
	 */
	@SuppressWarnings(""unchecked"")
	public static <T extends Connection> Collection<T> safeGetConnections(ConnectionManager connectionManager,
			Class<T> connectionType, Object... objects) {
		Collection<T> connections = new ArrayList<T>(1);
		for (ConnectionID connID : connectionManager.getConnectionIDs()) {
			try {
				Connection c = connectionManager.getConnection(connID);
				if (((connectionType == null) || connectionType.isAssignableFrom(c.getClass()))
						&& c.containsObjects(objects)) {
					connections.add((T) c);
				}
			} catch (ConnectionCannotBeObtained e) {
			}
		}
		return connections;
	}

	/**
	 * Returns the first connection between the objects specified, such that the
	 * type of the connection is assignable from the given connectionType. Throw
	 * {@link ConnectionCannotBeObtained} in case no connection is available.
	 * Does NOT try to automatically create a connection.
	 * 
	 * @param connectionManager
	 * @param connectionType
	 * @param objects
	 * @return
	 * @throws ConnectionCannotBeObtained
	 */
	@SuppressWarnings(""unchecked"")
	public static <T extends Connection> T safeGetFirstConnection(ConnectionManager connectionManager,
			Class<T> connectionType, Object... objects) throws ConnectionCannotBeObtained {
		for (ConnectionID connID : connectionManager.getConnectionIDs()) {
			Connection c = connectionManager.getConnection(connID);
			if (((connectionType == null) || connectionType.isAssignableFrom(c.getClass()))
					&& c.containsObjects(objects)) {
				return (T) c;
			}
		}
		throw new ConnectionCannotBeObtained(""Connection not found"", connectionType, objects);
	}

}
"
HammingDistance.java,widget,"package org.processmining.plugins.utils;

import java.util.Comparator;

/**
 * @author michael
 * 
 */
public class HammingDistance {
	/**
	 * @author michael
	 * 
	 * @param <T>
	 */
	public static interface Namer<T> {
		/**
		 * @param object
		 * @return
		 */
		String toString(T object);
	}

	/**
	 * @param <T>
	 * @param name
	 * @param values
	 * @return
	 */
	public static <T> T getBestMatch(final String name, final Iterable<T> values) {
		return HammingDistance.getBestMatch(name, values, new Namer<T>() {
			@Override
			public String toString(final T object) {
				if (object == null) {
					return ""<null>"";
				}
				return object.toString();
			}
		});
	}

	/**
	 * @param <T>
	 * @param name
	 * @param values
	 * @param namer
	 * @return
	 */
	public static <T> T getBestMatch(final String name, final Iterable<T> values, final Namer<T> namer) {
		return HammingDistance.getBestMatch(name, values, namer, new Comparator<T>() {
			@Override
			public int compare(final T o1, final T o2) {
				return 0;
			}
		});
	}

	/**
	 * @param <T>
	 * @param name
	 * @param values
	 * @param namer
	 * @param comparator
	 * @return
	 */
	public static <T> T getBestMatch(final String name, final Iterable<T> values, final Namer<T> namer,
			final Comparator<T> comparator) {
		int match = -1;
		T result = null;
		for (final T value : values) {
			final String newName = namer.toString(value);
			final int newMatch = HammingDistance.hammingDistance(name, newName, false);
			if (newMatch > match) {
				match = newMatch;
				result = value;
			}
			if (newMatch == match) {
				final int thisStrictMatch = HammingDistance.hammingDistance(name, newName);
				final int oldStrictMatch = HammingDistance.hammingDistance(name, namer.toString(result));
				if (thisStrictMatch > oldStrictMatch) {
					match = newMatch;
					result = value;
				}
				if (thisStrictMatch == oldStrictMatch) {
					if (comparator.compare(result, value) < 0) {
						match = newMatch;
						result = value;
					}
				}
			}
		}
		return result;
	}

	/**
	 * @param s1
	 * @param s2
	 * @return
	 */
	public static int hammingDistance(final String s1, final String s2) {
		return HammingDistance.hammingDistance(s1, s2, true);
	}

	/**
	 * @param s1
	 * @param s2
	 * @param caseSensitive
	 * @return
	 */
	public static int hammingDistance(String s1, String s2, final boolean caseSensitive) {
		if (s2.length() > s1.length()) {
			final String tmp = s1;
			s1 = s2;
			s2 = tmp;
		}
		final int[][] matrix = new int[2][s2.length() + 1];
		for (int i = 1; i < s1.length() + 1; i++) {
			for (int j = 1; j < s2.length() + 1; j++) {
				int result = Math.max(matrix[(i - 1) % 2][j], matrix[i % 2][j - 1]);
				if (s1.charAt(i - 1) == s2.charAt(j - 1) || !caseSensitive
						&& Character.toLowerCase(s1.charAt(i - 1)) == Character.toLowerCase(s2.charAt(j - 1))) {
					result = Math.max(result, matrix[(i - 1) % 2][j - 1] + 1);
				}
				matrix[i % 2][j] = result;
			}
		}
		return matrix[s1.length() % 2][s2.length()];
	}

	/**
	 * @param args
	 */
	public static void main(final String[] args) {
		HammingDistance.test(""Michael"", ""mikael"");
		HammingDistance.test(""Britney"", ""britney"");
		HammingDistance.test(""Lady Gaga"", ""ladygaga"");
	}

	/**
	 * @param s1
	 * @param s2
	 */
	public static void test(final String s1, final String s2) {
		System.out.print(""\"""" + s1 + ""\"""");
		System.out.print("" -- "");
		System.out.print(""\"""" + s2 + ""\"""");
		System.out.print("": "");
		System.out.println(HammingDistance.hammingDistance(s1, s2));
		System.out.print(""\"""" + s1 + ""\"""");
		System.out.print("" -- "");
		System.out.print(""\"""" + s2 + ""\"""");
		System.out.print("": "");
		System.out.println(HammingDistance.hammingDistance(s1, s2, false));
	}
}
"
ProvidedObjectHelper.java,widget,"package org.processmining.plugins.utils;

import java.lang.reflect.Field;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.List;

import javax.swing.SwingUtilities;

import org.deckfour.uitopia.api.model.ResourceType;
import org.deckfour.uitopia.api.model.View;
import org.deckfour.uitopia.api.model.ViewType;
import org.deckfour.uitopia.ui.UITopiaController;
import org.processmining.contexts.uitopia.UIContext;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.contexts.uitopia.model.ProMPOResource;
import org.processmining.contexts.uitopia.model.ProMResource;
import org.processmining.contexts.uitopia.model.ProMTask;
import org.processmining.framework.plugin.GlobalContext;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.providedobjects.ProvidedObjectDeletedException;
import org.processmining.framework.providedobjects.ProvidedObjectID;
import org.processmining.framework.providedobjects.ProvidedObjectManager;

/**
 * @author michael
 * @author F. Mannhardt
 * 
 */
public class ProvidedObjectHelper {
	/**
	 * Will publish object as a provided object with the class specified by
	 * clazz. If the context is a UIPluginContext and favorite is true, it will
	 * be marked as a favorite object as well. Finally, if it is marked as
	 * favorite, it will also be show and ProM will switch to the Views tab.
	 * Encapsulation is for scared little boys/girls who still believe in the
	 * invisible pink unicorn (IPU).
	 * 
	 * @param <T>
	 * @param context
	 * @param name
	 * @param object
	 * @param clazz
	 * @param favorite
	 */
	public static <T> void publish(final PluginContext context, final String name, final T object,
			final Class<? super T> clazz, final boolean favorite) {
		final ProvidedObjectID id = context.getProvidedObjectManager().createProvidedObject(name, object, clazz,
				context);
		// Do not look at the rest of this method.  Boudewijn was busy and I just decided to do what is necessary.
		// It works.  It probably breaks if somebody changes anything.  Here or elsewhere.

		if (context instanceof UIPluginContext) {
			final GlobalContext gcontext = ((UIPluginContext) context).getGlobalContext();
			if (gcontext instanceof UIContext) {
				final UIContext uicontext = (UIContext) gcontext;
				final ResourceType resType = uicontext.getResourceManager().getResourceTypeFor(clazz);
				if (resType != null) {
					ProMTask task = null;
					try {
						final Field taskField = context.getClass().getDeclaredField(""task"");
						taskField.setAccessible(true);
						task = (ProMTask) taskField.get(context);
					} catch (final Exception _) {
						// Guess it wasn't meant to be, then...
					}
					final List<Collection<ProMPOResource>> lst = Collections.emptyList();
					ProMPOResource res = new ProMPOResource(uicontext, task == null ? null : task.getAction(), resType,
							id, lst);
					res = uicontext.getResourceManager().addResource(id, res);
				}
			}
		}
		if (favorite) {
			ProvidedObjectHelper.setFavorite(context, object);
			ProvidedObjectHelper.raise(context, object);
		}
	}

	/**
	 * Show the visualizer for the provided object
	 * 
	 * @param context
	 * @param object
	 */
	public static void raise(final PluginContext context, final Object object) {
		if (context instanceof UIPluginContext) {
			final GlobalContext gcontext = ((UIPluginContext) context).getGlobalContext();
			if (gcontext instanceof UIContext) {
				final UIContext uicontext = (UIContext) gcontext;
				final ProMResource<?> res = uicontext.getResourceManager().getResourceForInstance(object);
				final List<ViewType> viewTypes = uicontext.getViewManager().getViewTypes(res);
				if (viewTypes.size() > 0) {
					final ViewType viewType = viewTypes.get(0);
					final View view = viewType.createView(res);
					uicontext.getViewManager().addView(view);
					final UITopiaController controller = uicontext.getController();
					SwingUtilities.invokeLater(new Runnable() {
						@Override
						public void run() {
							controller.getMainView().showViewsView();
							controller.getMainView().getViewsView().showFullScreen(view);
						}
					});
				}
			}
		}
	}

	/**
	 * @param context
	 * @param object
	 */
	public static void setFavorite(final PluginContext context, final Object object) {
		ProvidedObjectHelper.setFavorite(context, object, true);
	}

	/**
	 * @param context
	 * @param object
	 * @param favorite
	 */
	public static void setFavorite(final PluginContext context, final Object object, final boolean favorite) {
		if (context instanceof UIPluginContext) {
			final GlobalContext gcontext = ((UIPluginContext) context).getGlobalContext();
			if (gcontext instanceof UIContext) {
				final UIContext uicontext = (UIContext) gcontext;
				final ProMResource<?> res = uicontext.getResourceManager().getResourceForInstance(object);
				try {
					res.setFavorite(favorite);
				} catch (final Exception _) {
					// Ignore
				}
			}
		}
	}

	/**
	 * List all the provided objects of the type
	 * 
	 * @param context
	 * @param clazz
	 * @return
	 */
	@SuppressWarnings(""unchecked"")
	public static <T> Collection<T> getProvidedObjects(final PluginContext context, final Class<T> clazz) {
		Collection<T> filteredObjects = new ArrayList<>();
		ProvidedObjectManager pom = context.getProvidedObjectManager();
		List<ProvidedObjectID> allProvidedObjects = pom.getProvidedObjects();
		for (ProvidedObjectID id : allProvidedObjects) {
			try {
				Class<?> type = pom.getProvidedObjectType(id);
				if (clazz.equals(type)) {
					filteredObjects.add((T) pom.getProvidedObjectObject(id, false));
				}
			} catch (ProvidedObjectDeletedException e) {
				//Ignore
			}
		}
		return filteredObjects;
	}

	/**
	 * Rename the provided object
	 * 
	 * @param context
	 * @param obj
	 *            the object instance
	 * @param newName
	 */
	public static void changeProvidedObjectName(final PluginContext context, final Object obj, final String newName) {
		ProvidedObjectManager pom = context.getProvidedObjectManager();
		for (ProvidedObjectID id : pom.getProvidedObjects()) {
			try {
				Object providedObj = pom.getProvidedObjectObject(id, false);
				if (obj != null && obj.equals(providedObj)) {
					pom.relabelProvidedObject(id, newName);
				}
			} catch (ProvidedObjectDeletedException e) {
			}
		}
	}

	/**
	 * Returns the label of the provided object
	 * 
	 * @param context
	 * @param obj
	 * @return
	 */
	public static String getProvidedObjectLabel(final PluginContext context, Object obj) {
		ProvidedObjectManager pom = context.getProvidedObjectManager();
		for (ProvidedObjectID id : pom.getProvidedObjects()) {
			try {
				Object providedObj = pom.getProvidedObjectObject(id, false);
				if (obj != null && obj.equals(providedObj)) {
					return pom.getProvidedObjectLabel(id);
				}
			} catch (ProvidedObjectDeletedException e) {
			}
		}
		return null;
	}

}
"
AbstractSequenceDistance.java,widget,"package org.processmining.plugins.utils.sequencedistance;

import java.util.Arrays;

public abstract class AbstractSequenceDistance<T> implements SequenceDistance<T> {

	public AbstractSequenceDistance() {
		super();
	}

	public DistanceResult<T> computeAlignment(T[] a, T[] b, SequenceDistance.Equivalence<T> eq) {
		return computeAlignment(Arrays.asList(a), Arrays.asList(b), eq);
	}

	public int computeDistance(T[] a, T[] b, SequenceDistance.Equivalence<T> eq) {
		return computeDistance(Arrays.asList(a), Arrays.asList(b), eq);
	}

}"
GenericLevenshteinDistance.java,widget,"package org.processmining.plugins.utils.sequencedistance;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

/**
 * Generic Levenshtein Distance computation that also returns an ""aligned""
 * version of the two input Lists. Adapted from this post at <a href=
 * ""http://stackoverflow.com/questions/15042879/java-characters-alignment-algorithm/15043478#15043478""
 * >Stack Overflow</a>.
 * <p>
 * Please note that this class is not thread-safe.
 * 
 * @author F. Mannhardt
 * 
 * @param <T>
 *            type of the objects
 */
public final class GenericLevenshteinDistance<T> extends AbstractSequenceDistance<T> {

	private final class ResultEntryImpl implements DistanceResult.Entry<T> {

		private final T a;
		private final T b;

		public ResultEntryImpl(T a, T b) {
			this.a = a;
			this.b = b;
		}

		public T getA() {
			return a;
		}

		public T getB() {
			return b;
		}

	}

	private final int maxDistance;
	
	private int[][] matrix;
	private int[] array1;
	private int[] array2;
	
	public GenericLevenshteinDistance() {
		this(Integer.MAX_VALUE);
	}

	public GenericLevenshteinDistance(int maxDistance) {
		this(maxDistance, 30);
	}
	
	public GenericLevenshteinDistance(int maxDistance, int initialCapacity) {
		super();
		this.maxDistance = maxDistance;
		this.matrix = new int[initialCapacity][initialCapacity];
		this.array1 = new int[initialCapacity];
		this.array2 = new int[initialCapacity];
	}
	

	public final DistanceResult<T> computeAlignment(final List<T> a, final List<T> b,
			final SequenceDistance.Equivalence<T> eq) {
		
		if (a == b) {
			return new DistanceResult<T>() {

				public int getDistance() {
					return 0;
				}

				public List<DistanceResult.Entry<T>> getAlignment() {
					ArrayList<DistanceResult.Entry<T>> alignment = new ArrayList<DistanceResult.Entry<T>>(a.size());
					for (int i = 0; i < a.size(); i++) {
						alignment.add(new ResultEntryImpl(a.get(i), b.get(i)));
					}
					return alignment;
				}

			};
		}

		final int sizeA = a.size();
		final int sizeB = b.size();

		final int[][] matrix = getMatrix(sizeA + 1, sizeB + 1);

		for (int i = 0; i <= sizeA; i++) {
			matrix[i][0] = i;
		}
		for (int i = 0; i <= sizeB; i++) {
			matrix[0][i] = i;
		}

		for (int i = 1; i <= sizeA; i++) {
			for (int j = 1; j <= sizeB; j++) {
				if (eq.equals(a.get(i - 1), b.get(j - 1))) {
					matrix[i][j] = matrix[i - 1][j - 1];
				} else {
					matrix[i][j] = Math.min(matrix[i - 1][j], matrix[i][j - 1]) + 1;
				}
			}
		}

		final int distance = matrix[sizeA][sizeB];

		final List<DistanceResult.Entry<T>> result = new ArrayList<DistanceResult.Entry<T>>(Math.max(sizeA, sizeB));
		for (int i = sizeA, j = sizeB; i > 0 || j > 0;) {
			if (i > 0 && matrix[i][j] == matrix[i - 1][j] + 1) {
				result.add(new ResultEntryImpl(a.get(--i), null));
			} else if (j > 0 && matrix[i][j] == matrix[i][j - 1] + 1) {
				result.add(new ResultEntryImpl(null, b.get(--j)));
			} else if (i > 0 && j > 0 && matrix[i][j] == matrix[i - 1][j - 1]) {
				result.add(new ResultEntryImpl(a.get(--i), b.get(--j)));
			}
		}
		Collections.reverse(result);

		return new DistanceResult<T>() {

			public int getDistance() {
				return distance;
			}

			public List<DistanceResult.Entry<T>> getAlignment() {
				return result;
			}

		};
	}

	private final int[][] getMatrix(final int sizeA, final int sizeB) {
		if (matrix.length < sizeA || matrix[0].length < sizeB) {
			int newSize = Math.max(sizeA, sizeB);
			matrix = new int[newSize][newSize];
		}
		return matrix;
	}

	public final int computeDistance(List<T> a, List<T> b, SequenceDistance.Equivalence<T> eq) {
		
		if (a == b) {
			return 0;
		}
		
		int aSize = a.size() + 1;
		int bSize = b.size() + 1;

		int[] array1 = getArray1(aSize);
		int[] array2 = getArray2(aSize);

		for (int i = 0; i < aSize; i++) {
			array1[i] = i;
		}

		for (int j = 1; j < bSize; j++) {
			array2[0] = j;
			for (int i = 1; i < aSize; i++) {
				int substitution = array1[i - 1] + (eq.equals(a.get(i - 1), b.get(j - 1)) ? 0 : 1);
				int insertion = array1[i] + 1;
				int deletion = array2[i - 1] + 1;
				array2[i] = Math.min(Math.min(insertion, deletion), substitution);
			}
			int[] temp = array1;
			array1 = array2;
			array2 = temp;
		}
		return array1[aSize - 1];
	}

	private int[] getArray1(int size) {
		if (array1.length < size) {
			array1 = new int[Math.max(size, array1.length * 2)];
		}
		return array1;
	}

	private int[] getArray2(int size) {
		if (array2.length < size) {
			array2 = new int[Math.max(size, array2.length * 2)];
		}
		return array2;
	}

}
"
SequenceDistance.java,widget,"package org.processmining.plugins.utils.sequencedistance;

import java.util.List;

public interface SequenceDistance<T> {

	public interface Equivalence<T> {

		boolean equals(T a, T b);

	}

	/**
	 * Holds the result of a sequence distance computation.
	 * 
	 * @author F. Mannhardt
	 * 
	 * @param <T>
	 */
	public interface DistanceResult<T> {

		/**
		 * A single step in the alignment of A and B. Either A or B can be
		 * <code>null</code>, if the distance function did not find a
		 * corresponding ""move"".
		 * 
		 * @author F. Mannhardt
		 * 
		 * @param <T>
		 */
		public interface Entry<T> {
			T getA();
			T getB();
		}

		/**
		 * Optional alignment of the two sequences. This may be
		 * <code>null</code>.
		 * 
		 * @return a list of {@link Entry} that represents the ""alignment"" of A
		 *         and B according to the distance function
		 */
		List<Entry<T>> getAlignment();

		/**
		 * @return the distance between A and B
		 */
		int getDistance();
	}

	/**
	 * Compute the distance and a possible alignment between two sequences. 
	 * 
	 * @param a
	 *            first sequence
	 * @param b
	 *            second sequence
	 * @param eq
	 *            equivalence relation on <code>T</code>
	 * @return a distance and optional alignment
	 */
	DistanceResult<T> computeAlignment(T[] a, T[] b, Equivalence<T> eq);

	/**
	 * Compute the distance and a possible alignment between two sequences. 
	 * 
	 * @param a
	 *            first sequence
	 * @param b
	 *            second sequence
	 * @param eq
	 *            equivalence relation on <code>T</code>
	 * @return a distance and optional alignment
	 */
	DistanceResult<T> computeAlignment(List<T> a, List<T> b, Equivalence<T> eq);

	/**
	 * Computes only the distance between two sequences.
	 * 
	 * @param a
	 *            first sequence
	 * @param b
	 *            second sequence
	 * @param eq
	 *            equivalence relation on <code>T</code>
	 * @return the distance
	 */
	int computeDistance(T[] a, T[] b, Equivalence<T> eq);
	
	/**
	 * Computes only the distance between two sequences.
	 * 
	 * @param a
	 *            first sequence
	 * @param b
	 *            second sequence
	 * @param eq
	 *            equivalence relation on <code>T</code>
	 * @return the distance
	 */
	int computeDistance(List<T> a, List<T> b, Equivalence<T> eq);

}"
BorderPanel.java,widget,"package org.processmining.framework.util.ui.widgets;

import java.awt.BasicStroke;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.RenderingHints;

import javax.swing.BorderFactory;
import javax.swing.JPanel;

/**
 * Panel which adds a border around its contents
 * 
 * @author mwesterg
 * 
 */
public class BorderPanel extends JPanel {

	/**
	 * 
	 */
	private static final long serialVersionUID = 1L;
	private final int borderWidth;

	private final int size;

	/**
	 * @param size
	 * @param borderWidth
	 */
	public BorderPanel(final int size, final int borderWidth) {
		super();
		this.size = size;
		this.borderWidth = borderWidth;
		setBorder(BorderFactory.createEmptyBorder(borderWidth, size, borderWidth, size));
	}

	@Override
	protected void paintComponent(final Graphics g) {
		final Graphics2D g2d = (Graphics2D) g.create();
		g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
		if (isOpaque()) {
			g2d.setColor(getBackground());
			g2d.fillRoundRect(1, 1, getWidth() - 3, getHeight() - 3, size * 2, size * 2);
		}
		if (borderWidth > 0) {
			g2d.setColor(getForeground());
			g2d.setStroke(new BasicStroke(borderWidth));
			g2d.drawRoundRect(borderWidth / 2, borderWidth / 2, getWidth() - borderWidth - 1, getHeight() - borderWidth
					- 1, size * 2, size * 2);
		}
	}
}
"
ColorScheme.java,widget,"package org.processmining.framework.util.ui.widgets;

import java.awt.Color;

/**
 * Some nice color schemes for visualization. Mostly taken from colorbrewer2.org
 * under Apache 2.0 license.
 * 
 * @author F. Mannhardt
 *
 */
public enum ColorScheme {

	BLACK(new Color[] { Color.BLACK }, Color.BLACK),

	COLOR_BREWER_5CLASS_SET1(new Color[] { new Color(228, 26, 28), new Color(55, 126, 184), new Color(77, 175, 74),
			new Color(152, 78, 163), new Color(255, 127, 0) }, Color.GRAY), //

	COLOR_BREWER_9CLASS_SET1(new Color[] { new Color(228, 26, 28), new Color(55, 126, 184), new Color(77, 175, 74),
			new Color(152, 78, 163), new Color(255, 127, 0), new Color(255, 255, 51), new Color(166, 86, 40),
			new Color(247, 129, 191), new Color(153, 153, 153) }, Color.LIGHT_GRAY), //

	COLOR_BREWER_9CLASS_SET21(new Color[] { new Color(141, 211, 199), new Color(255, 255, 179),
			new Color(190, 186, 218), new Color(251, 128, 114), new Color(128, 177, 211), new Color(253, 180, 98),
			new Color(179, 222, 105), new Color(252, 205, 229), new Color(217, 217, 217) }, Color.LIGHT_GRAY), //

	COLOR_BREWER_12CLASS_PAIRED(new Color[] { new Color(166, 206, 227), new Color(31, 120, 180),
			new Color(178, 223, 138), new Color(51, 160, 44), new Color(251, 154, 153), new Color(227, 26, 28),
			new Color(253, 191, 111), new Color(255, 127, 0), new Color(202, 178, 214), new Color(106, 61, 154),
			new Color(255, 255, 153), new Color(177, 89, 40) }, Color.GRAY), //
	
	SEQ_PALETTE_YlOrRd(new Color[] {
			new Color(255, 255, 229), new Color(255, 255, 204), new Color(255, 237, 160), new Color(254, 217, 118), new Color(254, 178, 76),
			new Color(253, 141, 60), new Color(252, 78, 42), new Color(227, 26, 28), new Color(189, 0, 38),
			new Color(128, 0, 38)}, Color.GRAY);

	private final Color[] scheme;
	private final Color defaultColor;

	private ColorScheme(Color[] scheme, Color defaultColor) {
		this.scheme = scheme;
		this.defaultColor = defaultColor;
	}

	public Color[] getColors() {
		return scheme;
	}

	public Color getColor(int index) {
		return getColor(index, defaultColor);
	}

	public Color getColor(int index, Color defaultColor) {
		if (index >= scheme.length) {
			return defaultColor;
		}
		return scheme[index];
	}
	
	public Color getColorFromGradient(float factor) {
		return getColorFromGradient(factor, defaultColor);
	}
	
	public Color getColorFromGradient(float factor, Color defaultColor) {
		return getColorFromGradient(factor, scheme, defaultColor);
	}

	public static Color getColorFromGradient(float factor, Color[] colorScheme, Color defaultColor) {
		if (factor >= 1.0) {
			// Special case
			return defaultColor;
		}
		float bucketSize = 1.0f / colorScheme.length;
		int maxIndex = colorScheme.length-1;
		int minIndex = 0;
		int bucket = Math.min(maxIndex, Math.max(minIndex, (int) Math.floor(factor / bucketSize)));
		return colorScheme[bucket];
	}

}"
ColorSchemeLegend.java,widget,"package org.processmining.framework.util.ui.widgets;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.geom.Line2D;
import java.awt.geom.Rectangle2D;
import java.text.MessageFormat;

import javax.swing.JComponent;

/**
 * Legend for a gradient-based color scheme.
 * 
 * @author F. Mannhardt
 *
 */
public class ColorSchemeLegend extends JComponent {

	private static final long serialVersionUID = 1L;

	private final Color[] colorPalette;
	protected final float bucketSize;

	private int textDistance = 1;
	private int tickHeight = 3;

	public ColorSchemeLegend(Color[] colorPalette) {
		super();
		this.colorPalette = colorPalette;
		this.bucketSize = 1.0f / colorPalette.length;
	}

	protected void paintComponent(Graphics g) {
		super.paintComponent(g);

		Dimension size = getSize();
		Graphics2D g2d = (Graphics2D) g;
		g2d.setFont(new Font(Font.MONOSPACED, Font.PLAIN, 10));

		double barWidth = size.getWidth() / colorPalette.length;
		double barHeight = getBarHeight(g2d, size);

		for (int i = 0; i < colorPalette.length; i++) {
			Color color = colorPalette[i];
			g2d.setColor(color);
			double currentX = i * barWidth;
			g2d.fill(new Rectangle2D.Double(currentX, 0, barWidth, barHeight));
			g2d.setColor(getForeground());
			if (i != 0) {
				g2d.setColor(Color.BLACK);
				g2d.draw(new Line2D.Double(currentX, 0, currentX, barHeight + getTickHeight()));
				drawBarDesc(g2d, barHeight, i, currentX);
			}
			drawBucketDesc(g2d, barWidth, barHeight, i);
		}
		g2d.setColor(Color.BLACK);
		drawBucketDesc(g2d, barWidth, barHeight, colorPalette.length);
		g2d.draw(new Rectangle2D.Double(0, 0, size.getWidth() - 1, getBarHeight(g2d, size)));
	}

	private void drawBarDesc(Graphics2D g2d, double barHeight, int i, double currentX) {
		String barDesc = getBarDesc(i);
		int descWidth = g2d.getFontMetrics().stringWidth(barDesc);
		g2d.drawString(barDesc, (int) Math.ceil(currentX - (descWidth / 2.0)),
				(int) Math.ceil(barHeight + getTextBaseline(g2d)));
	}

	private void drawBucketDesc(Graphics2D g2d, double barWidth, double barHeight, int i) {
		String bucketDesc = getBucketDesc(i);
		if (bucketDesc != null) {
			int descWidth = g2d.getFontMetrics().stringWidth(bucketDesc);
			g2d.drawString(bucketDesc, (int) Math.ceil((i * barWidth) - (descWidth / 2.0) - (barWidth / 2.0)),
					(int) Math.ceil(barHeight + getTextBaseline(g2d)));
		}
	}

	protected String getBarDesc(int bucket) {
		float bucketStart = bucket * bucketSize;
		return MessageFormat.format(""{0,number,#.#}"", bucketStart);
	}

	protected String getBucketDesc(int bucket) {
		return null;
	}

	private double getBarHeight(Graphics2D g2d, Dimension size) {
		return size.getHeight() - getTextBaseline(g2d);
	}

	private int getTextBaseline(Graphics2D g2d) {
		return g2d.getFontMetrics().getAscent() + textDistance;
	}

	public int getTextDistance() {
		return textDistance;
	}

	public void setTextDistance(int textDistance) {
		this.textDistance = textDistance;
	}

	public int getTickHeight() {
		return tickHeight;
	}

	public void setTickHeight(int tickHeight) {
		this.tickHeight = tickHeight;
	}
}"
HeaderRenderer.java,widget,"package org.processmining.framework.util.ui.widgets;

import java.awt.Component;
import java.awt.ComponentOrientation;

import javax.swing.BorderFactory;
import javax.swing.JTable;
import javax.swing.SwingConstants;
import javax.swing.UIManager;
import javax.swing.table.DefaultTableCellRenderer;
import javax.swing.table.JTableHeader;

/**
 * Renderer for headers for tables
 * 
 * @author mwesterg
 * 
 */
public class HeaderRenderer extends DefaultTableCellRenderer {
	/**
	 * 
	 */
	private static final long serialVersionUID = 1L;

	/**
	 * 
	 */
	public HeaderRenderer() {
		setHorizontalAlignment(SwingConstants.CENTER);
		setOpaque(true);

		// This call is needed because DefaultTableCellRenderer calls setBorder()
		// in its constructor, which is executed after updateUI()
		setBorder(BorderFactory.createEmptyBorder(0, 0, 10, 0));
	}

	/**
	 * @see javax.swing.table.DefaultTableCellRenderer#getTableCellRendererComponent(javax.swing.JTable,
	 *      java.lang.Object, boolean, boolean, int, int)
	 */
	@Override
	public Component getTableCellRendererComponent(final JTable table, final Object value, final boolean selected,
			final boolean focused, final int row, final int column) {
		final JTableHeader h = table != null ? table.getTableHeader() : null;

		if (h != null) {
			setEnabled(h.isEnabled());
			setComponentOrientation(h.getComponentOrientation());

			setForeground(h.getForeground());
			setBackground(h.getBackground());
			setFont(h.getFont());
		} else {
			/*
			 * Use sensible values instead of random leftover values from the
			 * last call
			 */
			setEnabled(true);
			setComponentOrientation(ComponentOrientation.UNKNOWN);

			setForeground(UIManager.getColor(""TableHeader.foreground""));
			setBackground(UIManager.getColor(""TableHeader.background""));
			setFont(UIManager.getFont(""TableHeader.font""));
		}

		setValue(value);

		return this;
	}

	/**
	 * @see javax.swing.table.DefaultTableCellRenderer#updateUI()
	 */
	@Override
	public void updateUI() {
		super.updateUI();
		setBorder(BorderFactory.createEmptyBorder(0, 0, 10, 0));
	}
}"
ChoiceQueryPanel.java,widget,"package org.processmining.framework.util.ui.widgets.helper;

import java.awt.Component;

import javax.swing.BoxLayout;
import javax.swing.JOptionPane;
import javax.swing.JPanel;

import org.deckfour.uitopia.api.event.TaskListener.InteractionResult;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.framework.util.ui.widgets.ProMComboBox;

class ChoiceQueryPanel<T> extends JPanel {

	private static final long serialVersionUID = -6547392010448275699L;

	private final ProMComboBox<T> choiceField;

	public ChoiceQueryPanel(Iterable<T> choices) {
		super();
		setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));
		choiceField = new ProMComboBox<>(choices);
		choiceField.setPreferredSize(null);
		add(choiceField);
	}

	public InteractionResult getUserChoice(UIPluginContext context, String query) {
		return context.showConfiguration(query, this);
	}
	
	public InteractionResult getUserChoice(Component view, String query) {
		String[] options = new String[] { ""Confirm"", ""Cancel"" };
		int result = JOptionPane.showOptionDialog(view, this, query, JOptionPane.DEFAULT_OPTION,
				JOptionPane.QUESTION_MESSAGE, null, options, options[0]);
		return result == 0 ? InteractionResult.CONTINUE : InteractionResult.CANCEL;
	}

	@SuppressWarnings(""unchecked"")
	public T getResult() {
		return (T) choiceField.getModel().getSelectedItem();
	}

}"
FixedMappingQueryPanel.java,widget,"package org.processmining.framework.util.ui.widgets.helper;

import java.awt.Component;
import java.awt.Dimension;
import java.util.HashMap;
import java.util.Map;
import java.util.Vector;

import javax.swing.BoxLayout;
import javax.swing.DefaultCellEditor;
import javax.swing.JComboBox;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.table.DefaultTableModel;

import org.deckfour.uitopia.api.event.TaskListener.InteractionResult;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.framework.util.ui.widgets.ProMTable;

import com.google.common.collect.ImmutableList;
import com.google.common.collect.UnmodifiableIterator;

class FixedMappingQueryPanel<S,T> extends JPanel {

	private static final String NO_MAPPING = ""NONE"";

	private static final long serialVersionUID = 4946819373227598703L;

	private ProMTable mappingTable;
	private ImmutableList<S> sourceList;
	private ImmutableList<T> targetList;

	@SuppressWarnings(""serial"")
	public FixedMappingQueryPanel(String text, Iterable<S> sources, Iterable<T> targets, Map<S, T> defaultValues) {
		super();
		setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));
		setBackground(null);

		sourceList = ImmutableList.copyOf(sources);
		targetList = ImmutableList.copyOf(targets);

		DefaultTableModel tableModel = new DefaultTableModel(sourceList.size(), 2) {

			public boolean isCellEditable(int row, int column) {
				if (column == 0) {
					return false;
				}
				return super.isCellEditable(row, column);
			}

		};

		mappingTable = new ProMTable(tableModel);
		mappingTable.setPreferredSize(new Dimension(600, 400));
		mappingTable.setMaximumSize(null);
		mappingTable.setMinimumSize(null);
		mappingTable.getTableHeader().getColumnModel().getColumn(0).setHeaderValue(""Source"");
		mappingTable.getTableHeader().getColumnModel().getColumn(0).setPreferredWidth(200);
		mappingTable.getTableHeader().getColumnModel().getColumn(1).setHeaderValue(""Target"");
		mappingTable.getTableHeader().getColumnModel().getColumn(1).setPreferredWidth(200);

		mappingTable.getColumnModel().getColumn(1)
				.setCellEditor(new DefaultCellEditor(new JComboBox<T>(new Vector<>(targetList))) {

					protected void fireEditingStopped() {
						this.cancelCellEditing();
						super.fireEditingStopped();
					}

					protected void fireEditingCanceled() {
						super.fireEditingCanceled();
					}

				});

		int i = 0;
		for (S source : sourceList) {
			mappingTable.getTable().getModel().setValueAt(source, i++, 0);
		}

		for (i = 0; i < sourceList.size(); i++) {
			T defaultValue = defaultValues.get(sourceList.get(i));
			if (defaultValue != null) {
				mappingTable.getTable().getModel().setValueAt(defaultValue, i, 1);
			} else {
				mappingTable.getTable().getModel().setValueAt(null, i, 1);
			}
		}

		add(mappingTable);
	}

	public InteractionResult getUserChoice(UIPluginContext context, String query) {
		return context.showConfiguration(query, this);
	}
	
	public InteractionResult getUserChoice(Component view, String query) {
		String[] options = new String[] { ""Confirm"", ""Cancel"" };
		int result = JOptionPane.showOptionDialog(view, this, query, JOptionPane.DEFAULT_OPTION,
				JOptionPane.QUESTION_MESSAGE, null, options, options[0]);
		return result == 0 ? InteractionResult.CONTINUE : InteractionResult.CANCEL;
	}

	public Map<S, T> getResult() {
		Map<S, T> result = new HashMap<>();

		int i = 0;
		UnmodifiableIterator<S> iterator = sourceList.iterator();
		while (iterator.hasNext()) {
			S source = iterator.next();
			@SuppressWarnings(""unchecked"")
			T target = (T) mappingTable.getTable().getModel().getValueAt(i++, 1);
			if (!target.equals(null)) {
				result.put(source, target);
			}
		}

		return result;
	}

}"
FreeMappingQueryPanel.java,widget,"package org.processmining.framework.util.ui.widgets.helper;

import java.awt.Component;
import java.awt.Dimension;
import java.util.HashMap;
import java.util.Map;

import javax.swing.BoxLayout;
import javax.swing.DefaultCellEditor;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JTextField;
import javax.swing.table.DefaultTableModel;

import org.deckfour.uitopia.api.event.TaskListener.InteractionResult;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.framework.util.ui.widgets.ProMTable;

import com.google.common.collect.ImmutableList;
import com.google.common.collect.UnmodifiableIterator;

class FreeMappingQueryPanel<T> extends JPanel {

	private static final String NO_MAPPING = ""NONE"";

	private static final long serialVersionUID = 4946819373227598703L;
	
	private ProMTable mappingTable;
	private ImmutableList<T> sourceList;

	@SuppressWarnings(""serial"")
	public FreeMappingQueryPanel(String text, Iterable<T> sources, Map<T, String> defaultValues) {
		super();
		setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));
		setBackground(null);

		sourceList = ImmutableList.copyOf(sources);
		
		DefaultTableModel tableModel = new DefaultTableModel(sourceList.size(), 2) {

			public boolean isCellEditable(int row, int column) {
				if (column == 0) {
					return false;
				}
				return super.isCellEditable(row, column);
			}
			
		};
		
		mappingTable = new ProMTable(tableModel);
		mappingTable.setPreferredSize(new Dimension(600, 400));
		mappingTable.setMaximumSize(null);
		mappingTable.setMinimumSize(null);
		mappingTable.getTableHeader().getColumnModel().getColumn(0).setHeaderValue(""Source"");
		mappingTable.getTableHeader().getColumnModel().getColumn(0).setPreferredWidth(200);
		mappingTable.getTableHeader().getColumnModel().getColumn(1).setHeaderValue(""Target"");
		mappingTable.getTableHeader().getColumnModel().getColumn(1).setPreferredWidth(200);
		
		mappingTable.getColumnModel().getColumn(0).setCellEditor(new DefaultCellEditor(new JTextField()) {

			protected void fireEditingStopped() {
				this.cancelCellEditing();
				super.fireEditingStopped();
			}

			protected void fireEditingCanceled() {
				super.fireEditingCanceled();
			}

		});
		

		int i = 0;
		for (T source: sourceList) {
			mappingTable.getTable().getModel().setValueAt(source, i++, 0);
		}
		
		for (i = 0; i < sourceList.size(); i++) {
			String defaultValue = defaultValues.get(sourceList.get(i));
			if (defaultValue != null) {
				mappingTable.getTable().getModel().setValueAt(defaultValue, i, 1);
			} else {
				mappingTable.getTable().getModel().setValueAt(NO_MAPPING, i, 1);	
			}			
		}
	
		add(mappingTable);
	}

	public InteractionResult getUserChoice(UIPluginContext context, String query) {
		return context.showConfiguration(query, this);
	}
	
	public InteractionResult getUserChoice(Component view, String query) {
		String[] options = new String[] { ""Confirm"", ""Cancel"" };
		int result = JOptionPane.showOptionDialog(view, this, query, JOptionPane.DEFAULT_OPTION,
				JOptionPane.QUESTION_MESSAGE, null, options, options[0]);
		return result == 0 ? InteractionResult.CONTINUE : InteractionResult.CANCEL;
	}

	public Map<T, String> getResult() {
		Map<T, String> result = new HashMap<>();
		
		int i = 0;
		UnmodifiableIterator<T> iterator = sourceList.iterator();
		while (iterator.hasNext()) {
			T source = iterator.next();
			String target = (String) mappingTable.getTable().getModel().getValueAt(i++, 1);
			if (!target.equals(NO_MAPPING)) {
				result.put(source, target);	
			}			
		}
		
		return result;
	}

}"
MultilineStringQueryPanel.java,widget,"package org.processmining.framework.util.ui.widgets.helper;

import java.awt.Component;

import javax.swing.BoxLayout;
import javax.swing.JOptionPane;
import javax.swing.JPanel;

import org.deckfour.uitopia.api.event.TaskListener.InteractionResult;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.framework.util.ui.widgets.ProMTextArea;

public class MultilineStringQueryPanel extends JPanel {

	private static final long serialVersionUID = -8701706429341608153L;
	
	private final ProMTextArea textArea;
	
	public MultilineStringQueryPanel(String text) {
		super();
		setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));
		textArea = new ProMTextArea();
		if (text != null) {
			textArea.setText(text);
		}
		textArea.setPreferredSize(null);
		add(textArea);
	}

	public MultilineStringQueryPanel() {
		this(null);
	}

	public InteractionResult getUserChoice(UIPluginContext context, String query) {
		return context.showConfiguration(query, this);
	}
	
	public InteractionResult getUserChoice(Component view, String query) {
		String[] options = new String[] { ""Confirm"", ""Cancel"" };
		int result = JOptionPane.showOptionDialog(view, this, query, JOptionPane.DEFAULT_OPTION,
				JOptionPane.QUESTION_MESSAGE, null, options, options[0]);
		return result == 0 ? InteractionResult.CONTINUE : InteractionResult.CANCEL;
	}

	public String getResult() {
		return textArea.getText();
	}

	
}
"
MultipleChoiceQueryPanel.java,widget,"package org.processmining.framework.util.ui.widgets.helper;

import java.awt.BorderLayout;
import java.awt.Component;
import java.util.List;

import javax.swing.DefaultListModel;
import javax.swing.JOptionPane;
import javax.swing.JPanel;

import org.deckfour.uitopia.api.event.TaskListener.InteractionResult;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.framework.util.ui.widgets.ProMList;

class MultipleChoiceQueryPanel<T> extends JPanel {

	private static final long serialVersionUID = -6547392010448275699L;

	private final ProMList<T> choiceField;

	public MultipleChoiceQueryPanel(String title, Iterable<T> choices) {
		super(new BorderLayout());
		DefaultListModel<T> listModel = new DefaultListModel<>();
		for (T c : choices) {
			listModel.addElement(c);
		}
		choiceField = new ProMList<>(title, listModel);
		choiceField.setPreferredSize(null);
		add(choiceField, BorderLayout.CENTER);
	}

	public InteractionResult getUserChoice(UIPluginContext context, String query) {
		return context.showConfiguration(query, this);
	}

	public List<T> getResult() {
		return choiceField.getSelectedValuesList();
	}

	public InteractionResult getUserChoice(Component view, String query) {
		String[] options = new String[]{ ""Confirm"", ""Cancel"" };
		int result = JOptionPane.showOptionDialog(view, this, query, JOptionPane.DEFAULT_OPTION,
				JOptionPane.QUESTION_MESSAGE, null, options, options[0]);
		return result == 0 ? InteractionResult.CONTINUE : InteractionResult.CANCEL;  
	}

}"
ProMUIHelper.java,widget,"package org.processmining.framework.util.ui.widgets.helper;

import java.awt.Component;
import java.awt.Dimension;
import java.util.Arrays;
import java.util.List;
import java.util.Map;

import javax.swing.JComponent;
import javax.swing.JOptionPane;
import javax.swing.JScrollPane;
import javax.swing.JTextArea;

import org.deckfour.uitopia.api.event.TaskListener.InteractionResult;
import org.processmining.contexts.uitopia.UIPluginContext;

import com.google.common.base.Throwables;
import com.google.common.collect.ImmutableMap;

/**
 * Commonly used functionality for the ProM UI as static helper methods. All
 * methods throw {@link UserCancelledException} when the user presses the cancel
 * button.
 * 
 * @author F. Mannhardt
 * 
 */
public class ProMUIHelper {

	/******************* ERROR / WARNING / INFO MESSAGES *****************/

	/**
	 * Displays an error message in a 'modal' pop-up using the global UI as
	 * parent JFrame.
	 * 
	 * @param context
	 * @param errorMessage
	 * @param errorTitle
	 */
	public static void showErrorMessage(UIPluginContext context, String errorMessage, String errorTitle) {
		Object[] options = { ""OK"" };

		JOptionPane.showOptionDialog(context.getGlobalContext().getUI(), createMessageBody(errorMessage), errorTitle,
				JOptionPane.PLAIN_MESSAGE, JOptionPane.ERROR_MESSAGE, null, options, options[0]);
	}

	/**
	 * Displays an error message in a 'modal' pop-up using a default JFrame.
	 * 
	 * @param errorMessage
	 * @param errorTitle
	 */
	public static void showErrorMessage(String errorMessage, String errorTitle) {
		Object[] options = { ""OK"" };
		JOptionPane.showOptionDialog(null, createMessageBody(errorMessage), errorTitle, JOptionPane.PLAIN_MESSAGE,
				JOptionPane.ERROR_MESSAGE, null, options, options[0]);
	}

	/**
	 * Displays an error message in a 'modal' pop-up using the specified
	 * Component as parent.
	 * 
	 * @param component
	 * @param errorMessage
	 * @param errorTitle
	 */
	public static void showErrorMessage(Component component, String errorMessage, String errorTitle) {
		Object[] options = { ""OK"" };
		JOptionPane.showOptionDialog(component, createMessageBody(errorMessage), errorTitle, JOptionPane.PLAIN_MESSAGE,
				JOptionPane.ERROR_MESSAGE, null, options, options[0]);
	}

	public static void showErrorMessage(Component component, String errorMessage, String errorTitle, Throwable e) {
		Object[] options = { ""OK"", ""Show Debug Information"" };
		int result = JOptionPane.showOptionDialog(component, createMessageBody(errorMessage), errorTitle,
				JOptionPane.PLAIN_MESSAGE, JOptionPane.ERROR_MESSAGE, null, options, options[0]);
		if (result == 1) {
			String[] optionsStacktrace = new String[] { ""OK"" };
			JOptionPane.showOptionDialog(component, createMessageBody(Throwables.getStackTraceAsString(e)),
					""Debug Information: "" + errorTitle, JOptionPane.PLAIN_MESSAGE, JOptionPane.ERROR_MESSAGE, null,
					optionsStacktrace, optionsStacktrace[0]);
		}
	}

	/**
	 * Displays an warning message in a 'modal' pop-up using the global UI as
	 * parent JFrame.
	 * 
	 * @param context
	 * @param warnMessage
	 * @param warnTitle
	 */
	public static void showWarningMessage(UIPluginContext context, String warnMessage, String warnTitle) {
		Object[] options = { ""OK"" };
		JOptionPane.showOptionDialog(context.getGlobalContext().getUI(), createMessageBody(warnMessage), warnTitle,
				JOptionPane.PLAIN_MESSAGE, JOptionPane.WARNING_MESSAGE, null, options, options[0]);
	}

	/**
	 * Displays an warning message in a 'modal' pop-up using a default JFrame.
	 * 
	 * @param warnMessage
	 * @param warnTitle
	 */
	public static void showWarningMessage(String warnMessage, String warnTitle) {
		Object[] options = { ""OK"" };
		JOptionPane.showOptionDialog(null, createMessageBody(warnMessage), warnTitle, JOptionPane.PLAIN_MESSAGE,
				JOptionPane.WARNING_MESSAGE, null, options, options[0]);
	}

	/**
	 * Displays an warning message in a 'modal' pop-up using using the specified
	 * Component as parent.
	 * 
	 * @param component
	 * @param warnMessage
	 * @param warnTitle
	 */
	public static void showWarningMessage(Component component, String warnMessage, String warnTitle) {
		Object[] options = { ""OK"" };
		JOptionPane.showOptionDialog(component, createMessageBody(warnMessage), warnTitle, JOptionPane.PLAIN_MESSAGE,
				JOptionPane.WARNING_MESSAGE, null, options, options[0]);
	}

	private static JComponent createMessageBody(String message) {
		JTextArea errorBody = new JTextArea(message);
		errorBody.setWrapStyleWord(true);
		errorBody.setLineWrap(true);
		return new JScrollPane(errorBody) {

			private static final long serialVersionUID = 1L;

			public Dimension getPreferredSize() {
				return new Dimension(480, 320);
			}

		};
	}

	/******************* QUERY DIALOGS *****************/

	/**
	 * Displays a configuration dialog asking the user to enter a String
	 * literal.
	 * 
	 * @param context
	 * @param queryCaption
	 * @return
	 * @throws UserCancelledException
	 */
	public static String queryForString(UIPluginContext context, String queryCaption) throws UserCancelledException {
		return queryForString(context, queryCaption, null, null);
	}
	
	public static String queryForString(Component view, String queryCaption) throws UserCancelledException {
		return queryForString(view, queryCaption, null, null);
	}

	/**
	 * Displays a configuration dialog asking the user to enter a String literal
	 * 
	 * @param context
	 * @param queryCaption
	 * @param queryText
	 * @return
	 * @throws UserCancelledException
	 */
	public static String queryForString(UIPluginContext context, String queryCaption, String queryText)
			throws UserCancelledException {
		return queryForString(context, queryCaption, queryText, null);
	}
	
	public static String queryForString(Component view, String queryCaption, String queryText)
			throws UserCancelledException {
		return queryForString(view, queryCaption, queryText, null);
	}

	/**
	 * Displays a configuration dialog asking the user to enter a String literal
	 * 
	 * @param context
	 * @param queryCaption
	 * @param queryText
	 * @param defaultValue
	 * @return
	 * @throws UserCancelledException
	 */
	public static String queryForString(UIPluginContext context, String queryCaption, String queryText,
			String defaultValue) throws UserCancelledException {
		StringQueryPanel queryPanel = new StringQueryPanel(queryText, defaultValue);
		InteractionResult choice = queryPanel.getUserChoice(context, queryCaption);
		if (choice == InteractionResult.FINISHED || choice == InteractionResult.CONTINUE) {
			return queryPanel.getResult();
		} else {
			throw new UserCancelledException();
		}
	}
	
	public static String queryForString(Component view, String queryCaption, String queryText,
			String defaultValue) throws UserCancelledException {
		StringQueryPanel queryPanel = new StringQueryPanel(queryText, defaultValue);
		InteractionResult choice = queryPanel.getUserChoice(view, queryCaption);
		if (choice == InteractionResult.FINISHED || choice == InteractionResult.CONTINUE) {
			return queryPanel.getResult();
		} else {
			throw new UserCancelledException();
		}
	}

	/**
	 * Displays a configuration dialog asking the user to enter a Integer, uses
	 * {@link Integer#parseInt(String)} to convert the user input.
	 * 
	 * @param context
	 * @param query
	 * @return
	 * @throws NumberFormatException
	 * @throws UserCancelledException
	 */
	public static int queryForInteger(UIPluginContext context, String query)
			throws NumberFormatException, UserCancelledException {
		return Integer.parseInt(queryForString(context, query));
	}
	
	public static int queryForInteger(Component view, String query)
			throws NumberFormatException, UserCancelledException {
		return Integer.parseInt(queryForString(view, query));
	}

	/**
	 * Displays a configuration dialog asking the user to enter a Float, uses
	 * {@link Float#parseFloat(String)} to convert the user input.
	 * 
	 * @param context
	 * @param query
	 * @return
	 * @throws NumberFormatException
	 * @throws UserCancelledException
	 */
	public static float queryForFloat(UIPluginContext context, String query)
			throws NumberFormatException, UserCancelledException {
		return Float.parseFloat(queryForString(context, query));
	}
	
	public static float queryForFloat(Component view, String query)
			throws NumberFormatException, UserCancelledException {
		return Float.parseFloat(queryForString(view, query));
	}

	/**
	 * Displays a configuration dialog asking the user to enter a Double, uses
	 * {@link Double#parseDouble(String)} to convert the user input.
	 * 
	 * @param context
	 * @param query
	 * @return
	 * @throws NumberFormatException
	 * @throws UserCancelledException
	 */
	public static double queryForDouble(UIPluginContext context, String query)
			throws NumberFormatException, UserCancelledException {
		return Double.parseDouble(queryForString(context, query));
	}
	
	public static double queryForDouble(Component view, String query)
			throws NumberFormatException, UserCancelledException {
		return Double.parseDouble(queryForString(view, query));
	}

	/**
	 * Displays a configuration dialog asking the user to select a double value
	 * between 0.0 and 1.0 (both inclusive). The default value is 1.0.
	 * 
	 * @param context
	 * @param query
	 * @return
	 * @throws NumberFormatException
	 * @throws UserCancelledException
	 */
	public static double queryForDoubleZeroOne(UIPluginContext context, String query) throws UserCancelledException {
		return queryForDouble(context, query, 0.0d, 1.0d, 1.0d);
	}
	
	public static double queryForDoubleZeroOne(Component view, String query) throws UserCancelledException {
		return queryForDouble(view, query, 0.0d, 1.0d, 1.0d);
	}

	/**
	 * Displays a configuration dialog asking the user to select a double value.
	 * 
	 * @param context
	 * @param query
	 * @return
	 * @throws UserCancelledException
	 */
	public static double queryForDouble(UIPluginContext context, String query, double min, double max,
			double defaultValue) throws UserCancelledException {
		SliderQueryPanel queryPanel = new SliderQueryPanel(query, min, max, defaultValue);
		InteractionResult choice = queryPanel.getUserChoice(context, query);
		if (choice == InteractionResult.FINISHED || choice == InteractionResult.CONTINUE) {
			return queryPanel.getResult();
		} else {
			throw new UserCancelledException();
		}
	}
	
	public static double queryForDouble(Component view, String query, double min, double max,
			double defaultValue) throws UserCancelledException {
		SliderQueryPanel queryPanel = new SliderQueryPanel(query, min, max, defaultValue);
		InteractionResult choice = queryPanel.getUserChoice(view, query);
		if (choice == InteractionResult.FINISHED || choice == InteractionResult.CONTINUE) {
			return queryPanel.getResult();
		} else {
			throw new UserCancelledException();
		}
	}

	/**
	 * Shows a dialog asking the user to enter an ordered list of integers
	 * separated by comma.
	 * 
	 * @param context
	 * @param query
	 * @return
	 * @throws NumberFormatException
	 * @throws UserCancelledException
	 */
	public static int[] queryForIntArray(UIPluginContext context, String query)
			throws NumberFormatException, UserCancelledException {
		String result = queryForString(context, query);
		if (result != null && result.length() > 0) {
			String[] traceIndexArray = result.split("","");
			int[] traceIndexSet = new int[traceIndexArray.length];
			for (int i = 0; i < traceIndexArray.length; i++) {
				String singleTraceIndex = traceIndexArray[i];
				traceIndexSet[i] = Integer.parseInt(singleTraceIndex);
			}
			return traceIndexSet;
		} else {
			throw new NumberFormatException(""Invalid format, should be comma separated integers!"");
		}
	}

	/**
	 * Shows a dialog with a combo box containing the choices, and returns the
	 * selected value.
	 * 
	 * @param context
	 * @param query
	 * @param choices
	 * @return
	 * @throws UserCancelledException
	 */
	public static <T> T queryForObject(UIPluginContext context, String query, T[] choices)
			throws UserCancelledException {
		return queryForObject(context, query, Arrays.asList(choices));
	}
	
	public static <T> T queryForObject(Component view, String query, T[] choices)
			throws UserCancelledException {
		return queryForObject(view, query, Arrays.asList(choices));
	}

	/**
	 * 
	 * Shows a dialog with a combo box containing the choices, and returns the
	 * selected value.
	 * 
	 * @param context
	 * @param query
	 * @param choices
	 * @return
	 * @throws UserCancelledException
	 */
	public static <T> T queryForObject(UIPluginContext context, String query, Iterable<T> choices)
			throws UserCancelledException {
		ChoiceQueryPanel<T> queryPanel = new ChoiceQueryPanel<>(choices);
		InteractionResult choice = queryPanel.getUserChoice(context, query);
		if (choice == InteractionResult.FINISHED || choice == InteractionResult.CONTINUE) {
			return queryPanel.getResult();
		} else {
			throw new UserCancelledException();
		}
	}
	
	public static <T> T queryForObject(Component view, String query, Iterable<T> choices)
			throws UserCancelledException {
		ChoiceQueryPanel<T> queryPanel = new ChoiceQueryPanel<>(choices);
		InteractionResult choice = queryPanel.getUserChoice(view, query);
		if (choice == InteractionResult.FINISHED || choice == InteractionResult.CONTINUE) {
			return queryPanel.getResult();
		} else {
			throw new UserCancelledException();
		}
	}

	/**
	 * Shows a dialog with a combo box containing the choices, and returns the
	 * selected value.
	 * 
	 * @param context
	 * @param query
	 * @param choices
	 * @return
	 * @throws UserCancelledException
	 */
	public static String queryForString(UIPluginContext context, String query, String[] choices)
			throws UserCancelledException {
		return queryForString(context, query, Arrays.asList(choices));
	}
	
	public static String queryForString(Component view, String query, String[] choices)
			throws UserCancelledException {
		return queryForString(view, query, Arrays.asList(choices));
	}

	/**
	 * Shows a dialog with a combo box containing the choices, and returns the
	 * selected value.
	 * 
	 * @param context
	 * @param query
	 * @param choices
	 * @return
	 * @throws UserCancelledException
	 */
	public static String queryForString(UIPluginContext context, String query, Iterable<String> choices)
			throws UserCancelledException {
		ChoiceQueryPanel<String> queryPanel = new ChoiceQueryPanel<>(choices);
		InteractionResult choice = queryPanel.getUserChoice(context, query);
		if (choice == InteractionResult.FINISHED || choice == InteractionResult.CONTINUE) {
			return queryPanel.getResult();
		} else {
			throw new UserCancelledException();
		}
	}
	
	public static String queryForString(Component view, String query, Iterable<String> choices)
			throws UserCancelledException {
		ChoiceQueryPanel<String> queryPanel = new ChoiceQueryPanel<>(choices);
		InteractionResult choice = queryPanel.getUserChoice(view, query);
		if (choice == InteractionResult.FINISHED || choice == InteractionResult.CONTINUE) {
			return queryPanel.getResult();
		} else {
			throw new UserCancelledException();
		}
	}

	/**
	 * Shows a dialog with a multi-line text area, and returns the entered
	 * value.
	 * 
	 * @param context
	 * @param queryCaption
	 * @return
	 * @throws UserCancelledException
	 */
	public static String queryForMultilineString(UIPluginContext context, String queryCaption)
			throws UserCancelledException {
		MultilineStringQueryPanel queryPanel = new MultilineStringQueryPanel();
		InteractionResult choice = queryPanel.getUserChoice(context, queryCaption);
		if (choice == InteractionResult.FINISHED || choice == InteractionResult.CONTINUE) {
			return queryPanel.getResult();
		} else {
			throw new UserCancelledException();
		}
	}

	/**
	 * Shows a dialog with a multi-line text area, and returns the entered
	 * value.
	 * 
	 * @param context
	 * @param queryCaption
	 *            that is shown on top of the dialog
	 * @param defaultText
	 *            that is shown in the text area
	 * @return
	 * @throws UserCancelledException
	 */
	public static String queryForMultilineString(UIPluginContext context, String queryCaption, String defaultText)
			throws UserCancelledException {
		MultilineStringQueryPanel queryPanel = new MultilineStringQueryPanel(defaultText);
		InteractionResult choice = queryPanel.getUserChoice(context, queryCaption);
		if (choice == InteractionResult.FINISHED || choice == InteractionResult.CONTINUE) {
			return queryPanel.getResult();
		} else {
			throw new UserCancelledException();
		}
	}

	/**
	 * Shows a dialog with a selection list that allow multi-selection.
	 * 
	 * @param context
	 * @param query
	 * @param choices
	 * @return
	 * @throws UserCancelledException
	 */
	public static <T> List<T> queryForObjects(UIPluginContext context, String query, T[] choices)
			throws UserCancelledException {
		return queryForObjects(context, query, Arrays.asList(choices));
	}
	
	public static <T> List<T> queryForObjects(Component view, String query, T[] choices)
			throws UserCancelledException {
		return queryForObjects(view, query, Arrays.asList(choices));
	}

	/**
	 * Shows a dialog with a selection list that allow multi-selection.
	 * 
	 * @param context
	 * @param query
	 * @param choices
	 * @return
	 * @throws UserCancelledException
	 */
	public static <T> List<T> queryForObjects(UIPluginContext context, String query, Iterable<T> choices)
			throws UserCancelledException {
		MultipleChoiceQueryPanel<T> queryPanel = new MultipleChoiceQueryPanel<>(query, choices);
		InteractionResult choice = queryPanel.getUserChoice(context, query);
		if (choice == InteractionResult.FINISHED || choice == InteractionResult.CONTINUE) {
			return queryPanel.getResult();
		} else {
			throw new UserCancelledException();
		}
	}

	public static <T> List<T> queryForObjects(Component view, String query, Iterable<T> choices)
			throws UserCancelledException {
		MultipleChoiceQueryPanel<T> queryPanel = new MultipleChoiceQueryPanel<>(query, choices);
		InteractionResult choice = queryPanel.getUserChoice(view, query);
		if (choice == InteractionResult.FINISHED || choice == InteractionResult.CONTINUE) {
			return queryPanel.getResult();
		} else {
			throw new UserCancelledException();
		}
	}

	/**
	 * Shows a dialog with a selection list that allow multi-selection.
	 * 
	 * @param context
	 * @param query
	 * @param choices
	 * @return
	 * @throws UserCancelledException
	 */
	public static List<String> queryForStrings(UIPluginContext context, String query, Iterable<String> choices)
			throws UserCancelledException {
		MultipleChoiceQueryPanel<String> queryPanel = new MultipleChoiceQueryPanel<>(query, choices);
		InteractionResult choice = queryPanel.getUserChoice(context, query);
		if (choice == InteractionResult.FINISHED || choice == InteractionResult.CONTINUE) {
			return queryPanel.getResult();
		} else {
			throw new UserCancelledException();
		}
	}

	public static List<String> queryForStrings(Component view, String query, Iterable<String> choices)
			throws UserCancelledException {
		MultipleChoiceQueryPanel<String> queryPanel = new MultipleChoiceQueryPanel<>(query, choices);
		InteractionResult choice = queryPanel.getUserChoice(view, query);
		if (choice == InteractionResult.FINISHED || choice == InteractionResult.CONTINUE) {
			return queryPanel.getResult();
		} else {
			throw new UserCancelledException();
		}
	}

	/**
	 * Shows a dialog with a selection list that allow multi-selection.
	 * 
	 * @param context
	 * @param query
	 * @param choices
	 * @return
	 * @throws UserCancelledException
	 */
	public static List<String> queryForStrings(UIPluginContext context, String query, String[] choices)
			throws UserCancelledException {
		return queryForStrings(context, query, Arrays.asList(choices));
	}

	/**
	 * Shows a dialog to the user with a two-column table. The first column
	 * contains the supplied keys. In the second column the user can enter the
	 * desired values. The mapping is returned as a Map.
	 * 
	 * @param context
	 * @param query
	 * @param keys
	 * @return
	 * @throws UserCancelledException
	 */
	public static <T> Map<T, String> queryMapToString(UIPluginContext context, String query, Iterable<T> keys)
			throws UserCancelledException {
		FreeMappingQueryPanel<T> queryPanel = new FreeMappingQueryPanel<>(query, keys, ImmutableMap.<T, String>of());
		InteractionResult choice = queryPanel.getUserChoice(context, query);
		if (choice == InteractionResult.FINISHED || choice == InteractionResult.CONTINUE) {
			return queryPanel.getResult();
		} else {
			throw new UserCancelledException();
		}
	}

	/**
	 * Shows a dialog to the user with a two-column table. The first column
	 * contains the supplied keys. In the second column the user can enter the
	 * desired values. The mapping is returned as a Map.
	 * 
	 * @param context
	 * @param query
	 * @param keys
	 * @return
	 * @throws UserCancelledException
	 */
	public static <T> Map<T, String> queryMapToString(UIPluginContext context, String query, T[] keys)
			throws UserCancelledException {
		return queryMapToString(context, query, Arrays.asList(keys));
	}

	/**
	 * Shows a dialog to the user with a two-column table. The first column
	 * contains the supplied keys. In the second column the user can enter the
	 * desired values. The mapping is returned as a Map.
	 * 
	 * @param context
	 * @param query
	 * @param keys
	 * @param defaultValues
	 * @return
	 * @throws UserCancelledException
	 */
	public static <T> Map<T, String> queryMapToString(UIPluginContext context, String query, Iterable<T> keys,
			Map<T, String> defaultValues) throws UserCancelledException {
		FreeMappingQueryPanel<T> queryPanel = new FreeMappingQueryPanel<>(query, keys, defaultValues);
		InteractionResult choice = queryPanel.getUserChoice(context, query);
		if (choice == InteractionResult.FINISHED || choice == InteractionResult.CONTINUE) {
			return queryPanel.getResult();
		} else {
			throw new UserCancelledException();
		}
	}

	/**
	 * Shows a dialog to the user with a two-column table. The first column
	 * contains the supplied keys. In the second column the user can enter the
	 * desired values. The mapping is returned as a Map.
	 * 
	 * @param context
	 * @param query
	 * @param keys
	 * @param defaultValues
	 * @return
	 * @throws UserCancelledException
	 */
	public static <T> Map<T, String> queryMapToString(UIPluginContext context, String query, T[] keys,
			Map<T, String> defaultValues) throws UserCancelledException {
		return queryMapToString(context, query, Arrays.asList(keys), defaultValues);
	}

	/**
	 * Shows a dialog to the user with a two-column table. The first column
	 * contains the supplied keys. In the second column the user can choose from
	 * a list of values. The mapping is returned as a Map.
	 * 
	 * @param context
	 * @param query
	 * @param keys
	 * @param values
	 * @return
	 * @throws UserCancelledException
	 */
	public static <S, T> Map<S, T> queryMapToObject(UIPluginContext context, String query, Iterable<S> keys,
			Iterable<T> values) throws UserCancelledException {
		return queryMapToObject(context, query, keys, values, ImmutableMap.<S, T>of());
	}

	/**
	 * Shows a dialog to the user with a two-column table. The first column
	 * contains the supplied keys. In the second column the user can choose from
	 * a list of values. The mapping is returned as a Map.
	 * 
	 * @param context
	 * @param query
	 * @param keys
	 * @param values
	 * @param defaultMap
	 * @return
	 * @throws UserCancelledException
	 */
	public static <S, T> Map<S, T> queryMapToObject(UIPluginContext context, String query, Iterable<S> keys,
			Iterable<T> values, Map<S, T> defaultMap) throws UserCancelledException {
		FixedMappingQueryPanel<S, T> queryPanel = new FixedMappingQueryPanel<S, T>(query, keys, values, defaultMap);
		InteractionResult choice = queryPanel.getUserChoice(context, query);
		if (choice == InteractionResult.FINISHED || choice == InteractionResult.CONTINUE) {
			return queryPanel.getResult();
		} else {
			throw new UserCancelledException();
		}
	}

}"
SliderQueryPanel.java,widget,"package org.processmining.framework.util.ui.widgets.helper;

import java.awt.Component;

import javax.swing.BoxLayout;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JPanel;

import org.deckfour.uitopia.api.event.TaskListener.InteractionResult;
import org.processmining.contexts.uitopia.UIPluginContext;

import com.fluxicon.slickerbox.components.NiceDoubleSlider;
import com.fluxicon.slickerbox.components.NiceSlider.Orientation;
import com.fluxicon.slickerbox.factory.SlickerFactory;

public class SliderQueryPanel extends JPanel {

	private static final long serialVersionUID = 1L;

	private final NiceDoubleSlider slider;

	public SliderQueryPanel(String queryText, double min, double max, double defaultValue) {
		setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));
		if (queryText != null) {
			add(new JLabel(queryText));
		}
		slider = SlickerFactory.instance().createNiceDoubleSlider(queryText, min, max, defaultValue,
				Orientation.HORIZONTAL);
		add(slider);
	}

	public InteractionResult getUserChoice(UIPluginContext context, String query) {
		return context.showConfiguration(query, this);
	}

	public InteractionResult getUserChoice(Component view, String query) {
		String[] options = new String[] { ""Confirm"", ""Cancel"" };
		int result = JOptionPane.showOptionDialog(view, this, query, JOptionPane.DEFAULT_OPTION,
				JOptionPane.QUESTION_MESSAGE, null, options, options[0]);
		return result == 0 ? InteractionResult.CONTINUE : InteractionResult.CANCEL;
	}

	public double getResult() {
		return slider.getValue();
	}

}
"
StringQueryPanel.java,widget,"package org.processmining.framework.util.ui.widgets.helper;

import java.awt.Component;

import javax.swing.BoxLayout;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JPanel;

import org.deckfour.uitopia.api.event.TaskListener.InteractionResult;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.framework.util.ui.widgets.ProMTextField;

class StringQueryPanel extends JPanel {

	private static final long serialVersionUID = -6547392010448275699L;

	private final ProMTextField textField;
	
	public StringQueryPanel(String queryText, String defaultValue) {
		setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));
		if (queryText != null) {
			add(new JLabel(queryText));
		}
		if (defaultValue != null) {
			textField = new ProMTextField(defaultValue);	
		} else {
			textField = new ProMTextField();
		}
		textField.setPreferredSize(null);
		add(textField);
	}
	
	public StringQueryPanel(String text) {
		this(text, null);
	}

	public StringQueryPanel() {
		this(null);
	}

	public InteractionResult getUserChoice(UIPluginContext context, String query) {
		return context.showConfiguration(query, this);
	}
	
	public InteractionResult getUserChoice(Component view, String query) {
		String[] options = new String[] { ""Confirm"", ""Cancel"" };
		int result = JOptionPane.showOptionDialog(view, this, query, JOptionPane.DEFAULT_OPTION,
				JOptionPane.QUESTION_MESSAGE, null, options, options[0]);
		return result == 0 ? InteractionResult.CONTINUE : InteractionResult.CANCEL;
	}

	public String getResult() {
		return textField.getText();
	}

}"
UserCancelledException.java,widget,"package org.processmining.framework.util.ui.widgets.helper;

/**
 * Thrown by most methods in {@link ProMUIHelper} in case the user cancels an
 * operation.
 * 
 * @author F. Mannhardt
 * 
 */
public class UserCancelledException extends Exception {

	private static final long serialVersionUID = 1L;

	public UserCancelledException() {
		super(""User Cancelled"");
	}

	public UserCancelledException(String message, Throwable cause) {
		super(message, cause);
	}

	public UserCancelledException(String message) {
		super(message);
	}

	public UserCancelledException(Throwable cause) {
		super(cause);
	}

}
"
Inspector.java,widget,"package org.processmining.framework.util.ui.widgets;

import java.awt.BasicStroke;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Container;
import java.awt.Dimension;
import java.awt.FlowLayout;
import java.awt.Font;
import java.awt.Frame;
import java.awt.GradientPaint;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.GraphicsDevice.WindowTranslucency;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.ContainerEvent;
import java.awt.event.ContainerListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;

import javax.swing.BorderFactory;
import javax.swing.BoxLayout;
import javax.swing.Icon;
import javax.swing.ImageIcon;
import javax.swing.JComponent;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JWindow;

import org.deckfour.uitopia.ui.components.ImageButton;

import com.fluxicon.slickerbox.components.SlickerTabbedPane;
import com.fluxicon.slickerbox.factory.SlickerFactory;

/**
 * Inspector-style window. You should probably use an InspectorPanel instead of
 * this class directly.
 * 
 * @author mwesterg
 * 
 */
public abstract class Inspector extends JWindow {
	private static final Icon closed;
	private static final Image minimize;
	private static final Icon opened;
	private static final Image options;

	/**
	 * 
	 */
	private static final long serialVersionUID = 1L;
	static {
		Image i = new BufferedImage(9, 9, BufferedImage.TYPE_INT_ARGB);
		Graphics g = i.getGraphics();
		g.setColor(Color.RED);
		g.fillPolygon(new int[] { 0, 8, 0 }, new int[] { 0, 4, 8 }, 3);
		closed = new ImageIcon(i);

		i = new BufferedImage(9, 9, BufferedImage.TYPE_INT_ARGB);
		g = i.getGraphics();
		g.setColor(Color.LIGHT_GRAY);
		g.fillPolygon(new int[] { 0, 4, 8 }, new int[] { 0, 8, 0 }, 3);
		opened = new ImageIcon(i);

		minimize = new BufferedImage(16, 16, BufferedImage.TYPE_INT_ARGB);
		g = Inspector.minimize.getGraphics();
		Graphics2D g2d = (Graphics2D) g.create();
		g2d.setColor(WidgetColors.HEADER_COLOR);
		g2d.setStroke(new BasicStroke(3));
		g2d.drawArc(0, 0, 15, 15, 90, 270);
		g2d.drawLine(7, 8, 12, 3);
		g2d.setStroke(new BasicStroke(2));
		g2d.drawLine(5, 10, 5, 5);
		g2d.drawLine(5, 10, 10, 10);

		options = new BufferedImage(16, 16, BufferedImage.TYPE_INT_ARGB);
		g = Inspector.options.getGraphics();
		g2d = (Graphics2D) g.create();
		g2d.setColor(WidgetColors.HEADER_COLOR);
		g2d.setStroke(new BasicStroke(3));
		g2d.drawArc(0, 0, 15, 15, 110, 220);
		g2d.drawArc(8, 1, 7, 7, 90, 270);
		g2d.setStroke(new BasicStroke(4, BasicStroke.CAP_ROUND, BasicStroke.JOIN_ROUND));
		g2d.drawLine(5, 10, 8, 7);

		//g2d.setColor(Color.LIGHT_GRAY);
		//g2d.drawLine(15, 0, 11, 4);
	}
	private final JPanel buttons;
	private final JPanel main;
	private final JPanel settings;
	private final SlickerTabbedPane tabbedPane;

	/**
	 * @deprecated, use Inspector(Frame owner) instead.
	 */
	@Deprecated
	public Inspector() {
		this(null);
	}

	public Inspector(Frame owner) {
		super(owner);
		final MouseAdapter listener = new MouseAdapter() {
			private int x, y;

			@Override
			public void mouseDragged(final MouseEvent e) {
				setLocation(getLocation().x + e.getX() - x, getLocation().y + e.getY() - y);
			}

			@Override
			public void mousePressed(final MouseEvent e) {
				x = e.getX();
				y = e.getY();
			}
		};
		addMouseListener(listener);
		addMouseMotionListener(listener);
		setBackground(null);
		setFocusable(false);
		setMinimumSize(new Dimension(200, 50));
		setMaximumSize(new Dimension(200, 2000));
		setSize(200, 600);
		setAlwaysOnTop(true);
		//Toolkit.getDefaultToolkit().addAWTEventListener(new Fader(), AWTEvent.MOUSE_EVENT_MASK);
		settings = new BorderPanel(3, 3);
		settings.add(SlickerFactory.instance().createCheckBox(""Only one open group"", false));
		final JPanel padding = new JPanel(new BorderLayout());
		padding.setBorder(BorderFactory.createEmptyBorder(3, 3, 0, 3));
		padding.add(settings);
		padding.setOpaque(false);
		main = new JPanel(new BorderLayout());
		padding.setVisible(false);
		main.add(padding, BorderLayout.NORTH);
		main.setOpaque(false);
		tabbedPane = SlickerFactory.instance().createTabbedPane("""", Color.BLACK, Color.WHITE, Color.BLACK);
		final BorderPanel border = new BorderPanel(5, 5);
		border.setOpaque(true);
		border.setBackground(Color.LIGHT_GRAY);
		border.setLayout(new BorderLayout());
		main.add(tabbedPane);
		border.add(main);
		final JPanel header = new JPanel();
		header.setLayout(new BorderLayout());
		header.setOpaque(false);
		final LeftAlignedHeader headerText = new LeftAlignedHeader(""Inspector"");
		headerText.setBorder(BorderFactory.createEmptyBorder(0, 5, 0, 5));
		header.add(headerText);
		buttons = new JPanel(new FlowLayout(FlowLayout.RIGHT, 2, 0));
		buttons.setOpaque(false);
		buttons.setBorder(BorderFactory.createEmptyBorder(2, 2, 0, 2));
		final ImageButton minimizeButton = new ImageButton(Inspector.minimize, Color.LIGHT_GRAY, Color.GRAY, 0);
		minimizeButton.addActionListener(new ActionListener() {

			@Override
			public void actionPerformed(final ActionEvent e) {
				setVisible(false);
				main.remove(tabbedPane);
				minimized(tabbedPane);
			}

		});
		buttons.add(minimizeButton);
		final ImageButton optionsButton = new ImageButton(Inspector.options, Color.LIGHT_GRAY, Color.GRAY, 0);
		optionsButton.addActionListener(new ActionListener() {
			@Override
			public void actionPerformed(final ActionEvent e) {
				padding.setVisible(!padding.isVisible());
				invalidate();
				repaint();
				pack();
			}
		});
		buttons.add(optionsButton);
		header.add(buttons, BorderLayout.EAST);
		border.add(header, BorderLayout.NORTH);
		border.setForeground(Color.BLACK);
		add(border);

		tabbedPane.setBackground(null);

		// EWEWEW! SlickerBox insists on setting a preferred size instead of minimum and maximum sizes, so for pack to work, we need to reset this
		tabbedPane.getComponent(0).setPreferredSize(null);
		// Another EW! SlickerBox provides a veryrudimentary event-system when tabs are switched (events are only passed before); this allows us to receive an event when a tab has been switched
		((Container) tabbedPane.getComponent(1)).addContainerListener(new ContainerListener() {

			@Override
			public void componentAdded(final ContainerEvent arg0) {
				pack();

			}

			@Override
			public void componentRemoved(final ContainerEvent arg0) {
			}
		});

		pack();
		//FM, Updated to Java 7 commands as explained here: https://docs.oracle.com/javase/tutorial/uiswing/misc/trans_shaped_windows.html
		if (getGraphicsConfiguration().getDevice().isWindowTranslucencySupported(WindowTranslucency.TRANSLUCENT)) {
			this.setBackground(new Color(0, 0, 0,1.0f));
			this.setOpacity(0.85f);
		}
	}

	/**
	 * @param tab
	 * @param header
	 * @param component
	 */
	public void addGroup(final JPanel tab, final String header, final JComponent component) {
		addGroup(tab, header, component, false);
	}

	/**
	 * @param tab
	 * @param header
	 * @param component
	 * @param open
	 */
	public void addGroup(final JPanel tab, final String header, final JComponent component, final boolean open) {
		final JPanel group = new JPanel();
		group.setBackground(Color.BLACK);
		group.setLayout(new BorderLayout());
		final JLabel headerComponent = new JLabel() {
			private static final long serialVersionUID = 1L;
			private Color c;

			@Override
			public void paintComponent(final Graphics g) {
				final Graphics2D g2d = (Graphics2D) g;
				g2d.setPaint(new GradientPaint(new Point(getWidth() / 2, getHeight()), c, new Point(getWidth(),
						getHeight()), Color.LIGHT_GRAY));
				g2d.fillRect(0, 0, getWidth(), getHeight());
				super.paintComponent(g);
			}

			@Override
			public void setBackground(final Color c) {
				this.c = c;
				super.setOpaque(false);
				super.setBackground(null);
			}
		};
		headerComponent.setBackground(Color.BLACK);
		headerComponent.setText(header);
		if (open) {
			headerComponent.setIcon(Inspector.opened);
		} else {
			headerComponent.setIcon(Inspector.closed);
		}
		headerComponent.setFont(headerComponent.getFont().deriveFont(Font.BOLD + Font.ITALIC));
		headerComponent.setForeground(Color.LIGHT_GRAY);
		group.add(headerComponent, BorderLayout.NORTH);

		final JPanel main = SlickerFactory.instance().createRoundedPanel(10, Color.LIGHT_GRAY);
		main.setLayout(new BorderLayout());
		main.add(component);
		if (open) {
			group.add(main);
		}
		headerComponent.addMouseListener(new MouseAdapter() {
			private boolean opened = open;

			@Override
			public void mouseClicked(final MouseEvent e) {
				if (opened) {
					headerComponent.setIcon(Inspector.closed);
					group.remove(main);
					opened = false;
				} else {
					headerComponent.setIcon(Inspector.opened);
					group.add(main);
					opened = true;
				}
				group.invalidate();
				group.validate();
				group.repaint();
				pack();
			}

			@Override
			public void mousePressed(final MouseEvent e) {
				headerComponent.setBackground(Color.GRAY);
				headerComponent.setForeground(Color.WHITE);
			}

			@Override
			public void mouseReleased(final MouseEvent e) {
				headerComponent.setBackground(Color.BLACK);
				headerComponent.setForeground(Color.LIGHT_GRAY);
			}
		});
		tab.add(group);
		invalidate();
		repaint();
		pack();
	}

	/**
	 * @param name
	 * @return
	 */
	public JPanel addTab(final String name) {
		final JPanel tab = new JPanel();
		tab.setLayout(new BoxLayout(tab, BoxLayout.Y_AXIS));
		tabbedPane.addTab(name, tab);
		return tab;
	}

	/**
	 * 
	 */
	public void restore() {
		if (tabbedPane.getParent() != null) {
			tabbedPane.getParent().remove(tabbedPane);
		}
		main.add(tabbedPane);
		setVisible(true);
		invalidate();
		repaint();
		pack();
	}

	abstract void minimized(SlickerTabbedPane tabbedPane);

}
"
InspectorPanel.java,widget,"package org.processmining.framework.util.ui.widgets;

import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.Frame;
import java.awt.LayoutManager;
import java.awt.Point;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;

import javax.swing.JComponent;
import javax.swing.JPanel;
import javax.swing.JSplitPane;
import javax.swing.event.AncestorEvent;
import javax.swing.event.AncestorListener;

import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.framework.plugin.PluginContext;

import com.fluxicon.slickerbox.components.SlickerTabbedPane;

/**
 * Panel with an Inspector
 * 
 * @author mwesterg
 * 
 */
public class InspectorPanel extends ProMSplitPane {

	/**
	 * 
	 */
	private static final long serialVersionUID = 1L;
	private final JPanel info;
	private final Inspector inspector;
	private final JPanel main;
	private boolean moved;
	private final JPanel tabs;
	boolean minimized = false;

	/**
	 * @deprecated, use InspectorPanel(Frame owner) or InspectorPanel(PluginContext context) instead.
	 */
	@Deprecated
	public InspectorPanel() {
		this((Frame) null);
	}

	public InspectorPanel(PluginContext context) {
		this(context instanceof UIPluginContext ? ((UIPluginContext) context).getGlobalContext().getUI() : (Frame) null);
	}

	public InspectorPanel(Frame owner) {
		super(JSplitPane.VERTICAL_SPLIT);
		final JPanel tmp = new JPanel();
		tmp.setOpaque(false);
		tabs = new JPanel(new BorderLayout());
		tabs.setOpaque(false);
		setTopComponent(tmp);
		setBottomComponent(tabs);
		main = tmp;
		setOneTouchExpandable(true);
		setDividerSize(0);
		setResizeWeight(1.0);
		inspector = new Inspector(owner) {
			/**
			 * 
			 */
			private static final long serialVersionUID = 1L;

			@Override
			void minimized(final SlickerTabbedPane tabbedPane) {
				minimized = true;
				tabs.add(tabbedPane);
				setDividerSize(5);
				setDividerLocation(getHeight() - 100);
				tabs.validate();
				validate();
				repaint();
			}
		};
		info = inspector.addTab(""Info"");

		addComponentListener(new ComponentAdapter() {
			@Override
			public void componentResized(final ComponentEvent e) {
				resize();
			}
		});

		addAncestorListener(new AncestorListener() {
			@Override
			public void ancestorAdded(final AncestorEvent arg0) {
				if (!minimized) {
					inspector.setLocationByPlatform(false);
					inspector.setVisible(true);
					validate();
					InspectorPanel.this.requestFocus();
				}
			}

			@Override
			public void ancestorMoved(final AncestorEvent arg0) {

			}

			@Override
			public void ancestorRemoved(final AncestorEvent arg0) {
				if (!minimized) {
					inspector.setVisible(false);
				}
			}
		});

	}

	/**
	 * @see java.awt.Container#add(java.awt.Component)
	 */
	@Override
	public Component add(final Component c) {
		if (main != null) {
			main.add(c);
		} else {
			super.add(c);
		}
		return c;
	}

	/**
	 * @param header
	 * @param component
	 */
	public void addInfo(final String header, final JComponent component) {
		inspector.addGroup(info, header, component);
	}

	/**
	 * @see java.awt.Container#remove(java.awt.Component)
	 */
	@Override
	public void remove(final Component c) {
		if (main != null) {
			main.remove(c);
		} else {
			super.remove(c);
		}
	}

	/**
	 * 
	 */
	public void resize() {
		if (!moved) {
			final Point point = getLocationOnScreen();
			inspector.setLocation((int) (point.getX() + getWidth() - inspector.getWidth() - 8),
					(int) (point.getY() + 8));
			moved = true;
		}
	}

	/**
	 * @see java.awt.Container#setLayout(java.awt.LayoutManager)
	 */
	@Override
	public void setLayout(final LayoutManager layout) {
		if (main != null) {
			main.setLayout(layout);
		} else {
			super.setLayout(layout);
		}
	}

	/**
	 * @see java.awt.Container#validate()
	 */
	@Override
	public void validate() {
		super.validate();
		if (!minimized) {
			setDividerLocation(5000);
		}
	}

	/**
	 * @return the inspector
	 */
	protected Inspector getInspector() {
		return inspector;
	}

	@Override
	protected void rightClicked() {
		minimized = false;
		inspector.restore();
		setDividerSize(0);
		setDividerLocation(getHeight());
		tabs.validate();
		validate();
		repaint();
	}
}
"
LeftAlignedHeader.java,widget,"package org.processmining.framework.util.ui.widgets;

import javax.swing.BorderFactory;
import javax.swing.Box;
import javax.swing.BoxLayout;
import javax.swing.JLabel;
import javax.swing.JPanel;

/**
 * Header aligned to the left
 * 
 * @author mwesterg
 * 
 */
public class LeftAlignedHeader extends JPanel {

	/**
	 * 
	 */
	private static final long serialVersionUID = 1L;

	/**
	 * @param title
	 */
	public LeftAlignedHeader(final String title) {
		final JLabel hLabel = new JLabel(title);
		hLabel.setOpaque(false);
		hLabel.setForeground(WidgetColors.HEADER_COLOR);
		hLabel.setFont(hLabel.getFont().deriveFont(15f));
		setBorder(BorderFactory.createEmptyBorder());
		setOpaque(false);
		setLayout(new BoxLayout(this, BoxLayout.X_AXIS));
		add(hLabel);
		add(Box.createHorizontalGlue());
	}

}
"
CreateLogPlugin.java,widget,"package org.processmining.framework.util.ui.widgets.logging;

import java.util.logging.Logger;

import org.deckfour.uitopia.api.event.TaskListener.InteractionResult;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.framework.util.ui.widgets.ProMPropertiesPanel;
import org.processmining.framework.util.ui.widgets.ProMTextField;

/**
 * @author michael
 * 
 */
@Plugin(name = ""Create Fresh Log"", parameterLabels = {}, returnLabels = { ""Log"" }, returnTypes = { Loggable.class })
public class CreateLogPlugin {
	/**
	 * @param context
	 * @return
	 */
	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""M. Westergaard"", email = ""m.westergaard@tue.nl"")
	@PluginVariant(requiredParameterLabels = {})
	public static Loggable createLog(final UIPluginContext context) {
		final ProMPropertiesPanel panel = new ProMPropertiesPanel(null);
		final ProMTextField name = panel.addTextField(""Log Name"");
		if (context.showConfiguration(""New Log"", panel) == InteractionResult.CONTINUE) {
			return new Loggable() {
				transient Logger log = Logger.getLogger(name.getText());

				@Override
				public Logger getLogger() {
					return log;
				}
			};
		}
		context.getFutureResult(0).cancel(true);
		return null;
	}
}
"
Loggable.java,widget,"package org.processmining.framework.util.ui.widgets.logging;

import java.util.logging.Logger;

/**
 * @author michael
 * 
 */
public interface Loggable {
	/**
	 * @return
	 */
	Logger getLogger();
}
"
LogViewer.java,widget,"package org.processmining.framework.util.ui.widgets.logging;

import java.awt.BorderLayout;
import java.awt.FlowLayout;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.logging.Handler;
import java.util.logging.Level;
import java.util.logging.LogRecord;
import java.util.logging.Logger;

import javax.swing.JButton;
import javax.swing.JCheckBox;
import javax.swing.JComboBox;
import javax.swing.JComponent;
import javax.swing.JFileChooser;
import javax.swing.JPanel;
import javax.swing.filechooser.FileFilter;

import org.processmining.contexts.uitopia.annotations.Visualizer;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.framework.util.ui.widgets.ProMPropertiesPanel;
import org.processmining.framework.util.ui.widgets.ProMTextArea;

import com.fluxicon.slickerbox.factory.SlickerFactory;

/**
 * 
 * @author mwesterg
 * 
 */
@Plugin(name = ""Show Log"", returnLabels = { ""Log Viewer"" }, returnTypes = { JComponent.class }, parameterLabels = { ""Loggable Object"" }, userAccessible = false)
@Visualizer
public class LogViewer {
	private static class LogHandler extends Handler {
		private final transient LogView view;

		public LogHandler(final LogView view) {
			this.view = view;
		}

		@Override
		public void close() throws SecurityException {
		}

		@Override
		public void flush() {
		}

		@Override
		public void publish(final LogRecord record) {
			if (view != null) {
				view.add(record);
			}
		}
	}

	private static class LogView extends ProMPropertiesPanel {
		/**
		 * 
		 */
		private static final long serialVersionUID = 1L;
		private JCheckBox details;
		@SuppressWarnings(""rawtypes"")
		private final JComboBox/* <Level> */level;
		private final ProMTextArea log;

		public LogView(final Logger logger) {
			super(""Log ("" + logger.getName() + "")"");

			level = addComboBox(""Logging level"", new Level[] { Level.OFF, Level.SEVERE, Level.WARNING, Level.INFO,
					Level.CONFIG, Level.FINE, Level.FINER, Level.FINEST, Level.ALL });
			level.setSelectedItem(Level.ALL);
			level.addActionListener(new ActionListener() {
				@Override
				public void actionPerformed(final ActionEvent e) {
					logger.setLevel((Level) level.getSelectedItem());
				}
			});

			details = addCheckBox(""Show details"", true);

			final JPanel panel = new JPanel();
			panel.setLayout(new BorderLayout());
			panel.setOpaque(false);
			add(panel);

			log = new ProMTextArea();
			log.setEditable(false);
			log.setTabSize(4);
			panel.add(log);

			final JPanel buttons = new JPanel();
			buttons.setLayout(new FlowLayout(FlowLayout.CENTER, 5, 5));
			buttons.setOpaque(false);
			panel.add(buttons, BorderLayout.SOUTH);

			final JButton clearButton = SlickerFactory.instance().createButton(""Clear"");
			buttons.add(clearButton);

			clearButton.addActionListener(new ActionListener() {
				@Override
				public void actionPerformed(final ActionEvent e) {
					log.setText("""");
				}
			});

			final JButton saveButton = SlickerFactory.instance().createButton(""Save"");
			buttons.add(saveButton);

			saveButton.addActionListener(new ActionListener() {
				@Override
				public void actionPerformed(final ActionEvent e) {
					final String txt = log.getText();
					final JFileChooser chooser = new JFileChooser();
					chooser.setFileFilter(new FileFilter() {
						@Override
						public boolean accept(final File f) {
							return f.getName().toLowerCase().endsWith("".txt"");
						}

						@Override
						public String getDescription() {
							return ""Text files"";
						}
					});
					chooser.setSelectedFile(new File(""Log for "" + logger.getName() + "".txt""));
					if (chooser.showSaveDialog(null) == JFileChooser.APPROVE_OPTION) {
						FileWriter fileWriter;
						try {
							fileWriter = new FileWriter(chooser.getSelectedFile());
							final BufferedWriter bufferedWriter = new BufferedWriter(fileWriter);
							bufferedWriter.append(txt);
							bufferedWriter.close();
						} catch (final IOException _) {
						}
					}
				}
			});

		}

		public void add(final LogRecord record) {
			if (((Level) level.getSelectedItem()).intValue() <= record.getLevel().intValue()) {
				final StringBuilder message = new StringBuilder();
				boolean indent = false;
				if (details.isSelected()) {
					indent = true;
					message.append(LogViewer.format.format(new Date(record.getMillis())));
					message.append('\t');
					message.append(record.getLevel());
					message.append('\t');
					boolean addedClass = false;
					if (record.getSourceClassName() != null && !"""".equals(record.getSourceClassName())) {
						message.append(record.getSourceClassName());
						addedClass = true;
					}
					if (record.getSourceMethodName() != null && !"""".equals(record.getSourceMethodName())) {
						if (addedClass) {
							message.append('.');
						}
						message.append(record.getSourceMethodName());
					}
					message.append(""\n\t"");
				}
				message.append(record.getMessage());
				Throwable t = record.getThrown();
				while (t != null) {
					message.append(' ');
					message.append(t.getClass());
					message.append("": "");
					message.append(t.getMessage());
					for (final StackTraceElement ste : record.getThrown().getStackTrace()) {
						message.append('\n');
						if (indent) {
							message.append('\t');
						}
						message.append('\t');
						message.append(ste);
					}
					if (t.getCause() != t && t.getCause() != null) {
						t = t.getCause();
						message.append('\n');
						if (indent) {
							message.append('\t');
						}
						message.append(""Caused by"");
					} else {
						t = null;
					}
				}
				message.append('\n');
				log.append(message.toString());
				log.scrollToEnd();
			}
		}
	};

	private static final DateFormat format = new SimpleDateFormat(""yyyy/MM/dd HH:mm:ss"");

	/**
	 * @param context
	 * @param service
	 * @return
	 */
	@PluginVariant(requiredParameterLabels = { 0 })
	public static JComponent visualize(final PluginContext context, final Loggable service) {
		final Logger logger = service.getLogger();
		logger.setLevel(Level.ALL);
		final LogView view = new LogView(logger);
		logger.addHandler(new LogHandler(view));
		return view;
	}

}
"
ProMLoggable.java,widget,"package org.processmining.framework.util.ui.widgets.logging;

import java.util.logging.Logger;

/**
 * @author michael
 * 
 */
public final class ProMLoggable implements Loggable {
	private transient final Logger l;

	/**
	 * @param l
	 */
	public ProMLoggable(final Logger l) {
		this.l = l;
	}

	/**
	 * @see org.processmining.framework.util.ui.widgets.logging.Loggable#getLogger()
	 */
	@Override
	public Logger getLogger() {
		return l;
	}
}"
ProMAutoCompletingTextField.java,widget,"/*
 * Adopted from Java Tutorials Code Examples
 * 
 * Copyright (c) 1995, 2008, Oracle and/or its affiliates. All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 * - Redistributions of source code must retain the above copyright notice, this
 * list of conditions and the following disclaimer.
 * 
 * - Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 * 
 * - Neither the name of Oracle or the names of its contributors may be used to
 * endorse or promote products derived from this software without specific prior
 * written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
package org.processmining.framework.util.ui.widgets;

import java.awt.event.ActionEvent;
import java.util.Collections;
import java.util.List;
import java.util.Set;

import javax.swing.AbstractAction;
import javax.swing.ActionMap;
import javax.swing.InputMap;
import javax.swing.KeyStroke;
import javax.swing.SwingUtilities;
import javax.swing.event.DocumentEvent;
import javax.swing.event.DocumentListener;
import javax.swing.text.BadLocationException;

import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Ordering;

public class ProMAutoCompletingTextField extends ProMTextField {

	private static final long serialVersionUID = 3530217391302932937L;

	private final class DocumentListenerImpl implements DocumentListener {
		public void removeUpdate(DocumentEvent e) {
		}

		public void insertUpdate(DocumentEvent e) {
			if (e.getLength() != 1) {
				return;
			}

			try {
				int pos = e.getOffset();
				String content = e.getDocument().getText(0, pos + 1);

				int startIndex;
				for (startIndex = pos; startIndex >= 0; startIndex--) {
					if (isStopCharacter(content.charAt(startIndex))) {
						break;
					}
				}
				int charactersInWord = pos - startIndex;
				if (charactersInWord < 2) {
					// Too few chars
					return;
				}

				String prefix = e.getDocument().getText(startIndex + 1, e.getDocument().getLength());
				int wordIndex = Collections.binarySearch(getDictionary(), prefix);
				if (wordIndex < 0 && -wordIndex <= getDictionary().size()) {
					String match = getDictionary().get(-wordIndex - 1);
					if (match.startsWith(prefix)) {
						// A completion is found
						String completion = match.substring(pos - startIndex);
						// We cannot modify Document from within notification,
						// so we submit a task that does the change later
						SwingUtilities.invokeLater(new CompletionTask(completion, pos + 1));
					}
				} else {
					// Nothing found
					mode = Mode.INSERT;
				}
			} catch (BadLocationException e1) {
			}
		}

		public void changedUpdate(DocumentEvent e) {
		}
	}

	private static enum Mode {
		INSERT, COMPLETION
	};

	private class CompletionTask implements Runnable {

		String completion;
		int position;

		CompletionTask(String completion, int position) {
			this.completion = completion;
			this.position = position;
		}

		public void run() {
			try {
				getTextField().getDocument().insertString(position, completion, null);
				getTextField().setCaretPosition(position + completion.length());
				getTextField().moveCaretPosition(position);
				mode = Mode.COMPLETION;
			} catch (BadLocationException e) {
			}
		}
	}

	private class CommitAction extends AbstractAction {

		private static final long serialVersionUID = 98076970931098392L;

		public void actionPerformed(ActionEvent ev) {
			try {
				if (mode == Mode.COMPLETION) {
					int pos = getTextField().getSelectionEnd();
					getTextField().getDocument().insertString(pos, "" "", null);
					getTextField().setCaretPosition(pos + 1);
					mode = Mode.INSERT;
				} else {
					getTextField().replaceSelection("""");
					getTextField().postActionEvent();
				}
			} catch (BadLocationException e) {
			}
		}
	}

	private Mode mode = Mode.INSERT;

	private ImmutableList<String> dictionary = ImmutableList.of();
	private ImmutableSet<Character> stopCharacter = ImmutableSet.of('.', '\""', '=', '>', '<', '(', ')');

	public ProMAutoCompletingTextField() {
		super();
		init();
	}

	public ProMAutoCompletingTextField(String initial, String hint) {
		super(initial, hint);
		init();
	}

	public ProMAutoCompletingTextField(String initial) {
		super(initial);
		init();
	}

	private void init() {
		getTextField().getDocument().addDocumentListener(new DocumentListenerImpl());
		InputMap im = getTextField().getInputMap();
		ActionMap am = getTextField().getActionMap();
		im.put(KeyStroke.getKeyStroke(""ENTER""), ""commit"");
		am.put(""commit"", new CommitAction());
	}

	public ImmutableList<String> getDictionary() {
		return dictionary;
	}

	public void setDictionary(List<String> dictionary) {
		this.dictionary = Ordering.natural().immutableSortedCopy(dictionary);
	}

	public ImmutableSet<Character> getStopCharacter() {
		return stopCharacter;
	}

	protected boolean isStopCharacter(char c) {
		return stopCharacter.contains(c);
	}

	public void setStopCharacter(Set<Character> stopCharacter) {
		this.stopCharacter = ImmutableSet.copyOf(stopCharacter);
	}

}"
ProMCheckBoxWithComboBox.java,widget,"package org.processmining.framework.util.ui.widgets;

import java.awt.BorderLayout;

/**
 * @author michael
 * @param <T>
 * 
 */
public class ProMCheckBoxWithComboBox<T> extends ProMCheckBoxWithPanel {

	/**
	 * 
	 */
	private static final long serialVersionUID = 5157157777410895997L;

	private ProMComboBox<T> comboBox;

	/**
	 * @param checked
	 * @param hideIfNotChecked
	 * @param items
	 */
	public ProMCheckBoxWithComboBox(final boolean checked, final boolean hideIfNotChecked, final Iterable<T> items) {
		this(checked, hideIfNotChecked, ProMComboBox.toArray(items));
	}

	/**
	 * @param checked
	 * @param hideIfNotChecked
	 * @param items
	 */
	public ProMCheckBoxWithComboBox(final boolean checked, final boolean hideIfNotChecked, final Object[]... items) {
		super(checked, hideIfNotChecked);

		comboBox = new ProMComboBox<T>(items);
		getPanel().setLayout(new BorderLayout());
		getPanel().add(comboBox, BorderLayout.CENTER);

	}

	/**
	 * @param checked
	 * @param items
	 */
	public ProMCheckBoxWithComboBox(final boolean checked, final Iterable<T> items) {
		this(checked, true, items);
	}

	/**
	 * @param checked
	 * @param items
	 */
	public ProMCheckBoxWithComboBox(final boolean checked, final T[]... items) {
		this(checked, true, items);
	}

	/**
	 * @param items
	 */
	public ProMCheckBoxWithComboBox(final Iterable<T> items) {
		this(true, true, items);
	}

	/**
	 * @param items
	 */
	public ProMCheckBoxWithComboBox(final T[]... items) {
		this(true, true, items);
	}

	/**
	 * @return
	 */
	public ProMComboBox<T> getComboBox() {
		return comboBox;
	}

	/**
	 * @return
	 */
	public int getSelectedIndex() {
		return comboBox.getSelectedIndex();
	}

	/**
	 * @return
	 */
	public Object getSelectedItem() {
		return comboBox.getSelectedItem();
	}

	/**
	 * @param index
	 */
	public void setSelectedIndex(final int index) {
		comboBox.setSelectedIndex(index);
	}

	/**
	 * @param item
	 */
	public void setSelectedItem(final Object item) {
		comboBox.setSelectedItem(item);
	}
}
"
ProMCheckBoxWithPanel.java,widget,"package org.processmining.framework.util.ui.widgets;

import java.awt.BorderLayout;
import java.awt.Dimension;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

import javax.swing.JCheckBox;
import javax.swing.JPanel;

import com.fluxicon.slickerbox.factory.SlickerFactory;

/**
 * @author michael
 * 
 */
public class ProMCheckBoxWithPanel extends JPanel {

	/**
	 * 
	 */
	private static final long serialVersionUID = -1605514658715195558L;
	private final JCheckBox checkBox;
	private final JPanel panel;

	/**
	 * 
	 */
	public ProMCheckBoxWithPanel() {
		this(true, true);
	}

	/**
	 * @param checked
	 */
	public ProMCheckBoxWithPanel(final boolean checked) {
		this(checked, true);
	}

	/**
	 * @param checked
	 * @param hideIfNotChecked
	 */
	public ProMCheckBoxWithPanel(final boolean checked, final boolean hideIfNotChecked) {

		panel = new JPanel();
		checkBox = SlickerFactory.instance().createCheckBox("""", checked);

		if (hideIfNotChecked) {
			checkBox.addActionListener(new ActionListener() {

				@Override
				public void actionPerformed(final ActionEvent e) {
					toggleVisibility();
				}
			});
		}

		setLayout(new BorderLayout());
		setOpaque(false);

		checkBox.setPreferredSize(new Dimension(30, 30));
		checkBox.setMinimumSize(checkBox.getPreferredSize());
		checkBox.setMaximumSize(checkBox.getPreferredSize());

		//panel.setMinimumSize(new Dimension(600,30));
		panel.setPreferredSize(new Dimension(530, 30));

		this.add(checkBox, BorderLayout.WEST);
		this.add(panel, BorderLayout.EAST);
	}

	/**
	 * @return
	 */
	public JCheckBox getCheckBox() {
		return checkBox;
	}

	/**
	 * @return
	 */
	public boolean isSelected() {
		return checkBox.isSelected();
	}

	/**
	 * @param checked
	 */
	public void setSelected(final boolean checked) {
		checkBox.setSelected(checked);
	}

	private void toggleVisibility() {
		panel.setVisible(!panel.isVisible());
	}

	protected JPanel getPanel() {
		return panel;
	}
}
"
ProMCheckBoxWithTextField.java,widget,"package org.processmining.framework.util.ui.widgets;

import java.awt.BorderLayout;

/**
 * @author michael
 * 
 */
public class ProMCheckBoxWithTextField extends ProMCheckBoxWithPanel {

	/**
	 * 
	 */
	private static final long serialVersionUID = -3331182375174654223L;
	private final ProMTextField textField;

	/**
	 * 
	 */
	public ProMCheckBoxWithTextField() {
		this(true, true, """");
	}

	/**
	 * @param checked
	 * @param hideIfNotSelected
	 * @param text
	 */
	public ProMCheckBoxWithTextField(final boolean checked, final boolean hideIfNotSelected, final String text) {
		super(checked, hideIfNotSelected);

		textField = new ProMTextField(text);
		getPanel().setLayout(new BorderLayout());
		getPanel().add(textField, BorderLayout.CENTER);

	}

	/**
	 * @param checked
	 * @param text
	 */
	public ProMCheckBoxWithTextField(final boolean checked, final String text) {
		this(checked, true, text);
	}

	/**
	 * @param text
	 */
	public ProMCheckBoxWithTextField(final String text) {
		this(true, true, text);
	}

	/**
	 * @return
	 */
	public String getText() {
		return textField.getText();
	}

	/**
	 * @param text
	 */
	public void setText(final String text) {
		textField.setText(text);
	}

}
"
ProMCheckComboBox.java,widget,"package org.processmining.framework.util.ui.widgets;

import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Rectangle;
import java.util.ArrayList;

import csplugins.id.mapping.ui.CheckComboBox;

/**
 * @author michael
 * 
 */
public class ProMCheckComboBox extends CheckComboBox {

	/**
	 * 
	 */
	private static final long serialVersionUID = 1L;

	/**
	 * @param <T>
	 * @param values
	 * @return
	 */
	public static <T> Object[] toArray(final Iterable<T> values) {
		final ArrayList<T> valueList = new ArrayList<T>();
		for (final T value : values) {
			valueList.add(value);
		}
		return valueList.toArray();
	}

	private final BorderPanel borderPanel;
	private final BorderPanel buttonPanel;

	/**
	 * @param <T>
	 * @param values
	 */
	public <T> ProMCheckComboBox(final Iterable<T> values) {
		this(ProMCheckComboBox.toArray(values));
	}

	/**
	 * @param values
	 */
	public ProMCheckComboBox(final Object[] values) {
		super(values);

		borderPanel = new BorderPanel(15, 3);
		borderPanel.setOpaque(true);
		borderPanel.setBackground(WidgetColors.COLOR_LIST_BG);
		borderPanel.setForeground(WidgetColors.COLOR_ENCLOSURE_BG);
		buttonPanel = new BorderPanel(15, 3);
		buttonPanel.setOpaque(true);
		buttonPanel.setBackground(WidgetColors.COLOR_ENCLOSURE_BG);
		buttonPanel.setForeground(WidgetColors.COLOR_ENCLOSURE_BG);
		setOpaque(false);
		setBackground(WidgetColors.COLOR_LIST_BG);
		setForeground(WidgetColors.COLOR_LIST_FG);
		setMinimumSize(new Dimension(200, 30));
		setMaximumSize(new Dimension(1000, 30));
		setPreferredSize(new Dimension(1000, 30));

		//setUI(new ProMComboBoxUI(this));
	}

	/**
	 * @see javax.swing.JComponent#paintComponent(java.awt.Graphics)
	 */
	@Override
	public void paintComponent(final Graphics g) {
		final Rectangle bounds = getBounds();
		buttonPanel.setBounds(bounds);
		buttonPanel.paintComponent(g);
		final Dimension d = new Dimension();
		d.setSize(bounds.getWidth() - bounds.getHeight(), bounds.getHeight());
		bounds.setSize(d);
		borderPanel.setBounds(bounds);
		borderPanel.paintComponent(g);
		super.paintComponent(g);
	}
}
"
ProMComboBox.java,widget,"package org.processmining.framework.util.ui.widgets;

import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Rectangle;
import java.util.ArrayList;

import javax.swing.ComboBoxModel;
import javax.swing.DefaultComboBoxModel;
import javax.swing.JComboBox;

/**
 * @author michael
 * @param <E>
 * 
 */
@SuppressWarnings(""rawtypes"")
public class ProMComboBox<E> extends JComboBox/* <E> */{

	private static final long serialVersionUID = 1L;

	/**
	 * @param values
	 * @return
	 */
	public static <T> Object[] toArray(final Iterable<T> values) {
		final ArrayList<T> valueList = new ArrayList<T>();
		for (final T value : values) {
			valueList.add(value);
		}
		return valueList.toArray();
	}

	private final BorderPanel borderPanel;
	private final BorderPanel buttonPanel;
	
	@SuppressWarnings(""unchecked"")
	public ProMComboBox(final ComboBoxModel<E> model) {
		super(model);
		borderPanel = new BorderPanel(15, 3);
		borderPanel.setOpaque(true);
		borderPanel.setBackground(WidgetColors.COLOR_LIST_BG);
		borderPanel.setForeground(WidgetColors.COLOR_ENCLOSURE_BG);
		buttonPanel = new BorderPanel(15, 3);
		buttonPanel.setOpaque(true);
		buttonPanel.setBackground(WidgetColors.COLOR_ENCLOSURE_BG);
		buttonPanel.setForeground(WidgetColors.COLOR_ENCLOSURE_BG);
		setOpaque(false);
		setBackground(WidgetColors.COLOR_LIST_BG);
		setForeground(WidgetColors.COLOR_LIST_FG);
		setMinimumSize(new Dimension(200, 30));
		setMaximumSize(new Dimension(1000, 30));
		setPreferredSize(new Dimension(1000, 30));

		setUI(new ProMComboBoxUI(this));
	}
	
	
	public ProMComboBox(final ComboBoxModel<E> model, boolean noSize) {
		this(model);
		resetSizes();
	}

	public ProMComboBox<E> resetSizes() {
		setPreferredSize(null);
		setMaximumSize(null);
		setMinimumSize(null);
		return this;
	}

	/**
	 * @param values
	 */
	public ProMComboBox(final Iterable<E> values) {
		this(ProMComboBox.toArray(values));
	}

	/**
	 * @param values
	 */
	@SuppressWarnings({ ""unchecked"" })
	public ProMComboBox(final Object[] values) {
		this(new DefaultComboBoxModel<E>((E[]) values));
	}

	/**
	 * @param values
	 */
	@SuppressWarnings(""unchecked"")
	public void addAllItems(final Iterable<E> values) {
		for (final E value : values) {
			addItem(value);
		}
	}

	/**
	 * @see javax.swing.JComponent#paintComponent(java.awt.Graphics)
	 */
	@Override
	public void paintComponent(final Graphics g) {
		if (!Boolean.TRUE.equals(getClientProperty(""JComboBox.isTableCellEditor""))) {
			final Rectangle bounds = getBounds();
			buttonPanel.setBounds(bounds);
			buttonPanel.paintComponent(g);
			final Dimension d = new Dimension();
			d.setSize(bounds.getWidth() - bounds.getHeight(), bounds.getHeight());
			bounds.setSize(d);
			borderPanel.setBounds(bounds);
			borderPanel.paintComponent(g);
		}
		super.paintComponent(g);
	}
}
"
ProMComboBoxPopup.java,widget,"package org.processmining.framework.util.ui.widgets;

import java.awt.Color;
import java.awt.Graphics;

import javax.swing.BorderFactory;
import javax.swing.JComboBox;
import javax.swing.JScrollBar;
import javax.swing.ScrollPaneConstants;
import javax.swing.plaf.basic.BasicComboPopup;

import com.fluxicon.slickerbox.ui.SlickerScrollBarUI;

/**
 * @author michael
 * 
 */
public class ProMComboBoxPopup extends BasicComboPopup {

	/**
	 * 
	 */
	private static final long serialVersionUID = 1L;

	/**
	 * @param combo
	 */
	public <E> ProMComboBoxPopup(@SuppressWarnings(""rawtypes"") final JComboBox/*
																			 * <E
																			 * >
																			 */combo) {
		super(combo);
		setBorder(BorderFactory.createLineBorder(WidgetColors.COLOR_ENCLOSURE_BG, 3));
		setOpaque(true);
		setBackground(WidgetColors.COLOR_LIST_BG);
	}

	/**
	 * @see javax.swing.JComponent#paintComponent(java.awt.Graphics)
	 */
	@Override
	public void paintComponent(final Graphics g) {
		super.paintComponent(g);
	}

	@Override
	protected void configureList() {
		super.configureList();
		list.setBackground(WidgetColors.COLOR_LIST_BG);
		list.setForeground(WidgetColors.COLOR_LIST_FG);
		list.setSelectionBackground(WidgetColors.COLOR_LIST_SELECTION_BG);
		list.setSelectionForeground(WidgetColors.COLOR_LIST_SELECTION_FG);
	}

	@Override
	protected void configureScroller() {
		super.configureScroller();
		scroller.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);
		scroller.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_AS_NEEDED);
		final JScrollBar vBar = scroller.getVerticalScrollBar();
		vBar.setUI(new SlickerScrollBarUI(vBar, new Color(0, 0, 0, 0), new Color(160, 160, 160),
				WidgetColors.COLOR_NON_FOCUS, 4, 12));
		vBar.setOpaque(true);
		vBar.setBackground(WidgetColors.COLOR_ENCLOSURE_BG);
	}

}
"
ProMComboBoxTableCellEditor.java,widget,"package org.processmining.framework.util.ui.widgets;

import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.util.Arrays;
import java.util.Collection;

import javax.swing.AbstractCellEditor;
import javax.swing.JTable;
import javax.swing.table.TableCellEditor;

/**
 * @author michael
 * 
 * @param <T>
 */
public class ProMComboBoxTableCellEditor<T> extends AbstractCellEditor implements TableCellEditor {
	/**
		 * 
		 */
	private static final long serialVersionUID = 0;
	private T configured;
	protected ProMComboBox<T> comboBox;

	/**
	 * @param values
	 */
	public ProMComboBoxTableCellEditor(final Collection<T> values) {
		comboBox = new ProMComboBox<T>(values);
		comboBox.addActionListener(new ActionListener() {
			@Override
			@SuppressWarnings(""unchecked"")
			public void actionPerformed(final ActionEvent e) {
				setValue((T) comboBox.getSelectedItem());
			}
		});
	}

	/**
	 * @param values
	 */
	public ProMComboBoxTableCellEditor(final T... values) {
		this(Arrays.asList(values));
	}

	/**
	 * @see javax.swing.CellEditor#getCellEditorValue()
	 */
	@Override
	public Object getCellEditorValue() {
		return configured;
	}

	/**
	 * @see javax.swing.table.TableCellEditor#getTableCellEditorComponent(javax.swing.JTable,
	 *      java.lang.Object, boolean, int, int)
	 */
	@Override
	public ProMComboBox<T> getTableCellEditorComponent(final JTable table, final Object value,
			final boolean isSelected, final int row, final int column) {
		comboBox.setSelectedItem(value);
		return comboBox;
	}

	protected void setValue(final T value) {
		configured = value;
	}
}
"
ProMComboBoxUI.java,widget,"package org.processmining.framework.util.ui.widgets;

import java.awt.Graphics;
import java.awt.Insets;
import java.awt.Rectangle;

import javax.swing.BorderFactory;
import javax.swing.JButton;
import javax.swing.JComboBox;
import javax.swing.JComponent;
import javax.swing.SwingConstants;
import javax.swing.plaf.ComponentUI;
import javax.swing.plaf.basic.BasicArrowButton;
import javax.swing.plaf.basic.BasicComboBoxUI;
import javax.swing.plaf.basic.BasicComboPopup;
import javax.swing.plaf.basic.ComboPopup;

/**
 * @author michael
 * 
 */
public class ProMComboBoxUI extends BasicComboBoxUI {
	/**
	 * @param c
	 * @return
	 */
	@SuppressWarnings(""rawtypes"")
	public static ComponentUI createUI(final JComponent c) {
		return new ProMComboBoxUI((JComboBox/* <?> */) c);
	}

	@SuppressWarnings(""rawtypes"")
	private final JComboBox/* <?> */component;

	/**
	 * @param c
	 */
	@SuppressWarnings(""rawtypes"")
	public ProMComboBoxUI(final JComboBox/* <?> */c) {
		component = c;
	}

	/**
	 * @see javax.swing.plaf.basic.BasicComboBoxUI#configureArrowButton()
	 */
	@Override
	public void configureArrowButton() {
		super.configureArrowButton();
		arrowButton.setBorder(BorderFactory.createEmptyBorder());
	}

	/**
	 * @see javax.swing.plaf.basic.BasicComboBoxUI#paintCurrentValueBackground(java.awt.Graphics,
	 *      java.awt.Rectangle, boolean)
	 */
	@Override
	public void paintCurrentValueBackground(final Graphics g, final Rectangle bounds, final boolean hasFocus) {
	}

	@Override
	protected void configureEditor() {
		super.configureEditor();
		if (editor instanceof JComponent) {
			((JComponent) editor).setBorder(BorderFactory.createEmptyBorder());
			((JComponent) editor).setBackground(WidgetColors.COLOR_LIST_BG);
			((JComponent) editor).setForeground(WidgetColors.COLOR_LIST_FG);
		}
	}

	@Override
	protected JButton createArrowButton() {
		final JButton button = new BasicArrowButton(SwingConstants.SOUTH, WidgetColors.COLOR_ENCLOSURE_BG,
				WidgetColors.COLOR_ENCLOSURE_BG, WidgetColors.COLOR_LIST_FG, WidgetColors.COLOR_ENCLOSURE_BG);
		button.setName(""ComboBox.arrowButton"");
		return button;
	}

	@Override
	protected ComboPopup createPopup() {
		final BasicComboPopup result = new ProMComboBoxPopup(component);
		return result;
	}

	@Override
	protected void installDefaults() {
		super.installDefaults();
		comboBox.setBorder(BorderFactory.createEmptyBorder(5, 8, 5, 8));
	}

	@Override
	protected Rectangle rectangleForCurrentValue() {
		final int width = comboBox.getWidth();
		final int height = comboBox.getHeight();
		final Insets insets = getInsets();
		int buttonSize = height - (insets.top + insets.bottom);
		if (arrowButton != null) {
			buttonSize = arrowButton.getWidth();
		}
		return new Rectangle(insets.left + 3, insets.top - 1, width
				- (insets.left + insets.right + buttonSize + 3 + 3 + 10), height - (insets.top + insets.bottom) + 1);
	}

}
"
ProMComboBoxWithTextField.java,widget,"package org.processmining.framework.util.ui.widgets;

import java.awt.BorderLayout;
import java.awt.Dimension;
import java.util.Collection;

import javax.swing.JPanel;

/**
 * @author michael
 * 
 */
public class ProMComboBoxWithTextField extends JPanel {

	/**
	 * 
	 */
	private static final long serialVersionUID = 3750834515241351840L;
	private final ProMComboBox<?> comboBox;
	private final ProMTextField textField;

	/**
	 * @param items
	 */
	public ProMComboBoxWithTextField(final Collection<Object> items) {
		this(items.toArray());
	}

	/**
	 * @param items
	 * @param text
	 */
	public ProMComboBoxWithTextField(final Collection<Object> items, final String text) {
		this(items.toArray(), text);
	}

	/**
	 * @param items
	 */
	public ProMComboBoxWithTextField(final Object[] items) {
		this(items, """");
	}

	/**
	 * @param items
	 * @param text
	 */
	public ProMComboBoxWithTextField(final Object[] items, final String text) {

		comboBox = new ProMComboBox<Object>(items);
		textField = new ProMTextField(text);

		comboBox.setMinimumSize(new Dimension(50, 30));
		comboBox.setPreferredSize(new Dimension(150, 30));

		textField.setMinimumSize(new Dimension(50, 30));
		textField.setPreferredSize(new Dimension(250, 30));

		setLayout(new BorderLayout());
		setOpaque(false);

		this.add(comboBox, BorderLayout.WEST);
		this.add(textField, BorderLayout.EAST);
	}

	/**
	 * @return
	 */
	public ProMComboBox<?> getComboBox() {
		return comboBox;
	}

	/**
	 * @return
	 */
	public int getSelectedIndex() {
		return comboBox.getSelectedIndex();
	}

	/**
	 * @return
	 */
	public Object getSelectedItem() {
		return comboBox.getSelectedItem();
	}

	/**
	 * @return
	 */
	public String getText() {
		return textField.getText();
	}

	/**
	 * @return
	 */
	public ProMTextField getTextField() {
		return textField;
	}

	/**
	 * @param index
	 */
	public void setSelectedIndex(final int index) {
		comboBox.setSelectedIndex(index);
	}

	/**
	 * @param item
	 */
	public void setSelectedItem(final Object item) {
		comboBox.setSelectedItem(item);
	}

	/**
	 * @param text
	 */
	public void setText(final String text) {
		textField.setText(text);
	}

}
"
ProMComboCheckBox.java,widget,"package org.processmining.framework.util.ui.widgets;

import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Rectangle;
import java.util.Collection;

import csplugins.id.mapping.ui.CheckComboBox;

/**
 * @author Massimiliano de Leoni
 * 
 */
public class ProMComboCheckBox extends CheckComboBox {

	private static final long serialVersionUID = 1L;

	private BorderPanel borderPanel;
	private BorderPanel buttonPanel;

	public ProMComboCheckBox(@SuppressWarnings(""rawtypes"") Collection objs) {
		super(objs);
	}

	public ProMComboCheckBox(Object[] attributes, boolean selected) {
		super(attributes, selected);
		init();
	}

	public ProMComboCheckBox(String[] attributes, boolean selected) {
		super(attributes, selected);
		init();
	}

	private final void init() {
		borderPanel = new BorderPanel(15, 3);
		borderPanel.setOpaque(true);
		borderPanel.setBackground(WidgetColors.COLOR_LIST_BG);
		borderPanel.setForeground(WidgetColors.COLOR_ENCLOSURE_BG);
		buttonPanel = new BorderPanel(15, 3);
		buttonPanel.setOpaque(true);
		buttonPanel.setBackground(WidgetColors.COLOR_ENCLOSURE_BG);
		buttonPanel.setForeground(WidgetColors.COLOR_ENCLOSURE_BG);
		setOpaque(false);
		setBackgroundNotSelected(WidgetColors.COLOR_LIST_BG);
		setForegroundNotSelected(WidgetColors.COLOR_LIST_FG);
		setBackgroundSelected(WidgetColors.COLOR_LIST_SELECTION_BG);
		setForegroundSelected(WidgetColors.COLOR_LIST_SELECTION_FG);
		setMinimumSize(new Dimension(200, 30));
		setMaximumSize(new Dimension(1000, 30));
		setPreferredSize(new Dimension(1000, 30));

		setUI(new ProMComboBoxUI(this));
	}

	@Override
	public void paintComponent(final Graphics g) {
		if (!Boolean.TRUE.equals(getClientProperty(""JComboBox.isTableCellEditor""))) {
			final Rectangle bounds = getBounds();
			buttonPanel.setBounds(bounds);
			buttonPanel.paintComponent(g);
			final Dimension d = new Dimension();
			d.setSize(bounds.getWidth() - bounds.getHeight(), bounds.getHeight());
			bounds.setSize(d);
			borderPanel.setBounds(bounds);
			borderPanel.paintComponent(g);
		}
		super.paintComponent(g);
	}
}
"
ProMHeaderPanel.java,widget,"package org.processmining.framework.util.ui.widgets;

import java.awt.Dimension;

import javax.swing.Box;
import javax.swing.BoxLayout;

import com.fluxicon.slickerbox.components.RoundedPanel;

/**
 * Panel with a header
 * 
 * @author mwesterg
 * 
 */
public class ProMHeaderPanel extends RoundedPanel {

	/**
	 * 
	 */
	private static final long serialVersionUID = 1L;

	/**
	 * @param title
	 */
	public ProMHeaderPanel(final String title) {
		super(15, 0, 3);
		setMinimumSize(new Dimension(200, 20));
		setMaximumSize(new Dimension(1000, 1000));
		setPreferredSize(new Dimension(200, 300));
		setBackground(WidgetColors.PROPERTIES_BACKGROUND);
		setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));
		if (title != null) {
			add(new LeftAlignedHeader(title));
			add(Box.createVerticalStrut(15));
		}
	}

}
"
ProMList.java,widget,"package org.processmining.framework.util.ui.widgets;

import java.awt.Component;
import java.awt.Dimension;
import java.awt.event.MouseListener;
import java.util.Arrays;
import java.util.List;

import javax.swing.Box;
import javax.swing.BoxLayout;
import javax.swing.JLabel;
import javax.swing.JList;
import javax.swing.ListModel;
import javax.swing.ScrollPaneConstants;
import javax.swing.SwingConstants;
import javax.swing.event.ListSelectionListener;

import com.fluxicon.slickerbox.components.RoundedPanel;

/**
 * List (JList) with SlickerBox L&F
 * 
 * @author mwesterg
 * @param <E>
 * 
 */
public class ProMList<E> extends RoundedPanel {

	/**
	 * 
	 */
	private static final long serialVersionUID = 1L;
	@SuppressWarnings(""rawtypes"")
	private final JList/* <E> */jList;

	/**
	 * @param title
	 */
	@SuppressWarnings(""rawtypes"")
	public ProMList(final String title) {
		super(10, 5, 0);
		jList = new JList/* <E> */();
		setup(title);
	}

	/**
	 * @param title
	 * @param providers
	 */
	@SuppressWarnings({ ""unchecked"", ""rawtypes"" })
	public ProMList(final String title, final ListModel/* <E> */providers) {
		super(10, 5, 0);
		jList = new JList/* <E> */(providers);
		setup(title);
	}

	/**
	 * @param l
	 */
	public void addListSelectionListener(final ListSelectionListener l) {
		jList.addListSelectionListener(l);
	}

	/**
	 * @see java.awt.Component#addMouseListener(java.awt.event.MouseListener)
	 */
	@Override
	public void addMouseListener(final MouseListener l) {
		jList.addMouseListener(l);
	}

	/**
	 * @return
	 */
	@Deprecated
	public Object[] getSelectedValues() {
		return jList.getSelectedValues();
	}

	/**
	 * @return
	 */
	@SuppressWarnings({ ""unchecked"", ""deprecation"" })
	public List<E> getSelectedValuesList() {
		// Major fuck you to Hudson using an antiquated version of Java
		try {
			return (List<E>) JList.class.getMethod(""getSelectedValuesList"").invoke(this);
		} catch (final Exception e) {
			return (List<E>) Arrays.asList(jList.getSelectedValues());
		}
	}

	/**
	 * @param l
	 */
	public void removeListSelectionListener(final ListSelectionListener l) {
		jList.removeListSelectionListener(l);
	}

	/**
	 * @see java.awt.Component#removeMouseListener(java.awt.event.MouseListener)
	 */
	@Override
	public void removeMouseListener(final MouseListener l) {
		jList.removeMouseListener(l);
	}

	/**
	 * @param index
	 */
	public void setSelectedIndex(final int index) {
		jList.setSelectedIndex(index);
	}

	public void setSelectedIndices(final int[] index) {
		jList.setSelectedIndices(index);
	}

	/**
	 * @param selectedValues
	 */
	public void setSelection(final Iterable<Object> selectedValues) {
		jList.clearSelection();
		for (final Object value : selectedValues) {
			jList.setSelectedValue(value, true);
		}
	}

	/**
	 * @param selectedValues
	 */
	public void setSelection(final Object... selectedValues) {
		jList.clearSelection();
		for (final Object value : selectedValues) {
			jList.setSelectedValue(value, true);
		}
	}

	/**
	 * @param selectionMode
	 */
	public void setSelectionMode(final int selectionMode) {
		jList.setSelectionMode(selectionMode);
	}
	
	@SuppressWarnings(""rawtypes"") // this class is still java 6 :(
	public JList getList() {
		return jList;
	}

	private void setup(final String title) {
		jList.setBackground(WidgetColors.COLOR_LIST_BG);
		jList.setForeground(WidgetColors.COLOR_LIST_FG);
		jList.setSelectionBackground(WidgetColors.COLOR_LIST_SELECTION_BG);
		jList.setSelectionForeground(WidgetColors.COLOR_LIST_SELECTION_FG);

		final ProMScrollPane scroller = new ProMScrollPane(jList);
		scroller.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS);
		scroller.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);

		final JLabel providersLabel = new JLabel(title);
		providersLabel.setOpaque(false);
		providersLabel.setForeground(WidgetColors.COLOR_LIST_SELECTION_FG);
		providersLabel.setFont(providersLabel.getFont().deriveFont(13f));
		providersLabel.setAlignmentX(Component.CENTER_ALIGNMENT);
		providersLabel.setHorizontalAlignment(SwingConstants.CENTER);
		providersLabel.setHorizontalTextPosition(SwingConstants.CENTER);

		setBackground(WidgetColors.COLOR_ENCLOSURE_BG);
		setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));
		add(providersLabel);
		add(Box.createVerticalStrut(8));
		add(scroller);
		setMinimumSize(new Dimension(200, 100));
		setMaximumSize(new Dimension(1000, 1000));
		setPreferredSize(new Dimension(1000, 200));
	}
}
"
ProMListSortableWithComboBox.java,widget,"package org.processmining.framework.util.ui.widgets;
import java.awt.BorderLayout;
import java.awt.datatransfer.DataFlavor;
import java.awt.datatransfer.StringSelection;
import java.awt.datatransfer.Transferable;
import java.awt.dnd.DnDConstants;
import java.awt.dnd.DragGestureEvent;
import java.awt.dnd.DragGestureListener;
import java.awt.dnd.DragSource;
import java.awt.dnd.DragSourceDragEvent;
import java.awt.dnd.DragSourceDropEvent;
import java.awt.dnd.DragSourceEvent;
import java.awt.dnd.DragSourceListener;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.util.ArrayList;
import java.util.List;

import javax.swing.BoxLayout;
import javax.swing.ComboBoxModel;
import javax.swing.DefaultListModel;
import javax.swing.DropMode;
import javax.swing.JButton;
import javax.swing.JLabel;
import javax.swing.JList;
import javax.swing.JPanel;
import javax.swing.ListModel;
import javax.swing.ScrollPaneConstants;
import javax.swing.TransferHandler;

import com.fluxicon.slickerbox.components.SlickerButton;


/**
 * JList with ProM look & feel with a {@link ProMComboBox} on top of it that
 * allows to add elements to the list.
 */
public class ProMListSortableWithComboBox<T> extends JPanel {

	private static class DragListenerImpl<T> implements DragSourceListener, DragGestureListener {

		private final JList<T> list;
		private final DragSource ds = new DragSource();

		public DragListenerImpl(JList<T> list) {
			this.list = list;
			ds.createDefaultDragGestureRecognizer(list, DnDConstants.ACTION_MOVE, this);
		}

		public void dragGestureRecognized(DragGestureEvent dge) {
			StringSelection transferable = new StringSelection(Integer.toString(list.getSelectedIndex()));
			ds.startDrag(dge, DragSource.DefaultCopyDrop, transferable, this);
		}

		public void dragEnter(DragSourceDragEvent dsde) {
		}

		public void dragExit(DragSourceEvent dse) {
		}

		public void dragOver(DragSourceDragEvent dsde) {
		}

		public void dragDropEnd(DragSourceDropEvent dsde) {
		}

		public void dropActionChanged(DragSourceDragEvent dsde) {
		}
	}

	private static class DropHandlerImpl<T> extends TransferHandler {

		private static final long serialVersionUID = -3468373344687124791L;

		private final DefaultListModel<T> listModel;

		public DropHandlerImpl(DefaultListModel<T> listModel) {
			this.listModel = listModel;
		}

		public boolean canImport(TransferHandler.TransferSupport support) {
			if (!support.isDataFlavorSupported(DataFlavor.stringFlavor)) {
				return false;
			}
			JList.DropLocation dl = (JList.DropLocation) support.getDropLocation();
			if (dl.getIndex() == -1) {
				return false;
			} else {
				return true;
			}
		}

		public boolean importData(TransferHandler.TransferSupport support) {
			if (!canImport(support)) {
				return false;
			}

			Transferable transferable = support.getTransferable();
			String indexString;
			try {
				indexString = (String) transferable.getTransferData(DataFlavor.stringFlavor);
			} catch (Exception e) {
				return false;
			}

			int sourceIndex = Integer.parseInt(indexString);
			JList.DropLocation dl = (JList.DropLocation) support.getDropLocation();
			int dropTargetIndex = dl.getIndex();
			T element = listModel.remove(sourceIndex);
			if (sourceIndex < dropTargetIndex) {
				listModel.insertElementAt(element, dropTargetIndex - 1);
			} else {
				listModel.insertElementAt(element, dropTargetIndex);
			}
			return true;
		}
	}

	private static final long serialVersionUID = -3989998064589278170L;

	private final JLabel selectedItemsText;
	private final JList<T> list;
	private final ProMComboBox<T> comboBox;
	private final DefaultListModel<T> listModel;
	private boolean isMultiSelection = false;
	
	public ProMListSortableWithComboBox(ComboBoxModel<T> comboBoxModel) {
		super();
		setOpaque(false);
		JPanel controlPanel = new JPanel();
		controlPanel.setOpaque(false);
		controlPanel.setLayout(new BorderLayout());
		comboBox = new ProMComboBox<>(comboBoxModel, true);
		comboBox.addActionListener(new ActionListener() {
			
			@SuppressWarnings(""unchecked"")
			public void actionPerformed(ActionEvent e) {
				if (!isMultiSelection) {
					listModel.clear();
					listModel.addElement((T) comboBox.getSelectedItem());
				}
			}
		});
		controlPanel.add(comboBox, BorderLayout.CENTER);
		
		JPanel buttonPanel = new JPanel();
		buttonPanel.setOpaque(false);
		buttonPanel.setLayout(new BoxLayout(buttonPanel, BoxLayout.X_AXIS));
		
		JButton addButton = new SlickerButton(""+"");
		addButton.setAlignmentY(CENTER_ALIGNMENT);
		addButton.addActionListener(new ActionListener() {
			
			@SuppressWarnings(""unchecked"")
			public void actionPerformed(ActionEvent e) {
				isMultiSelection = true;
				listModel.addElement((T) comboBox.getSelectedItem());
			}
		});
		buttonPanel.add(addButton);
		JButton removeButton = new SlickerButton(""-"");
		removeButton.setAlignmentY(CENTER_ALIGNMENT);
		removeButton.addActionListener(new ActionListener() {
			
			public void actionPerformed(ActionEvent e) {
				isMultiSelection = true;
				if (list.getSelectedIndex() == -1) {
					// Just remove the last one
					if (list.getModel().getSize() >= 1) {
						listModel.remove(list.getModel().getSize()-1);
					}
				} else {
					listModel.removeElement(list.getSelectedValue());	
				}				
			}
		});
		buttonPanel.add(removeButton);
		controlPanel.add(buttonPanel, BorderLayout.EAST);

		listModel = new DefaultListModel<>();
		list = new JList<>(listModel);
		list.addKeyListener(new KeyListener() {

			public void keyTyped(KeyEvent e) {
			}

			public void keyReleased(KeyEvent e) {
				if (e.getKeyCode() == KeyEvent.VK_DELETE || e.getKeyCode() == KeyEvent.VK_BACK_SPACE) {
					for (int i : list.getSelectedIndices()) {
						listModel.remove(i);
					}
				}
			}

			public void keyPressed(KeyEvent e) {
			}

		});
		list.setDragEnabled(true);
		list.setDropMode(DropMode.INSERT);
		list.setTransferHandler(new DropHandlerImpl<>(listModel));
		list.setBackground(WidgetColors.COLOR_LIST_BG);
		list.setForeground(WidgetColors.COLOR_LIST_FG);
		list.setSelectionBackground(WidgetColors.COLOR_LIST_SELECTION_BG);
		list.setSelectionForeground(WidgetColors.COLOR_LIST_SELECTION_FG);

		final ProMScrollPane scroller = new ProMScrollPane(list);
		scroller.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_AS_NEEDED);
		scroller.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_AS_NEEDED);

		new DragListenerImpl<>(list);
		
		JPanel topPanel = new JPanel(new BorderLayout());
		topPanel.setOpaque(false);
		selectedItemsText = new JLabel(""Selected items"");
		getSelectedItemsText().setAlignmentX(CENTER_ALIGNMENT);
		topPanel.add(controlPanel, BorderLayout.CENTER);
		topPanel.add(getSelectedItemsText(), BorderLayout.SOUTH);
		
		setLayout(new BorderLayout());
		add(topPanel, BorderLayout.NORTH);
		add(scroller, BorderLayout.CENTER);
	}

	public JList<T> getList() {
		return list;
	}

	public ProMComboBox<T> getComboBox() {
		return comboBox;
	}

	/**
	 * @return the ordered elements currently in the {@link JList}
	 */
	public List<T> getElements() {
		ArrayList<T> elements = new ArrayList<>();
		for (int i = 0; i < listModel.getSize(); i++) {
			elements.add(listModel.get(i));
		}
		return elements;
	}

	public void addElement(T element) {
		listModel.addElement(element);
	}

	public ListModel<T> getListModel() {
		return listModel;
	}

	public JLabel getSelectedItemsText() {
		return selectedItemsText;
	}

}"
ProMPasswordField.java,widget,"package org.processmining.framework.util.ui.widgets;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.event.ActionListener;
import java.awt.event.FocusListener;
import java.awt.event.KeyListener;

import javax.swing.JPasswordField;
import javax.swing.text.Document;

import org.processmining.framework.util.ui.widgets.BorderPanel;
import org.processmining.framework.util.ui.widgets.WidgetColors;

/**
 * PasswordField with SlickerBox L&F
 * Built using the PromTextField as pattern
 * 
 * @author shernandez
 * 
 */
public class ProMPasswordField extends BorderPanel {

	/**
	 * 
	 */
	private static final long serialVersionUID = 1L;
	private final JPasswordField passwordField;

	/**
	 * 
	 */
	public ProMPasswordField() {
		super(15, 3);
		setLayout(new BorderLayout());
		setOpaque(true);
		setBackground(WidgetColors.COLOR_LIST_BG);
		setForeground(WidgetColors.COLOR_ENCLOSURE_BG);
		passwordField = new JPasswordField();
		add(passwordField, BorderLayout.CENTER);
		passwordField.setBorder(null);
		passwordField.setOpaque(true);
		passwordField.setBackground(WidgetColors.COLOR_LIST_BG);
		passwordField.setForeground(WidgetColors.COLOR_LIST_SELECTION_FG);
		passwordField.setSelectionColor(WidgetColors.COLOR_LIST_SELECTION_BG);
		passwordField.setSelectedTextColor(WidgetColors.COLOR_LIST_SELECTION_FG);
		passwordField.setCaretColor(WidgetColors.COLOR_LIST_SELECTION_FG);
		setMinimumSize(new Dimension(200, 30));
		setMaximumSize(new Dimension(1000, 30));
		setPreferredSize(new Dimension(1000, 30));
	}

	/**
	 * @param initial
	 */
	public ProMPasswordField(final String initial) {
		this();
		setText(initial);
	}

	/**
	 * @param listener
	 */
	public void addActionListener(final ActionListener listener) {
		passwordField.addActionListener(listener);
	}

	/**
	 * @see java.awt.Component#addFocusListener(java.awt.event.FocusListener)
	 */
	@Override
	public void addFocusListener(final FocusListener listener) {
		passwordField.addFocusListener(listener);
	}

	/**
	 * @see java.awt.Component#addKeyListener(java.awt.event.KeyListener)
	 */
	@Override
	public void addKeyListener(final KeyListener listener) {
		passwordField.addKeyListener(listener);
	}

	/**
	 * @return
	 */
	public Document getDocument() {
		return passwordField.getDocument();
	}

	/**
	 * @return
	 */
	public String getText() {
		return passwordField.getText();
	}

	/**
	 * @param text
	 */
	public void insertText(final String text) {
		final int position = passwordField.getCaretPosition();
		passwordField.setText(passwordField.getText().substring(0, position) + text + passwordField.getText().substring(position));
	}

	/**
	 * @param listener
	 */
	public void removeActionListener(final ActionListener listener) {
		passwordField.removeActionListener(listener);
	}

	/**
	 * @see java.awt.Component#removeFocusListener(java.awt.event.FocusListener)
	 */
	@Override
	public void removeFocusListener(final FocusListener listener) {
		passwordField.removeFocusListener(listener);
	}

	/**
	 * @param editable
	 */
	public void setEditable(final boolean editable) {
		passwordField.setEditable(editable);
	}

	/**
	 * @param text
	 */
	public void setText(final String text) {
		passwordField.setText(text);
	}

	/**
	 * @param isOkay
	 */
	public void visualizeStatus(final boolean isOkay) {
		final Color bg = isOkay ? WidgetColors.COLOR_LIST_BG : WidgetColors.COLOR_LIST_SELECTION_BG;
		super.setBackground(bg);
		passwordField.setBackground(bg);
		getParent().invalidate();
		getParent().repaint();
	}
}
"
ProMPropertiesExpertModePanel.java,widget,"package org.processmining.framework.util.ui.widgets;

import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import javax.swing.JCheckBox;
import javax.swing.JComponent;

import com.fluxicon.slickerbox.factory.SlickerFactory;

/**
 * A {@link ProMPropertiesPanel} with a switch that shows/hides a set of
 * 'expert' properties. Use {@link #addExpertProperty(JComponent)} to add these
 * 'expert' properties.
 * 
 * @author F. Mannhardt
 * 
 */
public class ProMPropertiesExpertModePanel extends ProMPropertiesPanel {

	private static final long serialVersionUID = -8333719879782883891L;

	private static String DEFAULT_EXPERT_MODE_TEXT = ""Show Expert Options"";
	private static final String EXPERT_MODE_HEADER = ""------------ EXPERT CONFIGURATION OPTIONS ------------"";

	private final List<JComponent> expertProperties;
	private JCheckBox expertSwitch;

	private boolean showExpertSwitch;
	private String expertPropertiesText;

	public ProMPropertiesExpertModePanel(final String title) {
		this(title, true, DEFAULT_EXPERT_MODE_TEXT);
	}

	public ProMPropertiesExpertModePanel(final String title, final boolean showExpertSwitch,
			final String expertSwitchText) {
		super(title);
		this.showExpertSwitch = showExpertSwitch;
		this.expertPropertiesText = expertSwitchText;
		this.expertProperties = new ArrayList<JComponent>();
	}

	public JCheckBox addCheckBox(final String name, final boolean value, final boolean isExpert) {
		final JCheckBox checkBox = SlickerFactory.instance().createCheckBox(null, value);
		return addProperty(name, checkBox, isExpert);
	}

	public ProMTextField addTextField(final String name, final String value, final boolean isExpertProperty) {
		return addProperty(name, new ProMTextField(value), isExpertProperty);
	}

	public <E> ProMComboBox<E> addComboBox(final String name, final Iterable<E> values, final boolean isExpertProperty) {
		return addProperty(name, new ProMComboBox<E>(values), isExpertProperty);
	}

	public <E> ProMComboBox<E> addComboBox(final String name, final E[] values, final boolean isExpertProperty) {
		return addProperty(name, new ProMComboBox<E>(values), isExpertProperty);
	}

	public <T extends JComponent> T addProperty(final String name, final T component, final boolean isExpertProperty) {
		if (isExpertProperty && showExpertSwitch && expertSwitch == null) {
			addExpertSwitch();
		}
		T c = super.addProperty(name, component);
		if (isExpertProperty) {
			addExpertProperty(c);
		}
		return c;
	}

	public void showExpertProperties() {
		for (JComponent c : getExpertProperties()) {
			c.setVisible(true);
		}
	}

	public void hideExpertProperties() {
		for (JComponent c : getExpertProperties()) {
			c.getParent().setVisible(false);
		}
	}

	public void toggleExpertPanel() {
		for (JComponent c : getExpertProperties()) {
			c.getParent().setVisible(!c.getParent().isVisible());
		}
	}

	/**
	 * @return {@link List} of all properties that are only visible in expert
	 *         mode
	 */
	public List<JComponent> getExpertProperties() {
		return Collections.unmodifiableList(expertProperties);
	}

	public void addExpertProperty(JComponent c) {
		expertProperties.add(c);
		// Hide component initially
		c.getParent().setVisible(false);
	}

	private void addExpertSwitch() {
		expertSwitch = addCheckBox(expertPropertiesText, false);
		expertSwitch.addActionListener(new ActionListener() {

			public void actionPerformed(ActionEvent e) {
				toggleExpertPanel();
			}
		});
		addProperty(null, SlickerFactory.instance().createLabel(EXPERT_MODE_HEADER), true);
	}

}
"
ProMPropertiesPanel.java,widget,"package org.processmining.framework.util.ui.widgets;

import java.awt.Color;
import java.awt.Component;
import java.awt.Container;
import java.awt.Dimension;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;

import javax.swing.AbstractButton;
import javax.swing.Box;
import javax.swing.BoxLayout;
import javax.swing.JCheckBox;
import javax.swing.JComponent;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.ScrollPaneConstants;
import javax.swing.text.JTextComponent;

import com.fluxicon.slickerbox.components.RoundedPanel;
import com.fluxicon.slickerbox.factory.SlickerFactory;

/**
 * 
 * @author mwesterg
 * @author shernandez d.d. 20150602 add passwordfield
 * 
 */
public class ProMPropertiesPanel extends ProMHeaderPanel {

	/**
	 * 
	 */
	private static final long serialVersionUID = 1L;

	private boolean first = true;

	private final JPanel properties;

	/**
	 * @param title
	 */
	public ProMPropertiesPanel(final String title) {
		super(title);
		properties = new ProMScrollablePanel();
		properties.setOpaque(false);
		properties.setLayout(new BoxLayout(properties, BoxLayout.Y_AXIS));
		final ProMScrollPane scrollPane = new ProMScrollPane(properties);
		scrollPane.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_AS_NEEDED);
		scrollPane.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);
		scrollPane.getViewport().setBackground(getBackground());
		add(scrollPane);
	}

	/**
	 * @param name
	 * @return
	 */
	public JCheckBox addCheckBox(final String name) {
		return addCheckBox(name, false);
	}

	/**
	 * @param name
	 * @param value
	 * @return
	 */
	public JCheckBox addCheckBox(final String name, final boolean value) {
		final JCheckBox checkBox = SlickerFactory.instance().createCheckBox(null, value);
		return addProperty(name, checkBox);
	}

	/**
	 * @param name
	 * @param values
	 * @return
	 */
	public <E> ProMComboBox<E> addComboBox(final String name, final E[] values) {
		return addProperty(name, new ProMComboBox<E>(values));
	}

	/**
	 * @param name
	 * @param values
	 * @return
	 */
	public <E> ProMComboBox<E> addComboBox(final String name, final Iterable<E> values) {
		return addProperty(name, new ProMComboBox<E>(values));
	}

	/**
	 * @param <T>
	 * @param name
	 * @param component
	 * @return
	 */
	public <T extends JComponent> T addProperty(final String name, final T component) {
		if (!first) {
			properties.add(Box.createVerticalStrut(3));
		} else {
			first = false;
		}
		properties.add(packInfo(name, component));
		return component;
	}

	/**
	 * @param name
	 * @return
	 */
	public ProMTextField addTextField(final String name) {
		return addTextField(name, """");
	}

	/**
	 * @param name
	 * @param value
	 * @return
	 */
	public ProMTextField addTextField(final String name, final String value) {
		final ProMTextField component = new ProMTextField();
		component.setText(value);
		return addProperty(name, component);
	}

	private Component findComponent(final Component component) {
		if (component instanceof AbstractButton) {
			return component;
		}
		if (component instanceof JTextComponent) {
			return component;
		}
		if (component instanceof Container) {
			for (final Component child : ((Container) component).getComponents()) {
				final Component result = findComponent(child);
				if (result != null) {
					return result;
				}
			}
		}
		return null;
	}

	private void installHighlighter(final Component component, final RoundedPanel target) {
		component.addMouseListener(new MouseListener() {
			@Override
			public void mouseClicked(final MouseEvent arg0) { /* ignore */
			}

			@Override
			public void mouseEntered(final MouseEvent arg0) {
				target.setBackground(new Color(60, 60, 60, 240));
				target.repaint();
			}

			@Override
			public void mouseExited(final MouseEvent arg0) {
				target.setBackground(new Color(60, 60, 60, 160));
				target.repaint();
			}

			@Override
			public void mousePressed(final MouseEvent arg0) { /* ignore */
			}

			@Override
			public void mouseReleased(final MouseEvent arg0) { /* ignore */
			}
		});
		if (component instanceof Container) {
			for (final Component child : ((Container) component).getComponents()) {
				installHighlighter(child, target);
			}
		}
	}

	protected RoundedPanel packInfo(final String name, final JComponent component) {
		final RoundedPanel packed = new RoundedPanel(10, 0, 0);
		packed.setBackground(new Color(60, 60, 60, 160));
		final RoundedPanel target = packed;
		final Component actualComponent = findComponent(component);
		packed.addMouseListener(new MouseListener() {
			@Override
			public void mouseClicked(final MouseEvent arg0) {
				if (actualComponent != null) {
					if (actualComponent instanceof AbstractButton) {
						final AbstractButton button = (AbstractButton) actualComponent;
						button.doClick();
					}
					if (actualComponent instanceof JTextComponent) {
						final JTextComponent text = (JTextComponent) actualComponent;
						if (text.isEnabled() && text.isEditable()) {
							text.selectAll();
						}
						text.grabFocus();
					}
				}
			}

			@Override
			public void mouseEntered(final MouseEvent arg0) {
				target.setBackground(new Color(60, 60, 60, 240));
				target.repaint();
			}

			@Override
			public void mouseExited(final MouseEvent arg0) {
				target.setBackground(new Color(60, 60, 60, 160));
				target.repaint();
			}

			@Override
			public void mousePressed(final MouseEvent arg0) { /* ignore */
			}

			@Override
			public void mouseReleased(final MouseEvent arg0) { /* ignore */
			}
		});
		installHighlighter(component, target);
		packed.setLayout(new BoxLayout(packed, BoxLayout.X_AXIS));
		final JLabel nameLabel = new JLabel(name);
		nameLabel.setOpaque(false);
		nameLabel.setForeground(WidgetColors.TEXT_COLOR);
		nameLabel.setFont(nameLabel.getFont().deriveFont(12f));
		nameLabel.setMinimumSize(new Dimension(150, 20));
		nameLabel.setMaximumSize(new Dimension(150, 1000));
		nameLabel.setPreferredSize(new Dimension(150, 30));

		packed.add(Box.createHorizontalStrut(5));
		packed.add(nameLabel);
		packed.add(Box.createHorizontalGlue());
		packed.add(component);
		packed.add(Box.createHorizontalStrut(5));
		packed.revalidate();
		return packed;
	}

	/**
	 * Adds a new password field
	 * 
	 * @param name
	 *            Name for the password field
	 * @return The new password field
	 */
	public ProMPasswordField addPasswordInputField(final String name) {
		return addPasswordInputField(name, """");
	}

	/**
	 * Adds a new password field
	 * 
	 * @param name
	 *            Name for the password field
	 * @param value
	 *            Value for the password field
	 * @return The new password field
	 */
	public ProMPasswordField addPasswordInputField(final String name, final String value) {
		final ProMPasswordField component = new ProMPasswordField();
		component.setText(value);
		return addProperty(name, component);
	}

}
"
ProMScrollablePanel.java,widget,"package org.processmining.framework.util.ui.widgets;

import java.awt.Dimension;
import java.awt.Rectangle;

import javax.swing.JPanel;
import javax.swing.Scrollable;
import javax.swing.SwingConstants;

/**
 * @author michael
 * 
 */
public class ProMScrollablePanel extends JPanel implements Scrollable {

	/**
	 * 
	 */
	private static final long serialVersionUID = 1L;

	/**
	 * @see javax.swing.Scrollable#getPreferredScrollableViewportSize()
	 */
	@Override
	public Dimension getPreferredScrollableViewportSize() {
		return getPreferredSize();
	}

	/**
	 * @see javax.swing.Scrollable#getScrollableBlockIncrement(java.awt.Rectangle,
	 *      int, int)
	 */
	@Override
	public int getScrollableBlockIncrement(final Rectangle visibleRect, final int orientation, final int direction) {
		return orientation == SwingConstants.VERTICAL ? getParent().getHeight() : getParent().getWidth();
	}

	/**
	 * @see javax.swing.Scrollable#getScrollableTracksViewportHeight()
	 */
	@Override
	public boolean getScrollableTracksViewportHeight() {
		return false;
	}

	/**
	 * @see javax.swing.Scrollable#getScrollableTracksViewportWidth()
	 */
	@Override
	public boolean getScrollableTracksViewportWidth() {
		return true;
	}

	/**
	 * @see javax.swing.Scrollable#getScrollableUnitIncrement(java.awt.Rectangle,
	 *      int, int)
	 */
	@Override
	public int getScrollableUnitIncrement(final Rectangle visibleRect, final int orientation, final int direction) {
		final int hundredth = (orientation == SwingConstants.VERTICAL ? getParent().getHeight() / 100 : getParent()
				.getWidth()) / 100;
		return hundredth == 0 ? 1 : hundredth;
	}

}"
ProMScrollContainer.java,widget,"package org.processmining.framework.util.ui.widgets;

import java.awt.BorderLayout;
import java.util.ArrayList;
import java.util.List;

import javax.swing.BorderFactory;
import javax.swing.Box;
import javax.swing.BoxLayout;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.ScrollPaneConstants;

/**
 * This class implements a Scroll Container. In the container, childs with a
 * minimize / maximize button can be added. In this way, one can group
 * properties.
 * 
 * Furthermore, childs can be added during run time.
 * 
 * @author jvdwerf
 * 
 */
public class ProMScrollContainer extends BorderPanel {

	/**
	 * 
	 */
	private static final long serialVersionUID = -3112303906580355823L;

	private final List<ProMScrollContainerChild> children = new ArrayList<ProMScrollContainerChild>();

	private JPanel scrollablePanel;

	private JScrollPane scrollPane;

	/**
	 * 
	 */
	public ProMScrollContainer() {
		this(10, 10);

	}

	/**
	 * @param size
	 * @param borderWidth
	 */
	public ProMScrollContainer(final int size, final int borderWidth) {
		super(size, borderWidth);

		initComponents();
	}

	/**
	 * @param child
	 */
	public void addChild(final ProMScrollContainerChild child) {
		addChild(child, children.size());
	}

	/**
	 * @param child
	 * @param index
	 */
	public void addChild(final ProMScrollContainerChild child, final int index) {
		children.add(child);

		if (children.size() > 0) {
			scrollablePanel.add(Box.createVerticalStrut(3));
		}

		scrollablePanel.add(child, index);
		scrollablePanel.revalidate();

		revalidate();
	}

	/**
	 * 
	 */
	public void clearChildren() {
		for (final ProMScrollContainerChild child : children) {
			scrollablePanel.remove(child);
		}

		children.clear();

		revalidate();
	}

	/**
	 * @param i
	 * @return
	 */
	public ProMScrollContainerChild getChild(final int i) {
		return children.get(i);
	}

	/**
	 * @return
	 */
	public List<ProMScrollContainerChild> getChildren() {
		return children;
	}

	/**
	 * @param child
	 */
	public void removeChild(final ProMScrollContainerChild child) {
		scrollablePanel.remove(child);
		children.remove(child);

		revalidate();
	}

	/**
	 * @param show
	 */
	public void showScrollbar(final boolean show) {
		if (show) {
			scrollPane.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS);
		} else {
			scrollPane.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_NEVER);
		}
	}

	private void initComponents() {

		setBorder(BorderFactory.createEmptyBorder(2, 2, 2, 2));

		setOpaque(true);
		setBackground(WidgetColors.COLOR_ENCLOSURE_BG);

		setLayout(new BorderLayout());

		scrollablePanel = new ProMScrollablePanel();
		scrollablePanel.setOpaque(true);
		scrollablePanel.setBackground(WidgetColors.COLOR_LIST_FG);
		scrollablePanel.setBorder(BorderFactory.createEmptyBorder(5, 5, 5, 5));

		scrollablePanel.setLayout(new BoxLayout(scrollablePanel, BoxLayout.Y_AXIS));

		scrollPane = new ProMScrollPane(scrollablePanel);

		this.add(scrollPane, BorderLayout.CENTER);

		revalidate();
	}
}
"
ProMScrollContainerChild.java,widget,"package org.processmining.framework.util.ui.widgets;

import java.awt.BorderLayout;
import java.awt.Dimension;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

import javax.swing.JButton;
import javax.swing.JPanel;

import com.fluxicon.slickerbox.factory.SlickerFactory;

/**
 * Child that can be displayed in the ProMScrollContainer. To update the user
 * interface of a child, one can use the functions
 * 
 * - getTitlePanel() Returns the top panel to display a title of the child
 * 
 * - getContentPanel() Returns the panel in which one can add the real content.
 * This panel will be hidden when the min/max button is hit.
 * 
 * - setContentSize() Sets the size of the content panel when maximized.
 * 
 * @author jvdwerf
 * 
 */
public class ProMScrollContainerChild extends BorderPanel {

	/**
	 * 
	 */
	private static final long serialVersionUID = -81027020923152280L;

	private JPanel buttonPanel;
	private JPanel contentPanel;

	private int contentSize = 100;
	private JButton deleteButton;
	private JButton minimizeButton;

	private boolean minimized = false;

	private final ProMScrollContainer parent;

	private JPanel topContentPanel;

	private JPanel topPanel;

	/**
	 * @param parent
	 */
	public ProMScrollContainerChild(final ProMScrollContainer parent) {
		this(parent, false);
	}

	/**
	 * @param parent
	 * @param startminimized
	 */
	public ProMScrollContainerChild(final ProMScrollContainer parent, final boolean startminimized) {
		this(parent, startminimized, true);
	}

	/**
	 * @param parent
	 * @param startminimized
	 * @param addDeleteButton
	 */
	public ProMScrollContainerChild(final ProMScrollContainer parent, final boolean startminimized,
			final boolean addDeleteButton) {
		super(10, 10);
		this.parent = parent;
		initComponents(addDeleteButton);

		setMinimized(startminimized);
	}

	/**
	 * @return
	 */
	public JPanel getContentPanel() {
		return contentPanel;
	}

	/**
	 * @return
	 */
	public int getContentSize() {
		return contentSize;
	}

	/**
	 * @return
	 */
	public JPanel getTitlePanel() {
		return topContentPanel;
	}

	/**
	 * @return
	 */
	public boolean isMinimized() {
		return minimized;
	}

	/**
	 * @see javax.swing.JComponent#revalidate()
	 */
	@Override
	public void revalidate() {
		super.revalidate();

		if (parent != null) {
			parent.revalidate();
		}
	}

	/**
	 * @param size
	 */
	public void setContentSize(final Dimension size) {
		//// lelijk :-S
		setContentSize((int) size.getHeight());
	}

	/**
	 * @param minimalContentSize
	 */
	public void setContentSize(final int minimalContentSize) {
		contentSize = minimalContentSize;

		updateHeights();
	}

	/**
	 * @param minimized
	 */
	public void setMinimized(final boolean minimized) {
		this.minimized = minimized;

		if (contentPanel != null && minimizeButton != null) {
			if (isMinimized()) {
				contentPanel.setVisible(false);
				minimizeButton.setText(""+"");
			} else {
				contentPanel.setVisible(true);
				minimizeButton.setText(""-"");
			}
		}

		revalidate();
	}

	private void initComponents(final boolean addDeleteButton) {

		setLayout(new BorderLayout());
		setOpaque(true);
		setBackground(WidgetColors.COLOR_LIST_BG);
		//this.setBorder(BorderFactory.createEmptyBorder(5,5,5,5));

		topPanel = new JPanel();
		topPanel.setLayout(new BorderLayout());
		topPanel.setOpaque(false);

		topContentPanel = new JPanel();
		topContentPanel.setLayout(new BorderLayout());
		topContentPanel.setOpaque(false);

		buttonPanel = new JPanel();
		buttonPanel.setLayout(new BorderLayout());
		buttonPanel.setOpaque(false);

		topPanel.add(topContentPanel, BorderLayout.WEST);

		minimizeButton = SlickerFactory.instance().createButton(""-"");
		minimizeButton.addActionListener(new ActionListener() {

			@Override
			public void actionPerformed(final ActionEvent e) {
				toggleMinimized();
			}
		});

		if (addDeleteButton) {
			deleteButton = SlickerFactory.instance().createButton(""x"");
			deleteButton.addActionListener(new ActionListener() {

				@Override
				public void actionPerformed(final ActionEvent e) {
					removeMe();
				}
			});

			buttonPanel.add(deleteButton, BorderLayout.WEST);
		}

		buttonPanel.add(minimizeButton, BorderLayout.EAST);

		topPanel.add(buttonPanel, BorderLayout.EAST);

		this.add(topPanel, BorderLayout.NORTH);

		contentPanel = SlickerFactory.instance().createRoundedPanel(8, WidgetColors.COLOR_LIST_FG);
		contentPanel.setLayout(new BorderLayout());

		updateHeights();

		this.add(contentPanel, BorderLayout.CENTER);

	}

	private void removeMe() {
		parent.removeChild(this);
	}

	private void toggleMinimized() {
		setMinimized(!isMinimized());
	}

	private void updateHeights() {
		if (contentSize > contentPanel.getMaximumSize().getHeight()) {
			contentPanel.setMaximumSize(new Dimension(100, getContentSize()));
		}

		contentPanel.setPreferredSize(new Dimension(100, getContentSize()));
		contentPanel.setSize(new Dimension(100, getContentSize()));

		revalidate();

	}

}
"
ProMScrollPane.java,widget,"package org.processmining.framework.util.ui.widgets;

import java.awt.Color;

import javax.swing.BorderFactory;
import javax.swing.JComponent;
import javax.swing.JScrollBar;
import javax.swing.JScrollPane;
import javax.swing.ScrollPaneConstants;

import com.fluxicon.slickerbox.ui.SlickerScrollBarUI;

/**
 * @author michael
 * 
 */
public class ProMScrollPane extends JScrollPane {

	/**
	 * 
	 */
	private static final long serialVersionUID = 1L;

	/**
	 * @param component
	 */
	public ProMScrollPane(final JComponent component) {
		super(component);
		setOpaque(true);
		setBackground(WidgetColors.COLOR_ENCLOSURE_BG);
		setBorder(BorderFactory.createEmptyBorder());
		setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_AS_NEEDED);
		setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_AS_NEEDED);
		JScrollBar vBar = getVerticalScrollBar();
		vBar.setUI(new SlickerScrollBarUI(vBar, new Color(0, 0, 0, 0), new Color(160, 160, 160),
				WidgetColors.COLOR_NON_FOCUS, 4, 12));
		vBar.setOpaque(true);
		vBar.setBackground(WidgetColors.COLOR_ENCLOSURE_BG);
		vBar = getHorizontalScrollBar();
		vBar.setUI(new SlickerScrollBarUI(vBar, new Color(0, 0, 0, 0), new Color(160, 160, 160),
				WidgetColors.COLOR_NON_FOCUS, 4, 12));
		vBar.setOpaque(true);
		vBar.setBackground(WidgetColors.COLOR_ENCLOSURE_BG);
	}

}
"
ProMSplitPane.java,widget,"package org.processmining.framework.util.ui.widgets;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Component;
import java.awt.Cursor;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

import javax.swing.BorderFactory;
import javax.swing.JButton;
import javax.swing.JPanel;
import javax.swing.JSplitPane;
import javax.swing.border.Border;
import javax.swing.plaf.basic.BasicSplitPaneDivider;
import javax.swing.plaf.basic.BasicSplitPaneUI;

import com.fluxicon.slickerbox.components.RoundedPanel;

/**
 * @author michael
 * 
 */
public class ProMSplitPane extends BorderPanel {
	private static class ImprovedSplitPaneDivider extends BasicSplitPaneDivider {
		/**
		 * 
		 */
		private static final long serialVersionUID = 1L;

		private ImprovedSplitPaneDivider(final BasicSplitPaneUI ui) {
			super(ui);
		}

		@Override
		public void paint(final Graphics g) {
			g.setColor(getBackground());
			g.fillRect(0, 0, getWidth(), getHeight());
			paintComponents(g);
		}

		@Override
		protected JButton createLeftOneTouchButton() {
			final JButton b = new JButton() {
				/**
				 * 
				 */
				private static final long serialVersionUID = 1L;

				// Don't want the button to participate in focus traversable.
				@Override
				@Deprecated
				public boolean isFocusTraversable() {
					return false;
				}

				@Override
				public void paint(final Graphics g) {
					if (splitPane != null) {
						final int[] xs = new int[3];
						final int[] ys = new int[3];
						int blockSize;

						// Fill the background first ...
						g.setColor(ImprovedSplitPaneDivider.this.getBackground());
						g.fillRect(0, 0, getWidth(), getHeight());

						// ... then draw the arrow.
						g.setColor(ImprovedSplitPaneDivider.this.getForeground());
						if (orientation == JSplitPane.VERTICAL_SPLIT) {
							blockSize = Math.min(getHeight(), BasicSplitPaneDivider.ONE_TOUCH_SIZE);
							xs[0] = blockSize;
							xs[1] = 0;
							xs[2] = blockSize << 1;
							ys[0] = 0;
							ys[1] = ys[2] = blockSize;
							g.drawPolygon(xs, ys, 3); // Little trick to make the
							// arrows of equal size
						} else {
							blockSize = Math.min(getWidth(), BasicSplitPaneDivider.ONE_TOUCH_SIZE);
							xs[0] = xs[2] = blockSize;
							xs[1] = 0;
							ys[0] = 0;
							ys[1] = blockSize;
							ys[2] = blockSize << 1;
						}
						g.fillPolygon(xs, ys, 3);
					}
				}

				@Override
				public void setBorder(final Border b) {
				}
			};
			b.setMinimumSize(new Dimension(BasicSplitPaneDivider.ONE_TOUCH_SIZE, BasicSplitPaneDivider.ONE_TOUCH_SIZE));
			b.setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));
			b.setFocusPainted(false);
			b.setBorderPainted(false);
			b.setRequestFocusEnabled(false);
			b.addActionListener(new ActionListener() {
				@Override
				public void actionPerformed(final ActionEvent e) {
					leftClicked();
				}
			});
			return b;
		}

		/**
		 * Creates and return an instance of JButton that can be used to
		 * collapse the right component in the split pane.
		 */
		@Override
		protected JButton createRightOneTouchButton() {
			final JButton b = new JButton() {
				/**
				 * 
				 */
				private static final long serialVersionUID = 1L;

				// Don't want the button to participate in focus traversable.
				@Override
				@Deprecated
				public boolean isFocusTraversable() {
					return false;
				}

				@Override
				public void paint(final Graphics g) {
					if (splitPane != null) {
						final int[] xs = new int[3];
						final int[] ys = new int[3];
						int blockSize;

						// Fill the background first ...
						g.setColor(ImprovedSplitPaneDivider.this.getBackground());
						g.fillRect(0, 0, getWidth(), getHeight());

						// ... then draw the arrow.
						if (orientation == JSplitPane.VERTICAL_SPLIT) {
							blockSize = Math.min(getHeight(), BasicSplitPaneDivider.ONE_TOUCH_SIZE);
							xs[0] = blockSize;
							xs[1] = blockSize << 1;
							xs[2] = 0;
							ys[0] = blockSize;
							ys[1] = ys[2] = 0;
						} else {
							blockSize = Math.min(getWidth(), BasicSplitPaneDivider.ONE_TOUCH_SIZE);
							xs[0] = xs[2] = 0;
							xs[1] = blockSize;
							ys[0] = 0;
							ys[1] = blockSize;
							ys[2] = blockSize << 1;
						}
						g.setColor(ImprovedSplitPaneDivider.this.getForeground());
						g.fillPolygon(xs, ys, 3);
					}
				}

				@Override
				public void setBorder(final Border border) {
				}
			};
			b.setMinimumSize(new Dimension(BasicSplitPaneDivider.ONE_TOUCH_SIZE, BasicSplitPaneDivider.ONE_TOUCH_SIZE));
			b.setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));
			b.setFocusPainted(false);
			b.setBorderPainted(false);
			b.setRequestFocusEnabled(false);
			b.addActionListener(new ActionListener() {
				@Override
				public void actionPerformed(final ActionEvent e) {
					rightClicked();
				}
			});
			return b;
		}

		protected void leftClicked() {

		}

		protected void rightClicked() {

		}
	}

	/**
	 * 
	 */
	public static final int HORIZONTAL_SPLIT = JSplitPane.HORIZONTAL_SPLIT;
	/**
	 * 
	 */
	public static final int VERTICAL_SPLIT = JSplitPane.VERTICAL_SPLIT;

	/**
	 * 
	 */
	private static final long serialVersionUID = 1L;
	JSplitPane split;
	JPanel top, bottom;

	/**
	 * 
	 */
	public ProMSplitPane() {
		this(ProMSplitPane.HORIZONTAL_SPLIT);
	}

	/**
	 * @param split
	 */
	public ProMSplitPane(final int split) {
		super(5, 5);
		setLayout(new BorderLayout());
		setBackground(WidgetColors.COLOR_ENCLOSURE_BG);
		setForeground(WidgetColors.COLOR_ENCLOSURE_BG);
		setOpaque(true);
		top = new RoundedPanel(10);
		top.setLayout(new BorderLayout());
		top.setBackground(Color.LIGHT_GRAY);
		top.setOpaque(true);
		bottom = new RoundedPanel(10);
		bottom.setLayout(new BorderLayout());
		bottom.setBackground(Color.LIGHT_GRAY);
		bottom.setOpaque(true);
		this.split = new JSplitPane(split, true);
		this.split.setLeftComponent(top);
		this.split.setRightComponent(bottom);
		this.split.setBorder(BorderFactory.createEmptyBorder());
		this.split.setBackground(WidgetColors.COLOR_ENCLOSURE_BG);
		this.split.setOpaque(true);
		this.split.setUI(new BasicSplitPaneUI() {
			@Override
			public BasicSplitPaneDivider createDefaultDivider() {
				final BasicSplitPaneDivider divider = new ImprovedSplitPaneDivider(this) {
					/**
					 * 
					 */
					private static final long serialVersionUID = 1L;

					@Override
					public void leftClicked() {
						ProMSplitPane.this.leftClicked();
					}

					@Override
					public void rightClicked() {
						ProMSplitPane.this.rightClicked();
					}
				};
				divider.setBackground(WidgetColors.COLOR_ENCLOSURE_BG);
				divider.setForeground(Color.LIGHT_GRAY);
				return divider;
			}
		});
		add(this.split);
	}

	/**
	 * @param c
	 */
	public void setBottomComponent(final Component c) {
		bottom.removeAll();
		bottom.add(c);
		validate();
	}

	/**
	 * @param d
	 */
	public void setDividerLocation(final double d) {
		split.setDividerLocation(d);

	}

	/**
	 * @param location
	 */
	public void setDividerLocation(final int location) {
		split.setDividerLocation(location);
	}

	/**
	 * @param size
	 */
	public void setDividerSize(final int size) {
		split.setDividerSize(size);
	}

	/**
	 * @param c
	 */
	public void setLeftComponent(final Component c) {
		setTopComponent(c);
	}

	/**
	 * @param expandable
	 */
	public void setOneTouchExpandable(final boolean expandable) {
		split.setOneTouchExpandable(expandable);
	}

	/**
	 * @param d
	 */
	public void setResizeWeight(final double d) {
		split.setResizeWeight(d);
	}

	/**
	 * @param c
	 */
	public void setRightComponent(final Component c) {
		setBottomComponent(c);
	}

	/**
	 * @param c
	 */
	public void setTopComponent(final Component c) {
		top.removeAll();
		top.add(c);
		validate();
	}

	protected void leftClicked() {

	}

	protected void rightClicked() {

	}
}
"
ProMTable.java,widget,"package org.processmining.framework.util.ui.widgets;

import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.Point;
import java.awt.event.MouseListener;
import java.util.Arrays;
import java.util.Comparator;

import javax.swing.BorderFactory;
import javax.swing.Box;
import javax.swing.JTable;
import javax.swing.ListSelectionModel;
import javax.swing.RowSorter;
import javax.swing.SortOrder;
import javax.swing.table.JTableHeader;
import javax.swing.table.TableCellEditor;
import javax.swing.table.TableColumnModel;
import javax.swing.table.TableModel;
import javax.swing.table.TableRowSorter;

import com.fluxicon.slickerbox.components.RoundedPanel;

/**
 * Table with SlickerBox L&F
 * 
 * @author mwesterg
 * 
 */
public class ProMTable extends RoundedPanel {

	/**
	 * 
	 */
	private static final long serialVersionUID = 1L;
	private final JTable table;

	/**
	 * @param model
	 */
	public ProMTable(final TableModel model) {
		this(model, null);
	}

	/**
	 * @param model
	 * @param columnModel
	 */
	public ProMTable(final TableModel model, final TableColumnModel columnModel) {
		super(10, 5, 0);

		table = createTable(model, columnModel);
		table.setBackground(WidgetColors.COLOR_LIST_BG);
		table.setForeground(WidgetColors.COLOR_LIST_FG);
		table.setSelectionBackground(WidgetColors.COLOR_LIST_SELECTION_BG);
		table.setSelectionForeground(WidgetColors.COLOR_LIST_SELECTION_FG);

		final ProMScrollPane scroller = new ProMScrollPane(table);

		table.getTableHeader().setBackground(WidgetColors.COLOR_ENCLOSURE_BG);
		table.getTableHeader().setOpaque(false);
		table.getTableHeader().setForeground(WidgetColors.COLOR_LIST_SELECTION_FG);
		table.getTableHeader().setBorder(BorderFactory.createEmptyBorder());
		table.getTableHeader().setFont(table.getTableHeader().getFont().deriveFont(13f).deriveFont(Font.BOLD));
		table.getTableHeader().setAlignmentX(Component.CENTER_ALIGNMENT);
		table.setShowHorizontalLines(false);
		table.setGridColor(WidgetColors.COLOR_ENCLOSURE_BG);
		table.setFont(table.getFont().deriveFont(Font.BOLD));

		scroller.getViewport().setBackground(WidgetColors.COLOR_LIST_BG);
		table.getTableHeader().setDefaultRenderer(new HeaderRenderer());

		setBackground(WidgetColors.COLOR_ENCLOSURE_BG);
		setLayout(new BorderLayout());
		setMinimumSize(new Dimension(200, 100));
		setMaximumSize(new Dimension(1000, 1000));
		setPreferredSize(new Dimension(1000, 200));
		add(Box.createHorizontalStrut(5), BorderLayout.WEST);
		add(scroller, BorderLayout.CENTER);
		add(Box.createHorizontalStrut(5), BorderLayout.EAST);

		table.setColumnSelectionAllowed(false);
		table.setAutoResizeMode(JTable.AUTO_RESIZE_NEXT_COLUMN);
	}

	/**
	 * @see java.awt.Component#addMouseListener(java.awt.event.MouseListener)
	 */
	@Override
	public void addMouseListener(final MouseListener l) {
		table.addMouseListener(l);
	}

	/**
	 * @param from
	 * @param to
	 */
	public void addRowSelectionInterval(final int from, final int to) {
		table.addRowSelectionInterval(from, to);
	}

	/**
	 * 
	 */
	public void clearSelection() {
		table.clearSelection();
	}

	/**
	 * @param point
	 * @return
	 */
	public int columnAtPoint(final Point point) {
		return table.columnAtPoint(point);
	}

	/**
	 * @param row
	 * @param col
	 * @return
	 */
	public TableCellEditor getCellEditor(final int row, final int col) {
		return table.getCellEditor(row, col);
	}

	/**
	 * @return
	 */
	public TableColumnModel getColumnModel() {
		return table.getColumnModel();
	}

	/**
	 * @return
	 */
	public boolean getColumnSelectionAllowed() {
		return table.getColumnSelectionAllowed();
	}

	/**
	 * @return
	 */
	public boolean getRowSelectionAllowed() {
		return table.getRowSelectionAllowed();
	}

	/**
	 * @return
	 */
	public RowSorter<? extends TableModel> getRowSorter() {
		return table.getRowSorter();
	}

	/**
	 * @return
	 */
	public int getSelectedColumn() {
		return table.getSelectedColumn();
	}

	/**
	 * @return
	 */
	public int getSelectedRow() {
		return table.getSelectedRow();
	}

	/**
	 * @return
	 */
	public ListSelectionModel getSelectionModel() {
		return table.getSelectionModel();
	}

	/**
	 * @return
	 */
	public JTable getTable() {
		return table;
	}

	/**
	 * @return
	 */
	public JTableHeader getTableHeader() {
		return table.getTableHeader();
	}

	/**
	 * @param row
	 * @param column
	 * @return
	 */
	public Object getValueAt(final int row, final int column) {
		return table.getValueAt(row, column);
	}

	/**
	 * @see java.awt.Component#removeMouseListener(java.awt.event.MouseListener)
	 */
	@Override
	public void removeMouseListener(final MouseListener l) {
		table.removeMouseListener(l);
	}

	/**
	 * @param point
	 * @return
	 */
	public int rowAtPoint(final Point point) {
		return table.rowAtPoint(point);
	}

	/**
	 * @param create
	 */
	public void setAutoCreateRowSorter(final boolean create) {
		table.setAutoCreateRowSorter(create);
	}

	/**
	 * @param mode
	 */
	public void setAutoResizeMode(final int mode) {
		table.setAutoResizeMode(mode);
	}

	/**
	 * @param allowed
	 */
	public void setColumnSelectionAllowed(final boolean allowed) {
		table.setColumnSelectionAllowed(allowed);
	}

	/**
	 * @param column
	 * @param width
	 */
	public void setPreferredWidth(final int column, final int width) {
		table.getColumnModel().getColumn(column).setPreferredWidth(width);
	}

	/**
	 * @param allowed
	 */
	public void setRowSelectionAllowed(final boolean allowed) {
		table.setRowSelectionAllowed(allowed);
	}

	/**
	 * @param column
	 * @param comparator
	 */
	public void setRowSorter(final int column, final Comparator<?> comparator) {
		final TableRowSorter<TableModel> sorter = new TableRowSorter<TableModel>(table.getModel());
		sorter.setSortsOnUpdates(true);
		sorter.setComparator(column, null);
		setRowSorter(sorter);
		sorter.setSortKeys(Arrays.asList(new RowSorter.SortKey(column, SortOrder.ASCENDING)));
	}

	/**
	 * @param sorter
	 */
	public void setRowSorter(final RowSorter<? extends TableModel> sorter) {
		table.setRowSorter(sorter);
	}

	/**
	 * @param sorter
	 */
	public void setRowSorter(final TableRowSorter<? extends TableModel> sorter) {
		table.setRowSorter(sorter);
		sorter.sort();
	}

	/**
	 * @param mode
	 */
	public void setSelectionMode(final int mode) {
		table.setSelectionMode(mode);
	}

	protected JTable createTable(final TableModel model, final TableColumnModel columnModel) {
		return new JTable(model, columnModel);
	}

}"
ProMTableWithoutPanel.java,widget,"package org.processmining.framework.util.ui.widgets;

import java.awt.Color;
import java.awt.Component;
import java.awt.Font;
import java.util.Enumeration;

import javax.swing.DefaultCellEditor;
import javax.swing.JPanel;
import javax.swing.JTable;
import javax.swing.JTextField;
import javax.swing.table.DefaultTableCellRenderer;
import javax.swing.table.TableColumn;
import javax.swing.table.TableColumnModel;
import javax.swing.table.TableModel;

/**
 * Adapted from {@link ProMTable}, but without a surrounding {@link JPanel}.
 * 
 * @author F. Mannhardt
 *
 */
public class ProMTableWithoutPanel extends JTable {

	private static final long serialVersionUID = 9039927753456671146L;
	
	public ProMTableWithoutPanel(TableModel model, TableColumnModel columnModel) {
		super(model, columnModel);
		setup();
	}

	public ProMTableWithoutPanel(TableModel model) {
		super(model);
		setup();
	}

	@SuppressWarnings(""serial"")
	private void setup() {
		setBackground(WidgetColors.COLOR_LIST_BG);
		setForeground(WidgetColors.COLOR_LIST_FG);
		setSelectionBackground(WidgetColors.COLOR_LIST_SELECTION_BG);
		setSelectionForeground(WidgetColors.COLOR_LIST_SELECTION_FG);
		setGridColor(WidgetColors.COLOR_ENCLOSURE_BG);
		setFont(getFont().deriveFont(Font.BOLD));
		
		getTableHeader().setBackground(WidgetColors.COLOR_ENCLOSURE_BG);
		getTableHeader().setOpaque(true);
		getTableHeader().setForeground(Color.WHITE);
		getTableHeader().setFont(getTableHeader().getFont().deriveFont(13f).deriveFont(Font.BOLD));
		getTableHeader().setReorderingAllowed(false);
		DefaultTableCellRenderer cellRenderer = new DefaultTableCellRenderer() {

			public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected,
					boolean hasFocus, int row, int column) {
				Component c = super.getTableCellRendererComponent(table, value, isSelected, hasFocus, row, column);
				if (!isSelected) {
					c.setBackground(table.getBackground());
					c.setForeground(table.getForeground());
				}
				return c;
			}

		};
		
		Enumeration<TableColumn> columns = getColumnModel().getColumns();
		while (columns.hasMoreElements()) {
			final TableColumn column = columns.nextElement();
			column.setPreferredWidth(200);
			column.setCellRenderer(cellRenderer);
			column.setCellEditor(new DefaultCellEditor(new JTextField()) {

				protected void fireEditingStopped() {
					this.cancelCellEditing();
					super.fireEditingStopped();
				}

				protected void fireEditingCanceled() {
					super.fireEditingCanceled();
				}

			});
		}
		
		setColumnSelectionAllowed(false);		
		setShowHorizontalLines(false);

		setMinimumSize(null);
		setMaximumSize(null);
		setPreferredSize(null);
		setBackground(null);
		setForeground(null);
		setOpaque(false);
		setAutoResizeMode(JTable.AUTO_RESIZE_OFF);
	}

}
"
ProMTextArea.java,widget,"package org.processmining.framework.util.ui.widgets;

import java.awt.BorderLayout;
import java.awt.Dimension;

import javax.swing.Box;
import javax.swing.JTextArea;

import com.fluxicon.slickerbox.components.RoundedPanel;

/**
 * TextAres with SlickerBox L&F
 * 
 * @author mwesterg
 * 
 */
public class ProMTextArea extends RoundedPanel {

	/**
	 * 
	 */
	private static final long serialVersionUID = 1L;
	private final JTextArea textArea;

	/**
	 * 
	 */
	public ProMTextArea() {
		super(10, 5, 0);
		textArea = new JTextArea();
		final ProMScrollPane logarea = new ProMScrollPane(textArea);
		textArea.setOpaque(true);
		textArea.setBackground(WidgetColors.COLOR_ENCLOSURE_BG);
		textArea.setForeground(WidgetColors.COLOR_LIST_SELECTION_FG);
		textArea.setSelectedTextColor(WidgetColors.COLOR_LIST_SELECTION_FG);
		textArea.setSelectionColor(WidgetColors.COLOR_LIST_SELECTION_BG);
		textArea.setCaretColor(WidgetColors.COLOR_LIST_SELECTION_FG);

		setBackground(WidgetColors.COLOR_ENCLOSURE_BG);
		setLayout(new BorderLayout());
		setMinimumSize(new Dimension(200, 100));
		setMaximumSize(new Dimension(1000, 1000));
		setPreferredSize(new Dimension(1000, 200));

		add(Box.createHorizontalStrut(5), BorderLayout.WEST);
		add(logarea, BorderLayout.CENTER);
		add(Box.createHorizontalStrut(5), BorderLayout.EAST);
	}

	/**
	 * @param editable
	 */
	public ProMTextArea(final boolean editable) {
		this();
		if (!editable) {
			setEditable(false);
			setLineWrap(true);
		}
	}

	/**
	 * @param text
	 */
	public void append(final String text) {
		textArea.append(text);
	}

	/**
	 * @return
	 */
	public int getLength() {
		return textArea.getDocument().getLength();
	}

	/**
	 * @return
	 */
	public boolean getLineWrap() {
		return textArea.getLineWrap();
	}

	/**
	 * @return
	 */
	public int getTabSize() {
		return textArea.getTabSize();
	}

	/**
	 * @return
	 */
	public String getText() {
		return textArea.getText();
	}

	/**
	 * 
	 */
	public void scrollToEnd() {
		setCaretPosition(getLength());
	}

	/**
	 * 
	 */
	public void selectAll() {
		textArea.selectAll();
	}

	/**
	 * @param position
	 */
	public void setCaretPosition(final int position) {
		textArea.setCaretPosition(position);
	}

	/**
	 * @param editable
	 */
	public void setEditable(final boolean editable) {
		textArea.setEditable(editable);
	}

	/**
	 * @param wrap
	 */
	public void setLineWrap(final boolean wrap) {
		textArea.setLineWrap(wrap);
		textArea.setWrapStyleWord(wrap);
	}

	/**
	 * @param size
	 */
	public void setTabSize(final int size) {
		textArea.setTabSize(size);
	}

	/**
	 * @param text
	 */
	public void setText(final String text) {
		textArea.setText(text);
	}

	public JTextArea getTextArea() {
		return textArea;
	}
}
"
ProMTextField.java,widget,"package org.processmining.framework.util.ui.widgets;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.FontMetrics;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Insets;
import java.awt.RenderingHints;
import java.awt.event.ActionListener;
import java.awt.event.FocusEvent;
import java.awt.event.FocusListener;
import java.awt.event.KeyListener;

import javax.swing.JTextField;
import javax.swing.text.Document;

/**
 * TextField with SlickerBox L&F
 * 
 * @author mwesterg
 * @author F. Mannhardt (hints & expose underlying {@link JTextField})
 * 
 */
public class ProMTextField extends BorderPanel {

	private final class JTextFieldWithHint extends JTextField implements FocusListener {
		
		private static final long serialVersionUID = -4392477239934637206L;
		
		private String hint;
		private boolean hintVisible = true;

		public JTextFieldWithHint() {
			super();
			super.addFocusListener(this);
		}

		@Override
		public void focusGained(FocusEvent e) {
			hintVisible = false;
			repaint();
		}

		@Override
		public void focusLost(FocusEvent e) {
			hintVisible = true;
			repaint();
		}

		public void setHint(String hint) {
			this.hint = hint;
		}
		
		@Override
	    public void paint(Graphics g) {
	        super.paint(g);
	        if (getText().length() == 0 && hintVisible && hint != null && !hint.isEmpty()) {
	            int h = getHeight();
	            ((Graphics2D)g).setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING,RenderingHints.VALUE_TEXT_ANTIALIAS_ON);
	            Insets ins = getInsets();
	            FontMetrics fm = g.getFontMetrics();
	            int c0 = getBackground().getRGB();
	            int c1 = getForeground().getRGB();
	            int m = 0xfefefefe;
	            int c2 = ((c0 & m) >>> 1) + ((c1 & m) >>> 1);
	            g.setColor(new Color(c2, true));
	            g.drawString(hint, ins.left, h / 2 + fm.getAscent() / 2 - 2);
	        }
	    }

	}

	/**
	 * 
	 */
	private static final long serialVersionUID = 1L;
	
	private final JTextFieldWithHint textField;
	
	/**
	 * 
	 */
	public ProMTextField() {
		super(15, 3);
		setLayout(new BorderLayout());
		setOpaque(true);
		setBackground(WidgetColors.COLOR_LIST_BG);
		setForeground(WidgetColors.COLOR_ENCLOSURE_BG);
		textField = new JTextFieldWithHint();
		add(textField, BorderLayout.CENTER);
		textField.setBorder(null);
		textField.setOpaque(true);
		textField.setBackground(WidgetColors.COLOR_LIST_BG);
		textField.setForeground(WidgetColors.COLOR_LIST_SELECTION_FG);
		textField.setSelectionColor(WidgetColors.COLOR_LIST_SELECTION_BG);
		textField.setSelectedTextColor(WidgetColors.COLOR_LIST_SELECTION_FG);
		textField.setCaretColor(WidgetColors.COLOR_LIST_SELECTION_FG);
		setMinimumSize(new Dimension(200, 30));
		setMaximumSize(new Dimension(1000, 30));
		setPreferredSize(new Dimension(1000, 30));
	}

	/**
	 * @param initial
	 */
	public ProMTextField(final String initial) {
		this();
		setText(initial);
	}

	/**
	 * @param initial
	 * @param hint
	 *            displayed in light gray font
	 */
	public ProMTextField(final String initial, final String hint) {
		this();
		setText(initial);
		setHint(hint);
	}

	/**
	 * @param listener
	 */
	public void addActionListener(final ActionListener listener) {
		textField.addActionListener(listener);
	}

	/**
	 * @see java.awt.Component#addFocusListener(java.awt.event.FocusListener)
	 */
	@Override
	public void addFocusListener(final FocusListener listener) {
		textField.addFocusListener(listener);
	}

	/**
	 * @see java.awt.Component#addKeyListener(java.awt.event.KeyListener)
	 */
	@Override
	public void addKeyListener(final KeyListener listener) {
		textField.addKeyListener(listener);
	}

	/**
	 * @return
	 */
	public Document getDocument() {
		return textField.getDocument();
	}

	/**
	 * @return
	 */
	public String getText() {
		return textField.getText();
	}

	/**
	 * @param text
	 */
	public void insertText(final String text) {
		final int position = textField.getCaretPosition();
		textField.setText(textField.getText().substring(0, position) + text + textField.getText().substring(position));
	}

	/**
	 * @param listener
	 */
	public void removeActionListener(final ActionListener listener) {
		textField.removeActionListener(listener);
	}

	/**
	 * @see java.awt.Component#removeFocusListener(java.awt.event.FocusListener)
	 */
	@Override
	public void removeFocusListener(final FocusListener listener) {
		textField.removeFocusListener(listener);
	}

	/**
	 * @param editable
	 */
	public void setEditable(final boolean editable) {
		textField.setEditable(editable);
	}

	/**
	 * @param text
	 */
	public void setText(final String text) {
		textField.setText(text);
	}

	/**
	 * @param isOkay
	 */
	public void visualizeStatus(final boolean isOkay) {
		final Color bg = isOkay ? WidgetColors.COLOR_LIST_BG : WidgetColors.COLOR_LIST_SELECTION_BG;
		super.setBackground(bg);
		textField.setBackground(bg);
		getParent().invalidate();
		getParent().repaint();
	}

	/**
	 * @return get underlying {@link JTextField}
	 */
	public JTextField getTextField() {
		return textField;
	}

	/**
	 * @param hint
	 *            gray text that appears when text field is empty
	 */
	public void setHint(String hint) {
		textField.setHint(hint);
	}

}
"
ProMTitledScrollContainerChild.java,widget,"package org.processmining.framework.util.ui.widgets;

import java.awt.BorderLayout;

/**
 * @author michael
 * 
 */
public class ProMTitledScrollContainerChild extends ProMScrollContainerChild {

	/**
	 * 
	 */
	private static final long serialVersionUID = -1497690974696615552L;

	private final String title;

	/**
	 * @param title
	 * @param parent
	 */
	public ProMTitledScrollContainerChild(final String title, final ProMScrollContainer parent) {
		this(title, parent, false);
	}

	/**
	 * @param title
	 * @param parent
	 * @param minimized
	 */
	public ProMTitledScrollContainerChild(final String title, final ProMScrollContainer parent, final boolean minimized) {
		super(parent, minimized);

		this.title = title;

		initialize();
	}

	/**
	 * @return
	 */
	public String getTitle() {
		return title;
	}

	private void initialize() {
		final LeftAlignedHeader header = new LeftAlignedHeader(getTitle());

		getTitlePanel().setLayout(new BorderLayout());
		getTitlePanel().setBackground(WidgetColors.PROPERTIES_BACKGROUND);
		getTitlePanel().add(header);

	}

}
"
DetailView.java,widget,"package org.processmining.framework.util.ui.widgets.traceview.masterdetail;

import java.util.Comparator;

import javax.swing.JComponent;

import org.processmining.framework.util.ui.widgets.traceview.ProMTraceList;

public interface DetailView<T> {
	
	JComponent getDetailComponent();
	
	ProMTraceList<T> getDetailList();

	Comparator<T> getSortOrder();

}
"
MasterView.java,widget,"package org.processmining.framework.util.ui.widgets.traceview.masterdetail;

import java.util.Collection;

import javax.swing.JComponent;

import org.processmining.framework.util.ui.widgets.traceview.ProMTraceList;

public interface MasterView<M, D> {
	
	JComponent getMasterComponent();
	
	ProMTraceList<M> getMasterList();
	
	Collection<D> getDetailElements(M element);

}
"
ProMTraceListMasterDetail.java,widget,"package org.processmining.framework.util.ui.widgets.traceview.masterdetail;

import java.awt.BorderLayout;
import java.awt.HeadlessException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.concurrent.ExecutionException;

import javax.swing.JList;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.ListModel;
import javax.swing.SwingWorker;
import javax.swing.event.ListSelectionEvent;
import javax.swing.event.ListSelectionListener;

import org.processmining.framework.util.ui.widgets.ProMSplitPane;
import org.processmining.framework.util.ui.widgets.traceview.model.SortableListModel;

public class ProMTraceListMasterDetail<M, D> extends JPanel {

	private static final long serialVersionUID = -289071473358339232L;

	private final MasterView<M, D> masterView;
	private final DetailView<D> detailView;
	private final TransparentSplitPane splitPane;

	private boolean doUpdates = true;

	public ProMTraceListMasterDetail(final MasterView<M, D> masterView, final DetailView<D> detailView) {
		super();
		this.masterView = masterView;
		this.detailView = detailView;

		masterView.getMasterList().addTraceSelectionListener(new ListSelectionListener() {

			public void valueChanged(ListSelectionEvent e) {
				if (e.getValueIsAdjusting() || !doUpdates) {
					return;
				}

				final JList<M> list = masterView.getMasterList().getList();
				final int[] selectedTraces = list.getSelectedIndices();

				onBeforeUpdate(selectedTraces);

				SwingWorker<Collection<D>, Object> bgWorker = new SwingWorker<Collection<D>, Object>() {

					@Override
					public Collection<D> doInBackground() {
						List<D> detailedCollection = new ArrayList<D>();
						for (int index : selectedTraces) {
							if (index < list.getModel().getSize()) {
								Collection<D> detailElements = masterView
										.getDetailElements(list.getModel().getElementAt(index));
								detailedCollection.addAll(detailElements);
							}
						}
						return detailedCollection;
					}

					@Override
					protected void done() {
						detailView.getDetailList().clear();
						detailView.getDetailList().getList().getSelectionModel().clearSelection();
						try {
							detailView.getDetailList().addAll(get());
							if (detailView.getSortOrder() != null) {
								ListModel<D> listModel = detailView.getDetailList().getListModel();
								if (listModel instanceof SortableListModel) {
									((SortableListModel<D>) listModel).sort(detailView.getSortOrder());
								}
							}
							onAfterUpdate();
						} catch (ExecutionException e) {
							JOptionPane.showMessageDialog(ProMTraceListMasterDetail.this,
									""Error loading detail elements "" + e.getMessage(), ""Loading error"",
									JOptionPane.ERROR_MESSAGE);
						} catch (InterruptedException e) {
							JOptionPane.showMessageDialog(ProMTraceListMasterDetail.this,
									""Error loading detail elements "" + e.getMessage(), ""Loading error"",
									JOptionPane.ERROR_MESSAGE);
						} catch (HeadlessException e) {
							JOptionPane.showMessageDialog(ProMTraceListMasterDetail.this,
									""Error loading detail elements "" + e.getMessage(), ""Loading error"",
									JOptionPane.ERROR_MESSAGE);
						}
					}

				};
				bgWorker.execute();
			}

		});

		setBackground(null);
		setForeground(null);
		setOpaque(false);
		setLayout(new BorderLayout());
		splitPane = createSplitPane();
		splitPane.setLeftComponent(masterView.getMasterComponent());
		splitPane.setRightComponent(detailView.getDetailComponent());
		splitPane.setResizeWeight(1.0d);
		splitPane.setOneTouchExpandable(true);
		add(splitPane, BorderLayout.CENTER);
	}

	protected TransparentSplitPane createSplitPane() {
		return new TransparentSplitPane(ProMSplitPane.HORIZONTAL_SPLIT);
	}

	public MasterView<M, D> getMasterView() {
		return masterView;
	}

	public DetailView<D> getDetailView() {
		return detailView;
	}

	public TransparentSplitPane getSplitPane() {
		return splitPane;
	}

	public void disableDetailUpdates() {
		doUpdates = false;
	}

	public void enableDetailUpdates() {
		doUpdates = true;
	}

	protected void onBeforeUpdate(int[] selectedIndicies) {
		detailView.getDetailList().beforeUpdate();
	}

	private void onAfterUpdate() {
		detailView.getDetailList().afterUpdate();
	}

}
"
TransparentSplitPane.java,widget,"package org.processmining.framework.util.ui.widgets.traceview.masterdetail;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Component;
import java.awt.Cursor;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

import javax.swing.BorderFactory;
import javax.swing.JButton;
import javax.swing.JPanel;
import javax.swing.JSplitPane;
import javax.swing.border.Border;
import javax.swing.plaf.basic.BasicSplitPaneDivider;
import javax.swing.plaf.basic.BasicSplitPaneUI;

import org.processmining.framework.util.ui.widgets.WidgetColors;

public class TransparentSplitPane extends JPanel {

	private static final long serialVersionUID = 1L;

	private static class ImprovedSplitPaneDivider extends BasicSplitPaneDivider {
		/**
			 * 
			 */
		private static final long serialVersionUID = 1L;

		private ImprovedSplitPaneDivider(final BasicSplitPaneUI ui) {
			super(ui);
		}

		@Override
		public void paint(final Graphics g) {
			g.setColor(getBackground());
			g.fillRect(0, 0, getWidth(), getHeight());
			paintComponents(g);
		}

		@Override
		protected JButton createLeftOneTouchButton() {
			final JButton b = new JButton() {
				/**
					 * 
					 */
				private static final long serialVersionUID = 1L;

				// Don't want the button to participate in focus traversable.
				@Override
				@Deprecated
				public boolean isFocusTraversable() {
					return false;
				}

				@Override
				public void paint(final Graphics g) {
					if (splitPane != null) {
						final int[] xs = new int[3];
						final int[] ys = new int[3];
						int blockSize;

						// Fill the background first ...
						g.setColor(ImprovedSplitPaneDivider.this.getBackground());
						g.fillRect(0, 0, getWidth(), getHeight());

						// ... then draw the arrow.
						g.setColor(ImprovedSplitPaneDivider.this.getForeground());
						if (orientation == JSplitPane.VERTICAL_SPLIT) {
							blockSize = Math.min(getHeight(), BasicSplitPaneDivider.ONE_TOUCH_SIZE);
							xs[0] = blockSize;
							xs[1] = 0;
							xs[2] = blockSize << 1;
							ys[0] = 0;
							ys[1] = ys[2] = blockSize;
							g.drawPolygon(xs, ys, 3); // Little trick to make the
							// arrows of equal size
						} else {
							blockSize = Math.min(getWidth(), BasicSplitPaneDivider.ONE_TOUCH_SIZE);
							xs[0] = xs[2] = blockSize;
							xs[1] = 0;
							ys[0] = 0;
							ys[1] = blockSize;
							ys[2] = blockSize << 1;
						}
						g.fillPolygon(xs, ys, 3);
					}
				}

				@Override
				public void setBorder(final Border b) {
				}
			};
			b.setMinimumSize(new Dimension(BasicSplitPaneDivider.ONE_TOUCH_SIZE, BasicSplitPaneDivider.ONE_TOUCH_SIZE));
			b.setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));
			b.setFocusPainted(false);
			b.setBorderPainted(false);
			b.setRequestFocusEnabled(false);
			b.addActionListener(new ActionListener() {
				@Override
				public void actionPerformed(final ActionEvent e) {
					leftClicked();
				}
			});
			return b;
		}

		/**
		 * Creates and return an instance of JButton that can be used to
		 * collapse the right component in the split pane.
		 */
		@Override
		protected JButton createRightOneTouchButton() {
			final JButton b = new JButton() {
				/**
					 * 
					 */
				private static final long serialVersionUID = 1L;

				// Don't want the button to participate in focus traversable.
				@Override
				@Deprecated
				public boolean isFocusTraversable() {
					return false;
				}

				@Override
				public void paint(final Graphics g) {
					if (splitPane != null) {
						final int[] xs = new int[3];
						final int[] ys = new int[3];
						int blockSize;

						// Fill the background first ...
						g.setColor(ImprovedSplitPaneDivider.this.getBackground());
						g.fillRect(0, 0, getWidth(), getHeight());

						// ... then draw the arrow.
						if (orientation == JSplitPane.VERTICAL_SPLIT) {
							blockSize = Math.min(getHeight(), BasicSplitPaneDivider.ONE_TOUCH_SIZE);
							xs[0] = blockSize;
							xs[1] = blockSize << 1;
							xs[2] = 0;
							ys[0] = blockSize;
							ys[1] = ys[2] = 0;
						} else {
							blockSize = Math.min(getWidth(), BasicSplitPaneDivider.ONE_TOUCH_SIZE);
							xs[0] = xs[2] = 0;
							xs[1] = blockSize;
							ys[0] = 0;
							ys[1] = blockSize;
							ys[2] = blockSize << 1;
						}
						g.setColor(ImprovedSplitPaneDivider.this.getForeground());
						g.fillPolygon(xs, ys, 3);
					}
				}

				@Override
				public void setBorder(final Border border) {
				}
			};
			b.setMinimumSize(new Dimension(BasicSplitPaneDivider.ONE_TOUCH_SIZE, BasicSplitPaneDivider.ONE_TOUCH_SIZE));
			b.setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));
			b.setFocusPainted(false);
			b.setBorderPainted(false);
			b.setRequestFocusEnabled(false);
			b.addActionListener(new ActionListener() {
				@Override
				public void actionPerformed(final ActionEvent e) {
					rightClicked();
				}
			});
			return b;
		}

		protected void leftClicked() {

		}

		protected void rightClicked() {

		}
	}

	public static final int HORIZONTAL_SPLIT = JSplitPane.HORIZONTAL_SPLIT;
	public static final int VERTICAL_SPLIT = JSplitPane.VERTICAL_SPLIT;

	private JSplitPane split;
	private JPanel top, bottom;

	/**
		 * 
		 */
	public TransparentSplitPane() {
		this(TransparentSplitPane.HORIZONTAL_SPLIT);
	}

	/**
	 * @param split
	 */
	public TransparentSplitPane(final int split) {
		super(new BorderLayout());
		setOpaque(true);
		//setBackground(WidgetColors.COLOR_ENCLOSURE_BG);
		//setForeground(WidgetColors.COLOR_ENCLOSURE_BG);		
		top = new JPanel();
		top.setLayout(new BorderLayout());
		//top.setBackground(Color.LIGHT_GRAY);
		top.setOpaque(false);
		bottom = new JPanel();
		bottom.setLayout(new BorderLayout());
		//bottom.setBackground(Color.LIGHT_GRAY);
		bottom.setOpaque(false);
		this.split = new JSplitPane(split, true);
		this.split.setLeftComponent(top);
		this.split.setRightComponent(bottom);
		this.split.setBorder(BorderFactory.createEmptyBorder());
		this.split.setBackground(WidgetColors.COLOR_ENCLOSURE_BG);
		this.split.setOpaque(false);
		this.split.setUI(new BasicSplitPaneUI() {
			@Override
			public BasicSplitPaneDivider createDefaultDivider() {
				final BasicSplitPaneDivider divider = new ImprovedSplitPaneDivider(this) {
					/**
						 * 
						 */
					private static final long serialVersionUID = 1L;

					@Override
					public void leftClicked() {
						TransparentSplitPane.this.leftClicked();
					}

					@Override
					public void rightClicked() {
						TransparentSplitPane.this.rightClicked();
					}
				};
				divider.setBackground(WidgetColors.COLOR_ENCLOSURE_BG);
				divider.setForeground(Color.LIGHT_GRAY);
				return divider;
			}
		});
		add(this.split);
	}

	/**
	 * @param c
	 */
	public void setBottomComponent(final Component c) {
		bottom.removeAll();
		bottom.add(c);
		validate();
	}

	/**
	 * @param d
	 */
	public void setDividerLocation(final double d) {
		split.setDividerLocation(d);

	}

	/**
	 * @param location
	 */
	public void setDividerLocation(final int location) {
		split.setDividerLocation(location);
	}

	/**
	 * @param size
	 */
	public void setDividerSize(final int size) {
		split.setDividerSize(size);
	}

	/**
	 * @param c
	 */
	public void setLeftComponent(final Component c) {
		setTopComponent(c);
	}

	/**
	 * @param expandable
	 */
	public void setOneTouchExpandable(final boolean expandable) {
		split.setOneTouchExpandable(expandable);
	}

	/**
	 * @param d
	 */
	public void setResizeWeight(final double d) {
		split.setResizeWeight(d);
	}

	/**
	 * @param c
	 */
	public void setRightComponent(final Component c) {
		setBottomComponent(c);
	}

	/**
	 * @param c
	 */
	public void setTopComponent(final Component c) {
		top.removeAll();
		top.add(c);
		validate();
	}

	protected void leftClicked() {

	}

	protected void rightClicked() {

	}

	public void setForeground(Color fg) {
		super.setForeground(fg);
		if (top != null) {
			top.setForeground(fg);
		}
		if (bottom != null) {
			bottom.setForeground(fg);
		}
	}

	public void setBackground(Color bg) {
		super.setBackground(bg);
		// Workaround because setOpaque -> false does not work for some reason
		if (top != null) {
			top.setBackground(bg);
		}
		if (bottom != null) {
			bottom.setBackground(bg);
		}
	}

}
"
FilteredListModel.java,widget,"package org.processmining.framework.util.ui.widgets.traceview.model;

import javax.swing.ListModel;

import org.processmining.framework.util.ui.widgets.traceview.model.FilteredListModelImpl.ListModelFilter;

public interface FilteredListModel<E> {

	void filter(ListModelFilter<E> filter);

	ListModel<E> getUnfilteredListModel();

}
"
FilteredListModelImpl.java,widget,"package org.processmining.framework.util.ui.widgets.traceview.model;

import java.util.ArrayList;
import java.util.List;

import javax.swing.AbstractListModel;
import javax.swing.ListModel;
import javax.swing.event.ListDataEvent;
import javax.swing.event.ListDataListener;

/**
 * Provides a filtered {@link ListModel} based on a supplied
 * {@link ListModelFilter}.
 * 
 * @author F.Mannhardt
 *
 * @param <E>
 */
public final class FilteredListModelImpl<T extends ListModel<E>, E> extends AbstractListModel<E>
		implements FilteredListModel<E> {

	private static final long serialVersionUID = -5708650645208821099L;

	public static interface ListModelFilter<E> {
		boolean accept(E e);
	}

	private ListModelFilter<E> currentFilter;
	private final T originalListModel;
	private final List<Integer> visibleElements = new ArrayList<Integer>();

	public FilteredListModelImpl(T source) {
		originalListModel = source;
		getUnfilteredListModel().addListDataListener(new ListDataListener() {
			public void intervalRemoved(ListDataEvent e) {
				boolean changed = doFilter();
				if (!changed) {
					fireIntervalRemoved(e.getSource(), e.getIndex0(), e.getIndex1());
				}
			}

			public void intervalAdded(ListDataEvent e) {
				boolean changed = doFilter();
				if (!changed) {
					fireIntervalAdded(e.getSource(), e.getIndex0(), e.getIndex1());
				}
			}

			public void contentsChanged(ListDataEvent e) {
				boolean changed = doFilter();
				if (!changed) {
					fireContentsChanged(e.getSource(), e.getIndex0(), e.getIndex1());
				}
			}
		});
	}

	public T getUnfilteredListModel() {
		return originalListModel;
	}

	public void filter(ListModelFilter<E> f) {
		currentFilter = f;
		doFilter();
	}

	protected boolean doFilter() {
		ListModelFilter<E> f = currentFilter;
		if (f != null) {
			visibleElements.clear();
			int count = getUnfilteredListModel().getSize();
			for (int i = 0; i < count; i++) {
				if (f.accept(getUnfilteredListModel().getElementAt(i))) {
					visibleElements.add(i);
				}
			}
			fireContentsChanged(this, 0, getSize() - 1);
			return true;
		}
		return false;
	}

	@Override
	public int getSize() {
		return (currentFilter != null) ? visibleElements.size() : getUnfilteredListModel().getSize();
	}

	@Override
	public E getElementAt(int index) {
		return (currentFilter != null) ? getUnfilteredListModel().getElementAt(visibleElements.get(index))
				: getUnfilteredListModel().getElementAt(index);
	}

}"
MutableListModel.java,widget,"package org.processmining.framework.util.ui.widgets.traceview.model;

import javax.swing.ListModel;

public interface MutableListModel<T> extends ListModel<T> {

	boolean add(T element);
	
	boolean addAll(Iterable<T> elements);

	void clear();
	
}
"
SortableListModel.java,widget,"package org.processmining.framework.util.ui.widgets.traceview.model;

import java.util.Comparator;

public interface SortableListModel<T> extends MutableListModel<T> {

	void sort(Comparator<T> comparator);
	
}
"
SortableListModelImpl.java,widget,"package org.processmining.framework.util.ui.widgets.traceview.model;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;

import javax.swing.AbstractListModel;
import javax.swing.JList;
import javax.swing.ListModel;

/**
 * Provides a sorted {@link ListModel} based on an {@link ArrayList} for use
 * with a {@link JList}.
 * 
 * @author F. Mannhardt
 *
 * @param <T>
 */
public final class SortableListModelImpl<T> extends AbstractListModel<T> implements SortableListModel<T> {

	private static final long serialVersionUID = -8658365206622116891L;

	private final List<T> sortedList;

	public SortableListModelImpl() {
		this(Collections.<T>emptyList());
	}

	public SortableListModelImpl(Collection<T> traces) {
		super();
		this.sortedList = new ArrayList<T>(traces);
	}

	public int getSize() {
		return sortedList.size();
	}

	public T getElementAt(int index) {
		return sortedList.get(index);
	}

	public boolean add(T element) {
		if (sortedList.add(element)) {
			fireIntervalAdded(this, sortedList.size(), sortedList.size());
			return true;
		} else {
			return false;
		}
	}

	public boolean addAll(Iterable<T> elements) {
		final int sizeBefore = sortedList.size();
		boolean hasAdded = false;
		if (elements instanceof Collection) {
			hasAdded = sortedList.addAll((Collection<T>) elements);
		} else {
			for (T item : elements) {
				// Side-effect is adding the element 
				hasAdded = sortedList.add(item) || hasAdded;
			}
		}
		if (hasAdded) {
			fireIntervalAdded(this, sizeBefore + 1, sortedList.size());
			return true;
		}
		return false;
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see
	 * org.processmining.framework.util.ui.widgets.traceview.SortableListModel#
	 * sort(java.util.Comparator)
	 */
	public void sort(Comparator<T> comparator) {
		Collections.sort(sortedList, comparator);
		fireContentsChanged(this, 0, sortedList.size());
	}

	public void clear() {
		sortedList.clear();
		fireIntervalRemoved(this, 0, sortedList.size());
	}

}"
ProMTraceList.java,widget,"/*
 * Copyright (c) 2014 F. Mannhardt (f.mannhardt@tue.nl)
 * 
 * LICENSE:
 * 
 * This code is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License as published by the Free Software
 * Foundation; either version 2 of the License, or (at your option) any later
 * version.
 * 
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
 * details.
 * 
 * You should have received a copy of the GNU General Public License along with
 * this program; if not, write to the Free Software Foundation, Inc., 51
 * Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA
 */
package org.processmining.framework.util.ui.widgets.traceview;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Component;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.Graphics2D;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.Stroke;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.EventListener;
import java.util.Iterator;
import java.util.List;
import java.util.Properties;
import java.util.Set;
import java.util.concurrent.CopyOnWriteArraySet;

import javax.swing.Box;
import javax.swing.BoxLayout;
import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JList;
import javax.swing.JPanel;
import javax.swing.JProgressBar;
import javax.swing.JScrollPane;
import javax.swing.ListCellRenderer;
import javax.swing.ListModel;
import javax.swing.event.ListSelectionListener;

import org.freehep.graphics2d.VectorGraphics;
import org.freehep.graphicsio.MultiPageDocument;
import org.freehep.graphicsio.PageConstants;
import org.freehep.graphicsio.VectorGraphicsIO;
import org.freehep.graphicsio.emf.EMFGraphics2D;
import org.freehep.graphicsio.pdf.PDFGraphics2D;
import org.freehep.graphicsio.ps.EPSGraphics2D;
import org.freehep.graphicsio.svg.SVGGraphics2D;
import org.processmining.framework.util.ui.widgets.ProMScrollPane;
import org.processmining.framework.util.ui.widgets.traceview.ProMTraceView.DefaultEvent;
import org.processmining.framework.util.ui.widgets.traceview.ProMTraceView.DefaultTrace;
import org.processmining.framework.util.ui.widgets.traceview.ProMTraceView.Event;
import org.processmining.framework.util.ui.widgets.traceview.ProMTraceView.Trace;
import org.processmining.framework.util.ui.widgets.traceview.model.FilteredListModel;
import org.processmining.framework.util.ui.widgets.traceview.model.FilteredListModelImpl;
import org.processmining.framework.util.ui.widgets.traceview.model.FilteredListModelImpl.ListModelFilter;
import org.processmining.framework.util.ui.widgets.traceview.model.MutableListModel;
import org.processmining.framework.util.ui.widgets.traceview.model.SortableListModel;
import org.processmining.framework.util.ui.widgets.traceview.model.SortableListModelImpl;

import com.fluxicon.slickerbox.factory.SlickerFactory;

/**
 * A {@link JPanel} that displays a list of arbitrary objects that are
 * visualized as ""wedges"" using {@link ProMTraceView}. It uses a {@link JList}
 * under the hood, which can be accessed directly using {@link #getList()}.
 * <p>
 * To use this component you need to create a {@link TraceBuilder} that takes
 * any of your objects and returns a {@link Trace} of {@link Event}s. This
 * conversion happens on-the-fly and only for the objects that are currently
 * shown to the user. Therefore, the performance overhead should be small.
 * <p>
 * There are default implementations {@link DefaultTrace} and
 * {@link DefaultEvent} available for convenience. If your class already
 * implements {@link Trace}, then use the provided {@link NoOpTraceBuilder}.
 * <p>
 * It is possible to sort and filter the list by using an appropriate
 * {@link ListModel}. Such as {@link SortableListModelImpl} or
 * {@link FilteredListModelImpl}.
 * <p>
 * It is also possible to listen for click, selection and mouse movement events
 * on an element of the list by using
 * {@link #addTraceClickListener(ClickListener)}.
 * {@link #addTraceSelectionListener(ListSelectionListener)}, as well as
 * {@link #addTraceMoveListener(MoveListener)}.
 * 
 * @author F. Mannhardt
 * 
 * @param <T>
 *            the class of objects that are to be visualized
 */
public class ProMTraceList<T> extends JPanel {

	public interface ClickListener<T> extends EventListener {

		/**
		 * Event that the user has double clicked on a trace.
		 * 
		 * @param trace
		 *            the object that has been clicked on
		 * @param traceIndex
		 *            the index of the trace in the list
		 * @param eventIndex
		 *            the index of the event that has been clicked on or -1 in
		 *            case not event was below the mouse pointer
		 * @param e
		 *            the original {@link MouseEvent}
		 */
		public void traceMouseDoubleClicked(T trace, int traceIndex, int eventIndex, MouseEvent e);

		/**
		 * Event that the user has clicked on a trace.
		 * 
		 * @param trace
		 *            the object that has been clicked on
		 * @param traceIndex
		 *            the index of the trace in the list
		 * @param eventIndex
		 *            the index of the event that has been clicked on or -1 in
		 *            case not event was below the mouse pointer
		 * @param e
		 *            the original {@link MouseEvent}
		 */
		public void traceMouseClicked(T trace, int traceIndex, int eventIndex, MouseEvent e);

	}

	public interface MoveListener<T> extends EventListener {

		/**
		 * Event that the user has moved the mouse over a trace.
		 * 
		 * @param trace
		 *            the object that has been moved over
		 * @param traceIndex
		 *            the index of the trace in the list
		 * @param eventIndex
		 *            the index of the event or -1 in case no event was below
		 *            the mouse pointer
		 * @param e
		 *            the original {@link MouseEvent}
		 */
		public void traceMouseMoved(T trace, int traceIndex, int eventIndex, MouseEvent e);

	}

	/**
	 * Builds {@link Trace} objects for object of class T.
	 * 
	 * @author F. Mannhardt
	 * 
	 * @param <T>
	 *            class of object that is converted to a {@link Trace}
	 */
	public interface TraceBuilder<T> {

		/**
		 * @param element
		 * @return a {@link Trace}
		 */
		Trace<? extends Event> build(T element);

	}

	/**
	 * Can be used to override the default coloring of an {@link Event} based on
	 * some other information. If only one of the colors needs to be overridden,
	 * please use {@link DefaultWedgeBuilder}.
	 * 
	 * @author F. Mannhardt
	 * 
	 */
	public interface WedgeBuilder {

		Color buildNameColor(Trace<? extends Event> trace);

		Color buildInfoColor(Trace<? extends Event> trace);

		Color buildWedgeColor(Trace<? extends Event> trace, Event event);

		Integer assignWedgeGap(Trace<? extends Event> trace, Event event);

		Stroke buildBorderStroke(Trace<? extends Event> trace, Event event);

		Color buildBorderColor(Trace<? extends Event> trace, Event event);

		Color buildLabelColor(Trace<? extends Event> trace, Event event);

		Color buildTopLabelColor(Trace<? extends Event> trace, Event event);

		Color buildBottomLabelColor(Trace<? extends Event> trace, Event event);

		Color buildBottom2LabelColor(Trace<? extends Event> trace, Event event);

	}

	/**
	 * {@link WedgeBuilder} that simply returns the original color of an
	 * {@link Event}. Override single methods to change the color.
	 * 
	 * @author F. Mannhardt
	 * 
	 */
	public static class DefaultWedgeBuilder implements WedgeBuilder {

		public Color buildWedgeColor(Trace<? extends Event> trace, Event event) {
			return event.getWedgeColor();
		}

		public Color buildLabelColor(Trace<? extends Event> trace, Event event) {
			return event.getLabelColor();
		}

		public Color buildTopLabelColor(Trace<? extends Event> trace, Event event) {
			return event.getTopLabelColor();
		}

		public Color buildBottomLabelColor(Trace<? extends Event> trace, Event event) {
			return event.getBottomLabelColor();
		}

		public Color buildBottom2LabelColor(Trace<? extends Event> trace, Event event) {
			return event.getBottomLabel2Color();
		}

		public Color buildBorderColor(Trace<? extends Event> trace, Event event) {
			return event.getBorderColor();
		}

		public Integer assignWedgeGap(Trace<? extends Event> trace, Event event) {
			return null;
		}

		public Stroke buildBorderStroke(Trace<? extends Event> trace, Event e) {
			return null;
		}

		public Color buildNameColor(Trace<? extends Event> trace) {
			return trace.getNameColor();
		}

		public Color buildInfoColor(Trace<? extends Event> trace) {
			return trace.getInfoColor();
		}

	}

	/**
	 * {@link WedgeBuilder} that delegates all methods to another
	 * {@link WedgeBuilder}.
	 * 
	 * @author F. Mannhardt
	 * 
	 */
	public static class DelegateWedgeBuilder extends DefaultWedgeBuilder {

		private final WedgeBuilder wedgeBuilder;

		public DelegateWedgeBuilder(WedgeBuilder wedgeBuilder) {
			this.wedgeBuilder = wedgeBuilder;
		}

		public Color buildWedgeColor(Trace<? extends Event> trace, Event event) {
			Color color = wedgeBuilder.buildWedgeColor(trace, event);
			if (color != null) {
				return color;
			}
			return super.buildWedgeColor(trace, event);
		}

		public Color buildLabelColor(Trace<? extends Event> trace, Event event) {
			Color color = wedgeBuilder.buildLabelColor(trace, event);
			if (color != null) {
				return color;
			}
			return super.buildLabelColor(trace, event);
		}

		public Color buildTopLabelColor(Trace<? extends Event> trace, Event event) {
			Color color = wedgeBuilder.buildTopLabelColor(trace, event);
			if (color != null) {
				return color;
			}
			return super.buildTopLabelColor(trace, event);
		}

		public Color buildBottomLabelColor(Trace<? extends Event> trace, Event event) {
			Color color = wedgeBuilder.buildBottomLabelColor(trace, event);
			if (color != null) {
				return color;
			}
			return super.buildBottomLabelColor(trace, event);
		}

		public Color buildBottom2LabelColor(Trace<? extends Event> trace, Event event) {
			Color color = wedgeBuilder.buildBottom2LabelColor(trace, event);
			if (color != null) {
				return color;
			}
			return super.buildBottom2LabelColor(trace, event);
		}

		public Color buildBorderColor(Trace<? extends Event> trace, Event event) {
			Color color = wedgeBuilder.buildBorderColor(trace, event);
			if (color != null) {
				return color;
			}
			return super.buildBorderColor(trace, event);
		}

		public Integer assignWedgeGap(Trace<? extends Event> trace, Event event) {
			Integer wedgeGap = wedgeBuilder.assignWedgeGap(trace, event);
			if (wedgeGap != null) {
				return wedgeGap;
			}
			return super.assignWedgeGap(trace, event);
		}

		public Stroke buildBorderStroke(Trace<? extends Event> trace, Event e) {
			Stroke wedgeStroke = wedgeBuilder.buildBorderStroke(trace, e);
			if (wedgeStroke != null) {
				return wedgeStroke;
			}
			return super.buildBorderStroke(trace, e);
		}

		public Color buildNameColor(Trace<? extends Event> trace) {
			Color color = wedgeBuilder.buildNameColor(trace);
			if (color != null) {
				return color;
			}
			return super.buildNameColor(trace);
		}

		public Color buildInfoColor(Trace<? extends Event> trace) {
			Color color = wedgeBuilder.buildInfoColor(trace);
			if (color != null) {
				return color;
			}
			return super.buildInfoColor(trace);
		}

	}

	/**
	 * TraceBuilder that just returns a class, which already implements
	 * {@link Trace}.
	 * 
	 * @author F. Mannhardt
	 * 
	 */
	public static class NoOpTraceBuilder<T extends Event> implements TraceBuilder<Trace<T>> {

		public Trace<? extends Event> build(Trace<T> e) {
			return e;
		}

	}

	private static final Font DEFAULT_FONT = new Font(null, Font.PLAIN, 10);

	private final static class ProMTraceListMouseAdapter<T> extends MouseAdapter {

		private final Set<ClickListener<T>> clickListener;
		private final Set<MoveListener<T>> moveListener;
		private final JList<T> list;
		private ProMTraceViewCellRenderer<T> cellRenderer;

		private ProMTraceListMouseAdapter(JList<T> list, ProMTraceViewCellRenderer<T> cellRenderer,
				Set<ClickListener<T>> clickListener, Set<MoveListener<T>> moveListener) {
			super();
			this.list = list;
			this.cellRenderer = cellRenderer;
			this.clickListener = clickListener;
			this.moveListener = moveListener;
		}

		public void mouseClicked(MouseEvent e) {

			if (!clickListener.isEmpty()) {
				final int traceIndex = getTraceIndex(e);
				if (traceIndex != -1) {
					final T trace = list.getModel().getElementAt(traceIndex);
					final int eventIndex = getEventIndex(traceIndex, trace, e);

					for (ClickListener<T> listener : clickListener) {
						if (e.getClickCount() == 2) {
							listener.traceMouseDoubleClicked(trace, traceIndex, eventIndex, e);
						} else if (e.getClickCount() == 1) {
							listener.traceMouseClicked(trace, traceIndex, eventIndex, e);
						}
					}
				}
			}
		}

		public void mouseMoved(MouseEvent e) {

			if (!moveListener.isEmpty()) {
				final int traceIndex = getTraceIndex(e);
				if (traceIndex != -1) {
					final T trace = list.getModel().getElementAt(traceIndex);
					final int eventIndex = getEventIndex(traceIndex, trace, e);

					for (MoveListener<T> listener : moveListener) {
						listener.traceMouseMoved(trace, traceIndex, eventIndex, e);
					}
				}
			}
		}

		private int getEventIndex(int traceIndex, T trace, MouseEvent e) {
			return cellRenderer.translateToEventIndex(e.getPoint(), trace, list.isSelectedIndex(traceIndex));
		}

		private int getTraceIndex(MouseEvent e) {
			Rectangle r = list.getCellBounds(0, list.getLastVisibleIndex());
			if (r != null && r.contains(e.getPoint())) {
				return list.locationToIndex(e.getPoint());
			}
			return -1;
		}

	}

	/**
	 * The {@link ListCellRenderer} used to paint the objects.
	 * 
	 * @author F. Mannhardt
	 * 
	 * @param <T>
	 */
	private final static class ProMTraceViewCellRenderer<E> extends ProMTraceView implements ListCellRenderer<E> {

		private static final long serialVersionUID = -2495069999724478333L;

		private TraceBuilder<E> traceBuilder;
		private E currentValue;
		private int fixedWidthLimit = DEFAULT_FIXED_WIDTH_TRACE_COUNT;

		private final ListModel<E> listModel;

		public ProMTraceViewCellRenderer(ListModel<E> listModel, TraceBuilder<E> traceBuilder, Font defaultFont,
				boolean hasLabels) {
			super(defaultFont, hasLabels);
			this.listModel = listModel;
			setTraceBuilder(traceBuilder);
			setOpaque(false);
		}

		@Override
		public Component getListCellRendererComponent(JList<? extends E> list, E value, int index, boolean isSelected,
				boolean cellHasFocus) {
			if (value != currentValue) {
				setTrace(getTraceBuilder().build(value));
				updatePreferredSize();
			}
			currentValue = value;
			setSelected(isSelected);
			setForeground(list.getForeground());
			return this;
		}

		public int translateToEventIndex(Point point, E value, boolean isSelected) {
			if (value != currentValue) {
				setTrace(getTraceBuilder().build(value));
				updatePreferredSize();
			}
			currentValue = value;
			setSelected(isSelected);
			return translateToEventIndex(point);
		}

		public int translateToDetailedEventIndex(Point point, E value, boolean isSelected) {
			if (value != currentValue) {
				setTrace(getTraceBuilder().build(value));
				updatePreferredSize();
			}
			currentValue = value;
			setSelected(isSelected);
			return translateToDetailedEventIndex(point);
		}

		public TraceBuilder<E> getTraceBuilder() {
			return traceBuilder;
		}

		public void setTraceBuilder(TraceBuilder<E> traceBuilder) {
			this.currentValue = null;
			this.traceBuilder = traceBuilder;
		}

		public int getFixedWidthLimit() {
			return fixedWidthLimit;
		}

		public void setFixedWidthLimit(int fixedWidthLimit) {
			this.currentValue = null;
			this.fixedWidthLimit = fixedWidthLimit;
		}

		@Override
		public int getFixedWedgeWidth() {
			// listModel might be have been initialized yet
			if (listModel != null && listModel.getSize() > getFixedWidthLimit()) {
				// Override the wedge width, either with max width or the preset fixed width
				return super.getFixedWedgeWidth() == -1 ? getMaxWedgeWidth() : super.getFixedWedgeWidth();
			} else {
				// Return the normal setting
				return super.getFixedWedgeWidth();
			}
		}

		@Override
		public int getFixedInfoWidth() {
			// listModel might be have been initialized yet
			if (listModel != null && listModel.getSize() > getFixedWidthLimit()) {
				// Override the info width, either with max width or the preset fixed width
				return super.getFixedInfoWidth() == -1 ? getMaxInfoWidth() : super.getFixedInfoWidth();
			} else {
				// Return the normal setting
				return super.getFixedInfoWidth();
			}
		}

		@Override
		public String getToolTipText(MouseEvent e) {
			int event = translateToDetailedEventIndex(e.getPoint(), currentValue, isSelected());
			if (event != -1) {
				Trace<?> tr = traceBuilder.build(currentValue);
				if (event == -2) {
					return ""<html>"" + n(tr.getName()) + ""<br>"" + n(tr.getInfo()) + ""</html>"";
				} else if (event >= 0) {
					for (Iterator<? extends Event> it = tr.iterator(); it.hasNext();) {
						Event ev = it.next();
						if (event == 0) {
							return ""<html>"" + n(ev.getTopLabel()) + ""<br>"" + n(ev.getLabel()) + ""<br>""
									+ n(ev.getBottomLabel()) + ""<br>"" + n(ev.getBottomLabel2()) + ""</html>"";
						}
						event--;
					}
				}
			}
			return null;
		}

		private String n(Object x) {
			return x == null ? """" : x.toString();
		}
	}

	private static final long serialVersionUID = -8729322696443726936L;

	public static final int DEFAULT_FIXED_WIDTH_TRACE_COUNT = 50000;

	private final ListModel<T> listModel;
	private final JList<T> jList;
	private final ProMTraceViewCellRenderer<T> cellRenderer;
	private final boolean hasLabels;

	private final JScrollPane scrollPane;

	private transient CopyOnWriteArraySet<ClickListener<T>> clickListener = new CopyOnWriteArraySet<ClickListener<T>>();
	private transient CopyOnWriteArraySet<MoveListener<T>> moveListener = new CopyOnWriteArraySet<MoveListener<T>>();

	private JProgressBar progressBar;

	private JPanel toolbar;
	private JButton selectAll;
	private JButton deselectAll;

	/**
	 * Creates an empty {@link ProMTraceList}
	 * 
	 * @param traceBuilder
	 */
	public ProMTraceList(TraceBuilder<T> traceBuilder) {
		this(Collections.<T>emptyList(), traceBuilder);
	}

	/**
	 * Creates a filterable and sortable {@link ProMTraceList} from the supplied
	 * {@link Collection} of objects
	 * 
	 * @param traces
	 * @param traceBuilder
	 */
	public ProMTraceList(Collection<T> traces, TraceBuilder<T> traceBuilder) {
		this(traces, traceBuilder, DEFAULT_FONT);
	}

	/**
	 * Creates a filterable and sortable {@link ProMTraceList} from the supplied
	 * {@link Collection} of objects
	 * 
	 * @param traces
	 * @param traceBuilder
	 * @param labelFont
	 */
	public ProMTraceList(Collection<T> traces, TraceBuilder<T> traceBuilder, Font labelFont) {
		this(traces, traceBuilder, null, labelFont);
	}

	/**
	 * Creates a filterable and sortable {@link ProMTraceList} from the supplied
	 * {@link Collection} of objects
	 * 
	 * @param traces
	 * @param traceBuilder
	 * @param labelFont
	 * @param hasLabels
	 */
	public ProMTraceList(Collection<T> traces, TraceBuilder<T> traceBuilder, Font labelFont, boolean hasLabels) {
		this(traces, traceBuilder, null, labelFont, hasLabels);
	}

	/**
	 * Creates a filterable and sortable {@link ProMTraceList} from the supplied
	 * {@link Collection} of objects
	 * 
	 * @param traces
	 * @param traceBuilder
	 * @param order
	 */
	public ProMTraceList(Collection<T> traces, TraceBuilder<T> traceBuilder, Comparator<T> order) {
		this(traces, traceBuilder, order, DEFAULT_FONT);
	}

	public ProMTraceList(Collection<T> traces, TraceBuilder<T> traceBuilder, Comparator<T> order, Font labelFont) {
		this(traces, traceBuilder, order, labelFont, true);
	}

	/**
	 * Creates a filterable and sortable {@link ProMTraceList} from the supplied
	 * {@link Collection} of objects
	 * 
	 * @param traces
	 * @param traceBuilder
	 * @param order
	 * @param labelFont
	 * @param hasLabels
	 */
	public ProMTraceList(Collection<T> traces, TraceBuilder<T> traceBuilder, Comparator<T> order, Font labelFont,
			boolean hasLabels) {
		this(new FilteredListModelImpl<>(new SortableListModelImpl<>(traces)), traceBuilder, labelFont, hasLabels);
		if (order != null) {
			sort(order);
		}
	}

	/**
	 * Creates a {@link ProMTraceList} from the supplied {@link ListModel}, if
	 * you want your list to be sortable and filterable your {@link ListModel}
	 * needs to implement {@link FilteredListModel} and
	 * {@link SortableListModel}.
	 * 
	 * @param traceModel
	 * @param traceBuilder
	 */
	public ProMTraceList(ListModel<T> traceModel, TraceBuilder<T> traceBuilder) {
		this(traceModel, traceBuilder, DEFAULT_FONT);
	}

	public ProMTraceList(ListModel<T> traceModel, TraceBuilder<T> traceBuilder, Font labelFont) {
		this(traceModel, traceBuilder, labelFont, true);
	}

	/**
	 * Creates a {@link ProMTraceList} from the supplied {@link ListModel}, if
	 * you want your list to be sortable and filterable your {@link ListModel}
	 * needs to implement {@link FilteredListModel} and
	 * {@link SortableListModel}.
	 * 
	 * @param traces
	 * @param traceBuilder
	 * @param labelFont
	 *            to be used
	 * @param whether
	 *            there should be space for labels
	 */
	public ProMTraceList(ListModel<T> listModel, TraceBuilder<T> traceBuilder, Font labelFont, boolean hasLabels) {
		this.listModel = listModel;
		this.hasLabels = hasLabels;
		this.cellRenderer = new ProMTraceViewCellRenderer<T>(listModel, traceBuilder, labelFont, hasLabels);
		setFont(labelFont);

		jList = new JList<T>(listModel);
		jList.setFixedCellHeight((int) cellRenderer.getPreferredSize().getHeight());
		jList.setOpaque(false);
		jList.setForeground(null);
		jList.setBackground(null);
		jList.setCellRenderer(cellRenderer);

		ProMTraceListMouseAdapter<T> mouseAdapter = new ProMTraceListMouseAdapter<T>(jList, cellRenderer, clickListener,
				moveListener);
		jList.addMouseListener(mouseAdapter);
		jList.addMouseMotionListener(mouseAdapter);

		setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));
		setOpaque(false);
		setForeground(null);
		setBackground(null);

		toolbar = new JPanel();
		toolbar.setMaximumSize(new Dimension(Short.MAX_VALUE, 30));
		toolbar.setOpaque(false);
		toolbar.setForeground(null);
		toolbar.setBackground(null);
		toolbar.setVisible(false);
		toolbar.setLayout(new BoxLayout(toolbar, BoxLayout.X_AXIS));
		selectAll = SlickerFactory.instance().createButton(""Select all"");
		selectAll.addActionListener(new ActionListener() {

			public void actionPerformed(ActionEvent e) {
				jList.setSelectionInterval(0, jList.getModel().getSize() - 1);
			}
		});
		toolbar.add(selectAll);
		toolbar.add(Box.createHorizontalStrut(5));
		deselectAll = SlickerFactory.instance().createButton(""Deselect all"");
		deselectAll.addActionListener(new ActionListener() {

			public void actionPerformed(ActionEvent e) {
				jList.clearSelection();
			}
		});
		toolbar.add(deselectAll);
		toolbar.add(Box.createGlue());

		scrollPane = new ProMScrollPane(jList);
		scrollPane.setOpaque(false);
		scrollPane.setForeground(null);
		scrollPane.setBackground(null);
		scrollPane.getViewport().setOpaque(false);
		scrollPane.getViewport().setForeground(null);
		scrollPane.getViewport().setBackground(null);

		progressBar = new JProgressBar();
		progressBar.setIndeterminate(true);
		progressBar.setString(""Loading ..."");
		progressBar.setStringPainted(true);

		add(toolbar, BorderLayout.NORTH);
		add(scrollPane, BorderLayout.CENTER);
	}

	public void addTraceSelectionListener(ListSelectionListener l) {
		jList.addListSelectionListener(l);
	}

	public void removeTraceSelectionListener(ListSelectionListener l) {
		jList.removeListSelectionListener(l);
	}

	public void addTraceClickListener(ClickListener<T> l) {
		clickListener.add(l);
	}

	public void removeTraceClickListener(ClickListener<T> l) {
		clickListener.remove(l);
	}

	public void addTraceMoveListener(MoveListener<T> l) {
		moveListener.add(l);
	}

	public void removeTraceMoveListener(MoveListener<T> l) {
		moveListener.remove(l);
	}

	/**
	 * @return the underlying {@link JList}
	 */
	public JList<T> getList() {
		return jList;
	}

	/**
	 * @return the underlying {@link JScrollPane}
	 */
	public JScrollPane getScrollPane() {
		return scrollPane;
	}

	/**
	 * @return the underlying {@link ListModel}
	 */
	public ListModel<T> getListModel() {
		return listModel;
	}

	/****************************************************************************
	 * Methods for special ListModels, mainly here for legacy reasons. Better to
	 * use ListModel directly!
	 ****************************************************************************/

	/**
	 * Adds the element to this view. Please note your {@link ListModel} needs
	 * to implement {@link MutableListModel} otherwise an
	 * {@link UnsupportedOperationException} will be thrown.
	 * 
	 * @param element
	 * @throws UnsupportedOperationException
	 *             in case the ListModel is not mutable
	 */
	public void add(T element) {
		if (listModel instanceof FilteredListModel) {
			@SuppressWarnings(""unchecked"")
			FilteredListModel<T> filteredListModel = (FilteredListModel<T>) listModel;
			((SortableListModel<T>) filteredListModel.getUnfilteredListModel()).add(element);
		} else if (listModel instanceof MutableListModel) {
			((MutableListModel<T>) listModel).add(element);
		} else {
			throw new UnsupportedOperationException(
					""ListModel does not implement MutableListModel, please add data directly to the ListModel you supplied!"");
		}
	}

	/**
	 * Adds the elements to this view. Please note your {@link ListModel} needs
	 * to implement {@link MutableListModel} otherwise an
	 * {@link UnsupportedOperationException} will be thrown.
	 * 
	 * @param elements
	 * @throws UnsupportedOperationException
	 *             in case the ListModel is not mutable
	 */
	public void addAll(Iterable<T> elements) {
		if (listModel instanceof FilteredListModel) {
			@SuppressWarnings(""unchecked"")
			FilteredListModel<T> filteredListModel = (FilteredListModel<T>) listModel;
			((MutableListModel<T>) filteredListModel.getUnfilteredListModel()).addAll(elements);
		} else if (listModel instanceof MutableListModel) {
			((MutableListModel<T>) listModel).addAll(elements);
		} else {
			throw new UnsupportedOperationException(
					""ListModel does not implement MutableListModel, please add data directly to the ListModel you supplied!"");
		}
	}

	/**
	 * Clears the underlying data structure {@link #getListModel()}.
	 * 
	 * @throws UnsupportedOperationException
	 *             in case the ListModel is not mutable
	 */
	public void clear() {
		if (listModel instanceof FilteredListModel) {
			@SuppressWarnings(""unchecked"")
			FilteredListModel<T> filteredListModel = (FilteredListModel<T>) listModel;
			((MutableListModel<T>) filteredListModel.getUnfilteredListModel()).clear();
		} else if (listModel instanceof MutableListModel) {
			((MutableListModel<T>) listModel).clear();
		} else {
			throw new UnsupportedOperationException(
					""ListModel does not implement MutableListModel, please clear your data directly in the ListModel you supplied!"");
		}
	}

	public void sort(Comparator<T> sortOrder) {
		if (listModel instanceof FilteredListModel) {
			@SuppressWarnings(""unchecked"")
			FilteredListModel<T> filteredListModel = (FilteredListModel<T>) listModel;
			((SortableListModel<T>) filteredListModel.getUnfilteredListModel()).sort(sortOrder);
		} else if (listModel instanceof SortableListModel) {
			((SortableListModel<T>) listModel).sort(sortOrder);
		} else {
			throw new UnsupportedOperationException(
					""ListModel does not implement SortableListModel, please sort your data directly in the ListModel you supplied!"");
		}
	}

	@SuppressWarnings(""unchecked"")
	public void filter(ListModelFilter<T> filter) {
		if (listModel instanceof FilteredListModel) {
			((FilteredListModel<T>) listModel).filter(filter);
		} else {
			throw new UnsupportedOperationException(
					""ListModel does not implement FilteredListModel, please filter your data directly in the ListModel you supplied!"");
		}
	}

	/*********************************************************/

	/**
	 * Set the factor by which the color of the unselected traces is modified.
	 * For example, 1.0 will result in no change and 0.5 will darken the color.
	 * 
	 * @param attenuationFactor
	 *            non-negative factor
	 */
	public void setAttenuationFactor(float attenuationFactor) {
		cellRenderer.setAttenuationFactor(attenuationFactor);
	}

	public float getAttenuationFactor() {
		return cellRenderer.getAttenuationFactor();
	}

	public WedgeBuilder getWedgeBuilder() {
		return cellRenderer.getWedgeBuilder();
	}

	/**
	 * Use a {@link WedgeBuilder} to dynamically override the color of an
	 * {@link Event}. Use {@link DefaultWedgeBuilder}, if you only want to
	 * override a certain color.
	 * 
	 * @param wedgeBuilder
	 *            that overrides the default color of an event
	 */
	public void setWedgeBuilder(WedgeBuilder wedgeBuilder) {
		if (wedgeBuilder == null) {
			cellRenderer.setWedgeBuilder(new DefaultWedgeBuilder());
		} else {
			cellRenderer.setWedgeBuilder(new DelegateWedgeBuilder(wedgeBuilder));
		}
	}

	public int getMaxWedgeWidth() {
		return cellRenderer.getMaxWedgeWidth();
	}

	/**
	 * Set the maximum width (in pixel) of a single ""event wedge"".
	 * 
	 * @param maxWidth
	 */
	public void setMaxWedgeWidth(int maxWidth) {
		cellRenderer.setMaxWedgeWidth(maxWidth);
	}

	public int getMaxInfoWidth() {
		return cellRenderer.getMaxInfoWidth();
	}

	/**
	 * Set the maximum width (in pixel) of the trace info area.
	 * 
	 * @param maxWidth
	 */
	public void setMaxInfoWidth(int maxWidth) {
		cellRenderer.setMaxInfoWidth(maxWidth);
	}

	/**
	 * Set the fixed width (in pixel) of a single ""event wedge"". Set to -1 to
	 * enable dynamic sizing (slower) according to the length of labels.
	 * 
	 * @param fixedWidth
	 */
	public void setFixedWedgeWidth(int fixedWidth) {
		cellRenderer.setFixedWedgeWidth(fixedWidth);
	}

	/**
	 * Set the fixed width (in pixel) of the trace info area. Set to -1 to
	 * enable dynamic sizing (slower) according to the length of labels.
	 * 
	 * @param fixedWidth
	 */
	public void setFixedInfoWidth(int fixedWidth) {
		cellRenderer.setFixedInfoWidth(fixedWidth);
	}

	public int getFixedWedgeLimit() {
		return cellRenderer.getFixedWidthLimit();
	}

	/**
	 * Changes the built-in limit of events per trace that is used to determine
	 * when to switch to fixed size wedge width for performance reasons.
	 * 
	 * @param fixedWedgeLimit
	 */
	public void setFixedWedgeLimit(int fixedWedgeLimit) {
		cellRenderer.setFixedWidthLimit(fixedWedgeLimit);
	}

	public int getCollapsedLabelLength() {
		return cellRenderer.getCollapsedLabelLength();
	}

	/**
	 * Set the length of the label shown in a collapsed event, in an unselected
	 * trace.
	 * 
	 * @param collapsedLabelLength
	 */
	public void setCollapsedLabelLength(int collapsedLabelLength) {
		cellRenderer.setCollapsedLabelLength(collapsedLabelLength);
	}

	public Stroke getWedgeStroke() {
		return cellRenderer.getWedgeStroke();
	}

	/**
	 * @param wedgeStroke
	 *            the default {@link Stroke} that the wedges border is painted
	 *            with
	 */
	public void setWedgeStroke(Stroke wedgeStroke) {
		cellRenderer.setWedgeStroke(wedgeStroke);
	}

	public int getWedgeGap() {
		return cellRenderer.getWedgeGap();
	}

	/**
	 * @param wedgeGap
	 *            sets the default gap between two event wedges
	 */
	public void setWedgeGap(int wedgeGap) {
		cellRenderer.setWedgeGap(wedgeGap);
	}

	public TraceBuilder<T> getTraceBuilder() {
		return cellRenderer.getTraceBuilder();
	}

	/**
	 * @param traceBuilder
	 *            that is used to create traces out of the input objects
	 */
	public void setTraceBuilder(TraceBuilder<T> traceBuilder) {
		cellRenderer.setTraceBuilder(traceBuilder);
	}

	public void beforeUpdate() {
		setEnabled(false);
		remove(scrollPane);
		add(progressBar, BorderLayout.CENTER);
		validate();
	}

	public void afterUpdate() {
		remove(progressBar);
		add(scrollPane, BorderLayout.CENTER);
		validate();
		setEnabled(true);
	}

	public void showToolbar() {
		toolbar.setVisible(true);
	}

	public void hideToolbar() {
		toolbar.setVisible(false);
	}

	public JPanel getToolbar() {
		return toolbar;
	}

	public void setToolbar(JPanel toolbar) {
		this.toolbar = toolbar;
	}

	/********* Printing/Saving methods ********/

	private interface GraphicsExporterFactory {

		Graphics2D newGraphicsIO(Dimension pageDimension) throws FileNotFoundException, IOException;

	}

	/**
	 * Saves the list content as PDF
	 * 
	 * @param pdfTitle
	 * @param file
	 * @param graphicsExporter
	 * @throws IOException
	 */
	public static <T> void saveAsPDF(ProMTraceList<T> traceList, final String pdfTitle, final File file)
			throws IOException {
		saveUsing(new GraphicsExporterFactory() {

			public VectorGraphicsIO newGraphicsIO(Dimension pageDimension) throws FileNotFoundException {
				PDFGraphics2D vectorGraphicsIO = new PDFGraphics2D(file, pageDimension);
				vectorGraphicsIO.setMultiPage(true);
				Properties p = new Properties();
				p.setProperty(PDFGraphics2D.PAGE_SIZE, PageConstants.A4);
				p.setProperty(PDFGraphics2D.ORIENTATION, PageConstants.LANDSCAPE);
				p.setProperty(PDFGraphics2D.TITLE, pdfTitle != null ? pdfTitle : ""Trace Variants"");
				p.setProperty(PDFGraphics2D.COMPRESS, ""true"");
				p.setProperty(PDFGraphics2D.FIT_TO_PAGE, ""true"");
				p.setProperty(PDFGraphics2D.TEXT_AS_SHAPES, ""false"");
				vectorGraphicsIO.setProperties(p);
				return vectorGraphicsIO;
			}
		}, traceList);
	}

	/**
	 * Saves the list content as EMF
	 * 
	 * @param file
	 * @param graphicsExporter
	 * @throws IOException
	 */
	public static <T> void saveAsEMF(ProMTraceList<T> traceList, final File file) throws IOException {
		saveUsing(new GraphicsExporterFactory() {

			public VectorGraphicsIO newGraphicsIO(Dimension pageDimension) throws FileNotFoundException {
				return new EMFGraphics2D(file, pageDimension);
			}
		}, traceList);
	}

	/**
	 * Saves the list content as PS
	 * 
	 * @param file
	 * @param graphicsExporter
	 * @throws IOException
	 */
	public static <T> void saveAsEPS(ProMTraceList<T> traceList, final File file) throws IOException {
		saveUsing(new GraphicsExporterFactory() {

			public VectorGraphicsIO newGraphicsIO(Dimension pageDimension) throws FileNotFoundException {
				EPSGraphics2D g = new EPSGraphics2D(file, pageDimension);
				Properties p = new Properties(EPSGraphics2D.getDefaultProperties());
				p.setProperty(EPSGraphics2D.PAGE_SIZE, EPSGraphics2D.CUSTOM_PAGE_SIZE);
				p.setProperty(EPSGraphics2D.PAGE_MARGINS, ""0, 0, 0, 0"");
				p.setProperty(EPSGraphics2D.TEXT_AS_SHAPES, ""false"");
				p.put(EPSGraphics2D.CUSTOM_PAGE_SIZE, pageDimension.width + "", "" + pageDimension.height);
				g.setProperties(p);
				return g;
			}
		}, traceList);
	}

	public static <T> void saveAsSVG(ProMTraceList<T> traceList, final File file) throws IOException {
		saveUsing(new GraphicsExporterFactory() {

			public VectorGraphicsIO newGraphicsIO(Dimension pageDimension) throws IOException {
				SVGGraphics2D g = new SVGGraphics2D(file, pageDimension);
				Properties properties = new Properties(SVGGraphics2D.getDefaultProperties());
				properties.setProperty(SVGGraphics2D.TEXT_AS_SHAPES, ""false"");
				g.setProperties(properties);
				return g;
			}
		}, traceList);
	}

	/**
	 * Saves the list content as PDF
	 * 
	 * @param pdfTitle
	 * @param file
	 * @throws IOException
	 */
	public static <T> void saveUsing(GraphicsExporterFactory graphicsExporter, ProMTraceList<T> traceList)
			throws IOException {

		List<T> currentElements = new ArrayList<>();
		for (int i = 0; i < traceList.getListModel().getSize(); i++) {
			currentElements.add(traceList.getListModel().getElementAt(i));
		}

		ProMTraceList<T> listForPrinting = new ProMTraceList<>(currentElements, traceList.getTraceBuilder(),
				traceList.getFont(), traceList.hasLabels());
		listForPrinting.setBackground(traceList.getBackground());
		listForPrinting.setForeground(traceList.getForeground());
		listForPrinting.setAttenuationFactor(traceList.getAttenuationFactor());
		listForPrinting.setWedgeBuilder(traceList.getWedgeBuilder());
		listForPrinting.setWedgeGap(traceList.getWedgeGap());
		listForPrinting.setWedgeStroke(traceList.getWedgeStroke());
		listForPrinting.setOpaque(true);

		JFrame printFrame = new JFrame();

		try {

			JList<T> list = listForPrinting.getList();

			printFrame.add(list);
			printFrame.pack();

			Dimension pageDimension = new Dimension(list.getWidth(), list.getHeight());

			Graphics2D graphicsIO = graphicsExporter.newGraphicsIO(pageDimension);

			if (graphicsIO instanceof VectorGraphicsIO) {
				((VectorGraphics) graphicsIO).startExport();
			}

			if (graphicsIO instanceof MultiPageDocument) {

				int tracesPerPage = 10;
				int pageCount = Math.max(1, currentElements.size() / tracesPerPage);
				int currentStartIndex = 0;

				for (int i = 0; i < pageCount; i++) {

					List<T> pageTraces = currentElements.subList(currentStartIndex,
							Math.min(currentStartIndex + tracesPerPage, currentElements.size()));

					listForPrinting.clear();
					listForPrinting.addAll(pageTraces);
					printFrame.pack();

					pageDimension = new Dimension(listForPrinting.getList().getWidth(), list.getHeight());

					((MultiPageDocument) graphicsIO).openPage(pageDimension, ""Page "" + i);
					list.print(graphicsIO);
					((MultiPageDocument) graphicsIO).closePage();

					currentStartIndex = currentStartIndex + tracesPerPage;
				}
			} else {
				list.print(graphicsIO);
			}

			if (graphicsIO instanceof VectorGraphicsIO) {
				((VectorGraphics) graphicsIO).endExport();
			}

		} finally {
			printFrame.dispose();
		}
	}

	public JButton getSelectAllButton() {
		return selectAll;
	}

	public JButton getDeselectAllButton() {
		return deselectAll;
	}

	public boolean hasLabels() {
		return hasLabels;
	}

}"
ProMTraceView.java,widget,"/*
 * Copyright (c) 2014 F. Mannhardt (f.mannhardt@tue.nl) Original Copyright for
 * the 'wedge' drawing code Copyright (c) 2007 Christian W. Guenther
 * (christian@deckfour.org)
 * 
 * LICENSE:
 * 
 * This code is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License as published by the Free Software
 * Foundation; either version 2 of the License, or (at your option) any later
 * version.
 * 
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
 * details.
 * 
 * You should have received a copy of the GNU General Public License along with
 * this program; if not, write to the Free Software Foundation, Inc., 51
 * Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA
 */
package org.processmining.framework.util.ui.widgets.traceview;

import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.FontMetrics;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.RenderingHints;
import java.awt.Stroke;
import java.awt.event.MouseListener;
import java.awt.font.LineBreakMeasurer;
import java.awt.font.TextAttribute;
import java.awt.font.TextLayout;
import java.text.AttributedString;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;

import javax.swing.JComponent;
import javax.swing.JList;
import javax.swing.ListCellRenderer;

import org.processmining.framework.util.ui.widgets.traceview.ProMTraceList.DefaultWedgeBuilder;
import org.processmining.framework.util.ui.widgets.traceview.ProMTraceList.WedgeBuilder;

import com.google.common.collect.ForwardingList;

/**
 * Displays a {@link Trace} of {@link Event}s as a sequence of wedges. This
 * implementation is similar to the class TraceView in the LogDialog package,
 * but it neither allows nor relies on {@link MouseListener}, so it may be used
 * as a rubber stamp in a {@link ListCellRenderer} of {@link JList}.
 * 
 * @author F. Mannhardt
 * 
 */
public class ProMTraceView extends JComponent {

	/**
	 * A Trace is just a sequence of events.
	 * 
	 * @author F. Mannhardt
	 * 
	 */
	public static interface Trace<T extends Event> extends Iterable<T> {

		/**
		 * @return name of the trace that is displayed in front of it
		 */
		String getName();

		/**
		 * @return the text color of the name label
		 */
		Color getNameColor();

		/**
		 * @return extra information about the trace that is displayed below the
		 *         name
		 */
		String getInfo();

		/**
		 * @return the text color of the info label
		 */
		Color getInfoColor();

	}

	/**
	 * An Event with labels and colors. It is safe for methods to return NULL.
	 * 
	 * @author F. Mannhardt
	 * 
	 */
	public static interface Event {

		/**
		 * @return the color of the wedge
		 */
		Color getWedgeColor();

		/**
		 * @return the color of the border
		 */
		Color getBorderColor();

		/**
		 * @return the label of this event
		 */
		String getLabel();

		/**
		 * @return the text color of the label
		 */
		Color getLabelColor();

		/**
		 * @return label that is displayed on top of the event
		 */
		String getTopLabel();

		/**
		 * @return the text color of the top label
		 */
		Color getTopLabelColor();

		/**
		 * @return label that is displayed in the first row below of the event
		 */
		String getBottomLabel();

		/**
		 * @return the text color of the bottom label
		 */
		Color getBottomLabelColor();

		/**
		 * @return label that is displayed in the second row below of the event
		 */
		String getBottomLabel2();

		/**
		 * @return the text color of the second bottom label
		 */
		Color getBottomLabel2Color();

	}

	public static interface SplittedEvent extends Event {

		String getUpperLabel();

		Color getUpperColor();

		String getLowerLabel();

		Color getLowerColor();

	}

	public static interface ExtendedEvent extends Event {

		Color getExtendedColor();

		String getExtendedLabel();

	}

	/**
	 * An abstract implementation of the {@link Trace} interface. This class
	 * provides an empty list, please override the {@link #delegate()} method to
	 * provide your own list.
	 * 
	 * @author F. Mannhardt
	 * 
	 */
	public abstract static class AbstractTrace<T extends Event> extends ForwardingList<T> implements Trace<T> {

		public String getName() {
			return EMPTY_LABEL;
		}

		public String getInfo() {
			return EMPTY_LABEL;
		}

		public Color getNameColor() {
			return null;
		}

		public Color getInfoColor() {
			return null;
		}

		protected List<T> delegate() {
			return Collections.emptyList();
		}

	}

	/**
	 * An abstract implementation of {@link Event} that returns an empty event.
	 * 
	 * @author F. Mannhardt
	 * 
	 */
	public abstract static class AbstractEvent implements Event {

		public String getLabel() {
			return EMPTY_LABEL;
		}

		public Color getWedgeColor() {
			return DEFAULT_COLOR;
		}

		public String getTopLabel() {
			return EMPTY_LABEL;
		}

		public String getBottomLabel() {
			return EMPTY_LABEL;
		}

		public String getBottomLabel2() {
			return EMPTY_LABEL;
		}

		public Color getLabelColor() {
			return null;
		}

		public Color getTopLabelColor() {
			return null;
		}

		public Color getBottomLabelColor() {
			return null;
		}

		public Color getBottomLabel2Color() {
			return null;
		}

		public Color getBorderColor() {
			return DEFAULT_BORDER_COLOR;
		}

	}

	/**
	 * A default implementation of the {@link Trace} interface.
	 * 
	 * @author F. Mannhardt
	 * 
	 */
	public static class DefaultTrace<T extends Event> extends AbstractTrace<T> {

		private List<T> list;

		private String name;
		private String info;

		public DefaultTrace() {
			this(EMPTY_LABEL, EMPTY_LABEL);
		}

		public DefaultTrace(String name, String info) {
			this(name, info, 16);
		}

		public DefaultTrace(String name, String info, int initialCapacity) {
			super();
			this.list = new ArrayList<T>(initialCapacity);
			this.name = name;
			this.info = info;
		}

		protected List<T> delegate() {
			return list;
		}

		public String getName() {
			return name;
		}

		public String getInfo() {
			return info;
		}

	}

	/**
	 * A default implementation of the {@link Event} interface.
	 * 
	 * @author F. Mannhardt
	 * 
	 */
	public static class DefaultEvent extends AbstractEvent {

		private final Color color;
		private final String label;
		private final String topLabel;
		private final String bottomLabel;
		private final String bottomLabel2;

		public DefaultEvent() {
			this(DEFAULT_COLOR, EMPTY_LABEL, EMPTY_LABEL, EMPTY_LABEL, EMPTY_LABEL);
		}

		public DefaultEvent(String label) {
			this(DEFAULT_COLOR, label);
		}

		public DefaultEvent(Color color, String label) {
			this(color, label, EMPTY_LABEL, EMPTY_LABEL, EMPTY_LABEL);
		}

		public DefaultEvent(Color color, String label, String topLabel, String bottomLabel, String bottomLabel2) {
			super();
			this.color = color;
			this.label = label;
			this.topLabel = topLabel;
			this.bottomLabel = bottomLabel;
			this.bottomLabel2 = bottomLabel2;
		}

		public String getLabel() {
			return label;
		}

		public Color getWedgeColor() {
			return color;
		}

		public String getTopLabel() {
			return topLabel;
		}

		public String getBottomLabel() {
			return bottomLabel;
		}

		public String getBottomLabel2() {
			return bottomLabel2;
		}

		public Color getBorderColor() {
			return null;
		}

	}

	/**
	 * Abstract base class for {@link SplittedEvent}.
	 * 
	 * @author F. Mannhardt
	 * 
	 */
	public static abstract class AbstractSplittedEvent extends AbstractEvent implements SplittedEvent {

		public String getUpperLabel() {
			return getLabel();
		}

		public Color getUpperColor() {
			return getWedgeColor();
		}

		public String getLowerLabel() {
			return getLabel();
		}

		public Color getLowerColor() {
			return getWedgeColor();
		}

	}

	/**
	 * Default implementation of {@link SplittedEvent}.
	 * 
	 * @author F. Mannhardt
	 * 
	 */
	public static class DefaultSplittedEvent extends DefaultEvent implements SplittedEvent {

		private String upperLabel;
		private String lowerLabel;
		private Color upperColor;
		private Color lowerColor;

		public DefaultSplittedEvent(Color upperColor, String upperLabel, Color lowerColor, String lowerLabel) {
			super();
			this.upperColor = upperColor;
			this.upperLabel = upperLabel;
			this.lowerColor = lowerColor;
			this.lowerLabel = lowerLabel;
		}

		public DefaultSplittedEvent(Color upperColor, String upperLabel, Color lowerColor, String lowerLabel,
				String topLabel, String bottomLabel, String bottomLabel2) {
			super(null, null, topLabel, bottomLabel, bottomLabel2);
			this.upperColor = upperColor;
			this.upperLabel = upperLabel;
			this.lowerColor = lowerColor;
			this.lowerLabel = lowerLabel;
		}

		@Override
		public String getUpperLabel() {
			return upperLabel;
		}

		@Override
		public Color getUpperColor() {
			return upperColor;
		}

		@Override
		public String getLowerLabel() {
			return lowerLabel;
		}

		@Override
		public Color getLowerColor() {
			return lowerColor;
		}

	}

	public static abstract class AbstractExtendedEvent extends AbstractEvent implements ExtendedEvent {

		public Color getExtendedColor() {
			return null;
		}

		public String getExtendedLabel() {
			return null;
		}

	}

	private static final long serialVersionUID = -2403943214348555300L;

	public static final String EMPTY_LABEL = new String();

	private static final Color DEFAULT_COLOR = Color.LIGHT_GRAY;
	private static final Color DEFAULT_BORDER_COLOR = Color.BLACK;

	private static final int WEDGE_HEIGHT = 40;
	private static final int MINIMUM_WEDGE_WIDTH = 15;

	private static final int ELEMENT_TRI_OFFSET = 6;
	private static final int ELEMENT_X_OFFSET = 5;

	private static final int LABEL_Y_OFFSET = 1;
	private static final int LABEL_X_OFFSET = 9;

	private static final int TOP_LABEL_Y_OFFSET = 0;
	private static final int TOP_LABEL_X_OFFSET = 5;

	private static final int BOTTOM_LABEL_Y_OFFSET = 0;
	private static final int BOTTOM_LABEL_X_OFFSET = 5;

	private static final int NAME_INFO_X_OFFSET = 2;

	private static final String ABBREVIATION_SUFFIX = ""..."";

	private final int elementHeight;
	private final int halfElementHeight;
	private final Font defaultFont;

	private Dimension cachedPreferredSize;

	private int maxInfoWidth = 85;
	private int fixedInfoWidth = -1;

	private int maxWedgeWidth = 130;
	private int fixedWedgeWidth = -1;

	private int collapsedLabelLength = 3;
	private int wedgeGap = 0;

	private float attenuationFactor = 0.9f;
	private Stroke wedgeStroke = new BasicStroke();

	private Trace<? extends Event> trace;
	private boolean isSelected;

	private WedgeBuilder wedgeBuilder;

	private FontMetrics fontMetric;

	/**
	 * Creates a new instance of {@link ProMTraceView} that paints a
	 * {@link Trace} consisting of {@link Event}'s. You need to call the method
	 * {@link #setTrace(Trace, boolean)} to actually display something. That is
	 * because this class is used together with {@link JList} and, therefore,
	 * the displayed {@link Trace} needs to be changeable.
	 */
	public ProMTraceView() {
		this(new Font(Font.SANS_SERIF, Font.PLAIN, 10));
	}

	public ProMTraceView(Font font) {
		this(font, true);
	}

	/**
	 * Creates a new instance of {@link ProMTraceView} that paints a
	 * {@link Trace} consisting of {@link Event}'s. You need to call the method
	 * {@link #setTrace(Trace, boolean)} to actually display something. That is
	 * because this class is used together with {@link JList} and, therefore,
	 * the displayed {@link Trace} needs to be changeable.
	 * 
	 * @param colorBuilder
	 * 
	 * @param font
	 *            the font to be used
	 * @param hasLabels
	 *            whether the wedge has labels
	 */
	public ProMTraceView(Font font, boolean hasLabels) {
		this.setWedgeBuilder(new DefaultWedgeBuilder());
		this.isSelected = false;
		this.defaultFont = font;
		this.trace = new DefaultTrace<Event>();
		this.fontMetric = getFontMetrics(getDefaultFont());
		if (hasLabels) {
			this.elementHeight = 40 + fontMetric.getHeight() * 3 + 5;
		} else {
			this.elementHeight = 40 + 25;
		}
		this.halfElementHeight = elementHeight / 2;
		updatePreferredSize();
		setDoubleBuffered(true);
		setOpaque(false);
	}

	public boolean isOpaque() {
		return false;
	}

	/**
	 * Updates the currently displayed trace
	 * 
	 * @param trace
	 */
	public void setTrace(Trace<? extends Event> trace) {
		this.trace = trace;
	}

	/**
	 * Updates the selection status of the currently displayed trace
	 * 
	 * @param isSelected
	 */
	public void setSelected(boolean isSelected) {
		this.isSelected = isSelected;
	}
	
	public boolean isSelected() {
		return isSelected;
	}

	public Trace<? extends Event> getTrace() {
		return trace;
	}

	public void updatePreferredSize() {
		this.cachedPreferredSize = calcPreferredSize();
	}

	public void updatePreferredSize(Dimension size) {
		this.cachedPreferredSize = size;
	}

	protected void paintChildren(Graphics g) {
		// No op
	}

	protected void paintBorder(Graphics g) {
		//No op
	}

	protected void printComponent(Graphics g) {
		boolean wasSelected = isSelected;
		try {
			isSelected = true;
			super.printComponent(g);
		} finally {
			isSelected = wasSelected;
		}
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see javax.swing.JComponent#paintComponent(java.awt.Graphics)
	 */
	@Override
	protected void paintComponent(Graphics g) {

		Iterator<? extends Event> iterator = trace.iterator();

		if (iterator.hasNext()) {
			Graphics2D g2d = (Graphics2D) g;
			g2d.setFont(getDefaultFont());
			g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
			g2d.setRenderingHint(RenderingHints.KEY_INTERPOLATION, RenderingHints.VALUE_INTERPOLATION_BILINEAR);
			g2d.setRenderingHint(RenderingHints.KEY_STROKE_CONTROL, RenderingHints.VALUE_STROKE_NORMALIZE);

			FontMetrics fontMetrics = g2d.getFontMetrics();
			int fontHeight = fontMetrics.getHeight();
			int nameInfoWidth = getNameInfoWidth(fontMetrics);

			Dimension preferredSize = getPreferredSize();
			Rectangle visibleRegion = g.getClipBounds();
			Rectangle completeRegion = new Rectangle(preferredSize.width, preferredSize.height);

			int wedgeYOffset = fontHeight + TOP_LABEL_Y_OFFSET;
			int y = completeRegion.y + wedgeYOffset + 2;
			int x = completeRegion.x;

			// draw name / info			
			x += NAME_INFO_X_OFFSET;

			if (isInVisibleRegion(visibleRegion, x, nameInfoWidth + 2 * NAME_INFO_X_OFFSET)) {
				if (!isEmpty(trace.getInfo()) && !isEmpty(trace.getName())) {
					drawTraceLabel(g2d, x, y + fontHeight, wedgeBuilder.buildNameColor(trace), trace.getName());
					drawTraceLabel(g2d, x, y + 2 * fontHeight, wedgeBuilder.buildInfoColor(trace), trace.getInfo());
				} else if (!isEmpty(trace.getName())) {
					drawTraceLabel(g2d, x, (int) (y + 1.5 * fontHeight), wedgeBuilder.buildNameColor(trace),
							trace.getName());
				}
			}

			// draw events			
			x += NAME_INFO_X_OFFSET;
			x += nameInfoWidth;
			x += ELEMENT_X_OFFSET;

			boolean hasPainted = false;

			while (iterator.hasNext()) {
				Event e = iterator.next();

				// position & wedge width calculations
				int currentEventWidth;
				int wedgeGap = getWedgeGap(trace, e);
				if (isSelected) {
					currentEventWidth = getExpandedEventWidth(e, fontMetrics);
				} else {
					currentEventWidth = getCollapsedEventWidth(e, fontMetrics);
				}

				// check if we should paint
				if (isInVisibleRegion(visibleRegion, x, currentEventWidth + wedgeGap)) {

					// color & stroke
					Color color = nullSafeColor(wedgeBuilder.buildWedgeColor(trace, e));
					Color strokeColor = nullSafeColor(wedgeBuilder.buildBorderColor(trace, e));
					Stroke stroke = getWedgeStroke(trace, e);

					// actual painting
					if (isSelected) {
						drawEventWedge(g2d, e, color, strokeColor, stroke, x, wedgeYOffset, currentEventWidth,
								WEDGE_HEIGHT, isSelected);

						if (e instanceof SplittedEvent) {
							SplittedEvent splittedEvent = (SplittedEvent) e;
							if (!isEmpty(splittedEvent.getUpperLabel())) {
								drawFullLabel(g2d, wedgeBuilder.buildLabelColor(trace, e), color,
										splittedEvent.getUpperLabel(), x, wedgeYOffset, currentEventWidth,
										halfElementHeight);
							}
							if (!isEmpty(splittedEvent.getLowerLabel())) {
								drawFullLabel(g2d, wedgeBuilder.buildLabelColor(trace, e), color,
										splittedEvent.getLowerLabel(), x,
										wedgeYOffset + 2 * fontMetrics.getAscent() - 2, currentEventWidth,
										halfElementHeight);
							}
						} else {
							if (!isEmpty(e.getLabel())) {
								drawFullLabel(g2d, wedgeBuilder.buildLabelColor(trace, e), color, e.getLabel(), x,
										wedgeYOffset, currentEventWidth, elementHeight);
							}
						}

						if (e instanceof ExtendedEvent) {
							ExtendedEvent extendedEvent = (ExtendedEvent) e;
							drawExtendedInfo(g2d, extendedEvent.getExtendedColor(), extendedEvent.getExtendedLabel(), x,
									TOP_LABEL_Y_OFFSET, currentEventWidth);
						}

						if (!isEmpty(e.getTopLabel()) && !(e instanceof ExtendedEvent)) {
							drawExtraLabel(g2d, wedgeBuilder.buildTopLabelColor(trace, e), e.getTopLabel(),
									x + TOP_LABEL_X_OFFSET, TOP_LABEL_Y_OFFSET, currentEventWidth);
						}
						if (!isEmpty(e.getBottomLabel())) {
							drawExtraLabel(g2d, wedgeBuilder.buildBottomLabelColor(trace, e), e.getBottomLabel(),
									x + BOTTOM_LABEL_X_OFFSET, BOTTOM_LABEL_Y_OFFSET + WEDGE_HEIGHT + wedgeYOffset,
									currentEventWidth);
						}
						if (!isEmpty(e.getBottomLabel2())) {
							drawExtraLabel(g2d, wedgeBuilder.buildBottom2LabelColor(trace, e), e.getBottomLabel2(),
									x + BOTTOM_LABEL_X_OFFSET,
									BOTTOM_LABEL_Y_OFFSET + WEDGE_HEIGHT + wedgeYOffset + fontHeight,
									currentEventWidth);
						}
					} else {
						drawEventWedge(g2d, e, color, strokeColor, stroke, x, wedgeYOffset, currentEventWidth,
								WEDGE_HEIGHT, isSelected);

						if (e instanceof SplittedEvent) {
							SplittedEvent splittedEvent = (SplittedEvent) e;
							if (!isEmpty(splittedEvent.getUpperLabel())) {
								drawCollapsedLabel(g2d, wedgeBuilder.buildLabelColor(trace, e), color,
										splittedEvent.getUpperLabel(), x, wedgeYOffset + fontMetrics.getAscent());
							}
							if (!isEmpty(splittedEvent.getLowerLabel())) {
								drawCollapsedLabel(g2d, wedgeBuilder.buildLabelColor(trace, e), color,
										splittedEvent.getLowerLabel(), x,
										wedgeYOffset + 3 * fontMetrics.getAscent() - 2);
							}
						} else {
							if (!isEmpty(e.getLabel())) {
								drawCollapsedLabel(g2d, wedgeBuilder.buildLabelColor(trace, e), color, e.getLabel(), x,
										wedgeYOffset + (WEDGE_HEIGHT / 2) + (int) (fontMetrics.getAscent() / 1.5f)
												- fontMetrics.getLeading() - fontMetrics.getDescent());
							}
						}

						if (e instanceof ExtendedEvent) {
							ExtendedEvent extendedEvent = (ExtendedEvent) e;
							drawCollapseExtendedInfo(g2d, extendedEvent.getExtendedColor(),
									extendedEvent.getExtendedLabel(), x, TOP_LABEL_Y_OFFSET, currentEventWidth);
						}

					}

					hasPainted = true;

				} else {
					if (hasPainted) {
						break;
					}
				}

				x += currentEventWidth + wedgeGap;
			}
		}
	}

	private static boolean isInVisibleRegion(Rectangle visibleRegion, int x, int elementWidth) {
		int partlyVisibleHorizon = elementWidth;
		int startX = visibleRegion.x;
		int endX = visibleRegion.x + visibleRegion.width;
		return x + partlyVisibleHorizon > startX && x - partlyVisibleHorizon < endX;
	}

	protected final int translateToEventIndex(Point point) {
		Iterator<? extends Event> iterator = trace.iterator();
		FontMetrics fontMetrics = getFontMetrics(getDefaultFont());
		int offsetX = NAME_INFO_X_OFFSET + getNameInfoWidth(fontMetrics) + ELEMENT_X_OFFSET + ELEMENT_TRI_OFFSET;
		int currentX = offsetX;
		int lastX = offsetX;
		int currentEventIndex = 0;
		while (iterator.hasNext() && point.getX() > currentX) {
			Event e = iterator.next();
			if (isSelected) {
				currentX += getExpandedEventWidth(e, fontMetrics);
			} else {
				currentX += getCollapsedEventWidth(e, fontMetrics);
			}
			if (point.getX() > lastX && point.getX() < currentX) {
				return currentEventIndex;
			}
			currentX += getWedgeGap(trace, e);
			lastX = currentX;
			currentEventIndex++;
		}
		return -1;
	}

	/**
	 * 
	 * @param point
	 * @return positive: event index; -1: out of trace; -2: name of trace
	 */
	protected final int translateToDetailedEventIndex(Point point) {
		Iterator<? extends Event> iterator = trace.iterator();
		FontMetrics fontMetrics = getFontMetrics(getDefaultFont());
		int offsetX = NAME_INFO_X_OFFSET + getNameInfoWidth(fontMetrics) + ELEMENT_X_OFFSET + ELEMENT_TRI_OFFSET;
		int currentX = offsetX;
		int lastX = offsetX;
		int currentEventIndex = 0;
		if (point.getX() <= currentX) {
			return -2;
		}
		while (iterator.hasNext() && point.getX() > currentX) {
			Event e = iterator.next();
			if (isSelected) {
				currentX += getExpandedEventWidth(e, fontMetrics);
			} else {
				currentX += getCollapsedEventWidth(e, fontMetrics);
			}
			if (point.getX() > lastX && point.getX() < currentX) {
				return currentEventIndex;
			}
			currentX += getWedgeGap(trace, e);
			lastX = currentX;
			currentEventIndex++;
		}
		return -1;
	}

	private Stroke getWedgeStroke(Trace<? extends Event> trace, Event e) {
		Stroke stroke = wedgeBuilder.buildBorderStroke(trace, e);
		if (stroke != null) {
			return stroke;
		}
		return wedgeStroke;
	}

	private int getWedgeGap(Trace<? extends Event> trace, Event e) {
		Integer gap = wedgeBuilder.assignWedgeGap(trace, e);
		if (gap != null) {
			return gap;
		}
		return this.wedgeGap;
	}

	private static boolean isEmpty(String s) {
		return s == null || s == EMPTY_LABEL || s.isEmpty();
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see javax.swing.JComponent#getMaximumSize()
	 */
	public Dimension getMaximumSize() {
		return new Dimension(Integer.MAX_VALUE, elementHeight);
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see javax.swing.JComponent#getMinimumSize()
	 */
	public Dimension getMinimumSize() {
		return getPreferredSize();
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see javax.swing.JComponent#getPreferredSize()
	 */
	public Dimension getPreferredSize() {
		return cachedPreferredSize;
	}

	private final Dimension calcPreferredSize() {
		FontMetrics fontMetrics = fontMetric;
		int nameWidth = NAME_INFO_X_OFFSET + getNameInfoWidth(fontMetrics);
		int traceWidth = ELEMENT_X_OFFSET + ELEMENT_TRI_OFFSET + getSelectedTraceWidth(fontMetrics);
		return new Dimension(nameWidth + traceWidth + 5, elementHeight); // do not know where the 5 comes from
	}

	private int getNameInfoWidth(FontMetrics metrics) {
		if (getFixedInfoWidth() != -1) {
			return getFixedInfoWidth();
		} else {
			return Math.min(getMaxInfoWidth(),
					Math.max(nullSafeWidth(metrics, trace.getName()), nullSafeWidth(metrics, trace.getInfo())));
		}
	}

	private final int getSelectedTraceWidth(FontMetrics metrics) {
		if (getFixedWedgeWidth() != -1) {
			if (trace instanceof Collection) {
				return (getFixedWedgeWidth() + wedgeGap) * ((Collection<?>) trace).size();
			} else {
				Iterator<? extends Event> iterator = trace.iterator();
				if (iterator.hasNext()) {
					int width = 0;
					for (; iterator.hasNext();) {
						iterator.next();
						width += getFixedWedgeWidth();
						width += wedgeGap;
					}
					return width;
				} else {
					return MINIMUM_WEDGE_WIDTH;
				}
			}
		} else {
			Iterator<? extends Event> iterator = trace.iterator();
			if (iterator.hasNext()) {
				int width = 0;
				for (; iterator.hasNext();) {
					Event e = iterator.next();
					width += getExpandedEventWidth(e, metrics);
					width += getWedgeGap(trace, e);
				}
				return width;
			} else {
				return MINIMUM_WEDGE_WIDTH;
			}
		}
	}

	private final int getExpandedEventWidth(final Event e, FontMetrics metrics) {
		if (getFixedWedgeWidth() != -1) {
			return Math.max(getFixedWedgeWidth(), MINIMUM_WEDGE_WIDTH);
		} else {
			int width = nullSafeWidth(metrics, e.getLabel()) + LABEL_X_OFFSET;
			width = Math.max(width, nullSafeWidth(metrics, e.getTopLabel()) + BOTTOM_LABEL_X_OFFSET);
			width = Math.max(width, nullSafeWidth(metrics, e.getBottomLabel()) + BOTTOM_LABEL_X_OFFSET);
			width = Math.max(width, nullSafeWidth(metrics, e.getBottomLabel2()) + BOTTOM_LABEL_X_OFFSET);

			if (e instanceof SplittedEvent) {
				width = Math.max(width, nullSafeWidth(metrics, ((SplittedEvent) e).getUpperLabel()) + LABEL_X_OFFSET);
				width = Math.max(width, nullSafeWidth(metrics, ((SplittedEvent) e).getLowerLabel()) + LABEL_X_OFFSET);
			}

			return Math.max(Math.min(maxWedgeWidth, width), MINIMUM_WEDGE_WIDTH);
		}
	}

	private int getCollapsedEventWidth(Event e, FontMetrics metrics) {
		int width = Math.max(MINIMUM_WEDGE_WIDTH, nullSafeWidth(metrics, shortenLabel(e.getLabel()) + LABEL_X_OFFSET));
		if (e instanceof SplittedEvent) {
			width = Math.max(width,
					nullSafeWidth(metrics, shortenLabel(((SplittedEvent) e).getUpperLabel())) + LABEL_X_OFFSET);
			width = Math.max(width,
					nullSafeWidth(metrics, shortenLabel(((SplittedEvent) e).getLowerLabel())) + LABEL_X_OFFSET);
		}
		return width;
	}

	private void drawCollapseExtendedInfo(Graphics2D g2d, Color extendedColor, String extendedLabel, int x, int y,
			int width) {
		if (extendedColor != null) {
			g2d.setColor(extendedColor);
			g2d.fillRect(x, y, width, g2d.getFontMetrics().getHeight() - 4);
			g2d.setColor(Color.BLACK);
			g2d.drawRect(x, y, width, g2d.getFontMetrics().getHeight() - 4);
			g2d.setColor(determineFontColor(getForeground(), extendedColor));
		}

		if (extendedLabel != null) {
			g2d.setFont(g2d.getFont().deriveFont(g2d.getFont().getSize() - 2.0f));
			try {
				FontMetrics fontMetrics = g2d.getFontMetrics();
				g2d.setColor(determineFontColor(getForeground(), extendedColor));
				if (fontMetrics.stringWidth(extendedLabel) <= width) {
					g2d.drawString(extendedLabel, x, y + fontMetrics.getAscent());
				} else {
					char[] charArray = extendedLabel.toCharArray();
					int cutoffPoint = extendedLabel.length();
					for (int i = extendedLabel.length(); i > 0; i--) {
						if (fontMetrics.charsWidth(charArray, 0, i) <= width) {
							cutoffPoint = i;
							break;
						}
					}
					g2d.drawString(extendedLabel.substring(0, Math.max(0, cutoffPoint - 3)).concat(ABBREVIATION_SUFFIX),
							x, y + fontMetrics.getAscent());
				}
			} finally {
				g2d.setFont(g2d.getFont().deriveFont(g2d.getFont().getSize() + 2.0f));
			}
		}
	}

	private void drawExtendedInfo(Graphics2D g2d, Color extendedColor, String extendedLabel, int x, int y, int width) {
		if (extendedColor != null) {
			g2d.setColor(extendedColor);
			g2d.fillRect(x, y, width, g2d.getFontMetrics().getHeight() - 4);
			g2d.setColor(Color.BLACK);
			g2d.drawRect(x, y, width, g2d.getFontMetrics().getHeight() - 4);
			g2d.setColor(determineFontColor(getForeground(), extendedColor));
		}

		if (extendedLabel != null) {
			g2d.setFont(g2d.getFont().deriveFont(g2d.getFont().getSize() - 2.0f));
			try {
				FontMetrics fontMetrics = g2d.getFontMetrics();
				if (fontMetrics.stringWidth(extendedLabel) <= width) {
					g2d.drawString(extendedLabel, x, y + fontMetrics.getAscent());
				} else {
					char[] charArray = extendedLabel.toCharArray();
					int cutoffPoint = extendedLabel.length();
					for (int i = extendedLabel.length(); i > 0; i--) {
						if (fontMetrics.charsWidth(charArray, 0, i) <= width) {
							cutoffPoint = i;
							break;
						}
					}
					g2d.drawString(extendedLabel.substring(0, Math.max(0, cutoffPoint - 3)).concat(ABBREVIATION_SUFFIX),
							x, y + fontMetrics.getAscent());
				}
			} finally {
				g2d.setFont(g2d.getFont().deriveFont(g2d.getFont().getSize() + 2.0f));
			}
		}
	}

	private final void drawEventWedge(final Graphics2D g, Event e, final Color color, final Color strokeColor,
			Stroke wedgeStroke, int x, int y, int width, int height, boolean isSelected) {

		int midPointBX = x + ELEMENT_TRI_OFFSET;
		int midPointAX = x + width + ELEMENT_TRI_OFFSET;
		int midPointY = y + (height / 2);
		int endPointX = x + width;
		int endPointY = y + height;

		if (e instanceof SplittedEvent) {
			SplittedEvent splittedEvent = (SplittedEvent) e;

			int[] xUpper = new int[] { x, endPointX, midPointAX, midPointBX };
			int[] yUpper = new int[] { y, y, midPointY, midPointY };

			g.setColor(isSelected ? splittedEvent.getUpperColor() : attenuateColor(splittedEvent.getUpperColor()));
			g.fillPolygon(xUpper, yUpper, 4);

			int[] xLower = new int[] { midPointBX, x, endPointX, midPointAX };
			int[] yLower = new int[] { midPointY, endPointY, endPointY, midPointY };

			g.setColor(isSelected ? splittedEvent.getLowerColor() : attenuateColor(splittedEvent.getLowerColor()));
			g.fillPolygon(xLower, yLower, 4);

		} else {

			int[] xCoords = new int[] { x, endPointX, midPointAX, endPointX, x, midPointBX };
			int[] yCoords = new int[] { y, y, midPointY, endPointY, endPointY, midPointY };

			g.setColor(isSelected ? color : attenuateColor(color));
			g.fillPolygon(xCoords, yCoords, 6);
		}

		g.setColor(strokeColor);

		Stroke oldStroke = g.getStroke();
		try {
			g.setStroke(wedgeStroke);

			// Start Wedge
			g.drawPolyline(new int[] { x, midPointBX, x }, new int[] { y, midPointY, endPointY }, 3);
			// End Wedge
			g.drawPolyline(new int[] { endPointX, midPointAX, endPointX }, new int[] { y, midPointY, endPointY }, 3);

			// Upper line
			g.drawLine(x, y, endPointX, y);
			// Lower line
			g.drawLine(x, endPointY, endPointX, endPointY);
		} finally {
			g.setStroke(oldStroke);
		}
	}

	private final void drawTraceLabel(Graphics2D g2d, int x, int y, Color color, String label) {
		g2d.setColor(color == null ? getForeground() : color);

		FontMetrics fontMetrics = g2d.getFontMetrics();
		int wedgeWidth = getNameInfoWidth(fontMetrics);
		if (wedgeWidth != -1) {
			if (fontMetrics.stringWidth(label) <= wedgeWidth) {
				g2d.drawString(label, x, y);
			} else {
				char[] charArray = label.toCharArray();
				int cutoffPoint = label.length();
				for (int i = label.length(); i > 0; i--) {
					if (fontMetrics.charsWidth(charArray, 0, i) <= wedgeWidth) {
						cutoffPoint = i;
						break;
					}
				}
				g2d.drawString(label.substring(0, Math.max(0, cutoffPoint - 3)).concat(ABBREVIATION_SUFFIX), x, y);
			}
		} else {
			g2d.drawString(label, x, y);
		}

	}

	private final void drawCollapsedLabel(final Graphics2D g, Color textColor, Color bgColor, final String label, int x,
			int y) {
		String shortenLabel = shortenLabel(label);
		if (shortenLabel != null) {
			g.setColor(determineFontColor(textColor, bgColor));
			g.drawString(shortenLabel, x + LABEL_X_OFFSET, y + LABEL_Y_OFFSET);
		}
	}

	private String shortenLabel(final String label) {
		if (label != null) {
			return label.substring(0, Math.min(collapsedLabelLength, label.length()));
		} else {
			return null;
		}
	}

	private final void drawFullLabel(final Graphics2D g, final Color textColor, final Color bgColor, final String label,
			int x, int y, int width, int maxHeight) {

		g.setColor(determineFontColor(textColor, bgColor));
		int wrappingWidth = width - LABEL_X_OFFSET;

		FontMetrics fontMetrics = g.getFontMetrics();
		if (fontMetrics.stringWidth(label) <= wrappingWidth) {
			// Shortcut the expensive text wrapping
			if (maxHeight == elementHeight) {
				// somehow get it centered (try and error calculation)
				g.drawString(label, x + LABEL_X_OFFSET, y + (WEDGE_HEIGHT / 2) + (fontMetrics.getAscent() / 2));
			} else {
				g.drawString(label, x + LABEL_X_OFFSET, y + LABEL_Y_OFFSET + fontMetrics.getAscent());
			}
		} else {
			AttributedString attributedString = new AttributedString(label);
			attributedString.addAttribute(TextAttribute.FONT, g.getFont());
			LineBreakMeasurer breakMeasure = new LineBreakMeasurer(attributedString.getIterator(),
					g.getFontRenderContext());

			int labelX = x + LABEL_X_OFFSET;
			int labelY = y + LABEL_Y_OFFSET;

			while (breakMeasure.getPosition() < label.length()) {

				int positionBefore = breakMeasure.getPosition();
				int positionAfter = breakMeasure.nextOffset(wrappingWidth);

				TextLayout layout = breakMeasure.nextLayout(wrappingWidth);
				float textHeight = layout.getDescent() + layout.getLeading() + layout.getAscent();

				if ((labelY + (4 * textHeight)) > maxHeight) {
					// Last Row				
					String shortenedLastRow = label
							.substring(positionBefore, Math.max(positionBefore, positionAfter - 3))
							.concat(ABBREVIATION_SUFFIX);
					AttributedString attrLastRow = new AttributedString(shortenedLastRow);
					attrLastRow.addAttribute(TextAttribute.FONT, g.getFont());
					TextLayout lastRowLayout = new TextLayout(attrLastRow.getIterator(), g.getFontRenderContext());
					float dx = lastRowLayout.isLeftToRight() ? 0 : (wrappingWidth - lastRowLayout.getAdvance());
					lastRowLayout.draw(g, labelX + dx, labelY + lastRowLayout.getAscent());
					break;
				}

				labelY += layout.getAscent();
				float dx = layout.isLeftToRight() ? 0 : (wrappingWidth - layout.getAdvance());
				layout.draw(g, labelX + dx, labelY);
				labelY += layout.getDescent() + layout.getLeading();
			}
		}

	}

	private void drawExtraLabel(Graphics2D g, Color color, String label, int x, int y, int width) {
		g.setColor(color != null ? color : getForeground());

		FontMetrics fontMetrics = g.getFontMetrics();
		if (fontMetrics.stringWidth(label) <= width) {
			g.drawString(label, x, y + fontMetrics.getAscent());
		} else {
			char[] charArray = label.toCharArray();
			int cutoffPoint = label.length();
			for (int i = label.length(); i > 0; i--) {
				if (fontMetrics.charsWidth(charArray, 0, i) <= width) {
					cutoffPoint = i;
					break;
				}
			}
			g.drawString(label.substring(0, Math.max(0, cutoffPoint - 3)).concat(ABBREVIATION_SUFFIX), x,
					y + fontMetrics.getAscent());
		}
	}

	private final Color attenuateColor(final Color c) {
		float[] hsb = Color.RGBtoHSB(c.getRed(), c.getGreen(), c.getBlue(), null);
		hsb[2] = hsb[2] * getAttenuationFactor();
		return new Color(Color.HSBtoRGB(hsb[0], hsb[1], hsb[2]));
	}

	private static final Color determineFontColor(final Color textColor, final Color bgColor) {
		if (textColor == null) {
			double val = Math.sqrt(.299 * Math.pow(bgColor.getRed(), 2) + .587 * Math.pow(bgColor.getGreen(), 2)
					+ .114 * Math.pow(bgColor.getBlue(), 2));
			return (val < 130) ? Color.WHITE : Color.BLACK;
		} else {
			return textColor;
		}
	}

	private static int nullSafeWidth(FontMetrics fontMetrics, String s) {
		return s != null ? fontMetrics.stringWidth(s) : 0;
	}

	private Color nullSafeColor(Color color) {
		return color == null ? Color.BLACK : color;
	}

	public float getAttenuationFactor() {
		return attenuationFactor;
	}

	public void setAttenuationFactor(float attenuationFactor) {
		this.attenuationFactor = attenuationFactor;
	}

	public Font getDefaultFont() {
		return defaultFont;
	}

	public WedgeBuilder getWedgeBuilder() {
		return wedgeBuilder;
	}

	public void setWedgeBuilder(WedgeBuilder colorBuilder) {
		this.wedgeBuilder = colorBuilder;
	}

	public int getMaxWedgeWidth() {
		return maxWedgeWidth;
	}

	public void setMaxWedgeWidth(int maxWedgeWidth) {
		this.maxWedgeWidth = maxWedgeWidth;
	}

	public int getCollapsedLabelLength() {
		return collapsedLabelLength;
	}

	public void setCollapsedLabelLength(int collapsedLabelLength) {
		this.collapsedLabelLength = collapsedLabelLength;
	}

	public Stroke getWedgeStroke() {
		return wedgeStroke;
	}

	public void setWedgeStroke(Stroke wedgeStroke) {
		this.wedgeStroke = wedgeStroke;
	}

	public int getWedgeGap() {
		return wedgeGap;
	}

	public void setWedgeGap(int wedgeGap) {
		this.wedgeGap = wedgeGap;
	}

	public boolean isFixedWedgeWidth() {
		return getFixedWedgeWidth() != -1;
	}

	public void setFixedWedgeWidth(int fixedWedgeWidth) {
		this.fixedWedgeWidth = fixedWedgeWidth;
	}

	public int getFixedWedgeWidth() {
		return fixedWedgeWidth;
	}

	public int getMaxInfoWidth() {
		return maxInfoWidth;
	}

	public void setMaxInfoWidth(int maxInfoWidth) {
		this.maxInfoWidth = maxInfoWidth;
	}

	public boolean isFixedInfoWidth() {
		return getFixedInfoWidth() != -1;
	}

	public int getFixedInfoWidth() {
		return fixedInfoWidth;
	}

	public void setFixedInfoWidth(int fixedInfoWidth) {
		this.fixedInfoWidth = fixedInfoWidth;
	}

}"
SaveAsActionListener.java,widget,"package org.processmining.framework.util.ui.widgets.traceview;

import java.awt.Color;
import java.awt.Font;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.prefs.Preferences;

import javax.swing.JFileChooser;
import javax.swing.JOptionPane;
import javax.swing.filechooser.FileNameExtensionFilter;

import org.processmining.framework.util.ui.widgets.helper.ProMUIHelper;

public class SaveAsActionListener<T> implements ActionListener {

	static final Preferences PREFS = Preferences.userRoot().node(""org.processmining.widgets.traceview"");
	static final String LAST_USED_FOLDER = ""lastUsedFolder"";

	private final ProMTraceList<T> listView;
	private final Comparator<T> sortOrder;

	public SaveAsActionListener(ProMTraceList<T> listView, Comparator<T> sortOrder) {
		this.listView = listView;
		this.sortOrder = sortOrder;
	}

	public void actionPerformed(ActionEvent e) {

		JFileChooser chooser = new JFileChooser(PREFS.get(LAST_USED_FOLDER, new File(""."").getAbsolutePath()));
		FileNameExtensionFilter pdfFilter = new FileNameExtensionFilter(""PDF"", ""pdf"");
		FileNameExtensionFilter emfFilter = new FileNameExtensionFilter(""EMF"", ""emf"");
		FileNameExtensionFilter epsFilter = new FileNameExtensionFilter(""EPS"", ""eps"");
		FileNameExtensionFilter svgFilter = new FileNameExtensionFilter(""SVG"", ""svg"");
		chooser.addChoosableFileFilter(pdfFilter);
		chooser.addChoosableFileFilter(emfFilter);
		chooser.addChoosableFileFilter(epsFilter);
		chooser.addChoosableFileFilter(svgFilter);
		chooser.setFileFilter(pdfFilter);
		chooser.setAcceptAllFileFilterUsed(false);
		int returnVal = chooser.showSaveDialog(listView);
		if (returnVal == JFileChooser.APPROVE_OPTION) {
			File file = chooser.getSelectedFile();
			PREFS.put(LAST_USED_FOLDER, file.getParent());

			List<T> traces = new ArrayList<>();
			List<T> selection = listView.getList().getSelectedValuesList();
			for (T o : selection) {
				traces.add(o);
			}

			if (selection.size() > 100) {
				int result = JOptionPane.showConfirmDialog(listView,
						String.format(
								""You selected %s traces to be saved, this could take a long time and freeze the UI. Do you want to continue?"",
								selection.size()));
				if (result != JOptionPane.OK_OPTION) {
					return;
				}
			}
			
			String font = JOptionPane.showInputDialog(listView, ""If you want to use a specific font, please specify its name (Experimental Feature)"", Font.SANS_SERIF);
	
			ProMTraceList<T> listForPrinting = new ProMTraceList<>(traces, listView.getTraceBuilder(), sortOrder, new Font(font, Font.PLAIN, 10), listView.hasLabels());

			listForPrinting.setOpaque(true);
			listForPrinting.setBackground(Color.WHITE);
			listForPrinting.setForeground(Color.BLACK);

			if (chooser.getFileFilter() == pdfFilter) {
				if (!file.getAbsolutePath().endsWith("".pdf"")) {
					file = new File(file.getAbsolutePath() + "".pdf"");
				}
				try {
					ProMTraceList.saveAsPDF(listForPrinting, """", file);
				} catch (IOException e1) {
					ProMUIHelper.showErrorMessage(listView, e1.getMessage(), ""Error saving"");
				}
			} else if (chooser.getFileFilter() == emfFilter) {
				if (!file.getAbsolutePath().endsWith("".emf"")) {
					file = new File(file.getAbsolutePath() + "".emf"");
				}
				try {
					ProMTraceList.saveAsEMF(listForPrinting, file);
				} catch (IOException e1) {
					ProMUIHelper.showErrorMessage(listView, e1.getMessage(), ""Error saving"");
				}
			} else if (chooser.getFileFilter() == epsFilter) {
				if (!file.getAbsolutePath().endsWith("".eps"")) {
					file = new File(file.getAbsolutePath() + "".eps"");
				}
				try {
					ProMTraceList.saveAsEPS(listForPrinting, file);
				} catch (IOException e1) {
					ProMUIHelper.showErrorMessage(listView, e1.getMessage(), ""Error saving"");
				}
			} else if (chooser.getFileFilter() == svgFilter) {
				if (!file.getAbsolutePath().endsWith("".svg"")) {
					file = new File(file.getAbsolutePath() + "".svg"");
				}
				try {
					ProMTraceList.saveAsSVG(listForPrinting, file);
				} catch (IOException e1) {
					ProMUIHelper.showErrorMessage(listView, e1.getMessage(), ""Error saving"");
				}
			}
		}

	}

}
"
JSplitPaneUtils.java,widget,"package org.processmining.widgets.ui.utils;

import javax.swing.BorderFactory;
import javax.swing.JComponent;
import javax.swing.JSplitPane;
import javax.swing.border.Border;
import javax.swing.plaf.basic.BasicSplitPaneDivider;
import javax.swing.plaf.basic.BasicSplitPaneUI;

public class JSplitPaneUtils {

	public static JSplitPane borderlessSplitPane(int orientation, JComponent left, JComponent right) {
		JSplitPane pane = new JSplitPane(orientation, left, right);
		// svzelst@20151022 the fix for no borders comes from stack-overflow
		// as commented in the thread, this fix is not guaranteed to work cross-platform
		//http://stackoverflow.com/questions/12799640/why-does-jsplitpane-add-a-border-to-my-components-and-how-do-i-stop-it
		pane.setBorder(BorderFactory.createEmptyBorder(0, 0, 0, 0));
		BasicSplitPaneUI flatDividerSplitPaneUI = new BasicSplitPaneUI() {
			@Override
			public BasicSplitPaneDivider createDefaultDivider() {
				return new BasicSplitPaneDivider(this) {

					private static final long serialVersionUID = -7728070024389270847L;

					@Override
					public void setBorder(Border b) {
					}
				};
			}
		};
		pane.setUI(flatDividerSplitPaneUI);
		pane.setBorder(null);
		pane.setOpaque(false);
		return pane;
	}

}
"
WidgetColors.java,widget,"package org.processmining.framework.util.ui.widgets;

import java.awt.Color;

/**
 * Colors used in widgets
 * 
 * @author mwesterg
 * 
 */
public interface WidgetColors {
	/**
	 * 
	 */
	public static final Color COLOR_ENCLOSURE_BG = new Color(40, 40, 40);
	/**
	 * 
	 */
	public static final Color COLOR_LIST_BG = new Color(60, 60, 60);
	/**
	 * 
	 */
	public static final Color COLOR_LIST_FG = new Color(180, 180, 180);
	/**
	 * 
	 */
	public static final Color COLOR_LIST_SELECTION_BG = new Color(80, 0, 0);
	/**
	 * 
	 */
	public static final Color COLOR_LIST_SELECTION_FG = new Color(240, 240, 240);
	/**
	 * 
	 */
	public static final Color COLOR_NON_FOCUS = new Color(70, 70, 70);
	/**
	 * 
	 */
	public static final Color HEADER_COLOR = new Color(20, 20, 20, 230);
	/**
	 * 
	 */
	public static final Color PROPERTIES_BACKGROUND = Color.LIGHT_GRAY;
	/**
	 * 
	 */
	public static final Color TEXT_COLOR = new Color(210, 210, 210);

}
"
WidgetImages.java,widget,"package org.processmining.framework.util.ui.widgets;

import java.awt.Image;

import javax.swing.ImageIcon;

/**
 * Images useful for tabbed panes
 * 
 * @author mwesterg
 * 
 */
public interface WidgetImages {
	/**
	 * 
	 */
	final static Image dashboardIcon = new ImageIcon(WidgetImages.class.getResource(""resources/dashboard48.png""))
			.getImage();
	/**
	 * 
	 */
	final static Image inspectorIcon = new ImageIcon(WidgetImages.class.getResource(""resources/inspector48.png""))
			.getImage();
	/**
	 * 
	 */
	final static Image summaryIcon = new ImageIcon(WidgetImages.class.getResource(""resources/summary48-2.png""))
			.getImage();

}
"
AbstractDialog.java,widget,"package org.processmining.widgets.wizard;

import javax.swing.JOptionPane;

import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.framework.util.ui.widgets.ProMHeaderPanel;

public abstract class AbstractDialog<P> extends ProMHeaderPanel implements Dialog<P> {

	private static final long serialVersionUID = -1559194274412334852L;

	private final UIPluginContext context;

	private P parameters;

	private Dialog<P> previous = null;

	private final String title;

	public AbstractDialog(final UIPluginContext context, final String title, final P parameters,
			final Dialog<P> previous) {
		super(title);
		this.parameters = parameters;
		this.previous = previous;
		this.context = context;
		this.title = title;
	}

	protected abstract boolean canProceedToNext();

	protected abstract Dialog<P> determineNextDialog();

	public final Dialog<P> getNext() {
		if (canProceedToNext()) {
			updateParametersOnGetNext();
			return determineNextDialog();
		} else {
			JOptionPane.showMessageDialog(this, getUserInputProblems(), ""Incomplete Parameter Selection"",
					JOptionPane.WARNING_MESSAGE);
			return this;
		}
	}

	public P getParameters() {
		return parameters;
	}

	public Dialog<P> getPrevious() {
		updateParametersOnGetPrevious();
		return previous;
	}

	public String getTitle() {
		return title;
	}

	public UIPluginContext getUIPluginContext() {
		return context;
	}

	protected abstract String getUserInputProblems();

	public boolean hasPreviousDialog() {
		return previous != null;
	}

	public void setParameters(P parameters) {
		this.parameters = parameters;
	}
}
"
AbstractRoutableDialog.java,widget,"package org.processmining.widgets.wizard;

import org.processmining.contexts.uitopia.UIPluginContext;

public abstract class AbstractRoutableDialog<P> extends AbstractDialog<P> {

	private static final long serialVersionUID = 191742936970950461L;
	private final Route<P> route;

	public AbstractRoutableDialog(UIPluginContext context, String title, P parameters, Dialog<P> previous,
			Route<P> route) {
		super(context, title, parameters, previous);
		this.route = route;
	}

	public boolean hasNextDialog() {
		return route == null ? false : route.getNext(this) != null;
	}

	protected Dialog<P> determineNextDialog() {
		return route == null ? null : route.getNext(this);
	}
}
"
Dialog.java,widget,"package org.processmining.widgets.wizard;

import javax.swing.JComponent;

import org.processmining.contexts.uitopia.UIPluginContext;

/**
 * @author svzelst
 *
 * @param
 * 			<P>
 *            parameters object
 */
public interface Dialog<P> {

	Dialog<P> getNext();

	P getParameters();

	Dialog<P> getPrevious();

	String getTitle();

	UIPluginContext getUIPluginContext();

	boolean hasNextDialog();

	boolean hasPreviousDialog();

	void setParameters(P parameters);

	void updateParametersOnGetNext();

	void updateParametersOnGetPrevious();

	JComponent visualize();

}
"
Route.java,widget,"package org.processmining.widgets.wizard;

public interface Route<P> {

	Dialog<P> getNext(Dialog<P> current);

}
"
Wizard.java,widget,"package org.processmining.widgets.wizard;

import org.deckfour.uitopia.api.event.TaskListener;
import org.processmining.contexts.uitopia.UIPluginContext;

public class Wizard {

	public static <P> WizardResult<P> show(UIPluginContext context, Dialog<P> dialog) {
		return route(context, dialog, embed(context, dialog).getInteractionResult());
	}

	private static <P> WizardResult<P> embed(UIPluginContext context, Dialog<P> dialog) {
		return new WizardResult<>(dialog.getParameters(), context.showWizard(dialog.getTitle(),
				!dialog.hasPreviousDialog(), !dialog.hasNextDialog(), dialog.visualize()));
	}

	private static <P> WizardResult<P> route(UIPluginContext context, Dialog<P> dialog,
			TaskListener.InteractionResult interactionResult) {
		Dialog<P> next;
		switch (interactionResult) {
			case NEXT :
				next = dialog.getNext();
				return route(context, next, embed(context, next).getInteractionResult());
			case PREV :
				next = dialog.getPrevious();
				if (next == null)
					next = dialog;
				return route(context, next, embed(context, next).getInteractionResult());
			case FINISHED :
				next = dialog.getNext();
				if (next == null) {
					dialog.updateParametersOnGetNext();
					return new WizardResult<>(dialog.getParameters(), interactionResult);
				}
				return route(context, next, embed(context, next).getInteractionResult());
			default :
				return new WizardResult<>(dialog.getParameters(), interactionResult);
		}
	}

}
"
WizardResult.java,widget,"package org.processmining.widgets.wizard;

import org.deckfour.uitopia.api.event.TaskListener.InteractionResult;

public class WizardResult<P> {

	private final P parameters;

	private final InteractionResult interactionResult;

	public WizardResult(P parameters, InteractionResult interactionResult) {
		this.parameters = parameters;
		this.interactionResult = interactionResult;
	}

	public P getParameters() {
		return parameters;
	}

	public InteractionResult getInteractionResult() {
		return interactionResult;
	}
	
	
}
"
InformationStep.java,widget,"package org.processmining.framework.util.ui.wizard;

import javax.swing.JComponent;

/**
 * @author michael
 * 
 * @param <M>
 */
public abstract class InformationStep<M> implements ProMWizardStep<M> {

	private final String title;

	/**
	 * @param title
	 */
	public InformationStep(final String title) {
		this.title = title;
	}

	/**
	 * @see org.processmining.framework.util.ui.wizard.ProMWizardStep#apply(java.lang.Object,
	 *      javax.swing.JComponent)
	 */
	@Override
	public M apply(final M model, final JComponent component) {
		return model;
	}

	/**
	 * @see org.processmining.framework.util.ui.wizard.ProMWizardStep#canApply(java.lang.Object,
	 *      javax.swing.JComponent)
	 */
	@Override
	public boolean canApply(final M model, final JComponent component) {
		return true;
	}

	/**
	 * @see org.processmining.framework.util.ui.wizard.ProMWizardStep#getTitle()
	 */
	@Override
	public String getTitle() {
		return title;
	}

}
"
ListWizard.java,widget,"package org.processmining.framework.util.ui.wizard;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/**
 * @author michael
 * 
 * @param <SettingsModel>
 */
public class ListWizard<SettingsModel> implements ProMWizard<SettingsModel, ListWizard.ListModel<SettingsModel>> {

	static class ListModel<SettingsModel> {
		private final SettingsModel model;

		private int step = 0;

		public ListModel(final int step, final SettingsModel model) {
			super();
			this.step = step;
			this.model = model;
		}

		public SettingsModel getModel() {
			return model;
		}

		public int getStep() {
			return step;
		}

	}

	private final List<ProMWizardStep<SettingsModel>> steps;

	/**
	 * @param steps
	 */
	public ListWizard(final List<ProMWizardStep<SettingsModel>> steps) {
		this.steps = new ArrayList<ProMWizardStep<SettingsModel>>(steps);
	}

	/**
	 * @param steps
	 */
	public ListWizard(final ProMWizardStep<SettingsModel>... steps) {
		this.steps = new ArrayList<ProMWizardStep<SettingsModel>>(Arrays.asList(steps));
	}

	/**
	 * @param step
	 */
	public ListWizard(final ProMWizardStep<SettingsModel> step) {
		this.steps = new ArrayList<ProMWizardStep<SettingsModel>>();
		steps.add(step);
	}

	/**
	 * @see org.processmining.framework.util.ui.wizard.ProMWizard#getFirst(java.lang.Object)
	 */
	@Override
	public ProMWizardStep<SettingsModel> getFirst(final ListModel<SettingsModel> model) {
		return getNext(model, null);
	}

	/**
	 * @see org.processmining.framework.util.ui.wizard.ProMWizard#getModel(java.lang.Object)
	 */
	@Override
	public SettingsModel getModel(final ListModel<SettingsModel> wizardModel) {
		return wizardModel.getModel();
	}

	/**
	 * @see org.processmining.framework.util.ui.wizard.ProMWizard#getNext(java.lang.Object,
	 *      org.processmining.framework.util.ui.wizard.ProMWizardStep)
	 */
	@Override
	public ProMWizardStep<SettingsModel> getNext(final ListModel<SettingsModel> model,
			final ProMWizardStep<SettingsModel> current) {

		if (steps.size() > model.getStep()) {
			return steps.get(model.getStep());
		}

		return null;
	}

	/**
	 * @see org.processmining.framework.util.ui.wizard.ProMWizard#getWizardModel(java.lang.Object,
	 *      java.lang.Object)
	 */
	@Override
	public ListModel<SettingsModel> getWizardModel(final SettingsModel model,
			final ListModel<SettingsModel> currentWizardModel) {
		if (currentWizardModel == null) {
			return new ListModel<SettingsModel>(0, model);
		} else {
			return new ListModel<SettingsModel>(currentWizardModel.getStep() + 1, model);
		}
	}

	/**
	 * @see org.processmining.framework.util.ui.wizard.ProMWizard#isFinished(java.lang.Object)
	 */
	@Override
	public boolean isFinished(final ListModel<SettingsModel> model) {

		return model.getStep() >= steps.size();

	}

	/**
	 * @see org.processmining.framework.util.ui.wizard.ProMWizard#isLastStep(java.lang.Object)
	 */
	@Override
	public boolean isLastStep(final ListModel<SettingsModel> model) {
		return model.getStep() >= steps.size() - 1;
	}

}
"
MapWizard.java,widget,"package org.processmining.framework.util.ui.wizard;

import java.util.Collection;
import java.util.HashMap;
import java.util.Map;

/**
 * @author michael
 * 
 * @param <SettingsModel>
 * @param <Key>
 */
public abstract class MapWizard<SettingsModel, Key> implements
		ProMWizard<SettingsModel, MapWizard.MapModel<SettingsModel, Key>> {

	/**
	 * @author michael
	 * 
	 * @param <SettingsModel>
	 * @param <Key>
	 */
	public static class MapModel<SettingsModel, Key> {

		private final Key current;
		private final Key previous;
		private final SettingsModel settings;

		/**
		 * @param current
		 * @param model
		 * @param previous
		 */
		public MapModel(final Key current, final SettingsModel model, final Key previous) {
			super();

			this.current = current;
			this.settings = model;
			this.previous = previous;
		}

		/**
		 * @return the current
		 */
		public Key getCurrent() {
			return current;
		}

		/**
		 * @return
		 */
		public SettingsModel getModel() {
			return this.settings;
		}

		/**
		 * @return
		 */
		public Key getPrevious() {
			return previous;
		}
	}

	protected Map<Key, ProMWizardStep<SettingsModel>> steps;

	/**
	 * @param steps
	 */
	public MapWizard(final Map<Key, ProMWizardStep<SettingsModel>> steps) {
		this.steps = new HashMap<Key, ProMWizardStep<SettingsModel>>(steps);
	}

	protected MapWizard() {
		this.steps = new HashMap<Key, ProMWizardStep<SettingsModel>>();
	}

	/**
	 * @param currentWizardModel
	 * @return
	 */
	public abstract Collection<Key> getFinalKeys(MapModel<SettingsModel, Key> currentWizardModel);

	/**
	 * @see org.processmining.framework.util.ui.wizard.ProMWizard#getFirst(java.lang.Object)
	 */
	@Override
	public ProMWizardStep<SettingsModel> getFirst(final MapModel<SettingsModel, Key> model) {
		return getNext(model, null);
	}

	/**
	 * @param settings
	 * @return
	 */
	public abstract Key getInitialKey(SettingsModel settings);

	/**
	 * @see org.processmining.framework.util.ui.wizard.ProMWizard#getModel(java.lang.Object)
	 */
	@Override
	public SettingsModel getModel(final MapModel<SettingsModel, Key> wizardModel) {
		return wizardModel.getModel();
	}

	/**
	 * @see org.processmining.framework.util.ui.wizard.ProMWizard#getNext(java.lang.Object,
	 *      org.processmining.framework.util.ui.wizard.ProMWizardStep)
	 */
	@Override
	public ProMWizardStep<SettingsModel> getNext(final MapModel<SettingsModel, Key> model,
			final ProMWizardStep<SettingsModel> current) {
		if (steps.containsKey(model.getCurrent())) {
			return steps.get(model.getCurrent());
		}
		return null;
	}

	/**
	 * @param currentWizardModel
	 * @return
	 */
	public abstract Key getNextKey(MapModel<SettingsModel, Key> currentWizardModel);

	/**
	 * @see org.processmining.framework.util.ui.wizard.ProMWizard#getWizardModel(java.lang.Object,
	 *      java.lang.Object)
	 */
	@Override
	public MapModel<SettingsModel, Key> getWizardModel(final SettingsModel model,
			final MapModel<SettingsModel, Key> currentWizardModel) {
		if (currentWizardModel == null) {
			return new MapModel<SettingsModel, Key>(getInitialKey(model), model, null);
		} else {
			return new MapModel<SettingsModel, Key>(getNextKey(currentWizardModel), model,
					currentWizardModel.getCurrent());
		}
	}

	/**
	 * @see org.processmining.framework.util.ui.wizard.ProMWizard#isFinished(java.lang.Object)
	 */
	@Override
	public boolean isFinished(final MapModel<SettingsModel, Key> model) {
		return model.getPrevious() != null && getFinalKeys(model).contains(model.getPrevious());
	}

	/**
	 * @see org.processmining.framework.util.ui.wizard.ProMWizard#isLastStep(java.lang.Object)
	 */
	@Override
	public boolean isLastStep(final MapModel<SettingsModel, Key> model) {
		return model.getCurrent() != null && getFinalKeys(model).contains(model.getCurrent());
	}

}
"
ProMWizard.java,widget,"package org.processmining.framework.util.ui.wizard;

/**
 * @author michael
 * 
 * @param <SettingsModel>
 * @param <WizardModel>
 */
public interface ProMWizard<SettingsModel, WizardModel> {

	/**
	 * @param model
	 * @return
	 */
	public ProMWizardStep<SettingsModel> getFirst(WizardModel model);

	/**
	 * @param wizardModel
	 * @return
	 */
	public SettingsModel getModel(WizardModel wizardModel);

	/**
	 * @param model
	 * @param current
	 * @return
	 */
	public ProMWizardStep<SettingsModel> getNext(WizardModel model, ProMWizardStep<SettingsModel> current);

	/**
	 * @param model
	 * @param currentWizardModel
	 * @return
	 */
	public WizardModel getWizardModel(SettingsModel model, WizardModel currentWizardModel);

	//we do not have canFinish, as the ProM Wizard interface only 
	//shows the finish button if it is the last step
	//public boolean canFinish(WizardModel model);
	/**
	 * @param model
	 * @return
	 */
	public boolean isFinished(WizardModel model);

	/**
	 * @param model
	 * @return
	 */
	public boolean isLastStep(WizardModel model);

}
"
ProMWizardDisplay.java,widget,"package org.processmining.framework.util.ui.wizard;

import java.util.Stack;

import javax.swing.JComponent;

import org.deckfour.uitopia.api.event.TaskListener.InteractionResult;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.framework.util.Pair;

/**
 * @author michael
 * 
 */
public class ProMWizardDisplay {

	/**
	 * @param context
	 * @param wizard
	 * @param model
	 * @return
	 */
	public static <SettingsModel, WizardModel> SettingsModel show(final UIPluginContext context,
			final ProMWizard<SettingsModel, WizardModel> wizard, final SettingsModel model) {

		WizardModel wizardModel = wizard.getWizardModel(model, null);

		ProMWizardStep<SettingsModel> current = wizard.getFirst(wizardModel);
		JComponent configuration = current.getComponent(wizard.getModel(wizardModel));

		final Stack<Pair<ProMWizardStep<SettingsModel>, WizardModel>> steps = new Stack<Pair<ProMWizardStep<SettingsModel>, WizardModel>>();

		int stepCount = 1;
		do {
			String title;
			if (current.getTitle() == null) {
				title = ""Step "" + stepCount;
			} else {
				title = current.getTitle();
			}

			final InteractionResult result = context.showWizard(title, steps.isEmpty(), wizard.isLastStep(wizardModel),
					configuration);

			switch (result) {
				case FINISHED :
				case NEXT :
					if (current.canApply(wizard.getModel(wizardModel), configuration)) {
						steps.push(new Pair<ProMWizardStep<SettingsModel>, WizardModel>(current, wizardModel));

						wizardModel = wizard.getWizardModel(current.apply(wizard.getModel(wizardModel), configuration),
								wizardModel);
						current = wizard.getNext(wizardModel, current);
						if (current != null) {
							configuration = current.getComponent(wizard.getModel(wizardModel));
							stepCount++;
						}
					}
					// if canApply is false, the current remains the same!
					break;
				case PREV :
					if (current.canApply(wizard.getModel(wizardModel), configuration)) {
						wizardModel = wizard.getWizardModel(current.apply(wizard.getModel(wizardModel), configuration),
								wizardModel);
					}
					final Pair<ProMWizardStep<SettingsModel>, WizardModel> prevstep = steps.pop();
					current = prevstep.getFirst();
					wizardModel = prevstep.getSecond();

					configuration = current.getComponent(wizard.getModel(wizardModel));
					stepCount--;
					break;
				case CANCEL :
					return null;
				case CONTINUE :
					//never used.
			}

		} while (!wizard.isFinished(wizardModel));

		//ProMWizardStep<SettingsModel> lastStupidStep = wizard.getLast(wizardModel, current); 
		//context.showWizard(lastStupidStep.getTitle(), true, true, lastStupidStep.getComponent(wizard.getModel(wizardModel)));

		return wizard.getModel(wizardModel);
	}

}
"
ProMWizardStep.java,widget,"package org.processmining.framework.util.ui.wizard;

import javax.swing.JComponent;

/**
 * @author michael
 * 
 * @param <SettingsModel>
 */
public interface ProMWizardStep<SettingsModel> {

	/**
	 * @param model
	 * @param component
	 * @return
	 */
	public SettingsModel apply(SettingsModel model, JComponent component);

	/**
	 * @param model
	 * @param component
	 * @return
	 */
	public boolean canApply(SettingsModel model, JComponent component);

	/**
	 * @param model
	 * @return
	 */
	public JComponent getComponent(SettingsModel model);

	/**
	 * @return
	 */
	public String getTitle();
}
"
TextAreaStep.java,widget,"package org.processmining.framework.util.ui.wizard;

import javax.swing.JComponent;

import org.processmining.framework.util.ui.widgets.ProMTextArea;

class TextAreaStep extends ProMTextArea implements ProMWizardStep<String> {

	private static final long serialVersionUID = 7227063553927410431L;

	private final String title;

	public TextAreaStep() {
		this("""");
	}

	public TextAreaStep(final String title) {
		this("""", """");
	}

	public TextAreaStep(final String title, final String text) {
		super();

		this.title = title;

		setText(text);

	}

	@Override
	public String apply(final String model, final JComponent component) {
		if (component instanceof TextAreaStep) {
			return ((TextAreaStep) component).getText();
		} else {
			return """";
		}
	}

	@Override
	public boolean canApply(final String model, final JComponent component) {
		return true;
	}

	@Override
	public JComponent getComponent(final String model) {
		return new TextAreaStep(title, model);
	}

	@Override
	public String getTitle() {
		return title;
	}
}"
TextStep.java,widget,"package org.processmining.framework.util.ui.wizard;

import java.awt.BorderLayout;

import javax.swing.JComponent;
import javax.swing.JLabel;

import org.processmining.framework.util.ui.widgets.WidgetColors;

import com.fluxicon.slickerbox.components.RoundedPanel;
import com.fluxicon.slickerbox.factory.SlickerFactory;

/**
 * @author michael
 * 
 * @param <M>
 */
public class TextStep<M> extends InformationStep<M> {

	/**
	 * @param title
	 * @param text
	 * @return
	 */
	public static <T> TextStep<T> create(final String title, final String text) {
		return new TextStep<T>(title, text);
	}

	private final String text;

	/**
	 * @param title
	 * @param text
	 */
	public TextStep(final String title, final String text) {
		super(title);

		this.text = text;
	}

	/**
	 * @see org.processmining.framework.util.ui.wizard.ProMWizardStep#getComponent(java.lang.Object)
	 */
	@Override
	public JComponent getComponent(final Object model) {
		final JLabel label = SlickerFactory.instance().createLabel(text);
		final RoundedPanel panel = new RoundedPanel(15, 0, 3);

		panel.setOpaque(true);
		panel.setBackground(WidgetColors.PROPERTIES_BACKGROUND);

		panel.setLayout(new BorderLayout());
		panel.add(label, BorderLayout.CENTER);

		return panel;
	}

}
"
