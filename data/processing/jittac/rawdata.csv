FileName,Label,FileContent
AbstractArchitectureElement.java,architecture-model,"package se.kau.cs.jittac.model.am;

import java.util.UUID;

/**
 * Basic abstract implementation of architecture elements.
 * @author Sebastian Herold
 *
 */
public abstract class AbstractArchitectureElement implements IArchitectureElement {

	private final UUID id;
	
	protected AbstractArchitectureElement() {
		this(null);
	}
	
	protected AbstractArchitectureElement(UUID id) {
		if (id == null) {
			this.id = UUID.randomUUID();
		}
		else {
			this.id = id;
		}
	}

	public final UUID getId() {
		return id;
	}
	
	public String toString() {
		return getName();
	}
}
"
ArchitectureModel.java,architecture-model,"package se.kau.cs.jittac.model.am;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.UUID;

import org.apache.commons.collections4.map.HashedMap;

import com.sun.xml.internal.ws.policy.privateutil.PolicyUtils.Collections;

import se.kau.cs.jittac.model.am.events.ArchitectureModelChangeEvent;
import se.kau.cs.jittac.model.am.events.ComponentAdditionEvent;
import se.kau.cs.jittac.model.am.events.ComponentNameChangeEvent;
import se.kau.cs.jittac.model.am.events.ComponentRemovalEvent;
import se.kau.cs.jittac.model.am.events.ConnectorAdditionEvent;
import se.kau.cs.jittac.model.am.events.ConnectorReferencesAddedEvent;
import se.kau.cs.jittac.model.am.events.ConnectorReferencesRemovedEvent;
import se.kau.cs.jittac.model.am.events.ConnectorRemovalEvent;
import se.kau.cs.jittac.model.am.events.ConnectorStateChangeEvent;
import se.kau.cs.jittac.model.am.events.IArchitectureModelChangeListener;
import se.kau.cs.jittac.model.am.events.IArchitectureModelVisitor;
import se.kau.cs.jittac.model.im.IImplementationModel;
import se.kau.cs.jittac.model.im.IImplementationModelElement;
import se.kau.cs.jittac.model.im.IXReference;
import se.kau.cs.jittac.model.im.ImplementationModelPartition;
import se.kau.cs.jittac.model.im.events.IImplementationChangeListener;
import se.kau.cs.jittac.model.im.events.XReferenceChangeDeltaEvent;
import se.kau.cs.jittac.model.mapping.ArchitectureMapping;
import se.kau.cs.jittac.model.mapping.IJittacProject;
import se.kau.cs.jittac.model.mapping.IMappableElement;
import se.kau.cs.jittac.model.mapping.events.AbstractArchitectureMappingChangeListener;
import se.kau.cs.jittac.model.mapping.events.ManagedProjectAddedEvent;
import se.kau.cs.jittac.model.mapping.events.ManagedProjectRemovedEvent;
import se.kau.cs.jittac.model.mapping.events.MappingAdditionEvent;
import se.kau.cs.jittac.model.mapping.events.MappingRemovalEvent;

/**
 * This class represents architecture models, consisting of components and connectors.
 * It implements also IImplementationModelListener functionality to react to any changes
 * occuring in implementation model connected with this architecture model.
 * 
 * It furthermore contains a MappingListener to react to changes in the mapping between
 * components and resources.
 * @author Sebastian Herold
 *
 */
public class ArchitectureModel extends AbstractArchitectureElement
								implements IImplementationChangeListener {

	//Mapping and listener for mapping
	private ArchitectureMapping mapping;
	private MappingListener mappingListener;
	
	//managing listeners to architectural model
	private List<IArchitectureModelChangeListener> modelListeners;
	
	//Components and connectors
	private List<Component> components;
	private List<Connector> connectors;
	
	public static ArchitectureModel createArchitectureModel() {
		return new ArchitectureModel();
	}
	
	private ArchitectureModel() {
		super();
		mappingListener = new MappingListener();
		modelListeners = new ArrayList<IArchitectureModelChangeListener>();
		this.mapping = ArchitectureMapping.createEmptyMapping(this);
		mapping.registerListener(this.mappingListener);
		components = new ArrayList<Component>();
		connectors = new ArrayList<Connector>();
	}
	
	public ArchitectureModel getModel() {
		return this;
	}
	
	@Override
	public String getName() {
		return ""Architecture model"";
	}
	
	public ArchitectureMapping getMapping() {
		return mapping;
	}
	
	public Component createComponent() {
		return createComponent(null, null);
	}
	
	public Component createComponent(String name) {
		return createComponent(name, null);
	}
	
	public Component createComponent(String name, UUID id) {
		Component newComponent = Component.createComponent(this, id);
		if (newComponent != null) {
			if (name != null) {
				newComponent.setName(name);
			}
			if (!components.contains(newComponent)) {
				components.add(newComponent);
			}
			createConnector(newComponent, newComponent);
		}
		this.fireEvent(new ComponentAdditionEvent(newComponent, this));
		return newComponent;
	}
	
	public Connector createConnector(Component src, Component trg) {
		
		Connector newConnector = Connector.createConnector(src, trg);
		if (newConnector != null && !connectors.contains(newConnector)) {
			connectors.add(newConnector);
			if (src.equals(trg)) {
				src.setReflexiveConnector(newConnector);
			}
			else {
				src.addOutgoingConnector(newConnector);
				trg.addIncomingConnector(newConnector);
				this.fireEvent(new ConnectorAdditionEvent(newConnector, this));
			}
		}
		return newConnector;
	}
	
	public boolean removeComponent(Component comp) {
		if (comp == null) throw new IllegalArgumentException(""Argument must not be null"");
		if (comp.getModel() != this) throw new IllegalArgumentException(""Component "" + comp + "" already attached to different model."");
		
		Set<Connector> connectorsToBeRemoved = new HashSet<Connector>();
		boolean removed;
		if (components.contains(comp)) {
			for (Connector conn : comp.getOutgoingConnectors()) {
				removed = connectorsToBeRemoved.add(conn);
			}
			for (Connector conn : comp.getIncomingConnectors()) {
				removed = connectorsToBeRemoved.add(conn);
			}
			for (Connector conn : connectorsToBeRemoved) {
				this.removeConnector(conn);
			}
			this.removeConnector(comp.getReflexiveConnector());
			removed = components.remove(comp); 
			if (removed) {
				getMapping().removeComponent(comp);
				comp.detachFromModel();
				this.fireEvent(new ComponentRemovalEvent(comp, this));
			}
			return removed;
		}
		return false;
	}
	
	public boolean removeConnector(Connector conn) {
		if (conn == null) throw new IllegalArgumentException(""Argument must not be null"");
		if (conn.getModel() != this) throw new IllegalArgumentException(""Connector "" + conn + "" attached to different model."");
		boolean removed;
		
		if (!conn.isReflexive()) {
			conn.getSrc().removeOutgoingConnector(conn);
			conn.getTrg().removeIncomingConnector(conn);
			removed = connectors.remove(conn);
			if (removed) {
				conn.detachFromModel();
				fireEvent(new ConnectorRemovalEvent(conn, this));
			}
		}
		else {
			conn.getSrc().setReflexiveConnector(null);
			removed = connectors.remove(conn);
		}
		return removed;
	}
	
	public void makeConnectorUnenvisaged(Connector conn) {
		if (conn == null) throw new IllegalArgumentException(""Argument must not be null"");
		if (conn.getModel() != this) throw new IllegalArgumentException(""Connector "" + conn + "" attached to different model."");

		if (conn.getState() == Connector.STATE.CONVERGENCE) {
			changeConnectorState(conn, false);
		}
		else if (conn.getState() == Connector.STATE.DIVERGENCE) {
			
		}
		else if (conn.getState() == Connector.STATE.ABSENCE) {
			removeConnector(conn);
		}
	}
	
	public boolean changeConnectorState(Connector conn, boolean envisaged) {
		if (conn == null) throw new IllegalArgumentException(""Argument must not be null"");
		if (conn.getModel() != this) throw new IllegalArgumentException(""Connector "" + conn + "" attached to different model."");
		boolean changed = false;
		
		Connector.STATE oldState = conn.getState();
		if (oldState == Connector.STATE.CONVERGENCE ||
			oldState == Connector.STATE.DIVERGENCE) {
			conn.setEnvisaged(envisaged);
			changed = oldState != conn.getState();
		}
		if (changed) {
			this.fireEvent(new ConnectorStateChangeEvent(conn, oldState, conn.getState(), this));
		}
		return changed;
	}
	
	public boolean containsComponent(Component c) {
		return components.contains(c);
	}
	
	public boolean containsConnectorBetween(Component src, Component trg) {
		
		for (Connector c : connectors) {
			if (src.equals(c.getSrc()) && trg.equals(c.getTrg())) {
				return true;
			}
		}
		return false;
	}
	
	public Component getComponentById(UUID id) {
		for (Component c: components) {
			if (c.getId().equals(id)) {
				return c;
			}
		}
		return null;
	}
	
	public Set<Component> getComponents() {
		return new HashSet<Component>(this.components);
	}
	
	public Set<Connector> getConnectors() {
		return new HashSet<Connector>(this.connectors);
	}
	
	public List<Component> getComponentsAsList() {
		return new ArrayList<Component>(this.components);
	}

	public List<Connector> getConnectorsAsList() {
		return new ArrayList<Connector>(this.connectors);
	}
	
	public Connector getConnectorByComponents(Component src, Component trg) {

		for (Connector c : connectors) {
			if (src.equals(c.getSrc()) && trg.equals(c.getTrg())) {
				return c;
			}
		}
		return null;
	}

	public Set<IJittacProject> getManagedProjects() {
		return getMapping().getManagedProjects();
	}
	
	public void setComponentName(Component comp, String name) {
		String oldName = comp.getName();
		if (oldName != name) {
			comp.setName(name);
			fireEvent(new ComponentNameChangeEvent(comp, this, oldName, name));
		}
	}
	
	public void registerListener(IArchitectureModelChangeListener listener) {
		if (!modelListeners.contains(listener)) {
			modelListeners.add(listener);
		}
	}
	
	public void deregisterListener(IArchitectureModelChangeListener listener) {
		modelListeners.remove(listener);
	}
	
	@Override
	public void onXReferenceDeltaEvent(XReferenceChangeDeltaEvent event) {
		if (event == null) throw new IllegalArgumentException(""Argument must not be null."");

		removeReferencesFromConnectors(event.removedReferences());
		addReferencesToConnectors(event.addedReferences());
		addReferencesToConnectors(event.unchangedReferences());
	}

	@Override
	public void onCompleteLoad(IImplementationModel im) {
		if (this.getManagedProjects().contains(im.getProject())) {
			for (ImplementationModelPartition part : im.getPartitions()) {
				addReferencesToConnectors(part.getReferences());
			}
		}
		
	}
	
	private void fireEvent(ArchitectureModelChangeEvent event) {
		//Local copy to avoid concurrent modification exceptions
		List<IArchitectureModelChangeListener> temp = new ArrayList<>(modelListeners);
		for (IArchitectureModelChangeListener listener : temp) {
			listener.handleEvent(event);
		}
	}
	
	private boolean addReferencesToConnectors(Set<? extends IXReference<?,?>> refs) {
		if (refs == null) throw new IllegalArgumentException(""Argument must not be null."");
		boolean referenceSetModified = false;
		boolean result = false;
		Map<Connector, Set<IXReference<?,?>>> mappings = new HashedMap<Connector, Set<IXReference<?,?>>>();
		
		for (IXReference<?,?> ref : refs) {
			Component srcComp = 
					mapping.getComponent(ref.getSource().getResource());
			Component trgComp = 
					mapping.getComponent(ref.getTarget().getResource());
			if (srcComp != null && trgComp != null /*&& !srcComp.equals(trgComp)*/) {
				Connector conn = this.getConnectorByComponents(srcComp, trgComp);
				if (conn == null) {
					conn = this.createConnector(srcComp, trgComp);
					conn.setEnvisaged(false);
				}
				if (!mappings.containsKey(conn)) {
					mappings.put(conn, new HashSet<IXReference<?,?>>());
				}
				mappings.get(conn).add(ref);
			}
		}
		for (Connector changedConnector : mappings.keySet()) {
			Set<IXReference<?,?>> actuallyNewReferences = mappings.get(changedConnector);
			actuallyNewReferences.removeAll(changedConnector.getContributingReferences());
					
			referenceSetModified = changedConnector.addReferences(mappings.get(changedConnector));
			result = result || referenceSetModified;
			if (!changedConnector.isReflexive() && referenceSetModified)
				fireEvent(new ConnectorReferencesAddedEvent(changedConnector, actuallyNewReferences, this));
		}
		return result;
	}
	
	/**
	 * Do not call when mapping is in consistent state, e.g. while handling mapping change events.
	 * @param refs
	 * @return
	 */
	private boolean removeReferencesFromConnectors(Set<IXReference<?,?>> refs) {
		if (refs == null) throw new IllegalArgumentException(""Argument must not be null."");
		
		Map<Connector, Set<IXReference<?,?>>> mappings = new HashedMap<Connector, Set<IXReference<?,?>>>();
		boolean referenceSetModified = false;
		boolean result = false;
		
		for (IXReference<?,?> ref : refs) {
			Component srcComp = 
					mapping.getComponent(ref.getSource().getResource());
			Component trgComp = 
					mapping.getComponent(ref.getTarget().getResource());
			Connector conn = getConnectorByComponents(srcComp, trgComp);
			
			if (conn != null) {
				if (!mappings.containsKey(conn)) {
					mappings.put(conn, new HashSet<IXReference<?,?>>());
				}
				mappings.get(conn).add(ref);
			}
		}
		for (Connector conn : mappings.keySet()) {
			/*Set<IXReference> actuallyRemovedRefs = conn.getContributingReferences();
			Connector.STATE oldState = conn.getState();
			actuallyRemovedRefs.retainAll(mappings.get(conn));
			
			referenceSetModified = conn.removeReferences(actuallyRemovedRefs);*/
			result = result || removeReferencesFromConnector(conn, mappings.get(conn));
/*			if (!conn.isReflexive() && referenceSetModified) {
				fireEvent(new ConnectorReferencesRemovedEvent(conn, actuallyRemovedRefs, this));
			}
			//The following is true if we removed the last references of a connector
			if (conn.getState() != oldState ) {
				//The following is true if we removed the last references of a divergence
				if (conn.getState() == Connector.STATE.INCONSISTENT) {
					this.removeConnector(conn);
				}
				else {
					fireEvent(new ConnectorStateChangeEvent(conn, oldState, conn.getState(), this));
				}
			}*/
		}
		return referenceSetModified;
	}
	
	private boolean removeReferencesFromConnector(Connector conn, Set<IXReference<?,?>> refs) {
		boolean result = false;
		
		if (conn != null && refs != null) {
			Set<IXReference<?,?>> actuallyRemovedRefs = conn.getContributingReferences();
			actuallyRemovedRefs.retainAll(refs);
			Connector.STATE oldState = conn.getState();
			result = conn.removeReferences(actuallyRemovedRefs);
			if (!conn.isReflexive() && result) {
				fireEvent(new ConnectorReferencesRemovedEvent(conn, actuallyRemovedRefs, this));
				if (conn.getState() != oldState ) {
					//The following is true if we removed the last references of a divergence
					if (conn.getState() == Connector.STATE.INCONSISTENT) {
						this.removeConnector(conn);
					}
					else {
						fireEvent(new ConnectorStateChangeEvent(conn, oldState, conn.getState(), this));
					}
				}
			}
		}
		
		return result;
	}
	
	private class MappingListener extends AbstractArchitectureMappingChangeListener {

		@Override
		public void onMappingAdded(MappingAdditionEvent event) {
			IMappableElement newlyMappedResource = event.getElement();
			Map<Connector, Set<IXReference<?,?>>> relevantRefs = new HashedMap<Connector, Set<IXReference<?,?>>>();
			Set<IXReference<?,?>> formerlyUnmappedReferences = new HashSet<IXReference<?,?>>();
			
			if (event.getPreviousComponent() != null) {
				Set<Connector> connectors = event.getPreviousComponent().getOutgoingConnectors();
				connectors.addAll(event.getPreviousComponent().getIncomingConnectors());
				connectors.add(event.getPreviousComponent().getReflexiveConnector());
				for (Connector con : connectors) {
					relevantRefs.put(con, _getReferencesAffectedByChangeOfMapping(con, newlyMappedResource, event.getPreviousComponent()));
				}
			}
			else {
				//retrieve references from implementation model
				_gatherReferencesFromIdenticallyMappedChildResources(event.getElement(), formerlyUnmappedReferences);
				
			}
			//remove refs and attach to correct connectors
			for (Connector conn : relevantRefs.keySet()) {
				//TODO: add a corresponding removeReferences to this class.
				//conn.removeReferences(relevantRefs.get(conn));
				//fireEvent(new ConnectorReferencesRemovedEvent(conn, relevantRefs.get(conn), ArchitectureModel.this));
				removeReferencesFromConnector(conn, relevantRefs.get(conn));

				formerlyUnmappedReferences.addAll(relevantRefs.get(conn));
				//addReferencesToConnectors();
			}
			addReferencesToConnectors(formerlyUnmappedReferences);
			event.getElement().getProject().getImplementationModel().
				registerImplementationChangeListener(ArchitectureModel.this);
		}

		@Override
		public void onMappingRemoved(MappingRemovalEvent event) {
			IMappableElement newlyMappedResource = event.getElement();
			Map<Connector, Set<IXReference<?,?>>> relevantRefs = new HashedMap<Connector, Set<IXReference<?,?>>>();
			//get all connectors that go to old component;
			Set<Connector> connectors = event.getComponent().getOutgoingConnectors();
			Set<IXReference<?,?>> refsToBeRemoved = new HashSet<IXReference<?,?>>();
			connectors.addAll(event.getComponent().getIncomingConnectors());
			connectors.add(event.getComponent().getReflexiveConnector());
			for (Connector con : connectors) {
				relevantRefs.put(con, _getReferencesAffectedByChangeOfMapping(con, newlyMappedResource, event.getComponent()));
			}
			for (Connector con : relevantRefs.keySet()) {
				removeReferencesFromConnector(con, relevantRefs.get(con));
				refsToBeRemoved.addAll(relevantRefs.get(con));
			}
			if (event.getComponentAfterRemoval() != null) {
				addReferencesToConnectors(refsToBeRemoved);
			}
			if (!getMapping().getManagedProjects().contains(event.getElement().getProject())) {
				event.getElement().getProject().getImplementationModel().
					deregisterImplementationChangeListener(ArchitectureModel.this);
			}
		}

		@Override
		public void onManagedProjectAdded(ManagedProjectAddedEvent event) {
			IJittacProject project = event.getProject();
			IImplementationModel im = project.getImplementationModel();
			im.registerImplementationChangeListener(ArchitectureModel.this);
			ArchitectureModel.this.onCompleteLoad(im);
		}
		
		public void onManagedProjectRemoved(ManagedProjectRemovedEvent event) {
			IJittacProject project = event.getProject();
			IImplementationModel im = project.getImplementationModel();
			im.deregisterImplementationChangeListener(ArchitectureModel.this);
		}		
		
		/**
		 * Queries references of a single connector that are need to be re-routed, i.e. to be assigned to a
		 * different connector because the mapping of the given element has changed.
		 * @param con The connector for which the references are scanned
		 * @param elem The element for which the mapping was changed
		 * @param prevCompForElem The component that the element was previously mapped to.
		 * @return The set of references that are affected. 
		 */
		private Set<IXReference<?,?>> _getReferencesAffectedByChangeOfMapping(Connector con, 
				IMappableElement elem, Component prevCompForElem) {
			Set<IXReference<?,?>> relevantRefs = new HashSet<IXReference<?,?>>();
			IMappableElement endPointAResource = null;
			IMappableElement endPointBResource = null;
			
			for (IXReference<?,?> ref : con.getContributingReferences()) {
				if (con.isReflexive()) {
					endPointAResource = mapping.getExplicitlyMappedParent(ref.getSource().getResource());
					endPointBResource = mapping.getExplicitlyMappedParent(ref.getTarget().getResource());
				}
				else if (con.getSrc().equals(prevCompForElem)) {
					endPointAResource = mapping.getExplicitlyMappedParent(ref.getSource().getResource());
					endPointBResource = endPointAResource;
				}
				else  if (con.getTrg().equals(prevCompForElem)) {
					endPointBResource = mapping.getExplicitlyMappedParent(ref.getTarget().getResource());
					endPointAResource = endPointBResource;
				}
				elem = mapping.getExplicitlyMappedParent(elem);		
				if (elem == null) {
					if (endPointAResource == null || endPointBResource == null) {
					relevantRefs.add(ref);
					}
				}
				else if (elem.equals(endPointAResource) || elem.equals(endPointBResource)) {
					relevantRefs.add(ref);
				}
			}
			return relevantRefs;
		}
		
		private void _gatherReferencesFromIdenticallyMappedChildResources(IMappableElement elem, Set<IXReference<?,?>> result) {
			IImplementationModel im = elem.getProject().getImplementationModel();
			Set<IXReference<? extends IImplementationModelElement<?>,?>> refsInResource =  new HashSet<>();
			refsInResource.addAll(im.getReferencesForResource(elem));
			refsInResource.addAll(im.getIncomingReferencesForResource(elem));
			result.addAll(refsInResource);
			for (IMappableElement child : elem.getChildren()) {
				if (mapping.getComponent(child).equals(mapping.getComponent(elem))) {
					_gatherReferencesFromIdenticallyMappedChildResources(child, result);
				}
			}
		}
	}
}
"
Component.java,architecture-model,"package se.kau.cs.jittac.model.am;

import java.util.HashSet;
import java.util.Set;
import java.util.UUID;

/**
 * Class representing components of architecture models. Components (""boxes"") in architecture models
 * represent logical partitions of source code. The mapping between components and source code
 * is managed by se.kau.cs.jittac.model.mapping.ArchitectureMapping which, in turn, is accessed via
 * the component's architecture model.
 *  
 * @author Sebastian Herold
 *
 */
public class Component extends AbstractArchitectureElement {

	private String name = ""Unnamed component"";
	private ArchitectureModel am;
	
	private Set<Connector> outgoingConnectors;
	private Set<Connector> incomingConnectors;
	private Connector reflexiveConnector;
	
	/**
	 * Creates a component inside the given architecture model.
	 * @param am The architecture model that should contain the new component.
	 * @return The new component.
	 */
	public static Component createComponent(ArchitectureModel am) {
		return new Component(am);
	}
	
	/**
	 * Creates a component with the given id. ONLY TO BE CALLED DURING DESERIALIZATION!
	 * @param am The architecture model that should contain the new component.
	 * @param id The id assigned to the new component.
	 * @return The new component.
	 */
	public static Component createComponent(ArchitectureModel am, UUID id) {
		return new Component(am, id);
	}
	
	private Component(ArchitectureModel am, UUID id) {
		super(id);
		this.am = am;
		outgoingConnectors = new HashSet<Connector>();
		incomingConnectors = new HashSet<Connector>();
		reflexiveConnector = null;
	}
	
	private Component(ArchitectureModel am) {
		//pre: am != null
		this(am, null);
	}

	public void setName(String name) {
		this.name = name;
	}
	
	public String getName() {
		return this.name;
	}
	
	public ArchitectureModel getModel() {
		return am;
	}

	/**
	 * Add a new outgoing connector to the component.
	 * @param conn The connector to be added.
	 * @return True if connector is truly added, i.e. it had not been connected as outgoing from the component before.
	 */
	public boolean addOutgoingConnector(Connector conn) {
		return outgoingConnectors.add(conn);
	}

	/**
	 * Add a new incoming connector to the component.
	 * @param conn The connector to be added.
	 * @return True if connector is truly added, i.e. it had not been connected as incoming to the component before.
	 */
	public boolean addIncomingConnector(Connector conn) {
		return incomingConnectors.add(conn);
	}
	
	/**
	 * Sets the components reflexive connector which connects the components with itself.
	 * This is a supporting construct that makes dependency analysis easier. The reflexive
	 * connector is NOT counted as a incoming or outgoing connector.
	 * @param conn The connector supposed to be the reflexive connector.
	 */
	public void setReflexiveConnector(Connector conn) {
		this.reflexiveConnector = conn;
	}
	
	/**
	 * Removes a connector from the component's set of outgoing connectors.
	 * @param conn The connector to be removed
	 * @return True if the connector was in the set before, false otherwise.
	 */
	public boolean removeOutgoingConnector(Connector conn) {
		return outgoingConnectors.remove(conn);
	}

	/**
	 * Removes a connector from the component's set of incoming connectors.
	 * @param conn The connector to be removed
	 * @return True if the connector was in the set before, false otherwise.
	 */
	public boolean removeIncomingConnector(Connector conn) {
		return incomingConnectors.remove(conn);
	}	
	
	/**
	 * Returns the component's set of outgoing connectors.
	 * @return See above. Empty set if there are no outgoing connectors.
	 */
	public Set<Connector> getOutgoingConnectors() {
		return new HashSet<Connector>(this.outgoingConnectors);
	}

	/**
	 * Returns the component's set of incoming connectors.
	 * @return See above. Empty set if there are no incoming connectors.
	 */

	public Set<Connector> getIncomingConnectors() {
		return new HashSet<Connector>(this.incomingConnectors);
	}

	/**
	 * Gets the components reflexive connector which connects the components with itself.
	 * This is a supporting construct that makes dependency analysis easier. The reflexive
	 * connector is NOT counted as a incoming or outgoing connector.
	 * @return The reflexive connector of the component.
	 */
	public Connector getReflexiveConnector() {
		return this.reflexiveConnector;
	}
	
	public void detachFromModel() {
		am = null;
	}
	
	@Override
	public int hashCode() {
		final int prime = 67;
		int result = 1;
		result = prime * result + ((getId() == null) ? 0 : getId().hashCode());
		return result;
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		Component other = (Component) obj;
		if (getId() == null) {
			if (other.getId() != null)
				return false;
		} else if (!getId().equals(other.getId()))
			return false;
		return true;
	}

	
}
"
Connector.java,architecture-model,"package se.kau.cs.jittac.model.am;

import java.util.HashSet;
import java.util.Set;

import se.kau.cs.jittac.model.im.IXReference;

/**
 * This class represents connectors in architecture models.
 * @author Sebastian Herold
 *
 */
public class Connector extends AbstractArchitectureElement {

	private ArchitectureModel am;
	private final Component src;
	private final Component trg;
	private boolean envisaged;
	private Set<IXReference<?,?>> contributingRefs;

	/**
	 * The state of a connector represents the different types of
	 * connectors in reflexion modelling plus additional states for
	 * reflexive connectors and inconsistent situations (e.g., not
	 * envisaged but convergent).
	 * @author Sebastian Herold
	 *
	 */
	public static enum STATE {
		CONVERGENCE,
		DIVERGENCE,
		ABSENCE,
		INCONSISTENT,
		REFLEXIVE
	}
	
	/**
	 * Creates a connector between two components if none exists between them.
	 * Both components must be in the same architecture model.
	 * @param src Component being the source of the connector. May not be null.
	 * @param trg Component being the target of the connector. May not be null.
	 * @return A new Connector object. Null if one or both components are null,
	 * not in the same model, or if a connector already exists between them.
	 */
	public static Connector createConnector(Component src, Component trg) {
		if (src == null || trg == null /*|| src.equals(trg)*/ || src.getModel() != trg.getModel()) return null;
		if (src.getModel().containsConnectorBetween(src, trg)) return null;
		
		return new Connector(src.getModel(), src, trg);
	}
	
	private Connector(ArchitectureModel am, Component src, Component trg) {
		super();
		this.am = am;
		this.src = src;
		this.trg = trg;
		this.envisaged = true;
		contributingRefs = new HashSet<IXReference<?,?>>();
	}
	
	public ArchitectureModel getModel() {
		return am;
	}
	
	/**
	 * Returns the name of the connector in the form
	 * 
	 * Name of source component -> name of target component
	 */
	public String getName() {
		return src.getName() + "" -> "" + trg.getName();
	}
	
	/**
	 * Returns the component being the source of the connector.
	 * @return
	 */
	public Component getSrc() {
		return src;
	}

	/**
	 * Returns the component being the target of the connector.
	 * @return
	 */
	public Component getTrg() {
		return trg;
	}

	/**
	 * Sets a boolean value indicating whether the connector is
	 * envisaged, i.e. whether it represents allowed source code
	 * dependencies.
	 * @param value true for ""is envisaged"", false for ""not envisaged"".
	 */
	public void setEnvisaged(boolean value) {
		envisaged = value;
	}
	
	/**
	 * Returns whether the connector is envisaged or not.
	 * @return True if the connector is envisaged. Always true
	 * for reflexive connectors. False otherwise.
	 */
	public boolean isEnvisaged() {
		if (isReflexive()) return true;
		return envisaged;
	}
	
	/**
	 * Returns whether the connector is reflexive,
	 * i.e. whether the source component equals the target 
	 * component.
	 * @return see above.
	 */
	public boolean isReflexive() {
		return getSrc().equals(getTrg());
	}
	
	/**
	 * Returns a copy of the set of references contributing
	 * to the connector.
	 * @return see above.
	 */
	public Set<IXReference<?,?>> getContributingReferences() {
		return new HashSet<IXReference<?,?>>(this.contributingRefs);
	}
	
	/**
	 * Adds a reference to the connector
	 * @param ref The reference to be added.
	 * @return True if the set of contributing references was
	 * changed by this addition, the passed reference was
	 * not contained before the call. False otherwise.
	 */
	public boolean addReference(IXReference<?,?> ref) {
		return contributingRefs.add(ref);
	}
	
	/**
	 * Adds a set of references to the connector.
	 * @param refs The set of references to be added.
	 * @return True if the set of contributing references was
	 * changed by this addition, the passed reference was
	 * not contained before the call. False otherwise.
	 */
	public boolean addReferences(Set<IXReference<?,?>> refs) {
		return contributingRefs.addAll(refs);
	}	
	
	/**
	 * Checks whether a reference contributes to the connector.
	 * @param ref The reference to be checked.
	 * @return True if the passed reference contributes, false otherwise.
	 */
	public boolean isContributedBy(IXReference<?,?> ref) {
		return contributingRefs.contains(ref);
	}
	
	/**
	 * Removes a reference from the set of contributing references
	 * @param ref The reference to be removed.
	 * @return True if the set of contributing references was changed.
	 * False otherwise.
	 */
	public boolean removeReference(IXReference<?,?> ref) {
		return contributingRefs.remove(ref);
	}

	/**
	 * Removes references from the set of contributing references
	 * @param refs The references to be removed.
	 * @return True if the set of contributing references was changed.
	 * False otherwise.
	 */
	public boolean removeReferences(Set<IXReference<?,?>> refs) {
		return contributingRefs.removeAll(refs);
	}
	
	/**
	 * Returns the state of the connector.
	 * The state of a reflexive connector is always STATE.REFLEXIVE.
	 * The state of an envisaged connector is STATE.CONVERGENCE unless
	 * there are no contributing references, in which case its state is
	 * STATE.ABSENCE.
	 * The state of a non-envisaged connector is STATE.DIVERGENCE unless
	 * there are no contributing references, in which case its state is
	 * STATE.INCONSISTENT (something is broken then).
	 * 
	 * @return the connector's state according to the description above.
	 */
	public Connector.STATE getState() {
		if (isReflexive()) return STATE.REFLEXIVE;
		if (isEnvisaged()) {
			return contributingRefs.size() > 0 ? STATE.CONVERGENCE : STATE.ABSENCE;
		}
		else {
			return contributingRefs.size() > 0 ? STATE.DIVERGENCE : STATE.INCONSISTENT;
		}
	}
	
	public void detachFromModel() {
		am = null;
	}
	
	@Override
	public int hashCode() {
		final int prime = 73;
		int result = 1;
		result = prime * result + ((src == null) ? 0 : src.hashCode());
		result = prime * result + ((trg == null) ? 0 : trg.hashCode());
		return result;
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		Connector other = (Connector) obj;
		if (src == null) {
			if (other.src != null)
				return false;
		} else if (!src.equals(other.src))
			return false;
		if (trg == null) {
			if (other.trg != null)
				return false;
		} else if (!trg.equals(other.trg))
			return false;
		return true;
	}
	
	
}
"
AbstractArchitectureModelChangeListener.java,architecture-model,"package se.kau.cs.jittac.model.am.events;

public abstract class AbstractArchitectureModelChangeListener implements IArchitectureModelChangeListener {

	@Override
	public void onComponentAdded(ComponentAdditionEvent event) {
	}

	@Override
	public void onComponentRemoved(ComponentRemovalEvent event) {
	}

	@Override
	public void onConnectorStateChange(ConnectorStateChangeEvent event) {
	}
	
	@Override
	public void onConnectorAdded(ConnectorAdditionEvent event) {
	}

	@Override
	public void onConnectorRemoved(ConnectorRemovalEvent event) {
	}


	@Override
	public void onConnectorReferencesAdded(ConnectorReferencesAddedEvent event) {
	}

	@Override
	public void onConnectorReferencesRemoved(ConnectorReferencesRemovedEvent event) {
	}

	@Override
	public void onComponentNameChanged(ComponentNameChangeEvent event) {
		
	}

	@Override
	public void handleEvent(ArchitectureModelChangeEvent event) {
		if (event instanceof ComponentAdditionEvent) {
			this.onComponentAdded((ComponentAdditionEvent) event);
		}
		else if (event instanceof ComponentRemovalEvent) {
			this.onComponentRemoved((ComponentRemovalEvent) event);
		}
		else if (event instanceof ConnectorAdditionEvent) {
			this.onConnectorAdded((ConnectorAdditionEvent) event);
		}
		else if (event instanceof ComponentNameChangeEvent) {
			this.onComponentNameChanged((ComponentNameChangeEvent) event);
		}
		else if (event instanceof ConnectorStateChangeEvent) {
			this.onConnectorStateChange((ConnectorStateChangeEvent) event);
		}
		else if (event instanceof ConnectorRemovalEvent) {
			this.onConnectorRemoved((ConnectorRemovalEvent) event);
		}
		else if (event instanceof ConnectorReferencesAddedEvent) {
			this.onConnectorReferencesAdded((ConnectorReferencesAddedEvent) event);
		}
		else if (event instanceof ConnectorReferencesRemovedEvent) {
			this.onConnectorReferencesRemoved((ConnectorReferencesRemovedEvent) event);
		}
	}

	
}
"
ArchitectureModelChangeEvent.java,architecture-model,"package se.kau.cs.jittac.model.am.events;

import se.kau.cs.jittac.model.am.ArchitectureModel;

public interface ArchitectureModelChangeEvent {

	ArchitectureModel getModel();
}
"
ComponentAdditionEvent.java,architecture-model,"package se.kau.cs.jittac.model.am.events;

import se.kau.cs.jittac.model.am.ArchitectureModel;
import se.kau.cs.jittac.model.am.Component;

public class ComponentAdditionEvent implements ArchitectureModelChangeEvent {

	private ArchitectureModel am;
	private Component comp;
	
	public ComponentAdditionEvent(Component comp, ArchitectureModel am) {
		this.comp = comp;
		this.am = am;
	}
	
	public Component getAddedComponent() {
		return comp;
	}
	
	public ArchitectureModel getModel() {
		return am;
	}
}
"
ComponentNameChangeEvent.java,architecture-model,"package se.kau.cs.jittac.model.am.events;

import se.kau.cs.jittac.model.am.ArchitectureModel;
import se.kau.cs.jittac.model.am.Component;

public class ComponentNameChangeEvent implements ArchitectureModelChangeEvent {

	private ArchitectureModel am;
	private Component comp;
	private String oldName, newName;
	
	public ComponentNameChangeEvent(Component comp, ArchitectureModel am, String oldname, String newName) {
		this.comp = comp;
		this.am = am;
		this.oldName = oldname;
		this.newName = newName;
	}
	
	@Override
	public ArchitectureModel getModel() {
		return am;
	}
	
	public Component getComponent() {
		return comp;
	}
	
	public String getOldName() {
		return oldName;
	}

	public String getNewName() {
		return newName;
	}
}
"
ComponentRemovalEvent.java,architecture-model,"package se.kau.cs.jittac.model.am.events;

import se.kau.cs.jittac.model.am.ArchitectureModel;
import se.kau.cs.jittac.model.am.Component;

public class ComponentRemovalEvent implements ArchitectureModelChangeEvent {

	private ArchitectureModel am;
	private Component comp;
	
	public ComponentRemovalEvent(Component comp, ArchitectureModel am) {
		this.comp = comp;
		this.am = am;
	}
	
	public Component getRemovedComponent() {
		return comp;
	}
	
	public ArchitectureModel getModel() {
		return am;
	}
	

}
"
ConnectorAdditionEvent.java,architecture-model,"package se.kau.cs.jittac.model.am.events;

import se.kau.cs.jittac.model.am.ArchitectureModel;
import se.kau.cs.jittac.model.am.Connector;

public class ConnectorAdditionEvent implements ArchitectureModelChangeEvent {

	private ArchitectureModel am;
	private Connector conn;
	
	public ConnectorAdditionEvent(Connector conn, ArchitectureModel am) {
		this.conn = conn;
		this.am = am;
	}
	
	public Connector getAddedConnector() {
		return conn;
	}
	
	public ArchitectureModel getModel() {
		return am;
	}
	

}
"
ConnectorReferencesAddedEvent.java,architecture-model,"package se.kau.cs.jittac.model.am.events;

import java.util.HashSet;
import java.util.Set;

import se.kau.cs.jittac.model.am.ArchitectureModel;
import se.kau.cs.jittac.model.am.Connector;
import se.kau.cs.jittac.model.im.IXReference;

public class ConnectorReferencesAddedEvent implements ArchitectureModelChangeEvent {

	private ArchitectureModel am;
	private Connector conn;
	private Set<IXReference<?,?>> addedRefs;
	
	public ConnectorReferencesAddedEvent(Connector conn, Set<IXReference<?,?>> addedRefs, ArchitectureModel am) {
		this.conn = conn;
		this.am = am;
		this.addedRefs = new HashSet<IXReference<?,?>>(addedRefs);
	}
	
	public Connector getModifiedConnector() {
		return conn;
	}
	
	public ArchitectureModel getModel() {
		return am;
	}
	
	public Set<IXReference<?,?>> getAddedReferences() {
		return new HashSet<IXReference<?,?>>(this.addedRefs);
	}
}
"
ConnectorReferencesRemovedEvent.java,architecture-model,"package se.kau.cs.jittac.model.am.events;

import java.util.HashSet;
import java.util.Set;

import se.kau.cs.jittac.model.am.ArchitectureModel;
import se.kau.cs.jittac.model.am.Connector;
import se.kau.cs.jittac.model.im.IXReference;

public class ConnectorReferencesRemovedEvent implements ArchitectureModelChangeEvent {

	private ArchitectureModel am;
	private Connector conn;
	private Set<IXReference<?,?>> removedRefs;
	
	public ConnectorReferencesRemovedEvent(Connector conn, Set<IXReference<?,?>> removedRefs, ArchitectureModel am) {
		this.conn = conn;
		this.am = am;
		this.removedRefs = new HashSet<IXReference<?,?>>(removedRefs);
	}
	
	public Connector getModifiedConnector() {
		return conn;
	}
	
	public ArchitectureModel getModel() {
		return am;
	}
	
	public Set<IXReference<?,?>> getRemovedReferences() {
		return new HashSet<IXReference<?,?>>(removedRefs);
	}

}
"
ConnectorRemovalEvent.java,architecture-model,"package se.kau.cs.jittac.model.am.events;

import se.kau.cs.jittac.model.am.ArchitectureModel;
import se.kau.cs.jittac.model.am.Connector;

public class ConnectorRemovalEvent implements ArchitectureModelChangeEvent {

	private ArchitectureModel am;
	private Connector conn;
	
	public ConnectorRemovalEvent(Connector conn, ArchitectureModel am) {
		this.conn = conn;
		this.am = am;
	}
	
	public Connector getRemovedConnector() {
		return conn;
	}
	
	public ArchitectureModel getModel() {
		return am;
	}
	

}
"
ConnectorStateChangeEvent.java,architecture-model,"package se.kau.cs.jittac.model.am.events;

import se.kau.cs.jittac.model.am.ArchitectureModel;
import se.kau.cs.jittac.model.am.Connector;

public class ConnectorStateChangeEvent implements ArchitectureModelChangeEvent {

	private ArchitectureModel am;
	private Connector conn;
	private Connector.STATE oldState, newState;
	
	public ConnectorStateChangeEvent(Connector conn, Connector.STATE oldState,
			Connector.STATE newState, ArchitectureModel am) {
		this.conn = conn;
		this.oldState = oldState;
		this.newState = newState;
		this.am = am;
	}
		
	public Connector getConnector() {
		return conn;
	}

	public Connector.STATE getOldState() {
		return oldState;
	}

	public Connector.STATE getNewState() {
		return newState;
	}

	@Override
	public ArchitectureModel getModel() {
		return am;
	}

}
"
IArchitectureModelChangeListener.java,architecture-model,"package se.kau.cs.jittac.model.am.events;

/**
 * This interface defines handlers for dealing with events raised by changes in architecture models,
 * such as adding or removing components.
 * 
 * Implementations should extend AbstractArchitectureModelChangeListener and override the corresponding
 * handlers (onXXX). They are hooked into handleEvent(...) which will be invoked automatically by any
 * architecture model that the listener is registered, in case an event occurs.   
 * 
 * @author Sebastian Herold
 *
 */
public interface IArchitectureModelChangeListener {
	
	public void onComponentAdded(ComponentAdditionEvent event);
	public void onComponentRemoved(ComponentRemovalEvent event);
	public void onConnectorAdded(ConnectorAdditionEvent event);
	public void onConnectorStateChange(ConnectorStateChangeEvent event);
	public void onConnectorRemoved(ConnectorRemovalEvent event);
	public void onConnectorReferencesAdded(ConnectorReferencesAddedEvent event);
	public void onConnectorReferencesRemoved(ConnectorReferencesRemovedEvent event);
	public void onComponentNameChanged(ComponentNameChangeEvent event);
	
	public void handleEvent(ArchitectureModelChangeEvent event);
}
"
IArchitectureModelVisitor.java,architecture-model,"package se.kau.cs.jittac.model.am.events;

import se.kau.cs.jittac.model.am.ArchitectureModel;

public interface IArchitectureModelVisitor {
	
	public void visit(ArchitectureModel model);

}
"
IArchitectureElement.java,architecture-model,"package se.kau.cs.jittac.model.am;

import java.util.UUID;

/**
 * Interface representing commonalities of architecture model elements.
 * @author Sebastian Herold
 *
 */
public interface IArchitectureElement {
	
	/**
	 * Returns the model containing the model element or, in case the element is a model, the model itself.
	 * @return see above.
	 */
	public ArchitectureModel getModel();
	
	/**
	 * Returns the identifier of the element
	 * @return see above.
	 */
	public UUID getId();
	
	/**
	 * Returns the human-readable name for the element
	 * @return The element's name as string.
	 */
	public String getName();
	
}
"
ArchitectureModelReader.java,architecture-model,"package se.kau.cs.jittac.model.am.io;

import java.io.IOException;
import java.io.InputStream;
import java.nio.file.Path;
import java.util.UUID;

import org.xml.sax.Attributes;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;
import org.xml.sax.XMLReader;
import org.xml.sax.helpers.DefaultHandler;
import org.xml.sax.helpers.XMLReaderFactory;

import se.kau.cs.jittac.model.am.ArchitectureModel;
import se.kau.cs.jittac.model.am.Component;
import se.kau.cs.jittac.model.am.Connector;
import se.kau.cs.jittac.model.mapping.IJittacProject;
import se.kau.cs.jittac.model.mapping.IJittacResource;
import se.kau.cs.jittac.model.mapping.IJittacResourceFactory;
import se.kau.cs.jittac.model.mapping.JittacResourceModelRegistry;


/**
 * Class for reading in a serialized architecture model (serialized as XML).
 * @author Sebastian Herold
 *
 */
public class ArchitectureModelReader {

	static class ArchitectureModelHandler extends DefaultHandler {
		private ArchitectureModel model = null;
		IJittacResourceFactory resourceFactory = null;
		
		public ArchitectureModelHandler() {
		}		
		
		public ArchitectureModelHandler(Path file) {
		}
		
		public ArchitectureModel getModel() {
			return model;
		}

		public void startElement(String uri, String name,
			      				 String qname, Attributes atts)
		throws SAXException {
			
			try {
				if (name.equals(""model"")) {
					model = ArchitectureModel.createArchitectureModel();
				}
				else if (name.equals(""mapping"")) {
					String resourceModelName = atts.getValue(""resourceModel"");
					resourceFactory =
							JittacResourceModelRegistry.INSTANCE.getResourceModelFor(resourceModelName);
					if (resourceFactory == null) {
						throw new IllegalArgumentException(""Unknown resource model."");
					}
					
				} else if (name.equals(""component"")) {
					String id = atts.getValue(""id"");
					if (id == null)
						throw new IllegalArgumentException();
					
					model.createComponent(atts.getValue(""name""), UUID.fromString(id));

				} else if (name.equals(""connector"")) {
					Component source = model.getComponentById(UUID.fromString(atts.getValue(""source"")));
					Component target = model.getComponentById(UUID.fromString(atts.getValue(""target"")));
					if (source == null || target == null)
						throw new IllegalArgumentException();
					Connector con = model.createConnector(source, target);
					con.setEnvisaged(true);
				} else if (name.equals(""map"")) {
					if (resourceFactory == null) 
						throw new NullPointerException(""Mapping cannot be resolved."");
					String target = atts.getValue(""target"");
					String handle = atts.getValue(""handle"");
					String projectHandle = atts.getValue(""projectHandle"");
					if (target == null || handle == null || projectHandle == null)
						throw new NullPointerException(""Mapping cannot be resolved."");
	
					Component comp = model.getComponentById(UUID.fromString(target));
					IJittacProject jProject = resourceFactory.createJittacProjectFromPersistentHandle(projectHandle);
					IJittacResource jResource = resourceFactory.createJittacResourceFromPersistentHandle(handle, jProject);
					
					if (jResource != null && comp != null && jProject != null) {
						model.getMapping().addMapping(comp, jResource);
					}
					else {
						throw new NullPointerException(""Mapping cannot be resolved."");
					}
				} else if (name.equals(""email"")) {
					//String url = atts.getValue(""url"");
					//TODO: add this functionality
					//model.setEmail(url);
				} else if (name.equals(""project"")) {
					String handle = atts.getValue(""handle"");
//					IJittacProject proj = resourceFactory.createJittacProjectFromPersistentHandle(handle);
//					model.manageProject(proj);
				}
		
			} catch (IllegalArgumentException ex) {
				// TODO: Report errors in the file!
				ex.printStackTrace();
			}
		}
	}

	public static ArchitectureModel read(Path file) {
		ArchitectureModelHandler handler = new ArchitectureModelHandler(file);
		// Parse the XML file containing the model.
		try {
			XMLReader parser = XMLReaderFactory.createXMLReader();
			parser.setContentHandler(handler);
			parser.parse(file.toUri().toString());
		} catch (SAXException ex) {
			ex.printStackTrace();
		} catch (IOException ex) {
			ex.printStackTrace();
		} // TODO: Handle the errors properly!
	
		finalizeModel(handler.getModel());
		return handler.getModel();
	}
	
	public static ArchitectureModel read(InputStream input) {
		ArchitectureModelHandler handler = new ArchitectureModelHandler();
		// Parse the XML file containing the model.
		try {
			XMLReader parser = XMLReaderFactory.createXMLReader();
			parser.setContentHandler(handler);
			parser.parse(new InputSource(input));
		} catch (SAXException ex) {
			ex.printStackTrace();
		} catch (IOException ex) {
			ex.printStackTrace();
		} // TODO: Handle the errors properly!
	
		finalizeModel(handler.getModel());
		return handler.getModel();
	}	
	
	private static void finalizeModel(ArchitectureModel model) {
		
		for (IJittacProject relevantProject : model.getMapping().getManagedProjects()) {
			relevantProject.getImplementationModel().registerImplementationChangeListener(model);
			//Semi-hack: if model depends on an implementation model im that has already been loaded
			//before m was registered as a listener of im, the following line causes model to update anyway.
			model.onCompleteLoad(relevantProject.getImplementationModel());
		}
	}
}
"
ArchitectureModelWriter.java,architecture-model,"package se.kau.cs.jittac.model.am.io;

import java.io.OutputStream;
import java.util.Iterator;
import java.util.Set;

import javax.xml.stream.XMLOutputFactory;
import javax.xml.stream.XMLStreamException;
import javax.xml.stream.XMLStreamWriter;

import se.kau.cs.jittac.model.mapping.ArchitectureMapping;
import se.kau.cs.jittac.model.mapping.IJittacProject;
import se.kau.cs.jittac.model.mapping.IMappableElement;
import se.kau.cs.jittac.model.am.ArchitectureModel;
import se.kau.cs.jittac.model.am.Component;
import se.kau.cs.jittac.model.am.Connector;

/**
 * Class for serializing an architecture model in XML format.
 * @author Sebastian Herold
 *
 */

public class ArchitectureModelWriter {
	private static final String EOL = System.getProperty(""line.separator"");
    
	
	protected static void writeIndentation(XMLStreamWriter writer, int level)
		throws XMLStreamException {
		String indent = """";
		for (int i=0; i < level; ++i)
			indent += ""    "";
		writer.writeCharacters(indent);
	}
	
	
    protected static void writeComponents(XMLStreamWriter writer, ArchitectureModel model, int level)
        throws XMLStreamException {

    	// Write all the components.
        writer.writeCharacters(EOL);
        writeIndentation(writer, level++);
        writer.writeStartElement(""components"");
        writer.writeCharacters(EOL);

        Iterator<Component> iter = model.getComponents().iterator();
        while (iter.hasNext()) {
            Component component = iter.next();
            
            writeIndentation(writer, level);
            writer.writeEmptyElement(""component"");
            writer.writeAttribute(""id"", component.getId().toString());
            writer.writeAttribute(""name"", component.getName());
            writer.writeCharacters(EOL);
        }
        writeIndentation(writer, --level);
        writer.writeEndElement();
        writer.writeCharacters(EOL);
    }
    
    protected static void writeConnectors(XMLStreamWriter writer, ArchitectureModel model, int level)
        throws XMLStreamException {
        // Write all the connectors.
        writer.writeCharacters(EOL);
        writeIndentation(writer, level++);
        writer.writeStartElement(""connectors"");
        writer.writeCharacters(EOL);

        Iterator<Connector> iter = model.getConnectors().iterator();
        while (iter.hasNext()) {
            Connector connector = iter.next();
            if (!connector.isEnvisaged() || connector.isReflexive())
                continue;
            
            // Write the connector.
            writeIndentation(writer, level);
            writer.writeEmptyElement(""connector"");
            writer.writeAttribute(""source"", connector.getSrc().getId().toString());
            writer.writeAttribute(""target"", connector.getTrg().getId().toString());
            writer.writeCharacters(EOL);
        }
        writeIndentation(writer, --level);
        writer.writeEndElement();
        writer.writeCharacters(EOL);
    }
    
    protected static void writeMappings(XMLStreamWriter writer, ArchitectureModel model, int level)
        throws XMLStreamException {
        
    	ArchitectureMapping mapping = model.getMapping();
        
        writer.writeCharacters(EOL);
        writeIndentation(writer, level++);
        writer.writeStartElement(""mapping"");
        writer.writeAttribute(""resourceModel"", mapping.getResourceFactory().getResourceModelName());
        writer.writeCharacters(EOL);


        Set<Component> components = model.getComponents();
        for (Component comp : components) {
           Set<IMappableElement> resources = mapping.getMappedResources(comp);
           
           for (IMappableElement resource : resources) {
               writeIndentation(writer, level);
               writer.writeEmptyElement(""map"");
               writer.writeAttribute(""target"", comp.getId().toString());
               writer.writeAttribute(""handle"", resource.getPersistentHandle());
               writer.writeAttribute(""projectHandle"", resource.getProject().getPersistentHandle());
               writer.writeCharacters(EOL);
           }
        }
        writeIndentation(writer, --level);
        writer.writeEndElement();
        writer.writeCharacters(EOL);
    }

    protected static void writeManagedProjects(XMLStreamWriter writer, ArchitectureModel model, int level)
    	throws XMLStreamException {
    	
    	ArchitectureMapping mapping = model.getMapping();
        
        writer.writeCharacters(EOL);
        writeIndentation(writer, level++);
        writer.writeStartElement(""projects"");
        writer.writeAttribute(""resourceModel"", mapping.getResourceFactory().getResourceModelName());
        writer.writeCharacters(EOL);
        
        for (IJittacProject project : model.getManagedProjects()) {
        	writer.writeEmptyElement(""project"");
        	writer.writeAttribute(""handle"", project.getPersistentHandle());
        	writer.writeCharacters(EOL);
        }
        writeIndentation(writer, --level);
        writer.writeEndElement();
        writer.writeCharacters(EOL);
    }
    
    public static void write(OutputStream stream, ArchitectureModel model){
        try {
            XMLStreamWriter writer = XMLOutputFactory.newInstance().createXMLStreamWriter(stream);
            int level = 0;

            // Write header and open the root component.
            writer.writeStartDocument();
            
            writer.writeCharacters(EOL);
            writer.writeStartElement(""model"");
            //writer.writeCharacters(EOL);
            
            // Write all file contents.
            level++;
            writeComponents(writer, model, level);
            writeConnectors(writer, model, level);
            //writeManagedProjects(writer, model, level);
            writeMappings(writer, model, level);
            writeEmail(writer, model, level);
            level--;
            
            // Finish the document.
            writer.writeEndElement();
            //writer.writeCharacters(EOL);
            writer.writeEndDocument();
            
            writer.flush();
            writer.close();
        } catch (XMLStreamException e) {
            e.printStackTrace();
        }
    }
    /**
	 * @since 0.2
	 */
    protected static void writeEmail(XMLStreamWriter writer, ArchitectureModel model, int level)
            throws XMLStreamException {

        	// Write all the components.
            writer.writeCharacters(EOL);
            writeIndentation(writer, level++);
            writer.writeEmptyElement(""email"");
            writer.writeAttribute(""url"", ""joe@somewhere.se"");
            writeIndentation(writer, --level);
            writer.writeCharacters(EOL);
        }
}
"
ProblemMarker.java,eclipse-code-support,"package se.kau.cs.jittac.eclipse.codesupport;

import org.eclipse.core.internal.resources.Marker;
import org.eclipse.core.resources.IMarker;
import org.eclipse.core.resources.IResource;
import org.eclipse.core.runtime.CoreException;

import se.kau.cs.jittac.eclipse.builders.jdt.JDTJavaReference;
import se.kau.cs.jittac.eclipse.builders.jdt.JDTJavaReferenceCodeInformation;
import se.kau.cs.jittac.model.am.Connector;
import se.kau.cs.jittac.model.am.events.AbstractArchitectureModelChangeListener;
import se.kau.cs.jittac.model.am.events.ConnectorReferencesAddedEvent;
import se.kau.cs.jittac.model.am.events.ConnectorReferencesRemovedEvent;
import se.kau.cs.jittac.model.im.IXReference;
import se.kau.cs.jittac.model.mapping.IJittacResource;
import se.kau.cs.jittac.model.mapping.eclipse.EclipseJittacResource;
import se.kau.cs.jittac.model.mapping.eclipse.EclipseJittacResourceFactory;

public class ProblemMarker extends AbstractArchitectureModelChangeListener {
		
	public static final String MARKER_TYPE = ""se.kau.cs.jittac.eclipse.codesupport.ProblemMarker"";
	public static final int SEVERITY = Marker.SEVERITY_WARNING;
	public static final String CONNECTOR_ID_ATTRIBUTE = ""CONNECTOR_ID"";
	
	public static final ProblemMarker instance = new ProblemMarker();
	
	public static ProblemMarker getInstance() {
		return instance;
	}

	public void onConnectorReferencesAdded(ConnectorReferencesAddedEvent event) {
		
		Connector conn = event.getModifiedConnector(); 
		if (conn.isEnvisaged()) return;
		try {
			for(IXReference<?,?> ref : event.getAddedReferences()) {
				IJittacResource jResource = ref.getResource();
				if (jResource.getResourceModelName()
						.equals(EclipseJittacResourceFactory.RESOURCE_MODEL_NAME)) {
					IResource resource = ((EclipseJittacResource) jResource).getWrappedResource();
					if (ref instanceof JDTJavaReference) {
						JDTJavaReferenceCodeInformation refInf =
							((JDTJavaReference) ref).getInternalReference();
						IMarker marker = resource.createMarker(MARKER_TYPE);
						marker.setAttribute(IMarker.SEVERITY, SEVERITY);
						marker.setAttribute(IMarker.MESSAGE, 
								ref.getTarget() + "" should not be accessed in this context "" +
								"" ("" + event.getModifiedConnector().getName() + "")"");
						marker.setAttribute(IMarker.CHAR_START, refInf.offset);
						marker.setAttribute(IMarker.CHAR_END, refInf.offset + refInf.length);
						marker.setAttribute(IMarker.LINE_NUMBER, refInf.line);
						marker.setAttribute(CONNECTOR_ID_ATTRIBUTE, event.getModifiedConnector().getName());

					}
				}
			}
		} catch (CoreException e) {
			e.printStackTrace();
		}
	}
	
	public void onConnectorReferencesRemoved(ConnectorReferencesRemovedEvent event) {
		
	}
}
"
Activator.java,eclipse-main,"package se.kau.cs.jittac.eclipse;

import static org.eclipse.jdt.core.JavaCore.isJavaLikeFileName;

import java.net.URL;
import java.util.HashMap;
import java.util.Map;

import org.eclipse.core.resources.IProject;
import org.eclipse.core.resources.IResource;
import org.eclipse.ui.plugin.AbstractUIPlugin;
import org.osgi.framework.BundleContext;

import com.google.common.base.Predicate;

import se.kau.cs.jittac.eclipse.builders.jdt.JDTImplementationModelFactory;
import se.kau.cs.jittac.model.im.ImplementationModelFactoryRegistry;
import se.kau.cs.jittac.model.mapping.JittacResourceModelRegistry;
import se.kau.cs.jittac.model.mapping.eclipse.EclipseJittacResourceFactory;

/**
 * The activator class controls the plug-in life cycle
 */
public class Activator extends AbstractUIPlugin {

	// The plug-in ID
	public static final String PLUGIN_ID = ""se.kau.cs.jittac.eclipse""; //$NON-NLS-1$

	// The shared instance
	private static Activator plugin;
	
	/**
	 * The constructor
	 */
	public Activator() {
	}

	/*
	 * (non-Javadoc)
	 * @see org.eclipse.ui.plugin.AbstractUIPlugin#start(org.osgi.framework.BundleContext)
	 */
	public void start(BundleContext context) throws Exception {
		super.start(context);
		plugin = this;
		JittacResourceModelRegistry.INSTANCE.registerResourceModel(EclipseJittacResourceFactory.INSTANCE);
		JittacResourceModelRegistry.INSTANCE.setDefaultResourceModel(EclipseJittacResourceFactory.INSTANCE);
		
		ImplementationModelFactoryRegistry.instance().register(JDTImplementationModelFactory.INSTANCE);
		URL url = getBundle().getEntry(""temp"");
		//System.out.println(""Activator URL: "" + url);
	}

	/*
	 * (non-Javadoc)
	 * @see org.eclipse.ui.plugin.AbstractUIPlugin#stop(org.osgi.framework.BundleContext)
	 */
	public void stop(BundleContext context) throws Exception {
		plugin = null;
		super.stop(context);
	}

	/**
	 * Returns the shared instance
	 *
	 * @return the shared instance
	 */
	public static Activator getDefault() {
		return plugin;
	}

    /**
     * Return a predicate which returns true when the given resource is supported by this plug-in,
     * that is when the resource represents a java compilation unit.
     * 
     * @return the predicate
     */
    public static Predicate<IResource> supportedResource() {
        return new Predicate<IResource>() {
            @Override
            public boolean apply(IResource resource) {
                return isJavaLikeFileName(resource.getName());
            }
        };
    }
}
"
DummyProgressMonitor.java,eclipse-main,"package se.kau.cs.jittac.eclipse.util;
import org.eclipse.core.runtime.IProgressMonitor;

/**
 * 
 * @author Jacek Rosik
 *
 */
public class DummyProgressMonitor implements IProgressMonitor {
    private IProgressMonitor monitor;
    
    public DummyProgressMonitor() {
    }

    public DummyProgressMonitor(IProgressMonitor monitor) {
        this.monitor = monitor;
    }
 
    @Override
    public void beginTask(String name, int totalWork) {
 
    }

    @Override
    public void done() {
    }

    @Override
    public void internalWorked(double work) {
    }

    @Override
    public boolean isCanceled() {
        return monitor != null ? monitor.isCanceled() : false;
    }

    @Override
    public void setCanceled(boolean value) {
        if (monitor != null) {
            monitor.setCanceled(value);
        }
    }

    @Override
    public void setTaskName(String name) {
    }

    @Override
    public void subTask(String name) {
    }

    @Override
    public void worked(int work) {
    }
}
"
FeatureLocationCSV.java,eclipse-main,"package se.kau.cs.jittac.eclipse.util;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;

import org.eclipse.core.resources.IProject;
import org.eclipse.core.resources.IResource;
import org.eclipse.core.resources.ResourcesPlugin;

import se.kau.cs.jittac.model.feature.Feature;
import se.kau.cs.jittac.model.feature.FeatureLocation;
import se.kau.cs.jittac.model.feature.FeatureLocationRegistry;
import se.kau.cs.jittac.model.mapping.IJittacProject;
import se.kau.cs.jittac.model.mapping.IJittacResource;
import se.kau.cs.jittac.model.mapping.eclipse.EclipseJittacProject;

public class FeatureLocationCSV
{
	public static void load( File csvPath )
	{
        try
        {
        	// TODO use more robust CSV reader e.g. OpenCSV (http://opencsv.sourceforge.net/)
        	BufferedReader bufferedReader = new BufferedReader( new FileReader( csvPath ) );	            
            String line = null;
            String cvsSplitBy = "","";
            
            FeatureLocationRegistry.INSTANCE.clearAll();
            
            while( ( line = bufferedReader.readLine() ) != null )
            {
            	String[] featLoc = line.split( cvsSplitBy );
        	    String sourcePath = featLoc[0];
        	    String featureName = featLoc[1];
        	    int startOffSet = Integer.parseInt( featLoc[2] );
        	    int length = Integer.parseInt( featLoc[3] );
        	    Feature feature = Feature.getFeature( featureName );
        	    
        	    String projectName = sourcePath.split( ""/"" )[1];
        	    IProject eProject = ResourcesPlugin.getWorkspace().getRoot().getProject( projectName );
        	    IJittacProject jProject = EclipseJittacProject.get( ( IProject ) eProject );
        	    IProject ejProject = ( ( EclipseJittacProject ) jProject ).getWrappedProject();
        	    
        	    IResource resource = ResourcesPlugin.getWorkspace().getRoot().findMember( sourcePath );

				if( ejProject.equals( resource.getProject() ) )
				{ 
					IJittacResource jResource = ( ( EclipseJittacProject ) jProject ).getResource( resource );
					FeatureLocationRegistry.INSTANCE.registerFeatureLocation( new FeatureLocation( feature, jResource, startOffSet, length ) );
				}
            }   
            
            bufferedReader.close();
        }
        catch( FileNotFoundException ex )
        {
            System.out.println( ""Unable to open file '"" + csvPath + ""'"" );                
        }
        catch( IOException ex )
        {
        	ex.printStackTrace(); 
        }
	}
}
"
JittacJavaNature.java,eclipse-main,"package se.kau.cs.jittac.eclipse;

import static java.lang.System.arraycopy;

import org.eclipse.core.resources.ICommand;
import org.eclipse.core.resources.IProject;
import org.eclipse.core.resources.IProjectDescription;
import org.eclipse.core.resources.IProjectNature;
import org.eclipse.core.runtime.CoreException;

import se.kau.cs.jittac.eclipse.builders.jdt.JavaImplementationModelBuilder;

public class JittacJavaNature implements IProjectNature {
    /** Unique ID of this project nature.  */
    public static final String NATURE_ID = ""se.kau.cs.jittac.eclipse.natures.java"";
    private IProject project;

    /**
     * Adds the {@link JavaImplementationModelBuilder} to the build specification of the project.
     */
    @Override
    public void configure() throws CoreException {
        IProjectDescription desc = project.getDescription();
        ICommand[] commands = desc.getBuildSpec();

        // Do nothing If the builder is already included in the build specification!
        for (int i = 0; i < commands.length; ++i) {
            if (JavaImplementationModelBuilder.ID.equals(commands[i].getBuilderName())) {
                return;
            }
        }

        // Create new build specification with the new builder.
        ICommand[] newCommands = new ICommand[commands.length + 1];
        arraycopy(commands, 0, newCommands, 0, commands.length);
        ICommand command = desc.newCommand();
        command.setBuilderName(JavaImplementationModelBuilder.ID);
        newCommands[newCommands.length - 1] = command;

        desc.setBuildSpec(newCommands);
        project.setDescription(desc, null);
    }

    /**
     * Removes the {@link JavaImplementationModelBuilder} to the build specification of the project.
     */
    @Override
    public void deconfigure() throws CoreException {
        IProjectDescription description = getProject().getDescription();
        ICommand[] commands = description.getBuildSpec();

        // Remove the Java IM builder from the build spec 
        // (assumes that only one such builder can be present in the build spec).
        for (int i = 0; i < commands.length; ++i) {
            if (JavaImplementationModelBuilder.ID.equals(commands[i].getBuilderName())) {
                ICommand[] newCommands = new ICommand[commands.length - 1];
                arraycopy(commands, 0, newCommands, 0, i);
                arraycopy(commands, i + 1, newCommands, i, commands.length - i - 1);
                
                description.setBuildSpec(newCommands);
                project.setDescription(description, null);
                break;
            }
        }
    }

    @Override
    public IProject getProject() {
        return project;
    }

    @Override
    public void setProject(IProject project) {
        this.project = project;
    }
}
"
ModelManager.java,eclipse-main,"package se.kau.cs.jittac.eclipse;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FilenameFilter;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

import org.apache.commons.collections4.BidiMap;
import org.apache.commons.collections4.bidimap.DualHashBidiMap;
import org.apache.commons.collections4.map.HashedMap;
import org.eclipse.core.resources.IFile;
import org.eclipse.core.resources.IProject;
import org.eclipse.core.runtime.CoreException;
import org.eclipse.core.runtime.IPath;

import se.kau.cs.jittac.eclipse.codesupport.ProblemMarker;
import se.kau.cs.jittac.model.am.ArchitectureModel;
import se.kau.cs.jittac.model.am.io.ArchitectureModelReader;
import se.kau.cs.jittac.model.im.IImplementationModel;
import se.kau.cs.jittac.model.im.ImplementationModelPartition;
import se.kau.cs.jittac.model.im.events.AbstractBuildEventListener;
import se.kau.cs.jittac.model.im.events.BuildEndEvent;
import se.kau.cs.jittac.model.im.io.ImplementationModelReader;
import se.kau.cs.jittac.model.im.io.ImplementationModelWriter;
import se.kau.cs.jittac.model.mapping.IJittacProject;
import se.kau.cs.jittac.model.mapping.eclipse.EclipseJittacProject;

public class ModelManager {
	
	private static ModelManager instance = new ModelManager();
	private static final String IMPLEMENTATION_FILE_NAME_PREFIX = ""jittac-im-"";
	private static final String IMPLEMENTATION_FILE_NAME_SUFFIX = "".sav"";
	
	
	private BidiMap<IFile, ArchitectureModel> modelsByFile;
	private ModelManagerBuildEventListener buildEventListener;
	private Set<IImplementationModel> loadedImplementationModels;
	
	private class ModelManagerBuildEventListener extends AbstractBuildEventListener {
		
		@Override
		public void onBuildEnd(BuildEndEvent event) {
			Runnable  r = 
				() -> {
					try (OutputStream out = createOutputStream(event.getPartition())) {
						if (out != null) {
							ImplementationModelWriter.writePartition(out, event.getPartition());
							out.flush();
						}
					} catch (IOException e) {
						e.printStackTrace();
					}
				};
			new Thread(r).start();
		}
	}
	
	private ModelManager() {
		modelsByFile = new DualHashBidiMap<>();
		buildEventListener = new ModelManagerBuildEventListener();
		loadedImplementationModels = new HashSet<>();
	}

	public static ModelManager instance() {
		return instance;
	}

	public ArchitectureModel getArchitectureModel(IFile file) {
		ArchitectureModel model = null;
		if (!file.exists()) {
			modelsByFile.remove(file);
		}
		else {
			model = modelsByFile.get(file);
			if (model == null) {
				try {
					model = ArchitectureModelReader.read(file.getContents());
					model.registerListener(ProblemMarker.getInstance());
					if (model != null) {
						modelsByFile.put(file, model);
						for (IJittacProject proj : model.getManagedProjects()) {
							IImplementationModel im = proj.getImplementationModel();
							im.registerBuildEventListener(buildEventListener);
							if (!loadedImplementationModels.contains(im)) {
								locateAndReadPartitionFiles(im);
								loadedImplementationModels.add(im);
							}
						}
					}
				} catch (CoreException e) {
					e.printStackTrace();
				} catch (FileNotFoundException e) {
					
				}
			}
		}
		return model;
	}
	
	public IFile getFile(ArchitectureModel model) {
		return modelsByFile.getKey(model);
	}

	private void locateAndReadPartitionFiles(IImplementationModel im) 
	throws FileNotFoundException {
		File[] partFiles = this.findPartitionFiles(im);
		for (File f : partFiles) {
			InputStream in = new FileInputStream(f);
			ImplementationModelReader.read(in, im);
		}
	}
	
	private File[] findPartitionFiles(IImplementationModel im) {
		IJittacProject jProject = im.getProject();
		if (jProject instanceof EclipseJittacProject) {
			IProject project = ((EclipseJittacProject) jProject).
					getWrappedProject();
			IPath path = project.getWorkingLocation(Activator.PLUGIN_ID);
			File dir = path.toFile();
			if (!(dir.isDirectory() && dir.canRead())) return null;
			File[] matchingFiles =
					dir.listFiles(new FilenameFilter() {
						@Override
						public boolean accept(File dir, String name) {
							return name.startsWith(IMPLEMENTATION_FILE_NAME_PREFIX) &&
									name.endsWith(IMPLEMENTATION_FILE_NAME_SUFFIX);
						}
					});
			return matchingFiles;
		}
		return null;
	}
	
	private OutputStream createOutputStream(ImplementationModelPartition part) {
		OutputStream out = null;
		IPath path = getPathToPartition(part);
        File file = path.toFile();
        if (file.exists()) {
        	file.delete();
        }
		try {
			file.createNewFile();
			if (file.canWrite()) {
				out = new FileOutputStream(file);
			}
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			//TODO
		}
		return out;
	}

	
	
	private IPath getPathToPartition(ImplementationModelPartition part) {
		IJittacProject jProject = part.getImplementationModel().getProject();
		if (jProject instanceof EclipseJittacProject) {
			IProject project = ((EclipseJittacProject) jProject).
					getWrappedProject();
	        IPath path = project.getWorkingLocation(Activator.PLUGIN_ID);
	        path = path.append(""/"" + 
	        		IMPLEMENTATION_FILE_NAME_PREFIX +
	        		part.getBuilderType().getName() +
	        		IMPLEMENTATION_FILE_NAME_SUFFIX);
	        return path;
		}
		return null;
	}
}
"
EclipseJittacProject.java,eclipse-resource-mapping,"package se.kau.cs.jittac.model.mapping.eclipse;

import java.util.HashSet;
import java.util.Map;
import java.util.Set;

import org.apache.commons.collections4.map.HashedMap;
import org.eclipse.core.resources.IContainer;
import org.eclipse.core.resources.IProject;
import org.eclipse.core.resources.IResource;
import org.eclipse.core.runtime.CoreException;

import se.kau.cs.jittac.model.am.ArchitectureModel;
import se.kau.cs.jittac.model.im.IImplementationModel;
import se.kau.cs.jittac.model.im.ImplementationModel;
import se.kau.cs.jittac.model.mapping.AbstractJittacProject;
import se.kau.cs.jittac.model.mapping.IJittacProject;
import se.kau.cs.jittac.model.mapping.IJittacResource;
import se.kau.cs.jittac.model.mapping.IMappableElement;

public class EclipseJittacProject extends AbstractJittacProject {

	private final IProject project;
	private final IImplementationModel im;
	private ArchitectureModel am;
	
	private Map<IResource, EclipseJittacResource> resourceMapping;
	
	//TODO: move instance creation to factory
	private static Map<IProject, EclipseJittacProject> createdInstances = new HashedMap<>();
	
	public static EclipseJittacProject get(IProject project) {
		
		EclipseJittacProject result = createdInstances.get(project);
		if (result == null) {
			result = new EclipseJittacProject(project);
			if (result != null) {
				createdInstances.put(project, result);
			}
		}
		return result;
	}

	private EclipseJittacProject(IProject project) {
		this.project = project;
		im = new ImplementationModel(this);
		resourceMapping = new HashedMap<IResource, EclipseJittacResource>();
	}
	
	@Override
	public IImplementationModel getImplementationModel() {
		return im;
	}

	public IProject getWrappedProject() {
		return project;
	}
	
	@Override
	public Set<IJittacResource> getChildren() {
		return getChildrenFor(this.project) ;
	}

	public EclipseJittacResource getResource(IResource resource) {
		if (resourceMapping.containsKey(resource)) {
			return resourceMapping.get(resource);
		}
		else {
			EclipseJittacResource newResource = EclipseJittacResource.create(resource, this);
			if (newResource != null) {
				resourceMapping.put(resource, newResource);
				return newResource;
			}
			else {
				return null;
			}
		}
	}

	public Set<IJittacResource> getChildrenFor(IResource resource) {
		Set<IJittacResource> result = new HashSet<>();
		if (resource != null && resource instanceof IContainer) {
			IContainer wrappedContainer = (IContainer) resource;
			EclipseJittacResource child;
			try {
				for (IResource wrappedChild : wrappedContainer.members()) {
					child = this.getResource(wrappedChild);
					if (child != null) {
						result.add(child);
					}
				}
			} catch (CoreException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
				return result;
			}
		}
		return result;
	}

	@Override
	public String getPersistentHandle() {
		return this.project.getFullPath().toPortableString();
	}

	@Override
	public ArchitectureModel getArchitectureModel() {
		return am;
	}

	public String toString() {
		return getWrappedProject().getName();
	}
	
	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + ((project == null) ? 0 : project.hashCode());
		return result;
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		EclipseJittacProject other = (EclipseJittacProject) obj;
		if (project == null) {
			if (other.project != null)
				return false;
		} else if (!project.equals(other.project))
			return false;
		return true;
	}

	@Override
	public String getResourceModelName() {
		return EclipseJittacResourceFactory.RESOURCE_MODEL_NAME;
	}
	
	
}
"
EclipseJittacResource.java,eclipse-resource-mapping,"package se.kau.cs.jittac.model.mapping.eclipse;

import java.util.Set;

import org.eclipse.core.resources.IResource;

import se.kau.cs.jittac.model.mapping.AbstractJittacResource;
import se.kau.cs.jittac.model.mapping.IJittacProject;
import se.kau.cs.jittac.model.mapping.IJittacResource;
import se.kau.cs.jittac.model.mapping.IMappableElement;

public class EclipseJittacResource extends AbstractJittacResource {

	private IResource resource;
	private EclipseJittacProject project;

	public static EclipseJittacResource create(IResource resource, EclipseJittacProject project) {
		return new EclipseJittacResource(resource, project);
	}
	
	private EclipseJittacResource(IResource resource, EclipseJittacProject project) {
		this.resource = resource;
		this.project = project;
	}
	
	@Override
	public IJittacProject getProject() {
		return project;
	}

	@Override
	public IMappableElement getParent() {
		IResource eParent = resource.getParent();
		if (eParent == null) {
			return null;
		}
		else {
			return project.getResource(eParent);
		}
	}

	@Override
	public Set<IJittacResource> getChildren() {
		return project.getChildrenFor(this.resource);
	}

	public IResource getWrappedResource() {
		return resource;
	}

	@Override
	public String getPersistentHandle() {
		return this.resource.getFullPath().toPortableString();
	}

	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + ((resource == null) ? 0 : resource.hashCode());
		return result;
	}

	public String toString() {
		return getWrappedResource().getName();
	}
	
	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		EclipseJittacResource other = (EclipseJittacResource) obj;
		if (resource == null) {
			if (other.resource != null)
				return false;
		} else if (!resource.equals(other.resource))
			return false;
		return true;
	}

	@Override
	public String getResourceModelName() {
		return EclipseJittacResourceFactory.RESOURCE_MODEL_NAME;
	}
	
	
}
"
EclipseJittacResourceFactory.java,eclipse-resource-mapping,"package se.kau.cs.jittac.model.mapping.eclipse;

import org.eclipse.core.resources.IProject;
import org.eclipse.core.resources.IResource;
import org.eclipse.core.resources.ResourcesPlugin;
import org.eclipse.core.runtime.IPath;
import org.eclipse.core.runtime.Path;

import se.kau.cs.jittac.model.mapping.IJittacProject;
import se.kau.cs.jittac.model.mapping.IJittacResource;
import se.kau.cs.jittac.model.mapping.IJittacResourceFactory;

public class EclipseJittacResourceFactory implements IJittacResourceFactory {

	public static final String RESOURCE_MODEL_NAME = ""eclipse-resource-model"";
	
	public static EclipseJittacResourceFactory INSTANCE =
			new EclipseJittacResourceFactory();
	
	private EclipseJittacResourceFactory() {
	}
	
	@Override
	public IJittacProject createJittacProjectFromPersistentHandle(String handle) {
		
		IJittacProject result = null;
		IResource resource = getResourceFromString(handle);
		if (resource != null) {
			if (resource instanceof IProject) {
				result = EclipseJittacProject.get((IProject) resource);
			}
		}
		return result;
	}

	@Override
	public IJittacResource createJittacResourceFromPersistentHandle(
			String handle, IJittacProject project) {
		
		IResource resource = getResourceFromString(handle);
		if (project instanceof EclipseJittacProject) {
			IProject eclProject = ((EclipseJittacProject) project).getWrappedProject();
			if (resource != null && eclProject != null) {
				if (eclProject.equals(resource.getProject())) {
					//return EclipseJittacResource.create(resource, (EclipseJittacProject) project);
					return ((EclipseJittacProject) project).getResource(resource);
				}
			}
		}
		return null;
	}

	@Override
	public String getResourceModelName() {
		return RESOURCE_MODEL_NAME;
	}

	private IResource getResourceFromString(String protableString) {
		IPath path =  Path.fromPortableString(protableString);
		IResource resource = ResourcesPlugin.getWorkspace().getRoot().findMember(path);
		return resource;
	}
	
}
"
ArchitectureModelModule.java,eclipse-ui,"package se.kau.cs.jittac.eclipse.ui;

import com.google.inject.multibindings.MapBinder;

import se.kau.cs.jittac.eclipse.ui.models.ItemCreationModel;
import se.kau.cs.jittac.eclipse.ui.parts.ArchitectureModelAnchorProvider;
import se.kau.cs.jittac.eclipse.ui.parts.ArchitectureModelPart;
import se.kau.cs.jittac.eclipse.ui.parts.ArchitectureModelPartsFactory;
import se.kau.cs.jittac.eclipse.ui.parts.ComponentPart;
import se.kau.cs.jittac.eclipse.ui.parts.ConnectorGeometricOutlineProvider;
import se.kau.cs.jittac.eclipse.ui.parts.ConnectorPart;
import se.kau.cs.jittac.eclipse.ui.parts.ConnectorSelectionFeedbackPart;
import se.kau.cs.jittac.eclipse.ui.parts.CreateConnectorFeedbackPartBehavior;
import se.kau.cs.jittac.eclipse.ui.parts.CreateConnectorFeedbackPartFactory;
import se.kau.cs.jittac.eclipse.ui.parts.SelectionColorProvider;
import se.kau.cs.jittac.eclipse.ui.policies.AbortConnectorCreationStrokeHandler;
import se.kau.cs.jittac.eclipse.ui.policies.ComponentOnDragHandler;
import se.kau.cs.jittac.eclipse.ui.policies.CreateComponentOnClickHandler;
import se.kau.cs.jittac.eclipse.ui.policies.CreateConnectorOnClickHandler;
import se.kau.cs.jittac.eclipse.ui.policies.ShowArchitectureElementContextMenuOnClickHandler;
import se.kau.cs.jittac.eclipse.ui.policies.ShowArchitectureModelContextMenuOnClickHandler;
import se.kau.cs.jittac.eclipse.ui.policies.TestOnDragHandler;

import org.eclipse.gef.common.adapt.AdapterKey;
import org.eclipse.gef.common.adapt.inject.AdapterMaps;
import org.eclipse.gef.mvc.fx.MvcFxModule;
import org.eclipse.gef.mvc.fx.handlers.FocusAndSelectOnClickHandler;
import org.eclipse.gef.mvc.fx.handlers.TranslateSelectedOnDragHandler;
import org.eclipse.gef.mvc.fx.parts.DefaultHoverFeedbackPartFactory;
import org.eclipse.gef.mvc.fx.parts.DefaultSelectionFeedbackPartFactory;
import org.eclipse.gef.mvc.fx.parts.SelectionFeedbackPart;
import org.eclipse.gef.mvc.fx.policies.TransformPolicy;
import org.eclipse.gef.mvc.fx.providers.ShapeOutlineProvider;

public class ArchitectureModelModule extends MvcFxModule {

    @Override
    protected void bindIContentPartFactoryAsContentViewerAdapter(MapBinder<AdapterKey<?>, Object> adapterMapBinder) {
        // bind MindMapPartsFactory adapter to the content viewer
        adapterMapBinder.addBinding(AdapterKey.defaultRole()).to(ArchitectureModelPartsFactory.class);
    }

    /**
     *
     * @param adapterMapBinder
     */
    @SuppressWarnings(""restriction"")
	protected void bindComponentPartAdapters(MapBinder<AdapterKey<?>, Object> adapterMapBinder) {
        // bind anchor provider used to create the connection anchors
        adapterMapBinder.addBinding(AdapterKey.defaultRole()).to(ArchitectureModelAnchorProvider.class);

        // bind a geometry provider, which is used in our anchor provider
        adapterMapBinder.addBinding(AdapterKey.defaultRole()).to(ShapeOutlineProvider.class);
        
        // provides a hover feedback to the shape, used by the HoverBehavior
        AdapterKey<?> role = AdapterKey.role(DefaultHoverFeedbackPartFactory.HOVER_FEEDBACK_GEOMETRY_PROVIDER);
        adapterMapBinder.addBinding(role).to(ShapeOutlineProvider.class);

		// provides a selection feedback to the shape
		role = AdapterKey.role(DefaultSelectionFeedbackPartFactory.SELECTION_FEEDBACK_GEOMETRY_PROVIDER);
		adapterMapBinder.addBinding(role).to(ShapeOutlineProvider.class);
        
         // support moving nodes via mouse drag
        adapterMapBinder.addBinding(AdapterKey.defaultRole()).to(TransformPolicy.class);
        adapterMapBinder.addBinding(AdapterKey.defaultRole()).to(ComponentOnDragHandler.class);
        
        adapterMapBinder.addBinding(AdapterKey.defaultRole()).to(CreateConnectorOnClickHandler.class);
        
        adapterMapBinder.addBinding(AdapterKey.defaultRole()).to(ShowArchitectureElementContextMenuOnClickHandler.class);
    }
    
    @SuppressWarnings(""restriction"")
	protected void bindConnectorPartAdapters(MapBinder<AdapterKey<?>, Object> adapterMapBinder) {
        // provides a hover feedback to the shape, used by the HoverBehavior
        AdapterKey<?> role = AdapterKey.role(DefaultHoverFeedbackPartFactory.HOVER_FEEDBACK_GEOMETRY_PROVIDER);
        adapterMapBinder.addBinding(role).to(ConnectorGeometricOutlineProvider.class);

		// provides a selection feedback to the shape
		role = AdapterKey.role(DefaultSelectionFeedbackPartFactory.SELECTION_FEEDBACK_GEOMETRY_PROVIDER);
		adapterMapBinder.addBinding(role).to(ConnectorGeometricOutlineProvider.class);
	
		adapterMapBinder.addBinding(AdapterKey.defaultRole()).to(ShowArchitectureElementContextMenuOnClickHandler.class);
		//AdapterKey<?> key = AdapterKey.get(SelectionFeedbackPart.class); 
		//adapterMapBinder.addBinding(key).to(ConnectorSelectionFeedbackPart.class);
    }
    
    @SuppressWarnings(""restriction"")
    protected void bindArchitectureModelPartAdapters(MapBinder<AdapterKey<?>, Object> adapterMapBinder) {
        
    	// add the focus and select policy to every part, listening to clicks
        // and changing the focus and selection model
        //adapterMapBinder.addBinding(AdapterKey.defaultRole()).to(FocusAndSelectOnClickHandler.class);
        
        
        //adapterMapBinder.addBinding(AdapterKey.defaultRole()).to(TestOnDragHandler.class);
        
        //adapterMapBinder.addBinding(AdapterKey.defaultRole()).to(AbortConnectorCreationStrokeHandler.class);
        
        
    }

//    @SuppressWarnings(""restriction"")
//    @Override
//	protected void bindHoverFeedbackPartFactoryAsContentViewerAdapter(MapBinder<AdapterKey<?>, Object> adapterMapBinder) {
//    	adapterMapBinder
//			.addBinding(AdapterKey.role(HoverBehavior.HOVER_FEEDBACK_PART_FACTORY))
//			.to(HoverFeedbackPartFactory.class);
//    }
    
    @SuppressWarnings(""restriction"")
	@Override
    protected void bindAbstractContentPartAdapters(MapBinder<AdapterKey<?>, Object> adapterMapBinder) {
        super.bindAbstractContentPartAdapters(adapterMapBinder);

        // binding the HoverOnHoverPolicy to every part
        // if a mouse is moving above a part it is set i the HoverModel
        //adapterMapBinder.addBinding(AdapterKey.defaultRole()).to(HoverOnHoverHandler.class);

        // add the focus and select policy to every part, listening to clicks
        // and changing the focus and selection model
        adapterMapBinder.addBinding(AdapterKey.defaultRole()).to(FocusAndSelectOnClickHandler.class);

        //adapterMapBinder.addBinding(AdapterKey.defaultRole()).to(TestOnDragHandler.class);
        
        //adapterMapBinder.addBinding(AdapterKey.defaultRole()).to(AbortConnectorCreationStrokeHandler.class);
        
        
    }
    
    @SuppressWarnings(""restriction"")
	@Override
    protected void bindIRootPartAdaptersForContentViewer(MapBinder<AdapterKey<?>, Object> adapterMapBinder) {
        super.bindIRootPartAdaptersForContentViewer(adapterMapBinder);

        adapterMapBinder.addBinding(AdapterKey.defaultRole()).to(CreateComponentOnClickHandler.class);
        // binding a Hover Behavior to the root part. it will react to
        // HoverModel changes and render the hover part
        //adapterMapBinder.addBinding(AdapterKey.defaultRole()).to(HoverBehavior.class);
        adapterMapBinder.addBinding(AdapterKey.defaultRole()).to(CreateConnectorFeedbackPartBehavior.class);
        
        adapterMapBinder.addBinding(AdapterKey.defaultRole()).to(AbortConnectorCreationStrokeHandler.class);
        
        adapterMapBinder.addBinding(AdapterKey.defaultRole()).to(ShowArchitectureModelContextMenuOnClickHandler.class);
        
    }
    
    @SuppressWarnings(""restriction"")
	@Override
    protected void bindIViewerAdaptersForContentViewer(MapBinder<AdapterKey<?>, Object> adapterMapBinder) {
    	super.bindIViewerAdaptersForContentViewer(adapterMapBinder);
    	// bind the model to the content viewer
    	adapterMapBinder.addBinding(AdapterKey.defaultRole()).to(ItemCreationModel.class);
    	
        AdapterKey<?> role = AdapterKey.role(DefaultSelectionFeedbackPartFactory.PRIMARY_SELECTION_FEEDBACK_COLOR_PROVIDER);
        adapterMapBinder.addBinding(role).to(SelectionColorProvider.class);
        
        role = AdapterKey.role(DefaultSelectionFeedbackPartFactory.SECONDARY_SELECTION_FEEDBACK_COLOR_PROVIDER);
        adapterMapBinder.addBinding(role).to(SelectionColorProvider.class);
        
        role = AdapterKey.role(CreateConnectorFeedbackPartBehavior.CREATE_FEEDBACK_PART_FACTORY);
        adapterMapBinder.addBinding(role).to(CreateConnectorFeedbackPartFactory.class);
        
        
    }
    
    @SuppressWarnings(""restriction"")
	@Override
    protected void configure() {
        // start the default configuration
        super.configure();

        bindComponentPartAdapters(AdapterMaps.getAdapterMapBinder(binder(), ComponentPart.class));
        bindConnectorPartAdapters(AdapterMaps.getAdapterMapBinder(binder(), ConnectorPart.class));
        bindArchitectureModelPartAdapters(AdapterMaps.getAdapterMapBinder(binder(), ArchitectureModelPart.class));
        
        bind(SelectionFeedbackPart.class).to(ConnectorSelectionFeedbackPart.class);
    }
}
"
ArchitectureModelModuleUI.java,eclipse-ui,"package se.kau.cs.jittac.eclipse.ui;

import org.eclipse.gef.mvc.fx.ui.MvcFxUiModule;

public class ArchitectureModelModuleUI extends MvcFxUiModule {

}
"
ArchitectureModelPropertyPage.java,eclipse-ui,"package se.kau.cs.jittac.eclipse.ui;

import static com.google.common.collect.Sets.newHashSet;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.Set;

import org.eclipse.core.resources.IFile;
import org.eclipse.core.resources.IMarker;
import org.eclipse.core.resources.IProject;
import org.eclipse.core.resources.ResourcesPlugin;
import org.eclipse.jface.dialogs.Dialog;
import org.eclipse.jface.preference.PreferencePage;
import org.eclipse.jface.viewers.ArrayContentProvider;
import org.eclipse.jface.viewers.CheckboxTableViewer;
import org.eclipse.jface.viewers.LabelProvider;
import org.eclipse.swt.SWT;
import org.eclipse.swt.graphics.Image;
import org.eclipse.swt.layout.GridData;
import org.eclipse.swt.layout.GridLayout;
import org.eclipse.swt.widgets.Combo;
import org.eclipse.swt.widgets.Composite;
import org.eclipse.swt.widgets.Control;
import org.eclipse.swt.widgets.Label;
import org.eclipse.ui.PlatformUI;
import org.eclipse.ui.dialogs.PropertyPage;
import org.eclipse.ui.ide.IDE;

import se.kau.cs.jittac.eclipse.ModelManager;
import se.kau.cs.jittac.model.am.ArchitectureModel;
import se.kau.cs.jittac.model.mapping.IJittacProject;
import se.kau.cs.jittac.model.mapping.eclipse.EclipseJittacProject;



public class ArchitectureModelPropertyPage extends PropertyPage {

	private static final String PROJECTS_TEXT =""Select projectList controlled by this model..."";
	private static final String VIOLATIONS_TEXT =""Report violations as:"";
//    private static final String UNMAPPED_TEXT =""Report unmapped resources as:"";

	private Composite contents;
	private Combo violationsCombo;
	//private Combo unmappedCombo;
	private CheckboxTableViewer projectList;
	
	
	/**
	 * Constructor for SamplePropertyPage.
	 */
	public ArchitectureModelPropertyPage() {
		super();
	}
	
	public ArchitectureModel getModel() {
		return ModelManager.instance()
			.getArchitectureModel((IFile) getElement().getAdapter(IFile.class));
	}

	private void addSeparator(Composite parent) {
		Label separator = new Label(parent, SWT.SEPARATOR | SWT.HORIZONTAL);
		GridData gridData = new GridData();
		gridData.horizontalAlignment = GridData.FILL;
		gridData.grabExcessHorizontalSpace = true;
		separator.setLayoutData(gridData);
	}
	
	private void addErrorsWarningsSection(Composite parent) {
		contents = createComposite(parent, 2, false);
		Label label;
		
		label = new Label(contents, SWT.HORIZONTAL);
		label.setText(VIOLATIONS_TEXT);
		violationsCombo = createCombo();
		
		//label = new Label(contents, SWT.HORIZONTAL);
		//label.setText(UNMAPPED_TEXT);		
		//unmappedCombo = createCombo();
	}

	private void addProjectsSection(Composite parent) {
        Composite composite = createComposite(parent, 1, true);
        initializeDialogUnits(composite);
        
		Label label = new Label(composite, SWT.NONE);
		label.setText(PROJECTS_TEXT);
  
        projectList = CheckboxTableViewer.newCheckList(composite, SWT.BORDER);
        projectList.getTable().setLayoutData(new GridData(GridData.FILL_BOTH));
        projectList.setLabelProvider(new LabelProvider() {
        	@Override
        	public Image getImage(Object element) {
        		return PlatformUI.getWorkbench().getSharedImages().getImage(IDE.SharedImages.IMG_OBJ_PROJECT);
        	}

        	@Override
        	public String getText(Object element) {
        		return ((IProject) element).getName();
        	}
        });
		
        // Filter out closed projects!
        ArrayList<IProject> projects = new ArrayList<IProject>();
        for (IProject project: ResourcesPlugin.getWorkspace().getRoot().getProjects()) {
        	if (project.isOpen())
        		projects.add(project);
        }
        projectList.setContentProvider(new ArrayContentProvider());
        projectList.setInput(projects);

        Dialog.applyDialogFont(composite);
	}

	
	/**
	 * @see PreferencePage#createContents(Composite)
	 */
	protected Control createContents(Composite parent) {
		addErrorsWarningsSection(parent);
		addSeparator(parent);
		addProjectsSection(parent);
		
		initSettings();
		return parent;
	}

	private static Composite createComposite(Composite parent, int columns, boolean expand) {
		Composite contents = new Composite(parent, SWT.NULL);
		GridLayout layout = new GridLayout();
		layout.numColumns = columns;
		contents.setLayout(layout);

		GridData data = new GridData();
		data.grabExcessHorizontalSpace = true;
		data.grabExcessVerticalSpace = expand;
		data.verticalAlignment = GridData.FILL;
		data.horizontalAlignment = GridData.FILL;
		contents.setLayoutData(data);

		return contents;
	}
	
	private Combo createCombo() {
		Combo combo = new Combo(contents, SWT.READ_ONLY);
		combo.setItems(new String[] {
			""Error"",
			""Warning"",
			""Info"",
			""Ignore""
		});
		return combo;
	}
	
	private void setCombo(Combo combo, int value) {
		switch (value) {
		case IMarker.SEVERITY_ERROR:
			combo.select(0);
			break;
		case IMarker.SEVERITY_WARNING:
			combo.select(1);
			break;
		case IMarker.SEVERITY_INFO:
			combo.select(2);
			break;
		default:
			combo.select(3);
		}
	}
	
	private int getCombo(Combo combo) {
		switch (combo.getSelectionIndex()) {
		case 0:
			return IMarker.SEVERITY_ERROR;
		case 1:
			return IMarker.SEVERITY_WARNING;
		case 2:
			return IMarker.SEVERITY_INFO;
			
		default:
			return -1;
		}
	}
	
	private IProject[] getControlledProjects() {
		Object[] elements = projectList.getCheckedElements();
		IProject[] projects = new IProject[elements.length];
		for (int i = 0; i < elements.length; ++i)
			projects[i] = (IProject) elements[i];
		
		return projects;
	}
	
    private void setControlledProjects(Set<IProject> projects) {
        projectList.setCheckedElements(projects.toArray(new IProject[projects.size()]));
    }
	
	protected void initSettings() {
		performDefaults();
		
		/*ModelProblemManager manager = getProblemManager();
		setCombo(violationsCombo, manager.getViolationSeverity());*/
		//setCombo(unmappedCombo, manager.getUnmappedSeverity());
//		if(manager.getControlledProjects().length==0){
//			// make sure default is maintained if no projects are selected.
//			manager.setControlledProjects(getControlledProjects());
//		}
		Set<IProject> projects = new HashSet<>();
		for (IJittacProject jProj : getModel().getManagedProjects()) {
			projects.add(((EclipseJittacProject) jProj).getWrappedProject());
		}
		setControlledProjects(projects);
	}

	protected void performDefaults() {
		violationsCombo.select(1);
		//unmappedCombo.select(2);
//		projectList.setAllChecked(true);// tick all projects by default
		
	}
	
	public boolean performOk() {		
		//ModelProblemManager manager = getProblemManager();
		//manager.setViolationSeverity(getCombo(violationsCombo));
		//manager.setUnmappedSeverity(getCombo(unmappedCombo));

		for (IProject project : getControlledProjects()) {
			
			//getModel().manageProject(EclipseJittacProject.get(project));
		}
		return true;
	}

}
"
ArchitectureModelEditor.java,eclipse-ui,"package se.kau.cs.jittac.eclipse.ui.editors;


import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.IOException;

import org.eclipse.core.resources.IFile;
import org.eclipse.core.runtime.CoreException;
import org.eclipse.core.runtime.IProgressMonitor;
import org.eclipse.gef.mvc.fx.ui.MvcFxUiModule;
import org.eclipse.gef.mvc.fx.ui.parts.AbstractFXEditor;
import org.eclipse.gef.mvc.fx.viewer.IViewer;
import org.eclipse.ui.IEditorInput;
import org.eclipse.ui.IFileEditorInput;
import org.eclipse.ui.IEditorSite;
import org.eclipse.ui.PartInitException;

import com.google.inject.Guice;
import com.google.inject.util.Modules;

import javafx.scene.Node;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.control.Toggle;
import javafx.scene.control.ToggleButton;
import javafx.scene.control.ToggleGroup;
import javafx.scene.layout.BorderPane;
import javafx.scene.layout.VBox;
import javafx.stage.FileChooser;
import javafx.event.ActionEvent;  
import javafx.event.EventHandler;

import se.kau.cs.jittac.eclipse.ModelManager;
import se.kau.cs.jittac.eclipse.ui.ArchitectureModelModule;
import se.kau.cs.jittac.eclipse.ui.models.ItemCreationModel;
import se.kau.cs.jittac.eclipse.ui.views.BrowserView;
import se.kau.cs.jittac.eclipse.ui.views.FeatureLocationTableView;
import se.kau.cs.jittac.eclipse.util.FeatureLocationCSV;
import se.kau.cs.jittac.model.am.ArchitectureModel;
import se.kau.cs.jittac.model.am.Component;
import se.kau.cs.jittac.model.am.io.ArchitectureModelWriter;
import se.kau.cs.jittac.model.am.test.ConsoleArchitectureModelListener;
import se.kau.cs.jittac.model.mapping.JittacResourceModelRegistry;
import se.kau.cs.jittac.model.mapping.events.AbstractArchitectureMappingChangeListener;
import se.kau.cs.jittac.model.mapping.events.IArchitectureMappingChangeListener;
import se.kau.cs.jittac.model.mapping.events.MappingAdditionEvent;
import se.kau.cs.jittac.model.mapping.events.MappingRemovalEvent;
import se.kau.cs.jittac.model.mapping.test.TestResourceFactory;

public class ArchitectureModelEditor extends AbstractFXEditor {
	
	private ArchitectureModel model;
	private Component c1, c2, c3;
	private boolean mappingChanged;
	private IArchitectureMappingChangeListener mappingListener =
			new ArchitectureModelEditorMappingListener();
	
	private class ArchitectureModelEditorMappingListener extends AbstractArchitectureMappingChangeListener {
		protected void onMappingAdded(MappingAdditionEvent event) {
			mappingChanged = true;
		}

		protected void onMappingRemoved(MappingRemovalEvent event) {
			mappingChanged = true;
		}
	}
	
	public ArchitectureModelEditor() {
		super(Guice.createInjector(
				Modules.override(new ArchitectureModelModule()).
				with(new MvcFxUiModule())));
	}
	
	@Override
	public void doSave(IProgressMonitor monitor) {
		try {
			ArchitectureModel model = (ArchitectureModel) getContentViewer().getContents().get(0);
			ByteArrayOutputStream output = new ByteArrayOutputStream();
			ArchitectureModelWriter.write(output, model);
			
			IFile file = ((IFileEditorInput) getEditorInput()).getFile();
			
			file.setContents(new ByteArrayInputStream(output.toByteArray()), true, false, monitor);
			this.markNonDirty();
			output.close();
		} catch (CoreException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
	
	@Override
	public void doSaveAs() {
		// TODO Auto-generated method stub

	}

	@Override
	public boolean isSaveAsAllowed() {
		return false;
	}
	
	@Override
	public boolean isDirty() {
		return super.isDirty() || mappingChanged;
	}
	
	@Override
	public void markNonDirty() {
		mappingChanged = false;
		super.markNonDirty();
	}
	
	public ArchitectureModel getModel() {
		return (ArchitectureModel) getContentViewer().getContents().get(0);
	}

	@Override
	public void init(IEditorSite site, IEditorInput input) throws PartInitException {
		super.init(site, input);
		IFile archModelFile = ((IFileEditorInput) input).getFile();
		ArchitectureModel model = ModelManager.instance().getArchitectureModel( archModelFile );
		
		if (model != null) {
			model.getMapping().registerListener(mappingListener);
			mappingChanged = false;
			IViewer viewer = getContentViewer();
			viewer.getContents().setAll(model);
			viewer.getRootPart().refreshVisual();
			this.setPartName( archModelFile.getName() );
		}
		else {
			throw new PartInitException(""Jittac Architecture Editor could not load "" + archModelFile.getName());
		}
	}
	
	@Override
	protected void hookViewers() {

		final IViewer contentViewer = getContentViewer();

		// creating parent pane for Canvas and button pane
		BorderPane pane = new BorderPane();

		//pane.setTop();
		pane.setCenter(contentViewer.getCanvas());
		pane.setRight(createToolPalette());

		pane.setMinWidth(800);
		pane.setMinHeight(600);

		Scene scene = new Scene(pane);
		getCanvas().setScene(scene);
	}
	
//	private Node createTopPalette() {
//
//	}
	
	private Node createToolPalette()
	{
		ItemCreationModel creationModel = getContentViewer().getAdapter( ItemCreationModel.class );
		
		// the toggleGroup makes sure, we only select one 
		ToggleGroup toggleGroup = new ToggleGroup();
		
		ToggleButton createNode = new ToggleButton( ""New Node"" );
		createNode.setToggleGroup( toggleGroup );
		createNode.setStyle( ""-fx-base: lightskyblue;"" );
		createNode.setMaxWidth( Double.MAX_VALUE );
		createNode.setMinHeight( 50 );
		createNode.selectedProperty().addListener( ( e, oldVal, newVal ) -> {
			creationModel.setType( newVal ? ItemCreationModel.Type.Component : ItemCreationModel.Type.None );
		} );

		ToggleButton createConn = new ToggleButton( ""New Connection"" );
		createConn.setToggleGroup( toggleGroup );
		createConn.setMaxWidth( Double.MAX_VALUE );
		createConn.setMinHeight( 50 );
		createConn.selectedProperty().addListener( ( e, oldVal, newVal ) -> {
	        creationModel.setType( newVal ? ItemCreationModel.Type.Connector : ItemCreationModel.Type.None );
		});
		
		// now listen to changes in the model, and deactivate buttons, if necessary
		creationModel.getTypeProperty().addListener( ( e, oldVal, newVal ) -> {
	            
			if( ItemCreationModel.Type.None == newVal )
			{
                // unselect the toggle button
                Toggle selectedToggle = toggleGroup.getSelectedToggle();
                
                if( selectedToggle != null )
                {
                    selectedToggle.setSelected( false );
                }
	        }
	    } );
		
		Button loadFeatLocs = new Button( ""Load Feature Locations"" );
		loadFeatLocs.setMaxWidth( Double.MAX_VALUE );
		loadFeatLocs.setMinHeight( 50 );
		loadFeatLocs.setStyle( ""-fx-base: lightgreen;"" );
		loadFeatLocs.setOnAction( new EventHandler<ActionEvent>() {  
			@Override  
			public void handle( ActionEvent arg0 )
			{  
				FileChooser file = new FileChooser();  
		        file.setTitle( ""Open File"" );  
		        File csvPath = file.showOpenDialog( null );
		        FeatureLocationCSV.load( csvPath );
		        FeatureLocationTableView.refresh();
			} 
		} );

		Button openBrowser = new Button( ""View Feature Dependencies"" );
		openBrowser.setMaxWidth( Double.MAX_VALUE );
		openBrowser.setMinHeight( 50 );
		openBrowser.setStyle( ""-fx-base: lightgreen;"" );
		openBrowser.setOnAction( new EventHandler<ActionEvent>()
		{  
			@Override  
			public void handle( ActionEvent arg0 )
			{   
				BrowserView.openBrowser();
			} 
		} );
		
		return new VBox( 20, createNode, createConn, loadFeatLocs, openBrowser );
	}

	private void populateViewerContents() {
		double[] positions = new double[] {100, 100, 500, 100, 300, 400};
		JittacResourceModelRegistry.INSTANCE.registerResourceModel(TestResourceFactory.INSTANCE);
		JittacResourceModelRegistry.INSTANCE.setDefaultResourceModel(TestResourceFactory.INSTANCE);
        model = ArchitectureModel.createArchitectureModel();
		model.registerListener(new ConsoleArchitectureModelListener());
        c1 = model.createComponent(""C1"");
        c2 = model.createComponent(""C2"");
        c3 = model.createComponent(""C3"");
		

        IViewer viewer = getContentViewer();
        viewer.getContents().setAll(model);
        
 /*       int i = 0;
        for (IVisualPart p : viewer.getRootPart().getChildrenUnmodifiable().get(0).getChildrenUnmodifiable()) {
        	if (p instanceof ComponentPart) {
        		p.getVisual().setLayoutX(positions[i++]);
        		p.getVisual().setLayoutY(positions[i++]);
        	}
        }*/
        viewer.getRootPart().refreshVisual();
    }
	
}"
ArchitectureModelOutlineAdapterFactory.java,eclipse-ui,"package se.kau.cs.jittac.eclipse.ui.editors;

import org.eclipse.core.runtime.IAdapterFactory;
import org.eclipse.ui.views.contentoutline.IContentOutlinePage;

public class ArchitectureModelOutlineAdapterFactory implements IAdapterFactory {

	@Override
	public <T> T getAdapter(Object adaptableObject, Class<T> adapterType) {
		if (IContentOutlinePage.class.equals(adapterType)) {
			ArchitectureModelEditor editor = (ArchitectureModelEditor) adaptableObject;
			return (T) new ArchitectureModelOutlinePage(editor);
		}
		return null;
	}

	@Override
	public Class<?>[] getAdapterList() {
		return new Class<?>[] {IContentOutlinePage.class};
	}

}
"
ArchitectureModelOutlinePage.java,eclipse-ui,"package se.kau.cs.jittac.eclipse.ui.editors;

import org.eclipse.core.resources.IProject;
import org.eclipse.core.resources.IResource;
import org.eclipse.jface.viewers.ILabelProvider;
import org.eclipse.jface.viewers.ILabelProviderListener;
import org.eclipse.jface.viewers.ITreeContentProvider;
import org.eclipse.jface.viewers.TreeViewer;
import org.eclipse.swt.SWT;
import org.eclipse.swt.dnd.DND;
import org.eclipse.swt.dnd.DropTargetAdapter;
import org.eclipse.swt.dnd.DropTargetEvent;
import org.eclipse.swt.dnd.Transfer;
import org.eclipse.swt.events.KeyEvent;
import org.eclipse.swt.events.KeyListener;
import org.eclipse.swt.graphics.Image;
import org.eclipse.swt.widgets.Composite;
import org.eclipse.swt.widgets.TreeItem;
import org.eclipse.ui.IViewPart;
import org.eclipse.ui.PartInitException;
import org.eclipse.ui.PlatformUI;
import org.eclipse.ui.part.ResourceTransfer;
import org.eclipse.ui.views.contentoutline.ContentOutlinePage;
import org.eclipse.ui.navigator.resources.ProjectExplorer;
import se.kau.cs.jittac.model.am.ArchitectureModel;
import se.kau.cs.jittac.model.am.Component;
import se.kau.cs.jittac.model.am.events.AbstractArchitectureModelChangeListener;
import se.kau.cs.jittac.model.am.events.ComponentAdditionEvent;
import se.kau.cs.jittac.model.am.events.ComponentNameChangeEvent;
import se.kau.cs.jittac.model.am.events.ComponentRemovalEvent;
import se.kau.cs.jittac.model.am.events.IArchitectureModelChangeListener;
import se.kau.cs.jittac.model.mapping.IMappableElement;
import se.kau.cs.jittac.model.mapping.eclipse.EclipseJittacProject;
import se.kau.cs.jittac.model.mapping.eclipse.EclipseJittacResource;

public class ArchitectureModelOutlinePage extends ContentOutlinePage {

	private ArchitectureModelEditor editor;
	
	private IArchitectureModelChangeListener architectureModelListener = 
			new AbstractArchitectureModelChangeListener() {
		@Override
		public void onComponentAdded(ComponentAdditionEvent event) {
			getTreeViewer().refresh(false);
		}
		
		@Override
		public void onComponentRemoved(ComponentRemovalEvent event) {
			getTreeViewer().refresh(false);
		}
		
		@Override
		public void onComponentNameChanged(ComponentNameChangeEvent event) {
			getTreeViewer().refresh(event.getComponent());
		}
	};

	public ArchitectureModelOutlinePage(ArchitectureModelEditor editor) {
		super();
		this.editor = editor;

	}
	
	@Override
	public void createControl(Composite parent) {
		super.createControl(parent);
		
		TreeViewer viewer = getTreeViewer();
		viewer.setContentProvider(new OutlineContentProvider());
		viewer.setLabelProvider(new OutlineLabelProvider());
		viewer.setInput(editor.getModel());
		viewer.expandAll();
		
		ArchitectureModel model = (ArchitectureModel) editor.getContentViewer().getContents().get(0);
		model.registerListener(architectureModelListener);
		
		int operations = DND.DROP_COPY | DND.DROP_DEFAULT;
		//DropTarget target = new DropTarget(getTreeViewer().getTree(), operations);
		ResourceTransfer resourceTransfer = ResourceTransfer.getInstance();
		//FileTransfer fileTransfer = FileTransfer.getInstance();
		Transfer transferTypes[] = new Transfer[] {resourceTransfer};
		
		getTreeViewer().addDropSupport(operations, transferTypes, new DropTargetAdapter() {
			
			public void drop(DropTargetEvent event) {
				
				IMappableElement newMapElement = null;
				Component comp = null;
				
				
				if (event.data instanceof IResource[]) {
					IResource dataArr[] = (IResource []) event.data;
					for (IResource res : dataArr) {
						if (res instanceof IProject) {
							newMapElement = EclipseJittacProject.get((IProject) res);
						}
						else if (res instanceof IResource) {
							newMapElement = EclipseJittacResource.create((IResource) res,
									EclipseJittacProject.get(((IResource) res).getProject()));
						}
						else return;
						
						TreeItem item = (TreeItem) event.item;
						Object data = item.getData();
						if (data instanceof ArchitectureModel) {
							
						}
						else if (data instanceof Component) {
							comp = (Component) data;
							comp.getModel().getMapping().addMapping(comp, newMapElement);
						}
						else if (data instanceof IMappableElement) {
							IMappableElement mappedElem = 
									(IMappableElement) data;
							comp = editor.getModel().getMapping().getComponent(mappedElem);
							comp.getModel().getMapping().addMapping(comp, newMapElement);
						}
						else {
							//Do nothing I suppose
						}
					}
				}
				if (comp != null)
					getTreeViewer().refresh(comp);
			}
			
			public void dragEnter(DropTargetEvent event) {
				if (event.detail != DND.DROP_COPY) {
					event.detail = DND.DROP_COPY;
				}
			}
		});
		
		getTreeViewer().getTree().addKeyListener(new KeyListener() {

			@Override
			public void keyPressed(KeyEvent e) {
				if (e.keyCode == SWT.DEL) {
					for (Object selected : getTreeViewer().getStructuredSelection().toList())  {
						if (selected instanceof IMappableElement) {
							getTreeViewer().setSelection(null);
							IMappableElement element = (IMappableElement) selected;
							Component comp = editor.getModel().getMapping().getComponent(element);
							editor.getModel().getMapping().removeMapping(comp, element);
							getTreeViewer().refresh(comp);
							
						}

					}
					
				}
			}

			@Override
			public void keyReleased(KeyEvent e) {
			}
			
		});
	}
	
	@Override
	public void dispose() {
		ArchitectureModel model = (ArchitectureModel) editor.getContentViewer().getContents().get(0);
		model.deregisterListener(architectureModelListener);

		super.dispose();
	}
	
	public class OutlineContentProvider implements ITreeContentProvider {

		@Override
		public Object[] getElements(Object inputElement) {
			if (inputElement instanceof ArchitectureModel) {
				return getChildren(inputElement);
			}
			return null;
		}

		@Override
		public Object[] getChildren(Object parentElement) {
			if (parentElement instanceof ArchitectureModel) {
				return ((ArchitectureModel) parentElement).getComponents().toArray();
			}
			else if (parentElement instanceof Component) {
				Component comp = (Component) parentElement;
				return comp.getModel().getMapping().getMappedResources(comp).toArray();
			}
			return null;
		}

		@Override
		public Object getParent(Object element) {
			if (element instanceof Component) {
				return ((Component) element).getModel();
			}
			else if (element instanceof IMappableElement) {
				ArchitectureModel model = ArchitectureModelOutlinePage.this.editor.getModel();
				return model.getMapping().getComponent((IMappableElement) element);
			}
			return null;
		}

		@Override
		public boolean hasChildren(Object element) {
			if (element instanceof ArchitectureModel) {
				return ((ArchitectureModel) element).getComponents().size() > 0;
			}
			if (element instanceof Component) {
				Component comp = (Component) element;
				return comp.getModel().getMapping().getMappedResources(comp).size() > 0;
			}
			return false;
		}
		
	}
	
	public class OutlineLabelProvider implements ILabelProvider {

		private ILabelProvider peLabelProvider;
		
		public OutlineLabelProvider() {
			IViewPart view;
			try {
				view = PlatformUI.getWorkbench().getActiveWorkbenchWindow().
						getActivePage().showView(ProjectExplorer.VIEW_ID);
				peLabelProvider = (ILabelProvider) ((ProjectExplorer) view).getCommonViewer().getLabelProvider();
			} catch (PartInitException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}
		
		@Override
		public void addListener(ILabelProviderListener listener) {
			// TODO Auto-generated method stub
			
		}

		@Override
		public void dispose() {
			// TODO Auto-generated method stub
			
		}

		@Override
		public boolean isLabelProperty(Object element, String property) {
			// TODO Auto-generated method stub
			return false;
		}

		@Override
		public void removeListener(ILabelProviderListener listener) {
			// TODO Auto-generated method stub
			
		}

		@Override
		public Image getImage(Object element) {
			//TODO: find out how to properly reuse icons and decorations from ProjectExplorer and edit constructor
			//view = PlatformUI.getWorkbench().getActiveWorkbenchWindow().getActivePage().showView(ProjectExplorer.VIEW_ID);
			//NavigatorContentService contentService  = new NavigatorContentService(ProjectExplorer.VIEW_ID);
			if (element instanceof Component) {
				
			}
			if (element instanceof EclipseJittacResource) {
				return peLabelProvider.getImage(((EclipseJittacResource) element).getWrappedResource());
			}
			return null;
		}

		@Override
		public String getText(Object element) {
			if (element instanceof ArchitectureModel)
			{
				return ""Mappings"";
			}
			else if (element instanceof Component) {
				return ((Component) element).getName() + "" mappings"";
			}
			else if (element instanceof EclipseJittacProject ) {
				return peLabelProvider.getText(((EclipseJittacProject) element).getWrappedProject());
			}
			else if (element instanceof EclipseJittacResource) {
				return peLabelProvider.getText(((EclipseJittacResource) element).getWrappedResource());				
			}
			return null;
		}
		
		
		
	}

}
"
ItemCreationModel.java,eclipse-ui,"package se.kau.cs.jittac.eclipse.ui.models;

import javafx.beans.property.ObjectProperty;
import javafx.beans.property.SimpleObjectProperty;
import se.kau.cs.jittac.eclipse.ui.parts.ComponentPart;

public class ItemCreationModel {

	public static enum Type {
		None,
		Component,
		Connector
	};
	
	private ObjectProperty<Type> typeProperty = new SimpleObjectProperty<ItemCreationModel.Type>(Type.None);
	private ObjectProperty<ComponentPart> srcProperty = new SimpleObjectProperty<ComponentPart>();

	public ObjectProperty<Type> getTypeProperty() {
		return typeProperty;
	}

	public Type getType() {
		return typeProperty.getValue();
	}

	public void setType(Type type) {
		this.typeProperty.setValue(type);
	}
	
	public ComponentPart getSource() {
		return srcProperty.getValue();
	}
	
	public ObjectProperty<ComponentPart> getSourceProperty() {
		return srcProperty;
	}

	public void setSource(ComponentPart part) {
		srcProperty.setValue(part);
	}
}
"
MarkConnectorAsEnvisagedOperation.java,eclipse-ui,"package se.kau.cs.jittac.eclipse.ui.operations;

import org.eclipse.core.commands.ExecutionException;
import org.eclipse.core.commands.operations.AbstractOperation;
import org.eclipse.core.runtime.IAdaptable;
import org.eclipse.core.runtime.IProgressMonitor;
import org.eclipse.core.runtime.IStatus;
import org.eclipse.core.runtime.Status;
import org.eclipse.gef.mvc.fx.operations.ITransactionalOperation;

import se.kau.cs.jittac.model.am.Connector;

public class MarkConnectorAsEnvisagedOperation extends AbstractOperation implements ITransactionalOperation {

	private Connector conn;
	private boolean wasEnvisaged;
	public MarkConnectorAsEnvisagedOperation(Connector conn) {
		super(""Envisage Connector"");
		this.conn = conn;
		wasEnvisaged = conn.isEnvisaged();
	}
	
	@Override
	public boolean isContentRelevant() {
		return true;
	}

	@Override
	public boolean isNoOp() {
		return wasEnvisaged;
	}

	@Override
	public IStatus execute(IProgressMonitor monitor, IAdaptable info) throws ExecutionException {
		conn.setEnvisaged(true);
		return Status.OK_STATUS;
	}

	@Override
	public IStatus redo(IProgressMonitor monitor, IAdaptable info) throws ExecutionException {
		return execute(monitor, info);
	}

	@Override
	public IStatus undo(IProgressMonitor monitor, IAdaptable info) throws ExecutionException {
		conn.setEnvisaged(wasEnvisaged);
		return Status.OK_STATUS;
	}

}
"
SetComponentNameOperation.java,eclipse-ui,"package se.kau.cs.jittac.eclipse.ui.operations;

import org.eclipse.core.commands.ExecutionException;
import org.eclipse.core.commands.operations.AbstractOperation;
import org.eclipse.core.runtime.IAdaptable;
import org.eclipse.core.runtime.IProgressMonitor;
import org.eclipse.core.runtime.IStatus;
import org.eclipse.core.runtime.Status;
import org.eclipse.gef.mvc.fx.operations.ITransactionalOperation;

import se.kau.cs.jittac.eclipse.ui.parts.ComponentPart;
import se.kau.cs.jittac.model.am.Component;

public class SetComponentNameOperation extends AbstractOperation implements ITransactionalOperation {

	private ComponentPart part;
	private String oldName, newName;
	
	public SetComponentNameOperation(ComponentPart part, String newName) {
		super(""Change component name"");
		this.part = part;
		this.newName = newName;
		this.oldName = part.getContent().getName();
	}

	@Override
	public boolean isContentRelevant() {
		return true;
	}

	@Override
	public boolean isNoOp() {
		return newName.equals(oldName);
	}

	@Override
	public IStatus execute(IProgressMonitor monitor, IAdaptable info) throws ExecutionException {
		Component comp = part.getContent();
		comp.getModel().setComponentName(comp, newName);
		return Status.OK_STATUS;
	}

	@Override
	public IStatus redo(IProgressMonitor monitor, IAdaptable info) throws ExecutionException {
		return execute(monitor, info);
	}

	@Override
	public IStatus undo(IProgressMonitor monitor, IAdaptable info) throws ExecutionException {
		part.getContent().setName(oldName);
		return Status.OK_STATUS;
	}

}
"
ArchitectureModelAnchorProvider.java,eclipse-ui,"package se.kau.cs.jittac.eclipse.ui.parts;

import org.eclipse.gef.common.adapt.IAdaptable;
import org.eclipse.gef.fx.anchors.DynamicAnchor;
import org.eclipse.gef.fx.anchors.DynamicAnchor.AnchorageReferenceGeometry;
import org.eclipse.gef.fx.anchors.IAnchor;
import org.eclipse.gef.geometry.planar.IGeometry;
import org.eclipse.gef.mvc.fx.parts.IVisualPart;

import com.google.common.reflect.TypeToken;
import com.google.inject.Provider;

import javafx.beans.binding.ObjectBinding;
import javafx.beans.property.ReadOnlyObjectProperty;
import javafx.scene.Node;

public class ArchitectureModelAnchorProvider extends IAdaptable.Bound.Impl<IVisualPart<? extends Node>>
implements Provider<IAnchor> {

	// the anchor in case we already created one
    private DynamicAnchor anchor;

    @Override
    public ReadOnlyObjectProperty<IVisualPart<? extends Node>> adaptableProperty() {
        return null;
    }

    @Override
    public IAnchor get() {
        if (anchor == null) {
            // get the visual from the host (MindMapNodePart)
            Node anchorage = getAdaptable().getVisual();
            // create a new anchor instance
            anchor = new DynamicAnchor(anchorage);

            // binding the anchor reference to an object binding, which
            // recalculates the geometry when the layout bounds of
            // the anchorage are changing
            anchor.getComputationParameter(AnchorageReferenceGeometry.class).bind(new ObjectBinding<IGeometry>() {
                {
                    bind(anchorage.layoutBoundsProperty());
                }

                @Override
                protected IGeometry computeValue() {
                    @SuppressWarnings({ ""serial"", ""restriction"" })
                    // get the registered geometry provider from the host
                    Provider<IGeometry> geomProvider = getAdaptable().getAdapter(new TypeToken<Provider<IGeometry>>() {
                    });
                    return geomProvider.get();
                }
            });
        }
        return anchor;
    }

}
"
ArchitectureModelPart.java,eclipse-ui,"package se.kau.cs.jittac.eclipse.ui.parts;

import java.util.List;

import org.eclipse.gef.mvc.fx.parts.AbstractContentPart;
import org.eclipse.gef.mvc.fx.parts.IVisualPart;

import com.google.common.collect.HashMultimap;
import com.google.common.collect.Lists;
import com.google.common.collect.SetMultimap;

import javafx.application.Platform;
import javafx.scene.Group;
import se.kau.cs.jittac.eclipse.ui.parts.ConnectorPart.ConnectorPartModelListener;
import se.kau.cs.jittac.model.am.AbstractArchitectureElement;
import se.kau.cs.jittac.model.am.ArchitectureModel;
import se.kau.cs.jittac.model.am.Component;
import se.kau.cs.jittac.model.am.Connector;
import se.kau.cs.jittac.model.am.events.AbstractArchitectureModelChangeListener;
import se.kau.cs.jittac.model.am.events.ConnectorAdditionEvent;
import se.kau.cs.jittac.model.am.events.ConnectorReferencesAddedEvent;
import se.kau.cs.jittac.model.am.events.ConnectorReferencesRemovedEvent;
import se.kau.cs.jittac.model.am.events.ConnectorRemovalEvent;
import se.kau.cs.jittac.model.am.events.ConnectorStateChangeEvent;
import javafx.scene.Group;
import javafx.scene.Node;

public class ArchitectureModelPart extends AbstractContentPart<Group> {
	
		private ArchitectureModelPartModelListener modelListener = new ArchitectureModelPartModelListener();
		
		private class ArchitectureModelPartModelListener extends AbstractArchitectureModelChangeListener {
			
			public void onConnectorRemoved(ConnectorRemovalEvent event) {
				Platform.runLater(new Runnable() {
					@Override
					public void run() {
						refreshContentChildren();
						refreshVisual();
					}
					
				});
			}
			
			public void onConnectorAdded(ConnectorAdditionEvent event) {
				Platform.runLater(new Runnable() {
					@Override
					public void run() {
						refreshContentChildren();
						refreshVisual();
					}
				});
			}
		}
		
	    @Override
	    protected void doAddChildVisual(IVisualPart<? extends Node> child, int index) {
	        getVisual().getChildren().add(child.getVisual());
	    }

	    @Override
	    protected void doAddContentChild(Object contentChild, int index) {
	        if (contentChild instanceof Component) {
	        	Component comp = (Component) contentChild;
	            getContent().createComponent(comp.getName(), comp.getId());
	        }
	        else if (contentChild instanceof Connector) {
	        	Connector con = (Connector) contentChild;
	        	getContent().createConnector(con.getSrc(), con.getTrg());
	        } else {
	            throw new IllegalArgumentException(""contentChild has invalid type: "" + contentChild.getClass());
	        }
	    }

	    @Override
	    protected Group doCreateVisual() {
	        // the visual is just a container for our child visuals (nodes and
	        // connections)
	        return new Group();
	    }

	    @Override
	    protected SetMultimap<? extends Object, String> doGetContentAnchorages() {
	        return HashMultimap.create();
	    }

	    @Override
	    protected List<? extends Object> doGetContentChildren() {
	    	List<AbstractArchitectureElement> result = Lists.newArrayList();
	    	result.addAll(getContent().getComponentsAsList());
	    	for (Connector con : getContent().getConnectorsAsList()) {
	    		if (!con.isReflexive()) {
	    			result.add(con);
	    		}
	    	}
	        return result;
	    }

	    @Override
	    protected void doRefreshVisual(Group visual) {
	        // no refreshing necessary, just a Group
	    }

	    @Override
	    protected void doRemoveChildVisual(IVisualPart<? extends Node> child, int index) {
	        getVisual().getChildren().remove(child.getVisual());
	    }

	    @Override
	    protected void doRemoveContentChild(Object contentChild) {
	        if (contentChild instanceof Component) {
	            getContent().removeComponent((Component) contentChild);
	        }
	        else if (contentChild instanceof Connector) {
	        	getContent().removeConnector((Connector) contentChild);
	        }
	        else {
	            throw new IllegalArgumentException(""contentChild has invalid type: "" + contentChild.getClass());
	        }
	    }

	    @Override
	    public ArchitectureModel getContent() {
	        return (ArchitectureModel) super.getContent();
	    }

	   @Override
	    public void setContent(Object content) {
	    	if (content != null) {
	    		if (!(content instanceof ArchitectureModel)) {
	    			return;
	    		}
	    	}
	    	ArchitectureModel oldContent = getContent();
	    	super.setContent(content);
	    	
	    	if (oldContent != null) {
	    		if (!oldContent.equals(content) && oldContent.getModel() != null) {
	    			oldContent.getModel().deregisterListener(modelListener);
	    		}
	    	}
	    	if (content != null) {
	    		if (!content.equals(oldContent)) {
	    			getContent().getModel().registerListener(modelListener);
	    		}
	    	}
	    }
}
"
ArchitectureModelPartsFactory.java,eclipse-ui,"package se.kau.cs.jittac.eclipse.ui.parts;

import java.util.Map;

import org.eclipse.gef.mvc.fx.parts.IContentPart;
import org.eclipse.gef.mvc.fx.parts.IContentPartFactory;

import com.google.inject.Inject;
import com.google.inject.Injector;

import javafx.scene.Node;
import se.kau.cs.jittac.model.am.ArchitectureModel;
import se.kau.cs.jittac.model.am.Component;
import se.kau.cs.jittac.model.am.Connector;

public class ArchitectureModelPartsFactory implements IContentPartFactory {

	@Inject
	private Injector injector;
	
	@Override
	public IContentPart<? extends Node> createContentPart(Object content, Map<Object, Object> contextMap) {
        if (content == null) {
            throw new IllegalArgumentException(""Content must not be null!"");
        }

        if (content instanceof ArchitectureModel) {
        	return injector.getInstance(ArchitectureModelPart.class);
        } else if (content instanceof Component) {
            return injector.getInstance(ComponentPart.class);
        } else if (content instanceof Connector) {
            return injector.getInstance(ConnectorPart.class);
        } else {
            throw new IllegalArgumentException(""Unknown content type <"" + content.getClass().getName() + "">"");
        }

	}

}
"
ComponentPart.java,eclipse-ui,"package se.kau.cs.jittac.eclipse.ui.parts;

import java.util.Collections;
import java.util.List;

import org.eclipse.core.commands.ExecutionException;
import org.eclipse.core.resources.IFile;
import org.eclipse.core.runtime.CoreException;
import org.eclipse.core.runtime.QualifiedName;
import org.eclipse.gef.mvc.fx.models.SelectionModel;
import org.eclipse.gef.mvc.fx.operations.ITransactionalOperation;
import org.eclipse.gef.mvc.fx.parts.AbstractContentPart;
import org.eclipse.gef.mvc.fx.parts.IContentPart;
import org.eclipse.gef.mvc.fx.parts.ITransformableContentPart;
import org.eclipse.gef.mvc.fx.viewer.IViewer;
import org.eclipse.swt.dnd.DropTarget;

import com.google.common.collect.HashMultimap;
import com.google.common.collect.SetMultimap;

import javafx.beans.value.ChangeListener;
import javafx.beans.value.ObservableValue;
import javafx.collections.ListChangeListener;
import javafx.collections.ObservableList;
import javafx.scene.Node;
import javafx.scene.transform.Affine;
import se.kau.cs.jittac.eclipse.Activator;
import se.kau.cs.jittac.eclipse.ModelManager;
import se.kau.cs.jittac.eclipse.ui.operations.SetComponentNameOperation;
import se.kau.cs.jittac.eclipse.ui.visuals.ComponentVisual;
import se.kau.cs.jittac.model.am.Component;
import se.kau.cs.jittac.model.am.Connector;

public class ComponentPart extends AbstractContentPart<ComponentVisual>
implements ITransformableContentPart<ComponentVisual> {

	private ListChangeListener<IContentPart<? extends Node>> selectionModelObserver =
			new ListChangeListener<IContentPart<? extends Node>>() {
		@Override
		public void onChanged(ListChangeListener.Change<? extends IContentPart<? extends Node>> c) {
			boolean removed = false;
			boolean added = false;
			IViewer viewer = getRoot().getViewer();
			SelectionModel selectionModel = viewer.getAdapter(SelectionModel.class);
			boolean currentlySelected = 
					selectionModel.getSelectionUnmodifiable().contains(ComponentPart.this);
			ComponentPart.this.getVisual().getNameText().setEditable(false);
			
			while (c.next()) {
				if (c.wasRemoved()) {
					if (c.getRemoved().contains(ComponentPart.this)) {
						removed = true;
					}
				}
				else if (c.wasAdded()) {
					if (!c.getAddedSubList().contains(ComponentPart.this)) {
						added = true;
					}
				}
			}
			if (!currentlySelected && removed
				|| currentlySelected && !added) {
				String newName = ComponentPart.this.getVisual().getNameText().getText();
				String oldName = getContent().getName();
				if (!newName.equals(oldName)) {
					ITransactionalOperation op = new SetComponentNameOperation(ComponentPart.this, newName);
					try {
						getRoot().getViewer().getDomain().execute(op, null);
					} catch (ExecutionException e) {
						e.printStackTrace();
					}
				}
				refreshVisual();
			}
		}
	};
	
	@Override
	protected void doActivate() {
		super.doActivate();
		IViewer viewer = getRoot().getViewer();
		
		SelectionModel selectionModel = viewer.getAdapter(SelectionModel.class);
		selectionModel.selectionUnmodifiableProperty().addListener(selectionModelObserver);
	}
	
	@Override
	protected void doDeactivate() {
		IViewer viewer = getRoot().getViewer();
		SelectionModel selectionModel = viewer.getAdapter(SelectionModel.class);
		selectionModel.selectionUnmodifiableProperty().removeListener(selectionModelObserver);
	}
	
	@Override
	protected SetMultimap<? extends Object, String> doGetContentAnchorages() {
		return HashMultimap.create();
	}

	@Override
	protected List<? extends Object> doGetContentChildren() {
		return Collections.emptyList();
	}

	@Override
	protected ComponentVisual doCreateVisual() {
		ComponentVisual visual = new ComponentVisual();
		try {
			IFile file = ModelManager.instance().getFile(getContent().getModel());
			String id = getContent().getId().toString();
			String xString = file.getPersistentProperty(new QualifiedName(Activator.PLUGIN_ID, id + ""_x""));
			String yString = file.getPersistentProperty(new QualifiedName(Activator.PLUGIN_ID, id + ""_y""));
			
			if (xString != null && yString != null) {
				visual.relocate(Double.parseDouble(xString), Double.parseDouble(yString));
			}
		} catch (NumberFormatException e) {
			e.printStackTrace();
		} catch (CoreException e) {
			e.printStackTrace();
		}
		return visual;
	}

	@Override
	protected void doRefreshVisual(ComponentVisual visual) {
		Component comp = getContent();
		visual.setName(comp.getName());

		//setVisualTransform(getContentTransform());
		 
        //visual.getParent().layout();
	}
	
    @Override
    protected void doRemoveContentChild(Object obj) {
    	if (!(obj instanceof Connector))
    		throw new IllegalArgumentException(""Argument must be of type Connector"");
    	Component comp = (Component) obj;
    	comp.getModel().removeComponent(comp);
    }
    
    @Override
    public Component getContent() {
    	return (Component) super.getContent();
    }

	@Override
	public Affine getContentTransform() {
		return getVisualTransform();
		//Bounds bounds = getVisual().getBoundsInParent();
        //return new Affine(new Translate(bounds.getMinX(), bounds.getMinY()));
	}

	@Override
	public void setContentTransform(Affine totalTransform) {
		setVisualTransform(totalTransform);
	}
}
"
ConnectorGeometricOutlineProvider.java,eclipse-ui,"package se.kau.cs.jittac.eclipse.ui.parts;

import org.eclipse.gef.geometry.planar.IGeometry;
import org.eclipse.gef.mvc.fx.providers.GeometricOutlineProvider;

import com.google.inject.Provider;

public class ConnectorGeometricOutlineProvider extends GeometricOutlineProvider implements Provider<IGeometry> {

	@Override
	public IGeometry get() {
		ConnectorPart part = (ConnectorPart) getAdaptable();
		return part.getVisual().getOutline();
	}
}
"
ConnectorPart.java,eclipse-ui,"package se.kau.cs.jittac.eclipse.ui.parts;

import java.util.Collections;
import java.util.List;

import org.eclipse.gef.common.adapt.AdapterKey;
import org.eclipse.gef.fx.anchors.IAnchor;
import org.eclipse.gef.mvc.fx.parts.AbstractContentPart;
import org.eclipse.gef.mvc.fx.parts.IContentPart;
import org.eclipse.gef.mvc.fx.parts.IVisualPart;

import com.google.common.collect.HashMultimap;
import com.google.common.collect.SetMultimap;
import com.google.common.reflect.TypeToken;
import com.google.inject.Provider;

import javafx.application.Platform;
import javafx.scene.Node;
import se.kau.cs.jittac.eclipse.ui.visuals.ConnectorVisual;
import se.kau.cs.jittac.model.am.Connector;
import se.kau.cs.jittac.model.am.events.AbstractArchitectureModelChangeListener;
import se.kau.cs.jittac.model.am.events.ConnectorReferencesAddedEvent;
import se.kau.cs.jittac.model.am.events.ConnectorReferencesRemovedEvent;
import se.kau.cs.jittac.model.am.events.ConnectorRemovalEvent;
import se.kau.cs.jittac.model.am.events.ConnectorStateChangeEvent;

public class ConnectorPart extends AbstractContentPart<ConnectorVisual> {

	    private static final String START_ROLE = ""START"";
	    private static final String END_ROLE = ""END"";
	    
	    private ConnectorPartModelListener modelListener = new ConnectorPartModelListener();

   
	    public class ConnectorPartModelListener extends AbstractArchitectureModelChangeListener {
	    	
	    	@Override
	    	public void onConnectorReferencesAdded(ConnectorReferencesAddedEvent event) {
	    		if (event.getModifiedConnector().equals(getContent())) {
					Platform.runLater(new Runnable() {
						@Override
						public void run() {
							refreshVisual();
						}
						
					});
	    		}
	    	}
	    	
	    	@Override
	    	public void onConnectorReferencesRemoved(ConnectorReferencesRemovedEvent event) {
	    		if (event.getModifiedConnector().equals(getContent())) {
					Platform.runLater(new Runnable() {
						@Override
						public void run() {
							refreshVisual();
						}
						
					});
	    		}
	    	}
	    	
	    	@Override
	    	public void onConnectorStateChange(ConnectorStateChangeEvent event) {
	    		if (event.getConnector().equals(getContent())) {
					Platform.runLater(new Runnable() {
						@Override
						public void run() {
							refreshVisual();
						}
						
					});
	    		}
	    	}
	    }
	    
	    @Override
	    protected void doAttachToAnchorageVisual(IVisualPart<? extends Node> anchorage, String role) {
	        // find a anchor provider, which must be registered in the module
	        // be aware to use the right interfaces (Provider is used a lot)
	        @SuppressWarnings({ ""serial"", ""restriction"" })
	        Provider<? extends IAnchor> adapter = anchorage
	                .getAdapter(AdapterKey.get(new TypeToken<Provider<? extends IAnchor>>() {
	                }));
	        if (adapter == null) {
	            throw new IllegalStateException(""No adapter  found for <"" + anchorage.getClass() + ""> found."");
	        }
	        IAnchor anchor = adapter.get();

	        if (role.equals(START_ROLE)) {
	            getVisual().getConnection().setStartAnchor(anchor);
	        } else if (role.equals(END_ROLE)) {
	            getVisual().getConnection().setEndAnchor(anchor);
	        } else {
	            throw new IllegalArgumentException(""Invalid role: "" + role);
	        }
	    }

	    @Override
	    protected ConnectorVisual doCreateVisual() {

	        return new ConnectorVisual();
	    }

	    @Override
	    protected void doDetachFromAnchorageVisual(IVisualPart<? extends Node> anchorage, String role) {
	        if (role.equals(START_ROLE)) {
	            getVisual().getConnection().setStartPoint(getVisual().getConnection().getStartPoint());
	        } else if (role.equals(END_ROLE)) {
	            getVisual().getConnection().setEndPoint(getVisual().getConnection().getEndPoint());
	        } else {
	            throw new IllegalArgumentException(""Invalid role: "" + role);
	        }
	    }
	    
/*	    @Override
	    protected void doDetachFromContentAnchorage(Object contentAnchorage, String role) {
	    	
	    }*/

	    @Override
	    protected SetMultimap<? extends Object, String> doGetContentAnchorages() {
	        SetMultimap<Object, String> anchorages = HashMultimap.create();

	        if (getContent().getModel() != null) {
	        	anchorages.put(getContent().getSrc(), START_ROLE);
	        	anchorages.put(getContent().getTrg(), END_ROLE);
	        }
	        return anchorages;
	    }

	    @Override
	    protected List<? extends Object> doGetContentChildren() {
	        return Collections.emptyList();
	    }

	/*    @Override
	    protected void doRemoveContentChild(Object obj) {
	    	if (!(obj instanceof Connector))
	    		throw new IllegalArgumentException(""Argument must be of type Connector"");
	    	Connector conn = (Connector) obj;
	    	conn.getModel().removeConnector(conn);
	    }*/
	    
	    @Override
	    protected void doRefreshVisual(ConnectorVisual visual) {
			Connector con = getContent();
			String s = Integer.toString(con.getContributingReferences().size());
			visual.setLabel(s);
			//setVisualTransform(getContentTransform());
			//set stroke based on content 
			visual.setStrokeStyle(con.getContributingReferences().size(), con.isEnvisaged());
	       // visual.getParent().layout();
	    }

	    @Override
	    public Connector getContent() {
	    	return (Connector) super.getContent();
	    }
	    
	    @Override
	    public void setContent(Object content) {
	    	if (content != null) {
	    		if (!(content instanceof Connector)) {
	    			return;
	    		}
	    	}
	    	Connector oldContent = getContent();
	    	super.setContent(content);
	    	
	    	if (oldContent != null) {
	    		if (!oldContent.equals(content) && oldContent.getModel() != null) {
	    			oldContent.getModel().deregisterListener(modelListener);
	    		}
	    	}
	    	if (content != null) {
	    		if (!content.equals(oldContent)) {
	    			getContent().getModel().registerListener(modelListener);
	    		}
	    	}
	    }

}
"
ConnectorSelectionFeedbackPart.java,eclipse-ui,"package se.kau.cs.jittac.eclipse.ui.parts;

import org.eclipse.gef.fx.nodes.GeometryNode;
import org.eclipse.gef.geometry.planar.IGeometry;
import org.eclipse.gef.mvc.fx.parts.SelectionFeedbackPart;

import javafx.scene.shape.StrokeType;

public class ConnectorSelectionFeedbackPart extends SelectionFeedbackPart {

	public ConnectorSelectionFeedbackPart() {
		
	}
	
	@Override
	protected GeometryNode<IGeometry> doCreateVisual() {
		GeometryNode<IGeometry> feedbackVisual = super.doCreateVisual();
		feedbackVisual.setStrokeWidth(3);
		feedbackVisual.setStrokeType(StrokeType.INSIDE);
		
		return feedbackVisual;
	}
}
"
CreateConnectorFeedbackPart.java,eclipse-ui,"package se.kau.cs.jittac.eclipse.ui.parts;

import org.eclipse.gef.common.adapt.AdapterKey;
import org.eclipse.gef.fx.anchors.IAnchor;
import org.eclipse.gef.fx.anchors.StaticAnchor;
import org.eclipse.gef.fx.nodes.Connection;
import org.eclipse.gef.geometry.convert.fx.FX2Geometry;
import org.eclipse.gef.geometry.convert.fx.Geometry2FX;
import org.eclipse.gef.geometry.planar.Point;
import org.eclipse.gef.mvc.fx.parts.AbstractFeedbackPart;
import org.eclipse.gef.mvc.fx.parts.IVisualPart;

import com.google.common.reflect.TypeToken;
import com.google.inject.Provider;

import javafx.event.EventHandler;
import javafx.scene.Node;
import javafx.scene.input.MouseEvent;

public class CreateConnectorFeedbackPart extends AbstractFeedbackPart<Node> {

	@Override
	protected Node doCreateVisual() {
		return new Connection();
	}

	@Override
	protected void doRefreshVisual(Node visual) {
	}
	
	@Override
	public void doAttachToAnchorageVisual(IVisualPart<? extends Node> anchorage, String role) {
		// find a anchor provider, which must be registered in the module
		// be aware to use the right interfaces (Proviser is used a lot)
		@SuppressWarnings(""serial"")
		Provider<? extends IAnchor> adapter = anchorage
				.getAdapter(AdapterKey.get(new TypeToken<Provider<? extends IAnchor>>() {
				}));
		if (adapter == null) {
			throw new IllegalStateException(""No adapter  found for <"" + anchorage.getClass() + ""> found."");
		}
		// set the start anchor
		IAnchor anchor = adapter.get();
		getVisual().setStartAnchor(anchor);

		MousePositionAnchor endAnchor = new MousePositionAnchor(
                                FX2Geometry.toPoint(getVisual().localToScene(
                                        Geometry2FX.toFXPoint(getVisual().getStartPoint()))));
		endAnchor.init();
		getVisual().setEndAnchor(endAnchor);
	}
	
	@Override
	protected void doDetachFromAnchorageVisual(IVisualPart<? extends Node> anchorage, String role) {
		getVisual().setStartPoint(getVisual().getStartPoint());
		((MousePositionAnchor) getVisual().getEndAnchor()).dispose();
		getVisual().setEndPoint(getVisual().getEndPoint());
	}
	
	@Override
	public Connection getVisual() {
		return (Connection) super.getVisual();
	}
	
	private class MousePositionAnchor extends StaticAnchor implements EventHandler<MouseEvent>{

		public MousePositionAnchor(Point referencePositionInScene) {
			super(referencePositionInScene);
		}
		
		public void init() {
			// listen to any mouse move and reposition the anchor
			getRoot().getVisual().getScene().addEventHandler(MouseEvent.MOUSE_MOVED, this);
		}
		
		@Override
		public void handle(MouseEvent event) {
			Point v = new Point(event.getSceneX(), event.getSceneY());
			referencePositionProperty().setValue(v);
		}
		
		public void dispose() {
			// listen to any mouse move and reposition the anchor
			getRoot().getVisual().getScene().removeEventHandler(MouseEvent.MOUSE_MOVED, this);
		}
		
	}

}
"
CreateConnectorFeedbackPartBehavior.java,eclipse-ui,"package se.kau.cs.jittac.eclipse.ui.parts;

import org.eclipse.gef.mvc.fx.behaviors.AbstractBehavior;
import org.eclipse.gef.mvc.fx.parts.IFeedbackPartFactory;
import org.eclipse.gef.mvc.fx.viewer.IViewer;

import se.kau.cs.jittac.eclipse.ui.models.ItemCreationModel;

public class CreateConnectorFeedbackPartBehavior extends AbstractBehavior {

	/**
	 * The adapter role for the {@link IFeedbackPartFactory} that is used to
	 * generate hover feedback parts.
	 */
	public static final String CREATE_FEEDBACK_PART_FACTORY = ""CREATE_FEEDBACK_PART_FACTORY"";

	@Override
	protected void doActivate() {

		ItemCreationModel model = getHost().getRoot().getViewer().getAdapter(ItemCreationModel.class);
		model.getSourceProperty().addListener((o, oldVal, newVal) -> {
			if (newVal == null) {
				clearFeedback(); // no source set, so no feedback
			} else {
				addFeedback(newVal); // we have source, start the feedback
			}
		});

		super.doActivate();
	}

	@Override
	protected IFeedbackPartFactory getFeedbackPartFactory(IViewer viewer) {
		return getFeedbackPartFactory(viewer, CREATE_FEEDBACK_PART_FACTORY);
	}
}
"
CreateConnectorFeedbackPartFactory.java,eclipse-ui,"package se.kau.cs.jittac.eclipse.ui.parts;

import java.util.List;
import java.util.Map;

import org.eclipse.gef.mvc.fx.parts.IFeedbackPart;
import org.eclipse.gef.mvc.fx.parts.IFeedbackPartFactory;
import org.eclipse.gef.mvc.fx.parts.IVisualPart;

import com.google.common.collect.Lists;
import com.google.inject.Inject;
import com.google.inject.Injector;

import javafx.scene.Node;

public class CreateConnectorFeedbackPartFactory implements IFeedbackPartFactory {

	@Inject
	Injector injector;
	
	@Override
	public List<IFeedbackPart<? extends Node>> createFeedbackParts(List<? extends IVisualPart<? extends Node>> targets,
			Map<Object, Object> contextMap) {

		List<IFeedbackPart<? extends Node>> parts = Lists.newArrayList();
		
		if (targets.isEmpty())
			return parts; // shouldn't happen, just to be sure
		
		// we just expect one target
		IVisualPart< ? extends Node> target = targets.get(0);
		
		if (target instanceof ComponentPart) {
			// a MindMapNode target is the source of a connection so we create the connection feedback
			CreateConnectorFeedbackPart part = injector.getInstance(CreateConnectorFeedbackPart.class);
			parts.add(part);
		}

		return parts;
	}

}
"
HoverFeedbackPartFactory.java,eclipse-ui,"package se.kau.cs.jittac.eclipse.ui.parts;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;

import org.eclipse.gef.common.adapt.AdapterKey;
import org.eclipse.gef.fx.utils.NodeUtils;
import org.eclipse.gef.geometry.planar.IGeometry;
import org.eclipse.gef.mvc.fx.parts.DefaultHoverFeedbackPartFactory;
import org.eclipse.gef.mvc.fx.parts.HoverFeedbackPart;
import org.eclipse.gef.mvc.fx.parts.IFeedbackPart;
import org.eclipse.gef.mvc.fx.parts.IFeedbackPartFactory;
import org.eclipse.gef.mvc.fx.parts.IVisualPart;

import com.google.common.reflect.TypeToken;
import com.google.inject.Inject;
import com.google.inject.Injector;
import com.google.inject.Provider;

import javafx.scene.Node;

public class HoverFeedbackPartFactory extends DefaultHoverFeedbackPartFactory implements IFeedbackPartFactory {

	@Inject
	private Injector injector;
	
	@Override
	public List<IFeedbackPart<? extends Node>> createFeedbackParts(
			List<? extends IVisualPart<? extends Node>> targets,
			Map<Object, Object> contextMap) {
		// check that we have targets
		if (targets == null || targets.isEmpty()) {
			throw new IllegalArgumentException(
					""Part factory is called without targets."");
		}
		if (targets.size() > 1) {
			throw new IllegalArgumentException(
					""Cannot create feedback for multiple targets."");
		}

		final IVisualPart<? extends Node> target = targets.get(0);

		
		List<IFeedbackPart<? extends Node>> feedbackParts = new ArrayList<>();

		// determine feedback geometry
		
		@SuppressWarnings(""serial"")
		final Provider<? extends IGeometry> hoverFeedbackGeometryProvider = target
				.getAdapter(AdapterKey
						.get(new TypeToken<Provider<? extends IGeometry>>() {
						}, HOVER_FEEDBACK_GEOMETRY_PROVIDER));
		if (hoverFeedbackGeometryProvider != null) {
			Provider<IGeometry> geometryInSceneProvider = new Provider<IGeometry>() {
				@Override
				public IGeometry get() {
					Node n;
					if (target instanceof ConnectorPart) {
						n = ((ConnectorPart) target).getVisual().getConnection();
					}
					else {
						n = target.getVisual();
					}
					return NodeUtils.localToScene(n, hoverFeedbackGeometryProvider.get());
				}
			};
			HoverFeedbackPart part = injector
					.getInstance(HoverFeedbackPart.class);
			part.setGeometryProvider(geometryInSceneProvider);
			feedbackParts.add(part);
		}

		return feedbackParts;
	}

}
"
SelectionColorProvider.java,eclipse-ui,"package se.kau.cs.jittac.eclipse.ui.parts;

import com.google.inject.Provider;

import javafx.scene.paint.Color;

public class SelectionColorProvider implements Provider<Color> {

	@Override
	public Color get() {
		return Color.web(""#00008866"");
	}

}
"
AbortConnectorCreationStrokeHandler.java,eclipse-ui,"package se.kau.cs.jittac.eclipse.ui.policies;

import org.eclipse.gef.mvc.fx.behaviors.AbstractBehavior;
import org.eclipse.gef.mvc.fx.handlers.IOnStrokeHandler;

import javafx.scene.input.KeyCode;
import javafx.scene.input.KeyEvent;
import se.kau.cs.jittac.eclipse.ui.models.ItemCreationModel;

public class AbortConnectorCreationStrokeHandler extends AbstractBehavior implements IOnStrokeHandler {

	@Override
	public void abortPress() {

	}

	@Override
	public void finalRelease(KeyEvent event) {
	}

	@Override
	public void initialPress(KeyEvent event) {

		if (!(event.getCode() == KeyCode.ESCAPE ||
				event.getCode() == KeyCode.DELETE)) 
			return;

		ItemCreationModel model =
				getHost().getRoot().
					getViewer().getAdapter(ItemCreationModel.class);
		if (model.getType() != ItemCreationModel.Type.Connector) 
			return;
		if (model.getSource() == null)
			return;
		model.setSource(null);
		model.setType(ItemCreationModel.Type.None);
	}

	@Override
	public void press(KeyEvent event) {
	}

	@Override
	public void release(KeyEvent event) {
	}

}
"
ComponentOnDragHandler.java,eclipse-ui,"package se.kau.cs.jittac.eclipse.ui.policies;

import org.eclipse.core.resources.IFile;
import org.eclipse.core.runtime.CoreException;
import org.eclipse.core.runtime.QualifiedName;
import org.eclipse.gef.geometry.planar.Dimension;
import org.eclipse.gef.mvc.fx.handlers.TranslateSelectedOnDragHandler;

import javafx.scene.input.MouseEvent;
import se.kau.cs.jittac.eclipse.Activator;
import se.kau.cs.jittac.eclipse.ModelManager;
import se.kau.cs.jittac.eclipse.ui.parts.ComponentPart;

public class ComponentOnDragHandler extends TranslateSelectedOnDragHandler {

	@Override
	public void endDrag(MouseEvent e, Dimension delta) {
		super.endDrag(e, delta);
		try {
			if (getHost() instanceof ComponentPart) {
				ComponentPart part = (ComponentPart) getHost();
				double xpos = part.getVisual().getLayoutX() + delta.getWidth();
				double ypos = part.getVisual().getLayoutY() + delta.getHeight();
				IFile file = ModelManager.instance().getFile(part.getContent().getModel());
				String id = part.getContent().getId().toString();
				file.setPersistentProperty(new QualifiedName(Activator.PLUGIN_ID, id + ""_x""), Double.toString(xpos));
				file.setPersistentProperty(new QualifiedName(Activator.PLUGIN_ID, id + ""_y""), Double.toString(ypos));
			}
		} catch (CoreException e1) {
			e1.printStackTrace();
		}
	}
}
"
CreateComponentOnClickHandler.java,eclipse-ui,"package se.kau.cs.jittac.eclipse.ui.policies;

import org.eclipse.gef.mvc.fx.handlers.AbstractHandler;
import org.eclipse.gef.mvc.fx.handlers.IOnClickHandler;
import org.eclipse.gef.mvc.fx.parts.IContentPart;
import org.eclipse.gef.mvc.fx.parts.IRootPart;
import org.eclipse.gef.mvc.fx.parts.IVisualPart;
import org.eclipse.gef.mvc.fx.policies.CreationPolicy;
import org.eclipse.gef.mvc.fx.viewer.IViewer;

import com.google.common.collect.HashMultimap;

import javafx.geometry.Point2D;
import javafx.scene.Node;
import javafx.scene.input.MouseEvent;
import se.kau.cs.jittac.eclipse.ui.models.ItemCreationModel;
import se.kau.cs.jittac.eclipse.ui.parts.ArchitectureModelPart;
import se.kau.cs.jittac.eclipse.ui.parts.ComponentPart;
import se.kau.cs.jittac.model.am.Component;

public class CreateComponentOnClickHandler extends AbstractHandler implements IOnClickHandler {

	@Override
	public void click(MouseEvent e) {
		if (!e.isPrimaryButtonDown()) {
			return; // wrong mouse button
		}

		IViewer viewer = getHost().getRoot().getViewer();
		ItemCreationModel creationModel = viewer.getAdapter(ItemCreationModel.class);
		if (creationModel == null) {
			throw new IllegalStateException(""No ItemCreationModel bound to viewer!"");
		}

		if (creationModel.getType() != ItemCreationModel.Type.Component) {
			// don't want to create a node
			return;
		}
		IVisualPart<? extends Node> part = viewer.getRootPart().getChildrenUnmodifiable().get(0);

		if (part instanceof ArchitectureModelPart) {
			ArchitectureModelPart  amp = (ArchitectureModelPart) part;
			// calculate the mouse coordinates
			// determine coordinates of new nodes origin in model coordinates
			Point2D mouseInLocal = part.getVisual().sceneToLocal(e.getSceneX(), e.getSceneY());

			Component comp = Component.createComponent(amp.getContent());

			// GEF provides the CreatePolicy and operations to add a new element
			// to the model
			IRootPart<? extends Node> root = getHost().getRoot();
			// get the policy bound to the IRootPart
			CreationPolicy creationPolicy = root.getAdapter(CreationPolicy.class);
			// initialize the policy
			init(creationPolicy);
			// create a IContentPart for our new model. We don't use the
			// returned content-part

			//creationPolicy.create(comp, amp,
			//		HashMultimap.<IContentPart<? extends Node>, String>create());
			
			IContentPart<?> newPart = creationPolicy.create(comp, amp,
					amp.getContent().getComponents().size(),
					HashMultimap.<IContentPart<? extends Node>, String>create(),
					true, true); 
			// execute the creation
			commit(creationPolicy);
			((ComponentPart) newPart).getVisual().setLayoutX(mouseInLocal.getX());
			((ComponentPart) newPart).getVisual().setLayoutY(mouseInLocal.getY());
		}
		// clear the creation selection
		creationModel.setType(ItemCreationModel.Type.None);


	}

}
"
CreateConnectorOnClickHandler.java,eclipse-ui,"package se.kau.cs.jittac.eclipse.ui.policies;

import java.util.Collections;

import org.eclipse.core.commands.ExecutionException;
import org.eclipse.gef.mvc.fx.handlers.AbstractHandler;
import org.eclipse.gef.mvc.fx.handlers.IOnClickHandler;
import org.eclipse.gef.mvc.fx.operations.ChangeSelectionOperation;
import org.eclipse.gef.mvc.fx.operations.ITransactionalOperation;
import org.eclipse.gef.mvc.fx.parts.IContentPart;
import org.eclipse.gef.mvc.fx.parts.IRootPart;
import org.eclipse.gef.mvc.fx.parts.IVisualPart;
import org.eclipse.gef.mvc.fx.policies.CreationPolicy;
import org.eclipse.gef.mvc.fx.viewer.IViewer;

import com.google.common.collect.HashMultimap;
import com.google.common.reflect.TypeToken;
import javafx.scene.Node;
import javafx.scene.input.MouseEvent;
import se.kau.cs.jittac.eclipse.ui.models.ItemCreationModel;
import se.kau.cs.jittac.eclipse.ui.operations.MarkConnectorAsEnvisagedOperation;
import se.kau.cs.jittac.eclipse.ui.parts.ArchitectureModelPart;
import se.kau.cs.jittac.eclipse.ui.parts.ComponentPart;
import se.kau.cs.jittac.model.am.Connector;

public class CreateConnectorOnClickHandler extends AbstractHandler implements IOnClickHandler {

	@Override
	public void click(MouseEvent e) {
		if (!e.isPrimaryButtonDown()) {
			return; 
		}
		
		IViewer viewer = getHost().getRoot().getViewer();
		ItemCreationModel creationModel = viewer.getAdapter(ItemCreationModel.class);
		if (creationModel.getType() != ItemCreationModel.Type.Connector) {
			return; // don't want to create a connection
		}
		
		if (creationModel.getSource()==null) {
			// the host is the source
			creationModel.setSource((ComponentPart) getHost());
			return; // wait for the next click
		}
		
		// okay, we have a pair
		ComponentPart source = creationModel.getSource();
		ComponentPart target = (ComponentPart) getHost();

        // check if valid
        if (source == target) {
                return;
        }
  
		IRootPart<? extends Node> root = getHost().getRoot();
		// get the policy bound to the IRootPart
		@SuppressWarnings(""serial"")
		CreationPolicy creationPolicy = root.getAdapter(new TypeToken<CreationPolicy>() {});
		// initialize the policy
		init(creationPolicy);
        
        IVisualPart<? extends Node> part = getHost().getRoot().getChildrenUnmodifiable().get(0);
		if (part instanceof ArchitectureModelPart) {
			ArchitectureModelPart amPart = (ArchitectureModelPart) part;
			Connector conn = amPart.getContent().getConnectorByComponents(source.getContent(), target.getContent());
			if (conn != null) {
				if (!conn.isEnvisaged()) {
					ITransactionalOperation op = new MarkConnectorAsEnvisagedOperation(conn);
					conn.getModel().changeConnectorState(conn, true);
					try {
						viewer.getDomain().execute(op, null);
					} catch (ExecutionException exc) {
						exc.printStackTrace();
					}
				}
			}
			else {
				conn = Connector.createConnector(source.getContent(), target.getContent());
				// create a IContentPart for our new model. We don't use the
				// returned content-part
				creationPolicy.create(conn, (ArchitectureModelPart) part,
						HashMultimap.<IContentPart<? extends Node>, String>create());
				// execute the creation

			}
			commit(creationPolicy);
            try {
                    viewer.getDomain().execute(new ChangeSelectionOperation(viewer, Collections.singletonList(target)),
                                    null);
            } catch (ExecutionException e1) {
            }
            amPart.refreshContentChildren();
    		// finally reset creationModel
    		creationModel.setSource(null);
    		creationModel.setType(ItemCreationModel.Type.None);
		}
	}
}
"
ShowArchitectureElementContextMenuOnClickHandler.java,eclipse-ui,"package se.kau.cs.jittac.eclipse.ui.policies;

import java.util.ArrayList;

import org.eclipse.gef.mvc.fx.handlers.AbstractHandler;
import org.eclipse.gef.mvc.fx.handlers.IOnClickHandler;
import org.eclipse.gef.mvc.fx.models.HoverModel;
import org.eclipse.gef.mvc.fx.parts.IContentPart;
import org.eclipse.gef.mvc.fx.parts.IRootPart;
import org.eclipse.gef.mvc.fx.parts.IVisualPart;
import org.eclipse.gef.mvc.fx.policies.DeletionPolicy;

import javafx.scene.Node;
import javafx.scene.control.ContextMenu;
import javafx.scene.control.MenuItem;
import javafx.scene.input.MouseEvent;
import se.kau.cs.jittac.eclipse.ui.parts.ConnectorPart;
import se.kau.cs.jittac.model.am.Connector;

public class ShowArchitectureElementContextMenuOnClickHandler extends AbstractHandler implements IOnClickHandler {

	private ContextMenu openContextMenu = null;
	
	@Override
	public void click(MouseEvent event) {
		if (openContextMenu != null) openContextMenu.hide();
		if (!event.isSecondaryButtonDown()) {
			return; // only listen to secondary buttons
		}

		
		MenuItem deleteElementItem = new MenuItem(""Delete"");

		
		if (getHost() instanceof ConnectorPart) {
			Connector conn = ((ConnectorPart) getHost()).getContent();
			if (!conn.isEnvisaged()) {
				deleteElementItem.setDisable(true);
			}
		}
		
		deleteElementItem.setOnAction((e) -> {

			HoverModel hover = getHost().getViewer().getAdapter(HoverModel.class);
			if (getHost() == hover.getHover()) {
				hover.clearHover();
			}

			// query DeletionPolicy for the removal of the host part
			IRootPart<? extends Node> root = getHost().getRoot();
			DeletionPolicy delPolicy = root.getAdapter(DeletionPolicy.class);
			init(delPolicy);

			// delete all anchored connection parts
			for (IVisualPart<? extends Node> a : new ArrayList<>(getHost().getAnchoredsUnmodifiable())) {
				if (a instanceof ConnectorPart) {
					delPolicy.delete((IContentPart<? extends Node>) a);
				}
			}

			if (getHost() instanceof ConnectorPart) {
				Connector conn = ((ConnectorPart) getHost()).getContent();
				
				if (conn.getState() == Connector.STATE.ABSENCE) {
					delPolicy.delete((IContentPart<? extends Node>) getHost());
				}
				else {
					conn.getModel().makeConnectorUnenvisaged(conn);
				}
	
			}
			else {
				// delete the node part
				delPolicy.delete((IContentPart<? extends Node>) getHost());
			}
			
			
			commit(delPolicy);
		});

		
		ContextMenu contextMenu = new ContextMenu(deleteElementItem);
		contextMenu.show((Node) event.getTarget(), event.getScreenX(), event.getScreenY());
		openContextMenu = contextMenu;
	}

}
"
ShowArchitectureModelContextMenuOnClickHandler.java,eclipse-ui,"package se.kau.cs.jittac.eclipse.ui.policies;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.text.SimpleDateFormat;
import java.util.Date;

import org.eclipse.core.resources.IFile;
import org.eclipse.core.runtime.IPath;
import org.eclipse.gef.mvc.fx.handlers.AbstractHandler;
import org.eclipse.gef.mvc.fx.handlers.IOnClickHandler;

import javafx.scene.Node;
import javafx.scene.control.ContextMenu;
import javafx.scene.control.MenuItem;
import javafx.scene.input.ContextMenuEvent;
import javafx.scene.input.MouseEvent;
import se.kau.cs.jittac.eclipse.ModelManager;
import se.kau.cs.jittac.eclipse.ui.parts.ArchitectureModelPart;
import se.kau.cs.jittac.model.am.ArchitectureModel;
import se.kau.cs.jittac.model.report.PlainTextViolationReporter;

public class ShowArchitectureModelContextMenuOnClickHandler extends AbstractHandler implements IOnClickHandler {

	private ContextMenu openContextMenu;
	SimpleDateFormat sdf = new SimpleDateFormat(""yyyy-MM-dd-HH-mm-ss"");
	
	@Override
	public void click(MouseEvent event) {
		if (openContextMenu != null) openContextMenu.hide();
		MenuItem reportItem = new MenuItem(""Generate Report"");
		ContextMenu contextMenu = new ContextMenu(reportItem);
		openContextMenu = contextMenu;
		
		if (!event.isSecondaryButtonDown()) {
			return; // only listen to secondary buttons
		}
		
		reportItem.setOnAction((e) -> {
			if (getHost() == getHost().getRoot()) {
				ArchitectureModel model = ((ArchitectureModelPart) getHost().getChildrenUnmodifiable().get(0)).getContent();
				IFile modelFile = ModelManager.instance().getFile(model); 
				IPath modelDir = modelFile.getLocation();
				modelDir = modelDir.uptoSegment(modelDir.segmentCount() - 1);
				String reportFileName = modelFile.getName() + ""-"" + sdf.format(new Date(System.currentTimeMillis())) + "".txt"";
				IPath reportPath = modelDir.append(reportFileName);
		        File file = reportPath.toFile();
		        if (file.exists()) {
		        	file.delete();
		        }
				try {
					file.createNewFile();
					if (file.canWrite()) {
						OutputStream out = new FileOutputStream(file);
						PlainTextViolationReporter.write(out, model);
						out.flush();
						out.close();
					}
				} catch (FileNotFoundException ex) {
					// TODO Auto-generated catch block
					ex.printStackTrace();
				} catch (IOException ex) {
				}
			}
		});
	
		contextMenu.show((Node) event.getTarget(), event.getScreenX(), event.getScreenY());
	}

	
}
"
TestOnDragHandler.java,eclipse-ui,"package se.kau.cs.jittac.eclipse.ui.policies;

import org.eclipse.gef.geometry.planar.Dimension;
import org.eclipse.gef.mvc.fx.handlers.AbstractHandler;
import org.eclipse.gef.mvc.fx.handlers.IOnDragHandler;

import javafx.scene.input.KeyEvent;
import javafx.scene.input.MouseEvent;

public class TestOnDragHandler extends AbstractHandler implements IOnDragHandler {

	@Override
	public void abortDrag() {
		// TODO Auto-generated method stub

	}

	@Override
	public void drag(MouseEvent e, Dimension delta) {
		// TODO Auto-generated method stub

	}

	@Override
	public void endDrag(MouseEvent e, Dimension delta) {
		System.out.println(""End of drag"");

	}

	@Override
	public void hideIndicationCursor() {
		// TODO Auto-generated method stub

	}

	@Override
	public boolean showIndicationCursor(KeyEvent event) {
		// TODO Auto-generated method stub
		return false;
	}

	@Override
	public boolean showIndicationCursor(MouseEvent event) {
		// TODO Auto-generated method stub
		return false;
	}

	@Override
	public void startDrag(MouseEvent e) {
		// TODO Auto-generated method stub

	}

}
"
ArchitectureModelView.java,eclipse-ui,"package se.kau.cs.jittac.eclipse.ui.views;

import org.eclipse.gef.common.adapt.AdapterKey;
import org.eclipse.gef.mvc.fx.models.FocusModel;
import org.eclipse.gef.mvc.fx.models.HoverModel;
import org.eclipse.gef.mvc.fx.models.SelectionModel;
import org.eclipse.gef.mvc.fx.ui.actions.FitToViewportAction;
import org.eclipse.gef.mvc.fx.ui.actions.FitToViewportLockAction;
import org.eclipse.gef.mvc.fx.ui.actions.ScrollActionGroup;
import org.eclipse.gef.mvc.fx.ui.actions.ZoomActionGroup;
import org.eclipse.gef.mvc.fx.ui.parts.AbstractFXView;
import org.eclipse.gef.mvc.fx.viewer.IViewer;
import org.eclipse.jface.action.IToolBarManager;
import org.eclipse.jface.action.Separator;
import org.eclipse.swt.widgets.Composite;
import org.eclipse.ui.IActionBars;

import com.google.inject.Guice;
import com.google.inject.util.Modules;

import javafx.scene.Scene;
import se.kau.cs.jittac.eclipse.ui.ArchitectureModelModule;
import se.kau.cs.jittac.eclipse.ui.ArchitectureModelModuleUI;

public class ArchitectureModelView extends AbstractFXView {

	
	private ZoomActionGroup zoomActionGroup;
	private ScrollActionGroup scrollActionGroup;
	private FitToViewportLockAction fitToViewportLockAction;
	
	
	public ArchitectureModelView() {
		super(Guice.createInjector(Modules.override(new ArchitectureModelModule())
				.with(new ArchitectureModelModuleUI())));
	}

	
	@Override
	public void createPartControl(Composite parent) {
		super.createPartControl(parent);
		
		// create actions
		zoomActionGroup = new ZoomActionGroup(new FitToViewportAction());
		getContentViewer().setAdapter(zoomActionGroup);
		
		fitToViewportLockAction = new FitToViewportLockAction();
		getContentViewer().setAdapter(fitToViewportLockAction);
		
		scrollActionGroup = new ScrollActionGroup();
		getContentViewer().setAdapter(scrollActionGroup);
		
		// contribute to toolbar
		IActionBars actionBars = getViewSite().getActionBars();
		IToolBarManager mgr = actionBars.getToolBarManager();
		zoomActionGroup.fillActionBars(actionBars);
		mgr.add(new Separator());
		mgr.add(fitToViewportLockAction);
		mgr.add(new Separator());
		scrollActionGroup.fillActionBars(actionBars);
	}
	
	@Override
	public void dispose() {
		// clear viewer models
		getContentViewer().getAdapter(SelectionModel.class).clearSelection();
		getContentViewer().getAdapter(HoverModel.class).clearHover();
		getContentViewer().getAdapter(FocusModel.class).setFocus(null);
		getContentViewer().contentsProperty().clear();
		/*getPaletteViewer().getAdapter(SelectionModel.class).clearSelection();
		getPaletteViewer().getAdapter(HoverModel.class).clearHover();
		getPaletteViewer().getAdapter(FocusModel.class).setFocus(null);
		getPaletteViewer().contentsProperty().clear();*/

		// dispose actions
		if (zoomActionGroup != null) {
			getContentViewer().unsetAdapter(zoomActionGroup);
			zoomActionGroup.dispose();
			zoomActionGroup = null;
		}
		if (scrollActionGroup != null) {
			getContentViewer().unsetAdapter(scrollActionGroup);
			scrollActionGroup.dispose();
			scrollActionGroup = null;
		}
		if (fitToViewportLockAction != null) {
			getContentViewer().unsetAdapter(fitToViewportLockAction);
			fitToViewportLockAction = null;
		}

		super.dispose();
	}
	
	@Override
	protected void hookViewers() {
		// build viewers composite
		//MvcLogoExampleViewersComposite viewersComposite = new MvcLogoExampleViewersComposite(
		//		getContentViewer(), getPaletteViewer());
		// create scene and populate canvas
		//getCanvas().setScene(new Scene(viewersComposite.getComposite()));
		getCanvas().setScene(new Scene(getContentViewer().getCanvas()));
	}
}
"
BrowserView.java,eclipse-ui,"package se.kau.cs.jittac.eclipse.ui.views;


import org.eclipse.core.runtime.FileLocator;
import org.eclipse.ui.PartInitException;
import org.eclipse.ui.PlatformUI;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.net.MalformedURLException;
import java.net.URISyntaxException;
import java.net.URL;
import java.util.ArrayList;

public class BrowserView
{
	private static boolean hasData()
	{		
		try
		{
			URL dataFileUrl = new URL( ""platform:/plugin/se.kau.cs.jittac.eclipse/resources/data.json"" );
			InputStream inputStream = dataFileUrl.openConnection().getInputStream();
	    	BufferedReader in = new BufferedReader( new InputStreamReader( inputStream ) );
		    String inputLine = in.readLine();
		    
		    if( inputLine.equals( ""no feature dependencies"" ) )
		    {
		        return false;
		    }
		 
		    in.close();
		}
		catch( IOException e )
		{ 	
			e.printStackTrace();
		}
		
		return true;
	}
	
	public static void openBrowser()
	{	
		String browserID = ""JittacBrowser"";
		ArrayList<URL> url = new ArrayList<URL>();

		try
		{
			if( hasData() )
			{
				url.add( new URL( ""platform:/plugin/se.kau.cs.jittac.eclipse/resources/headerA.html"" ) );
				url.add( new URL( ""platform:/plugin/se.kau.cs.jittac.eclipse/resources/headerB.html"" ) );
				url.add( new URL( ""platform:/plugin/se.kau.cs.jittac.eclipse/resources/headerC.html"" ) );
				url.add( new URL( ""platform:/plugin/se.kau.cs.jittac.eclipse/resources/data.json"" ) );
				url.add( new URL( ""platform:/plugin/se.kau.cs.jittac.eclipse/resources/footer.html"" ) );
			}
			else
			{
				url.add( new URL( ""platform:/plugin/se.kau.cs.jittac.eclipse/resources/headerA.html"" ) );
				url.add( new URL( ""platform:/plugin/se.kau.cs.jittac.eclipse/resources/headerB.html"" ) );
				url.add( new URL( ""platform:/plugin/se.kau.cs.jittac.eclipse/resources/nullConnector.html"" ) );
			}
			
			URL featureDependenciesUrl = new URL( ""platform:/plugin/se.kau.cs.jittac.eclipse/resources/featureDependencies.html"" );
			File featureDependenciesFile = new File( FileLocator.resolve( featureDependenciesUrl ).toURI() );
			featureDependenciesFile.delete();
			featureDependenciesFile.createNewFile();	
			BufferedWriter writer = new BufferedWriter( new FileWriter( featureDependenciesFile, true ) );
		    
		    for( int i = 0; i < url.size(); i++ )
		    {
		    	InputStream inputStream = url.get( i ).openConnection().getInputStream();
		    	BufferedReader in = new BufferedReader( new InputStreamReader( inputStream ) );
			    String inputLine;
			    
			    while( ( inputLine = in.readLine() ) != null )
			    {
			        writer.append( ""\n"" );
			        writer.append( inputLine );
			    }
			 
			    in.close();
		    }
		    
		    writer.close();
		    
		    String featureDependenciesPage = ""file:///"" + featureDependenciesFile;
			PlatformUI.getWorkbench().getBrowserSupport().createBrowser( browserID ).openURL( new URL ( featureDependenciesPage ) );	
		}
		catch( IOException | PartInitException | URISyntaxException e )
		{ 	
			e.printStackTrace();
		}
	}
	
}"
ComponentFeaturesView.java,eclipse-ui,"package se.kau.cs.jittac.eclipse.ui.views;

import java.util.HashSet;
import java.util.Map;
import java.util.Set;

import org.apache.commons.collections4.map.HashedMap;
import org.eclipse.jface.viewers.ISelection;
import org.eclipse.jface.viewers.IStructuredContentProvider;
import org.eclipse.jface.viewers.IStructuredSelection;
import org.eclipse.jface.viewers.ITableLabelProvider;
import org.eclipse.jface.viewers.LabelProvider;
import org.eclipse.jface.viewers.TableViewer;
import org.eclipse.jface.viewers.Viewer;
import org.eclipse.jface.viewers.ViewerComparator;
import org.eclipse.swt.SWT;
import org.eclipse.swt.graphics.Image;
import org.eclipse.swt.widgets.Composite;
import org.eclipse.swt.widgets.TableColumn;
import org.eclipse.ui.ISelectionListener;
import org.eclipse.ui.IViewSite;
import org.eclipse.ui.IWorkbenchPart;
import org.eclipse.ui.PartInitException;
import org.eclipse.ui.part.ViewPart;

import se.kau.cs.jittac.eclipse.ui.editors.ArchitectureModelEditor;
import se.kau.cs.jittac.model.am.Component;
import se.kau.cs.jittac.model.feature.Feature;
import se.kau.cs.jittac.model.feature.FeatureLocationRegistry;
import se.kau.cs.jittac.model.mapping.ArchitectureMapping;
import se.kau.cs.jittac.model.mapping.IJittacResource;
import se.kau.cs.jittac.model.mapping.IMappableElement;

public class ComponentFeaturesView extends ViewPart implements ISelectionListener {

	private TableViewer viewer;
	private String[] columnHeaders = {""Feature"", ""#Resources""};
	
	@Override
    public void init(IViewSite site) throws PartInitException {
        super.init(site);
        getSite().getWorkbenchWindow().getSelectionService().addPostSelectionListener(this);
    }
	
	 public void dispose() {
		 getSite().getWorkbenchWindow().getSelectionService().removeSelectionListener(this);
		 super.dispose();
	 }
	 
	@Override
	public void createPartControl(Composite parent) {
        viewer = new TableViewer(parent, SWT.MULTI | SWT.H_SCROLL
				| SWT.V_SCROLL | SWT.BORDER);
        viewer.getTable().setHeaderVisible(true);
        viewer.getTable().setLinesVisible(true);
		for (int i = 0; i < columnHeaders.length; i++) {
			TableColumn column = new TableColumn(viewer.getTable(), SWT.NONE);
			column.setText(columnHeaders[i]);
			column.pack();
		}
		viewer.setContentProvider(new ContentProvider());
		viewer.setLabelProvider(new ReferenceLabelProvider());
		viewer.setComparator(new LocalViewerComparator());
	}

	@Override
	public void setFocus() {
		// TODO Auto-generated method stub

	}

	@Override
	public void selectionChanged(IWorkbenchPart part, ISelection selection) {
        if (!(selection instanceof IStructuredSelection)) return;
        IStructuredSelection selected = (IStructuredSelection) selection;
        if (part instanceof ArchitectureModelEditor) {
        	if (selected.getFirstElement() instanceof Component) {
        		if (!viewer.getControl().isDisposed()) {
        			viewer.setInput((Component) selected.getFirstElement());
        		}
        	}
        }
	}

	private class Entry {
		public Feature feature;
		public int occurences;
		
		public Entry(Feature feature, int occurences) {
			this.feature = feature;
			this.occurences = occurences;
		}
	}
	
	private class ContentProvider implements IStructuredContentProvider {

		@Override
		public Object[] getElements(Object inputElement) {
			if (inputElement != null && !(inputElement instanceof Component))
				throw new IllegalArgumentException();
		
			if (inputElement != null) {
				Component comp = (Component) inputElement;
				ArchitectureMapping mapping = comp.getModel().getMapping();
				Set<IMappableElement> resources = new HashSet<>();
				Map<Feature, Integer> features = new HashedMap<>();
				for (IMappableElement elem : mapping.getMappedResources(comp)) {
					resources.addAll(mapping.getIdenticallyMappedSubtree(elem));
				}
				for (IMappableElement elem : resources) {
					if (elem instanceof IJittacResource) {
						Set<Feature> featuresInResource = 
								FeatureLocationRegistry.INSTANCE.getFeatures((IJittacResource ) elem);
						for (Feature f : featuresInResource) {
							if (features.containsKey(f)) {
								int nrOfRes = features.get(f);
								features.put(f, nrOfRes + 1);
							}
							else {
								features.put(f, (Integer) 1);
							}
						}
					}
				}
				Entry[] result = new Entry[features.keySet().size()];
				int i = 0;
				for (Feature f : features.keySet()) {
					result[i++] = new Entry(f, features.get(f));
				}
				return result;
			}
			return new Object[0];
		}
	}

	private class ReferenceLabelProvider extends LabelProvider implements ITableLabelProvider {

		@Override
		public Image getColumnImage(Object element, int columnIndex) {
			return null;
		}

		@Override
		public String getColumnText(Object element, int columnIndex) {
		   	Entry entry = (Entry) element;
	    	
	    	switch (columnIndex) {
	    	case 0:
	    		return entry.feature.getName();
	        case 1:
	            return Integer.toString(entry.occurences);
	        }
	        return null;
		}
	}
	
	private class LocalViewerComparator extends ViewerComparator {
		@Override
		public int compare(Viewer viewer, Object e1, Object e2) {
			Entry e = (Entry) e1;
			Entry f = (Entry) e2;
			
			return e.feature.getName().compareTo(f.feature.getName());
		}
	}
	
}
"
FeatureDependencyMatrixView.java,eclipse-ui,"package se.kau.cs.jittac.eclipse.ui.views;


import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.net.URISyntaxException;
import java.net.URL;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Random;
import java.util.Set;

import org.eclipse.core.runtime.FileLocator;
import org.eclipse.jdt.core.IMember;
import org.eclipse.jdt.core.JavaModelException;
import org.eclipse.jface.viewers.ISelection;
import org.eclipse.jface.viewers.IStructuredContentProvider;
import org.eclipse.jface.viewers.IStructuredSelection;
import org.eclipse.jface.viewers.ITableLabelProvider;
import org.eclipse.jface.viewers.LabelProvider;
import org.eclipse.jface.viewers.TableViewer;
import org.eclipse.jface.viewers.Viewer;
import org.eclipse.jface.viewers.ViewerComparator;
import org.eclipse.swt.SWT;
import org.eclipse.swt.graphics.Image;
import org.eclipse.swt.widgets.Composite;
import org.eclipse.swt.widgets.TableColumn;
import org.eclipse.ui.ISelectionListener;
import org.eclipse.ui.IViewSite;
import org.eclipse.ui.IWorkbenchPart;
import org.eclipse.ui.PartInitException;
import org.eclipse.ui.part.ViewPart;

import se.kau.cs.jittac.eclipse.builders.jdt.JDTJavaReference;
import se.kau.cs.jittac.eclipse.ui.editors.ArchitectureModelEditor;
import se.kau.cs.jittac.model.am.Component;
import se.kau.cs.jittac.model.am.Connector;
import se.kau.cs.jittac.model.feature.Feature;
import se.kau.cs.jittac.model.feature.FeatureLocationRegistry;
import se.kau.cs.jittac.model.im.IXReference;
import se.kau.cs.jittac.model.mapping.IJittacResource;

public class FeatureDependencyMatrixView extends ViewPart implements ISelectionListener {

	private TableViewer viewer;
	private String[] columnHeaders = {""Feature Dependency"", ""#Occurrences""};

	
	@Override
    public void init(IViewSite site) throws PartInitException {
        super.init(site);
        getSite().getWorkbenchWindow().getSelectionService().addPostSelectionListener(this);
    }
	
	public void dispose() {
		 getSite().getWorkbenchWindow().getSelectionService().removeSelectionListener(this);
		 super.dispose();
	}
	
	@Override
	public void selectionChanged(IWorkbenchPart part, ISelection selection) {
		if (!(selection instanceof IStructuredSelection)) return;
        IStructuredSelection selected = (IStructuredSelection) selection;
        if (part instanceof ArchitectureModelEditor) {
        	if (selected.getFirstElement() instanceof Connector) {
        		if (!viewer.getControl().isDisposed()) {
        			viewer.setInput((Connector) selected.getFirstElement());
        		}
        	}
        }
	}

	@Override
	public void createPartControl(Composite parent) {
        viewer = new TableViewer(parent, SWT.MULTI | SWT.H_SCROLL
				| SWT.V_SCROLL | SWT.BORDER);
        viewer.getTable().setHeaderVisible(true);
        viewer.getTable().setLinesVisible(true);
		for (int i = 0; i < columnHeaders.length; i++) {
			TableColumn column = new TableColumn(viewer.getTable(), SWT.NONE);
			column.setText(columnHeaders[i]);
			column.pack();
			column.setWidth( 450 );
		}

		viewer.setContentProvider(new ContentProvider());
		viewer.setLabelProvider(new ReferenceLabelProvider());
		viewer.setComparator(new LocalViewerComparator());
	}

	@Override
	public void setFocus() {
		// TODO Auto-generated method stub

	}
	
	private class Entry
	{
		public Feature source, target;
		public int occurences;
		
		public Entry( Feature source, Feature target, int occurences )
		{
			this.source = source;
			this.target = target;
			this.occurences = occurences;
		}
	}
	
	private class ContentProvider implements IStructuredContentProvider
	{
		@Override
		public Object[] getElements( Object inputElement )
		{
			Map<String, Entry> resultmap = new HashMap<>();
			
			if( inputElement != null && !( inputElement instanceof Connector) )
				throw new IllegalArgumentException();
		
			if( inputElement != null )
			{
				Connector connector = ( Connector ) inputElement;
				
				for( IXReference<?, ?> ref : connector.getContributingReferences() )
				{
					IJittacResource srcRes = ref.getSource().getResource();
					IJittacResource trgRes = ref.getTarget().getResource();
					
					if( ref instanceof JDTJavaReference )
					{
						JDTJavaReference jref = ( JDTJavaReference ) ref;
						Feature sf = FeatureLocationRegistry.INSTANCE.getFeature( srcRes, jref.getInternalReference().offset );
						
						if( sf != null )
						{
							Set<Feature> trgFeatures = new HashSet<>();
							
							try 
							{
								switch( ref.getType() )
								{ 
//									case TYPEREF:
//									case CONTAINMENT: 	trgFeatures.addAll(FeatureLocationRegistry.INSTANCE.getFeatures(trgRes));
//												  	break;
									case ACCESS:
									case CALL:
									case CREATION:	
										int pos = ( ( IMember ) jref.getTarget().getJavaElement() ).getSourceRange().getOffset();
										Feature tf = FeatureLocationRegistry.INSTANCE.getFeature( trgRes, pos );
													
										if( tf != null )
										{
											trgFeatures.add( tf );
										}
													
										break;
									default: 		
										break;
								}
							}
							catch( JavaModelException e1 )
							{
								// TODO Auto-generated catch block
								e1.printStackTrace();
							}
							
							for( Feature tf : trgFeatures )
							{
								if( resultmap.containsKey( sf.getName() + "" -> "" + tf.getName() ) )
								{
									Entry e = resultmap.get( sf.getName() + "" -> "" + tf.getName() );
									e.occurences++;
								}
								else
								{
									resultmap.put( sf.getName() + "" -> "" + tf.getName(), new Entry( sf, tf, 1 ) );
								}
							}
						}
					}
				}
				
				produceJsonData( resultmap );
				produceHeaderB( connector );
				
				return resultmap.values().toArray();
			}
			
			return new Object[ 0 ];
		}
	}
	
	private class ReferenceLabelProvider extends LabelProvider implements ITableLabelProvider {

		@Override
		public Image getColumnImage(Object element, int columnIndex) {
			return null;
		}

		@Override
		public String getColumnText(Object element, int columnIndex) {
		   	Entry entry = (Entry) element;
	    	
	    	switch (columnIndex) {
	    	case 0:
	    		return entry.source.getName() + "" -> "" + entry.target.getName();
	        case 1:
	            return Integer.toString(entry.occurences);
	        }
	        return null;
		}
	}
	
	private class LocalViewerComparator extends ViewerComparator {
		@Override
		public int compare(Viewer viewer, Object e1, Object e2) {
			Entry e = (Entry) e1;
			Entry f = (Entry) e2;
			
			return (e.source.getName() + ""->"" + e.target.getName())
					.compareTo(f.source.getName() + ""->"" + f.target.getName());
		}
	}

	private static void produceJsonData( Map<String, Entry> featureMap )
	{	
		if( featureMap.isEmpty() )
		{
			try
			{
				URL dataFileUrl = new URL( ""platform:/plugin/se.kau.cs.jittac.eclipse/resources/data.json"" );
				File dataFile = new File( FileLocator.resolve( dataFileUrl ).toURI() );
				dataFile.delete();
				dataFile.createNewFile();
				BufferedWriter writer = new BufferedWriter( new FileWriter( dataFile, true ) );
				writer.write( ""no feature dependencies"" );
			    writer.close();
			}
			catch( IOException | URISyntaxException e )
			{ 	
				e.printStackTrace();
			}
		}
		else
		{
			String tab = ""\t\t\t"";
			String data = tab + ""var json_data =\n"";
			ArrayList<String> features = new ArrayList<String>();
			
			for( String featureDependency : featureMap.keySet() )
			{
				String sourceFeature = featureMap.get( featureDependency ).source.getName();
				String targetFeature = featureMap.get( featureDependency ).target.getName();
				
				if( !sourceFeature.equals( targetFeature ) )
				{
					if( !features.contains( sourceFeature ) )
					{
						features.add( sourceFeature );
					}
					if( !features.contains( targetFeature ) )
					{
						features.add( targetFeature );
					}
				}
			}
			
			data = data + tab + ""{\n"";
			data = data + tab + ""\t\""nodes\"" :\n"";
			data = data + tab + ""\t[\n"";
			
			for( String feature : features )
			{
				data = data + tab + ""\t\t{\n "";
				data = data + tab + ""\t\t\t\""name\"" : \"""" + feature + ""\"",\n"";
				data = data + tab + ""\t\t\t\""id\"" : \"""" + feature + ""\""\n"";
				data = data + tab + ""\t\t},\n "";
			}
			
			data = data.substring( 0, data.lastIndexOf( "","" ) ) + ""\n"";	// removes last comma produced by loop
			data = data + tab + ""\t],\n\n"";
			data = data + tab + ""\t\""links\"" :\n"";
			data = data + tab + ""\t[\n"";
			
			for( String featureDependency : featureMap.keySet() )
			{
				String sourceFeature = featureMap.get( featureDependency ).source.getName();
				String targetFeature = featureMap.get( featureDependency ).target.getName();
				int source = features.indexOf( sourceFeature );
				int target = features.indexOf( targetFeature );
				int numOfDependencies = featureMap.get( featureDependency ).occurences;
				
				if( !sourceFeature.equals( targetFeature ) )
				{
					data = data + tab + ""\t\t{\n "";
					data = data + tab + ""\t\t\t\""source\"" : "" + source + "",\n"";
					data = data + tab + ""\t\t\t\""value\"" : "" + numOfDependencies + "",\n"";
					data = data + tab + ""\t\t\t\""target\"" : "" + target + ""\n"" ;
					data = data + tab + ""\t\t},\n "";
				}
			}
			
			data = data.substring( 0, data.lastIndexOf( "","" ) ) + ""\n"";	// removes last comma produced by loop
			data = data + tab + ""\t]\n"";
			data = data + tab + ""};\n\n"";
			data = data + tab + ""var colors =\n"";
			data = data + tab + ""{\n"";
			
			String[] colors = 
			{
	            ""#39add1"", // light blue
	            ""#3079ab"", // dark blue
	            ""#c25975"", // mauve
	            ""#e15258"", // red
	            ""#f9845b"", // orange
	            ""#838cc7"", // lavender
	            ""#7d669e"", // purple
	            ""#53bbb4"", // aqua
	            ""#51b46d"", // green
	            ""#e0ab18"", // mustard
	            ""#637a91"", // dark gray
	            ""#f092b0"", // pink
	            ""#b7c0c7""  // light gray
		    };
			
			Random randomGenerator = new Random();
			
			for( String feature : features )
			{
		        String randomColor = colors[ randomGenerator.nextInt( colors.length ) ];
				data = data + tab + ""\t'"" + feature + ""' : '"" + randomColor + ""',\n"";
			}
			
			data = data + tab + ""\t'fallback' : '#9f9fa3'\n"";
			data = data + tab + ""};\n\n"";
		
			try
			{
				URL dataFileUrl = new URL( ""platform:/plugin/se.kau.cs.jittac.eclipse/resources/data.json"" );
				File dataFile = new File( FileLocator.resolve( dataFileUrl ).toURI() );
				dataFile.delete();
				dataFile.createNewFile();
				BufferedWriter writer = new BufferedWriter( new FileWriter( dataFile, true ) );
				writer.write( data );
			    writer.close();
			}
			catch( IOException | URISyntaxException e )
			{ 	
				e.printStackTrace();
			}
		}
	}
	
	private static void produceHeaderB( Connector connector )
	{
		String sourceModule = connector.getSrc().getName();
		String targetModule = connector.getTrg().getName();
		String type = connector.getState().toString();
		String data = ""\t\t<h5>Source/Target Modules : <span style=\""color: #3079ab\"">"" 
				+ sourceModule + ""  <img src=\""right-arrow.png\"">  "" 
				+ targetModule +""</span> &emsp;&emsp;&emsp; Dependency Type : <span style=\""color: #3079ab\"">"" 
				+ type + ""</span></h5>"";
		
		try
		{
			URL dataFileUrl = new URL( ""platform:/plugin/se.kau.cs.jittac.eclipse/resources/headerB.html"" );
			File dataFile = new File( FileLocator.resolve( dataFileUrl ).toURI() );
			dataFile.delete();
			dataFile.createNewFile();
			BufferedWriter writer = new BufferedWriter( new FileWriter( dataFile, true ) );
			writer.write( data );
		    writer.close();
		}
		catch( IOException | URISyntaxException e )
		{ 	
			e.printStackTrace();
		}
	}

}
"
FeatureLocationTableView.java,eclipse-ui,"package se.kau.cs.jittac.eclipse.ui.views;


import org.eclipse.jface.viewers.ArrayContentProvider;
import org.eclipse.jface.viewers.ColumnLabelProvider;
import org.eclipse.jface.viewers.TableViewer;
import org.eclipse.jface.viewers.TableViewerColumn;
import org.eclipse.swt.SWT;
import org.eclipse.swt.layout.GridData;
import org.eclipse.swt.widgets.Composite;
import org.eclipse.swt.widgets.Table;
import org.eclipse.swt.widgets.TableColumn;
import org.eclipse.ui.part.ViewPart;

import se.kau.cs.jittac.model.feature.FeatureLocation;
import se.kau.cs.jittac.model.feature.FeatureLocationRegistry;

public class FeatureLocationTableView extends ViewPart
{
    private static TableViewer viewer;
    
    public void createPartControl( Composite parent )
    {
        //Table Search
    	//GridLayout layout = new GridLayout( 2, false );
        //parent.setLayout( layout );
        //Label searchLabel = new Label( parent, SWT.NONE );
        //searchLabel.setText( ""Search: "" );
        //final Text searchText = new Text( parent, SWT.BORDER | SWT.SEARCH );
        //searchText.setLayoutData( new GridData(GridData.GRAB_HORIZONTAL | GridData.HORIZONTAL_ALIGN_FILL ) );
        createViewer( parent );
    }

    private void createViewer( Composite parent )
    {
        viewer = new TableViewer( parent, SWT.MULTI | SWT.H_SCROLL | SWT.V_SCROLL | SWT.FULL_SELECTION | SWT.BORDER );
        createColumns( parent, viewer );
        
        final Table table = viewer.getTable();
        table.setHeaderVisible( true );
        table.setLinesVisible( true );
        
        viewer.setContentProvider( new ArrayContentProvider() );
        viewer.setInput( FeatureLocationRegistry.INSTANCE.getAllFeatureLocations() );
        getSite().setSelectionProvider( viewer );

        GridData gridData = new GridData();
        gridData.verticalAlignment = GridData.FILL;
        gridData.horizontalSpan = 2;
        gridData.grabExcessHorizontalSpace = true;
        gridData.grabExcessVerticalSpace = true;
        gridData.horizontalAlignment = GridData.FILL;
        viewer.getControl().setLayoutData( gridData );
    }

    public TableViewer getViewer()
    {
        return viewer;
    }

    private void createColumns( final Composite parent, final TableViewer viewer )
    {
        TableViewerColumn col = createTableViewerColumn( ""Source"", 450, 0 );
        col.setLabelProvider( new ColumnLabelProvider()
        {
            @Override
            public String getText( Object element )
            {
            	FeatureLocation fl = ( FeatureLocation ) element;
                return fl.getResource().getPersistentHandle();   
            }
        } );

        col = createTableViewerColumn( ""Feature"", 200, 1 );
        col.setLabelProvider( new ColumnLabelProvider()
        {
        	@Override
            public String getText( Object element )
            {
            	FeatureLocation fl = ( FeatureLocation ) element;
                return fl.getFeature().getName();
            }
        } );

        col = createTableViewerColumn( ""Start-Offset"", 100, 2 );
        col.setLabelProvider( new ColumnLabelProvider()
        {
        	@Override
            public String getText( Object element )
            {
            	FeatureLocation fl = ( FeatureLocation ) element;
                return Integer.toString( fl.getOffset() );
            }
        } );

        col = createTableViewerColumn( ""Length"", 75, 3 );
        col.setLabelProvider( new ColumnLabelProvider()
        {
        	@Override
            public String getText( Object element )
            {
            	FeatureLocation fl = ( FeatureLocation ) element;
                return Integer.toString( fl.getLength() );
            }
        } );
    }

    private TableViewerColumn createTableViewerColumn( String title, int bound, final int colNumber )
    {
        final TableViewerColumn viewerColumn = new TableViewerColumn( viewer, SWT.NONE );
        final TableColumn column = viewerColumn.getColumn();
        column.setText( title );
        column.setWidth( bound );
        column.setResizable( true );
        column.setMoveable( true );
        return viewerColumn;
    }

    public void setFocus()
    {
        viewer.getControl().setFocus();
    }

    public static void refresh()
    {
    	viewer.setInput( FeatureLocationRegistry.INSTANCE.getAllFeatureLocations() );
    	viewer.refresh();
    }

}"
ReferenceTableView.java,eclipse-ui,"package se.kau.cs.jittac.eclipse.ui.views;

import org.eclipse.core.resources.IFile;
import org.eclipse.core.resources.IResource;
import org.eclipse.jface.viewers.DoubleClickEvent;
import org.eclipse.jface.viewers.IDoubleClickListener;
import org.eclipse.jface.viewers.ISelection;
import org.eclipse.jface.viewers.IStructuredContentProvider;
import org.eclipse.jface.viewers.IStructuredSelection;
import org.eclipse.jface.viewers.ITableLabelProvider;
import org.eclipse.jface.viewers.LabelProvider;
import org.eclipse.jface.viewers.TableViewer;
import org.eclipse.jface.viewers.Viewer;
import org.eclipse.jface.viewers.ViewerComparator;
import org.eclipse.swt.SWT;
import org.eclipse.swt.events.SelectionAdapter;
import org.eclipse.swt.events.SelectionEvent;
import org.eclipse.swt.graphics.Image;
import org.eclipse.swt.widgets.Composite;
import org.eclipse.swt.widgets.TableColumn;
import org.eclipse.ui.IEditorPart;
import org.eclipse.ui.ISelectionListener;
import org.eclipse.ui.IViewSite;
import org.eclipse.ui.IWorkbenchPart;
import org.eclipse.ui.PartInitException;
import org.eclipse.ui.ide.IDE;
import org.eclipse.ui.part.ViewPart;
import org.eclipse.ui.texteditor.ITextEditor;

import se.kau.cs.jittac.eclipse.builders.jdt.JDTJavaReference;
import se.kau.cs.jittac.eclipse.builders.jdt.JDTJavaReferenceCodeInformation;
import se.kau.cs.jittac.eclipse.ui.editors.ArchitectureModelEditor;
import se.kau.cs.jittac.model.am.Connector;
import se.kau.cs.jittac.model.im.IXReference;
import se.kau.cs.jittac.model.mapping.IJittacResource;
import se.kau.cs.jittac.model.mapping.eclipse.EclipseJittacResource;
import se.kau.cs.jittac.model.mapping.eclipse.EclipseJittacResourceFactory;

public class ReferenceTableView extends ViewPart implements ISelectionListener {

	private TableViewer viewer;
	private Connector connector;
	private LocalComparator comparator;
	
	private String[] columnHeaders = {""Source Resource"", ""Source"", ""Type"", ""Target"", ""Target Resource""};
	private double[] widthFactors = {0.15, 0.3, 0.1, 0.3, 0.15};
	
	@Override
    public void init(IViewSite site) throws PartInitException {
        super.init(site);
        getSite().getWorkbenchWindow().getSelectionService().addPostSelectionListener(this);
    }
	
	 public void dispose() {
		 getSite().getWorkbenchWindow().getSelectionService().removeSelectionListener(this);
		 super.dispose();
	 }
	
	@Override
	public void createPartControl(Composite parent) {
        viewer = new TableViewer(parent, SWT.MULTI | SWT.H_SCROLL
				| SWT.V_SCROLL | SWT.BORDER);
        viewer.getTable().setHeaderVisible(true);
        viewer.getTable().setLinesVisible(true);
        int width = viewer.getTable().getSize().x;
		for (int i = 0; i < columnHeaders.length; i++) {
			TableColumn column = new TableColumn(viewer.getTable(), SWT.NONE);
			column.setText(columnHeaders[i]);
			column.setWidth((int) (width * widthFactors[i])); 
			column.addSelectionListener(getSelectionAdapter(column, i));
			column.pack();
		}
		comparator = new LocalComparator();
		viewer.setContentProvider(new ContentProvider());
		viewer.setLabelProvider(new ReferenceLabelProvider());
		viewer.setComparator(comparator);
		
		viewer.addDoubleClickListener(new IDoubleClickListener() {

			@Override
			public void doubleClick(DoubleClickEvent event) {
				IXReference xref = (IXReference) ((IStructuredSelection)event.getSelection()).getFirstElement();
				IJittacResource jResource = xref.getResource();
				if (jResource.getResourceModelName()
						.equals(EclipseJittacResourceFactory.RESOURCE_MODEL_NAME)) {
					IResource resource = ((EclipseJittacResource) jResource).getWrappedResource();
					if (resource.getType() != IResource.FILE)
	                	return;
					if (xref instanceof JDTJavaReference) {
						JDTJavaReferenceCodeInformation refInf =
								((JDTJavaReference) xref).getInternalReference();
						try {
		                    IEditorPart editor = IDE.openEditor(getSite().getPage(), (IFile) resource, true);
		                    ((ITextEditor) editor).selectAndReveal(refInf.offset, refInf.length);
		                } catch (PartInitException e) {
		                    e.printStackTrace();
		                }
					}
				}
				
			}
			
		});
	}

	@Override
	public void setFocus() {
		// TODO Auto-generated method stub

	}

	private class ContentProvider implements IStructuredContentProvider {

		@Override
		public Object[] getElements(Object inputElement) {
			if (inputElement != null && !(inputElement instanceof Connector))
				throw new IllegalArgumentException();
		
			if (inputElement != null) {
				Connector conn = (Connector) inputElement;
				Object result[] = conn.getContributingReferences().toArray();
				return result;
			}
			return new Object[0];
		}
	}
	
	private class ReferenceLabelProvider extends LabelProvider implements ITableLabelProvider {

		@Override
		public Image getColumnImage(Object element, int columnIndex) {
			return null;
		}

		@Override
		public String getColumnText(Object element, int columnIndex) {
		   	IXReference xref = (IXReference) element;
	    	
	    	return referenceToColumnText(xref, columnIndex);
		}
		
	}

	@Override
	public void selectionChanged(IWorkbenchPart part, ISelection selection) {
        if (!(selection instanceof IStructuredSelection)) return;
        IStructuredSelection selected = (IStructuredSelection) selection;
        if (part instanceof ArchitectureModelEditor) {
        	if (selected.getFirstElement() instanceof Connector) {
        		if (!viewer.getControl().isDisposed()) {
        			viewer.setInput((Connector) selected.getFirstElement());
        		}
        	}
        }
	}
	
	private class LocalComparator extends ViewerComparator {
		
		private static final int DESCENDING  = 1;
		private int currentColumn = 0;
		private int direction = DESCENDING;
		
		public int getDirection() {
			return direction == DESCENDING ? SWT.DOWN : SWT.UP;
		}
		
		public void setColumn(int column) {
			if (currentColumn == column) {
				direction = -direction; 
			}
			else {
				currentColumn = column;
			}
		}
		
		@Override
	    public int compare(Viewer viewer, Object e1, Object e2) {
		
			String s1 = referenceToColumnText((IXReference<?,?>) e1, currentColumn);
			String s2 = referenceToColumnText((IXReference<?,?>) e2, currentColumn);
			return -direction * s1.compareTo(s2);
		}
	}
	
	private String referenceToColumnText(IXReference<?,?> ref, int columnIndex) {
    	switch (columnIndex) {
    	case 0:
    		return ref.getSource().getResource().toString();
        case 1:
            return ref.getSource().toString();
        case 2:
        	return ref.getType().name();	            
        case 3:
            return ref.getTarget().toString();
        case 4:
        	return ref.getTarget().getResource().toString();
        }
        return null;
	}
	
    private SelectionAdapter getSelectionAdapter(final TableColumn column,
            final int index) {
        SelectionAdapter selectionAdapter = new SelectionAdapter() {
            @Override
            public void widgetSelected(SelectionEvent e) {
                comparator.setColumn(index);
                int dir = comparator.getDirection();
                viewer.getTable().setSortDirection(dir);
                viewer.getTable().setSortColumn(column);
                viewer.refresh();
            }
        };
        return selectionAdapter;
    }
}
"
ComponentVisual.java,eclipse-ui,"package se.kau.cs.jittac.eclipse.ui.visuals;

import org.eclipse.gef.fx.nodes.GeometryNode;
import org.eclipse.gef.geometry.planar.RoundedRectangle;
import org.eclipse.gef.mvc.fx.models.SelectionModel;

import javafx.event.Event;
import javafx.geometry.Insets;
import javafx.geometry.Orientation;
import javafx.geometry.Pos;
import javafx.geometry.VPos;
import javafx.scene.Cursor;
import javafx.scene.Group;
import javafx.scene.control.TextArea;
import javafx.scene.control.TextField;
import javafx.scene.effect.BlendMode;
import javafx.scene.input.ContextMenuEvent;
import javafx.scene.input.KeyCode;
import javafx.scene.layout.Border;
import javafx.scene.layout.Region;
import javafx.scene.layout.VBox;
import javafx.scene.paint.Color;
import javafx.scene.text.Text;
import javafx.scene.text.TextFlow;


public class ComponentVisual extends Region {
	private static final double HORIZONTAL_PADDING = 5d;
	private static final double VERTICAL_PADDING = 5d;
	private static final double VERTICAL_SPACING = 5d;
	
	private GeometryNode<RoundedRectangle> shape;
	private VBox labelVBox;
	private TextField nameText;
	private TextFlow nameFlow;
	
	public ComponentVisual() {
        shape = new GeometryNode<>(new RoundedRectangle(0, 0, 70, 30, 8, 8));
        shape.setFill(Color.LIGHTSKYBLUE);
        shape.setStroke(Color.BLACK);
        
        nameText = new TextField();
        nameText.setEditable(false);
        nameText.setAlignment(Pos.TOP_CENTER);
        nameText.setStyle(
        		""-fx-background-insets: 0;"" + 
        		""    -fx-background-color: transparent, white, transparent, white;"" + 
        		""    -fx-background-radius: 0, 0, 0, 0;"" + 
        		""    -fx-box-border: none;"" + 
        		""    -fx-focus-color: -fx-control-inner-background;"" + 
        		""    -fx-faint-focus-color: -fx-control-inner-background;"" + 
        		""    -fx-text-box-border: -fx-control-inner-background;"" + 
        		""    -fx-border-width: -1"");
        nameText.setBlendMode(BlendMode.MULTIPLY);
        nameText.setCursor(Cursor.DEFAULT);
        nameText.addEventFilter(ContextMenuEvent.CONTEXT_MENU_REQUESTED, Event::consume);
        nameText.setOnMouseClicked((event) ->
        {
        	if (event.getClickCount() >= 2)
        		nameText.setEditable(true);
        });
                         
        labelVBox = new VBox(VERTICAL_SPACING);
        labelVBox.setPadding(new Insets(VERTICAL_PADDING, HORIZONTAL_PADDING, VERTICAL_PADDING, HORIZONTAL_PADDING));
        
        labelVBox.getChildren().addAll(/*new Text(""Hallo""),*/ nameText);

        // ensure shape and labels are resized to fit this visual
        shape.prefWidthProperty().bind(widthProperty());
        shape.prefHeightProperty().bind(heightProperty());
        labelVBox.prefWidthProperty().bind(widthProperty());
        labelVBox.prefHeightProperty().bind(heightProperty());
        
 
        

        
        
        //nameText.setTextOrigin(VPos.CENTER);
        
        //nameFlow = new TextFlow(nameText);
        //nameFlow.maxWidthProperty().bind(shape.widthProperty().subtract(HORIZONTAL_PADDING * 2));
        
 
        
        setMinSize(USE_COMPUTED_SIZE, USE_COMPUTED_SIZE);

        getChildren().addAll(new Group(shape), new Group(labelVBox));
	}

    @Override
    public double computeMinHeight(double width) {
        
        return labelVBox.minHeight(width);
    }

    @Override
    public double computeMinWidth(double height) {
        // ensure title is always visible
    	Text temp = new Text(nameText.getText());
    	temp.setFont(nameText.getFont());
    	double result = temp.getLayoutBounds().getWidth();
    	return Math.max(result + 20 + HORIZONTAL_PADDING * 2, 50);
    }

    @Override
    protected double computePrefHeight(double width) {
        return minHeight(width);
    }

    @Override
    protected double computePrefWidth(double height) {
        return minWidth(height);
    }

    @Override
    public Orientation getContentBias() {
        return Orientation.HORIZONTAL;
    }
	
    public TextField getNameText() {
        return nameText;
    }

    public GeometryNode<?> getGeometryNode() {
        return shape;
    }

    public void setName(String name) {
        nameText.setText(name);
        nameText.commitValue();
    }
    
    
}
"
ConnectorVisual.java,eclipse-ui,"package se.kau.cs.jittac.eclipse.ui.visuals;

import java.util.List;

import org.eclipse.gef.fx.nodes.Connection;
import org.eclipse.gef.fx.nodes.GeometryNode;
import org.eclipse.gef.fx.utils.NodeUtils;
import org.eclipse.gef.geometry.planar.Line;
import org.eclipse.gef.geometry.planar.Point;
import org.eclipse.gef.geometry.planar.Polyline;

import javafx.geometry.VPos;
import javafx.scene.Group;
import javafx.scene.paint.Color;
import javafx.scene.shape.Polygon;
import javafx.scene.text.Text;

public class ConnectorVisual extends Group {
	
	private static final Double[] DIVERGENCE_DASH_STYLE = new Double[] {10.0, 6.0};
	private static final Double[] ABSENCE_DASH_STYLE = new Double[] {1.0, 5.0};
	
	private Connection connection = new Connection();
	private Text label;

    public static class ArrowHead extends Polygon {
    	public static double length = 12.0;
    	public static double width = 8.0;
        public ArrowHead() {
            super(0, 0, length, 0.5*width, length, -0.5*width);
        }

    }
    
    public ConnectorVisual() {
        ArrowHead endDecoration = new ArrowHead();
        endDecoration.setFill(Color.BLACK);
        connection.setEndDecoration(endDecoration);
        connection.addControlPoint(0, computeControlPoint());
        ((GeometryNode<?>) connection.getCurve()).setStrokeWidth(1.25);
        ((GeometryNode<?>) connection.getCurve()).setClickableAreaWidth(10.0);
        
        label = new Text(""Hallo"");
        Point labelPos = computeLabelPosition();
        label.setTextOrigin(VPos.CENTER);
        
        label.setLayoutX(labelPos.x());
        label.setLayoutY(labelPos.y());

        this.getChildren().addAll(connection, label);
    }
 
    @Override
    public void layoutChildren() {
    	super.layoutChildren();
        Point controlPoint = computeControlPoint();
        connection.setControlPoint(0, controlPoint);
        Point labelPos = computeLabelPosition();
        label.setLayoutX(labelPos.x());
        label.setLayoutY(labelPos.y()); 
     }
    
    
    private Point computeLabelPosition() {
    	//get middle segment
    	//int labelDistanceFactor = 5;
    	double labelWidth = label.getLayoutBounds().getWidth();
    	double labelHeight = label.getLayoutBounds().getHeight();
    	double labelDistanceFactor = 0.5 *  Math.sqrt(labelWidth*labelWidth + labelHeight*labelHeight);
    	Point p1 = connection.getStartPoint();
    	Point p2 = connection.getControlPoint(0);
    	double dx = p2.x - p1.x;
    	double dy = p2.y - p1.y;
    	
    	if (dy == 0) dy = 0.0001;
    	double ox = dy / (Math.sqrt(dx*dx + dy*dy));
    	double oy = -dx * ox / dy;
    	
    	double labelCenterX = (p1.x + p2.x) / 2 + labelDistanceFactor * ox;
    	double labelCenterY = (p1.y + p2.y) / 2 + labelDistanceFactor * oy;
 
    	return new Point(labelCenterX, labelCenterY);

    }
    
    private Point computeControlPoint() {
    	int controlPointDistanceFactor = 20;
    	Point p1 = connection.getStartPoint();
    	Point p2 = connection.getEndPoint();
    	
    	double dx = p2.x - p1.x;
    	double dy = p2.y - p1.y;
    	if (dy == 0) dy = 0.01;
    	double ox = dy / (Math.sqrt(dx*dx + dy*dy));
    	double oy = -dx * ox / dy;
    	
    	Point midPoint = this.getMidPoint();
    	
      	return new Point(midPoint.x + controlPointDistanceFactor * ox, 
      			midPoint.y + controlPointDistanceFactor * oy);
 
    }
    
    private Point getMidPoint() {
    	Point p1 = connection.getStartPoint();
    	Point p2 = connection.getEndPoint();

    	return new Point((p1.x + p2.x) / 2, (p1.y + p2.y)/ 2);
    	
    }
    
    public String getLabel() {
    	return label.getText();
    }
    
    public void setStrokeStyle(int nrOfDeps, boolean intended) {
    	if (nrOfDeps > 0) {
    		if (intended) {
    			((GeometryNode<?>) connection.getCurve()).getStrokeDashArray().clear();
    			
    		}
    		else {
    			((GeometryNode<?>) connection.getCurve()).getStrokeDashArray().setAll(DIVERGENCE_DASH_STYLE);
    		}
    	}
    	else if (intended)  {
    		((GeometryNode<?>) connection.getCurve()).getStrokeDashArray().setAll(ABSENCE_DASH_STYLE);
    	}
    }
    
    public void setLabel(String newText) {
    	label.setText(newText);
    }
    
    public Connection getConnection() {
    	return connection;
    }
  
    private Point getDecorationConnectionPoint() {
    	Point endPoint = connection.getEndPoint();
    	Point lastControlPoint = connection.getControlPoint(connection.getControlPoints().size() - 1);
    	double dx = endPoint.x - lastControlPoint.x;
    	double dy = endPoint.y - lastControlPoint.y;
    	double length = Math.sqrt(dx*dx + dy*dy); 
    	
    	double arrowX = ConnectorVisual.ArrowHead.length * dx / length;
    	double arrowY = ConnectorVisual.ArrowHead.length * dy / length;
    	
    	return new Point(endPoint.x - arrowX, endPoint.y - arrowY); 
    }

    public Polyline getOutline() {
    	
    	
    	List<Double> ahPoints = ((ArrowHead) connection.getEndDecoration()).getPoints();
    	Point p1 = new Point (ahPoints.get(2), ahPoints.get(3));
    	Point p2 = new Point (ahPoints.get(0), ahPoints.get(1));
    	Point p3 = new Point (ahPoints.get(4), ahPoints.get(5));
    	Polyline ahOutline = new Polyline(p1, p2, p3);
    	ahOutline = (Polyline)
    			NodeUtils.localToParent(connection.getEndDecoration(),
    					ahOutline);
    	
    	Point[] arrowHeadPoints = ahOutline.getPoints();

    	
    	Point newEndPoint = getDecorationConnectionPoint();
    	int nrOfControlPoints = connection.getControlPoints().size();
    	Line[] outlineElements = new Line[nrOfControlPoints + 5];
    	
    	outlineElements[0] = new Line(connection.getStartPoint(), connection.getControlPoint(0));
    	for (int i = 1; i < nrOfControlPoints; i++) {
    		outlineElements[i] = new Line(connection.getControlPoint(i - 1), connection.getControlPoint(i));
    	}
    	outlineElements[nrOfControlPoints] =
    			new Line(connection.getControlPoint(nrOfControlPoints - 1),
    					newEndPoint);

    	outlineElements[nrOfControlPoints + 1] =
    			new Line(newEndPoint, arrowHeadPoints[0]);
    	
    	outlineElements[nrOfControlPoints + 2] =
    			new Line(arrowHeadPoints[0], arrowHeadPoints[1]);

    	outlineElements[nrOfControlPoints + 3] =
    			new Line(arrowHeadPoints[1], arrowHeadPoints[2]);
    	
    	outlineElements[nrOfControlPoints + 4] =
    			new Line(arrowHeadPoints[2], newEndPoint);
    	
    	return new Polyline(outlineElements);
    }
    
}
"
TestApplication.java,eclipse-ui,"package se.kau.cs.jittac.eclipse.ui.visuals;

import org.eclipse.core.commands.operations.IUndoContext;
import org.eclipse.gef.common.adapt.AdapterKey;
import org.eclipse.gef.mvc.fx.domain.HistoricizingDomain;
import org.eclipse.gef.mvc.fx.domain.IDomain;
import org.eclipse.gef.mvc.fx.parts.IVisualPart;
import org.eclipse.gef.mvc.fx.viewer.IViewer;

import com.google.inject.Guice;

import javafx.application.Application;
import javafx.application.Platform;
import javafx.scene.Node;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.control.Toggle;
import javafx.scene.control.ToggleButton;
import javafx.scene.control.ToggleGroup;
import javafx.scene.layout.BorderPane;
import javafx.scene.layout.HBox;
import javafx.scene.layout.VBox;
import javafx.stage.Stage;
import se.kau.cs.jittac.eclipse.ui.ArchitectureModelModule;
import se.kau.cs.jittac.eclipse.ui.models.ItemCreationModel;
import se.kau.cs.jittac.eclipse.ui.parts.ComponentPart;
import se.kau.cs.jittac.model.am.ArchitectureModel;
import se.kau.cs.jittac.model.am.Component;
import se.kau.cs.jittac.model.am.test.ConsoleArchitectureModelListener;
import se.kau.cs.jittac.model.mapping.JittacResourceModelRegistry;
import se.kau.cs.jittac.model.mapping.test.JittacResourceStub;
import se.kau.cs.jittac.model.mapping.test.TestResourceFactory;

public class TestApplication extends Application {

	private ArchitectureModel model;
	private Component c1, c2, c3;
		
	public static void main(String[] args) {
	     Application.launch(args);
	}
	
	private Stage primaryStage;
	private HistoricizingDomain domain;
	
	    /**
	 * Returns the content viewer of the domain
	 *
	 * @return
	 */
	private IViewer getContentViewer() {
	    return domain.getAdapter(AdapterKey.get(IViewer.class, IDomain.CONTENT_VIEWER_ROLE));
	}
	
	/**
	 * Creating JavaFX widgets and set them to the stage.
	 */
	private void hookViewers() {
		   BorderPane pane = new BorderPane();

			//pane.setTop(createButtonBar());
			pane.setCenter(getContentViewer().getCanvas());
			pane.setRight(createToolPalette());

			pane.setMinWidth(800);
			pane.setMinHeight(600);
			
			Scene scene = new Scene(pane);
			primaryStage.setScene(scene);
	}
    

	private Node createButtonBar() {
		Button undoButton = new Button(""Undo"");
		undoButton.setDisable(true);
		undoButton.setOnAction((e) -> {
			try {
				domain.getOperationHistory().undo(domain.getUndoContext(), null, null);
			} catch (org.eclipse.core.commands.ExecutionException e1) {
				e1.printStackTrace();
			}
		});

		Button redoButton = new Button(""Redo"");
		redoButton.setDisable(true);
		redoButton.setOnAction((e) -> {
			try {
				domain.getOperationHistory().redo(domain.getUndoContext(), null, null);
			} catch (org.eclipse.core.commands.ExecutionException e1) {
				e1.printStackTrace();
			}
		});

		// add listener to operation history in our domain 
		// and enable/disable buttons
		domain.getOperationHistory().addOperationHistoryListener((e) -> {
			IUndoContext ctx = domain.getUndoContext();
			undoButton.setDisable(!e.getHistory().canUndo(ctx));
			redoButton.setDisable(!e.getHistory().canRedo(ctx));
		});

		return new HBox(10, undoButton, redoButton);
	}

	private Node createToolPalette() {
		ItemCreationModel creationModel = getContentViewer().getAdapter(ItemCreationModel.class);
		
		ComponentVisual graphic = new ComponentVisual();
		graphic.setName(""New Node"");

		// the toggleGroup makes sure, we only select one 
		ToggleGroup toggleGroup = new ToggleGroup();
		
		ToggleButton createNode = new ToggleButton("""", graphic);
		createNode.setToggleGroup(toggleGroup);
		createNode.selectedProperty().addListener((e, oldVal, newVal) -> {
	                creationModel.setType(newVal ? ItemCreationModel.Type.Component : ItemCreationModel.Type.None);
		});

		ToggleButton createConn = new ToggleButton(""New Connection"");
		createConn.setToggleGroup(toggleGroup);
		createConn.setMaxWidth(Double.MAX_VALUE);
		createConn.setMinHeight(50);
		createConn.selectedProperty().addListener((e, oldVal, newVal) -> {
	                creationModel.setType(newVal ? ItemCreationModel.Type.Connector : ItemCreationModel.Type.None);
		});
		
		// now listen to changes in the model, and deactivate buttons, if necessary
		creationModel.getTypeProperty().addListener((e, oldVal, newVal) -> {
	            if (ItemCreationModel.Type.None == newVal) {
	                // unselect the toggle button
	                Toggle selectedToggle = toggleGroup.getSelectedToggle();
	                if (selectedToggle != null) {
	                    selectedToggle.setSelected(false);
	                }
	            }
	        });
		
		return new VBox(20, createNode, createConn);
	}
	
	private void populateViewerContents() {
		double[] positions = new double[] {100, 100, 500, 100, 300, 400};
		JittacResourceModelRegistry.INSTANCE.registerResourceModel(TestResourceFactory.INSTANCE);
		JittacResourceModelRegistry.INSTANCE.setDefaultResourceModel(TestResourceFactory.INSTANCE);
        model = ArchitectureModel.createArchitectureModel();
		model.registerListener(new ConsoleArchitectureModelListener());
        c1 = model.createComponent(""C1"");
        c2 = model.createComponent(""C2"");
        c3 = model.createComponent(""C3"");
		

        IViewer viewer = getContentViewer();
        viewer.getContents().setAll(model);
        
        int i = 0;
        for (IVisualPart p : viewer.getRootPart().getChildrenUnmodifiable().get(0).getChildrenUnmodifiable()) {
        	if (p instanceof ComponentPart) {
        		p.getVisual().setLayoutX(positions[i++]);
        		p.getVisual().setLayoutY(positions[i++]);
        	}
        }
        viewer.getRootPart().refreshVisual();
    }
	
	@Override
	public void start(Stage primaryStage) throws Exception {
	       ArchitectureModelModule module = new ArchitectureModelModule();
	        this.primaryStage = primaryStage;
	        // create domain using guice
	        this.domain = (HistoricizingDomain) Guice.createInjector(module).getInstance(IDomain.class);

	        // create viewers
	        hookViewers();

	        // activate domain
	        domain.activate();

	        // load contents
	        populateViewerContents();

	        // set-up stage
	        primaryStage.setResizable(true);
	        primaryStage.setTitle(""GEF Jittac Model"");
	        primaryStage.sizeToScene(); 	
	        primaryStage.show();
	        
	       
	        //model.removeComponent(c3);
	        
	        Runnable r = new Runnable() {
				@Override
				public void run() {
			        try {
						model.createConnector(c1, c2);
						Thread.sleep(100);
						model.createConnector(c1, c3);
						Thread.sleep(100);
						model.getMapping().addMapping(c1, JittacResourceStub.INSTANCE_1);
						Thread.sleep(100);
						model.getMapping().addMapping(c2, JittacResourceStub.INSTANCE_2);
						Thread.sleep(100);
						model.getMapping().addMapping(c3, JittacResourceStub.INSTANCE_212);
						//model.getMapping().removeMapping(c2, JittacResourceStub.INSTANCE_2);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
	        };
	        //Platform.runLater(r);
	        new Thread(r).start();
	        
	        
	  }

}


"
NewArchitectureModelWizard.java,eclipse-ui,"package se.kau.cs.jittac.eclipse.ui.wizards;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PipedInputStream;
import java.io.PipedOutputStream;
import java.lang.reflect.InvocationTargetException;

import org.eclipse.core.resources.IContainer;
import org.eclipse.core.resources.IFile;
import org.eclipse.core.resources.IResource;
import org.eclipse.core.resources.IWorkspaceRoot;
import org.eclipse.core.resources.ResourcesPlugin;
import org.eclipse.core.runtime.CoreException;
import org.eclipse.core.runtime.IPath;
import org.eclipse.core.runtime.IProgressMonitor;
import org.eclipse.core.runtime.IStatus;
import org.eclipse.core.runtime.Path;
import org.eclipse.core.runtime.Status;
import org.eclipse.jface.dialogs.MessageDialog;
import org.eclipse.jface.operation.IRunnableWithProgress;
import org.eclipse.jface.viewers.IStructuredSelection;
import org.eclipse.jface.wizard.Wizard;
import org.eclipse.ui.INewWizard;
import org.eclipse.ui.IWorkbench;
import org.eclipse.ui.IWorkbenchPage;
import org.eclipse.ui.IWorkbenchWizard;
import org.eclipse.ui.PartInitException;
import org.eclipse.ui.PlatformUI;
import org.eclipse.ui.dialogs.WizardNewFileCreationPage;
import org.eclipse.ui.ide.IDE;

import se.kau.cs.jittac.eclipse.Activator;
import se.kau.cs.jittac.model.am.ArchitectureModel;
import se.kau.cs.jittac.model.am.io.ArchitectureModelWriter;
import se.kau.cs.jittac.model.mapping.JittacResourceModelRegistry;

/**
 * This is the Eclipse wizard for creating new architectural model files.
 * @author Jacek Rosik, Sebastian Herold
 *
 */
public class NewArchitectureModelWizard extends Wizard implements INewWizard {

	private WizardNewFileCreationPage page;
	private IStructuredSelection selection;
	
	public NewArchitectureModelWizard() {
		super();
		setNeedsProgressMonitor(true);
	}
	
	@Override
	public void init(IWorkbench workbench, IStructuredSelection selection) {
		this.selection = selection;
	}

	public void addPages() {
		super.addPages();
		page = new WizardNewFileCreationPage(""newFilePage"", selection);
		page.setTitle(""New Architecture Model"");
		page.setDescription(""Create an empty architecture model file for analysis in Jittac."");
		page.setFileExtension(""xam"");
		page.setFileName(""architecture.xam"");
	    addPage(page);
	}
	
	/**
	 * This method is called when 'Finish' button is pressed in
	 * the wizard. We will create an operation and run it
	 * using wizard as execution context.
	 */
	@Override
	public boolean performFinish() {
		final IPath containerName = page.getContainerFullPath();
		final String fileName = page.getFileName();
		
		IRunnableWithProgress op = new IRunnableWithProgress() {
			public void run(IProgressMonitor monitor) throws InvocationTargetException {
				try {
					doFinish(containerName, fileName, monitor);
				} catch (CoreException e) {
					throw new InvocationTargetException(e);
				} finally {
					monitor.done();
				}
			}
		};
		try {
			getContainer().run(true, false, op);
		} catch (InterruptedException e) {
			return false;
		} catch (InvocationTargetException e) {
			Throwable realException = e.getTargetException();
			MessageDialog.openError(getShell(), ""Error"", realException.getMessage());
			return false;
		}
		return true;
	}
	
	/**
	 * The worker method. It will find the container, create the
	 * file if missing or just replace its contents, and open
	 * the editor on the newly created file.
	 */

	private void doFinish(IPath containerPath, String filename,	IProgressMonitor monitor)
		throws CoreException {
		// create a sample file
		monitor.beginTask(""Creating "" + filename, 2);
		
		// Get the container.
		IWorkspaceRoot root = ResourcesPlugin.getWorkspace().getRoot();
		IResource resource = root.findMember(containerPath);
		if (!resource.exists() || !(resource instanceof IContainer)) {
			throwCoreException(""Container \"""" + containerPath.toOSString() + ""\"" does not exist."");
		}
		
		// Create file.
		IContainer container = (IContainer) resource;
		final IFile file = container.getFile(new Path(filename));

		try {
			ArchitectureModel newModel = ArchitectureModel.createArchitectureModel();
			ByteArrayOutputStream output = new ByteArrayOutputStream(); 
			ArchitectureModelWriter.write(output, newModel);
			ByteArrayInputStream input =  new ByteArrayInputStream(output.toByteArray());
					
			if (file.exists()) {

				file.setContents(input, true, true, monitor);
			} else {
				file.create(input, true, monitor);
			}
			
			input.close();
			output.close();
		} catch (IOException e) {
		}
		monitor.worked(1);
		
		// Open file.
		monitor.setTaskName(""Opening file for editing..."");
		getShell().getDisplay().asyncExec(new Runnable() {
			public void run() {
				IWorkbenchPage page =
					PlatformUI.getWorkbench().getActiveWorkbenchWindow().getActivePage();
				try {
					IDE.openEditor(page, file, true);
				} catch (PartInitException e) {
				}
			}
		});
		monitor.worked(1);
	}
	
	private void throwCoreException(String message) throws CoreException {
		IStatus status =
			new Status(IStatus.ERROR, Activator.PLUGIN_ID, IStatus.OK, message, null);
		throw new CoreException(status);
	}

}
"
BuildUnit.java,impl-model,"package se.kau.cs.jittac.model.im;

import java.util.HashSet;
import java.util.Set;

import se.kau.cs.jittac.model.im.IXReference;
import se.kau.cs.jittac.model.im.events.XReferenceChangeDeltaEvent;
import se.kau.cs.jittac.model.mapping.IJittacResource;

public class BuildUnit {
	private IJittacResource resource;
	private ImplementationModelPartition partition;
	
	private Set<IXReference<? extends IImplementationModelElement<?>,?>> common;				/// Unchanged references in current compilation unit.
	private Set<IXReference<? extends IImplementationModelElement<?>,?>> added;				/// References added to current compilation unit.
	private Set<IXReference<? extends IImplementationModelElement<?>,?>> current;
	
	private Set<IXReference<? extends IImplementationModelElement<?>,?>> incoming;
	boolean beingProcessed = false;

	
	public BuildUnit(IJittacResource resource, ImplementationModelPartition partition) {
		this.resource = resource;
		this.partition = partition;
		common = new HashSet<>();
		added = new HashSet<>();
		current = new HashSet<>();
		incoming = new HashSet<>();
	}
	
	/**
	 * Adds a reference to the implementation model.
	 * @param xref The reference to be added.
	 */
	public void addXReference(IXReference<? extends IImplementationModelElement<?>,?> xref) {
		if (!beingProcessed) return;
		//ArrayList<IXReference<T>> temp = new ArrayList<>(current);
		if (current.remove(xref)) {
			common.add(xref);
		} else {
			added.add(xref);
		}
	}
	
	public void loadReference(IXReference<? extends IImplementationModelElement<?>,?> xref) {
		if (beingProcessed) return;
		current.add(xref);
		getOppositeBuildUnit(xref).addIncomingReference(xref);
	}
	
	public void start() {
		if (beingProcessed) return;
		beingProcessed = true;
		common.clear();
		added.clear();
	}
	
	public void end() {
		if (!beingProcessed) return;
		Set<IXReference<? extends IImplementationModelElement<?>,?>> removed = new HashSet<>();
		removed.addAll(current);
		current.clear();
		current.addAll(common);
		current.addAll(added);
		for (IXReference<?,?> ref : removed) {
			getOppositeBuildUnit(ref).removeIncomingReference(ref);
		}
		for (IXReference<?,?> ref : added) {
			getOppositeBuildUnit(ref).addIncomingReference(ref);
		}
		
		beingProcessed = false;
		//fire event
		this.partition.
			getImplementationModel().
				fireChangeEvent(XReferenceChangeDeltaEvent.create(added, removed, common));
	}
	
	public void clear() {
		added.clear();
		common.clear();
		current.clear();
	}
	
	public Set<IXReference<?,?>> getReferences() {
		//TODO: better throw exception if unit is being processed
		if (beingProcessed) return new HashSet<IXReference<? extends IImplementationModelElement<?>,?>>();
		return new HashSet<IXReference<? extends IImplementationModelElement<?>,?>>(current);
	}
	
	public Set<IXReference<?,?>> getIncomingReferences() {
		return new HashSet<IXReference<?,?>>(incoming);
	}
	
	private boolean addIncomingReference(IXReference<? extends IImplementationModelElement<?>,?> ref) {
		if (!incoming.contains(ref)) {
			incoming.add(ref);
			return true;
		}
		return false;
	}
	
	private boolean removeIncomingReference(IXReference<? extends IImplementationModelElement<?>,?> ref) {
		return incoming.remove(ref);
	}
	
	private BuildUnit getOppositeBuildUnit(IXReference<? extends IImplementationModelElement<?>,?> ref) {
		IImplementationModelElement<?> trg = ref.getTarget();
		return trg.getPartition().getUnit(trg.getResource());
	}
	
	public IJittacResource getResource() {
		return resource;
	}
}
"
AbstractBuildEventListener.java,impl-model,"package se.kau.cs.jittac.model.im.events;

public abstract class AbstractBuildEventListener implements BuildEventListener {

	@Override
	public void onBuildStart(BuildStartEvent event) {
	}

	@Override
	public void onBuildEnd(BuildEndEvent event) {
	}
	
	public void onBuildEvent(BuildEvent event) {
		if (event instanceof BuildStartEvent) {
			onBuildStart((BuildStartEvent) event);
		}
		else if (event instanceof BuildEndEvent) {
			onBuildEnd((BuildEndEvent) event);
		}
	}

}
"
BuildEndEvent.java,impl-model,"package se.kau.cs.jittac.model.im.events;

import se.kau.cs.jittac.model.im.ImplementationModelPartition;

public class BuildEndEvent implements BuildEvent {

	private ImplementationModelPartition part;
	
	public BuildEndEvent(ImplementationModelPartition part) {
		this.part = part;
	}
	
	@Override
	public ImplementationModelPartition getPartition() {
		return part;
	}

}
"
BuildEvent.java,impl-model,"package se.kau.cs.jittac.model.im.events;

import se.kau.cs.jittac.model.im.ImplementationModelPartition;

public interface BuildEvent {

	public ImplementationModelPartition getPartition();
}
"
BuildEventListener.java,impl-model,"package se.kau.cs.jittac.model.im.events;

import se.kau.cs.jittac.model.im.IImplementationModel;
import se.kau.cs.jittac.model.im.ImplementationModelPartition;

public interface BuildEventListener {

	public void onBuildStart(BuildStartEvent event);
	
	public void onBuildEnd(BuildEndEvent event);
	
	public void onBuildEvent(BuildEvent event);
}
"
BuildStartEvent.java,impl-model,"package se.kau.cs.jittac.model.im.events;

import se.kau.cs.jittac.model.im.ImplementationModelPartition;

public class BuildStartEvent implements BuildEvent {

	private ImplementationModelPartition part;
	
	public BuildStartEvent(ImplementationModelPartition part) {
		this.part = part;
	}
	
	@Override
	public ImplementationModelPartition getPartition() {
		return part;
	}

}
"
IImplementationChangeListener.java,impl-model,"package se.kau.cs.jittac.model.im.events;

import se.kau.cs.jittac.model.im.IImplementationModel;

public interface IImplementationChangeListener {

	void onXReferenceDeltaEvent(XReferenceChangeDeltaEvent event);
	void onCompleteLoad(IImplementationModel im);
}
"
XReferenceChangeDeltaEvent.java,impl-model,"package se.kau.cs.jittac.model.im.events;

import java.util.HashSet;
import java.util.Set;

import se.kau.cs.jittac.model.im.IXReference;

/**
 * This class encapsulates information about modifications in
 * an implementation model and is passed on to the corresponding listeners.
 * The information is stored in terms of added and removed references, as well
 * as unchanged elements to be easily able to detect references that stayed
 * the same in a certain scope of the implementation model (such as a build increment).
 * @author sebahero
 *
 */
public class XReferenceChangeDeltaEvent {

	private Set<IXReference<?,?>> added;
	private Set<IXReference<?,?>> removed;	
	private Set<IXReference<?,?>> unchanged;

	/**
	 * Creates an event object for a modification corresponding to the given
	 * sets of references
	 * @param added References added through this modification. May not be null.
	 * @param removed References removed through this modification. May not be null.
	 * @param unchanged References that should be declared as unchanged through this modification. May not be null.
	 * @return A new event object, never null.
	 */
	public static XReferenceChangeDeltaEvent create(Set<? extends IXReference<?,?>> added, 
			Set<? extends IXReference<?,?>> removed, Set<? extends IXReference<?,?>> unchanged) {
		return new XReferenceChangeDeltaEvent(added, removed, unchanged);
	}
	
	private XReferenceChangeDeltaEvent(Set<? extends IXReference<?,?>> added, 
			Set<? extends IXReference<?,?>> removed, Set<? extends IXReference<?,?>> unchanged) {
		this.added = new HashSet<IXReference<?,?>>(added);
		this.removed = new HashSet<IXReference<?,?>>(removed);
		this.unchanged = new HashSet<IXReference<?,?>>(unchanged);
	}
	
	/**
	 * Returns the added references as set. Never null.
	 * @return see above.
	 */
	public Set<IXReference<?,?>> addedReferences() {
		return new HashSet<IXReference<?,?>>(added);
	}
	
	/**
	 * Returns the set of removed references. Never null.
	 * @return see above.
	 */
	public Set<IXReference<?,?>> removedReferences() {
		return new HashSet<IXReference<?,?>>(removed);
	}
	
	/**
	 * Returns the set of references stored as unchanged. Never null.
	 * @return see above.
	 */
	public Set<IXReference<?,?>> unchangedReferences() {
		return new HashSet<IXReference<?,?>>(unchanged);
	}
	
}
"
IImplementationModel.java,impl-model,"package se.kau.cs.jittac.model.im;

import java.util.Set;

import se.kau.cs.jittac.model.im.events.BuildEvent;
import se.kau.cs.jittac.model.im.events.BuildEventListener;
import se.kau.cs.jittac.model.im.events.IImplementationChangeListener;
import se.kau.cs.jittac.model.im.events.XReferenceChangeDeltaEvent;
import se.kau.cs.jittac.model.mapping.IJittacProject;
import se.kau.cs.jittac.model.mapping.IMappableElement;

/**
 * Interface for implementation models.
 * These must consist of (at least) a collection of references (IXReference).
 * They are populated by implementation model builders.
 * Each IJittacProject is associated with exactly one implementation model,
 * meaning that a singe implementation model can be populated by different
 * builders (e.g., one for Java source code, one interpreting Spring XML files).
 * 
 * @author Sebastian Herold
 *
 */
public interface IImplementationModel {
	
	/**
	 * Returns the project that this model belongs to.
	 * @return see above.
	 */
	public IJittacProject getProject();

	public Set<ImplementationModelPartition> getPartitions();
	
	/**
	 * Retrieves all references in the implementation model that are contained in the given resource.
	 * @param elem The resources for which the references are returned.
	 * @return The set of references if any, an empty set if there are no references for the resource.
	 */
	public Set<? extends IXReference<? extends IImplementationModelElement<?>,?>>
	getReferencesForResource(IMappableElement elem);
	
	public Set<? extends IXReference<? extends IImplementationModelElement<?>,?>>
	getReferencesForResource(IMappableElement elem, ImplementationModelPartitionType type);

	/**
	 * Retrieves all references in the implementation model that are contained in the given resource or its subresources.
	 * @param elem The resources for which the references are returned.
	 * @return The set of references if any, an empty set if there are no references for the resource.
	 */
	public Set<? extends IXReference<? extends IImplementationModelElement<?>,?>>
	getReferencesForResourceTree(IMappableElement elem);
	
	public Set<? extends IXReference<? extends IImplementationModelElement<?>,?>>
	getReferencesForResourceTree(IMappableElement elem, ImplementationModelPartitionType type);

	public Set<? extends IXReference<? extends IImplementationModelElement<?>,?>>
	getIncomingReferencesForResource(IMappableElement elem);
	
	public Set<? extends IXReference<? extends IImplementationModelElement<?>,?>>
	getIncomingReferencesForResource(IMappableElement elem, ImplementationModelPartitionType type);
	
	public ImplementationModelPartition getPartitionForBuilderType(ImplementationModelPartitionType type);
	
	
	/**
	 * Registers  a listener with the implementation model that will
	 * be notified in case of modifications in the implementation model.
	 * @param listener The listener to be added.
	 */
	public void registerImplementationChangeListener(IImplementationChangeListener listener);
	
	/**
	 * Deregisters a listener. No effect if the given listener is not registered.
	 * @param listener The listener to be removed.
	 */
	public void deregisterImplementationChangeListener(IImplementationChangeListener listener);
	
	public void fireChangeEvent(XReferenceChangeDeltaEvent event);
	
	public void registerBuildEventListener(BuildEventListener listener);
	
	public void deregisterBuildEventListener(BuildEventListener listener);
	
	public void fireBuildEvent(BuildEvent event);
	
	public void fireCompleteLoad();
}
"
IImplementationModelElement.java,impl-model,"package se.kau.cs.jittac.model.im;

import se.kau.cs.jittac.model.mapping.IJittacResource;

/**
 * Interface representing elements in implementation models
 * that are connected via references.
 * 
 * @author Sebastian Herold
 *
 */
public interface IImplementationModelElement<T> {

	/**
	 * Returns the implementation model that the element belongs to.
	 * @return see above.
	 */
	public ImplementationModelPartition getPartition();
	/**
	 * Returns the resource that the element is contained in.
	 * @return see above.
	 */
	public IJittacResource getResource();
	
	public T getElement();
}
"
ImplementationModel.java,impl-model,"package se.kau.cs.jittac.model.im;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import se.kau.cs.jittac.model.im.events.BuildEvent;
import se.kau.cs.jittac.model.im.events.BuildEventListener;
import se.kau.cs.jittac.model.im.events.IImplementationChangeListener;
import se.kau.cs.jittac.model.im.events.XReferenceChangeDeltaEvent;
import se.kau.cs.jittac.model.mapping.IJittacProject;
import se.kau.cs.jittac.model.mapping.IJittacResource;
import se.kau.cs.jittac.model.mapping.IMappableElement;

public class ImplementationModel implements IImplementationModel {

	private IJittacProject project;
	private List<IImplementationChangeListener> changeListeners = new ArrayList<IImplementationChangeListener>();
	private List<BuildEventListener> buildEventListeners = new ArrayList<BuildEventListener>();
	
	private Map<ImplementationModelPartitionType, ImplementationModelPartition> partitionsMap = new HashMap<>();

	public ImplementationModel(IJittacProject project) {
		this.project = project;
	}

	@Override
	public IJittacProject getProject() {
		return this.project;
	}

	@Override
	public Set<ImplementationModelPartition>
	getPartitions() {
		return new HashSet<>(partitionsMap.values());
	}

	@Override
	public Set<? extends IXReference<? extends IImplementationModelElement<?>,?>>
	getReferencesForResource(IMappableElement elem) {
		//Set<IXReference<?,?>> result = new HashSet<>();
		Set<IXReference<? extends IImplementationModelElement<?>,?>> result = new HashSet<>();
		//We don't allow references directly at project level, it's always resources
		if (elem instanceof IJittacResource) {
			IJittacResource res = (IJittacResource) elem;
			//TODO: better throw exception if elem is not in the model's project
			if (!res.getProject().equals(getProject())) return result;
			for (ImplementationModelPartition part : getPartitions()) {
				result.addAll(part.getReferences(res));
			}
		}
		return result;
	}

	@Override
	public Set<? extends IXReference<? extends IImplementationModelElement<?>,?>>
	getReferencesForResource(IMappableElement elem,	ImplementationModelPartitionType builderType) {
		Set<IXReference<? extends IImplementationModelElement<?>,?>> result = new HashSet<>();
		if (elem instanceof IJittacResource) {
			IJittacResource res = (IJittacResource) elem;
			//TODO: better throw exception if elem is not in the model's project
			if (!elem.getProject().equals(getProject())) return result;
			ImplementationModelPartition part = getPartitionForBuilderType(builderType);
			result.addAll(part.getReferences(res));
		}
		return result;
	}

	@Override
	public Set<? extends IXReference<? extends IImplementationModelElement<?>,?>>
	getReferencesForResourceTree(IMappableElement elem) {
		//TODO: better throw exception if elem is not in the model's project
		Set<IXReference<? extends IImplementationModelElement<?>,?>> result = new HashSet<>();
		if (!elem.getProject().equals(getProject())) return result;
		result.addAll(getReferencesForResource(elem));
		for (IJittacResource child : elem.getChildren()) {
			result.addAll(getReferencesForResourceTree(child));
		}
		return result;
	}

	@Override
	public Set<? extends IXReference<? extends IImplementationModelElement<?>,?>>
	getReferencesForResourceTree(
			IMappableElement elem, ImplementationModelPartitionType builderType) {
		//TODO: better throw exception if elem is not in the model's project
		Set<IXReference<? extends IImplementationModelElement<?>,?>> result = new HashSet<>();
		if (!elem.getProject().equals(getProject())) return result;
		result.addAll(getReferencesForResource(elem, builderType));
		for (IJittacResource child : elem.getChildren()) {
			result.addAll(getReferencesForResourceTree(child, builderType));
		}
		return result;

	}

	@Override
	public 	ImplementationModelPartition getPartitionForBuilderType(ImplementationModelPartitionType type) {
		
		if (partitionsMap.containsKey(type)) {
			return partitionsMap.get(type);
		}
		else {
			ImplementationModelPartition newPartition = createPartition(type);
			partitionsMap.put(type, newPartition);
			return newPartition;
		}

	}

	@Override
	public void registerImplementationChangeListener(IImplementationChangeListener listener) {
		if (!changeListeners.contains(listener)) {
			changeListeners.add(listener);
		}
	}

	@Override
	public void deregisterImplementationChangeListener(IImplementationChangeListener listener) {
		changeListeners.remove(listener);
	}

	@Override
	public void fireChangeEvent(XReferenceChangeDeltaEvent event) {
		for (IImplementationChangeListener l : changeListeners) {
			l.onXReferenceDeltaEvent(event);
		}
	}
	
	protected ImplementationModelPartition createPartition(ImplementationModelPartitionType type) {
		return new ImplementationModelPartition(this,type);
	}

	@Override
	public void registerBuildEventListener(BuildEventListener listener) {
		if (!buildEventListeners.contains(listener)) {
			buildEventListeners.add(listener);
		}
		
	}

	@Override
	public void deregisterBuildEventListener(BuildEventListener listener) {
		buildEventListeners.remove(listener);
	}

	@Override
	public void fireBuildEvent(BuildEvent event) {
		for (BuildEventListener l : buildEventListeners) {
			l.onBuildEvent(event);
		}
	}

	@Override
	public void fireCompleteLoad() {
		for (IImplementationChangeListener l : changeListeners) {
			l.onCompleteLoad(this);
		}
	}

	@Override
	public Set<? extends IXReference<? extends IImplementationModelElement<?>, ?>> getIncomingReferencesForResource(
			IMappableElement elem) {
		Set<IXReference<? extends IImplementationModelElement<?>,?>> result = new HashSet<>();
		for (ImplementationModelPartition part : this.getPartitions()) {
			result.addAll(getIncomingReferencesForResource(elem, part.getBuilderType()));
		}
		return result;
	}

	@Override
	public Set<? extends IXReference<? extends IImplementationModelElement<?>, ?>> getIncomingReferencesForResource(
			IMappableElement elem, ImplementationModelPartitionType type) {
		Set<IXReference<? extends IImplementationModelElement<?>,?>> result = new HashSet<>();
		if (elem instanceof IJittacResource) {
			IJittacResource res = (IJittacResource) elem;
			//TODO: better throw exception if elem is not in the model's project
			if (!elem.getProject().equals(getProject())) return result;
			ImplementationModelPartition part = getPartitionForBuilderType(type);
			result.addAll(part.getIncomingReferences(res));
		}
		return result;
	}
}
"
ImplementationModelBuilder.java,impl-model,"package se.kau.cs.jittac.model.im;

/**
 * Interface for implementation model builders - classes populating
 * implementation models, e.g. by parsing source code.
 * 
 * @author Sebastian Herold
 *
 */

public interface ImplementationModelBuilder {
	
	/**
	 * Returns the type of a builder.
	 * @return see above.
	 */
	public ImplementationModelPartitionType getType();
	
	public ImplementationModelPartition getPartition();
	
		
	//public void start();
	
	//public boolean isRunning();
}
"
ImplementationModelFactory.java,impl-model,"package se.kau.cs.jittac.model.im;

public interface ImplementationModelFactory
<T extends IImplementationModelElement<E>,E,
 U extends IXReference<T, F> ,F>	 {

	public T createElement(E element, ImplementationModelPartition partition);
	
	public U createReference(
		T src,
		T trg,
		IXReferenceType type,
		F internalRef);
	
	public IXReference<T,F> createExternalReference(
			T src,
			IImplementationModelElement<?> trg,
			IXReferenceType type,
			F internalRef);
	
	public ImplementationModelPartitionType getPartitionType();
	
	public String serializeInternalReference(IXReference<?,?> reference);
	
	public String serializeExternalReference(IXReference<?,?> reference);
	
	public String serializeLocalElement(T element);
	
	public T deserializeLocalElement(String elementAsString, ImplementationModelPartition partition);
	
	public U deserializeInternalReference(String referenceAsString, 
			ImplementationModelPartition partition);
	
	public IXReference<T,?> deserializeExternalReference(String referenceAsString,
			ImplementationModelPartition partition);
}
"
ImplementationModelFactoryRegistry.java,impl-model,"package se.kau.cs.jittac.model.im;

import java.util.HashMap;

public class ImplementationModelFactoryRegistry {
	
	private static ImplementationModelFactoryRegistry INSTANCE =
			new ImplementationModelFactoryRegistry();
	
	@SuppressWarnings(""rawtypes"")
	HashMap<String, ImplementationModelFactory> factories =
			new HashMap<String, ImplementationModelFactory>();
	
	
	public  <T extends IImplementationModelElement<E>,E, U extends IXReference<T,F>,F>
	boolean register(ImplementationModelFactory<T,E,U,F> factory) {
		String typeName = factory.getPartitionType().getName();
		if (factories.containsKey(typeName)) {
			return false;
		}
		else {
			factories.put(typeName, factory);
			return true;
		}
	}

	public 	void deregister(ImplementationModelPartitionType type) {
		factories.remove(type.getName());
	}
	
	public  <T extends IImplementationModelElement<E>,E, U extends IXReference<T,F>,F>
	ImplementationModelFactory<T,E,U,F> getFactory(ImplementationModelPartitionType type) {
		return getFactory(type.getName());
	}
	
	public  <T extends IImplementationModelElement<E>,E, U extends IXReference<T,F>,F>
	ImplementationModelFactory<T,E,U,F> getFactory(String typeName) {
		return factories.get(typeName);
	}
	
	public static ImplementationModelFactoryRegistry instance() {
		return INSTANCE;
	}
}
"
ImplementationModelPartition.java,impl-model,"package se.kau.cs.jittac.model.im;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import se.kau.cs.jittac.model.im.events.BuildEndEvent;
import se.kau.cs.jittac.model.im.events.BuildStartEvent;
import se.kau.cs.jittac.model.mapping.IJittacResource;

public class ImplementationModelPartition {

	public static enum State {
		INIT, BUILDING, IDLE;
	}
	
	private IImplementationModel im;
	private ImplementationModelPartitionType type;
	private Map<IJittacResource, BuildUnit> buildUnits;
	private List<BuildUnit> currentUnits;
	private State state;
	
	public ImplementationModelPartition(IImplementationModel im, ImplementationModelPartitionType type) {
		this.im = im;
		this.type = type;
		currentUnits = new ArrayList<>();
		state = State.IDLE;
		buildUnits = new HashMap<>();
	}
	
	public synchronized State startBuild() {
		if (state == State.IDLE) {
			state = State.BUILDING;
			im.fireBuildEvent(new BuildStartEvent(this));
		}
		else {
			//TODO: exception?
		}
		return state;
	}
	
	public synchronized State endBuild() {
		if (state == State.BUILDING) {
			im.fireBuildEvent(new BuildEndEvent(this));
			state = State.IDLE;
		}
		else {
			//TODO: exception?
		}
		return state;
	}
	
	public synchronized State startInit() {
		if (state == State.IDLE) {
			state = State.INIT;
		}
		else {
			//TODO: exception?
		}
		return state;
	}
	
	public synchronized State endInit() {
		if (state == State.INIT) {
			state = State.IDLE;
		} 
		else {
			//TODO: exception?
		}
		return state;
	}
	
	public synchronized BuildUnit startUnit(IJittacResource resourceOfUnit) {
		if (state == State.BUILDING) {
			BuildUnit unit = getUnit(resourceOfUnit);
			if (!currentUnits.contains(unit)) {
				currentUnits.add(unit);
				unit.start();
			}
			return unit;
		}
		return null;
	}
	
	public synchronized void endUnit(BuildUnit unit)  {
		
		if (currentUnits.contains(unit) && state == State.BUILDING) {
			unit.end();
			currentUnits.remove(unit);
		}
	}
	
	public void clearUnit(BuildUnit unit) {
		unit.clear();
	}

	public IImplementationModel getImplementationModel() {
		return im;
	}

	public ImplementationModelPartitionType getBuilderType() {
		return type;
	}
	
	public synchronized void addReference(IXReference<? extends IImplementationModelElement<?>,?> ref) {
		BuildUnit unit = this.getUnit(ref.getResource());
		if (state == State.BUILDING) {
			unit.addXReference(ref);
		}
		else if (state == State.INIT) {
			unit.loadReference(ref);
		}
	}
	
	public Set<? extends IXReference<? extends IImplementationModelElement<?>,?>> getReferences(IJittacResource res) {
		if (buildUnits.containsKey(res)) {
			return buildUnits.get(res).getReferences();
		}
		else {
			return new HashSet<IXReference<?,?>>();
		}
	}
	
	public Set<? extends IXReference<? extends IImplementationModelElement<?>,?>>
	getIncomingReferences(IJittacResource resource) {
		if (buildUnits.containsKey(resource)) {
			return buildUnits.get(resource).getIncomingReferences();
		}
		else {
			return new HashSet<IXReference<?,?>>();
		}

	}
	
	public Set<? extends IXReference<?,?>> getReferences() {
		//Set<IXReference<?,?>> result = new HashSet<IXReference<?,?>>();
		Set<IXReference<? extends IImplementationModelElement<?>,?>> result = new HashSet<>();
		for (BuildUnit unit : buildUnits.values()) {
			result.addAll(unit.getReferences());
		}
		return result;
	}
	
	public BuildUnit getUnit(IJittacResource resourceOfUnit) {
		BuildUnit unit = buildUnits.get(resourceOfUnit);
		if (unit == null) {
			unit = new BuildUnit(resourceOfUnit, this);
			buildUnits.put(resourceOfUnit, unit);
		}
		return unit;
	}
}
"
ImplementationModelPartitionType.java,impl-model,"package se.kau.cs.jittac.model.im;

/**
 * Interface to be implemented for different types of
 * builders, e.g. Java builder based on JDT.
 * @author Sebastian Herold
 *
 */
public interface ImplementationModelPartitionType {
	
	public String getName();
	
	public Class<?> getElementType();
	
	public Class<?> getReferenceType();
	
	//public ImplementationModelFactory<T,E,U,F> getFactory();
}
"
ImplementationModelReader.java,impl-model,"package se.kau.cs.jittac.model.im.io;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;

import se.kau.cs.jittac.model.im.IImplementationModel;
import se.kau.cs.jittac.model.im.IXReference;
import se.kau.cs.jittac.model.im.ImplementationModelFactory;
import se.kau.cs.jittac.model.im.ImplementationModelFactoryRegistry;
import se.kau.cs.jittac.model.im.ImplementationModelPartition;

/**
 * Very primitive implementation - might need redesign soon
 * Lines either start with <INTERNAL> or a partition type identifier
 * @author sebahero
 *
 */
public class ImplementationModelReader {
	

	public static void read(InputStream input, IImplementationModel model) {
		String line;
		ImplementationModelFactory<?,?,?,?> factory = null;
		ImplementationModelPartition partition = null;
		
		try (BufferedReader reader = new BufferedReader(new InputStreamReader(input))) {
			while ((line = reader.readLine()) != null) {
				if (line.startsWith(""\""<INTERNAL>\"""")) {
					if (factory != null && partition != null) {
						IXReference<?,?> ref = factory.deserializeInternalReference(line, partition);
						partition.addReference(ref);
					}
				}
				else {
					if (partition != null) {
						partition.endInit();
					}
					factory = ImplementationModelFactoryRegistry.instance().getFactory(line);
					partition = model.getPartitionForBuilderType(factory.getPartitionType());
					if (partition != null) {
						partition.startInit();
					}
				}
			}
			if (partition != null) {
				partition.endInit();
			}
			//TODO: The following only works for one-partition projects because the event is raised
			//after each partition (instead of once after the complete model). To be changed.
			model.fireCompleteLoad();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
	}
}
"
ImplementationModelWriter.java,impl-model,"package se.kau.cs.jittac.model.im.io;

import java.io.IOException;
import java.io.OutputStream;
import java.io.OutputStreamWriter;

import se.kau.cs.jittac.model.im.IImplementationModel;
import se.kau.cs.jittac.model.im.IImplementationModelElement;
import se.kau.cs.jittac.model.im.IXReference;
import se.kau.cs.jittac.model.im.ImplementationModelFactory;
import se.kau.cs.jittac.model.im.ImplementationModelFactoryRegistry;
import se.kau.cs.jittac.model.im.ImplementationModelPartition;

public class ImplementationModelWriter {
	
	public static void write(OutputStream out, IImplementationModel model) {
		
		writeHeader(out, model);
		for (ImplementationModelPartition part : model.getPartitions()) {
			writePartition(out, part);
		}
		writeFooter(out, model);
	}

	
	public static void writePartition(OutputStream out, ImplementationModelPartition partition) {
		
		ImplementationModelFactory<?,?,?,?> factory = 
				ImplementationModelFactoryRegistry.instance().getFactory(partition.getBuilderType());
	
		try (OutputStreamWriter writer = new OutputStreamWriter(out)) {
			if (factory != null) {
				writer.write(partition.getBuilderType().getName() + ""\n"");
				for(IXReference<? extends IImplementationModelElement<?>,?> ref : partition.getReferences()) {
					writer.write(factory.serializeInternalReference(ref) + ""\n"");
				}
			}
		} catch (IOException e) {
			e.printStackTrace();
		} 
		
	}
	
	public static void writeHeader(OutputStream out, IImplementationModel model) {
		
	}
	
	public static void writeFooter(OutputStream out, IImplementationModel model) {
		
	}
}
"
IXReference.java,impl-model,"package se.kau.cs.jittac.model.im;

import se.kau.cs.jittac.model.mapping.IJittacResource;

/**
 * This class encapsulates references which are the primary 
 * elements in implementation models. They represent different
 * ways of how elements in the implementation of a system might 
 * depend on other elements (e.g., calls to methods, import 
 * statements, inheritance,...). A reference is always directed.
 * 
 * @author Sebastian Herold
 */
public interface IXReference<T extends IImplementationModelElement<?>, U> {
	/**
	 * Returns the reference's model partition that the reference belongs to.
	 * In case of references connecting elements in different
	 * implementation models, this is, by definition, the model
	 * that the reference's source element is belonging to.
	 * @return see above.
	 */
	public ImplementationModelPartition getPartition();
	/**
	 * Returns the type of the reference.
	 * @return see above.
	 */
	public IXReferenceType getType();
	/**
	 * Returns the source element of the violation
	 * @return See above.
	 */
	public T getSource();
	/**
	 * Returns the target element of the violation
	 * @return see above.
	 */
	public IImplementationModelElement<?> getTarget();
	/**
	 * Returns the ""physical"" resource that the reference belongs
	 * to. By definition, this is the same resource that the source
	 * of the dependency belongs to.
	 * @return see above.
	 */
	public IJittacResource getResource();
	
	/**
	 * Returns some internal representation of the reference, e.g. the AST node
	 * representing the call/access/etc. in source code.
	 * @return
	 */
	public U getInternalReference();
}
"
IXReferenceType.java,impl-model,"package se.kau.cs.jittac.model.im;

/**
 * The different types of references supported in Jittac.
 * @author Sebastian Herold
 */
public enum IXReferenceType {
	UNKNOWN,
	ACCESS,
	ASSIGNMENT,
	CALL,
	CREATION,
	IMPORT,
	CONTAINMENT,
	TYPEREF;
}
"
BaseHandler.java,jdt-build,"package se.kau.cs.jittac.eclipse.builders.jdt.commands;

import static java.util.Collections.emptyList;
import static se.kau.cs.jittac.eclipse.builders.jdt.util.Projects.extractProjectsWithJavaNature;

import java.util.Collection;

import org.eclipse.core.commands.AbstractHandler;
import org.eclipse.core.commands.HandlerEvent;
import org.eclipse.core.expressions.IEvaluationContext;
import org.eclipse.core.resources.IProject;

abstract class BaseHandler extends AbstractHandler {
    
    /**
     * Extracts projects from selection for on which this action can be applied.
     * 
     * All other objects are ignored.
     * 
     * @param context evaluation context representing the selection
     * @return collection of projects, never {@code null}
     */
    protected Collection<IProject> extractApplicableProjects(IEvaluationContext context) {
        Object variable = context.getDefaultVariable();
        if (variable instanceof Collection) {
            return extractProjectsWithJavaNature((Collection<?>) variable);
        }

        return emptyList();
    }
    
    /*protected Collection<IProject> extractApplicableProjects(IEvaluationContext context) {
    	
    }*/
    
	protected void fireHadlerChanged(boolean enabledChanged, boolean handledChanged) {
	    fireHandlerChanged(new HandlerEvent(this, enabledChanged, handledChanged));
	}
}
"
DisableJavaCodeAnalysisHandler.java,jdt-build,"package se.kau.cs.jittac.eclipse.builders.jdt.commands;

import static com.google.common.collect.Lists.newArrayList;

import java.util.ArrayList;
import java.util.Collection;


import se.kau.cs.jittac.eclipse.JittacJavaNature;

import org.eclipse.core.commands.ExecutionEvent;
import org.eclipse.core.commands.ExecutionException;
import org.eclipse.core.expressions.EvaluationContext;
import org.eclipse.core.expressions.IEvaluationContext;
import org.eclipse.core.resources.IProject;
import org.eclipse.core.resources.IProjectDescription;
import org.eclipse.core.runtime.CoreException;
import org.eclipse.jdt.core.JavaCore;

public class DisableJavaCodeAnalysisHandler extends BaseHandler {

	@Override
	public Object execute(ExecutionEvent event) throws ExecutionException {
		Collection<IProject> projects
		        = extractApplicableProjects((IEvaluationContext) event.getApplicationContext());
		
        for (IProject project: projects) {
            try {
                if (!project.isOpen() 
                    || !project.hasNature(JavaCore.NATURE_ID)
                    || !project.hasNature(JittacJavaNature.NATURE_ID)) {
                    continue;
                }

                IProjectDescription desc = project.getDescription();
                
                ArrayList<String> natures = newArrayList();
                for (String nature: desc.getNatureIds()) {
                    if (!JittacJavaNature.NATURE_ID.equals(nature)){
                        natures.add(nature);
                    }
                }
                
                desc.setNatureIds(natures.toArray(new String[natures.size()]));
                project.setDescription(desc, null);
            } catch (CoreException e) {
//                errorStatus(""Error removing JITTAC nature: "" + JittacJavaNature.NATURE_ID, e);
            }
        }

        return null;
	}
}
"
EnableJavaCodeAnalysisHandler.java,jdt-build,"package se.kau.cs.jittac.eclipse.builders.jdt.commands;

import static com.google.common.collect.ObjectArrays.concat;
//import static net.sourceforge.actool.jdt.ACToolJDT.errorStatus;

import java.util.Collection;

//import jittac.jdt.JavaAC;
import se.kau.cs.jittac.eclipse.JittacJavaNature;

import org.eclipse.core.commands.ExecutionEvent;
import org.eclipse.core.commands.ExecutionException;
import org.eclipse.core.expressions.EvaluationContext;
import org.eclipse.core.expressions.IEvaluationContext;
import org.eclipse.core.resources.IProject;
import org.eclipse.core.resources.IProjectDescription;
import org.eclipse.core.runtime.CoreException;
import org.eclipse.jdt.core.JavaCore;

public class EnableJavaCodeAnalysisHandler extends BaseHandler {

	@Override
	public Object execute(ExecutionEvent event) throws ExecutionException {
		/*Collection<IProject> projects
		        = extractApplicableProjects((EvaluationContext) event.getApplicationContext());*/
		Collection<IProject> projects
        	= extractApplicableProjects((IEvaluationContext) event.getApplicationContext());
		
		for (IProject project: projects) {
        	try {
        	    if (!project.isOpen() 
        	        || !project.hasNature(JavaCore.NATURE_ID)
        	        || project.hasNature(JittacJavaNature.NATURE_ID)) {
        	        continue;
        	    }

                IProjectDescription desc = project.getDescription();
                desc.setNatureIds(concat(desc.getNatureIds(), JittacJavaNature.NATURE_ID));
                project.setDescription(desc, null);
        	} catch (CoreException e) {
//        	    errorStatus(""Errora adding JITTAC nature: "" + JittacJavaNature.NATURE_ID, e);
        	}
		}

		return null;
	}
}
"
FeatureAnnotationProcessor.java,jdt-build,"package se.kau.cs.jittac.eclipse.builders.jdt;

import org.eclipse.core.resources.IResource;
import org.eclipse.jdt.core.ICompilationUnit;
import org.eclipse.jdt.core.JavaModelException;
import org.eclipse.jdt.core.dom.ASTVisitor;
import org.eclipse.jdt.core.dom.LineComment;

import se.kau.cs.jittac.model.feature.Feature;
import se.kau.cs.jittac.model.feature.FeatureLocation;
import se.kau.cs.jittac.model.feature.FeatureLocationRegistry;
import se.kau.cs.jittac.model.mapping.eclipse.EclipseJittacProject;
import se.kau.cs.jittac.model.mapping.eclipse.EclipseJittacResource;

/**
 * 
 * @author Sebastian Herold
 *
 * Parser for processing feature annotations as defined in the Florida tool by GU/Chalmers.
 */
public class FeatureAnnotationProcessor extends ASTVisitor {
	
	private EclipseJittacProject project;
	private EclipseJittacResource currentResource;
	private ICompilationUnit source;
	private Feature currentFeature;
	private int currentFeatureStart = -1;
	
	protected static String BEGIN_FEATURE_COMMENT = ""&begin\\[\\S+\\]"";
	protected static String END_FEATURE_COMMENT = ""&end\\[\\S+\\]"";
	protected static String SINGLE_LINE_FEATURE_COMMENT = ""&line\\[\\S+\\]"";

	public FeatureAnnotationProcessor(EclipseJittacProject project) {
		
		this.project = project;
 	}
	
    public void init(ICompilationUnit source) {
    	
        try {
			IResource resource = source.getCorrespondingResource();
			currentResource = EclipseJittacResource.create(resource, project);
			FeatureLocationRegistry.INSTANCE.clear(currentResource);
			this.source = source;
			currentFeature = null;
		} catch (JavaModelException e) {
			e.printStackTrace();
		}
    }
    
    public boolean visit(LineComment node) {
    	
    	try {
    		String comment = source.getSource().substring(
    				node.getStartPosition() + 2,
    				node.getStartPosition() + node.getLength()).trim();
    		if (comment.matches(BEGIN_FEATURE_COMMENT)) {
    			handleBeginAnnotation(node, comment);
    		}
    		else if (comment.matches(END_FEATURE_COMMENT)) {
    			handleEndAnnotation(node, comment);
    		}
    		else if (comment.matches(SINGLE_LINE_FEATURE_COMMENT)) {
    			handleSingleLineAnnotation(node, comment);
    		}
		} catch (JavaModelException e) {
			e.printStackTrace();
		}

    	return true;
    }
    
    public void end() {
    	
		/*
		 * try { for (FeatureLocation fl :
		 * FeatureLocationRegistry.INSTANCE.getFeatureLocations(currentResource)) {
		 * System.out.println(fl.toString());
		 * System.out.println(source.getSource().substring(fl.getOffset(),
		 * fl.getOffset() + fl.getLength())); } currentResource = null; source = null; }
		 * catch (JavaModelException e) { e.printStackTrace(); }
		 */
    }
    
    protected void handleBeginAnnotation(LineComment node, String comment) {
    	
    	if (!insideFeature()) {
    		String featureName = extractFeatureName(comment);
    		startNewFeatureLocation(featureName, node.getStartPosition());
    	}
    }
    
    protected void handleEndAnnotation(LineComment node, String comment) {
    	
    	if (insideFeature()) {
    		String featureName = extractFeatureName(comment);
    		if (currentFeature.getName().compareTo(featureName) == 0) {
    			createFeatureLocation(node.getStartPosition() + node.getLength() - 1);
    			currentFeature = null;
    			currentFeatureStart = -1;
    		}
    	}
    }
    
    protected void handleSingleLineAnnotation(LineComment node, String comment) {
    	
    	try {
    		int featureLength = 0;
    		String[] nextLines = source.getSource().substring(node.getStartPosition()).split(""\n"", 3);
    		
    		if (nextLines.length <= 1) return;
    		while (nextLines[1].trim().isEmpty() && !nextLines[2].isEmpty()) {
    			if (nextLines.length == 2) return;
    			if (nextLines[2].isEmpty()) return;
    			featureLength += nextLines[1].length() + 1;
    			String[] temp = nextLines[2].split(""\n"", 2);
    			nextLines[1] = temp[0];
    			if (temp.length == 2) {
    				nextLines[2] = temp[1];
    			}
    			else {
    				nextLines[2] = """";
    			}
    		}
    		
			if (nextLines.length == 3) {
				String nextLine = nextLines[1];
				//Feature length: node length + line terminator + length of next line - remains of line terminator
				featureLength += node.getLength() + lineTerminatorLength(nextLines[0] + ""\n"") + nextLine.length() - (lineTerminatorLength(nextLine + ""\n"") - 1); 
				if (insideFeature()) {
					//Restart position: node start position + feature length + line terminator of code line
					splitCurrentFeature(node, node.getStartPosition() + featureLength + lineTerminatorLength(nextLine + ""\n""));
				}
				String featureName = extractFeatureName(comment);
				createFeatureLocation(
						Feature.getFeature(featureName),
						node.getStartPosition(),
						node.getStartPosition() + featureLength - 1);
			}
		} catch (JavaModelException e) {
			e.printStackTrace();
		}
    }
    
    protected void splitCurrentFeature(LineComment node, int restartPosition) {
    	
    	int endPosition = latestNonWhiteSpaceBefore(node);
    	if (endPosition != -1) {
    		createFeatureLocation(endPosition);
    		startNewFeatureLocation(currentFeature.getName(), restartPosition);
    	}
	}

    protected void startNewFeatureLocation(String name, int startPosition) {
    	
   		currentFeature = Feature.getFeature(name);
		currentFeatureStart = startPosition;
    }
    
    protected void createFeatureLocation(int endPosition) {
		createFeatureLocation(currentFeature, currentFeatureStart, endPosition);
    }
    
    protected void createFeatureLocation(Feature feature, int startPosition, int endPosition) {
    	
    	int featureLength = endPosition - startPosition + 1;
    	FeatureLocation fl = new FeatureLocation(feature, currentResource, startPosition, featureLength);
    	FeatureLocationRegistry.INSTANCE.registerFeatureLocation(fl);
    }
    
	protected String extractFeatureName(String comment) {
		
    	String[] commentComponents = comment.split(""[\\[\\]]"");
    	if (commentComponents.length == 2) {
    		return commentComponents[1];
    	}
    	else {
    		return """";
    	}
    }
    
    protected boolean insideFeature() {
    	
    	return currentFeature != null;
    }
    
    private int lineTerminatorLength(String line) {
    	
    	if (line.endsWith(""\r\n"")) return 2;
    	else if (line.endsWith(""\n"")) return 1;
    	return 0;
    }
    
    private int latestNonWhiteSpaceBefore(LineComment node) {

		boolean found = false;
		int i = 0;
    	try {
			while (!found) {
				if (node.getStartPosition() - ++i < 0) break;
				if (!Character.isWhitespace(source.getSource().charAt(node.getStartPosition() - i))) {
					found = true;
				}
			}
		} catch (JavaModelException e) {
			e.printStackTrace();
		}
    	return found ? node.getStartPosition() - i : -1;
    }
}"
JavaASTHandler.java,jdt-build,"package se.kau.cs.jittac.eclipse.builders.jdt;

import static com.google.common.base.Preconditions.checkNotNull;

import java.text.MessageFormat;
import java.util.List;

import se.kau.cs.jittac.model.im.IImplementationModel;
import se.kau.cs.jittac.model.mapping.eclipse.EclipseJittacProject;

import org.eclipse.core.runtime.IProgressMonitor;
import org.eclipse.jdt.core.ICompilationUnit;
import org.eclipse.jdt.core.dom.ASTRequestor;
import org.eclipse.jdt.core.dom.Comment;
import org.eclipse.jdt.core.dom.CompilationUnit;
import org.eclipse.jdt.core.dom.LineComment;

public class JavaASTHandler extends ASTRequestor {
    private static final MessageFormat progressMessageFormat
            = new MessageFormat(""[JITTAC] Extracting Java IA of ''{2}'' project (file {0} of {1}): {3}"");

    private IImplementationModel model;
    private IProgressMonitor monitor;
    private int total, processed = 0;
    private boolean processFeatureAnnotations = false;
    
    public JavaASTHandler(IImplementationModel model, int total, IProgressMonitor monitor) {
        this.model = checkNotNull(model);
        this.monitor = checkNotNull(monitor);
        this.total = total;
        activateFeatureAnnotationProcessing();
    }
    
    public void activateFeatureAnnotationProcessing() {
    	processFeatureAnnotations = true;
    }

    public void deactivateFeatureAnnotationProcessing() {
    	processFeatureAnnotations = false;
    }
    
    protected JavaASTProcessorSH createJavaASTProcessor() {
        JavaASTProcessorSH processor = new JavaASTProcessorSH(model);
//        processor.setIgnoreLibraryReferences(
//                preferenceStore().getBoolean(IGNORE_LIBRARY_REFERENCES));
//        processor.setIgnoreIntraProjectReferences(
//                preferenceStore().getBoolean(IGNORE_INTRAPROJECT_REFERENCES));
        processor.setIgnoreLibraryReferences(true);
        processor.setIgnoreIntraProjectReferences(false);

        return processor;
    }
    
    protected FeatureAnnotationProcessor createFeatureAnnotationProcessor() {
    	return new FeatureAnnotationProcessor((EclipseJittacProject) model.getProject());
    }

    private void updateSourcePath(ICompilationUnit source) {
        Object[] arguments = new Object[] {
            processed + 1, total, source.getJavaProject().getElementName(),
            source.getPath().removeLastSegments(1).toPortableString()
        };

        StringBuffer buffer = new StringBuffer(128);
        progressMessageFormat.format(arguments, buffer, null);
        monitor.subTask(buffer.toString());
    }

    @Override
    public void acceptAST(ICompilationUnit source, CompilationUnit ast) {
        updateSourcePath(source);

        try {
        	
            ast.accept(createJavaASTProcessor());
            if (processFeatureAnnotations) {
            	FeatureAnnotationProcessor featureProcessor = createFeatureAnnotationProcessor();
            	featureProcessor.init(source);
            	for (Comment comment : (List<Comment>) ast.getCommentList()) {
            		if (comment instanceof LineComment) { 
            			comment.accept(featureProcessor);
            		}
            	}
            	featureProcessor.end();
            }
            monitor.worked(1);
        } finally {
            //model.clearUnit();
            processed++;
        }
    }
}

"
JavaASTProcessorSH.java,jdt-build,"package se.kau.cs.jittac.eclipse.builders.jdt;

import static org.eclipse.jdt.core.IJavaElement.PACKAGE_FRAGMENT_ROOT;
import static org.eclipse.jdt.core.IPackageFragmentRoot.K_BINARY;

import java.util.Arrays;
import java.util.Iterator;
import java.util.Set;
import java.util.Stack;

import org.eclipse.core.resources.IResource;
import org.eclipse.jdt.core.ICompilationUnit;
import org.eclipse.jdt.core.IJavaElement;
import org.eclipse.jdt.core.IPackageFragmentRoot;
import org.eclipse.jdt.core.JavaModelException;
import org.eclipse.jdt.core.dom.ASTNode;
import org.eclipse.jdt.core.dom.ASTVisitor;
import org.eclipse.jdt.core.dom.AnonymousClassDeclaration;
import org.eclipse.jdt.core.dom.ArrayAccess;
import org.eclipse.jdt.core.dom.Assignment;
import org.eclipse.jdt.core.dom.ClassInstanceCreation;
import org.eclipse.jdt.core.dom.CompilationUnit;
import org.eclipse.jdt.core.dom.Expression;
import org.eclipse.jdt.core.dom.FieldAccess;
import org.eclipse.jdt.core.dom.FieldDeclaration;
import org.eclipse.jdt.core.dom.IBinding;
import org.eclipse.jdt.core.dom.IMethodBinding;
import org.eclipse.jdt.core.dom.ITypeBinding;
import org.eclipse.jdt.core.dom.IVariableBinding;
import org.eclipse.jdt.core.dom.ImportDeclaration;
import org.eclipse.jdt.core.dom.MethodDeclaration;
import org.eclipse.jdt.core.dom.MethodInvocation;
import org.eclipse.jdt.core.dom.Name;
import org.eclipse.jdt.core.dom.ParenthesizedExpression;
import org.eclipse.jdt.core.dom.QualifiedName;
import org.eclipse.jdt.core.dom.QualifiedType;
import org.eclipse.jdt.core.dom.SimpleName;
import org.eclipse.jdt.core.dom.SimpleType;
import org.eclipse.jdt.core.dom.SuperConstructorInvocation;
import org.eclipse.jdt.core.dom.SuperFieldAccess;
import org.eclipse.jdt.core.dom.SuperMethodInvocation;
import org.eclipse.jdt.core.dom.Type;
import org.eclipse.jdt.core.dom.TypeDeclaration;
import org.eclipse.jdt.core.dom.VariableDeclarationFragment;
import org.eclipse.jdt.core.dom.VariableDeclarationStatement;

import se.kau.cs.jittac.model.feature.Feature;
import se.kau.cs.jittac.model.feature.FeatureLocation;
import se.kau.cs.jittac.model.feature.FeatureLocationRegistry;
import se.kau.cs.jittac.model.im.BuildUnit;
import se.kau.cs.jittac.model.im.IImplementationModel;
import se.kau.cs.jittac.model.im.IXReferenceType;
import se.kau.cs.jittac.model.im.ImplementationModelFactory;
import se.kau.cs.jittac.model.im.ImplementationModelFactoryRegistry;
import se.kau.cs.jittac.model.im.ImplementationModelPartition;
import se.kau.cs.jittac.model.mapping.eclipse.EclipseJittacResource;
import se.kau.cs.jittac.model.mapping.eclipse.EclipseJittacProject;



/**
 * 
 * @author Jacek Rosik, Sebastian Herold
 *
 */
public class JavaASTProcessorSH extends ASTVisitor {

    private boolean ignoreLibraryReferences = false;
    private boolean ignoreIntraProjectReferences = false;
 
    private ImplementationModelPartition part = null;
    private ImplementationModelFactory<JDTJavaModelElement, IJavaElement,
    	JDTJavaReference, JDTJavaReferenceCodeInformation> factory = null;
    private BuildUnit unit = null;    
    //By setting the following flag to true, the visitors methods for types
    //can be deactivated; they are called but return without executing
    //any further actions.
    //Usage: when visiting a parent node that contains types as children you don't
    //want to visit, set flag to true in the visit() method of the parent node. Reset to 
    // false in the corresponding endvisit() method.
    //This is required if the relationship to the type is processed in the parent node and
    //visiting the type is unnecessary/redundant. See visit(VariableDeclarationFragment).
    private boolean ignoreTypesFlag = false;

    class NodeBinding {
        final ASTNode node;
        final IJavaElement element;
        
        public NodeBinding(ASTNode node, IJavaElement element) {
            this.node = node;
            this.element = element;
        }
    }
    private Stack<NodeBinding> _stack = new Stack<NodeBinding>();

    public JavaASTProcessorSH(IImplementationModel model) {
    	if (model == null)
    		throw new IllegalArgumentException(""ImplementationModel not set."");
        
    	part = model.getPartitionForBuilderType(JDTJavaImplementationModelPartitionType.INSTANCE);
        factory = ImplementationModelFactoryRegistry.instance().getFactory(JDTJavaImplementationModelPartitionType.INSTANCE);
        if (factory == null) {
        	throw new IllegalArgumentException(""Implementation factory for JDT not found."");
        } 
    }

    public boolean isIgnoreLibraryReferences() {
        return ignoreLibraryReferences;
    }

    public void setIgnoreLibraryReferences(boolean value) {
        this.ignoreLibraryReferences = value;
    }


    public boolean isIgnoreIntraProjectReferences() {
        return ignoreIntraProjectReferences;
    }


    public void setIgnoreIntraProjectReferences(boolean value) {
        this.ignoreIntraProjectReferences = value;
    }

    protected IJavaElement currentBinding() {
        return _stack.peek().element;
    }
    
    protected boolean pushNodeAndBinding(ASTNode node, IBinding binding) {
        if (binding == null) {
            _stack.push(new NodeBinding(node, null));
            unhandledBinding(node);
            return false;
        } else
            _stack.push(new NodeBinding(node, binding.getJavaElement()));

        return true;
    }
    
    protected void popNodeAndBinding() {
        _stack.pop();
    }

    public boolean visit(CompilationUnit node) {
        IJavaElement element = node.getJavaElement();
        _stack.push(new NodeBinding(node, element));
        try {
			IResource resource = ((ICompilationUnit) node.getJavaElement()).getCorrespondingResource();
			EclipseJittacResource jResource = EclipseJittacResource.create(resource, 
					(EclipseJittacProject) part.getImplementationModel().getProject());
			unit = part.startUnit(jResource);
		} catch (JavaModelException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
        
        return true;
    }

	public void endVisit(CompilationUnit node) {
        popNodeAndBinding();
		IResource resource = null;
		try {
			resource = ((ICompilationUnit) node.getJavaElement()).getCorrespondingResource();
		} catch (JavaModelException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
        // Finish resource processing and flush all the changes.
        part.endUnit(unit);
    }
    
    public boolean visit(AnonymousClassDeclaration node) {
    	//SH: containment.
    	this.handleXReference(IXReferenceType.CONTAINMENT,
    			currentBinding(),
    			node.resolveBinding().getJavaElement(),
    			node);
        return pushNodeAndBinding(node, node.resolveBinding());
    }
    
    public void endVisit(AnonymousClassDeclaration node) {
        popNodeAndBinding();
    }
    
    public boolean visit(MethodDeclaration node) {
    	//SH: containment.
    	this.handleXReference(IXReferenceType.CONTAINMENT,
    			currentBinding(),
    			node.resolveBinding().getJavaElement(),
    			node);
        return pushNodeAndBinding(node, node.resolveBinding());
    }
    
    public void endVisit(MethodDeclaration node) {
        popNodeAndBinding();
    }
    
    
    public boolean visit(TypeDeclaration node) {
    	//SH: containment.
     	this.handleXReference(IXReferenceType.CONTAINMENT,
    			currentBinding(),
    			node.resolveBinding().getJavaElement(),
    			node);
        return pushNodeAndBinding(node, node.resolveBinding());
    }
    
    public void endVisit(TypeDeclaration node) {
        popNodeAndBinding();
    }
    
    
    public boolean visit(ImportDeclaration node) {
        IBinding binding = node.resolveBinding();
        if (binding == null) {
            unhandledBinding(node);
            return false;
        }
        
        handleXReference(IXReferenceType.IMPORT, currentBinding(),
                         binding.getJavaElement(), node.getName());
        return false;
    }
    
    @SuppressWarnings(""unchecked"")
    public boolean visit(MethodInvocation node) {
        IMethodBinding binding = node.resolveMethodBinding();
        if (binding == null) {
            unhandledBinding(node);
            return false;
        }

        IJavaElement target = binding.getJavaElement();
        if (target == null && binding.getDeclaringClass().isEnum()) {
           // In case of enums some standard methods (like 'values()' will not resolve.
           // Reference the enum itself then..
           target = binding.getDeclaringClass().getJavaElement();
        }
        
        handleXReference(IXReferenceType.CALL, currentBinding(), target, node);
        
        // Process the expression which give the element
        // on which the method is called. 
        if (node.getExpression() != null)
            node.getExpression().accept(this);
        
        // Process type arguments (for templates).
        Iterator<ASTNode> types = node.typeArguments().iterator();
        while (types.hasNext())
            types.next().accept(this);
        
        // And process all the arguments.
        Iterator<ASTNode> args = node.arguments().iterator();
        while (args.hasNext())
            args.next().accept(this);

        return false;
    }
    
    @SuppressWarnings(""unchecked"")
    public boolean visit(SuperMethodInvocation node) {
        IBinding binding = node.resolveMethodBinding();
        if (binding == null) {
            unhandledBinding(node);
            return false;
        }
        
        handleXReference(IXReferenceType.CALL, currentBinding(), binding.getJavaElement(),node);
        
        // Process type arguments (for templates).
        Iterator<ASTNode> types = node.typeArguments().iterator();
        while (types.hasNext())
            types.next().accept(this);
        
        // And process all the arguments.
        Iterator<ASTNode> args = node.arguments().iterator();
        while (args.hasNext())
            args.next().accept(this);

        return false;
    }
    
    @SuppressWarnings(""unchecked"")
    public boolean visit(ClassInstanceCreation node) {
        // TODO: Investigate why resolveConstructorBinding() doesn't work.

        ITypeBinding binding = node.getType().resolveBinding();
        if (binding == null) {
            unhandledBinding(node);
            return false;
        }
            
        handleXReference(IXReferenceType.ACCESS,currentBinding(),
                         binding.getJavaElement(), node);
        
        // Process the expression which give the element
        // on which the method is called.
        if (node.getExpression() != null)
            node.getExpression().accept(this);
        
        // Process type arguments (for templates).
        Iterator<ASTNode> types = node.typeArguments().iterator();
        while (types.hasNext())
            types.next().accept(this);
        
        // And process all the arguments.
        Iterator<ASTNode> args = node.arguments().iterator();
        while (args.hasNext())
            args.next().accept(this);

        return false;
    }
    
    @SuppressWarnings(""unchecked"")
    public boolean visit(SuperConstructorInvocation node) {
        IMethodBinding binding = node.resolveConstructorBinding();
        if (binding == null) {
            unhandledBinding(node);
            return false;
        }
        
        IJavaElement target = binding.getJavaElement();
        if (target == null 
            && binding.isConstructor()
            && node.arguments().size() == 0) {
            // In case of a default constructor reference the Class itself...
            target = binding.getDeclaringClass().getJavaElement();
        }
        handleXReference(IXReferenceType.CALL, currentBinding(), target, node);
        
        // Process the expression which give the element
        // on which the method is called.
        if (node.getExpression() != null)
            node.getExpression().accept(this);
        
        // Process type arguments (for templates).
        Iterator<ASTNode> types = node.typeArguments().iterator();
        while (types.hasNext())
            types.next().accept(this);
        
        // And process all the arguments.
        Iterator<ASTNode> args = node.arguments().iterator();
        while (args.hasNext())
            args.next().accept(this);

        return false;
    }   
    
    public boolean visit(FieldDeclaration node) {
    	//Types will be dealt with while visiting the declaration fragments
    	//Thus, disable the type visits here.
    	ignoreTypesFlag = true;
    	return true;
    }
    
    public void endVisit(FieldDeclaration node) {
    	ignoreTypesFlag = false;
    }
    
    public boolean visit(VariableDeclarationStatement node) {
    	//Types will be dealt with while visiting the declaration fragments
    	ignoreTypesFlag = true;
    	return true;
    }

    public void endVisit(VariableDeclarationStatement node) {
    	ignoreTypesFlag = false;
    }
    
    public boolean visit(VariableDeclarationFragment node) {
    	IVariableBinding binding = node.resolveBinding();
     	
    	if (binding == null) {
    		unhandledBinding(node);
    		return false;
    	}
    	handleXReference(IXReferenceType.CONTAINMENT, currentBinding(), binding.getJavaElement(), node);
		ITypeBinding typeBinding = binding.getType();
        if (typeBinding == null) {
            unhandledBinding(node);
        }
        else {
        	handleXReference(IXReferenceType.TYPEREF, binding.getJavaElement(), typeBinding.getJavaElement(), node);
        }
    	return true;
    }

    public boolean visit(FieldAccess node) {
    	IVariableBinding binding = node.resolveFieldBinding();
    	
    	if (binding == null) {
    		unhandledBinding(node);
    	}
    	else {
    		handleXReference(IXReferenceType.ACCESS, currentBinding(), binding.getJavaElement(), node);
    	}
    	return true;
    }
    
    public boolean visit(Assignment node) {
        // Get the thing we assign to...
        IBinding binding = null;
        boolean handledLeftHand = false;
        Expression expr = node.getLeftHandSide();
        while (expr != null) {
            if (expr instanceof Name) {
                binding = ((Name) expr).resolveBinding();
                break;
            } else if (expr instanceof FieldAccess) {
                FieldAccess fa = (FieldAccess) expr;
                fa.getExpression().accept(this);
                binding = fa.resolveFieldBinding();
                break;
            } else if (expr instanceof SuperFieldAccess) {
                SuperFieldAccess fa = (SuperFieldAccess) expr;
                Name qualifier = fa.getQualifier();
                if (qualifier != null) {
                    qualifier.accept(this);
                }
                binding = fa.resolveFieldBinding();
                break;
            } else if (expr instanceof ArrayAccess) {
                ArrayAccess aa = (ArrayAccess) expr;
                aa.getIndex().accept(this);
                expr = aa.getArray();
                continue;
            } else if (expr instanceof ParenthesizedExpression) {
                expr = ((ParenthesizedExpression) expr).getExpression();
                continue;
            } else if (expr instanceof MethodInvocation
                       || expr instanceof SuperMethodInvocation) {
                expr.accept(this);
                handledLeftHand = true;
                break;
            }

//            warn(""Unable to handle left-hand side of assignment expression: {0}[''{1}'']"",
//                 expr.getClass().getSimpleName(), expr.toString());
            break;
        }
        
        if (!handledLeftHand) {
            if (binding == null) {
                unhandledBinding(node);
            }
            handleXReference(IXReferenceType.ASSIGNMENT, currentBinding(),
                             binding.getJavaElement(), node);
        }
        
        // Process right hand side expression (value).
        node.getRightHandSide().accept(this);
        return false;
    }
    
    public boolean visit(SimpleName node) {
        handleName(node);
        return false;
    }

    public boolean visit(QualifiedName node) {
        handleName(node);
        return false;
    }
    
    public boolean visit(SimpleType node) {
    	
    	return ignoreTypesFlag? true : handleType(node);
    }

    public boolean visit(QualifiedType node) {
    	return ignoreTypesFlag? true : handleType(node);
    }

    //Creates a reference between the currently bound type at the top of the
    //stack and the type given by node
    private boolean handleType(Type node) {
    	ITypeBinding binding = node.resolveBinding();
    	if (binding == null) {
    		unhandledBinding(node);
    		return false;
    	}
    	handleXReference(IXReferenceType.TYPEREF, currentBinding(), binding.getJavaElement(), node);
    	return true;
    }
    
    private boolean handleName(Name node) {
        return handleName(node, IXReferenceType.ACCESS);
    }

    private boolean handleName(Name node, IXReferenceType type) {
        IBinding binding = node.resolveBinding();
        if (binding == null) {
            unhandledBinding(node);
            return false;
        }

        switch (binding.getKind()) {
//        case IBinding.METHOD:
//        case IBinding.TYPE:
        case IBinding.VARIABLE:
            // Ignore local variables and self references.
            IJavaElement dependant = (IJavaElement) currentBinding();
            IJavaElement dependency = binding.getJavaElement();
            if (dependency == null || dependant == null) {
                // This seems to happen mostly for array length parameter.              
                // TODO: Investigate a little more.
                return false;
            }
//            if (dependency.getElementType() == IJavaElement.LOCAL_VARIABLE
//                || dependant.equals(dependency))
//                break;
            if (dependency.getElementType() == IJavaElement.LOCAL_VARIABLE) {
            	break;
            }
            handleXReference(type, dependant, dependency, node);
            break;
            
        case IBinding.PACKAGE:
            // IGNORE THESE
            break;

        default:
            //unhandledNode(node);
        }
        
        return true;
    }

    public void handleXReference(IXReferenceType type, IJavaElement source, IJavaElement target, ASTNode node) {
        if (source == null || target == null) {
            // TODO: Sometimes some binding may fail to resolve into java elements. Fix it!
//            error(""Failed to resolve Java element for {0}[''{1}'']"",
//                  node.getClass().getSimpleName(), node.toString());
            return;
        }
        
        IResource sourceResource = source.getResource();
        
        IResource targetResource = target.getResource();
        
        // Ignore references within ghe same project.
        if (ignoreIntraProjectReferences && targetResource != null
            && sourceResource.getProject().equals(targetResource.getProject())) {
            return;
        } 
        
        // Ignore all references to the types contained in libraries (jar or zip files)
        if (ignoreLibraryReferences) {
            try {
                IPackageFragmentRoot root = (IPackageFragmentRoot) target.getAncestor(PACKAGE_FRAGMENT_ROOT);
                if (root == null || root.getKind() == K_BINARY) {
                    return;
                }
            } catch (JavaModelException ex) {
//                error(ex, ""Unexpected exception in AST Parser"");
            }
        }
        
        JDTJavaReference ref = factory.createReference(
        		factory.createElement(source, part),
                factory.createElement(target, part),
                type,
                new JDTJavaReferenceCodeInformation(node));
        part.addReference(ref);
    }   
    
    private void unhandledBinding(ASTNode node) {
//        warn(""Unhandled Binding ({0}): {1}"", node.getClass().getSimpleName(), node.toString());
    }

    private void unhandledNode(ASTNode node){
//        warn(""Unhandled Node: {0}"",  node.toString());
    }
}

"
JavaImplementationModelBuilder.java,jdt-build,"package se.kau.cs.jittac.eclipse.builders.jdt;

import static com.google.common.collect.Lists.newArrayList;
import static com.google.common.collect.Lists.newLinkedList;
import static java.lang.Math.min;
import static java.lang.System.arraycopy;
import static java.util.Arrays.asList;
import static java.util.Collections.emptyList;
import static java.util.Collections.singleton;
import static java.util.regex.Pattern.compile;

import static org.eclipse.core.resources.IResource.FILE;
import static org.eclipse.core.resources.IResource.FOLDER;
import static org.eclipse.core.resources.IResource.PROJECT;
import static org.eclipse.core.resources.IResourceDelta.ADDED;
import static org.eclipse.core.resources.IResourceDelta.CHANGED;
import static org.eclipse.core.resources.IResourceDelta.REMOVED;
import static org.eclipse.jdt.core.IPackageFragmentRoot.K_SOURCE;

import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.regex.Pattern;

import se.kau.cs.jittac.model.im.BuildUnit;
import se.kau.cs.jittac.model.im.IImplementationModel;
import se.kau.cs.jittac.model.im.ImplementationModelPartition;
import se.kau.cs.jittac.model.im.ImplementationModelPartitionType;
import se.kau.cs.jittac.model.mapping.IJittacProject;
import se.kau.cs.jittac.model.mapping.eclipse.EclipseJittacProject;
import se.kau.cs.jittac.model.mapping.eclipse.EclipseJittacResource;
import org.eclipse.core.resources.IProject;
import org.eclipse.core.resources.IResource;
import org.eclipse.core.resources.IResourceDelta;
import org.eclipse.core.resources.IResourceDeltaVisitor;
import org.eclipse.core.resources.IncrementalProjectBuilder;
import org.eclipse.core.runtime.CoreException;
import org.eclipse.core.runtime.IProgressMonitor;
import org.eclipse.core.runtime.OperationCanceledException;
import org.eclipse.core.runtime.SubProgressMonitor;
import org.eclipse.jdt.core.ICompilationUnit;
import org.eclipse.jdt.core.IJavaElement;
import org.eclipse.jdt.core.IJavaProject;
import org.eclipse.jdt.core.IPackageFragment;
import org.eclipse.jdt.core.IPackageFragmentRoot;
import org.eclipse.jdt.core.JavaCore;
import org.eclipse.jdt.core.JavaModelException;
import org.eclipse.jdt.core.dom.AST;
import org.eclipse.jdt.core.dom.ASTParser;

/**
 * 
 * @author Jacek Rosik, Sebastian Herold
 *
 */
@SuppressWarnings(""deprecation"")
public class JavaImplementationModelBuilder extends IncrementalProjectBuilder {

	public static final Integer DEFAULT_MAX_BATCH_SIZE = 256;

	/** Unique ID of this builder. */
	public static final String ID = ""se.kau.cs.jittac.eclipse.builders.jdt"";
	public static final ImplementationModelPartitionType TYPE = 
			JDTJavaImplementationModelPartitionType.INSTANCE;

	private int maxBatchSize = DEFAULT_MAX_BATCH_SIZE;
	private boolean compactPackagesOnFullBuild = false;

	private Pattern ignoreResources[] = new Pattern[] { compile(""^src/test/""), compile(""Test\\.java$"") };

	protected void checkCancelled(IProgressMonitor monitor) {
		if (monitor.isCanceled()) {
			throw new OperationCanceledException();
		}
	}

	protected Collection<ICompilationUnit[]> batchCompilationUnits(ICompilationUnit[] units) {
		if (units.length > maxBatchSize) {
			Collection<ICompilationUnit[]> batches = newLinkedList();

			for (int processed = 0; processed < units.length; processed += maxBatchSize) {
				ICompilationUnit[] batch = new ICompilationUnit[min(units.length - processed, maxBatchSize)];
				arraycopy(units, processed, batch, 0, batch.length);
				batches.add(batch);
			}

			return batches;
		} else if (units.length > 0) {
			return singleton(units);
		} else {
			return emptyList();
		}
	}

	protected boolean ignoreResource(IResource resource) {
		String path = resource.getProjectRelativePath().toPortableString();
		for (Pattern pattern : ignoreResources) {
			if (pattern.matcher(path).find()) {
				return true;
			}
		}

		return false;
	}

	protected ICompilationUnit[] filterCompilationUnits(ICompilationUnit[] units) {
		ArrayList<ICompilationUnit> filtered = new ArrayList<ICompilationUnit>(units.length);

		for (ICompilationUnit unit : units) {
			if (!ignoreResource(unit.getResource())) {
				filtered.add(unit);
			}
		}

		return filtered.toArray(new ICompilationUnit[filtered.size()]);
	}

	protected Collection<ICompilationUnit[]> collectCompilationUnits(IJavaProject project, IProgressMonitor monitor)
			throws JavaModelException {
		monitor.beginTask("""", project.getAllPackageFragmentRoots().length);

		try {
			List<ICompilationUnit[]> packageBatches = newLinkedList();

			// Collect compilation units from all fragments (packages).
			for (IPackageFragmentRoot root : project.getAllPackageFragmentRoots()) {
				monitor.subTask(""[JITTAC] Scanning for Java sources in '"" + project.getElementName() + ""' project: ""
						+ root.getPath().toPortableString());

				// Only collect compilation units from actual source (java)
				// files.
				if (root.getKind() != K_SOURCE) {
					continue;
				}

				// Make sure that we do not include compilation units from other
				// projects
				// as these were already processed when those projects were
				// processed.
				if (!root.getJavaProject().equals(project)) {
					continue;
				}

				// Ignore resources which match given patterns.
				if (ignoreResource(root.getResource())) {
					continue;
				}

				for (IJavaElement element : root.getChildren()) {
					if (!(element instanceof IPackageFragment)) {
//						warn(""Ignoring element (not a package fragment) ''{2}''""
//								+ "" while analysing sources in ''{1}'' of project ''{0}''."", project.getElementName(),
//								root.getElementName(), element.getElementName());
						continue;
					}

					ICompilationUnit[] units = ((IPackageFragment) element).getCompilationUnits();
					units = filterCompilationUnits(units);
					if (units.length > 0) {
						packageBatches.addAll(batchCompilationUnits(units));
					}
				}

				monitor.worked(1);
				checkCancelled(monitor);
			}

			// Amalgamate units from all packages into a single array.
			if (compactPackagesOnFullBuild) {
				List<ICompilationUnit[]> batches = newLinkedList();
				List<ICompilationUnit> batch = newArrayList();

				for (ICompilationUnit[] packageBatch : packageBatches) {
					// Process the units of this package,
					// batch them in case package is larger than maxBatchSize
					for (ICompilationUnit[] units : batchCompilationUnits(packageBatch)) {
						if (batch.size() + units.length > maxBatchSize) {
							batches.add(batch.toArray(new ICompilationUnit[batch.size()]));
							batch.clear();
						}
						batch.addAll(asList(units));
					}
				}

				// Add the last batch to the list...
				if (!batch.isEmpty()) {
					batches.add(batch.toArray(new ICompilationUnit[batch.size()]));
				}

				return batches;
			}

			return packageBatches;
		} finally {
			monitor.done();
		}
	}

	public static void main(String[] args) {
		JavaImplementationModelBuilder builder = new JavaImplementationModelBuilder();

		System.out.println(builder.ignoreResources[0].matcher(""src/test/sdf"").find());
	}

	protected Collection<ICompilationUnit[]> collectCompilationUnits(IResourceDelta delta,
			final IProgressMonitor monitor) throws CoreException {
		final ArrayList<ICompilationUnit> units = newArrayList();
		if (!isSupportedProject()) 
			throw new IllegalStateException(""Builder not applicable for project "" + getProject().getName());
		final IJavaProject project = JavaCore.create(getProject());
		
		final IImplementationModel model =
				EclipseJittacProject.get(getProject()).getImplementationModel();

		monitor.beginTask("""", 1);
		try {
			checkCancelled(monitor);
			monitor.subTask(
					""[JITTAC] Scanning for modified Java sources in '"" + project.getElementName() + ""' project"");
			delta.accept(new IResourceDeltaVisitor() {
				@Override
				public boolean visit(IResourceDelta delta) throws CoreException {
					checkCancelled(monitor);

					IResource resource = delta.getResource();
					int resourceType = resource.getType();
					if (resourceType == FOLDER || resourceType == PROJECT) {
						return true;
					} else if (resourceType != FILE) {
						return false;
					}

					IJavaElement element = JavaCore.create(resource);
					if (element instanceof ICompilationUnit) {
						// Check that this java file is contained in a package
						// fragment,
						// this will only happen if it is on the build path.
						// Ignore otherwise...
						IJavaElement parent = JavaCore.create(resource.getParent());
						if (!(parent instanceof IPackageFragment || parent instanceof IPackageFragmentRoot)) {
							return false;
						}

						switch (delta.getKind()) {
						case ADDED:
						case CHANGED:
							units.add((ICompilationUnit) element);
							return false;

						case REMOVED:
							// This will remove all the x-references
							// from the given compilation unit.
							EclipseJittacResource res = EclipseJittacResource.create(
									((ICompilationUnit) element).getCorrespondingResource(),
									EclipseJittacProject.get(getProject()));
							BuildUnit unit = model.getPartitionForBuilderType(TYPE).startUnit(res);
							model.getPartitionForBuilderType(TYPE).endUnit(unit);
						}
					}

					return false;
				}
			});
			monitor.worked(1);
		} finally {
			monitor.done();
		}

		return batchCompilationUnits(units.toArray(new ICompilationUnit[units.size()]));
	}

	@Override
	protected IProject[] build(int kind, Map<String, String> args, IProgressMonitor monitor) throws CoreException {
		if (!isSupportedProject()) 
			throw new IllegalStateException(""Builder not applicable for project "" + getProject().getName());
		final IJavaProject project = JavaCore.create(getProject());
		final String projectName = project.getElementName();

		monitor.beginTask("""", 100 + 2000 + 50);
		try {
			final Collection<ICompilationUnit[]> batches;
			IProgressMonitor collectionMonitor = new SubProgressMonitor(monitor, 100);

			// Collect all the compilation units that should be analysed.
			if (kind == INCREMENTAL_BUILD || kind == AUTO_BUILD) {
				batches = collectCompilationUnits(getDelta(getProject()), collectionMonitor);
			} else if (kind == FULL_BUILD) {
				batches = collectCompilationUnits(project, collectionMonitor);
			} else {
//				error(""Invalid build kind ({0}) when invoking ''{2}'' on project ''{1}''; exiting..."", kind,
//						project.getElementName(), this.getCommand().getBuilderName());
				return null;
			}
			checkCancelled(monitor);

			// Create and configure the AST parser.
			final IProgressMonitor processingMonitor = new SubProgressMonitor(monitor, 2000);

			// Get total number of units to be processed.
			int totalUnits = 0;
			for (ICompilationUnit[] units : batches) {
				totalUnits += units.length;
			}

//			for (ArchitectureModel am : modelManager().getControllingModels(getProject())) {
//				am.getModelLogger().logBuildBegin(getProject());
//			}
			
			IJittacProject jProject = EclipseJittacProject.get(getProject());
			ImplementationModelPartition part =
				jProject.getImplementationModel().getPartitionForBuilderType(
					JDTJavaImplementationModelPartitionType.INSTANCE);
			part.startBuild();

			processingMonitor.beginTask("""", totalUnits);
			processingMonitor.subTask(""[JITTAC] Initialising Java IA extraction for '"" + projectName + ""' project..."");
			try {
				ASTParser parser = ASTParser.newParser(AST.JLS8);
				parser.setIgnoreMethodBodies(false);

				IProgressMonitor dummy = new se.kau.cs.jittac.eclipse.util.DummyProgressMonitor(processingMonitor);
				JavaASTHandler handler;
				IImplementationModel im = 
						EclipseJittacProject.get(project.getProject()).getImplementationModel();
				handler = new JavaASTHandler(im, totalUnits, processingMonitor);

				// Do the actual AST processing...
				for (ICompilationUnit[] units : batches) {
					checkCancelled(monitor);
					parser.setProject(project);
					parser.setResolveBindings(true);
					parser.createASTs(units, new String[0], handler, dummy);
				}
			} finally {
				part.endBuild();
				processingMonitor.done();
			}

//			for (ArchitectureModel am : modelManager().getControllingModels(getProject())) {
//				am.getModelLogger().logBuildEnd(getProject());
//			}

			monitor.subTask(""[JITTAC] Storing IA model of project '"" + project.getElementName() + ""'"");
//			modelManager()._storeImplementationModel(getProject());
			monitor.worked(50);

			// TODO: Move into a separate process/task.
//			ProjectTracker tracker = ACToolJDT.getDefault().getTracker(getProject());
//			if (tracker != null) {
//				tracker.scanForUnmappedResources();
//			}
		} finally {
			monitor.done();
		}

		return null;
	}

	public boolean isSupportedProject() {
		boolean isSupported = false;
		try {
			isSupported = getProject().isOpen() && getProject().hasNature(JavaCore.NATURE_ID);
		} catch (CoreException e) {
		}
		return isSupported;
	}
}
"
JDTImplementationModelFactory.java,jdt-build,"package se.kau.cs.jittac.eclipse.builders.jdt;

import org.eclipse.jdt.core.IJavaElement;
import org.eclipse.jdt.core.JavaCore;

import se.kau.cs.jittac.model.im.IImplementationModelElement;
import se.kau.cs.jittac.model.im.IXReference;
import se.kau.cs.jittac.model.im.IXReferenceType;
import se.kau.cs.jittac.model.im.ImplementationModelFactory;
import se.kau.cs.jittac.model.im.ImplementationModelFactoryRegistry;
import se.kau.cs.jittac.model.im.ImplementationModelPartition;
import se.kau.cs.jittac.model.im.ImplementationModelPartitionType;

public class JDTImplementationModelFactory 
	implements ImplementationModelFactory
	<JDTJavaModelElement, IJavaElement, JDTJavaReference,JDTJavaReferenceCodeInformation> {

	public static final JDTImplementationModelFactory INSTANCE = new JDTImplementationModelFactory();
	private static final String SEPARATOR = ""\t"";
	private static final String SRC_START = ""\""<SOURCE>\"""";
	private static final String TRG_START = ""\""<TARGET>\"""";
	private static final String REF_START = ""\""<REF>\"""";
	private static final String INT_HEADER = ""\""<INTERNAL>\"""";
	private static final String EXT_HEADER = ""\""<EXTERNAL>\"""";
	
	private JDTImplementationModelFactory() {
	}

	
	public JDTJavaModelElement createElement(IJavaElement element, ImplementationModelPartition partition) {
		return new JDTJavaModelElement(element, partition);
	}
	
	@Override
	public JDTJavaReference createReference(JDTJavaModelElement src, JDTJavaModelElement trg, IXReferenceType type,
			JDTJavaReferenceCodeInformation internalRef) {
		
		return new JDTJavaReference(src, trg, type, internalRef);
	}

	@Override
	public IXReference<JDTJavaModelElement, JDTJavaReferenceCodeInformation> createExternalReference(
			JDTJavaModelElement src, IImplementationModelElement<?> trg, IXReferenceType type,
			JDTJavaReferenceCodeInformation internalRef) {
		throw new UnsupportedOperationException(""Creation of external references not yet supported."");
	}

	@Override
	public ImplementationModelPartitionType getPartitionType() {
		return JDTJavaImplementationModelPartitionType.INSTANCE;
	}

	@Override
	public String serializeInternalReference(IXReference<?,?> reference) {
		Class<?> c = this.getPartitionType().getReferenceType();
		if (!reference.getClass().equals(c)) {
			throw new IllegalArgumentException(""Can't serilialize reference "" + reference);
		};
		JDTJavaReference jRef = (JDTJavaReference) reference;
		StringBuilder sb = new StringBuilder();
		sb.append(INT_HEADER);
		sb.append(SRC_START);
		sb.append(this.serializeLocalElement(jRef.getSource()));
		sb.append(TRG_START);
		sb.append(this.serializeLocalElement(jRef.getTarget()));
		sb.append(REF_START);
		sb.append(jRef.getType().name());
		sb.append(SEPARATOR);
		sb.append(jRef.getInternalReference().offset);
		sb.append(SEPARATOR);
		sb.append(jRef.getInternalReference().length);
		sb.append(SEPARATOR);
		sb.append(jRef.getInternalReference().line);
		return sb.toString();
	}

	@Override
	public String serializeExternalReference(IXReference<?,?> reference) {
		throw new UnsupportedOperationException(""Creation of external references not yet supported."");
	}

	@Override
	public String serializeLocalElement(JDTJavaModelElement element) {
		StringBuilder sb = new StringBuilder();
		sb.append(element.getResource().getResourceModelName());
		sb.append(SEPARATOR);
		sb.append(element.getResource().getPersistentHandle());
		sb.append(SEPARATOR);
		sb.append(element.getElement().getHandleIdentifier());
		return sb.toString();
	}

	@Override
	public JDTJavaModelElement deserializeLocalElement(String elementAsString, ImplementationModelPartition partition) {
		String[] temp = elementAsString.split(SEPARATOR);
		if (temp.length != 3) {
			throw new IllegalArgumentException(""Malformed element string."");
		}
		IJavaElement elem = JavaCore.create(temp[2]);
		if (elem == null) {
			throw new IllegalArgumentException(""Malformed element string: cannot find Java element."");
		}
		return this.createElement(elem, partition);
	}

	@Override
	public JDTJavaReference deserializeInternalReference(String referenceAsString,
			ImplementationModelPartition partition) {
		String sourceStr, targetStr, referenceStr;
		String[] temp = referenceAsString.split(INT_HEADER, 2);
		if (temp.length != 2) {
			throw new IllegalArgumentException(""String does not represent an internal reference."");
		}
		temp = temp[1].split(SRC_START, 2);
		if (temp.length != 2) {
			throw new IllegalArgumentException(""Malformed reference string: cannot identify source element."");
		}
		temp = temp[1].split(TRG_START, 2);
		if (temp.length != 2) {
			throw new IllegalArgumentException(""Malformed reference string: cannot identify target element."");
		}
		sourceStr = temp[0];
		temp = temp[1].split(REF_START, 2);
		if (temp.length != 2) {
			throw new IllegalArgumentException(""Malformed reference string: cannot identify reference section."");
		}
		targetStr = temp[0];
		referenceStr = temp[1];
		
		JDTJavaModelElement src = deserializeLocalElement(sourceStr, partition);
		JDTJavaModelElement trg = deserializeLocalElement(targetStr, partition);
		
		temp = referenceStr.split(SEPARATOR);
		if (temp.length != 4) {
			throw new IllegalArgumentException(""Malformed reference string: reference section malformed"");
		}
		
		try {
			IXReferenceType type = IXReferenceType.valueOf(temp[0]);
			JDTJavaReferenceCodeInformation codeInfo =
					new JDTJavaReferenceCodeInformation(Integer.parseInt(temp[1]),
							Integer.parseInt(temp[2]), Integer.parseInt(temp[3]));
			return this.createReference(src, trg, type, codeInfo);
		} catch (NumberFormatException e) {
			throw new IllegalArgumentException(""Malformed reference string: reference section malformed"");
		}
	}

	@Override
	public IXReference<JDTJavaModelElement, ?> deserializeExternalReference(String referenceAsString,
			ImplementationModelPartition partition) {
		throw new UnsupportedOperationException(""Creation of external references not yet supported."");
	}
}


"
JDTJavaImplementationModelPartitionType.java,jdt-build,"package se.kau.cs.jittac.eclipse.builders.jdt;

import se.kau.cs.jittac.model.im.ImplementationModelPartitionType;

public class JDTJavaImplementationModelPartitionType 
implements ImplementationModelPartitionType {

	private static final String NAME = ""JDT"";
	public static final JDTJavaImplementationModelPartitionType INSTANCE =
			new JDTJavaImplementationModelPartitionType();
	
	private JDTJavaImplementationModelPartitionType() {
	}

	@Override
	public Class<JDTJavaModelElement> getElementType() {
		return JDTJavaModelElement.class;
	}

	@Override
	public Class<JDTJavaReference> getReferenceType() {
		return JDTJavaReference.class;
	}

	@Override
	public String getName() {
		return NAME;
	}
}
"
JDTJavaModelElement.java,jdt-build,"package se.kau.cs.jittac.eclipse.builders.jdt;

import org.eclipse.jdt.core.IField;
import org.eclipse.jdt.core.IImportDeclaration;
import org.eclipse.jdt.core.IJavaElement;
import org.eclipse.jdt.core.IMember;
import org.eclipse.jdt.core.IMethod;
import org.eclipse.jdt.core.IType;
import org.eclipse.jdt.core.JavaCore;
import org.eclipse.jdt.core.JavaModelException;
import org.eclipse.jdt.core.Signature;

import se.kau.cs.jittac.model.im.IImplementationModel;
import se.kau.cs.jittac.model.im.IImplementationModelElement;
import se.kau.cs.jittac.model.im.IXReference;
import se.kau.cs.jittac.model.im.ImplementationModelPartition;
import se.kau.cs.jittac.model.mapping.IJittacProject;
import se.kau.cs.jittac.model.mapping.IJittacResource;
import se.kau.cs.jittac.model.mapping.IJittacResourceFactory;
import se.kau.cs.jittac.model.mapping.eclipse.EclipseJittacProject;
import se.kau.cs.jittac.model.mapping.eclipse.EclipseJittacResource;
import se.kau.cs.jittac.model.mapping.eclipse.EclipseJittacResourceFactory;

public class JDTJavaModelElement implements IImplementationModelElement<IJavaElement> {

	private ImplementationModelPartition part;
	private IJavaElement elem;
	private EclipseJittacResource resource;
	private String name;
	
	
	public JDTJavaModelElement(IJavaElement elem,
			ImplementationModelPartition part) {
		this.elem = elem;
		this.part = part;
		resource = EclipseJittacResource.create(elem.getResource(),
				(EclipseJittacProject) part.getImplementationModel().getProject());
	}
	
	public JDTJavaModelElement(IJavaElement elem) {
		
	}
	
	@Override
	public IJittacResource getResource() {
		return resource;
	}

	public IJavaElement getJavaElement() {
		return elem;
	}

	public String toString() {
		try {
			return toPrettyString(elem);
		} catch (JavaModelException e) {
			return elem.getElementName();
		}
		
	}
	
	private static String toPrettyString(IJavaElement element) throws JavaModelException {
		if (element instanceof IType) {
			return ((IType) element).getFullyQualifiedName();
		}
		if (element instanceof IMethod) {
			IMethod method = (IMethod) element;
			return Signature.toString(method.getSignature(),
					method.getElementName(),
					null, false, false);
		}
		if (element instanceof IField) {
			IJavaElement parent = ((IMember) element).getParent();
			IField field = (IField) element;
			return Signature.toString(field.getTypeSignature()) +
					"" "" + field.getElementName();
					
		}
		if (element instanceof IImportDeclaration ) {
			return ((IImportDeclaration) element).getElementName();
		}
		return element.getElementName();
	}
	
	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + ((elem == null) ? 0 : elem.hashCode());
		return result;
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		JDTJavaModelElement other = (JDTJavaModelElement) obj;
		if (elem == null) {
			if (other.elem != null)
				return false;
		} else if (!elem.equals(other.elem))
			return false;
		return true;
	}

	@Override
	public IJavaElement getElement() {
		return elem;
	}

	@Override
	public ImplementationModelPartition getPartition() {
		return part;
	}





}
"
JDTJavaReference.java,jdt-build,"package se.kau.cs.jittac.eclipse.builders.jdt;

import org.eclipse.jdt.core.IJavaElement;
import org.eclipse.jdt.core.dom.ASTNode;

import se.kau.cs.jittac.model.im.IImplementationModelElement;
import se.kau.cs.jittac.model.im.IXReference;
import se.kau.cs.jittac.model.im.IXReferenceType;
import se.kau.cs.jittac.model.im.ImplementationModelPartition;
import se.kau.cs.jittac.model.mapping.IJittacResource;

public class JDTJavaReference implements IXReference<JDTJavaModelElement, JDTJavaReferenceCodeInformation> {

	private JDTJavaModelElement src, trg;
	private IXReferenceType type;
	private JDTJavaReferenceCodeInformation codeInfo;
	private ImplementationModelPartition part;
	
	
	public JDTJavaReference(JDTJavaModelElement src, 
			JDTJavaModelElement trg, IXReferenceType type, JDTJavaReferenceCodeInformation codeInfo) {
		this.src = src;
		this.trg = trg;
		this.type = type;
		this.codeInfo = codeInfo;
		this.part = src.getPartition();
	}

	public JDTJavaReference(IJavaElement src, 
			IJavaElement trg, IXReferenceType type, JDTJavaReferenceCodeInformation codeInfo,
			ImplementationModelPartition part) {
		this(new JDTJavaModelElement(src, part),
			 new JDTJavaModelElement(trg, part), type, codeInfo);
	}
	
	public JDTJavaReference(IJavaElement src, 
			IJavaElement trg, IXReferenceType type, ASTNode node,
			ImplementationModelPartition part) {
		
		this(src, trg, type, new JDTJavaReferenceCodeInformation(node), part);
	}
	
	@Override
	public ImplementationModelPartition getPartition() {
		return part;
	}
	
	@Override
	public IXReferenceType getType() {
		return type;
	}

	@Override
	public JDTJavaModelElement getSource() {
		return src;
	}

	@Override
	public JDTJavaModelElement getTarget() {
		return trg;
	}

	@Override
	public IJittacResource getResource() {
		return src.getResource();
	}

	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;

		result = prime * result + ((codeInfo == null) ? 0 : codeInfo.offset);
		result = prime * result + ((src == null) ? 0 : src.hashCode());
		result = prime * result + ((trg == null) ? 0 : trg.hashCode());
		result = prime * result + ((type == null) ? 0 : type.hashCode());
		return result;
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		JDTJavaReference other = (JDTJavaReference) obj;
		if (codeInfo == null) {
			if (other.codeInfo != null)
				return false;
		} else if (codeInfo.offset !=
				other.codeInfo.offset)
			return false;
		if (src == null) {
			if (other.src != null)
				return false;
		} else if (!src.equals(other.src))
			return false;
		if (trg == null) {
			if (other.trg != null)
				return false;
		} else if (!trg.equals(other.trg))
			return false;
		if (type != other.type)
			return false;
		return true;
	}

	public String toString() {
		return src.getJavaElement().getElementName() + "" -> "" + 
				trg.getJavaElement().getElementName() + ""; "" + 
				type + ""; "" ;
	}

	@Override
	public  JDTJavaReferenceCodeInformation getInternalReference() {
		return codeInfo;
	}


}
"
JDTJavaReferenceCodeInformation.java,jdt-build,"package se.kau.cs.jittac.eclipse.builders.jdt;

import org.eclipse.jdt.core.dom.ASTNode;
import org.eclipse.jdt.core.dom.CompilationUnit;

public class JDTJavaReferenceCodeInformation {

	public final int offset;
	public final int length;
	public final int line;
	
	public JDTJavaReferenceCodeInformation(ASTNode node) {
		offset = node.getStartPosition();
		length = node.getLength();
		line = ((CompilationUnit) node.getRoot()).getLineNumber(node.getStartPosition());
	}
	
	public JDTJavaReferenceCodeInformation(int offset, int length, int line) {
		this.offset = offset;
		this.length = length;
		this.line = line;
	}
}
"
Projects.java,jdt-build,"package se.kau.cs.jittac.eclipse.builders.jdt.util;

import static com.google.common.collect.Collections2.filter;
//import static net.sourceforge.actool.jdt.ACToolJDT.errorStatus;

import java.util.Collection;

import org.eclipse.core.resources.IProject;
import org.eclipse.core.runtime.CoreException;
import org.eclipse.core.runtime.IAdaptable;
import org.eclipse.jdt.core.JavaCore;

import com.google.common.base.Function;
import com.google.common.base.Predicate;
import com.google.common.collect.Collections2;

public abstract class Projects {

    public static Predicate<Object> isProjectWithNature(final String nature) {
        return new Predicate<Object>() {

            @Override
            public boolean apply(Object obj) {
                if (obj instanceof IAdaptable) {
                    IProject project = (IProject) ((IAdaptable) obj).getAdapter(IProject.class);
                    try {
                        return project.isOpen() && project.hasNature(nature);
                    } catch (CoreException e) {
//                        errorStatus(""Error checking natures of Project: "" + project.getName(), e);
                    }
                }

                return false;
            }
        };
    }

    /**
     * Extracts instances of {@link IProject} instances with the given nature.
     * 
     * All object which do not have the right nature or are not instances of
     * {@link IProject} are silently ignored.
     * 
     * @param collection
     *            or object to be processed
     * @param nature
     *            string representing the ID of the required nature
     * @return collection of projects with the given nature, never {@code null}
     */
    public static Collection<IProject> extractProjectsWithNature(
            Collection<?> collection, String nature) {

        return Collections2.transform(
                filter(collection, isProjectWithNature(nature)),
                new Function<Object, IProject>() {
                    @Override
                    public IProject apply(Object obj) {
                        return (IProject) ((IAdaptable) obj).getAdapter(IProject.class);
                    }
                });
    }

    /**
     * Extracts instances of {@link IProject} instances with the Java nature.
     * 
     * All object which do not have the Java nature or are not instances of
     * {@link IProject} are silently ignored.
     * 
     * @param collection
     *            or object to be processed
     * @return collection of projects with java nature, never {@code null}
     */
    public static Collection<IProject> extractProjectsWithJavaNature(
            Collection<?> collection) {
        return extractProjectsWithNature(collection, JavaCore.NATURE_ID);
    }
}
"
PlainTextViolationReporter.java,report,"package se.kau.cs.jittac.model.report;

import java.io.IOException;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.Writer;
import java.util.Arrays;
import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.apache.commons.collections4.CollectionUtils;
import se.kau.cs.jittac.model.am.ArchitectureModel;
import se.kau.cs.jittac.model.am.Component;
import se.kau.cs.jittac.model.am.Connector;
import se.kau.cs.jittac.model.im.IXReference;
import se.kau.cs.jittac.model.im.IXReferenceType;

public class PlainTextViolationReporter {

	public static void write(OutputStream stream, ArchitectureModel model){
        
		try {
			OutputStreamWriter writer = new OutputStreamWriter(stream);

			writeArchitectureOverview(writer, model);
			
			//writeMapping(writer, model)
			
			for (Component c : ReporterUtils.getComponentsSortedByName(model)) {
				writeViolationReport(writer, c, new IXReferenceType[] {IXReferenceType.ACCESS, IXReferenceType.CALL});
			}

			
			writer.flush();
			writer.close();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
    }
	
	private static void writeArchitectureOverview(Writer writer, ArchitectureModel model) {
		
		try {
			writer.write(""Architecture Overview\n"");
			List<Component> comps = ReporterUtils.getComponentsSortedByName(model);
			for (Component c : comps) {
				StringBuffer sb = new StringBuffer();
				Collection<Connector> envisagedCons = CollectionUtils.select(c.getOutgoingConnectors(), con -> con.isEnvisaged() && !con.isReflexive());
				Collection<Component> targetedComps = CollectionUtils.collect(envisagedCons, Connector::getTrg);
				sb.append(""\t"" + c.getName() + (envisagedCons.size() > 0 ? "" -> "" : "" ""));
				targetedComps.forEach(comp -> sb.append(comp.getName() + "",""));
				sb.deleteCharAt(sb.length() - 1);
				sb.append(""\n"");
				writer.write(sb.toString());
			}
			writer.write(""\n"");
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

	private static void writeViolationReport(Writer writer, Component c, IXReferenceType[] types) throws IOException {
		Collection<Connector> divergences = CollectionUtils.select(c.getOutgoingConnectors(), con -> !con.isEnvisaged());
		Map<String, Set<IXReference<?,?>>> violationsPerResource;
		violationsPerResource = ReporterUtils.sortViolationsByResource(divergences);
					
		writer.write(""Component "" + c.getName() + ""\n"");
		for (String s : violationsPerResource.keySet()) {
			Collection<IXReference<?,?>> filteredViolations = 
					CollectionUtils.select(violationsPerResource.get(s), ref -> Arrays.asList(types).contains(ref.getType()));
			if (filteredViolations.size() > 0) {
				writer.write(""\tFollowing violations starting in "" + s + "":\n"");

				for (IXReference<?,?> ref : ReporterUtils.sortReferencesBySource(filteredViolations)) {
					StringBuffer sb = new StringBuffer();
					sb.append(""\t\t"");
					sb.append(ref.getSource().toString());
					sb.append("" --"" + ref.getType() + ""-> "" );
					sb.append(ref.getTarget().toString());
					sb.append(""("" + ref.getTarget().getResource().toString() + "", component "");
					sb.append(c.getModel().getMapping().getComponent(ref.getTarget().getResource()).getName());
					sb.append("")\n"");
					
					writer.write(sb.toString());
				}
				writer.write(""\n"");
			}
		}
	}
}
"
ReporterUtils.java,report,"package se.kau.cs.jittac.model.report;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.apache.commons.collections4.map.HashedMap;

import se.kau.cs.jittac.model.am.ArchitectureModel;
import se.kau.cs.jittac.model.am.Component;
import se.kau.cs.jittac.model.am.Connector;
import se.kau.cs.jittac.model.im.IXReference;

public class ReporterUtils {

	public static List<IXReference<?,?>> sortReferencesBySource(Collection<IXReference<?,?>> refs) {
		List<IXReference<?,?>> sortedRefs = new ArrayList<>(refs);
		Comparator<IXReference<?,?>> c = (IXReference<?,?> r1, IXReference<?,?> r2) -> r1.getSource().toString().compareTo(r2.getSource().toString());
		Collections.sort(sortedRefs, c);
		return sortedRefs;
	}
	
	
	public static Map<String, Set<IXReference<?,?>>> sortViolationsByResource(Collection<Connector> divergences) {
		Map<String, Set<IXReference<?,?>>> violationsPerResource = new HashedMap<>();
		for (Connector d : divergences) {
			for (IXReference<?,?> violation : d.getContributingReferences()) {
				String srcResName = violation.getSource().getResource().toString(); 
				if (violationsPerResource.containsKey(srcResName)) {
					violationsPerResource.get(srcResName).add(violation);
				}
				else {
					Set<IXReference<?,?>> newRefSet = new HashSet<>();
					newRefSet.add(violation);
					violationsPerResource.put(srcResName, newRefSet);
				}
			}
		}
		return violationsPerResource;
	}
	
	public static List<Component> getComponentsSortedByName(ArchitectureModel model) {
		List<Component> comps = model.getComponentsAsList();
		Collections.sort(comps, Comparator.comparing(Component::getName));
		return comps;
	}
}
"
AbstractJittacProject.java,resource-mapping,"package se.kau.cs.jittac.model.mapping;

/**
 * An incomplete default implementation for project resources in Jittac.
 * @author Sebastian Herold
 *
 */
public abstract class AbstractJittacProject extends AbstractMappableElement implements IJittacProject {

	
	@Override
	public IJittacProject getProject() {
		return this;
	}

	@Override
	public IJittacResource getParent() {
		return null;
	}

	@Override
	public boolean isDescendantOf(IMappableElement elem) {
		return false;
	}
	
}
"
AbstractJittacResource.java,resource-mapping,"package se.kau.cs.jittac.model.mapping;

public abstract class AbstractJittacResource extends AbstractMappableElement implements IJittacResource  {

	
}
"
AbstractMappableElement.java,resource-mapping,"package se.kau.cs.jittac.model.mapping;

public abstract class AbstractMappableElement implements IMappableElement {

	@Override
	public boolean isDescendantOf(IMappableElement elem) {
		
		if (elem == null) return false;
		IMappableElement parent = this.getParent();
		if (parent != null) {
			if (parent.equals(elem)) {
				 return true;
			}
			else {
				return parent.isDescendantOf(elem);
			}
		}
		return false;
	}

}
"
ArchitectureMapping.java,resource-mapping,"package se.kau.cs.jittac.model.mapping;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.apache.commons.collections4.map.HashedMap;

import se.kau.cs.jittac.model.am.ArchitectureModel;
import se.kau.cs.jittac.model.am.Component;
import se.kau.cs.jittac.model.am.events.AbstractArchitectureModelChangeListener;
import se.kau.cs.jittac.model.am.events.ComponentRemovalEvent;
import se.kau.cs.jittac.model.mapping.events.ArchitectureMappingChangeEvent;
import se.kau.cs.jittac.model.mapping.events.IArchitectureMappingChangeListener;
import se.kau.cs.jittac.model.mapping.events.ManagedProjectAddedEvent;
import se.kau.cs.jittac.model.mapping.events.ManagedProjectRemovedEvent;
import se.kau.cs.jittac.model.mapping.events.MappingAdditionEvent;
import se.kau.cs.jittac.model.mapping.events.MappingRemovalEvent;

/**
 * An architecture mapping is a mapping between the components of 
 * an architecture model and arbitrary ressources, for example source
 * code files.
 * @author Sebastian Herold
 *
 */
public class ArchitectureMapping {
	
	/**
	 * This class represents single entries in an architecture mapping.
	 * It maps a single component to a single resource.
	 * Entries are organized in a tree. Entries refine their parents. This means
	 * that the resource they refer to is in the scope of the parent entry
	 * and would be mapped to the component referred to there, if the child entry
	 * did not exist. For example, if a source code package pkg is mapped to component
	 * C, also pkg.a is automatically mapped to C, unless there is an entry
	 * mapping pkg.a to another component.
	 * @author Sebastian Herold
	 *
	 */
	public class Entry {
		public final Component comp;
		public final IMappableElement elem;
		public Entry refined = null;
		public Set<Entry> refining = new HashSet<Entry>();
		
		public Entry(Component comp, IMappableElement elem) {
			this.comp = comp;
			this.elem = elem;
		}
	}
	
	private Map<Component, Set<Entry>> explicitMappings;
	private Map<IMappableElement, Entry> explicitlyMappedElements;
	private Map<IJittacProject, Integer> managedProjects;
	private IJittacResourceFactory resourceFactory;
	private List<IArchitectureMappingChangeListener> listeners = new ArrayList<IArchitectureMappingChangeListener>();
	private ArchitectureModel architectureModel;
	
	/**
	 * Creates an empty architecture mapping and sets the
	 * resource factory that should be used for this mapping.
	 * @param resourceFactory The resource factory to be used.
	 * @return A new empty architecture mapping.
	 */
	public static ArchitectureMapping createEmptyMapping(IJittacResourceFactory resourceFactory, ArchitectureModel model) {
		return new ArchitectureMapping(resourceFactory, model);
	}
	
	/**
	 * Create an empty architecture mapping and sets the default
	 * resource factory as to be used.
	 * @return A new empty architecture mapping.
	 */
	public static ArchitectureMapping createEmptyMapping(ArchitectureModel model) {
		return new ArchitectureMapping(JittacResourceModelRegistry.INSTANCE.getDefaultResourceModel(), model);
	}
	
	private ArchitectureMapping(ArchitectureModel model) {
		this(JittacResourceModelRegistry.INSTANCE.getDefaultResourceModel(), model);
	}	
	
	private ArchitectureMapping(IJittacResourceFactory resourceFactory, ArchitectureModel model) {
		if (resourceFactory == null) 
			throw new NullPointerException(""No resource model set."");
		explicitMappings = new HashedMap<Component, Set<Entry>>();
		explicitlyMappedElements = new HashedMap<IMappableElement, Entry>();
		managedProjects = new HashedMap<IJittacProject, Integer>();
		this.resourceFactory = resourceFactory;
		this.architectureModel = model;
	}
	
	/**
	 * Returns the resource factory that is used in this mapping.
	 * @return see above.
	 */
	public IJittacResourceFactory getResourceFactory() {
		return resourceFactory;
	}
	
	/**
	 * Determines for resource the closest ancestor resource 
	 * for which an explicit mapping exists.  
	 * @param elem The element for which the described ancestor needs
	 * to be found.
	 * @return The closest explicitly mapped ancestor resource.
	 * If elem itself is explicitly mapped, elem is returned.
	 * Null if no such element exists.
	 */
	public IMappableElement getExplicitlyMappedParent(IMappableElement elem) {
		if (elem == null) return null;
		if (!explicitlyMappedElements.containsKey(elem)) {
			IMappableElement parent = elem.getParent();
			return getExplicitlyMappedParent(parent);
		}
		else {
			return elem;
		}
	}
	
	/**
	 * Determines the component that an element is mapped to, either directly
	 * or indirectly via an ancestor resource.
	 * @param elem The element for which the component is required.
	 * @return The corresponding component if such a component exists. 
	 */
	public Component getComponent(IMappableElement elem) {
		if (elem == null) return null;
		IMappableElement mappedParentOrSelf = this.getExplicitlyMappedParent(elem);
		if (mappedParentOrSelf == null) {
			return null;
		}
		else {
			return explicitlyMappedElements.get(mappedParentOrSelf).comp;
		}
	}

	/**
	 * Returns all the explicitly mapped resources for a component.
	 * @param comp The component for which the mapped resources are requested.
	 * @return Set of mapped resources.
	 */
	public Set<IMappableElement> getMappedResources(Component comp) {
		Set<IMappableElement> result = new HashSet<IMappableElement>();
		if (comp != null) {
			if (explicitMappings.containsKey(comp)) {
				for (Entry e : explicitMappings.get(comp)) {
					result.add(e.elem);
				}
			}
		}
		return result;
	}
	
	/**
	 * Adds a mapping between the specified resource and the specified component.
	 * No mapping is added if
	 * -the component is null or the resource is null, or
	 * -there is an explicit mapping for the resource already, or
	 * -the resource is already indirectly mapped to the specified component (because one its ancestor resources is already mapped to comp).
	 * @param comp The component onto which the resource should be mapped.
	 * @param resource The resource that should be mapped.
	 * @return True if a mapping has been added, false otherwise.
	 */
	public boolean addMapping(Component comp, IMappableElement resource) {
		if (comp == null || resource == null) throw new IllegalArgumentException(""Arguments must not be null!"");
		if (explicitlyMappedElements.containsKey(resource)) {
			return false;
		}
		else {
			Component currentComponent = getComponent(resource);
			if (comp.equals(currentComponent)) {
				return false;
			}
			else {
				_addMapping(comp, resource);
				fireEvent(new MappingAdditionEvent(comp, resource, currentComponent, this));
				return true;
			}
		}
	}
	
	public boolean removeComponent(Component comp) {
		boolean result = false;
		
		Set<IMappableElement> elements = this.getMappedResources(comp);
		result = elements.size() > 0;
		for (IMappableElement elem : elements) {
			boolean temp = removeMapping(comp, elem, true);
			result = result || temp;
		}
		return result;
	}
	
	/**
	 * Removes a single mapping between a given component and a given resource
	 * if this explicit mapping existed.
	 * @param comp The given component.
	 * @param resource The given resource.
	 * @return True if the the given component was explicitly mapped to the given
	 * resource. False otherwise.
	 */
	public boolean removeMapping(Component comp, IMappableElement resource) {
		return removeMapping(comp, resource, false);
	}

	public Set<IMappableElement> getIdenticallyMappedSubtree(IMappableElement elem) {
		HashSet<IMappableElement> result = new HashSet<>();
		Component comp = this.getComponent(elem);
		if (comp != null) {
			result.add(elem);
			for (IJittacResource child : elem.getChildren()) {
				if (comp.equals(this.getComponent(child))) {
					result.addAll(getIdenticallyMappedSubtree(child));
				}
			}
		}
		return result;
	}
	
	/**
	 * Removes an explicit mapping. See removeMapping(Component, IMappableElement)
	 * @param comp The given component
	 * @param resource The given resource
	 * @param isDuplicateRemoval Indicates whether or not this  removal is
	 * caused by another mapping removal. Removing a mapping entry can cause
	 * a further removals in case it leads to parent and child entries mapping
	 * to the same components which we do not allow. If this parameter is set
	 * to true, mapping listeners are not notified about the change.
	 * @return True if the the given component was explicitly mapped to the given
	 * resource. False otherwise.
	 */
	private boolean removeMapping(Component comp, IMappableElement resource, boolean isDuplicateRemoval) {
		if (comp == null || resource == null) throw new IllegalArgumentException(""Arguments must not be null!"");
		if (explicitlyMappedElements.containsKey(resource)) {
			Entry removeEntry = explicitlyMappedElements.get(resource);
			Set<Entry> currentMappings = explicitMappings.get(comp);

			_updateRefinementsForRemovedEntry(removeEntry);
			explicitlyMappedElements.remove(resource);
			currentMappings.remove(removeEntry);
			_decreaseResourceCounter(resource.getProject());
			if (currentMappings.isEmpty()) {
				explicitMappings.remove(comp);
			}
			if (!isDuplicateRemoval) {
				fireEvent(new MappingRemovalEvent(comp, resource, this.getComponent(resource), this));
			}
			return true;
		}
		else {
			return false;
		}
	}
	
	/**
	 * Adds a listener to the mapping.
	 * @param listener The listener to be added.
	 */
	public void registerListener(IArchitectureMappingChangeListener listener) {
		if (!listeners.contains(listener)) {
			listeners.add(listener);
		}
	}
	
	/**
	 * Removes a listener, so it does not get notified about mapping modifications
	 * anymore.
	 * @param listener The listener to be removed.
	 */
	public void deregisterListener(IArchitectureMappingChangeListener listener) {
		listeners.remove(listener);
	}
	
	/**
	 * Notifies registered listeners about a mapping modification
	 * @param event The mapping modification.
	 */
	public void fireEvent(ArchitectureMappingChangeEvent event) {
		for (IArchitectureMappingChangeListener l : listeners) {
			l.onEvent(event);
		}
	}
	
	private void _deleteEntryFromTree(Entry e) {
		Entry parent = e.refined;
		Set<Entry> children = e.refining;
		for (Entry child : children) {
			child.refined = parent;
		}
		if (parent != null) {
			parent.refining.remove(e);
			parent.refining.addAll(children);
		}
		e.refined = null;
		e.refining.clear();
	}
	
	
	
	private void _addMapping(Component comp, IMappableElement resource) {
		if (comp == null || resource == null) throw new IllegalArgumentException(""Arguments must not be null!"");		
		Set<Entry> currentMappings;
		
		if (!explicitMappings.containsKey(comp)) {
			currentMappings = new HashSet<Entry>();
			explicitMappings.put(comp, currentMappings);
		}
		else {
			currentMappings = explicitMappings.get(comp);
		}
		
		Entry newEntry = new Entry(comp, resource);
		currentMappings.add(newEntry);
		explicitlyMappedElements.put(resource, newEntry);
		_increaseResourceCounter(resource.getProject());
		_updateRefinementsForNewMapping(newEntry);
	}
	
	private void  _addEntryInTree(Entry newEntry) {
		if (newEntry == null) return;
		Entry parentEntry = explicitlyMappedElements.get(
				this.getExplicitlyMappedParent(newEntry.elem.getParent()));
		newEntry.refined = parentEntry;
		if (parentEntry != null) {
			Set<Entry> temp = new HashSet<Entry>(parentEntry.refining);
			for (Entry child : temp) {
				if (child.elem.isDescendantOf(newEntry.elem)) {
					parentEntry.refining.remove(child);
					child.refined = newEntry;
					newEntry.refining.add(child);
				}
			}
			parentEntry.refining.add(newEntry);
		}
		else {
			for (Entry e : explicitlyMappedElements.values()) {
				if (e.elem.isDescendantOf(newEntry.elem) && e.refined == null) {
					e.refined = newEntry;
					newEntry.refining.add(e);
				}
			}
		}
	}
	
	private void _updateRefinementsForNewMapping(Entry newEntry) {
		if (newEntry == null) return;
		_addEntryInTree(newEntry);
		_deleteIrrelevantRefinement(newEntry);
		_deleteIrrelevantRefinement(newEntry.refined, newEntry);
	}
	
	private void _updateRefinementsForRemovedEntry(Entry removeEntry) {
		if (removeEntry == null) return;
		Entry parent = removeEntry.refined;
		_deleteEntryFromTree(removeEntry);
		_deleteIrrelevantRefinement(parent);
	}
	
	private void _deleteIrrelevantRefinement(Entry entry) {
		if (entry == null) return;
		for (Entry child : entry.refining) {
			_deleteIrrelevantRefinement(entry, child);
		}
	}
	
	private void _deleteIrrelevantRefinement(Entry entry, Entry refining) {
		if (entry == null || refining == null) return;
		if (entry.refining.contains(refining) && entry.comp.equals(refining.comp)) {
			removeMapping(refining.comp, refining.elem, true);
		}
	}
	
	private void _increaseResourceCounter(IJittacProject project) {
		if (project == null) return;
		if (managedProjects.containsKey(project)) {
			int nrOfResources = managedProjects.get(project);
			managedProjects.put(project, nrOfResources + 1);
		}
		else {
			managedProjects.put(project, 1);
			fireEvent(new ManagedProjectAddedEvent(project, this));
		}
	}
	
	private void _decreaseResourceCounter(IJittacProject project) {
		if (project == null) return;
		if (managedProjects.containsKey(project)) {
			int nrOfResources = managedProjects.get(project);
			if (nrOfResources == 1) {
				managedProjects.remove(project);
				fireEvent(new ManagedProjectRemovedEvent(project, this));
			}
			else {
				managedProjects.put(project, nrOfResources - 1);
			}
		}
	}
	
	/**
	 * Returns the mapping entry for a resource
	 * @param elem the resource
	 * @return The mapping entry if an explicit mapping for elem exists.
	 */
	public Entry getEntryForElement(IMappableElement elem) {
		return explicitlyMappedElements.get(elem);
	}
	
	public Set<IJittacProject> getManagedProjects() {
		return new HashSet<IJittacProject>(managedProjects.keySet());
	}
}
"
AbstractArchitectureMappingChangeListener.java,resource-mapping,"package se.kau.cs.jittac.model.mapping.events;

public abstract class AbstractArchitectureMappingChangeListener implements IArchitectureMappingChangeListener {

	@Override
	public void onEvent(ArchitectureMappingChangeEvent event) {
		if (event == null) return;
		if (event instanceof MappingAdditionEvent) {
			onMappingAdded((MappingAdditionEvent) event);
		}
		else if (event instanceof MappingRemovalEvent) {
			onMappingRemoved((MappingRemovalEvent) event);
		}
		else if (event instanceof ManagedProjectAddedEvent) {
			
		}
		else if (event instanceof ManagedProjectRemovedEvent) {
			
		}
		
	}
	
	protected void onMappingAdded(MappingAdditionEvent event) {
	}

	protected void onMappingRemoved(MappingRemovalEvent event) {
	}
	
	protected void onManagedProjectAdded(ManagedProjectAddedEvent event) {
		
	}
	
	protected void onManagedProjectRemoved(ManagedProjectRemovedEvent event) {
		
	}
}
"
ArchitectureMappingChangeEvent.java,resource-mapping,"package se.kau.cs.jittac.model.mapping.events;

import se.kau.cs.jittac.model.mapping.ArchitectureMapping;

/**
 * Interface for change events in architecture mappings.
 * @author Sebastian Herold
 *
 */
public interface ArchitectureMappingChangeEvent {

	/**
	 * Returns the mapping that was modified through this event.
	 * @return see above.
	 */
	ArchitectureMapping getMapping();
}
"
IArchitectureMappingChangeListener.java,resource-mapping,"package se.kau.cs.jittac.model.mapping.events;

public interface IArchitectureMappingChangeListener {

	public void onEvent(ArchitectureMappingChangeEvent event);
}
"
ManagedProjectAddedEvent.java,resource-mapping,"package se.kau.cs.jittac.model.mapping.events;

import se.kau.cs.jittac.model.mapping.ArchitectureMapping;
import se.kau.cs.jittac.model.mapping.IJittacProject;

public class ManagedProjectAddedEvent implements ArchitectureMappingChangeEvent {

	private IJittacProject project;
	private ArchitectureMapping mapping;
	
	public ManagedProjectAddedEvent(IJittacProject project, ArchitectureMapping mapping) {
		this.project = project;
		this.mapping = mapping;
	}
	
	@Override
	public ArchitectureMapping getMapping() {
		return mapping;
	}
	
	public IJittacProject getProject() {
		return project;
	}

}
"
ManagedProjectRemovedEvent.java,resource-mapping,"package se.kau.cs.jittac.model.mapping.events;

import se.kau.cs.jittac.model.mapping.ArchitectureMapping;
import se.kau.cs.jittac.model.mapping.IJittacProject;

public class ManagedProjectRemovedEvent implements ArchitectureMappingChangeEvent {

	private IJittacProject project;
	private ArchitectureMapping mapping;
	
	public ManagedProjectRemovedEvent(IJittacProject project, ArchitectureMapping mapping) {
		this.project = project;
		this.mapping = mapping;
	}
	
	@Override
	public ArchitectureMapping getMapping() {
		return mapping;
	}

	public IJittacProject getProject() {
		return project;
	}
}
"
MappingAdditionEvent.java,resource-mapping,"package se.kau.cs.jittac.model.mapping.events;

import se.kau.cs.jittac.model.am.Component;
import se.kau.cs.jittac.model.mapping.ArchitectureMapping;
import se.kau.cs.jittac.model.mapping.IMappableElement;

/**
 * Event to represent the addition of a mapping to an architecture
 * mapping.
 * @author sebahero
 *
 */
public class MappingAdditionEvent implements ArchitectureMappingChangeEvent {

	private ArchitectureMapping mapping;
	private Component component, prevComp;
	private IMappableElement element;

	/**
	 * Create a mapping addition event.
	 * @param comp The component for which the new mapping was created.
	 * @param elem The resource for which the new mapping was created.
	 * @param prevComp The component that the resource was previously mapped to.
	 * @param mapping The architecture mapping that was changed by the event.
	 */
	public MappingAdditionEvent(Component comp, IMappableElement elem, Component prevComp, ArchitectureMapping mapping) {
		this.mapping = mapping;
		this.component = comp;
		this.element = elem;
		this.prevComp = prevComp;
	}
	
	@Override
	public ArchitectureMapping getMapping() {
		return this.mapping;
	}
	
	/**
	 * Returns the component that was newly mapped.
	 * @return see above.
	 */
	public Component getComponent() {
		return component;
	}
	
	/**
	 * Returns the component to which the resource was
	 * previously mapped.
	 * @return see above.
	 */
	public Component getPreviousComponent() {
		return prevComp;
	}
	
	/**
	 * Returns the resource that is newly mapped.
	 * @return see above.
	 */
	public IMappableElement getElement() {
		return element;
	}
}
"
MappingRemovalEvent.java,resource-mapping,"package se.kau.cs.jittac.model.mapping.events;

import se.kau.cs.jittac.model.am.Component;
import se.kau.cs.jittac.model.mapping.ArchitectureMapping;
import se.kau.cs.jittac.model.mapping.IMappableElement;

public class MappingRemovalEvent implements ArchitectureMappingChangeEvent {

	private ArchitectureMapping mapping;
	private Component component, componentAfterRemoval;
	private IMappableElement element;

	public MappingRemovalEvent(Component comp,
								IMappableElement elem,
								Component componentAfterRemoval,
								ArchitectureMapping mapping) {
		this.mapping = mapping;
		this.component = comp;
		this.element = elem;
		this.componentAfterRemoval = componentAfterRemoval;
	}
	
	@Override
	public ArchitectureMapping getMapping() {
		return this.mapping;
	}
	
	public Component getComponent() {
		return component;
	}
	
	public IMappableElement getElement() {
		return element;
	}
	
	public Component getComponentAfterRemoval() {
		return componentAfterRemoval;
	}
}
"
IJittacProject.java,resource-mapping,"package se.kau.cs.jittac.model.mapping;

import se.kau.cs.jittac.model.am.ArchitectureModel;
import se.kau.cs.jittac.model.im.IImplementationModel;

/**
 * This interface represents resources of type ""Project"" which
 * are the top-level resources.
 * @author Sebastian Herold
 *
 */
public interface IJittacProject extends IMappableElement {

	/**
	 * Returns the implementation model that this project is linked to.
	 * @return
	 */
	public IImplementationModel getImplementationModel();
	
	/**
	 * Returns the architecture model that this project is linked to.
	 * @return
	 */
	public ArchitectureModel getArchitectureModel();
}
"
IJittacResource.java,resource-mapping,"package se.kau.cs.jittac.model.mapping;

public interface IJittacResource extends IMappableElement {
}
"
IJittacResourceFactory.java,resource-mapping,"package se.kau.cs.jittac.model.mapping;

public interface IJittacResourceFactory {

	/**
	 * Creates a project resource from the given persistent handle.
	 * @param handle The persistent handle.
	 * @return The corresponding resource if handle can be interpreted.
	 * Null otherwise.
	 */
	public IJittacProject createJittacProjectFromPersistentHandle(String handle);
	
	/**
	 * Creates a non-project resource from the given persistent handle.
	 * @param handle The persistent handle.
	 * @return The corresponding resource if handle can be interpreted.
	 * Null otherwise.
	 */
	public IJittacResource createJittacResourceFromPersistentHandle(String handle, IJittacProject project);
	
	/**
	 * Returns the name of the resource model for which this object is a factory.
	 * @return
	 */
	public String getResourceModelName();
}
"
IMappableElement.java,resource-mapping,"package se.kau.cs.jittac.model.mapping;

import java.util.Set;

/**
 * This is the interface for both available types of resources - projects
 * and ""normal"" resources.
 * 
 * @author Sebastian Herold
 *
 */
public interface IMappableElement {

	/**
	 * Returns the project that a resource belongs to.
	 * @return The project.
	 */
	public IJittacProject getProject();
	
	/**
	 * Returns the parent resource of a resource.
	 * @return see above.
	 */
	public IMappableElement getParent();
	
	/**
	 * Returns the child resources of a resource
	 * @return see above.
	 */
	public Set<IJittacResource> getChildren();
	
	/**
	 * Checks if the current resource is direct or indirect child
	 * of a given resource 
	 * @param elem The resource for which it is checked whether the
	 * current element is a descendant of.
	 * @return True if the current resource is a descendant of the given
	 * resource. False otherwise.
	 */
	public boolean isDescendantOf(IMappableElement elem);
	
	/**
	 * Provides a string representation of an identifier for this resource.
	 * This must be persistent, i.e. it stays the same over different
	 * executions of the tool.
	 * @return A persistent identifier as string.
	 */
	public String getPersistentHandle();
	
	public String getResourceModelName();
}
"
JittacResourceModelRegistry.java,resource-mapping,"package se.kau.cs.jittac.model.mapping;

import java.util.Map;

import org.apache.commons.collections4.map.HashedMap;

/**
 * This class provides the means for managing different resource models,
 * e.g. for different IDEs.
 * 
 * @author Sebastian Herold
 *
 */
public class JittacResourceModelRegistry {

	private Map<String, IJittacResourceFactory> map;
	private IJittacResourceFactory defaultModel = null;
	
	public static JittacResourceModelRegistry INSTANCE = new JittacResourceModelRegistry();
	
	private JittacResourceModelRegistry() {
		map = new HashedMap<String, IJittacResourceFactory>();
	}
	
	/**
	 * Registers a new resource model by a factory for that resource model.
	 * @param factory The resource factory. getResourceModelName for that factory
	 * must not be empty. Will only be registered if no other factory for the same
	 * name has been registered before.
	 */
	public void registerResourceModel(IJittacResourceFactory factory) {
		String name = factory.getResourceModelName();
		if (name == null || name.equals("""") || factory == null) throw new IllegalArgumentException(""Cannnot register resource model."");

		if (!containsFactoryFor(name)) {
			map.put(name, factory);
		}
	}
	
	/**
	 * Sets the default resource model/factory.
	 * @param factory The factory to be used as default
	 * @return True if resource model/factory was registered. False otherwise.
	 */
	public boolean setDefaultResourceModel(IJittacResourceFactory factory) {
		if (map.containsKey(factory.getResourceModelName())) {
			defaultModel = factory;
			return true;
		}
		return false;
	}
	
	/**
	 * Returns the factory for the default resource model.
	 * @return
	 */
	public IJittacResourceFactory getDefaultResourceModel() {
		return defaultModel;
	}
	
	/**
	 * Checks whether a factory for a resource model exists.
	 * @param modelName The resource model given by its name
	 * @return True if factory exists, false otherwise.
	 */
	public boolean containsFactoryFor(String modelName) {
		return map.containsKey(modelName);
	}
	
	/**
	 * Returns the factory for a given resource model name.
	 * @param modelName The resource model name.
	 * @return see above.
	 */
	public IJittacResourceFactory getResourceModelFor(String modelName) {
		return map.get(modelName);
	}
	
	/**
	 * Deregisters a resource model by its name.
	 * @param modelName the name.
	 */
	public void deregisterResourceModel(String modelName) {
		map.remove(modelName);
	}
}
"
