FileName,Label,FileContent
AccountAttributes.java,data-transfer,"package teammates.common.datatransfer.attributes;

import java.util.ArrayList;
import java.util.Date;
import java.util.List;

import teammates.common.util.Assumption;
import teammates.common.util.FieldValidator;
import teammates.common.util.JsonUtils;
import teammates.common.util.SanitizationHelper;
import teammates.common.util.StringHelper;
import teammates.storage.entity.Account;

/**
 * A data transfer object for Account entities.
 */
public class AccountAttributes extends EntityAttributes<Account> {

    //Note: be careful when changing these variables as their names are used in *.json files.

    public String googleId;
    public String name;
    public boolean isInstructor;
    public String email;
    public String institute;
    public Date createdAt;
    public StudentProfileAttributes studentProfile;

    public AccountAttributes(Account a) {
        googleId = a.getGoogleId();
        name = a.getName();
        isInstructor = a.isInstructor();
        email = a.getEmail();
        institute = a.getInstitute();
        createdAt = a.getCreatedAt();
        studentProfile =
                a.getStudentProfile() == null ? null : StudentProfileAttributes.valueOf(a.getStudentProfile());
    }

    public AccountAttributes() {
        // attributes to be set after construction
    }

    public AccountAttributes(String googleId, String name, boolean isInstructor,
                String email, String institute, StudentProfileAttributes studentProfileAttributes) {
        this.googleId = SanitizationHelper.sanitizeGoogleId(googleId);
        this.name = SanitizationHelper.sanitizeName(name);
        this.isInstructor = isInstructor;
        this.email = SanitizationHelper.sanitizeEmail(email);
        this.institute = SanitizationHelper.sanitizeTitle(institute);
        this.studentProfile = studentProfileAttributes;
        this.studentProfile.sanitizeForSaving();

    }

    public AccountAttributes(String googleId, String name, boolean isInstructor,
                String email, String institute) {
        this.googleId = SanitizationHelper.sanitizeGoogleId(googleId);
        this.name = SanitizationHelper.sanitizeName(name);
        this.isInstructor = isInstructor;
        this.email = SanitizationHelper.sanitizeEmail(email);
        this.institute = SanitizationHelper.sanitizeTitle(institute);
        this.studentProfile = StudentProfileAttributes.builder().build();
        this.studentProfile.googleId = this.googleId;
    }

    /**
     * Gets a deep copy of this object.
     */
    public AccountAttributes getCopy() {
        AccountAttributes copy = new AccountAttributes(googleId, name, isInstructor, email, institute);
        copy.studentProfile = this.studentProfile == null ? null : this.studentProfile.getCopy();
        return copy;
    }

    public boolean isInstructor() {
        return isInstructor;
    }

    public String getGoogleId() {
        return googleId;
    }

    public String getName() {
        return name;
    }

    public String getEmail() {
        return email;
    }

    public String getTruncatedGoogleId() {
        return StringHelper.truncateLongId(googleId);
    }

    public String getInstitute() {
        return institute;
    }

    @Override
    public List<String> getInvalidityInfo() {
        FieldValidator validator = new FieldValidator();
        List<String> errors = new ArrayList<>();

        addNonEmptyError(validator.getInvalidityInfoForPersonName(name), errors);

        addNonEmptyError(validator.getInvalidityInfoForGoogleId(googleId), errors);

        addNonEmptyError(validator.getInvalidityInfoForEmail(email), errors);

        addNonEmptyError(validator.getInvalidityInfoForInstituteName(institute), errors);

        Assumption.assertTrue(""Non-null value expected for studentProfile"", this.studentProfile != null);
        // only check profile if the account is proper
        if (errors.isEmpty()) {
            errors.addAll(this.studentProfile.getInvalidityInfo());
        }

        //No validation for isInstructor and createdAt fields.
        return errors;
    }

    @Override
    public Account toEntity() {
        Assumption.assertNotNull(this.studentProfile);
        return new Account(googleId, name, isInstructor, email, institute, studentProfile.toEntity());
    }

    @Override
    public String toString() {
        return JsonUtils.toJson(this, AccountAttributes.class);
    }

    @Override
    public String getIdentificationString() {
        return this.googleId;
    }

    @Override
    public String getEntityTypeAsString() {
        return ""Account"";
    }

    @Override
    public String getBackupIdentifier() {
        return ""Account"";
    }

    @Override
    public String getJsonString() {
        return JsonUtils.toJson(this, AccountAttributes.class);
    }

    @Override
    public void sanitizeForSaving() {
        this.googleId = SanitizationHelper.sanitizeForHtml(googleId);
        this.name = SanitizationHelper.sanitizeForHtml(name);
        this.email = SanitizationHelper.sanitizeForHtml(email);
        this.institute = SanitizationHelper.sanitizeForHtml(institute);
        if (studentProfile == null) {
            return;
        }
        this.studentProfile.sanitizeForSaving();
    }

    public boolean isUserRegistered() {
        return googleId != null && !googleId.isEmpty();
    }

}
"
AdminEmailAttributes.java,data-transfer,"package teammates.common.datatransfer.attributes;

import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.List;

import com.google.appengine.api.datastore.Text;

import teammates.common.util.Const;
import teammates.common.util.FieldValidator;
import teammates.common.util.JsonUtils;
import teammates.common.util.SanitizationHelper;
import teammates.common.util.TimeHelper;
import teammates.storage.entity.AdminEmail;

public class AdminEmailAttributes extends EntityAttributes<AdminEmail> {

    public String emailId;
    public List<String> addressReceiver;
    public List<String> groupReceiver;
    public String subject;
    public Date sendDate;
    public Date createDate;
    public Text content;
    public boolean isInTrashBin;

    public AdminEmailAttributes(AdminEmail ae) {
        this.emailId = ae.getEmailId();
        this.addressReceiver = ae.getAddressReceiver();
        this.groupReceiver = ae.getGroupReceiver();
        this.subject = ae.getSubject();
        this.sendDate = ae.getSendDate();
        this.createDate = ae.getCreateDate();
        this.content = ae.getContent();
        this.isInTrashBin = ae.getIsInTrashBin();
    }

    public AdminEmailAttributes(String subject,
                                List<String> addressReceiver,
                                List<String> groupReceiver,
                                Text content,
                                Date sendDate) {
        this.subject = subject;
        this.addressReceiver = addressReceiver;
        this.groupReceiver = groupReceiver;
        this.content = content;
        this.sendDate = sendDate;
    }

    @Override
    public List<String> getInvalidityInfo() {

        FieldValidator validator = new FieldValidator();
        List<String> errors = new ArrayList<>();

        addNonEmptyError(validator.getInvalidityInfoForEmailContent(content), errors);

        addNonEmptyError(validator.getInvalidityInfoForEmailSubject(subject), errors);

        return errors;
    }

    @Override
    public AdminEmail toEntity() {
        return new AdminEmail(addressReceiver, groupReceiver, subject, content, sendDate);
    }

    @Override
    public String getIdentificationString() {
        return this.sendDate + ""/"" + this.subject;
    }

    @Override
    public String getEntityTypeAsString() {
        return ""Admin Email"";
    }

    @Override
    public String getBackupIdentifier() {
        return ""Admin Email"";
    }

    @Override
    public String getJsonString() {
        return JsonUtils.toJson(this, AdminEmail.class);
    }

    @Override
    public void sanitizeForSaving() {
        this.subject = SanitizationHelper.sanitizeTextField(subject);
        this.content = SanitizationHelper.sanitizeForRichText(content);
    }

    public String getEmailId() {
        return this.emailId;
    }

    public List<String> getAddressReceiver() {
        return this.addressReceiver;
    }

    public List<String> getGroupReceiver() {
        return this.groupReceiver;
    }

    public String getSubject() {
        return this.subject;
    }

    public Date getSendDate() {
        return this.sendDate;
    }

    public Date getCreateDate() {
        return this.createDate;
    }

    public String getContentValue() {
        return this.content.getValue();
    }

    public boolean getIsInTrashBin() {
        return this.isInTrashBin;
    }

    public String getSendDateForDisplay() {
        if (this.sendDate == null) {
            return ""Draft"";
        }

        Calendar cal = Calendar.getInstance();
        cal.setTime(this.sendDate);
        cal = TimeHelper.convertToUserTimeZone(cal, Const.SystemParams.ADMIN_TIME_ZONE_DOUBLE);

        return TimeHelper.formatTime12H(cal.getTime());
    }

    public String getCreateDateForDisplay() {
        Calendar cal = Calendar.getInstance();
        cal.setTime(this.createDate);
        cal = TimeHelper.convertToUserTimeZone(cal, Const.SystemParams.ADMIN_TIME_ZONE_DOUBLE);

        return TimeHelper.formatTime12H(cal.getTime());
    }

    public String getFirstAddressReceiver() {
        return this.addressReceiver.get(0);
    }

    public String getFirstGroupReceiver() {
        return getGroupReceiver().get(0);
    }
}
"
CourseAttributes.java,data-transfer,"package teammates.common.datatransfer.attributes;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.Date;
import java.util.List;

import teammates.common.util.Const;
import teammates.common.util.FieldValidator;
import teammates.common.util.JsonUtils;
import teammates.common.util.SanitizationHelper;
import teammates.storage.entity.Course;

/**
 * The data transfer object for Course entities.
 */
public class CourseAttributes extends EntityAttributes<Course> implements Comparable<CourseAttributes> {

    private static Comparator<CourseAttributes> createdDateComparator = new Comparator<CourseAttributes>() {
        @Override
        public int compare(CourseAttributes course1, CourseAttributes course2) {
            if (course1.createdAt.compareTo(course2.createdAt) == 0) {
                return course1.getId().compareTo(course2.getId());
            }

            // sort by newest course first
            return -1 * course1.createdAt.compareTo(course2.createdAt);
        }
    };

    //Note: be careful when changing these variables as their names are used in *.json files.
    public Date createdAt;
    private String id;
    private String name;
    private String timeZone;

    public CourseAttributes() {
        // attributes to be set after construction
    }

    public CourseAttributes(String courseId, String name, String timeZone) {
        this.id = SanitizationHelper.sanitizeTitle(courseId);
        this.name = SanitizationHelper.sanitizeTitle(name);
        this.timeZone = timeZone;
    }

    public CourseAttributes(Course course) {
        this.id = course.getUniqueId();
        this.name = course.getName();
        this.timeZone = course.getTimeZone();
        this.createdAt = course.getCreatedAt();
    }

    public String getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    public String getTimeZone() {
        return timeZone;
    }

    public void setTimeZone(String timeZone) {
        this.timeZone = timeZone;
    }

    @Override
    public List<String> getInvalidityInfo() {

        FieldValidator validator = new FieldValidator();
        List<String> errors = new ArrayList<>();

        addNonEmptyError(validator.getInvalidityInfoForCourseId(getId()), errors);

        addNonEmptyError(validator.getInvalidityInfoForCourseName(getName()), errors);

        addNonEmptyError(validator.getInvalidityInfoForCourseTimeZone(getTimeZone()), errors);

        return errors;
    }

    @Override
    public Course toEntity() {
        return new Course(getId(), getName(), getTimeZone(), createdAt);
    }

    @Override
    public String toString() {
        return ""["" + CourseAttributes.class.getSimpleName() + ""] id: "" + getId() + "" name: "" + getName()
               + "" timeZone: "" + getTimeZone();
    }

    @Override
    public String getIdentificationString() {
        return getId();
    }

    @Override
    public String getEntityTypeAsString() {
        return ""Course"";
    }

    @Override
    public String getBackupIdentifier() {
        return Const.SystemParams.COURSE_BACKUP_LOG_MSG + getId();
    }

    @Override
    public String getJsonString() {
        return JsonUtils.toJson(this, CourseAttributes.class);
    }

    @Override
    public void sanitizeForSaving() {
        // no additional sanitization required
    }

    @Override
    public int compareTo(CourseAttributes o) {
        if (o == null) {
            return 0;
        }
        return o.createdAt.compareTo(createdAt);
    }

    public static void sortById(List<CourseAttributes> courses) {
        Collections.sort(courses, new Comparator<CourseAttributes>() {
            @Override
            public int compare(CourseAttributes c1, CourseAttributes c2) {
                return c1.getId().compareTo(c2.getId());
            }
        });
    }

    public static void sortByCreatedDate(List<CourseAttributes> courses) {
        Collections.sort(courses, createdDateComparator);
    }

}
"
EntityAttributes.java,data-transfer,"package teammates.common.datatransfer.attributes;

import java.util.List;

import teammates.storage.entity.BaseEntity;

/**
 * Base class for Attribute classes (Attribute classes represent attributes of
 * persistable entities).
 */
public abstract class EntityAttributes<E extends BaseEntity> {

    /**
     * Returns true if the attributes represent a valid state for the entity.
     */
    public boolean isValid() {
        return getInvalidityInfo().isEmpty();
    }

    /**
     * Returns a {@code List} of strings, one string for each attribute whose
     *         value is invalid. The string explains why the value is invalid
     *         and what should values are acceptable. These explanations are
     *         good enough to show to the user. Returns an empty {@code List} if
     *         all attributes are valid.
     */
    public abstract List<String> getInvalidityInfo();

    /**
     * Returns a {@code Object} corresponding to the attributes defined by {@code this}
     *            {@link EntityAttributes} class.
     */
    public abstract E toEntity();

    /**
     * Returns an abridged string which can sufficiently identify the entity
     *            this class represents for use in error messages / exceptions.
     */
    public abstract String getIdentificationString();

    /**
     * Returns the type of entity this Attribute class represents as a human
     *            readable string.
     */
    public abstract String getEntityTypeAsString();

    /**
     * Returns the identifier used for logging to perform backup.
     */
    public abstract String getBackupIdentifier();

    /**
     * Returns the entity object as a JSON-formatted string.
     */
    public abstract String getJsonString();

    /**
     * Perform any sanitization that needs to be done before saving.
     * e.g. trim strings
     */
    public abstract void sanitizeForSaving();

    /**
     * Adds {@code error} to {@code errors} if {@code error} is a non-empty string.
     *
     * @param error An error message, possibly empty.
     * @param errors A List of errors, to add {@code error} to.
     */
    public void addNonEmptyError(String error, List<String> errors) {
        if (error.isEmpty()) {
            return;
        }

        errors.add(error);
    }
}
"
FeedbackQuestionAttributes.java,data-transfer,"package teammates.common.datatransfer.attributes;

import java.util.ArrayList;
import java.util.Date;
import java.util.List;

import org.json.JSONException;
import org.json.JSONObject;

import com.google.appengine.api.datastore.Text;

import teammates.common.datatransfer.FeedbackParticipantType;
import teammates.common.datatransfer.questions.FeedbackQuestionDetails;
import teammates.common.datatransfer.questions.FeedbackQuestionType;
import teammates.common.datatransfer.questions.FeedbackTextQuestionDetails;
import teammates.common.util.Const;
import teammates.common.util.FieldValidator;
import teammates.common.util.JsonUtils;
import teammates.common.util.SanitizationHelper;
import teammates.storage.entity.FeedbackQuestion;

public class FeedbackQuestionAttributes extends EntityAttributes<FeedbackQuestion>
        implements Comparable<FeedbackQuestionAttributes> {
    public String feedbackSessionName;
    public String courseId;
    public String creatorEmail;
    /**
     * Contains the JSON formatted string that holds the information of the question details.
     *
     * <p>Don't use directly unless for storing/loading from data store.<br>
     * To get the question text use {@code getQuestionDetails().questionText}
     */
    public Text questionMetaData;
    public Text questionDescription;
    public int questionNumber;
    public FeedbackQuestionType questionType;
    public FeedbackParticipantType giverType;
    public FeedbackParticipantType recipientType;
    public int numberOfEntitiesToGiveFeedbackTo;
    public List<FeedbackParticipantType> showResponsesTo;
    public List<FeedbackParticipantType> showGiverNameTo;
    public List<FeedbackParticipantType> showRecipientNameTo;
    protected transient Date createdAt;
    protected transient Date updatedAt;
    private String feedbackQuestionId;

    public FeedbackQuestionAttributes() {
        // attributes to be set after construction
    }

    public FeedbackQuestionAttributes(FeedbackQuestion fq) {
        this.feedbackQuestionId = fq.getId();
        this.feedbackSessionName = fq.getFeedbackSessionName();
        this.courseId = fq.getCourseId();
        this.creatorEmail = fq.getCreatorEmail();
        this.questionMetaData = fq.getQuestionMetaData();
        this.questionDescription = SanitizationHelper.sanitizeForRichText(fq.getQuestionDescription());
        this.questionNumber = fq.getQuestionNumber();
        this.questionType = fq.getQuestionType();
        this.giverType = fq.getGiverType();
        this.recipientType = fq.getRecipientType();
        this.numberOfEntitiesToGiveFeedbackTo = fq.getNumberOfEntitiesToGiveFeedbackTo();
        this.showResponsesTo = new ArrayList<>(fq.getShowResponsesTo());
        this.showGiverNameTo = new ArrayList<>(fq.getShowGiverNameTo());
        this.showRecipientNameTo = new ArrayList<>(fq.getShowRecipientNameTo());

        this.createdAt = fq.getCreatedAt();
        this.updatedAt = fq.getUpdatedAt();

        removeIrrelevantVisibilityOptions();
    }

    private FeedbackQuestionAttributes(FeedbackQuestionAttributes other) {
        this.feedbackQuestionId = other.getId();
        this.feedbackSessionName = other.getFeedbackSessionName();
        this.courseId = other.getCourseId();
        this.creatorEmail = other.getCreatorEmail();
        this.questionMetaData = other.getQuestionMetaData();
        this.questionNumber = other.getQuestionNumber();
        this.questionType = other.getQuestionType();
        this.giverType = other.getGiverType();
        this.recipientType = other.getRecipientType();
        this.numberOfEntitiesToGiveFeedbackTo = other.getNumberOfEntitiesToGiveFeedbackTo();
        this.showResponsesTo = new ArrayList<>(other.getShowResponsesTo());
        this.showGiverNameTo = new ArrayList<>(other.getShowGiverNameTo());
        this.showRecipientNameTo = new ArrayList<>(other.getShowRecipientNameTo());

        this.createdAt = other.getCreatedAt();
        this.updatedAt = other.getUpdatedAt();

        removeIrrelevantVisibilityOptions();
    }

    public FeedbackQuestionAttributes getCopy() {
        return new FeedbackQuestionAttributes(this);
    }

    public Date getCreatedAt() {
        return createdAt == null ? Const.TIME_REPRESENTS_DEFAULT_TIMESTAMP : createdAt;
    }

    public Date getUpdatedAt() {
        return updatedAt == null ? Const.TIME_REPRESENTS_DEFAULT_TIMESTAMP : updatedAt;
    }

    public String getId() {
        return feedbackQuestionId;
    }

    /** NOTE: Only use this to match and search for the ID of a known existing question entity. */
    public void setId(String id) {
        this.feedbackQuestionId = id;
    }

    @Override
    public FeedbackQuestion toEntity() {
        return new FeedbackQuestion(feedbackSessionName, courseId, creatorEmail,
                                    questionMetaData, questionDescription, questionNumber, questionType, giverType,
                                    recipientType, numberOfEntitiesToGiveFeedbackTo,
                                    showResponsesTo, showGiverNameTo, showRecipientNameTo);
    }

    @Override
    public String toString() {
        return ""FeedbackQuestionAttributes [feedbackSessionName=""
               + feedbackSessionName + "", courseId="" + courseId
               + "", creatorEmail="" + creatorEmail + "", questionText=""
               + questionMetaData + "", questionDescription="" + questionDescription
               + "", questionNumber="" + questionNumber
               + "", questionType="" + questionType + "", giverType="" + giverType
               + "", recipientType="" + recipientType
               + "", numberOfEntitiesToGiveFeedbackTo=""
               + numberOfEntitiesToGiveFeedbackTo + "", showResponsesTo=""
               + showResponsesTo + "", showGiverNameTo="" + showGiverNameTo
               + "", showRecipientNameTo="" + showRecipientNameTo + ""]"";
    }

    @Override
    public String getIdentificationString() {
        return this.questionNumber + "". "" + this.questionMetaData.toString() + ""/""
               + this.feedbackSessionName + ""/"" + this.courseId;
    }

    @Override
    public String getEntityTypeAsString() {
        return ""Feedback Question"";
    }

    @Override
    public String getBackupIdentifier() {
        return Const.SystemParams.COURSE_BACKUP_LOG_MSG + courseId;
    }

    @Override
    public String getJsonString() {
        return JsonUtils.toJson(this, FeedbackQuestionAttributes.class);
    }

    @Override
    public List<String> getInvalidityInfo() {
        FieldValidator validator = new FieldValidator();
        List<String> errors = new ArrayList<>();

        addNonEmptyError(validator.getInvalidityInfoForFeedbackSessionName(feedbackSessionName), errors);

        addNonEmptyError(validator.getInvalidityInfoForCourseId(courseId), errors);

        // special case when additional text should be added to error text
        String error = validator.getInvalidityInfoForEmail(creatorEmail);
        if (!error.isEmpty()) {
            error = new StringBuffer()
                    .append(""Invalid creator's email: "")
                    .append(error)
                    .toString();
        }
        addNonEmptyError(error, errors);

        errors.addAll(validator.getValidityInfoForFeedbackParticipantType(giverType, recipientType));

        errors.addAll(validator.getValidityInfoForFeedbackResponseVisibility(showResponsesTo,
                                                                             showGiverNameTo,
                                                                             showRecipientNameTo));

        return errors;
    }

    // TODO: move following methods to PageData?
    // Answer: OK to move to the respective PageData class. Unit test this thoroughly.
    public List<String> getVisibilityMessage() {
        List<String> message = new ArrayList<>();

        for (FeedbackParticipantType participant : showResponsesTo) {
            StringBuilder line = new StringBuilder(100);

            // Exceptional case: self feedback
            if (participant == FeedbackParticipantType.RECEIVER
                    && recipientType == FeedbackParticipantType.SELF) {
                message.add(""You can see your own feedback in the results page later on."");
                continue;
            }

            // Front fragment: e.g. Other students in the course..., The receiving.., etc.
            line.append(participant.toVisibilityString()).append(' ');

            // Recipient fragment: e.g. student, instructor, etc.
            if (participant == FeedbackParticipantType.RECEIVER) {
                line.append(recipientType.toSingularFormString());

                if (numberOfEntitiesToGiveFeedbackTo > 1) {
                    line.append('s');
                }

                line.append(' ');
            }

            line.append(""can see your response"");

            // Visibility fragment: e.g. can see your name, but not...
            if (showRecipientNameTo.contains(participant)) {
                if (participant != FeedbackParticipantType.RECEIVER
                        && recipientType != FeedbackParticipantType.NONE) {
                    line.append("", the name of the recipient"");
                }

                if (showGiverNameTo.contains(participant)) {
                    line.append("", and your name"");
                } else {
                    line.append("", but not your name"");
                }
            } else {
                if (showGiverNameTo.contains(participant)) {
                    line.append("", and your name"");
                }

                if (recipientType == FeedbackParticipantType.NONE) {
                    if (!showGiverNameTo.contains(participant)) {
                        line.append("", but not your name"");
                    }
                } else {
                    line.append("", but not the name of the recipient"");

                    if (!showGiverNameTo.contains(participant)) {
                        line.append("", or your name"");
                    }
                }

            }

            line.append('.');
            message.add(line.toString());
        }

        if (message.isEmpty()) {
            message.add(""No-one can see your responses."");
        }

        return message;
    }

    @Override
    public boolean isValid() {
        return getInvalidityInfo().isEmpty();
    }

    public boolean isGiverAStudent() {
        return giverType == FeedbackParticipantType.SELF
               || giverType == FeedbackParticipantType.STUDENTS;
    }

    public boolean isRecipientNameHidden() {
        return recipientType == FeedbackParticipantType.NONE
               || recipientType == FeedbackParticipantType.SELF;
    }

    public boolean isRecipientAStudent() {
        return recipientType == FeedbackParticipantType.SELF
               || recipientType == FeedbackParticipantType.STUDENTS
               || recipientType == FeedbackParticipantType.OWN_TEAM_MEMBERS
               || recipientType == FeedbackParticipantType.OWN_TEAM_MEMBERS_INCLUDING_SELF;
    }

    public boolean isResponseVisibleTo(FeedbackParticipantType userType) {
        return showResponsesTo.contains(userType);
    }

    /**
     * Checks if updating this question to the {@code newAttributes} will
     * require the responses to be deleted for consistency.
     * Does not check if any responses exist.
     */
    public boolean areResponseDeletionsRequiredForChanges(FeedbackQuestionAttributes newAttributes) {
        if (!newAttributes.giverType.equals(this.giverType)
                || !newAttributes.recipientType.equals(this.recipientType)) {
            return true;
        }

        return this.getQuestionDetails().isChangesRequiresResponseDeletion(newAttributes.getQuestionDetails());
    }

    @Override
    public int compareTo(FeedbackQuestionAttributes o) {
        if (o == null) {
            return 1;
        }

        if (this.questionNumber != o.questionNumber) {
            return Integer.compare(this.questionNumber, o.questionNumber);
        }
        /**
         * Although question numbers ought to be unique in a feedback session,
         * eventual consistency can result in duplicate questions numbers.
         * Therefore, to ensure that the question order is always consistent to the user,
         * compare feedbackQuestionId, which is guaranteed to be unique,
         * when the questionNumbers are the same.
         */
        return this.feedbackQuestionId.compareTo(o.feedbackQuestionId);
    }

    @Override
    public int hashCode() {
        final int prime = 31;
        int result = 1;

        result = prime * result + (courseId == null ? 0 : courseId.hashCode());

        result = prime * result + (creatorEmail == null ? 0 : creatorEmail.hashCode());

        result = prime * result + (feedbackSessionName == null ? 0 : feedbackSessionName.hashCode());

        result = prime * result + (giverType == null ? 0 : giverType.hashCode());

        result = prime * result + numberOfEntitiesToGiveFeedbackTo;

        result = prime * result + questionNumber;

        result = prime * result + (questionMetaData == null ? 0 : questionMetaData.hashCode());

        result = prime * result + (questionDescription == null ? 0 : questionDescription.hashCode());

        result = prime * result + (questionType == null ? 0 : questionType.hashCode());

        result = prime * result + (recipientType == null ? 0 : recipientType.hashCode());

        result = prime * result + (showGiverNameTo == null ? 0 : showGiverNameTo.hashCode());

        result = prime * result + (showRecipientNameTo == null ? 0 : showRecipientNameTo.hashCode());

        result = prime * result + (showResponsesTo == null ? 0 : showResponsesTo.hashCode());

        return result;
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) {
            return true;
        }

        if (obj == null) {
            return false;
        }

        if (getClass() != obj.getClass()) {
            return false;
        }

        FeedbackQuestionAttributes other = (FeedbackQuestionAttributes) obj;

        if (courseId == null) {
            if (other.courseId != null) {
                return false;
            }
        } else if (!courseId.equals(other.courseId)) {
            return false;
        }

        if (creatorEmail == null) {
            if (other.creatorEmail != null) {
                return false;
            }
        } else if (!creatorEmail.equals(other.creatorEmail)) {
            return false;
        }

        if (feedbackSessionName == null) {
            if (other.feedbackSessionName != null) {
                return false;
            }
        } else if (!feedbackSessionName.equals(other.feedbackSessionName)) {
            return false;
        }

        if (giverType != other.giverType) {
            return false;
        }

        if (numberOfEntitiesToGiveFeedbackTo != other.numberOfEntitiesToGiveFeedbackTo) {
            return false;
        }

        if (questionNumber != other.questionNumber) {
            return false;
        }

        if (questionMetaData == null) {
            if (other.questionMetaData != null) {
                return false;
            }
        } else if (!questionMetaData.equals(other.questionMetaData)) {
            return false;
        }

        if (questionDescription == null) {
            if (other.questionDescription != null) {
                return false;
            }
        } else if (!questionDescription.equals(other.questionDescription)) {
            return false;
        }

        if (questionType != other.questionType) {
            return false;
        }

        if (recipientType != other.recipientType) {
            return false;
        }

        if (showGiverNameTo == null) {
            if (other.showGiverNameTo != null) {
                return false;
            }
        } else if (!showGiverNameTo.equals(other.showGiverNameTo)) {
            return false;
        }

        if (showRecipientNameTo == null) {
            if (other.showRecipientNameTo != null) {
                return false;
            }
        } else if (!showRecipientNameTo.equals(other.showRecipientNameTo)) {
            return false;
        }

        if (showResponsesTo == null) {
            if (other.showResponsesTo != null) {
                return false;
            }
        } else if (!showResponsesTo.equals(other.showResponsesTo)) {
            return false;
        }

        return true;
    }

    public void updateValues(FeedbackQuestionAttributes newAttributes) {
        // These can't be changed anyway. Copy values to defensively avoid invalid parameters.
        newAttributes.feedbackSessionName = this.feedbackSessionName;
        newAttributes.courseId = this.courseId;
        newAttributes.creatorEmail = this.creatorEmail;

        if (newAttributes.questionMetaData == null) {
            newAttributes.questionMetaData = this.questionMetaData;
        }

        if (newAttributes.questionDescription == null) {
            newAttributes.questionDescription = this.questionDescription;
        }

        if (newAttributes.questionType == null) {
            newAttributes.questionType = this.questionType;
        }

        if (newAttributes.giverType == null) {
            newAttributes.giverType = this.giverType;
        }

        if (newAttributes.recipientType == null) {
            newAttributes.recipientType = this.recipientType;
        }

        if (newAttributes.showResponsesTo == null) {
            newAttributes.showResponsesTo = this.showResponsesTo;
        }

        if (newAttributes.showGiverNameTo == null) {
            newAttributes.showGiverNameTo = this.showGiverNameTo;
        }

        if (newAttributes.showRecipientNameTo == null) {
            newAttributes.showRecipientNameTo = this.showRecipientNameTo;
        }
    }

    public void removeIrrelevantVisibilityOptions() {
        List<FeedbackParticipantType> optionsToRemove = new ArrayList<>();

        switch (recipientType) {
        case NONE:
            optionsToRemove.add(FeedbackParticipantType.RECEIVER);
            optionsToRemove.add(FeedbackParticipantType.RECEIVER_TEAM_MEMBERS);
            break;
        case TEAMS:
        case INSTRUCTORS:
        case OWN_TEAM:
        case OWN_TEAM_MEMBERS:
            optionsToRemove.add(FeedbackParticipantType.RECEIVER_TEAM_MEMBERS);
            break;
        default:
            break;
        }

        switch (giverType) {
        case TEAMS:
        case INSTRUCTORS:
            optionsToRemove.add(FeedbackParticipantType.OWN_TEAM_MEMBERS);
            break;
        default:
            break;
        }

        removeVisibilities(optionsToRemove);
    }

    private void removeVisibilities(List<FeedbackParticipantType> optionsToRemove) {
        showResponsesTo.removeAll(optionsToRemove);
        showGiverNameTo.removeAll(optionsToRemove);
        showRecipientNameTo.removeAll(optionsToRemove);
    }

    @Override
    public void sanitizeForSaving() {
        this.questionDescription = SanitizationHelper.sanitizeForRichText(this.questionDescription);
    }

    private boolean isValidJsonString(String jsonString) {
        try {
            new JSONObject(jsonString);
        } catch (JSONException e) {
            return false;
        }
        return true;
    }

    /**
     * Converts the given Feedback*QuestionDetails object to JSON for storing.
     */
    public void setQuestionDetails(FeedbackQuestionDetails questionDetails) {
        questionMetaData = new Text(JsonUtils.toJson(questionDetails, getFeedbackQuestionDetailsClass()));
    }

    /**
     * Retrieves the Feedback*QuestionDetails object for this question.
     *
     * @return The Feedback*QuestionDetails object representing the question's details
     */
    public FeedbackQuestionDetails getQuestionDetails() {
        final String questionMetaDataValue = questionMetaData.getValue();
        // For old Text questions, the questionText simply contains the question, not a JSON
        if (questionType == FeedbackQuestionType.TEXT && !isValidJsonString(questionMetaDataValue)) {
            return new FeedbackTextQuestionDetails(questionMetaDataValue);
        }
        return JsonUtils.fromJson(questionMetaDataValue, getFeedbackQuestionDetailsClass());
    }

    /**
     * This method gets the appropriate class type for the Feedback*QuestionDetails object for this question.
     *
     * @return The Feedback*QuestionDetails class type appropriate for this question.
     */
    private Class<? extends FeedbackQuestionDetails> getFeedbackQuestionDetailsClass() {
        return questionType.getQuestionDetailsClass();
    }

    public String getFeedbackQuestionId() {
        return feedbackQuestionId;
    }

    public String getFeedbackSessionName() {
        return feedbackSessionName;
    }

    public String getCourseId() {
        return courseId;
    }

    public String getCreatorEmail() {
        return creatorEmail;
    }

    public Text getQuestionMetaData() {
        return questionMetaData;
    }

    public Text getQuestionDescription() {
        return questionDescription;
    }

    public void setQuestionDescription(Text questionDescription) {
        this.questionDescription = questionDescription;
    }

    public int getQuestionNumber() {
        return questionNumber;
    }

    public FeedbackQuestionType getQuestionType() {
        return questionType;
    }

    public FeedbackParticipantType getGiverType() {
        return giverType;
    }

    public FeedbackParticipantType getRecipientType() {
        return recipientType;
    }

    public int getNumberOfEntitiesToGiveFeedbackTo() {
        return numberOfEntitiesToGiveFeedbackTo;
    }

    public List<FeedbackParticipantType> getShowResponsesTo() {
        return showResponsesTo;
    }

    public List<FeedbackParticipantType> getShowGiverNameTo() {
        return showGiverNameTo;
    }

    public List<FeedbackParticipantType> getShowRecipientNameTo() {
        return showRecipientNameTo;
    }

    public String getQuestionAdditionalInfoHtml() {
        return getQuestionDetails().getQuestionAdditionalInfoHtml(questionNumber, """");
    }

}
"
FeedbackResponseAttributes.java,data-transfer,"package teammates.common.datatransfer.attributes;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.Date;
import java.util.List;

import com.google.appengine.api.datastore.Text;

import teammates.common.datatransfer.questions.FeedbackQuestionType;
import teammates.common.datatransfer.questions.FeedbackResponseDetails;
import teammates.common.datatransfer.questions.FeedbackTextResponseDetails;
import teammates.common.util.Const;
import teammates.common.util.FieldValidator;
import teammates.common.util.JsonUtils;
import teammates.storage.entity.FeedbackResponse;

public class FeedbackResponseAttributes extends EntityAttributes<FeedbackResponse> {
    public String feedbackSessionName;
    public String courseId;
    public String feedbackQuestionId;
    public FeedbackQuestionType feedbackQuestionType;
    /**
    * Depending on the question giver type, {@code giver} may contain the giver's email, the team name,
    * ""anonymous"", etc.
    */
    public String giver;
    /**
     * Depending on the question recipient type, {@code recipient} may contain the recipient's email, the team
     * name, ""%GENERAL%"", etc.
     */
    public String recipient;

    /** Contains the JSON formatted string that holds the information of the response details <br>
     * Don't use directly unless for storing/loading from data store <br>
     * To get the answer text use {@code getResponseDetails().getAnswerString()}
     *
     * <p>This is set to null to represent a missing response.
     */
    public Text responseMetaData;
    public String giverSection;
    public String recipientSection;
    protected transient Date createdAt;
    protected transient Date updatedAt;
    private String feedbackResponseId;

    public FeedbackResponseAttributes() {
        // attributes to be set after construction
    }

    public FeedbackResponseAttributes(String feedbackSessionName,
            String courseId, String feedbackQuestionId,
            FeedbackQuestionType feedbackQuestionType, String giver, String giverSection,
            String recipient, String recipientSection, Text responseMetaData) {
        this.feedbackSessionName = feedbackSessionName;
        this.courseId = courseId;
        this.feedbackQuestionId = feedbackQuestionId;
        this.feedbackQuestionType = feedbackQuestionType;
        this.giver = giver;
        this.giverSection = giverSection;
        this.recipient = recipient;
        this.recipientSection = recipientSection;
        this.responseMetaData = responseMetaData;
    }

    public FeedbackResponseAttributes(FeedbackResponse fr) {
        this.feedbackResponseId = fr.getId();
        this.feedbackSessionName = fr.getFeedbackSessionName();
        this.courseId = fr.getCourseId();
        this.feedbackQuestionId = fr.getFeedbackQuestionId();
        this.feedbackQuestionType = fr.getFeedbackQuestionType();
        this.giver = fr.getGiverEmail();
        this.giverSection = fr.getGiverSection() == null ? Const.DEFAULT_SECTION : fr.getGiverSection();
        this.recipient = fr.getRecipientEmail();
        this.recipientSection = fr.getRecipientSection() == null ? Const.DEFAULT_SECTION : fr.getRecipientSection();
        this.responseMetaData = fr.getResponseMetaData();
        this.createdAt = fr.getCreatedAt();
        this.updatedAt = fr.getUpdatedAt();
    }

    public FeedbackResponseAttributes(FeedbackResponseAttributes copy) {
        this.feedbackResponseId = copy.getId();
        this.feedbackSessionName = copy.feedbackSessionName;
        this.courseId = copy.courseId;
        this.feedbackQuestionId = copy.feedbackQuestionId;
        this.feedbackQuestionType = copy.feedbackQuestionType;
        this.giver = copy.giver;
        this.giverSection = copy.giverSection;
        this.recipient = copy.recipient;
        this.recipientSection = copy.recipientSection;
        this.responseMetaData = copy.responseMetaData;
        this.createdAt = copy.createdAt;
        this.updatedAt = copy.updatedAt;
    }

    public String getId() {
        return feedbackResponseId;
    }

    public void setId(String feedbackResponseId) {
        this.feedbackResponseId = feedbackResponseId;
    }

    public Date getCreatedAt() {
        return createdAt == null ? Const.TIME_REPRESENTS_DEFAULT_TIMESTAMP : createdAt;
    }

    public Date getUpdatedAt() {
        return updatedAt == null ? Const.TIME_REPRESENTS_DEFAULT_TIMESTAMP : updatedAt;
    }

    @Override
    public List<String> getInvalidityInfo() {

        FieldValidator validator = new FieldValidator();
        List<String> errors = new ArrayList<>();

        addNonEmptyError(validator.getInvalidityInfoForFeedbackSessionName(feedbackSessionName), errors);

        addNonEmptyError(validator.getInvalidityInfoForCourseId(courseId), errors);

        return errors;
    }

    @Override
    public boolean isValid() {
        return getInvalidityInfo().isEmpty();
    }

    @Override
    public FeedbackResponse toEntity() {
        return new FeedbackResponse(feedbackSessionName, courseId,
                feedbackQuestionId, feedbackQuestionType,
                giver, giverSection, recipient, recipientSection, responseMetaData);
    }

    @Override
    public String getIdentificationString() {
        return feedbackQuestionId + ""/"" + giver + "":"" + recipient;
    }

    @Override
    public String getEntityTypeAsString() {
        return ""Feedback Response"";
    }

    @Override
    public String getBackupIdentifier() {
        return Const.SystemParams.COURSE_BACKUP_LOG_MSG + courseId;
    }

    @Override
    public String toString() {
        return ""FeedbackResponseAttributes [feedbackSessionName=""
                + feedbackSessionName + "", courseId="" + courseId
                + "", feedbackQuestionId="" + feedbackQuestionId
                + "", feedbackQuestionType="" + feedbackQuestionType
                + "", giver="" + giver + "", recipient="" + recipient
                + "", answer="" + responseMetaData + ""]"";
    }

    @Override
    public String getJsonString() {
        return JsonUtils.toJson(this, FeedbackResponseAttributes.class);
    }

    @Override
    public void sanitizeForSaving() {
        // nothing to sanitize before saving
    }

    /**
     * Converts the given Feedback*ResponseDetails object to JSON for storing.
     */
    public void setResponseDetails(FeedbackResponseDetails responseDetails) {
        if (responseDetails == null) {
            // There was error extracting response data from http request
            responseMetaData = new Text("""");
        } else if (responseDetails.questionType == FeedbackQuestionType.TEXT) {
            // For Text questions, the answer simply contains the response text, not a JSON
            // This is due to legacy data in the data store before there were multiple question types
            responseMetaData = new Text(responseDetails.getAnswerString());
        } else {
            responseMetaData = new Text(JsonUtils.toJson(responseDetails, getFeedbackResponseDetailsClass()));
        }
    }

    /**
     * Retrieves the Feedback*ResponseDetails object for this response.
     * @return The Feedback*ResponseDetails object representing the response's details
     */
    public FeedbackResponseDetails getResponseDetails() {

        if (isMissingResponse()) {
            return null;
        }

        Class<? extends FeedbackResponseDetails> responseDetailsClass = getFeedbackResponseDetailsClass();

        if (responseDetailsClass == FeedbackTextResponseDetails.class) {
            // For Text questions, the questionText simply contains the question, not a JSON
            // This is due to legacy data in the data store before there are multiple question types
            return new FeedbackTextResponseDetails(responseMetaData.getValue());
        }
        return JsonUtils.fromJson(responseMetaData.getValue(), responseDetailsClass);
    }

    /** This method gets the appropriate class type for the Feedback*ResponseDetails object
     * for this response.
     * @return The Feedback*ResponseDetails class type appropriate for this response.
     */
    private Class<? extends FeedbackResponseDetails> getFeedbackResponseDetailsClass() {
        return feedbackQuestionType.getResponseDetailsClass();
    }

    /**
     * Checks if this object represents a missing response.
     * A missing response should never be written to the database.
     * It should only be used as a representation.
     */
    public boolean isMissingResponse() {
        return responseMetaData == null;
    }

    public static void sortFeedbackResponses(List<FeedbackResponseAttributes> frs) {
        Collections.sort(frs, new Comparator<FeedbackResponseAttributes>() {
            @Override
            public int compare(FeedbackResponseAttributes fr1, FeedbackResponseAttributes fr2) {
                return fr1.getId().compareTo(fr2.getId());
            }
        });
    }

}
"
FeedbackResponseCommentAttributes.java,data-transfer,"package teammates.common.datatransfer.attributes;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.Date;
import java.util.List;

import com.google.appengine.api.datastore.Text;

import teammates.common.datatransfer.FeedbackParticipantType;
import teammates.common.util.Const;
import teammates.common.util.FieldValidator;
import teammates.common.util.JsonUtils;
import teammates.common.util.SanitizationHelper;
import teammates.storage.entity.FeedbackResponseComment;

/**
 * Represents a data transfer object for {@link FeedbackResponseComment} entities.
 */
public class FeedbackResponseCommentAttributes extends EntityAttributes<FeedbackResponseComment> {

    public String courseId;
    public String feedbackSessionName;
    public String feedbackQuestionId;
    public String giverEmail;
    /* Response giver section */
    public String giverSection;
    /* Response receiver section */
    public String receiverSection;
    public String feedbackResponseId;
    public List<FeedbackParticipantType> showCommentTo;
    public List<FeedbackParticipantType> showGiverNameTo;
    public boolean isVisibilityFollowingFeedbackQuestion;
    public Date createdAt;
    public Text commentText;
    public String lastEditorEmail;
    public Date lastEditedAt;
    private Long feedbackResponseCommentId;

    public FeedbackResponseCommentAttributes() {
        this.feedbackResponseCommentId = null;
        this.courseId = null;
        this.feedbackSessionName = null;
        this.feedbackQuestionId = null;
        this.giverEmail = null;
        this.feedbackResponseId = null;
        this.createdAt = null;
        this.commentText = null;
        this.giverSection = ""None"";
        this.receiverSection = ""None"";
        this.showCommentTo = new ArrayList<>();
        this.showGiverNameTo = new ArrayList<>();
        this.lastEditorEmail = null;
        this.lastEditedAt = null;
    }

    public FeedbackResponseCommentAttributes(String courseId, String feedbackSessionName, String feedbackQuestionId,
            String giverEmail, String feedbackResponseId, Date createdAt, Text commentText) {
        this(courseId, feedbackSessionName, feedbackQuestionId, giverEmail,
                feedbackResponseId, createdAt, commentText, ""None"", ""None"");
    }

    public FeedbackResponseCommentAttributes(String courseId, String feedbackSessionName, String feedbackQuestionId,
            String giverEmail, String feedbackResponseId, Date createdAt, Text commentText,
            String giverSection, String receiverSection) {
        this.feedbackResponseCommentId = null; //Auto generated by GAE
        this.courseId = courseId;
        this.feedbackSessionName = feedbackSessionName;
        this.feedbackQuestionId = feedbackQuestionId;
        this.giverEmail = giverEmail;
        this.feedbackResponseId = feedbackResponseId;
        this.createdAt = createdAt;
        this.commentText = SanitizationHelper.sanitizeForRichText(commentText);
        this.giverSection = giverSection;
        this.receiverSection = receiverSection;
        this.showCommentTo = new ArrayList<>();
        this.showGiverNameTo = new ArrayList<>();
        this.lastEditorEmail = giverEmail;
        this.lastEditedAt = createdAt;
    }

    public FeedbackResponseCommentAttributes(String courseId, String feedbackSessionName,
            String feedbackQuestionId, String feedbackResponseId) {
        this.courseId = courseId;
        this.feedbackSessionName = feedbackSessionName;
        this.feedbackQuestionId = feedbackQuestionId;
        this.feedbackResponseId = feedbackResponseId;
    }

    public FeedbackResponseCommentAttributes(FeedbackResponseComment comment) {
        this.feedbackResponseCommentId = comment.getFeedbackResponseCommentId();
        this.courseId = comment.getCourseId();
        this.feedbackSessionName = comment.getFeedbackSessionName();
        this.feedbackQuestionId = comment.getFeedbackQuestionId();
        this.giverEmail = comment.getGiverEmail();
        this.feedbackResponseId = comment.getFeedbackResponseId();
        this.createdAt = comment.getCreatedAt();
        this.commentText = comment.getCommentText();
        this.giverSection = comment.getGiverSection() == null ? ""None"" : comment.getGiverSection();
        this.receiverSection = comment.getReceiverSection() == null ? ""None"" : comment.getReceiverSection();
        this.lastEditorEmail = comment.getLastEditorEmail() == null ? comment.getGiverEmail()
                                                                    : comment.getLastEditorEmail();
        this.lastEditedAt = comment.getLastEditedAt() == null ? comment.getCreatedAt() : comment.getLastEditedAt();

        if (comment.getIsVisibilityFollowingFeedbackQuestion() == null
                                        || comment.getIsVisibilityFollowingFeedbackQuestion()) {
            setDefaultVisibilityOptions();
        } else {
            this.showCommentTo = comment.getShowCommentTo();
            this.showGiverNameTo = comment.getShowGiverNameTo();
        }
    }

    private void setDefaultVisibilityOptions() {
        isVisibilityFollowingFeedbackQuestion = true;
        this.showCommentTo = new ArrayList<>();
        this.showGiverNameTo = new ArrayList<>();
    }

    public boolean isVisibleTo(FeedbackParticipantType viewerType) {
        return showCommentTo.contains(viewerType);
    }

    public Long getId() {
        return feedbackResponseCommentId;
    }

    /**
     * Use only to match existing and known Comment.
     */
    public void setId(Long id) {
        this.feedbackResponseCommentId = id;
    }

    @Override
    public List<String> getInvalidityInfo() {
        FieldValidator validator = new FieldValidator();
        List<String> errors = new ArrayList<>();

        addNonEmptyError(validator.getInvalidityInfoForCourseId(courseId), errors);

        addNonEmptyError(validator.getInvalidityInfoForFeedbackSessionName(feedbackSessionName), errors);

        addNonEmptyError(validator.getInvalidityInfoForEmail(giverEmail), errors);

        //TODO: handle the new attributes showCommentTo and showGiverNameTo

        return errors;
    }

    @Override
    public FeedbackResponseComment toEntity() {
        return new FeedbackResponseComment(courseId, feedbackSessionName, feedbackQuestionId, giverEmail,
                feedbackResponseId, createdAt, commentText, giverSection, receiverSection,
                showCommentTo, showGiverNameTo, lastEditorEmail, lastEditedAt);
    }

    @Override
    public String getIdentificationString() {
        return toString();
    }

    @Override
    public String getEntityTypeAsString() {
        return ""FeedbackResponseComment"";
    }

    @Override
    public String getBackupIdentifier() {
        return Const.SystemParams.COURSE_BACKUP_LOG_MSG + courseId;
    }

    @Override
    public String getJsonString() {
        return JsonUtils.toJson(this, FeedbackResponseCommentAttributes.class);
    }

    @Override
    public void sanitizeForSaving() {
        this.commentText = SanitizationHelper.sanitizeForRichText(this.commentText);
    }

    @Override
    public String toString() {
        //TODO: print visibilityOptions also
        return ""FeedbackResponseCommentAttributes [""
                + ""feedbackResponseCommentId = "" + feedbackResponseCommentId
                + "", courseId = "" + courseId
                + "", feedbackSessionName = "" + feedbackSessionName
                + "", feedbackQuestionId = "" + feedbackQuestionId
                + "", giverEmail = "" + giverEmail
                + "", feedbackResponseId = "" + feedbackResponseId
                + "", commentText = "" + commentText.getValue()
                + "", createdAt = "" + createdAt
                + "", lastEditorEmail = "" + lastEditorEmail
                + "", lastEditedAt = "" + lastEditedAt + ""]"";
    }

    public static void sortFeedbackResponseCommentsByCreationTime(List<FeedbackResponseCommentAttributes> frcs) {
        Collections.sort(frcs, new Comparator<FeedbackResponseCommentAttributes>() {
            @Override
            public int compare(FeedbackResponseCommentAttributes frc1, FeedbackResponseCommentAttributes frc2) {
                return frc1.createdAt.compareTo(frc2.createdAt);
            }
        });
    }
}
"
FeedbackSessionAttributes.java,data-transfer,"package teammates.common.datatransfer.attributes;

import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collections;
import java.util.Comparator;
import java.util.Date;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.TimeZone;

import com.google.appengine.api.datastore.Text;

import teammates.common.datatransfer.FeedbackSessionType;
import teammates.common.util.Const;
import teammates.common.util.FieldValidator;
import teammates.common.util.JsonUtils;
import teammates.common.util.SanitizationHelper;
import teammates.common.util.TimeHelper;
import teammates.storage.entity.FeedbackSession;

public class FeedbackSessionAttributes extends EntityAttributes<FeedbackSession> implements SessionAttributes {
    private String feedbackSessionName;
    private String courseId;
    private String creatorEmail;
    private Text instructions;
    private Date createdTime;
    private Date startTime;
    private Date endTime;
    private Date sessionVisibleFromTime;
    private Date resultsVisibleFromTime;
    private double timeZone;
    private int gracePeriod;
    private FeedbackSessionType feedbackSessionType;
    private boolean sentOpenEmail;
    private boolean sentClosingEmail;
    private boolean sentClosedEmail;
    private boolean sentPublishedEmail;
    private boolean isOpeningEmailEnabled;
    private boolean isClosingEmailEnabled;
    private boolean isPublishedEmailEnabled;
    private transient Set<String> respondingInstructorList;
    private transient Set<String> respondingStudentList;

    public FeedbackSessionAttributes() {
        this.isOpeningEmailEnabled = true;
        this.isClosingEmailEnabled = true;
        this.isPublishedEmailEnabled = true;
        this.respondingInstructorList = new HashSet<>();
        this.respondingStudentList = new HashSet<>();
    }

    public FeedbackSessionAttributes(FeedbackSession fs) {
        this.feedbackSessionName = fs.getFeedbackSessionName();
        this.courseId = fs.getCourseId();
        this.creatorEmail = fs.getCreatorEmail();
        this.instructions = fs.getInstructions();
        this.createdTime = fs.getCreatedTime();
        this.startTime = fs.getStartTime();
        this.endTime = fs.getEndTime();
        this.sessionVisibleFromTime = fs.getSessionVisibleFromTime();
        this.resultsVisibleFromTime = fs.getResultsVisibleFromTime();
        this.timeZone = fs.getTimeZone();
        this.gracePeriod = fs.getGracePeriod();
        this.feedbackSessionType = fs.getFeedbackSessionType();
        this.sentOpenEmail = fs.isSentOpenEmail();
        this.sentClosingEmail = fs.isSentClosingEmail();
        this.sentClosedEmail = fs.isSentClosedEmail();
        this.sentPublishedEmail = fs.isSentPublishedEmail();
        this.isOpeningEmailEnabled = fs.isOpeningEmailEnabled();
        this.isClosingEmailEnabled = fs.isClosingEmailEnabled();
        this.isPublishedEmailEnabled = fs.isPublishedEmailEnabled();
        this.respondingInstructorList = fs.getRespondingInstructorList() == null ? new HashSet<String>()
                                                                                 : fs.getRespondingInstructorList();
        this.respondingStudentList = fs.getRespondingStudentList() == null ? new HashSet<String>()
                                                                           : fs.getRespondingStudentList();
    }

    public FeedbackSessionAttributes(String feedbackSessionName, String courseId, String creatorId,
                                     Text instructions, Date createdTime, Date startTime, Date endTime,
                                     Date sessionVisibleFromTime, Date resultsVisibleFromTime,
                                     double timeZone, int gracePeriod, FeedbackSessionType feedbackSessionType,
                                     boolean sentOpenEmail, boolean sentClosingEmail,
                                     boolean sentClosedEmail, boolean sentPublishedEmail,
                                     boolean isOpeningEmailEnabled, boolean isClosingEmailEnabled,
                                     boolean isPublishedEmailEnabled) {
        this(feedbackSessionName, courseId, creatorId, instructions, createdTime, startTime, endTime,
             sessionVisibleFromTime, resultsVisibleFromTime, timeZone, gracePeriod, feedbackSessionType,
             sentOpenEmail, sentClosingEmail, sentClosedEmail, sentPublishedEmail, isOpeningEmailEnabled,
             isClosingEmailEnabled, isPublishedEmailEnabled, new HashSet<String>(), new HashSet<String>());
    }

    public FeedbackSessionAttributes(String feedbackSessionName, String courseId, String creatorId,
                                     Text instructions, Date createdTime, Date startTime, Date endTime,
                                     Date sessionVisibleFromTime, Date resultsVisibleFromTime,
                                     double timeZone, int gracePeriod, FeedbackSessionType feedbackSessionType,
                                     boolean sentOpenEmail, boolean sentClosingEmail,
                                     boolean sentClosedEmail, boolean sentPublishedEmail,
                                     boolean isOpeningEmailEnabled, boolean isClosingEmailEnabled,
                                     boolean isPublishedEmailEnabled, Set<String> instructorList,
                                     Set<String> studentList) {

        this.feedbackSessionName = feedbackSessionName;
        this.courseId = courseId;
        this.creatorEmail = creatorId;
        this.instructions = SanitizationHelper.sanitizeForRichText(instructions);
        this.createdTime = createdTime;
        this.startTime = startTime;
        this.endTime = endTime;
        this.sessionVisibleFromTime = sessionVisibleFromTime;
        this.resultsVisibleFromTime = resultsVisibleFromTime;
        this.timeZone = timeZone;
        this.gracePeriod = gracePeriod;
        this.feedbackSessionType = feedbackSessionType;
        this.sentOpenEmail = sentOpenEmail;
        this.sentClosingEmail = sentClosingEmail;
        this.sentClosedEmail = sentClosedEmail;
        this.sentPublishedEmail = sentPublishedEmail;
        this.isOpeningEmailEnabled = isOpeningEmailEnabled;
        this.isClosingEmailEnabled = isClosingEmailEnabled;
        this.isPublishedEmailEnabled = isPublishedEmailEnabled;
        this.respondingInstructorList = instructorList;
        this.respondingStudentList = studentList;
    }

    private FeedbackSessionAttributes(FeedbackSessionAttributes other) {
        this(other.feedbackSessionName, other.courseId, other.creatorEmail,
            other.instructions, other.createdTime, other.startTime, other.endTime,
            other.sessionVisibleFromTime, other.resultsVisibleFromTime, other.timeZone,
            other.gracePeriod, other.feedbackSessionType,
            other.sentOpenEmail, other.sentClosingEmail, other.sentClosedEmail, other.sentPublishedEmail,
            other.isOpeningEmailEnabled, other.isClosingEmailEnabled,
            other.isPublishedEmailEnabled, other.respondingInstructorList,
            other.respondingStudentList);
    }

    public FeedbackSessionAttributes getCopy() {
        return new FeedbackSessionAttributes(this);
    }

    public String getCourseId() {
        return courseId;
    }

    public String getFeedbackSessionName() {
        return feedbackSessionName;
    }

    public String getStartTimeString() {
        if (startTime == null) {
            return ""-"";
        }
        Date startTimeInUtc = TimeHelper.convertLocalDateToUtc(startTime, timeZone);
        return TimeHelper.formatDateTimeForSessions(startTimeInUtc, timeZone);
    }

    public String getEndTimeString() {
        if (endTime == null) {
            return ""-"";
        }
        Date endTimeInUtc = TimeHelper.convertLocalDateToUtc(endTime, timeZone);
        return TimeHelper.formatDateTimeForSessions(endTimeInUtc, timeZone);
    }

    public String getInstructionsString() {
        return SanitizationHelper.sanitizeForRichText(instructions.getValue());
    }

    @Override
    public FeedbackSession toEntity() {
        return new FeedbackSession(feedbackSessionName, courseId, creatorEmail, instructions, createdTime,
                                   startTime, endTime, sessionVisibleFromTime, resultsVisibleFromTime,
                                   timeZone, gracePeriod, feedbackSessionType, sentOpenEmail,
                                   sentClosingEmail, sentClosedEmail, sentPublishedEmail,
                                   isOpeningEmailEnabled, isClosingEmailEnabled, isPublishedEmailEnabled,
                                   respondingInstructorList, respondingStudentList);
    }

    @Override
    public String getIdentificationString() {
        return this.feedbackSessionName + ""/"" + this.courseId;
    }

    @Override
    public String getEntityTypeAsString() {
        return ""Feedback Session"";
    }

    @Override
    public String getBackupIdentifier() {
        return Const.SystemParams.COURSE_BACKUP_LOG_MSG + courseId;
    }

    @Override
    public String getJsonString() {
        return JsonUtils.toJson(this, FeedbackSessionAttributes.class);
    }

    @Override
    public List<String> getInvalidityInfo() {
        FieldValidator validator = new FieldValidator();
        List<String> errors = new ArrayList<>();

        // Check for null fields.

        addNonEmptyError(validator.getValidityInfoForNonNullField(
                FieldValidator.FEEDBACK_SESSION_NAME_FIELD_NAME, feedbackSessionName), errors);

        addNonEmptyError(validator.getValidityInfoForNonNullField(FieldValidator.COURSE_ID_FIELD_NAME, courseId), errors);

        addNonEmptyError(validator.getValidityInfoForNonNullField(""instructions to students"", instructions), errors);

        addNonEmptyError(validator.getValidityInfoForNonNullField(
                ""time for the session to become visible"", sessionVisibleFromTime), errors);

        addNonEmptyError(validator.getValidityInfoForNonNullField(""creator's email"", creatorEmail), errors);

        addNonEmptyError(validator.getValidityInfoForNonNullField(""session creation time"", createdTime), errors);

        // Early return if any null fields
        if (!errors.isEmpty()) {
            return errors;
        }

        addNonEmptyError(validator.getInvalidityInfoForFeedbackSessionName(feedbackSessionName), errors);

        addNonEmptyError(validator.getInvalidityInfoForCourseId(courseId), errors);

        addNonEmptyError(validator.getInvalidityInfoForEmail(creatorEmail), errors);

        // Skip time frame checks if session type is private.
        if (this.isPrivateSession()) {
            return errors;
        }

        addNonEmptyError(validator.getValidityInfoForNonNullField(""submission opening time"", startTime), errors);

        addNonEmptyError(validator.getValidityInfoForNonNullField(""submission closing time"", endTime), errors);

        addNonEmptyError(validator.getValidityInfoForNonNullField(
                ""time for the responses to become visible"", resultsVisibleFromTime), errors);

        // Early return if any null fields
        if (!errors.isEmpty()) {
            return errors;
        }

        addNonEmptyError(validator.getInvalidityInfoForTimeForSessionStartAndEnd(startTime, endTime), errors);

        addNonEmptyError(validator.getInvalidityInfoForTimeForVisibilityStartAndSessionStart(
                sessionVisibleFromTime, startTime), errors);

        Date actualSessionVisibleFromTime = sessionVisibleFromTime;

        if (actualSessionVisibleFromTime.equals(Const.TIME_REPRESENTS_FOLLOW_OPENING)) {
            actualSessionVisibleFromTime = startTime;
        }

        addNonEmptyError(validator.getInvalidityInfoForTimeForVisibilityStartAndResultsPublish(
                actualSessionVisibleFromTime, resultsVisibleFromTime), errors);

        return errors;
    }

    @Override
    public boolean isValid() {
        return getInvalidityInfo().isEmpty();
    }

    public boolean isClosedAfter(int hours) {
        Calendar now = Calendar.getInstance(TimeZone.getTimeZone(""UTC""));
        // Fix the time zone accordingly
        now.add(Calendar.MILLISECOND, (int) (60 * 60 * 1000 * timeZone));

        Calendar start = Calendar.getInstance(TimeZone.getTimeZone(""UTC""));
        start.setTime(startTime);

        Calendar deadline = Calendar.getInstance(TimeZone.getTimeZone(""UTC""));
        deadline.setTime(endTime);

        long nowMillis = now.getTimeInMillis();
        long deadlineMillis = deadline.getTimeInMillis();
        long differenceBetweenDeadlineAndNow = (deadlineMillis - nowMillis) / (60 * 60 * 1000);

        return now.after(start) && differenceBetweenDeadlineAndNow < hours;
    }

    public boolean isClosingWithinTimeLimit(int hours) {
        Calendar now = Calendar.getInstance(TimeZone.getTimeZone(""UTC""));
        // Fix the time zone accordingly
        now.add(Calendar.MILLISECOND,
                (int) (60 * 60 * 1000 * timeZone));

        Calendar start = Calendar.getInstance(TimeZone.getTimeZone(""UTC""));
        start.setTime(startTime);

        Calendar deadline = Calendar.getInstance(TimeZone.getTimeZone(""UTC""));
        deadline.setTime(endTime);

        long nowMillis = now.getTimeInMillis();
        long deadlineMillis = deadline.getTimeInMillis();
        long differenceBetweenDeadlineAndNow = (deadlineMillis - nowMillis) / (60 * 60 * 1000);

        // If now and start are almost similar, it means the feedback session
        // is open for only 24 hours.
        // Hence we do not send a reminder e-mail for feedback session.
        return now.after(start)
               && differenceBetweenDeadlineAndNow >= hours - 1
               && differenceBetweenDeadlineAndNow < hours;
    }

    /**
     * Returns true if the session is closed within the past hour of calling this function.
     */
    public boolean isClosedWithinPastHour() {
        long timeZoneOffset = (long) timeZone * 60 * 60 * 1000;
        Date date = new Date(endTime.getTime() + gracePeriod * 60000L - timeZoneOffset);
        return TimeHelper.isWithinPastHourFromNow(date);
    }

    /**
     * Returns {@code true} if it is after the closing time of this feedback session; {@code false} if not.
     */
    public boolean isClosed() {
        Calendar now = TimeHelper.now(timeZone);
        Calendar end = TimeHelper.dateToCalendar(endTime);
        end.add(Calendar.MINUTE, gracePeriod);

        return now.after(end);
    }

    /**
     * Returns true if the session is currently open and accepting responses.
     */
    public boolean isOpened() {
        Calendar now = TimeHelper.now(timeZone);
        Calendar start = TimeHelper.dateToCalendar(startTime);
        Calendar end = TimeHelper.dateToCalendar(endTime);

        return now.after(start) && now.before(end);
    }

    /**
     * Returns true if the session is currently close but is still accept responses.
     */
    public boolean isInGracePeriod() {
        Calendar now = TimeHelper.now(timeZone);
        Calendar end = TimeHelper.dateToCalendar(endTime);
        Calendar gracedEnd = TimeHelper.dateToCalendar(endTime);
        gracedEnd.add(Calendar.MINUTE, gracePeriod);

        return now.after(end) && now.before(gracedEnd);
    }

    /**
     * Returns {@code true} has not opened before and is waiting to open,
     * {@code false} if session has opened before.
     */
    public boolean isWaitingToOpen() {
        Calendar now = TimeHelper.now(timeZone);
        Calendar start = TimeHelper.dateToCalendar(startTime);

        return now.before(start);
    }

    /**
     * Returns {@code true} if the session is visible; {@code false} if not.
     *         Does not care if the session has started or not.
     */
    public boolean isVisible() {
        Date visibleTime = this.sessionVisibleFromTime;

        if (visibleTime.equals(Const.TIME_REPRESENTS_FOLLOW_OPENING)) {
            visibleTime = this.startTime;
        } else if (visibleTime.equals(Const.TIME_REPRESENTS_NEVER)) {
            return false;
        }

        Date now = TimeHelper.now(timeZone).getTime();
        return visibleTime.before(now);
    }

    /**
     * Returns {@code true} if the results of the feedback session is visible; {@code false} if not.
     *         Does not care if the session has ended or not.
     */
    public boolean isPublished() {
        Date now = TimeHelper.now(timeZone).getTime();
        Date publishTime = this.resultsVisibleFromTime;

        if (publishTime.equals(Const.TIME_REPRESENTS_FOLLOW_VISIBLE)) {
            return isVisible();
        } else if (publishTime.equals(Const.TIME_REPRESENTS_LATER)) {
            return false;
        } else if (publishTime.equals(Const.TIME_REPRESENTS_NEVER)) {
            return false;
        } else if (publishTime.equals(Const.TIME_REPRESENTS_NOW)) {
            return true;
        } else {
            return publishTime.before(now);
        }
    }

    /**
     * Returns {@code true} if the session has been set by the creator to be manually published.
     */
    public boolean isManuallyPublished() {
        return resultsVisibleFromTime.equals(Const.TIME_REPRESENTS_LATER)
               || resultsVisibleFromTime.equals(Const.TIME_REPRESENTS_NOW);
    }

    /**
     * Returns {@code true} if session is a private session (only open to the session creator),
     *  {@code false} if not.
     */
    public boolean isPrivateSession() {
        return sessionVisibleFromTime.equals(Const.TIME_REPRESENTS_NEVER)
               || feedbackSessionType.equals(FeedbackSessionType.PRIVATE);
    }

    public boolean isCreator(String instructorEmail) {
        return creatorEmail.equals(instructorEmail);
    }

    @Override
    public void sanitizeForSaving() {
        this.instructions = SanitizationHelper.sanitizeForRichText(instructions);
    }

    @Override
    public String toString() {
        return ""FeedbackSessionAttributes [feedbackSessionName=""
               + feedbackSessionName + "", courseId="" + courseId
               + "", creatorEmail="" + creatorEmail + "", instructions="" + instructions
               + "", startTime="" + startTime
               + "", endTime="" + endTime + "", sessionVisibleFromTime=""
               + sessionVisibleFromTime + "", resultsVisibleFromTime=""
               + resultsVisibleFromTime + "", timeZone="" + timeZone
               + "", gracePeriod="" + gracePeriod + "", feedbackSessionType=""
               + feedbackSessionType + "", sentOpenEmail="" + sentOpenEmail
               + "", sentPublishedEmail="" + sentPublishedEmail
               + "", isOpeningEmailEnabled="" + isOpeningEmailEnabled
               + "", isClosingEmailEnabled="" + isClosingEmailEnabled
               + "", isPublishedEmailEnabled="" + isPublishedEmailEnabled + ""]"";
    }

    /**
     * Sorts feedback session based courseID (ascending), then by create time (ascending), deadline
     * (ascending), then by start time (ascending), then by feedback session name
     * (ascending). The sort by CourseID part is to cater the case when this
     * method is called with combined feedback sessions from many courses
     */
    public static void sortFeedbackSessionsByCreationTime(List<FeedbackSessionAttributes> sessions) {
        Collections.sort(sessions, new Comparator<FeedbackSessionAttributes>() {
            @Override
            public int compare(FeedbackSessionAttributes session1, FeedbackSessionAttributes session2) {
                int result = session1.courseId.compareTo(session2.courseId);

                if (result == 0) {
                    result = session1.createdTime.compareTo(session2.createdTime);
                }

                if (result == 0) {
                    result = session1.endTime.compareTo(session2.endTime);
                }

                if (result == 0) {
                    result = session1.startTime.compareTo(session2.startTime);
                }

                if (result == 0) {
                    result = session1.feedbackSessionName.compareTo(session2.feedbackSessionName);
                }

                return result;
            }
        });
    }

    /**
     * Sorts feedback session based on create time (descending), deadline
     * (descending), then by start time (descending),then by courseID (ascending),then by feedback session name
     * (ascending). The sort by CourseID part is to cater the case when this
     * method is called with combined feedback sessions from many courses
     */
    public static void sortFeedbackSessionsByCreationTimeDescending(List<FeedbackSessionAttributes> sessions) {
        Collections.sort(sessions, new Comparator<FeedbackSessionAttributes>() {
            @Override
            public int compare(FeedbackSessionAttributes session1, FeedbackSessionAttributes session2) {
                int result = session2.createdTime.compareTo(session1.createdTime);
                if (result == 0) {
                    if (session1.endTime == null || session2.endTime == null) {
                        if (session1.endTime == null) {
                            --result;
                        }
                        if (session2.endTime == null) {
                            ++result;
                        }
                    } else {
                        result = session2.endTime.compareTo(session1.endTime);
                    }
                }

                if (result == 0) {
                    result = session2.startTime.compareTo(session1.startTime);
                }
                if (result == 0) {
                    result = session1.courseId.compareTo(session2.courseId);
                }

                if (result == 0) {
                    result = session1.feedbackSessionName.compareTo(session2.feedbackSessionName);
                }

                return result;
            }
        });
    }

    @Override
    public Date getSessionStartTime() {
        return this.startTime;
    }

    @Override
    public Date getSessionEndTime() {
        return this.endTime;
    }

    @Override
    public String getSessionName() {
        return this.feedbackSessionName;
    }

    public void setFeedbackSessionName(String feedbackSessionName) {
        this.feedbackSessionName = feedbackSessionName;
    }

    public void setCourseId(String courseId) {
        this.courseId = courseId;
    }

    public String getCreatorEmail() {
        return creatorEmail;
    }

    public void setCreatorEmail(String creatorEmail) {
        this.creatorEmail = creatorEmail;
    }

    public Text getInstructions() {
        return instructions;
    }

    public void setInstructions(Text instructions) {
        this.instructions = instructions;
    }

    public Date getCreatedTime() {
        return createdTime;
    }

    public void setCreatedTime(Date createdTime) {
        this.createdTime = createdTime;
    }

    public Date getStartTime() {
        return startTime;
    }

    public void setStartTime(Date startTime) {
        this.startTime = startTime;
    }

    public Date getEndTime() {
        return endTime;
    }

    public void setEndTime(Date endTime) {
        this.endTime = endTime;
    }

    public Date getSessionVisibleFromTime() {
        return sessionVisibleFromTime;
    }

    public void setSessionVisibleFromTime(Date sessionVisibleFromTime) {
        this.sessionVisibleFromTime = sessionVisibleFromTime;
    }

    public Date getResultsVisibleFromTime() {
        return resultsVisibleFromTime;
    }

    public void setResultsVisibleFromTime(Date resultsVisibleFromTime) {
        this.resultsVisibleFromTime = resultsVisibleFromTime;
    }

    public double getTimeZone() {
        return timeZone;
    }

    public void setTimeZone(double timeZone) {
        this.timeZone = timeZone;
    }

    public int getGracePeriod() {
        return gracePeriod;
    }

    public void setGracePeriod(int gracePeriod) {
        this.gracePeriod = gracePeriod;
    }

    public FeedbackSessionType getFeedbackSessionType() {
        return feedbackSessionType;
    }

    public void setFeedbackSessionType(FeedbackSessionType feedbackSessionType) {
        this.feedbackSessionType = feedbackSessionType;
    }

    public boolean isSentOpenEmail() {
        return sentOpenEmail;
    }

    public void setSentOpenEmail(boolean sentOpenEmail) {
        this.sentOpenEmail = sentOpenEmail;
    }

    public boolean isSentClosingEmail() {
        return sentClosingEmail;
    }

    public void setSentClosingEmail(boolean sentClosingEmail) {
        this.sentClosingEmail = sentClosingEmail;
    }

    public boolean isSentClosedEmail() {
        return sentClosedEmail;
    }

    public void setSentClosedEmail(boolean sentClosedEmail) {
        this.sentClosedEmail = sentClosedEmail;
    }

    public boolean isSentPublishedEmail() {
        return sentPublishedEmail;
    }

    public void setSentPublishedEmail(boolean sentPublishedEmail) {
        this.sentPublishedEmail = sentPublishedEmail;
    }

    public boolean isOpeningEmailEnabled() {
        return isOpeningEmailEnabled;
    }

    public void setOpeningEmailEnabled(boolean isOpeningEmailEnabled) {
        this.isOpeningEmailEnabled = isOpeningEmailEnabled;
    }

    public boolean isClosingEmailEnabled() {
        return isClosingEmailEnabled;
    }

    public void setClosingEmailEnabled(boolean isClosingEmailEnabled) {
        this.isClosingEmailEnabled = isClosingEmailEnabled;
    }

    public boolean isPublishedEmailEnabled() {
        return isPublishedEmailEnabled;
    }

    public void setPublishedEmailEnabled(boolean isPublishedEmailEnabled) {
        this.isPublishedEmailEnabled = isPublishedEmailEnabled;
    }

    public Set<String> getRespondingInstructorList() {
        return respondingInstructorList;
    }

    public void setRespondingInstructorList(Set<String> respondingInstructorList) {
        this.respondingInstructorList = respondingInstructorList;
    }

    public Set<String> getRespondingStudentList() {
        return respondingStudentList;
    }

    public void setRespondingStudentList(Set<String> respondingStudentList) {
        this.respondingStudentList = respondingStudentList;
    }

    public String getEndTimeInIso8601Format() {
        Date endTimeInUtc = TimeHelper.convertLocalDateToUtc(endTime, timeZone);
        return TimeHelper.formatDateToIso8601Utc(endTimeInUtc);
    }
}
"
InstructorAttributes.java,data-transfer,"package teammates.common.datatransfer.attributes;

import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;

import teammates.common.datatransfer.InstructorPrivileges;
import teammates.common.util.Const;
import teammates.common.util.FieldValidator;
import teammates.common.util.JsonUtils;
import teammates.common.util.SanitizationHelper;
import teammates.storage.entity.Instructor;

/**
 * The data transfer class for Instructor entities.
 */
public class InstructorAttributes extends EntityAttributes<Instructor> {

    public static final String DEFAULT_DISPLAY_NAME = ""Instructor"";

    /**
     * Sorts the Instructors list alphabetically by name.
     */
    public static Comparator<InstructorAttributes> compareByName = new Comparator<InstructorAttributes>() {
        public int compare(InstructorAttributes one, InstructorAttributes other) {
            return one.name.toLowerCase().compareTo(other.name.toLowerCase());
        }
    };

    // Note: be careful when changing these variables as their names are used in *.json files.

    /** Required fields. */
    public String googleId;
    public String courseId;
    public String name;
    public String email;

    /** Optional fields. */
    public String key;
    public String role;
    public String displayedName;
    public Boolean isArchived;
    public boolean isDisplayedToStudents;
    public InstructorPrivileges privileges;

    /**
     * Return new builder instance with default values for optional fields.
     *
     * <p>Following default values are set to corresponding attributes:
     * {@code isArchived = false} <br>
     * {@code isDisplayedForStudents = true} <br>
     * {@code displayedName = DEFAULT_DISPLAYED_NAME} <br>
     * {@code role = INSTRUCTOR_PERMISSION_ROLE_COOWNER} <br>
     * {@code privileges = new InstructorPrivileges(role)} <br>
     */
    public static Builder builder(String googleId, String courseId, String name, String email) {
        return new Builder(googleId, courseId, name, email);
    }

    public static InstructorAttributes valueOf(Instructor instructor) {
        instructor.setGeneratedKeyIfNull();

        return builder(instructor.getGoogleId(), instructor.getCourseId(), instructor.getName(), instructor.getEmail())
                .withKey(instructor.getRegistrationKey())
                .withRole(instructor.getRole())
                .withDisplayedName(instructor.getDisplayedName())
                .withPrivileges(instructor.getInstructorPrivilegesAsText())
                .withIsDisplayedToStudents(instructor.isDisplayedToStudents())
                .withIsArchived(instructor.getIsArchived())
                .build();
    }

    public InstructorAttributes getCopy() {
        return builder(googleId, courseId, name, email)
                .withKey(key).withRole(role).withDisplayedName(displayedName)
                .withPrivileges(privileges).withIsDisplayedToStudents(isDisplayedToStudents).withIsArchived(isArchived)
                .build();
    }

    public String getTextFromInstructorPrivileges() {
        return JsonUtils.toJson(privileges, InstructorPrivileges.class);
    }

    public String getName() {
        return name;
    }

    public String getDisplayedName() {
        return displayedName;
    }

    public String getEmail() {
        return email;
    }

    public boolean isDisplayedToStudents() {
        return isDisplayedToStudents;
    }

    public boolean isRegistered() {
        return googleId != null;
    }

    @Override
    public Instructor toEntity() {
        if (key != null) {
            return new Instructor(googleId, courseId, isArchived, name, email, key, role,
                                  isDisplayedToStudents, displayedName, getTextFromInstructorPrivileges());
        }
        return new Instructor(googleId, courseId, isArchived, name, email, role,
                              isDisplayedToStudents, displayedName, getTextFromInstructorPrivileges());
    }

    @Override
    public List<String> getInvalidityInfo() {
        FieldValidator validator = new FieldValidator();
        List<String> errors = new ArrayList<>();

        if (googleId != null) {
            addNonEmptyError(validator.getInvalidityInfoForGoogleId(googleId), errors);
        }

        addNonEmptyError(validator.getInvalidityInfoForCourseId(courseId), errors);

        addNonEmptyError(validator.getInvalidityInfoForPersonName(name), errors);

        addNonEmptyError(validator.getInvalidityInfoForEmail(email), errors);

        addNonEmptyError(validator.getInvalidityInfoForPersonName(displayedName), errors);

        addNonEmptyError(validator.getInvalidityInfoForRole(role), errors);

        return errors;
    }

    @Override
    public String toString() {
        return JsonUtils.toJson(this, InstructorAttributes.class);
    }

    @Override
    public String getIdentificationString() {
        return courseId + ""/"" + email;
    }

    @Override
    public String getEntityTypeAsString() {
        return ""Instructor"";
    }

    @Override
    public String getBackupIdentifier() {
        return Const.SystemParams.COURSE_BACKUP_LOG_MSG + courseId;
    }

    @Override
    public String getJsonString() {
        return JsonUtils.toJson(this, InstructorAttributes.class);
    }

    @Override
    public void sanitizeForSaving() {
        googleId = SanitizationHelper.sanitizeGoogleId(googleId);
        name = SanitizationHelper.sanitizeForHtml(SanitizationHelper.sanitizeName(name));
        email = SanitizationHelper.sanitizeEmail(email);
        courseId = SanitizationHelper.sanitizeTitle(courseId);

        if (role == null) {
            role = Const.InstructorPermissionRoleNames.INSTRUCTOR_PERMISSION_ROLE_COOWNER;
        } else {
            role = SanitizationHelper.sanitizeForHtml(SanitizationHelper.sanitizeName(role));
        }

        if (displayedName == null) {
            displayedName = Const.InstructorPermissionRoleNames.INSTRUCTOR_PERMISSION_ROLE_COOWNER;
        } else {
            displayedName = SanitizationHelper.sanitizeForHtml(SanitizationHelper.sanitizeName(displayedName));
        }

        if (privileges == null) {
            privileges = new InstructorPrivileges(Const.InstructorPermissionRoleNames.INSTRUCTOR_PERMISSION_ROLE_COOWNER);
        }
    }

    public boolean isAllowedForPrivilege(String privilegeName) {
        if (privileges == null) {
            privileges = new InstructorPrivileges(Const.InstructorPermissionRoleNames.INSTRUCTOR_PERMISSION_ROLE_COOWNER);
        }
        return privileges.isAllowedForPrivilege(privilegeName);
    }

    public boolean isAllowedForPrivilege(String sectionName, String privilegeName) {
        if (privileges == null) {
            privileges = new InstructorPrivileges(Const.InstructorPermissionRoleNames.INSTRUCTOR_PERMISSION_ROLE_COOWNER);
        }
        return privileges.isAllowedForPrivilege(sectionName, privilegeName);
    }

    public boolean isAllowedForPrivilege(String sectionName, String sessionName, String privilegeName) {
        if (privileges == null) {
            privileges = new InstructorPrivileges(Const.InstructorPermissionRoleNames.INSTRUCTOR_PERMISSION_ROLE_COOWNER);
        }
        return privileges.isAllowedForPrivilege(sectionName, sessionName, privilegeName);
    }

    /**
     * Returns true if privilege for session is present for any section.
     */
    public boolean isAllowedForPrivilegeAnySection(String sessionName, String privilegeName) {
        if (privileges == null) {
            privileges = new InstructorPrivileges(Const.InstructorPermissionRoleNames.INSTRUCTOR_PERMISSION_ROLE_COOWNER);
        }
        return privileges.isAllowedForPrivilegeAnySection(sessionName, privilegeName);
    }

    public boolean hasCoownerPrivileges() {
        return privileges.hasCoownerPrivileges();
    }

    public boolean hasManagerPrivileges() {
        return privileges.hasManagerPrivileges();
    }

    public boolean hasObserverPrivileges() {
        return privileges.hasObserverPrivileges();
    }

    public boolean hasTutorPrivileges() {
        return privileges.hasTutorPrivileges();
    }

    /**
     * Returns true if this instructor object is equal with the given {@code instructor} object.
     *
     * @param instructor
     *            the {@link InstructorAttributes} of an instructor, cannot be
     *            {@code null}
     * @return true if this {@link InstructorAttributes} is equal to
     *         {@code instructor}, otherwise false
     */
    public boolean isEqualToAnotherInstructor(InstructorAttributes instructor) {
        // JsonParser is used instead of
        // this.getJsonString().equals(instructor.getJsonString) so that the
        // comparison ignores the order of key-value pairs in the json strings.
        return JsonUtils.parse(getJsonString()).equals(JsonUtils.parse(instructor.getJsonString()));
    }

    public boolean isCustomRole() {
        return Const.InstructorPermissionRoleNames.INSTRUCTOR_PERMISSION_ROLE_CUSTOM.equals(role);
    }

    public String getCourseId() {
        return courseId;
    }

    public String getGoogleId() {
        return googleId;
    }

    public String getRole() {
        return role;
    }

    /**
     * A Builder class for {@link InstructorAttributes}.
     */
    public static class Builder {
        private final InstructorAttributes instructorAttributes;

        public Builder(String googleId, String courseId, String name, String email) {
            instructorAttributes = new InstructorAttributes();

            instructorAttributes.googleId = SanitizationHelper.sanitizeGoogleId(googleId);
            instructorAttributes.courseId = SanitizationHelper.sanitizeTitle(courseId);
            instructorAttributes.name = SanitizationHelper.sanitizeName(name);
            instructorAttributes.email = email;

            instructorAttributes.role = Const.InstructorPermissionRoleNames.INSTRUCTOR_PERMISSION_ROLE_COOWNER;
            instructorAttributes.displayedName = DEFAULT_DISPLAY_NAME;
            instructorAttributes.isArchived = false;
            instructorAttributes.isDisplayedToStudents = true;
            instructorAttributes.privileges = new InstructorPrivileges(instructorAttributes.role);
        }

        public Builder withKey(String key) {
            instructorAttributes.key = key;
            return this;
        }

        public Builder withRole(String role) {
            if (role != null) {
                instructorAttributes.role = SanitizationHelper.sanitizeName(role);
            }

            return this;
        }

        public Builder withDisplayedName(String displayedName) {
            if (displayedName != null) {
                instructorAttributes.displayedName = SanitizationHelper.sanitizeName(displayedName);
            }

            return this;
        }

        public Builder withIsArchived(Boolean isArchived) {
            instructorAttributes.isArchived = isArchived != null && isArchived;
            return this;
        }

        public Builder withIsDisplayedToStudents(boolean isDisplayedToStudents) {
            instructorAttributes.isDisplayedToStudents = isDisplayedToStudents;
            return this;
        }

        public Builder withPrivileges(InstructorPrivileges privileges) {
            instructorAttributes.privileges = (privileges == null)
                    ? new InstructorPrivileges(instructorAttributes.role)
                    : privileges;
            return this;
        }

        public Builder withPrivileges(String privilegesAsText) {
            instructorAttributes.privileges = (privilegesAsText == null)
                    ? new InstructorPrivileges(instructorAttributes.role)
                    : getInstructorPrivilegesFromText(privilegesAsText);
            return this;
        }

        public InstructorAttributes build() {
            return instructorAttributes;
        }

        private static InstructorPrivileges getInstructorPrivilegesFromText(String instructorPrivilegesAsText) {
            return JsonUtils.fromJson(instructorPrivilegesAsText, InstructorPrivileges.class);
        }
    }
}
"
package-info.java,data-transfer,"/**
 * Contains attributes classes as a wrapper for persistable entities.
 */
package teammates.common.datatransfer.attributes;
"
SessionAttributes.java,data-transfer,"package teammates.common.datatransfer.attributes;

import java.util.Comparator;
import java.util.Date;

import teammates.common.util.Assumption;

/**
 * Interface for Sessions, to be used for grouping
 * sessions together and sort them based on common attributes (time and name).
 *
 * <p>Current implementing classes: {@link FeedbackSessionAttributes}
 */
public interface SessionAttributes {

    /**
     * Comparator to sort SessionAttributes on ASCENDING order based on
     * end time, followed by start time and session name.
     */
    Comparator<SessionAttributes> ASCENDING_ORDER = new Comparator<SessionAttributes>() {
        @Override
        public int compare(SessionAttributes session1, SessionAttributes session2) {
            Assumption.assertNotNull(session1.getSessionName());
            Assumption.assertNotNull(session1.getSessionStartTime());
            Assumption.assertNotNull(session1.getSessionEndTime());
            Assumption.assertNotNull(session2.getSessionName());
            Assumption.assertNotNull(session2.getSessionStartTime());
            Assumption.assertNotNull(session2.getSessionEndTime());
            int result = 0;

            //Compares end times
            result = session1.getSessionEndTime().after(session2.getSessionEndTime()) ? 1
                    : session1.getSessionEndTime().before(session2.getSessionEndTime()) ? -1 : 0;

            //If the end time is same, compares start times
            if (result == 0) {
                result = session1.getSessionStartTime().after(session2.getSessionStartTime()) ? 1
                        : session1.getSessionStartTime().before(session2.getSessionStartTime()) ? -1 : 0;
            }

            //if both end and start time is same, compares session name
            if (result == 0) {
                result = session1.getSessionName().compareTo(session2.getSessionName());
            }
            return result;
        }
    };

    /**
     * Comparator to sort SessionAttributes on DESCENDING order based on
     * end time, followed by start time and session name.
     */
    Comparator<SessionAttributes> DESCENDING_ORDER = new Comparator<SessionAttributes>() {
        @Override
        public int compare(SessionAttributes session1, SessionAttributes session2) {
            FeedbackSessionAttributes feedbackSession1 = null;
            FeedbackSessionAttributes feedbackSession2 = null;
            Boolean isSession1PrivateFeedback = false;
            Boolean isSession2PrivateFeedback = false;
            if (session1 instanceof FeedbackSessionAttributes) {
                feedbackSession1 = (FeedbackSessionAttributes) session1;
            }
            if (session2 instanceof FeedbackSessionAttributes) {
                feedbackSession2 = (FeedbackSessionAttributes) session2;
            }

            Assumption.assertNotNull(session1.getSessionName());
            Assumption.assertNotNull(session1.getSessionStartTime());
            if (feedbackSession1 != null && feedbackSession1.isPrivateSession()) {
                isSession1PrivateFeedback = true;
            } else {
                Assumption.assertNotNull(session1.getSessionEndTime());
            }
            Assumption.assertNotNull(session2.getSessionName());
            Assumption.assertNotNull(session2.getSessionStartTime());
            if (feedbackSession2 != null && feedbackSession2.isPrivateSession()) {
                isSession2PrivateFeedback = true;
            } else {
                Assumption.assertNotNull(session2.getSessionEndTime());
            }
            int result = 0;

            //Compares end times
            if (!isSession1PrivateFeedback && !isSession2PrivateFeedback) {
                result = session1.getSessionEndTime().after(session2.getSessionEndTime()) ? -1
                        : session1.getSessionEndTime().before(session2.getSessionEndTime()) ? 1 : 0;
            }

            //If the end time is same, compares start times
            if (result == 0) {
                result = session1.getSessionStartTime().after(session2.getSessionStartTime()) ? -1
                        : session1.getSessionStartTime().before(session2.getSessionStartTime()) ? 1 : 0;
            }

            //if both end and start time is same, compares session name
            if (result == 0) {
                result = session1.getSessionName().compareTo(session2.getSessionName());
            }
            return result;
        }
    };

    Date getSessionStartTime();

    Date getSessionEndTime();

    String getSessionName();

}
"
StudentAttributes.java,data-transfer,"package teammates.common.datatransfer.attributes;

import static teammates.common.util.Const.EOL;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.Date;
import java.util.List;

import teammates.common.datatransfer.StudentUpdateStatus;
import teammates.common.util.Assumption;
import teammates.common.util.Config;
import teammates.common.util.Const;
import teammates.common.util.FieldValidator;
import teammates.common.util.JsonUtils;
import teammates.common.util.SanitizationHelper;
import teammates.common.util.StringHelper;
import teammates.storage.entity.CourseStudent;

public class StudentAttributes extends EntityAttributes<CourseStudent> {

    // Note: be careful when changing these variables as their names are used in *.json files.
    public String googleId;
    public String email;
    public String course;
    public String name;
    public String lastName;
    public String comments;
    public String team;
    public String section;
    public String key;

    public transient StudentUpdateStatus updateStatus = StudentUpdateStatus.UNKNOWN;

    /*
     * Creation and update time stamps.
     * Updated automatically in Student.java, jdoPreStore()
     */
    protected transient Date createdAt;
    protected transient Date updatedAt;

    public StudentAttributes(String id, String email, String name, String comments, String courseId,
                             String team, String section) {
        this(section, team, name, email, comments, courseId);
        this.googleId = SanitizationHelper.sanitizeGoogleId(id);
    }

    public StudentAttributes() {
        // attributes to be set after construction
    }

    public StudentAttributes(String section, String team, String name, String email, String comment,
                             String courseId) {
        this();
        this.section = section;
        this.team = team;
        this.lastName = SanitizationHelper.sanitizeName(StringHelper.splitName(name)[1]);
        this.name = SanitizationHelper.sanitizeName(name);
        this.email = email;
        this.comments = SanitizationHelper.sanitizeTextField(comment);
        this.course = courseId;
    }

    public StudentAttributes(CourseStudent student) {
        this();
        this.email = student.getEmail();
        this.course = student.getCourseId();
        this.name = student.getName();
        this.lastName = student.getLastName();
        this.comments = SanitizationHelper.sanitizeTextField(student.getComments());
        this.team = student.getTeamName();
        this.section = student.getSectionName() == null ? Const.DEFAULT_SECTION : student.getSectionName();
        this.googleId = student.getGoogleId() == null ? """" : student.getGoogleId();
        this.key = student.getRegistrationKey();

        this.createdAt = student.getCreatedAt();
        this.updatedAt = student.getUpdatedAt();

    }

    private StudentAttributes(StudentAttributes other) {
        this(other.googleId, other.email, other.name, other.comments,
             other.course, other.team, other.section);
        this.key = other.key;
        this.updateStatus = other.updateStatus;
    }

    public StudentAttributes getCopy() {
        return new StudentAttributes(this);
    }

    public String toEnrollmentString() {
        String enrollmentStringSeparator = ""|"";

        return this.section + enrollmentStringSeparator
             + this.team + enrollmentStringSeparator
             + this.name + enrollmentStringSeparator
             + this.email + enrollmentStringSeparator
             + this.comments;
    }

    public boolean isRegistered() {
        return googleId != null && !googleId.isEmpty();
    }

    public String getRegistrationUrl() {
        return Config.getAppUrl(Const.ActionURIs.STUDENT_COURSE_JOIN_NEW)
                                           .withRegistrationKey(StringHelper.encrypt(key))
                                           .withStudentEmail(email)
                                           .withCourseId(course)
                                           .toString();
    }

    public String getPublicProfilePictureUrl() {
        return Config.getAppUrl(Const.ActionURIs.STUDENT_PROFILE_PICTURE)
                           .withStudentEmail(StringHelper.encrypt(email))
                           .withCourseId(StringHelper.encrypt(course))
                           .toString();
    }

    public String getName() {
        return name;
    }

    public String getEmail() {
        return email;
    }

    public String getKey() {
        return key;
    }

    /**
     * Format: email%courseId e.g., adam@gmail.com%cs1101.
     */
    public String getId() {
        return email + ""%"" + course;
    }

    public String getSection() {
        return section;
    }

    public String getTeam() {
        return team;
    }

    public String getComments() {
        return comments;
    }

    public boolean isEnrollInfoSameAs(StudentAttributes otherStudent) {
        return otherStudent != null && otherStudent.email.equals(this.email)
               && otherStudent.course.equals(this.course)
               && otherStudent.name.equals(this.name)
               && otherStudent.comments.equals(this.comments)
               && otherStudent.team.equals(this.team)
               && otherStudent.section.equals(this.section);
    }

    @Override
    public List<String> getInvalidityInfo() {
        // id is allowed to be null when the student is not registered
        Assumption.assertTrue(team != null);
        Assumption.assertTrue(comments != null);

        FieldValidator validator = new FieldValidator();
        List<String> errors = new ArrayList<>();

        if (isRegistered()) {
            addNonEmptyError(validator.getInvalidityInfoForGoogleId(googleId), errors);
        }

        addNonEmptyError(validator.getInvalidityInfoForCourseId(course), errors);

        addNonEmptyError(validator.getInvalidityInfoForEmail(email), errors);

        addNonEmptyError(validator.getInvalidityInfoForTeamName(team), errors);

        addNonEmptyError(validator.getInvalidityInfoForSectionName(section), errors);

        addNonEmptyError(validator.getInvalidityInfoForStudentRoleComments(comments), errors);

        addNonEmptyError(validator.getInvalidityInfoForPersonName(name), errors);

        return errors;
    }

    public static void sortBySectionName(List<StudentAttributes> students) {
        Collections.sort(students, new Comparator<StudentAttributes>() {
            @Override
            public int compare(StudentAttributes student1, StudentAttributes student2) {
                String sect1 = student1.section;
                String sect2 = student2.section;

                // If the section name is the same, reorder by team name
                if (sect1.compareTo(sect2) == 0) {
                    if (student1.team.compareTo(student2.team) == 0) {
                        return student1.name.compareTo(student2.name);
                    }

                    return student1.team.compareTo(student2.team);
                }

                return sect1.compareTo(sect2);
            }
        });
    }

    public static void sortByTeamName(List<StudentAttributes> students) {
        Collections.sort(students, new Comparator<StudentAttributes>() {
            @Override
            public int compare(StudentAttributes student1, StudentAttributes student2) {
                String team1 = student1.team;
                String team2 = student2.team;

                // If the team name is the same, reorder by student name
                if (team1.compareTo(team2) == 0) {
                    return student1.name.compareTo(student2.name);
                }

                return team1.compareTo(team2);
            }
        });
    }

    public static void sortByNameAndThenByEmail(List<StudentAttributes> students) {
        Collections.sort(students, new Comparator<StudentAttributes>() {
            @Override
            public int compare(StudentAttributes student1, StudentAttributes student2) {
                int result = student1.name.compareTo(student2.name);

                if (result == 0) {
                    result = student1.email.compareTo(student2.email);
                }

                return result;
            }
        });
    }

    public void updateWithExistingRecord(StudentAttributes originalStudent) {
        if (this.email == null) {
            this.email = originalStudent.email;
        }

        if (this.name == null) {
            this.name = originalStudent.name;
        }

        if (this.googleId == null) {
            this.googleId = originalStudent.googleId;
        }

        if (this.team == null) {
            this.team = originalStudent.team;
        }

        if (this.comments == null) {
            this.comments = originalStudent.comments;
        }

        if (this.section == null) {
            this.section = originalStudent.section;
        }
    }

    @Override
    public CourseStudent toEntity() {
        return new CourseStudent(email, name, googleId, comments, course, team, section);
    }

    @Override
    public String toString() {
        return toString(0);
    }

    public String toString(int indent) {
        String indentString = StringHelper.getIndent(indent);
        StringBuilder sb = new StringBuilder();
        sb.append(indentString + ""Student:"" + name + ""["" + email + ""]"" + EOL);

        return sb.toString();
    }

    @Override
    public String getIdentificationString() {
        return this.course + ""/"" + this.email;
    }

    @Override
    public String getEntityTypeAsString() {
        return ""Student"";
    }

    @Override
    public String getBackupIdentifier() {
        return Const.SystemParams.COURSE_BACKUP_LOG_MSG + course;
    }

    @Override
    public String getJsonString() {
        return JsonUtils.toJson(this, StudentAttributes.class);
    }

    @Override
    public void sanitizeForSaving() {
        googleId = SanitizationHelper.sanitizeGoogleId(googleId);
        name = SanitizationHelper.sanitizeName(name);
        comments = SanitizationHelper.sanitizeTextField(comments);
    }

    public String getStudentStatus() {
        if (isRegistered()) {
            return Const.STUDENT_COURSE_STATUS_JOINED;
        }
        return Const.STUDENT_COURSE_STATUS_YET_TO_JOIN;
    }

    public Date getCreatedAt() {
        return createdAt == null ? Const.TIME_REPRESENTS_DEFAULT_TIMESTAMP : createdAt;
    }

    public Date getUpdatedAt() {
        return updatedAt == null ? Const.TIME_REPRESENTS_DEFAULT_TIMESTAMP : updatedAt;
    }

    /**
     * Returns true if section value has changed from its original value.
     */
    public boolean isSectionChanged(StudentAttributes originalStudentAttribute) {
        return this.section != null && !this.section.equals(originalStudentAttribute.section);
    }

    /**
     * Returns true if team value has changed from its original value.
     */
    public boolean isTeamChanged(StudentAttributes originalStudentAttribute) {
        return this.team != null && !this.team.equals(originalStudentAttribute.team);
    }

    /**
     * Returns true if email value has changed from its original value.
     */
    public boolean isEmailChanged(StudentAttributes originalStudentAttribute) {
        return this.email != null && !this.email.equals(originalStudentAttribute.email);
    }
}
"
StudentProfileAttributes.java,data-transfer,"package teammates.common.datatransfer.attributes;

import java.util.ArrayList;
import java.util.Date;
import java.util.List;

import com.google.appengine.api.blobstore.BlobKey;
import com.google.appengine.api.datastore.Text;

import teammates.common.util.Assumption;
import teammates.common.util.Const;
import teammates.common.util.FieldValidator;
import teammates.common.util.JsonUtils;
import teammates.common.util.SanitizationHelper;
import teammates.common.util.StringHelper;
import teammates.storage.entity.StudentProfile;

/**
 * The data transfer object for StudentProfile entities.
 */
public class StudentProfileAttributes extends EntityAttributes<StudentProfile> {

    public String googleId;
    public String shortName;
    public String email;
    public String institute;
    public String nationality;
    public String gender; // only accepts ""male"", ""female"" or ""other""
    public String moreInfo;
    public String pictureKey;
    public Date modifiedDate;

    StudentProfileAttributes() {
        // just a container so all can be null
        this.googleId = """";
        this.shortName = """";
        this.email = """";
        this.institute = """";
        this.nationality = """";
        this.gender = ""other"";
        this.moreInfo = """";
        this.pictureKey = """";
        this.modifiedDate = new Date();
    }

    public static StudentProfileAttributes valueOf(StudentProfile sp) {
        return builder()
                .withGoogleId(sp.getGoogleId())
                .withShortName(sp.getShortName())
                .withEmail(sp.getEmail())
                .withInstitute(sp.getInstitute())
                .withGender(sp.getGender())
                .withNationality(sp.getNationality())
                .withMoreInfo(sp.getMoreInfo().getValue())
                .withPictureKey(sp.getPictureKey().getKeyString())
                .withModifiedDate(sp.getModifiedDate())
                .build();
    }

    /**
     * Return new builder instance all string fields setted to {@code """"}
     * and with {@code gender = ""other""}.
     */
    public static Builder builder() {
        return new Builder();
    }

    public StudentProfileAttributes getCopy() {
        return builder()
                .withGoogleId(googleId)
                .withShortName(shortName)
                .withEmail(email)
                .withInstitute(institute)
                .withGender(gender)
                .withNationality(nationality)
                .withMoreInfo(moreInfo)
                .withPictureKey(pictureKey)
                .withModifiedDate(modifiedDate)
                .build();
    }

    // branch is not fully tested here: part of StudentCourseJoinAuthenticatedAction
    public String generateUpdateMessageForStudent() {
        if (isMultipleFieldsEmpty()) {
            return Const.StatusMessages.STUDENT_UPDATE_PROFILE;
        } else if (StringHelper.isEmpty(shortName)) {
            return Const.StatusMessages.STUDENT_UPDATE_PROFILE_SHORTNAME;
        } else if (StringHelper.isEmpty(email)) {
            return Const.StatusMessages.STUDENT_UPDATE_PROFILE_EMAIL;
        } else if (StringHelper.isEmpty(pictureKey)) {
            return Const.StatusMessages.STUDENT_UPDATE_PROFILE_PICTURE;
        } else if (StringHelper.isEmpty(moreInfo)) {
            return Const.StatusMessages.STUDENT_UPDATE_PROFILE_MOREINFO;
        } else if (StringHelper.isEmpty(nationality)) {
            return Const.StatusMessages.STUDENT_UPDATE_PROFILE_NATIONALITY;
        }
        return """";
    }

    private boolean isMultipleFieldsEmpty() {
        int numEmptyFields = StringHelper.countEmptyStrings(shortName, email, nationality, moreInfo, pictureKey);
        return numEmptyFields > 1;
    }

    @Override
    public List<String> getInvalidityInfo() {
        FieldValidator validator = new FieldValidator();
        List<String> errors = new ArrayList<>();

        addNonEmptyError(validator.getInvalidityInfoForGoogleId(googleId), errors);

        // accept empty string values as it means the user has not specified anything yet.

        if (!StringHelper.isEmpty(shortName)) {
            addNonEmptyError(validator.getInvalidityInfoForPersonName(shortName), errors);
        }

        if (!StringHelper.isEmpty(email)) {
            addNonEmptyError(validator.getInvalidityInfoForEmail(email), errors);
        }

        if (!StringHelper.isEmpty(institute)) {
            addNonEmptyError(validator.getInvalidityInfoForInstituteName(institute), errors);
        }

        if (!StringHelper.isEmpty(nationality)) {
            addNonEmptyError(validator.getInvalidityInfoForNationality(nationality), errors);
        }

        addNonEmptyError(validator.getInvalidityInfoForGender(gender), errors);

        Assumption.assertNotNull(this.pictureKey);

        // No validation for modified date as it is determined by the system.
        // No validation for More Info. It will properly sanitized.

        return errors;
    }

    @Override
    public String toString() {
        return JsonUtils.toJson(this, StudentProfileAttributes.class);
    }

    @Override
    public StudentProfile toEntity() {
        return new StudentProfile(googleId, shortName, email, institute, nationality, gender,
                                  new Text(moreInfo), new BlobKey(this.pictureKey));
    }

    @Override
    public String getIdentificationString() {
        return this.googleId;
    }

    @Override
    public String getEntityTypeAsString() {
        return ""StudentProfile"";
    }

    @Override
    public String getBackupIdentifier() {
        return ""Student profile modified"";
    }

    @Override
    public String getJsonString() {
        return JsonUtils.toJson(this, StudentProfileAttributes.class);
    }

    @Override
    public void sanitizeForSaving() {
        this.googleId = SanitizationHelper.sanitizeGoogleId(this.googleId);
    }

    /**
     * A Builder class for {@link StudentProfileAttributes}.
     */
    public static class Builder {
        private final StudentProfileAttributes profileAttributes = new StudentProfileAttributes();

        public Builder withGoogleId(String googleId) {
            if (googleId != null) {
                profileAttributes.googleId = googleId;
            }
            return this;
        }

        public Builder withShortName(String shortName) {
            if (shortName != null) {
                profileAttributes.shortName = SanitizationHelper.sanitizeName(shortName);
            }
            return this;
        }

        public Builder withEmail(String email) {
            if (email != null) {
                profileAttributes.email = SanitizationHelper.sanitizeEmail(email);
            }
            return this;
        }

        public Builder withInstitute(String institute) {
            if (institute != null) {
                profileAttributes.institute = SanitizationHelper.sanitizeTitle(institute);
            }
            return this;
        }

        public Builder withNationality(String nationality) {
            if (nationality != null) {
                profileAttributes.nationality = SanitizationHelper.sanitizeName(nationality);
            }
            return this;
        }

        public Builder withGender(String gender) {
            profileAttributes.gender = isGenderValid(gender) ? gender : ""other"";
            return this;
        }

        public Builder withMoreInfo(String moreInfo) {
            if (moreInfo != null) {
                profileAttributes.moreInfo = moreInfo;
            }
            return this;
        }

        public Builder withPictureKey(String pictureKey) {
            if (pictureKey != null) {
                profileAttributes.pictureKey = pictureKey;
            }
            return this;
        }

        public Builder withModifiedDate(Date modifiedDate) {
            profileAttributes.modifiedDate = modifiedDate == null ? new Date() : modifiedDate;
            return this;
        }

        public StudentProfileAttributes build() {
            return profileAttributes;
        }

        private boolean isGenderValid(String gender) {
            return ""male"".equals(gender) || ""female"".equals(gender) || ""other"".equals(gender);
        }
    }
}
"
CourseDetailsBundle.java,data-transfer,"package teammates.common.datatransfer;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;

import teammates.common.datatransfer.attributes.CourseAttributes;
import teammates.common.datatransfer.attributes.FeedbackSessionAttributes;
import teammates.common.util.SanitizationHelper;

/**
 * Represents details of a course, including its students and feedback sessions.
 * <br> Contains:
 * <br> * statistics of teams, enrollments, registrations
 * <br> * Details of its feedback sessions (as {@link FeedbackSessionDetailsBundle} objects)
 * <br> * Details of its teams (as {@link TeamDetailsBundle} objects)
 *
 */
public class CourseDetailsBundle {
    public CourseAttributes course;
    public CourseStats stats = new CourseStats();

    public List<FeedbackSessionDetailsBundle> feedbackSessions = new ArrayList<>();
    public List<SectionDetailsBundle> sections = new ArrayList<>();

    public CourseDetailsBundle(CourseAttributes courseData) {
        this.course = courseData;
        //TODO: [CourseAttribute] remove desanitization after data migration
        //creating a new course with possibly desanitized name as course name cannot be accessed directly
        this.course = new CourseAttributes(courseData.getId(),
                SanitizationHelper.desanitizeIfHtmlSanitized(courseData.getName()),
                courseData.getTimeZone());
        this.course.createdAt = courseData.createdAt;
    }

    /**
     * Gets all FeedbackSessionAttributes in this CourseDetailsBundle.
     */
    public List<FeedbackSessionAttributes> getFeedbackSessionsList() {
        List<FeedbackSessionAttributes> feedbackSessionAttributes = new ArrayList<>();
        for (FeedbackSessionDetailsBundle feedbackSessionDetails : feedbackSessions) {
            feedbackSessionAttributes.add(feedbackSessionDetails.feedbackSession);
        }
        return feedbackSessionAttributes;
    }

    public static void sortDetailedCoursesByCourseId(List<CourseDetailsBundle> courses) {
        Collections.sort(courses, new Comparator<CourseDetailsBundle>() {
            @Override
            public int compare(CourseDetailsBundle obj1, CourseDetailsBundle obj2) {
                return obj1.course.getId().compareTo(obj2.course.getId());
            }
        });
    }

    /**
     * Sorts courses based on course ID.
     */
    public static void sortDetailedCourses(List<CourseDetailsBundle> courses) {
        Collections.sort(courses, new Comparator<CourseDetailsBundle>() {
            @Override
            public int compare(CourseDetailsBundle obj1, CourseDetailsBundle obj2) {
                return obj1.course.getId().compareTo(obj2.course.getId());
            }
        });
    }

    /**
     * Sorts courses based on course creation date in the order of latest to oldest order.
     */
    public static void sortDetailedCoursesByCreationDate(List<CourseDetailsBundle> courses) {
        Collections.sort(courses, new Comparator<CourseDetailsBundle>() {
            @Override
            public int compare(CourseDetailsBundle obj1, CourseDetailsBundle obj2) {
                return obj2.course.createdAt.compareTo(obj1.course.createdAt);
            }
        });
    }

    public CourseStats getStats() {
        return stats;
    }

    public CourseAttributes getCourse() {
        return course;
    }
}
"
CourseEnrollmentResult.java,data-transfer,"package teammates.common.datatransfer;

import java.util.ArrayList;
import java.util.List;

import teammates.common.datatransfer.attributes.StudentAttributes;

/**
 * Represents the result of an enrollment of students to a course.
 */
public class CourseEnrollmentResult {

    public List<StudentAttributes> studentList = new ArrayList<>();
    public List<StudentEnrollDetails> enrollmentList = new ArrayList<>();

    public CourseEnrollmentResult(List<StudentAttributes> studentList, List<StudentEnrollDetails> enrollmentList) {
        this.studentList = studentList;
        this.enrollmentList = enrollmentList;
    }

}
"
CourseRoster.java,data-transfer,"package teammates.common.datatransfer;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import teammates.common.datatransfer.attributes.InstructorAttributes;
import teammates.common.datatransfer.attributes.StudentAttributes;

/**
 * Contains a list of students and instructors in a course. Useful for caching
 * a copy of student and instructor details of a course instead of reading
 * them from the database multiple times.
 */
public class CourseRoster {

    Map<String, StudentAttributes> studentListByEmail = new HashMap<>();
    Map<String, InstructorAttributes> instructorListByEmail = new HashMap<>();

    public CourseRoster(List<StudentAttributes> students, List<InstructorAttributes> instructors) {
        populateStudentListByEmail(students);
        populateInstructorListByEmail(instructors);
    }

    public List<StudentAttributes> getStudents() {
        return new ArrayList<>(studentListByEmail.values());
    }

    public List<InstructorAttributes> getInstructors() {
        return new ArrayList<>(instructorListByEmail.values());
    }

    /**
     * Checks if an instructor is the instructor of a course by providing an email address.
     * @param instructorEmail email of the instructor to be checked.
     * @return true if the instructor is an instructor of the course
     */
    public boolean isInstructorOfCourse(String instructorEmail) {
        return instructorListByEmail.containsKey(instructorEmail);
    }

    public boolean isStudentInCourse(String studentEmail) {
        return studentListByEmail.containsKey(studentEmail);
    }

    public boolean isStudentInTeam(String studentEmail, String targetTeamName) {
        StudentAttributes student = studentListByEmail.get(studentEmail);
        return student != null && student.team.equals(targetTeamName);
    }

    public boolean isStudentsInSameTeam(String studentEmail1, String studentEmail2) {
        StudentAttributes student1 = studentListByEmail.get(studentEmail1);
        StudentAttributes student2 = studentListByEmail.get(studentEmail2);
        return student1 != null && student2 != null
               && student1.team != null && student1.team.equals(student2.team);
    }

    public StudentAttributes getStudentForEmail(String email) {
        return studentListByEmail.get(email);
    }

    public InstructorAttributes getInstructorForEmail(String email) {
        return instructorListByEmail.get(email);
    }

    private void populateStudentListByEmail(List<StudentAttributes> students) {

        if (students == null) {
            return;
        }

        for (StudentAttributes s : students) {
            studentListByEmail.put(s.email, s);
        }
    }

    private void populateInstructorListByEmail(List<InstructorAttributes> instructors) {

        if (instructors == null) {
            return;
        }

        for (InstructorAttributes i : instructors) {
            instructorListByEmail.put(i.email, i);
        }
    }

}
"
CourseStats.java,data-transfer,"package teammates.common.datatransfer;

/**
 * Represents the course statistics for a course.
 * <br> Contains:
 * <br> * The total number of teams in the course.
 * <br> * The total number of students in the course.
 * <br> * The total number of unregistered students in the course.
 */
public class CourseStats {
    public int sectionsTotal;
    public int teamsTotal;
    public int studentsTotal;
    public int unregisteredTotal;

    public int getSectionsTotal() {
        return sectionsTotal;
    }

    public int getTeamsTotal() {
        return teamsTotal;
    }

    public int getStudentsTotal() {
        return studentsTotal;
    }

    public int getUnregisteredTotal() {
        return unregisteredTotal;
    }
}
"
CourseSummaryBundle.java,data-transfer,"package teammates.common.datatransfer;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;

import teammates.common.datatransfer.attributes.CourseAttributes;
import teammates.common.datatransfer.attributes.FeedbackSessionAttributes;
import teammates.common.util.SanitizationHelper;

public class CourseSummaryBundle {

    public CourseAttributes course;
    public List<FeedbackSessionAttributes> feedbackSessions = new ArrayList<>();

    public CourseSummaryBundle(CourseAttributes courseData) {
        this.course = courseData;
    }

    /**
     * Sorts courses based on course ID.
     */
    public static void sortSummarizedCoursesByCourseId(List<CourseSummaryBundle> courses) {
        Collections.sort(courses, new Comparator<CourseSummaryBundle>() {
            @Override
            public int compare(CourseSummaryBundle obj1, CourseSummaryBundle obj2) {
                return obj1.course.getId().compareTo(obj2.course.getId());
            }
        });
    }

    /**
     * Sorts courses based on course name.
     */
    public static void sortSummarizedCoursesByCourseName(List<CourseSummaryBundle> courses) {
        Collections.sort(courses, new Comparator<CourseSummaryBundle>() {
            @Override
            public int compare(CourseSummaryBundle obj1, CourseSummaryBundle obj2) {
                String courseName1 = obj1.course.getName();
                String courseName2 = obj2.course.getName();

                //TODO: [CourseAttribute] remove desanitization after data migration
                //desanitization is applied to course name to ensure a well-defined order of the courses by course name
                courseName1 = SanitizationHelper.desanitizeIfHtmlSanitized(courseName1);
                courseName2 = SanitizationHelper.desanitizeFromHtml(courseName2);

                return courseName1.compareTo(courseName2);
            }
        });
    }

    /**
     * Sorts courses based on course creation date in the order of latest to oldest order.
     */
    public static void sortSummarizedCoursesByCreationDate(List<CourseSummaryBundle> courses) {
        Collections.sort(courses, new Comparator<CourseSummaryBundle>() {
            @Override
            public int compare(CourseSummaryBundle obj1, CourseSummaryBundle obj2) {
                return obj2.course.createdAt.compareTo(obj1.course.createdAt);
            }
        });
    }

    public static void sortSummarizedCourses(List<CourseSummaryBundle> courses) {
        Collections.sort(courses, new Comparator<CourseSummaryBundle>() {
            @Override
            public int compare(CourseSummaryBundle obj1, CourseSummaryBundle obj2) {
                return obj1.course.getId().compareTo(obj2.course.getId());
            }
        });
    }
}
"
DataBundle.java,data-transfer,"package teammates.common.datatransfer;

import java.util.LinkedHashMap;
import java.util.Map;

import teammates.common.datatransfer.attributes.AccountAttributes;
import teammates.common.datatransfer.attributes.AdminEmailAttributes;
import teammates.common.datatransfer.attributes.CourseAttributes;
import teammates.common.datatransfer.attributes.EntityAttributes;
import teammates.common.datatransfer.attributes.FeedbackQuestionAttributes;
import teammates.common.datatransfer.attributes.FeedbackResponseAttributes;
import teammates.common.datatransfer.attributes.FeedbackResponseCommentAttributes;
import teammates.common.datatransfer.attributes.FeedbackSessionAttributes;
import teammates.common.datatransfer.attributes.InstructorAttributes;
import teammates.common.datatransfer.attributes.StudentAttributes;
import teammates.common.datatransfer.attributes.StudentProfileAttributes;
import teammates.storage.entity.BaseEntity;

/**
 * Holds a bundle of *Attributes data transfer objects.
 * This class is mainly used for serializing JSON strings.
 */
public class DataBundle {
    public Map<String, AccountAttributes> accounts = new LinkedHashMap<>();
    public Map<String, CourseAttributes> courses = new LinkedHashMap<>();
    public Map<String, InstructorAttributes> instructors = new LinkedHashMap<>();
    public Map<String, StudentAttributes> students = new LinkedHashMap<>();
    public Map<String, FeedbackSessionAttributes> feedbackSessions = new LinkedHashMap<>();
    public Map<String, FeedbackQuestionAttributes> feedbackQuestions = new LinkedHashMap<>();
    public Map<String, FeedbackResponseAttributes> feedbackResponses = new LinkedHashMap<>();
    public Map<String, FeedbackResponseCommentAttributes> feedbackResponseComments = new LinkedHashMap<>();
    public Map<String, StudentProfileAttributes> profiles = new LinkedHashMap<>();
    public Map<String, AdminEmailAttributes> adminEmails = new LinkedHashMap<>();

    /**
     * Sanitize each attribute in the dataBundle for saving.
     */
    public void sanitizeForSaving() {
        sanitizeMapForSaving(accounts);
        sanitizeMapForSaving(courses);
        sanitizeMapForSaving(instructors);
        sanitizeMapForSaving(students);
        sanitizeMapForSaving(feedbackSessions);
        sanitizeMapForSaving(feedbackQuestions);
        sanitizeMapForSaving(feedbackResponses);
        sanitizeMapForSaving(feedbackResponseComments);
        sanitizeMapForSaving(profiles);
        sanitizeMapForSaving(adminEmails);
    }

    /**
     * Sanitize each attribute in the {@code map} for saving.
     */
    private <T extends EntityAttributes<? extends BaseEntity>> void sanitizeMapForSaving(Map<String, T> map) {
        for (T attribute : map.values()) {
            attribute.sanitizeForSaving();
        }
    }
}
"
FeedbackParticipantType.java,data-transfer,"package teammates.common.datatransfer;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public enum FeedbackParticipantType {
    // booleans represent: isValidGiver?, isValidRecipient? isValidViewer?
    // Strings represents: option shown in giver select box, option shown in recipient select box,
    // text displayed during feedback submission respectively.
    SELF(true, true, false, ""Feedback session creator (i.e., me)"", ""Giver (Self feedback)"", """"),
    STUDENTS(true, true, true, ""Students in this course"", ""Other students in the course"", ""Other students in the course""),
    INSTRUCTORS(true, true, true, ""Instructors in this course"", ""Instructors in the course"", ""Instructors in this course""),
    TEAMS(true, true, false, ""Teams in this course"", ""Other teams in the course"", """"),
    OWN_TEAM(false, true, false, """", ""Giver's team"", ""Your team""),
    OWN_TEAM_MEMBERS(false, true, true, """", ""Giver's team members"", ""Your team members""),
    OWN_TEAM_MEMBERS_INCLUDING_SELF(false, true, true, """", ""Giver's team members and Giver"", ""Your team members""),
    RECEIVER(false, false, true, """", """", ""The receiving""),
    RECEIVER_TEAM_MEMBERS(false, false, true, """", """", ""The recipient's team members""),
    NONE(false, true, false, """", ""Nobody specific (For general class feedback)"", """"),
    // Used by feedbackResponseComment:
    GIVER(false, false, true, """", """", """");

    public static final List<FeedbackParticipantType> GIVERS;
    static {
        List<FeedbackParticipantType> giverInitializer = new ArrayList<>();
        for (FeedbackParticipantType participantType : FeedbackParticipantType.values()) {
            if (participantType.isValidGiver()) {
                giverInitializer.add(participantType);
            }
        }
        GIVERS = Collections.unmodifiableList(giverInitializer);
    }

    public static final List<FeedbackParticipantType> RECIPIENTS;
    static {
        List<FeedbackParticipantType> recipientInitializer = new ArrayList<>();
        for (FeedbackParticipantType participantType : FeedbackParticipantType.values()) {
            if (participantType.isValidRecipient()) {
                recipientInitializer.add(participantType);
            }
        }
        RECIPIENTS = Collections.unmodifiableList(recipientInitializer);
    }

    private final boolean validGiver;
    private final boolean validRecipient;
    private final boolean validViewer;
    private String displayNameGiver;
    private String displayNameRecipient;
    private String displayNameVisibility;

    FeedbackParticipantType(boolean isGiver, boolean isRecipient, boolean isViewer,
                            String displayNameGiver, String displayNameRecipient, String displayNameVisibility) {
        this.validGiver = isGiver;
        this.validRecipient = isRecipient;
        this.validViewer = isViewer;
        this.displayNameGiver = displayNameGiver;
        this.displayNameRecipient = displayNameRecipient;
        this.displayNameVisibility = displayNameVisibility;
    }

    public boolean isValidGiver() {
        return validGiver;
    }

    public boolean isValidRecipient() {
        return validRecipient;
    }

    public boolean isValidViewer() {
        return validViewer;
    }

    public boolean isTeam() {
        return this == TEAMS || this == OWN_TEAM;
    }

    /**
     * Formats the participant type as a giver for display to user.
     *
     * @return A user-friendly {@code String} representing this participant as a feedback giver.
     */
    public String toDisplayGiverName() {
        return displayNameGiver;
    }

    /**
     * Formats the participant type as a recipient for display to user.
     *
     * @return A user-friendly {@code String} representing this participant as a feedback recipient.
     */
    public String toDisplayRecipientName() {
        return displayNameRecipient;
    }

    /**
     * Formats the participant type for display to user in the response visibility section.
     *
     * @return A user-friendly {@code String} representing this participant directed to users who are
     *         responding to a feedback.
     */
    public String toVisibilityString() {
        return displayNameVisibility;
    }

    /**
     * Formats the participant type as a singular noun.
     *
     * @return A user-friendly {@code String} representing this participant in singular form.
     */
    public String toSingularFormString() {
        switch (this) {
        case INSTRUCTORS:
            return ""instructor"";
        case STUDENTS:
            // Fallthrough
        case OWN_TEAM_MEMBERS:
            // Fallthrough
        case OWN_TEAM_MEMBERS_INCLUDING_SELF:
            return ""student"";
        case TEAMS:
            return ""team"";
        case OWN_TEAM:
            return ""team"";
        default:
            return super.toString();
        }
    }

    /**
     * Gets {@code displayNameGiver} property.
     */
    public String getDisplayNameGiver() {
        return displayNameGiver;
    }

    /**
     * Gets {@code displayNameRecipient} property.
     */
    public String getDisplayNameRecipient() {
        return displayNameRecipient;
    }

    /**
     * Returns A list of {@link FeedbackParticipantType} objects corresponding to the supplied parameter.
     */
    public static List<FeedbackParticipantType> getParticipantListFromCommaSeparatedValues(
            String commaSeparatedValues) {
        List<FeedbackParticipantType> participantList = new ArrayList<>();

        if (commaSeparatedValues == null || commaSeparatedValues.isEmpty()) {
            return participantList;
        }

        for (String str : commaSeparatedValues.split("","")) {
            participantList.add(FeedbackParticipantType.valueOf(str));
        }

        return participantList;
    }
}
"
FeedbackResponseCommentSearchResultBundle.java,data-transfer,"package teammates.common.datatransfer;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import teammates.common.datatransfer.attributes.FeedbackQuestionAttributes;
import teammates.common.datatransfer.attributes.FeedbackResponseAttributes;
import teammates.common.datatransfer.attributes.FeedbackResponseCommentAttributes;
import teammates.common.datatransfer.attributes.FeedbackSessionAttributes;

/**
 * The search result bundle for {@link FeedbackResponseCommentAttributes}.
 */
public class FeedbackResponseCommentSearchResultBundle extends SearchResultBundle {

    public Map<String, List<FeedbackResponseCommentAttributes>> comments = new HashMap<>();
    public Map<String, List<FeedbackResponseAttributes>> responses = new HashMap<>();
    public Map<String, List<FeedbackQuestionAttributes>> questions = new HashMap<>();
    public Map<String, FeedbackSessionAttributes> sessions = new HashMap<>();
    public Map<String, String> commentGiverTable = new HashMap<>();
    public Map<String, String> responseGiverTable = new HashMap<>();
    public Map<String, String> responseRecipientTable = new HashMap<>();
    public Set<String> instructorEmails = new HashSet<>();
    public Map<String, String> instructorEmailNameTable = new HashMap<>();

}
"
FeedbackSessionDetailsBundle.java,data-transfer,"package teammates.common.datatransfer;

import java.util.Collections;
import java.util.Comparator;
import java.util.List;

import teammates.common.datatransfer.attributes.FeedbackSessionAttributes;
import teammates.common.util.Const;

/**
 * Represents details of a feedback session
 * Contains:
 * <br> * The basic info of the feedback session (as a {@link FeedbackSessionAttributes} object).
 * <br> * Feedback response statistics (as a {@link FeedbackSessionStats} object).
 */
public class FeedbackSessionDetailsBundle {

    public FeedbackSessionStats stats;
    public FeedbackSessionAttributes feedbackSession;

    public FeedbackSessionDetailsBundle(FeedbackSessionAttributes feedbackSession) {
        this.feedbackSession = feedbackSession;
        this.stats = new FeedbackSessionStats();
    }

    /**
     * Sorts feedback session based courseID (ascending), then by create time (ascending), deadline
     * (ascending), then by start time (ascending), then by feedback session name
     * (ascending). The sort by CourseID part is to cater the case when this
     * method is called with combined feedback sessions from many courses
     */
    public static void sortFeedbackSessionsByCreationTime(List<FeedbackSessionDetailsBundle> sessions) {
        Collections.sort(sessions, new Comparator<FeedbackSessionDetailsBundle>() {
            @Override
            public int compare(FeedbackSessionDetailsBundle fsd1, FeedbackSessionDetailsBundle fsd2) {
                FeedbackSessionAttributes session1 = fsd1.feedbackSession;
                FeedbackSessionAttributes session2 = fsd2.feedbackSession;
                int result = 0;
                if (result == 0) {
                    result = session1.getCourseId().compareTo(session2.getCourseId());
                }
                if (result == 0) {
                    result = session1.getCreatedTime().after(session2.getCreatedTime()) ? 1
                            : session1.getCreatedTime().before(session2.getCreatedTime()) ? -1 : 0;
                }
                if (result == 0) {
                    result = session1.getEndTime().after(session2.getEndTime()) ? 1
                            : session1.getEndTime().before(session2.getEndTime()) ? -1 : 0;
                }
                if (result == 0) {
                    result = session1.getStartTime().after(session2.getStartTime()) ? 1
                            : session1.getStartTime().before(session2.getStartTime()) ? -1 : 0;
                }
                if (result == 0) {
                    result = session1.getFeedbackSessionName().compareTo(session2.getFeedbackSessionName());
                }
                return result;
            }
        });
    }

    @Override
    public String toString() {
        return ""course:"" + feedbackSession.getCourseId() + "", name:"" + feedbackSession.getFeedbackSessionName() + Const.EOL
               + ""submitted/total: "" + stats.submittedTotal + ""/"" + stats.expectedTotal;
    }
}
"
FeedbackSessionQuestionsBundle.java,data-transfer,"package teammates.common.datatransfer;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

import teammates.common.datatransfer.attributes.FeedbackQuestionAttributes;
import teammates.common.datatransfer.attributes.FeedbackResponseAttributes;
import teammates.common.datatransfer.attributes.FeedbackSessionAttributes;

public class FeedbackSessionQuestionsBundle {

    public FeedbackSessionAttributes feedbackSession;
    public Map<FeedbackQuestionAttributes, List<FeedbackResponseAttributes>> questionResponseBundle;
    public Map<String, Map<String, String>> recipientList;

    public FeedbackSessionQuestionsBundle(FeedbackSessionAttributes feedbackSession,
            Map<FeedbackQuestionAttributes, List<FeedbackResponseAttributes>> questionResponseBundle,
            Map<String, Map<String, String>> recipientList) {
        this.feedbackSession = feedbackSession;
        this.questionResponseBundle = questionResponseBundle;
        this.recipientList = recipientList;
    }

    public Map<FeedbackQuestionAttributes, List<FeedbackResponseAttributes>> getQuestionResponseBundle() {
        return questionResponseBundle;
    }

    public FeedbackSessionAttributes getFeedbackSession() {
        return feedbackSession;
    }

    /**
     * Gets the list of questions in this bundle, sorted by question number.
     * @return A {@code List} of {@code FeedackQuestionAttributes}.
     */
    public List<FeedbackQuestionAttributes> getSortedQuestions() {
        List<FeedbackQuestionAttributes> sortedQuestions =
                new ArrayList<>(this.questionResponseBundle.keySet());

        Collections.sort(sortedQuestions);

        return sortedQuestions;
    }

    /**
     * Gets the question in the data bundle with id == questionId.
     * @return a FeedbackQuestionAttribute with the specified questionId
     */
    public FeedbackQuestionAttributes getQuestionAttributes(String questionId) {
        List<FeedbackQuestionAttributes> questions =
                new ArrayList<>(this.questionResponseBundle.keySet());

        for (FeedbackQuestionAttributes question : questions) {
            if (question.getId().equals(questionId)) {
                return question;
            }
        }

        return null;
    }

    /**
     * Gets the recipient list for a question, sorted by the recipient's name.
     * @param feedbackQuestionId of the question
     * @return A {@code Map<String key, String value>} where {@code key} is the recipient's email
     *         and {@code value} is the recipients name.
     */
    public Map<String, String> getSortedRecipientList(String feedbackQuestionId) {

        List<Map.Entry<String, String>> sortedList = new ArrayList<>(recipientList.get(feedbackQuestionId).entrySet());

        Collections.sort(sortedList, new Comparator<Map.Entry<String, String>>() {
            @Override
            public int compare(Map.Entry<String, String> o1, Map.Entry<String, String> o2) {
                // Sort by value (name).
                int compare = o1.getValue().compareTo(o2.getValue());
                // Sort by key (email) if name is same.
                return compare == 0 ? o1.getKey().compareTo(o2.getKey()) : compare;
            }
        });

        Map<String, String> result = new LinkedHashMap<>();

        for (Map.Entry<String, String> entry : sortedList) {
            result.put(entry.getKey(), entry.getValue());
        }

        return result;
    }

    public Set<String> getRecipientEmails(String feedbackQuestionId) {
        List<Map.Entry<String, String>> emailList = new ArrayList<>(recipientList.get(feedbackQuestionId).entrySet());

        HashSet<String> result = new HashSet<>();

        for (Map.Entry<String, String> entry : emailList) {
            result.add(entry.getKey());
        }

        return result;
    }

    /**
     * Removes question from the bundle if the question has givers or recipients that are anonymous to the instructor
     * or responses that are hidden from the instructor.
     */
    public void hideUnmoderatableQuestions() {
        List<FeedbackQuestionAttributes> questionsToHide = new ArrayList<>();

        for (FeedbackQuestionAttributes question : questionResponseBundle.keySet()) {
            boolean isGiverVisibleToInstructor = question.showGiverNameTo.contains(FeedbackParticipantType.INSTRUCTORS);
            boolean isRecipientVisibleToInstructor =
                    question.showRecipientNameTo.contains(FeedbackParticipantType.INSTRUCTORS);
            boolean isResponseVisibleToInstructor = question.showResponsesTo.contains(FeedbackParticipantType.INSTRUCTORS);

            if (!isResponseVisibleToInstructor || !isGiverVisibleToInstructor || !isRecipientVisibleToInstructor) {
                questionsToHide.add(question);
                questionResponseBundle.put(question, new ArrayList<FeedbackResponseAttributes>());
            }
        }

        questionResponseBundle.keySet().removeAll(questionsToHide);
    }

    /**
     * Empties responses for all questions in this bundle.
     * Used to not show existing responses when previewing as instructor
     */
    public void resetAllResponses() {
        for (FeedbackQuestionAttributes question : questionResponseBundle.keySet()) {
            questionResponseBundle.put(question, new ArrayList<FeedbackResponseAttributes>());
        }
    }
}
"
FeedbackSessionResponseStatus.java,data-transfer,"package teammates.common.datatransfer;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class FeedbackSessionResponseStatus {
    public List<String> noResponse;
    public List<String> studentsWhoResponded;
    public Map<String, String> emailNameTable;
    public Map<String, String> emailSectionTable;
    public Map<String, String> emailTeamNameTable;

    // Sorts by teamName > studentName
    private Comparator<String> compareByTeamNameStudentName = new Comparator<String>() {

        @Override
        public int compare(String s1, String s2) {
            int order = compareByTeamName.compare(s1, s2);
            if (order != 0) {
                // Sorting can be done at team name level
                return order;
            }
            // Both s1, s2 are in the same team
            // Sorting has to be done at name level
            return compareByName.compare(s1, s2);
        }

    };

    // Sorts by teamName
    private Comparator<String> compareByTeamName = new Comparator<String>() {

        @Override
        public int compare(String s1, String s2) {
            // Compare between instructor and student
            // Instructor should be at higher order compared to student
            String teamName1 = emailTeamNameTable.get(s1);
            String teamName2 = emailTeamNameTable.get(s2);
            boolean isTeamName1Instructor = teamName1 == null;
            boolean isTeamName2Instructor = teamName2 == null;

            if (isTeamName1Instructor && !isTeamName2Instructor) {
                // Team 1 has higher sorting order when team 1 belongs instructor and team 2 belongs to student
                // -1 represents team 1 is at higher order
                return -1;
            } else if (!isTeamName1Instructor && isTeamName2Instructor) {
                // Team 2 has higher sorting order when team 2 belongs instructor and team 1 belongs to student
                // 1 represents team 2 is at higher order
                return 1;
            } else if (isTeamName1Instructor && isTeamName2Instructor) {
                // Both teams belong to instructor
                // Therefore team name 1 and 2 are the same, which is indicated by 0
                return compareByName.compare(s1, s2);
            } else {
                // Both teams belong to student
                // Compare on team names
                return teamName1.compareToIgnoreCase(teamName2);
            }
        }

    };

    // Sorts by studentName
    private Comparator<String> compareByName = new Comparator<String>() {

        @Override
        public int compare(String s1, String s2) {
            // Compare on names
            String name1 = emailNameTable.get(s1);
            String name2 = emailNameTable.get(s2);
            return name1.compareToIgnoreCase(name2);
        }

    };

    public FeedbackSessionResponseStatus() {
        noResponse = new ArrayList<>();
        studentsWhoResponded = new ArrayList<>();
        emailNameTable = new HashMap<>();
        emailSectionTable = new HashMap<>();
        emailTeamNameTable = new HashMap<>();
    }

    /**
     * Returns list of students who did not respond to the feedback session
     * sorted by teamName > studentNamelist.
     */
    public List<String> getStudentsWhoDidNotRespondToAnyQuestion() {
        Collections.sort(noResponse, compareByTeamNameStudentName);
        return noResponse;
    }

    /**
     * Returns list of students who did not respond to the feedback session.
     */
    public List<String> getNoResponse() {
        return noResponse;
    }

    /**
     * Returns list of students who responded to the feedback session.
     */
    public List<String> getStudentsWhoResponded() {
        return studentsWhoResponded;
    }

    public Map<String, String> getEmailNameTable() {
        return emailNameTable;
    }

    public Map<String, String> getEmailTeamNameTable() {
        return emailTeamNameTable;
    }

    public Map<String, String> getEmailSectionTable() {
        return emailSectionTable;
    }
}
"
FeedbackSessionResultsBundle.java,data-transfer,"package teammates.common.datatransfer;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;

import org.jsoup.Jsoup;
import org.jsoup.nodes.Element;
import org.jsoup.select.Elements;

import com.google.appengine.api.datastore.Text;

import teammates.common.datatransfer.attributes.FeedbackQuestionAttributes;
import teammates.common.datatransfer.attributes.FeedbackResponseAttributes;
import teammates.common.datatransfer.attributes.FeedbackResponseCommentAttributes;
import teammates.common.datatransfer.attributes.FeedbackSessionAttributes;
import teammates.common.datatransfer.attributes.InstructorAttributes;
import teammates.common.datatransfer.attributes.StudentAttributes;
import teammates.common.util.Const;
import teammates.common.util.Logger;
import teammates.common.util.SanitizationHelper;
import teammates.common.util.StringHelper;

/**
 * Represents detailed results for an feedback session.
 * <br> Contains:
 * <br> * The basic {@link FeedbackSessionAttributes}
 * <br> * {@link List} of viewable responses as {@link FeedbackResponseAttributes} objects.
 */
public class FeedbackSessionResultsBundle {

    private static final Logger log = Logger.getLogger();

    public FeedbackSessionAttributes feedbackSession;
    public List<FeedbackResponseAttributes> responses;
    public Map<String, FeedbackQuestionAttributes> questions;
    public Map<String, String> emailNameTable;
    public Map<String, String> emailLastNameTable;
    public Map<String, String> emailTeamNameTable;
    public Map<String, String> instructorEmailNameTable;
    public Map<String, Set<String>> rosterTeamNameMembersTable;
    public Map<String, Set<String>> rosterSectionTeamNameTable;
    public Map<String, boolean[]> visibilityTable;
    public FeedbackSessionResponseStatus responseStatus;
    public CourseRoster roster;
    public Map<String, List<FeedbackResponseCommentAttributes>> responseComments;
    public boolean isComplete;

    /**
     * Responses with identities of giver/recipients NOT hidden.
     * To be used for anonymous result calculation only, and identities hidden before showing to users.
     */
    public List<FeedbackResponseAttributes> actualResponses;

    // For contribution questions.
    // Key is questionId, value is a map of student email to StudentResultSumary
    public Map<String, Map<String, StudentResultSummary>> contributionQuestionStudentResultSummary = new HashMap<>();
    // Key is questionId, value is a map of team name to TeamEvalResult
    public Map<String, Map<String, TeamEvalResult>> contributionQuestionTeamEvalResults = new HashMap<>();

    /*
     * sectionTeamNameTable takes into account the section viewing privileges of the logged-in instructor
     * and the selected section for viewing
     * whereas rosterSectionTeamNameTable doesn't.
     * As a result, sectionTeamNameTable only contains sections viewable to the logged-in instructor
     * whereas rosterSectionTeamNameTable contains all sections in the course.
     * As sectionTeamNameTable is dependent on instructor privileges,
     * it can only be used for instructor pages and not for student pages
    */
    public Map<String, Set<String>> sectionTeamNameTable;

    // Sorts by giverName > recipientName > qnNumber
    // General questions and team questions at the bottom.
    public Comparator<FeedbackResponseAttributes> compareByGiverRecipientQuestion =
            new Comparator<FeedbackResponseAttributes>() {
        @Override
        public int compare(FeedbackResponseAttributes o1, FeedbackResponseAttributes o2) {
            String giverSection1 = o1.giverSection;
            String giverSection2 = o2.giverSection;
            int order = giverSection1.compareTo(giverSection2);
            if (order != 0) {
                return order;
            }

            boolean isGiverVisible1 = isGiverVisible(o1);
            boolean isGiverVisible2 = isGiverVisible(o2);

            String giverName1 = emailNameTable.get(o1.giver);
            String giverName2 = emailNameTable.get(o2.giver);
            order = compareByNames(giverName1, giverName2, isGiverVisible1, isGiverVisible2);
            if (order != 0) {
                return order;
            }

            boolean isRecipientVisible1 = isRecipientVisible(o1);
            boolean isRecipientVisible2 = isRecipientVisible(o2);

            String recipientName1 = emailNameTable.get(o1.recipient);
            String recipientName2 = emailNameTable.get(o2.recipient);
            order = compareByNames(recipientName1, recipientName2, isRecipientVisible1, isRecipientVisible2);
            if (order != 0) {
                return order;
            }

            order = compareByQuestionNumber(o1, o2);
            if (order != 0) {
                return order;
            }
            order = compareByResponseString(o1, o2);
            if (order != 0) {
                return order;
            }

            return o1.getId().compareTo(o2.getId());
        }
    };

    // Sorts by giverName > recipientName
    private Comparator<FeedbackResponseAttributes> compareByGiverRecipient =
            new Comparator<FeedbackResponseAttributes>() {
        @Override
        public int compare(FeedbackResponseAttributes o1, FeedbackResponseAttributes o2) {

            boolean isGiverVisible1 = isGiverVisible(o1);
            boolean isGiverVisible2 = isGiverVisible(o2);

            String giverName1 = emailNameTable.get(o1.giver);
            String giverName2 = emailNameTable.get(o2.giver);
            int order = compareByNames(giverName1, giverName2, isGiverVisible1, isGiverVisible2);
            if (order != 0) {
                return order;
            }

            boolean isRecipientVisible1 = isRecipientVisible(o1);
            boolean isRecipientVisible2 = isRecipientVisible(o2);

            String recipientName1 = emailNameTable.get(o1.recipient);
            String recipientName2 = emailNameTable.get(o2.recipient);
            order = compareByNames(recipientName1, recipientName2, isRecipientVisible1, isRecipientVisible2);
            if (order != 0) {
                return order;
            }

            order = compareByResponseString(o1, o2);
            if (order != 0) {
                return order;
            }

            return o1.getId().compareTo(o2.getId());
        }
    };

    // Sorts by teamName > giverName > recipientName > qnNumber
    private Comparator<FeedbackResponseAttributes> compareByTeamGiverRecipientQuestion =
            new Comparator<FeedbackResponseAttributes>() {
        @Override
        public int compare(FeedbackResponseAttributes o1, FeedbackResponseAttributes o2) {
            String giverSection1 = o1.giverSection;
            String giverSection2 = o2.giverSection;
            int order = giverSection1.compareTo(giverSection2);
            if (order != 0) {
                return order;
            }

            boolean isGiverVisible1 = isGiverVisible(o1);
            boolean isGiverVisible2 = isGiverVisible(o2);

            String t1 = getTeamNameForEmail(o1.giver).isEmpty() ? getNameForEmail(o1.giver)
                                                                : getTeamNameForEmail(o1.giver);
            String t2 = getTeamNameForEmail(o2.giver).isEmpty() ? getNameForEmail(o2.giver)
                                                                : getTeamNameForEmail(o2.giver);
            order = compareByNames(t1, t2, isGiverVisible1, isGiverVisible2);
            if (order != 0) {
                return order;
            }

            String giverName1 = emailNameTable.get(o1.giver);
            String giverName2 = emailNameTable.get(o2.giver);
            order = compareByNames(giverName1, giverName2, isGiverVisible1, isGiverVisible2);
            if (order != 0) {
                return order;
            }

            boolean isRecipientVisible1 = isRecipientVisible(o1);
            boolean isRecipientVisible2 = isRecipientVisible(o2);

            String recipientName1 = emailNameTable.get(o1.recipient);
            String recipientName2 = emailNameTable.get(o2.recipient);
            order = compareByNames(recipientName1, recipientName2, isRecipientVisible1, isRecipientVisible2);
            if (order != 0) {
                return order;
            }

            order = compareByQuestionNumber(o1, o2);
            if (order != 0) {
                return order;
            }
            order = compareByResponseString(o1, o2);
            if (order != 0) {
                return order;
            }

            return o1.getId().compareTo(o2.getId());
        }
    };

    // Sorts by recipientName > giverName > qnNumber
    private Comparator<FeedbackResponseAttributes> compareByRecipientGiverQuestion =
            new Comparator<FeedbackResponseAttributes>() {
        @Override
        public int compare(FeedbackResponseAttributes o1, FeedbackResponseAttributes o2) {
            String recipientSection1 = o1.recipientSection;
            String recipientSection2 = o2.recipientSection;
            int order = recipientSection1.compareTo(recipientSection2);
            if (order != 0) {
                return order;
            }

            boolean isRecipientVisible1 = isRecipientVisible(o1);
            boolean isRecipientVisible2 = isRecipientVisible(o2);

            String recipientName1 = emailNameTable.get(o1.recipient);
            String recipientName2 = emailNameTable.get(o2.recipient);
            order = compareByNames(recipientName1, recipientName2, isRecipientVisible1, isRecipientVisible2);
            if (order != 0) {
                return order;
            }

            boolean isGiverVisible1 = isGiverVisible(o1);
            boolean isGiverVisible2 = isGiverVisible(o2);

            String giverName1 = emailNameTable.get(o1.giver);
            String giverName2 = emailNameTable.get(o2.giver);
            order = compareByNames(giverName1, giverName2, isGiverVisible1, isGiverVisible2);
            if (order != 0) {
                return order;
            }

            order = compareByQuestionNumber(o1, o2);
            if (order != 0) {
                return order;
            }
            order = compareByResponseString(o1, o2);
            if (order != 0) {
                return order;
            }

            return o1.getId().compareTo(o2.getId());
        }
    };

    // Sorts by teamName > recipientName > giverName > qnNumber
    private Comparator<FeedbackResponseAttributes> compareByTeamRecipientGiverQuestion =
            new Comparator<FeedbackResponseAttributes>() {
        @Override
        public int compare(FeedbackResponseAttributes o1, FeedbackResponseAttributes o2) {
            String recipientSection1 = o1.recipientSection;
            String recipientSection2 = o2.recipientSection;
            int order = recipientSection1.compareTo(recipientSection2);
            if (order != 0) {
                return order;
            }

            boolean isRecipientVisible1 = isRecipientVisible(o1);
            boolean isRecipientVisible2 = isRecipientVisible(o2);

            String t1 = getTeamNameForEmail(o1.recipient).isEmpty() ? getNameForEmail(o1.recipient)
                                                                    : getTeamNameForEmail(o1.recipient);
            String t2 = getTeamNameForEmail(o2.recipient).isEmpty() ? getNameForEmail(o2.recipient)
                                                                    : getTeamNameForEmail(o2.recipient);
            order = compareByNames(t1, t2, isRecipientVisible1, isRecipientVisible2);
            if (order != 0) {
                return order;
            }

            String recipientName1 = emailNameTable.get(o1.recipient);
            String recipientName2 = emailNameTable.get(o2.recipient);
            order = compareByNames(recipientName1, recipientName2, isRecipientVisible1, isRecipientVisible2);
            if (order != 0) {
                return order;
            }

            boolean isGiverVisible1 = isGiverVisible(o1);
            boolean isGiverVisible2 = isGiverVisible(o2);

            String giverName1 = emailNameTable.get(o1.giver);
            String giverName2 = emailNameTable.get(o2.giver);
            order = compareByNames(giverName1, giverName2, isGiverVisible1, isGiverVisible2);
            if (order != 0) {
                return order;
            }

            order = compareByQuestionNumber(o1, o2);
            if (order != 0) {
                return order;
            }
            order = compareByResponseString(o1, o2);
            if (order != 0) {
                return order;
            }

            return o1.getId().compareTo(o2.getId());
        }
    };

    // Sorts by giverName > question > recipientTeam > recipientName
    private Comparator<FeedbackResponseAttributes> compareByGiverQuestionTeamRecipient =
            new Comparator<FeedbackResponseAttributes>() {
        @Override
        public int compare(FeedbackResponseAttributes o1, FeedbackResponseAttributes o2) {
            String giverSection1 = o1.giverSection;
            String giverSection2 = o2.giverSection;
            int order = giverSection1.compareTo(giverSection2);
            if (order != 0) {
                return order;
            }

            boolean isGiverVisible1 = isGiverVisible(o1);
            boolean isGiverVisible2 = isGiverVisible(o2);

            String giverName1 = emailNameTable.get(o1.giver);
            String giverName2 = emailNameTable.get(o2.giver);
            order = compareByNames(giverName1, giverName2, isGiverVisible1, isGiverVisible2);
            if (order != 0) {
                return order;
            }

            order = compareByQuestionNumber(o1, o2);
            if (order != 0) {
                return order;
            }

            boolean isRecipientVisible1 = isRecipientVisible(o1);
            boolean isRecipientVisible2 = isRecipientVisible(o2);

            String t1 = getTeamNameForEmail(o1.recipient).isEmpty() ? getNameForEmail(o1.recipient)
                                                                    : getTeamNameForEmail(o1.recipient);
            String t2 = getTeamNameForEmail(o2.recipient).isEmpty() ? getNameForEmail(o2.recipient)
                                                                    : getTeamNameForEmail(o2.recipient);
            order = compareByNames(t1, t2, isRecipientVisible1, isRecipientVisible2);
            if (order != 0) {
                return order;
            }

            String recipientName1 = emailNameTable.get(o1.recipient);
            String recipientName2 = emailNameTable.get(o2.recipient);
            order = compareByNames(recipientName1, recipientName2, isRecipientVisible1, isRecipientVisible2);

            if (order != 0) {
                return order;
            }
            order = compareByResponseString(o1, o2);
            if (order != 0) {
                return order;
            }

            return o1.getId().compareTo(o2.getId());
        }
    };

    // Sorts by giverTeam > giverName > question > recipientTeam > recipientName
    private Comparator<FeedbackResponseAttributes> compareByTeamGiverQuestionTeamRecipient =
            new Comparator<FeedbackResponseAttributes>() {
        @Override
        public int compare(FeedbackResponseAttributes o1, FeedbackResponseAttributes o2) {
            String giverSection1 = o1.giverSection;
            String giverSection2 = o2.giverSection;
            int order = giverSection1.compareTo(giverSection2);
            if (order != 0) {
                return order;
            }

            boolean isGiverVisible1 = isGiverVisible(o1);
            boolean isGiverVisible2 = isGiverVisible(o2);

            String giverTeam1 = getTeamNameForEmail(o1.giver).isEmpty() ? getNameForEmail(o1.giver)
                                                                        : getTeamNameForEmail(o1.giver);
            String giverTeam2 = getTeamNameForEmail(o2.giver).isEmpty() ? getNameForEmail(o2.giver)
                                                                        : getTeamNameForEmail(o2.giver);
            order = compareByNames(giverTeam1, giverTeam2, isGiverVisible1, isGiverVisible2);
            if (order != 0) {
                return order;
            }

            String giverName1 = emailNameTable.get(o1.giver);
            String giverName2 = emailNameTable.get(o2.giver);
            order = compareByNames(giverName1, giverName2, isGiverVisible1, isGiverVisible2);
            if (order != 0) {
                return order;
            }

            order = compareByQuestionNumber(o1, o2);
            if (order != 0) {
                return order;
            }

            boolean isRecipientVisible1 = isRecipientVisible(o1);
            boolean isRecipientVisible2 = isRecipientVisible(o2);

            String receiverTeam1 = getTeamNameForEmail(o1.recipient).isEmpty() ? getNameForEmail(o1.recipient)
                                                                               : getTeamNameForEmail(o1.recipient);
            String receiverTeam2 = getTeamNameForEmail(o2.recipient).isEmpty() ? getNameForEmail(o2.recipient)
                                                                               : getTeamNameForEmail(o2.recipient);
            order = compareByNames(receiverTeam1, receiverTeam2, isRecipientVisible1, isRecipientVisible2);
            if (order != 0) {
                return order;
            }

            String recipientName1 = emailNameTable.get(o1.recipient);
            String recipientName2 = emailNameTable.get(o2.recipient);
            order = compareByNames(recipientName1, recipientName2, isRecipientVisible1, isRecipientVisible2);

            if (order != 0) {
                return order;
            }
            order = compareByResponseString(o1, o2);
            if (order != 0) {
                return order;
            }

            return o1.getId().compareTo(o2.getId());
        }
    };

    // Sorts by recipientName > question > giverTeam > giverName
    private final Comparator<FeedbackResponseAttributes> compareByRecipientQuestionTeamGiver =
            new Comparator<FeedbackResponseAttributes>() {
        @Override
        public int compare(FeedbackResponseAttributes o1, FeedbackResponseAttributes o2) {
            String recipientSection1 = o1.recipientSection;
            String recipientSection2 = o2.recipientSection;
            int order = recipientSection1.compareTo(recipientSection2);
            if (order != 0) {
                return order;
            }

            boolean isRecipientVisible1 = isRecipientVisible(o1);
            boolean isRecipientVisible2 = isRecipientVisible(o2);

            String recipientName1 = emailNameTable.get(o1.recipient);
            String recipientName2 = emailNameTable.get(o2.recipient);
            order = compareByNames(recipientName1, recipientName2, isRecipientVisible1, isRecipientVisible2);
            if (order != 0) {
                return order;
            }

            order = compareByQuestionNumber(o1, o2);
            if (order != 0) {
                return order;
            }

            boolean isGiverVisible1 = isGiverVisible(o1);
            boolean isGiverVisible2 = isGiverVisible(o2);

            String t1 = getTeamNameForEmail(o1.giver).isEmpty() ? getNameForEmail(o1.giver)
                                                                : getTeamNameForEmail(o1.giver);
            String t2 = getTeamNameForEmail(o2.giver).isEmpty() ? getNameForEmail(o2.giver)
                                                                : getTeamNameForEmail(o2.giver);
            order = compareByNames(t1, t2, isGiverVisible1, isGiverVisible2);
            if (order != 0) {
                return order;
            }

            String giverName1 = emailNameTable.get(o1.giver);
            String giverName2 = emailNameTable.get(o2.giver);
            order = compareByNames(giverName1, giverName2, isGiverVisible1, isGiverVisible2);
            if (order != 0) {
                return order;
            }
            order = compareByResponseString(o1, o2);
            if (order != 0) {
                return order;
            }

            return o1.getId().compareTo(o2.getId());

        }
    };

    // Sorts by recipientTeam > recipientName > question > giverTeam > giverName
    private Comparator<FeedbackResponseAttributes> compareByTeamRecipientQuestionTeamGiver =
            new Comparator<FeedbackResponseAttributes>() {
        @Override
        public int compare(FeedbackResponseAttributes o1, FeedbackResponseAttributes o2) {

            String recipientSection1 = o1.recipientSection;
            String recipientSection2 = o2.recipientSection;
            int order = recipientSection1.compareTo(recipientSection2);
            if (order != 0) {
                return order;
            }

            boolean isRecipientVisible1 = isRecipientVisible(o1);
            boolean isRecipientVisible2 = isRecipientVisible(o2);
            String recipientTeam1 = getTeamNameForEmail(o1.recipient).isEmpty() ? getNameForEmail(o1.recipient)
                                                                                : getTeamNameForEmail(o1.recipient);
            String recipientTeam2 = getTeamNameForEmail(o2.recipient).isEmpty() ? getNameForEmail(o2.recipient)
                                                                                : getTeamNameForEmail(o2.recipient);
            order = compareByNames(recipientTeam1, recipientTeam2, isRecipientVisible1, isRecipientVisible2);
            if (order != 0) {
                return order;
            }

            String recipientName1 = emailNameTable.get(o1.recipient);
            String recipientName2 = emailNameTable.get(o2.recipient);
            order = compareByNames(recipientName1, recipientName2, isRecipientVisible1, isRecipientVisible2);
            if (order != 0) {
                return order;
            }

            order = compareByQuestionNumber(o1, o2);
            if (order != 0) {
                return order;
            }

            boolean isGiverVisible1 = isGiverVisible(o1);
            boolean isGiverVisible2 = isGiverVisible(o2);

            String giverTeam1 = getTeamNameForEmail(o1.giver).isEmpty() ? getNameForEmail(o1.giver)
                                                                        : getTeamNameForEmail(o1.giver);
            String giverTeam2 = getTeamNameForEmail(o2.giver).isEmpty() ? getNameForEmail(o2.giver)
                                                                        : getTeamNameForEmail(o2.giver);
            order = compareByNames(giverTeam1, giverTeam2, isGiverVisible1, isGiverVisible2);
            if (order != 0) {
                return order;
            }

            String giverName1 = emailNameTable.get(o1.giver);
            String giverName2 = emailNameTable.get(o2.giver);
            order = compareByNames(giverName1, giverName2, isGiverVisible1, isGiverVisible2);
            if (order != 0) {
                return order;
            }
            order = compareByResponseString(o1, o2);
            if (order != 0) {
                return order;
            }

            return o1.getId().compareTo(o2.getId());
        }
    };

    // Sorts by recipientTeam > question > recipientName > giverTeam > giverName
    private Comparator<FeedbackResponseAttributes> compareByTeamQuestionRecipientTeamGiver =
            new Comparator<FeedbackResponseAttributes>() {
        @Override
        public int compare(FeedbackResponseAttributes o1, FeedbackResponseAttributes o2) {
            boolean isRecipientVisible1 = isRecipientVisible(o1);
            boolean isRecipientVisible2 = isRecipientVisible(o2);
            String recipientTeam1 = getTeamNameForEmail(o1.recipient).isEmpty() ? getNameForEmail(o1.recipient)
                                                                                : getTeamNameForEmail(o1.recipient);
            String recipientTeam2 = getTeamNameForEmail(o2.recipient).isEmpty() ? getNameForEmail(o2.recipient)
                                                                                : getTeamNameForEmail(o2.recipient);
            int order = compareByNames(recipientTeam1, recipientTeam2, isRecipientVisible1, isRecipientVisible2);
            if (order != 0) {
                return order;
            }

            order = compareByQuestionNumber(o1, o2);
            if (order != 0) {
                return order;
            }

            String recipientName1 = emailNameTable.get(o1.recipient);
            String recipientName2 = emailNameTable.get(o2.recipient);
            order = compareByNames(recipientName1, recipientName2, isRecipientVisible1, isRecipientVisible2);
            if (order != 0) {
                return order;
            }

            String giverTeam1 = getTeamNameForEmail(o1.giver).isEmpty() ? getNameForEmail(o1.giver)
                                                                        : getTeamNameForEmail(o1.giver);
            String giverTeam2 = getTeamNameForEmail(o2.giver).isEmpty() ? getNameForEmail(o2.giver)
                                                                        : getTeamNameForEmail(o2.giver);
            order = compareByNames(giverTeam1, giverTeam2, isRecipientVisible1, isRecipientVisible2);
            if (order != 0) {
                return order;
            }

            boolean isGiverVisible1 = isGiverVisible(o1);
            boolean isGiverVisible2 = isGiverVisible(o2);
            String giverName1 = emailNameTable.get(o1.giver);
            String giverName2 = emailNameTable.get(o2.giver);
            order = compareByNames(giverName1, giverName2, isGiverVisible1, isGiverVisible2);
            if (order != 0) {
                return order;
            }

            order = compareByResponseString(o1, o2);
            if (order != 0) {
                return order;
            }

            return o1.getId().compareTo(o2.getId());
        }
    };

    // Sorts by giverTeam > question > giverName > recipientTeam > recipientName
    private Comparator<FeedbackResponseAttributes> compareByTeamQuestionGiverTeamRecipient =
            new Comparator<FeedbackResponseAttributes>() {
        @Override
        public int compare(FeedbackResponseAttributes o1, FeedbackResponseAttributes o2) {
            boolean isGiverVisible1 = isGiverVisible(o1);
            boolean isGiverVisible2 = isGiverVisible(o2);

            String giverTeam1 = getTeamNameForEmail(o1.giver).isEmpty() ? getNameForEmail(o1.giver)
                                                                        : getTeamNameForEmail(o1.giver);
            String giverTeam2 = getTeamNameForEmail(o2.giver).isEmpty() ? getNameForEmail(o2.giver)
                                                                        : getTeamNameForEmail(o2.giver);
            int order = compareByNames(giverTeam1, giverTeam2, isGiverVisible1, isGiverVisible2);
            if (order != 0) {
                return order;
            }

            order = compareByQuestionNumber(o1, o2);
            if (order != 0) {
                return order;
            }

            String giverName1 = emailNameTable.get(o1.giver);
            String giverName2 = emailNameTable.get(o2.giver);
            order = compareByNames(giverName1, giverName2, isGiverVisible1, isGiverVisible2);
            if (order != 0) {
                return order;
            }

            boolean isRecipientVisible1 = isRecipientVisible(o1);
            boolean isRecipientVisible2 = isRecipientVisible(o2);

            String receiverTeam1 = getTeamNameForEmail(o1.recipient).isEmpty() ? getNameForEmail(o1.recipient)
                                                                               : getTeamNameForEmail(o1.recipient);
            String receiverTeam2 = getTeamNameForEmail(o2.recipient).isEmpty() ? getNameForEmail(o2.recipient)
                                                                               : getTeamNameForEmail(o2.recipient);
            order = compareByNames(receiverTeam1, receiverTeam2, isRecipientVisible1, isRecipientVisible2);
            if (order != 0) {
                return order;
            }

            String recipientName1 = emailNameTable.get(o1.recipient);
            String recipientName2 = emailNameTable.get(o2.recipient);
            order = compareByNames(recipientName1, recipientName2, isRecipientVisible1, isRecipientVisible2);

            if (order != 0) {
                return order;
            }

            order = compareByResponseString(o1, o2);
            if (order != 0) {
                return order;
            }

            return o1.getId().compareTo(o2.getId());
        }
    };

    // Sorts by recipientName > recipientEmail > giverName > giverEmail
    private Comparator<FeedbackResponseAttributes> compareByRecipientNameEmailGiverNameEmail =
            new Comparator<FeedbackResponseAttributes>() {
        @Override
        public int compare(FeedbackResponseAttributes o1, FeedbackResponseAttributes o2) {

            boolean isRecipientVisible1 = isRecipientVisible(o1);
            boolean isRecipientVisible2 = isRecipientVisible(o2);
            // Compare by Recipient Name
            int recipientNameCompareResult = compareByNames(getNameForEmail(o1.recipient),
                                                            getNameForEmail(o2.recipient),
                                                            isRecipientVisible1, isRecipientVisible2);
            if (recipientNameCompareResult != 0) {
                return recipientNameCompareResult;
            }

            // Compare by Recipient Email
            int recipientEmailCompareResult = compareByNames(o1.recipient, o2.recipient,
                                                             isRecipientVisible1, isRecipientVisible2);
            if (recipientEmailCompareResult != 0) {
                return recipientEmailCompareResult;
            }

            boolean isGiverVisible1 = isGiverVisible(o1);
            boolean isGiverVisible2 = isGiverVisible(o2);
            // Compare by Giver Name
            int giverNameCompareResult = compareByNames(getNameForEmail(o1.giver),
                                                        getNameForEmail(o2.giver),
                                                        isGiverVisible1, isGiverVisible2);
            if (giverNameCompareResult != 0) {
                return giverNameCompareResult;
            }

            // Compare by Giver Email
            int giverEmailCompareResult = compareByNames(o1.giver, o2.giver,
                                                         isGiverVisible1, isGiverVisible2);
            if (giverEmailCompareResult != 0) {
                return giverEmailCompareResult;
            }

            int responseStringResult = compareByResponseString(o1, o2);
            if (responseStringResult != 0) {
                return responseStringResult;
            }

            return o1.getId().compareTo(o2.getId());
        }
    };

    public FeedbackSessionResultsBundle(FeedbackSessionAttributes feedbackSession,
            Map<String, FeedbackQuestionAttributes> questions, CourseRoster roster) {
        this(feedbackSession, new ArrayList<FeedbackResponseAttributes>(), questions, new HashMap<String, String>(),
             new HashMap<String, String>(), new HashMap<String, String>(), new HashMap<String, Set<String>>(),
             new HashMap<String, boolean[]>(), new FeedbackSessionResponseStatus(), roster,
             new HashMap<String, List<FeedbackResponseCommentAttributes>>());
    }

    public FeedbackSessionResultsBundle(FeedbackSessionAttributes feedbackSession,
                                        List<FeedbackResponseAttributes> responses,
                                        Map<String, FeedbackQuestionAttributes> questions,
                                        Map<String, String> emailNameTable,
                                        Map<String, String> emailLastNameTable,
                                        Map<String, String> emailTeamNameTable,
                                        Map<String, Set<String>> sectionTeamNameTable,
                                        Map<String, boolean[]> visibilityTable,
                                        FeedbackSessionResponseStatus responseStatus,
                                        CourseRoster roster,
                                        Map<String, List<FeedbackResponseCommentAttributes>> responseComments) {
        this(feedbackSession, responses, questions, emailNameTable, emailLastNameTable,
             emailTeamNameTable, sectionTeamNameTable, visibilityTable, responseStatus, roster, responseComments, true);
    }

    public FeedbackSessionResultsBundle(FeedbackSessionAttributes feedbackSession,
                                        List<FeedbackResponseAttributes> responses,
                                        Map<String, FeedbackQuestionAttributes> questions,
                                        Map<String, String> emailNameTable,
                                        Map<String, String> emailLastNameTable,
                                        Map<String, String> emailTeamNameTable,
                                        Map<String, Set<String>> sectionTeamNameTable,
                                        Map<String, boolean[]> visibilityTable,
                                        FeedbackSessionResponseStatus responseStatus,
                                        CourseRoster roster,
                                        Map<String, List<FeedbackResponseCommentAttributes>> responseComments,
                                        boolean isComplete) {
        this.feedbackSession = feedbackSession;
        this.questions = questions;
        this.responses = responses;
        this.emailNameTable = emailNameTable;
        this.emailLastNameTable = emailLastNameTable;
        this.emailTeamNameTable = emailTeamNameTable;
        this.instructorEmailNameTable = getInstructorEmailNameTableFromRoster(roster);
        this.sectionTeamNameTable = sectionTeamNameTable;
        this.visibilityTable = visibilityTable;
        this.responseStatus = responseStatus;
        this.roster = roster;
        this.responseComments = responseComments;
        this.actualResponses = new ArrayList<>();

        // We change user email to team name here for display purposes.
        for (FeedbackResponseAttributes response : responses) {
            if (questions.get(response.feedbackQuestionId).giverType == FeedbackParticipantType.TEAMS
                    && roster.isStudentInCourse(response.giver)) {
                // for TEAMS giver type, for older responses,
                // the giverEmail is stored as the student giver's email in the database
                // so we convert it to the team name for use in FeedbackSessionResultsBundle
                response.giver = emailNameTable.get(response.giver + Const.TEAM_OF_EMAIL_OWNER);
            }
            // Copy the data before hiding response recipient and giver.
            FeedbackResponseAttributes fraCopy = new FeedbackResponseAttributes(response);
            actualResponses.add(fraCopy);
        }
        this.isComplete = isComplete;

        hideResponsesGiverRecipient();
        // unlike emailTeamNameTable, emailLastNameTable and emailTeamNameTable,
        // roster.*Table is populated using the CourseRoster data directly
        this.rosterTeamNameMembersTable = getTeamNameToEmailsTableFromRoster(roster);
        this.rosterSectionTeamNameTable = getSectionToTeamNamesFromRoster(roster);
    }

    /**
     * Hides response names/emails and teams that are not visible to the current user.
     * Replaces the giver/recipient email in responses to an email with two ""@@""s
     * to indicate it is invalid and should not be displayed.
     */
    private void hideResponsesGiverRecipient() {
        for (FeedbackResponseAttributes response : responses) {
            // Hide recipient details if its not visible to the current user
            String name = emailNameTable.get(response.recipient);
            FeedbackQuestionAttributes question = questions.get(response.feedbackQuestionId);
            FeedbackParticipantType participantType = question.recipientType;

            if (!isRecipientVisible(response)) {
                String anonEmail = getAnonEmail(participantType, name);
                name = getAnonName(participantType, name);

                emailNameTable.put(anonEmail, name);
                emailTeamNameTable.put(anonEmail, name + Const.TEAM_OF_EMAIL_OWNER);

                response.recipient = anonEmail;
            }

            // Hide giver details if its not visible to the current user
            name = emailNameTable.get(response.giver);
            participantType = question.giverType;

            if (!isGiverVisible(response)) {
                String anonEmail = getAnonEmail(participantType, name);
                name = getAnonName(participantType, name);

                emailNameTable.put(anonEmail, name);
                emailTeamNameTable.put(anonEmail, name + Const.TEAM_OF_EMAIL_OWNER);
                if (participantType == FeedbackParticipantType.TEAMS) {
                    emailTeamNameTable.put(anonEmail, name);
                }
                response.giver = anonEmail;
            }
        }
    }

    /**
     * Checks if the giver/recipient for a response is visible/hidden from the current user.
     */
    public boolean isFeedbackParticipantVisible(boolean isGiver, FeedbackResponseAttributes response) {
        FeedbackQuestionAttributes question = questions.get(response.feedbackQuestionId);
        FeedbackParticipantType participantType;
        String responseId = response.getId();

        boolean isVisible;
        if (isGiver) {
            isVisible = visibilityTable.get(responseId)[Const.VISIBILITY_TABLE_GIVER];
            participantType = question.giverType;
        } else {
            isVisible = visibilityTable.get(responseId)[Const.VISIBILITY_TABLE_RECIPIENT];
            participantType = question.recipientType;
        }
        boolean isTypeSelf = participantType == FeedbackParticipantType.SELF;
        boolean isTypeNone = participantType == FeedbackParticipantType.NONE;

        return isVisible || isTypeSelf || isTypeNone;
    }

    /**
     * Returns true if the recipient from a response is visible to the current user.
     * Returns false otherwise.
     */
    public boolean isRecipientVisible(FeedbackResponseAttributes response) {
        return isFeedbackParticipantVisible(false, response);
    }

    /**
     * Returns true if the giver from a response is visible to the current user.
     * Returns false otherwise.
     */
    public boolean isGiverVisible(FeedbackResponseAttributes response) {
        return isFeedbackParticipantVisible(true, response);
    }

    public static String getAnonEmail(FeedbackParticipantType type, String name) {
        String anonName = getAnonName(type, name);
        return anonName + ""@@"" + anonName + "".com"";
    }

    public String getAnonEmailFromStudentEmail(String studentEmail) {
        String name = roster.getStudentForEmail(studentEmail).name;
        return getAnonEmail(FeedbackParticipantType.STUDENTS, name);
    }

    public String getAnonNameWithoutNumericalId(FeedbackParticipantType type) {
        return ""Anonymous "" + type.toSingularFormString();
    }

    public static String getAnonName(FeedbackParticipantType type, String name) {
        String hashedEncryptedName = getHashOfName(getEncryptedName(name));
        String participantType = type.toSingularFormString();
        return String.format(""Anonymous %s %s"", participantType, hashedEncryptedName);
    }

    private static String getEncryptedName(String name) {
        return StringHelper.encrypt(name);
    }

    private static String getHashOfName(String name) {
        return Long.toString(Math.abs((long) name.hashCode()));
    }

    private String getNameFromRoster(String participantIdentifier, boolean isFullName) {
        if (participantIdentifier.equals(Const.GENERAL_QUESTION)) {
            return Const.USER_NOBODY_TEXT;
        }

        // return person name if participant is a student
        if (isParticipantIdentifierStudent(participantIdentifier)) {
            StudentAttributes student = roster.getStudentForEmail(participantIdentifier);
            if (isFullName) {
                return student.name;
            }
            return student.lastName;
        }

        // return person name if participant is an instructor
        if (isParticipantIdentifierInstructor(participantIdentifier)) {
            return roster.getInstructorForEmail(participantIdentifier)
                         .name;
        }

        // return team name if participantIdentifier is a team name
        boolean isTeamName = rosterTeamNameMembersTable.containsKey(participantIdentifier);
        if (isTeamName) {
            return participantIdentifier;
        }

        // return team name if participant is team identified by a member
        boolean isNameRepresentingStudentsTeam = participantIdentifier.contains(Const.TEAM_OF_EMAIL_OWNER);
        if (isNameRepresentingStudentsTeam) {
            int index = participantIdentifier.indexOf(Const.TEAM_OF_EMAIL_OWNER);
            return getTeamNameFromRoster(participantIdentifier.substring(0, index));
        }

        return """";
    }

    /**
     * Get the displayable full name from an email.
     *
     * <p>This function is different from {@link #getNameForEmail} as it obtains the name
     * using the class roster, instead of from the responses.
     * @return the full name of a student, if participantIdentifier is the email of a student, <br>
     *         the name of an instructor, if participantIdentifier is the email of an instructor, <br>
     *         or the team name, if participantIdentifier represents a team. <br>
     *         Otherwise, return an empty string
     */
    public String getFullNameFromRoster(String participantIdentifier) {
        return getNameFromRoster(participantIdentifier, true);
    }

    /**
     * Get the displayable last name from an email.
     *
     * <p>This function is different from {@link #getLastNameForEmail} as it obtains the name
     * using the class roster, instead of from the responses.
     * @return the last name of a student, if participantIdentifier is the email of a student, <br>
     *         the name of an instructor, if participantIdentifier is the email of an instructor, <br>
     *         or the team name, if participantIdentifier represents a team. <br>
     *         Otherwise, return an empty string
     */
    public String getLastNameFromRoster(String participantIdentifier) {
        return getNameFromRoster(participantIdentifier, false);
    }

    /**
     * Return true if the participantIdentifier is an email of either a student
     * or instructor in the course roster. Otherwise, return false.
     *
     * @return true if the participantIdentifier is an email of either a student
     *         or instructor in the course roster, false otherwise.
     */
    public boolean isEmailOfPersonFromRoster(String participantIdentifier) {
        boolean isStudent = isParticipantIdentifierStudent(participantIdentifier);
        boolean isInstructor = isParticipantIdentifierInstructor(participantIdentifier);
        return isStudent || isInstructor;
    }

    /**
     * If the participantIdentifier identifies a student or instructor,
     * the participantIdentifier is returned.
     *
     * <p>Otherwise, Const.USER_NOBODY_TEXT is returned.
     * @see #getDisplayableEmail
     */
    public String getDisplayableEmailFromRoster(String participantIdentifier) {
        if (isEmailOfPersonFromRoster(participantIdentifier)) {
            return participantIdentifier;
        }
        return Const.USER_NOBODY_TEXT;
    }

    /**
     * Get the displayable team name from an email.
     * If the email is not an email of someone in the class roster, an empty string is returned.
     *
     * <p>This function is different from {@link #getTeamNameForEmail} as it obtains the name
     * using the class roster, instead of from the responses.
     */
    public String getTeamNameFromRoster(String participantIdentifier) {
        if (participantIdentifier.equals(Const.GENERAL_QUESTION)) {
            return Const.USER_NOBODY_TEXT;
        }
        if (isParticipantIdentifierStudent(participantIdentifier)) {
            return roster.getStudentForEmail(participantIdentifier).team;
        } else if (isParticipantIdentifierInstructor(participantIdentifier)) {
            return Const.USER_TEAM_FOR_INSTRUCTOR;
        } else {
            return """";
        }
    }

    /**
     * Get the displayable section name from an email.
     *
     * <p>If the email is not an email of someone in the class roster, an empty string is returned.
     *
     * <p>If the email of an instructor or ""%GENERAL%"" is passed in, ""No specific recipient"" is returned.
     */
    public String getSectionFromRoster(String participantIdentifier) {
        boolean isStudent = isParticipantIdentifierStudent(participantIdentifier);
        boolean isInstructor = isParticipantIdentifierInstructor(participantIdentifier);
        boolean participantIsGeneral = participantIdentifier.equals(Const.GENERAL_QUESTION);

        if (isStudent) {
            return roster.getStudentForEmail(participantIdentifier)
                         .section;
        } else if (isInstructor || participantIsGeneral) {
            return Const.NO_SPECIFIC_RECIPIENT;
        } else {
            return """";
        }
    }

    /**
     * Get the emails of the students given a teamName,
     * if teamName is ""Instructors"", returns the list of instructors.
     * @return a set of emails of the students in the team
     */
    public Set<String> getTeamMembersFromRoster(String teamName) {
        if (!rosterTeamNameMembersTable.containsKey(teamName)) {
            return new HashSet<>();
        }

        return new HashSet<>(rosterTeamNameMembersTable.get(teamName));
    }

    /**
     * Get the team names in a section. <br>
     *
     * <p>Instructors are not contained in any section.
     * @return a set of team names of the teams in the section
     */
    public Set<String> getTeamsInSectionFromRoster(String sectionName) {
        if (rosterSectionTeamNameTable.containsKey(sectionName)) {
            return new HashSet<>(rosterSectionTeamNameTable.get(sectionName));
        }
        return new HashSet<>();
    }

    public boolean isParticipantIdentifierStudent(String participantIdentifier) {
        StudentAttributes student = roster.getStudentForEmail(participantIdentifier);
        return student != null;
    }

    public boolean isParticipantIdentifierInstructor(String participantIdentifier) {
        InstructorAttributes instructor = roster.getInstructorForEmail(participantIdentifier);
        return instructor != null;
    }

    /**
     * Get the possible givers for a recipient specified by its participant identifier for
     * a question.
     *
     * @return a list of participant identifiers that can give a response to the recipient specified
     */
    public List<String> getPossibleGivers(FeedbackQuestionAttributes fqa,
                                          String recipientParticipantIdentifier) {
        if (recipientParticipantIdentifier.contains(""@@"")) {
            return new ArrayList<>();
        }

        if (isParticipantIdentifierStudent(recipientParticipantIdentifier)) {
            StudentAttributes student = roster.getStudentForEmail(recipientParticipantIdentifier);
            return getPossibleGivers(fqa, student);
        } else if (isParticipantIdentifierInstructor(recipientParticipantIdentifier)) {
            return getPossibleGiversForInstructor(fqa);
        } else if (recipientParticipantIdentifier.equals(Const.GENERAL_QUESTION)) {
            switch (fqa.giverType) {
            case STUDENTS:
                return getSortedListOfStudentEmails();
            case TEAMS:
                return getSortedListOfTeams();
            case INSTRUCTORS:
                return getSortedListOfInstructorEmails();
            case SELF:
                List<String> creatorEmail = new ArrayList<>();
                creatorEmail.add(fqa.creatorEmail);
                return creatorEmail;
            default:
                log.severe(""Invalid giver type specified"");
                return new ArrayList<>();
            }
        } else {
            return getPossibleGiversForTeam(fqa, recipientParticipantIdentifier);
        }
    }

    /**
     * Get the possible givers for a TEAM recipient for the question specified.
     * @return a list of possible givers that can give a response to the team
     *         specified as the recipient
     */
    private List<String> getPossibleGiversForTeam(FeedbackQuestionAttributes fqa,
                                                  String recipientTeam) {
        FeedbackParticipantType giverType = fqa.giverType;
        FeedbackParticipantType recipientType = fqa.recipientType;
        List<String> possibleGivers = new ArrayList<>();

        if (recipientType == FeedbackParticipantType.TEAMS) {
            switch (giverType) {
            case TEAMS:
                possibleGivers = getSortedListOfTeams();
                break;
            case STUDENTS:
                possibleGivers = getSortedListOfStudentEmails();
                break;
            case INSTRUCTORS:
                possibleGivers = getSortedListOfInstructorEmails();
                break;
            case SELF:
                possibleGivers.add(fqa.creatorEmail);
                break;
            default:
                log.severe(""Invalid giver type specified"");
                break;
            }
        } else if (recipientType == FeedbackParticipantType.OWN_TEAM) {
            if (giverType == FeedbackParticipantType.TEAMS) {
                possibleGivers.add(recipientTeam);
            } else {
                possibleGivers = new ArrayList<>(getTeamMembersFromRoster(recipientTeam));
            }
        }

        return possibleGivers;
    }

    /**
     * Get the possible givers for a STUDENT recipient for the question specified.
     * @return a list of possible givers that can give a response to the student
     *         specified as the recipient
     */
    private List<String> getPossibleGivers(FeedbackQuestionAttributes fqa,
                                           StudentAttributes studentRecipient) {
        FeedbackParticipantType giverType = fqa.giverType;
        FeedbackParticipantType recipientType = fqa.recipientType;
        List<String> possibleGivers = new ArrayList<>();

        switch (giverType) {
        case STUDENTS:
            possibleGivers = getSortedListOfStudentEmails();
            break;
        case INSTRUCTORS:
            possibleGivers = getSortedListOfInstructorEmails();
            break;
        case TEAMS:
            possibleGivers = getSortedListOfTeams();
            break;
        case SELF:
            possibleGivers.add(fqa.creatorEmail);
            break;
        default:
            log.severe(""Invalid giver type specified"");
            break;
        }

        switch (recipientType) {
        case STUDENTS:
        case TEAMS:
            break;
        case SELF:
            possibleGivers = new ArrayList<>();
            possibleGivers.add(studentRecipient.email);
            break;
        case OWN_TEAM_MEMBERS:
            possibleGivers.retainAll(getSortedListOfTeamMembersEmailsExcludingSelf(studentRecipient));
            break;
        case OWN_TEAM_MEMBERS_INCLUDING_SELF:
            possibleGivers.retainAll(getSortedListOfTeamMembersEmails(studentRecipient));
            break;
        default:
            break;
        }

        return possibleGivers;
    }

    /**
     * Get the possible givers for a INSTRUCTOR recipient for the question specified.
     * @return a list of possible givers that can give a response to the instructor
     *         specified as the recipient
     */
    private List<String> getPossibleGiversForInstructor(FeedbackQuestionAttributes fqa) {
        FeedbackParticipantType giverType = fqa.giverType;
        List<String> possibleGivers = new ArrayList<>();

        switch (giverType) {
        case STUDENTS:
            possibleGivers = getSortedListOfStudentEmails();
            break;
        case INSTRUCTORS:
            possibleGivers = getSortedListOfInstructorEmails();
            break;
        case TEAMS:
            possibleGivers = getSortedListOfTeams();
            break;
        case SELF:
            possibleGivers.add(fqa.creatorEmail);
            break;
        default:
            log.severe(""Invalid giver type specified"");
            break;
        }

        return possibleGivers;
    }

    public List<String> getPossibleGivers(FeedbackQuestionAttributes fqa) {
        FeedbackParticipantType giverType = fqa.giverType;
        List<String> possibleGivers = new ArrayList<>();

        switch (giverType) {
        case STUDENTS:
            possibleGivers = getSortedListOfStudentEmails();
            break;
        case INSTRUCTORS:
            possibleGivers = getSortedListOfInstructorEmails();
            break;
        case TEAMS:
            possibleGivers = getSortedListOfTeams();
            break;
        case SELF:
            possibleGivers = new ArrayList<>();
            possibleGivers.add(fqa.creatorEmail);
            break;
        default:
            log.severe(""Invalid giver type specified"");
            break;
        }

        return possibleGivers;
    }

    public List<String> getPossibleRecipients(FeedbackQuestionAttributes fqa) {
        FeedbackParticipantType recipientType = fqa.recipientType;
        List<String> possibleRecipients = null;

        // use giver type to determine recipients if recipient is ""self""
        if (fqa.recipientType == FeedbackParticipantType.SELF) {
            recipientType = fqa.giverType;
        }

        switch (recipientType) {
        case STUDENTS:
        case OWN_TEAM_MEMBERS:
        case OWN_TEAM_MEMBERS_INCLUDING_SELF:
            possibleRecipients = getSortedListOfStudentEmails();
            break;
        case INSTRUCTORS:
            possibleRecipients = getSortedListOfInstructorEmails();
            break;
        case TEAMS:
        case OWN_TEAM:
            possibleRecipients = getSortedListOfTeams();
            break;
        case NONE:
            possibleRecipients = new ArrayList<>();
            possibleRecipients.add(Const.USER_NOBODY_TEXT);
            break;
        default:
            log.severe(""Invalid recipient type specified"");
            break;
        }

        return possibleRecipients;
    }

    // TODO code duplication between this function and in FeedbackQuestionsLogic getRecipientsForQuestion
    /**
     * Get the possible recipients for a giver for the question specified.
     * @return a list of possible recipients that can receive a response from giver specified by
     *         the participantIdentifier
     */
    public List<String> getPossibleRecipients(FeedbackQuestionAttributes fqa,
                                              String giverParticipantIdentifier) {
        if (giverParticipantIdentifier.contains(""@@"")) {
            return new ArrayList<>();
        }

        if (isParticipantIdentifierStudent(giverParticipantIdentifier)) {
            StudentAttributes student = roster.getStudentForEmail(giverParticipantIdentifier);
            return getPossibleRecipients(fqa, student);
        } else if (isParticipantIdentifierInstructor(giverParticipantIdentifier)) {
            InstructorAttributes instructor = roster.getInstructorForEmail(giverParticipantIdentifier);
            return getPossibleRecipients(fqa, instructor);
        } else {
            return getPossibleRecipientsForTeam(fqa, giverParticipantIdentifier);
        }
    }

    /**
     * Get the possible recipients for a INSTRUCTOR giver for the question specified.
     * @return a list of possible recipients that can receive a response from giver specified by
     *         the instructorGiver
     */
    private List<String> getPossibleRecipients(FeedbackQuestionAttributes fqa,
                                               InstructorAttributes instructorGiver) {
        FeedbackParticipantType recipientType = fqa.recipientType;
        List<String> possibleRecipients = new ArrayList<>();

        switch (recipientType) {
        case STUDENTS:
            possibleRecipients = getSortedListOfStudentEmails();
            break;
        case INSTRUCTORS:
            possibleRecipients = getSortedListOfInstructorEmails();
            possibleRecipients.remove(instructorGiver.email);
            break;
        case TEAMS:
            possibleRecipients = getSortedListOfTeams();
            break;
        case SELF:
            possibleRecipients.add(instructorGiver.email);
            break;
        case OWN_TEAM:
            possibleRecipients.add(Const.USER_TEAM_FOR_INSTRUCTOR);
            break;
        case NONE:
            possibleRecipients.add(Const.GENERAL_QUESTION);
            break;
        default:
            log.severe(""Invalid recipient type specified"");
            break;
        }

        return possibleRecipients;
    }

    /**
     * Get the possible recipients for a STUDENT giver for the question specified.
     * @return a list of possible recipients that can receive a response from giver specified by
     *         the studentGiver
     */
    private List<String> getPossibleRecipients(FeedbackQuestionAttributes fqa,
                                               StudentAttributes studentGiver) {
        FeedbackParticipantType recipientType = fqa.recipientType;
        List<String> possibleRecipients = new ArrayList<>();

        switch (recipientType) {
        case STUDENTS:
            possibleRecipients = getSortedListOfStudentEmails();
            possibleRecipients.remove(studentGiver.email);
            break;
        case OWN_TEAM_MEMBERS:
            possibleRecipients = getSortedListOfTeamMembersEmailsExcludingSelf(studentGiver);
            break;
        case OWN_TEAM_MEMBERS_INCLUDING_SELF:
            possibleRecipients = getSortedListOfTeamMembersEmails(studentGiver);
            break;
        case INSTRUCTORS:
            possibleRecipients = getSortedListOfInstructorEmails();
            break;
        case TEAMS:
            possibleRecipients = getSortedListOfTeamsExcludingOwnTeam(studentGiver);
            break;
        case OWN_TEAM:
            possibleRecipients.add(studentGiver.team);
            break;
        case SELF:
            possibleRecipients.add(studentGiver.email);
            break;
        case NONE:
            possibleRecipients.add(Const.GENERAL_QUESTION);
            break;
        default:
            log.severe(""Invalid recipient type specified"");
            break;
        }

        return possibleRecipients;
    }

    /**
     * Get the possible recipients for a TEAM giver for the question specified.
     * @return a list of possible recipients that can receive a response from giver specified by
     *         the givingTeam
     */
    private List<String> getPossibleRecipientsForTeam(FeedbackQuestionAttributes fqa,
                                                      String givingTeam) {
        FeedbackParticipantType recipientType = fqa.recipientType;
        List<String> possibleRecipients = new ArrayList<>();

        switch (recipientType) {
        case TEAMS:
            possibleRecipients = getSortedListOfTeams();
            possibleRecipients.remove(givingTeam);
            break;
        case SELF:
        case OWN_TEAM:
            possibleRecipients.add(givingTeam);
            break;
        case INSTRUCTORS:
            possibleRecipients = getSortedListOfInstructorEmails();
            break;
        case STUDENTS:
            possibleRecipients = getSortedListOfStudentEmails();
            break;
        case OWN_TEAM_MEMBERS_INCLUDING_SELF:
            if (rosterTeamNameMembersTable.containsKey(givingTeam)) {
                Set<String> studentEmailsToNames = rosterTeamNameMembersTable.get(givingTeam);
                possibleRecipients = new ArrayList<>(studentEmailsToNames);
                Collections.sort(possibleRecipients);
            }
            break;
        case NONE:
            possibleRecipients.add(Const.GENERAL_QUESTION);
            break;
        default:
            log.severe(""Invalid recipient type specified"");
            break;
        }

        return possibleRecipients;
    }

    private List<String> getSortedListOfTeamsExcludingOwnTeam(StudentAttributes student) {
        String studentTeam = student.team;
        List<String> listOfTeams = getSortedListOfTeams();
        listOfTeams.remove(studentTeam);
        return listOfTeams;
    }

    /**
     * Get a sorted list of teams for the feedback session.<br>
     * Instructors are not present as a team.
     */
    private List<String> getSortedListOfTeams() {
        List<String> teams = new ArrayList<>(rosterTeamNameMembersTable.keySet());
        teams.remove(Const.USER_TEAM_FOR_INSTRUCTOR);
        Collections.sort(teams);
        return teams;
    }

    /**
     * Get a sorted list of team members, who are in the same team as the student.<br>
     * This list includes the student.
     *
     * @return a list of team members, including the original student
     * @see #getSortedListOfTeamMembersEmailsExcludingSelf
     */
    public List<String> getSortedListOfTeamMembersEmails(StudentAttributes student) {
        String teamName = student.team;
        Set<String> teamMembersEmailsToNames = rosterTeamNameMembersTable.get(teamName);
        List<String> teamMembers = new ArrayList<>(teamMembersEmailsToNames);
        Collections.sort(teamMembers);
        return teamMembers;
    }

    /**
     * Get a sorted list of team members, who are in the same team as the student,
     * EXCLUDING the student.
     *
     * @return a list of team members, excluding the original student
     * @see #getSortedListOfTeamMembersEmails
     */
    private List<String> getSortedListOfTeamMembersEmailsExcludingSelf(StudentAttributes student) {
        List<String> teamMembers = getSortedListOfTeamMembersEmails(student);
        String currentStudentEmail = student.email;
        teamMembers.remove(currentStudentEmail);
        return teamMembers;
    }

    /**
     * Returns a list of student emails, sorted by section name.
     */
    private List<String> getSortedListOfStudentEmails() {
        List<String> emailList = new ArrayList<>();
        List<StudentAttributes> students = roster.getStudents();
        StudentAttributes.sortBySectionName(students);
        for (StudentAttributes student : students) {
            emailList.add(student.email);
        }
        return emailList;
    }

    /**
     * Returns a list of instructor emails, sorted alphabetically.
     */
    private List<String> getSortedListOfInstructorEmails() {
        List<String> emailList = new ArrayList<>();
        List<InstructorAttributes> instructors = roster.getInstructors();
        for (InstructorAttributes instructor : instructors) {
            emailList.add(instructor.email);
        }
        Collections.sort(emailList);
        return emailList;
    }

    /**
     * Used for instructor feedback results views.
     */
    public String getResponseAnswerHtml(FeedbackResponseAttributes response,
                                        FeedbackQuestionAttributes question) {
        return response.getResponseDetails().getAnswerHtml(response, question, this);
    }

    public String getResponseAnswerCsv(FeedbackResponseAttributes response,
                                       FeedbackQuestionAttributes question) {
        return response.getResponseDetails().getAnswerCsv(response, question, this);
    }

    public FeedbackResponseAttributes getActualResponse(FeedbackResponseAttributes response) {
        FeedbackResponseAttributes actualResponse = null;
        for (FeedbackResponseAttributes resp : actualResponses) {
            if (resp.getId().equals(response.getId())) {
                actualResponse = resp;
                break;
            }
        }
        return actualResponse;
    }

    public String getNameForEmail(String email) {
        String name = emailNameTable.get(email);
        if (name == null || name.equals(Const.USER_IS_MISSING)) {
            return Const.USER_UNKNOWN_TEXT;
        } else if (name.equals(Const.USER_IS_NOBODY)) {
            return Const.USER_NOBODY_TEXT;
        } else if (name.equals(Const.USER_IS_TEAM)) {
            return getTeamNameForEmail(email);
        } else {
            return name;
        }
    }

    public String getLastNameForEmail(String email) {
        String name = emailLastNameTable.get(email);
        if (name == null || name.equals(Const.USER_IS_MISSING)) {
            return Const.USER_UNKNOWN_TEXT;
        } else if (name.equals(Const.USER_IS_NOBODY)) {
            return Const.USER_NOBODY_TEXT;
        } else if (name.equals(Const.USER_IS_TEAM)) {
            return getTeamNameForEmail(email);
        } else {
            return name;
        }
    }

    public String getTeamNameForEmail(String email) {
        String teamName = emailTeamNameTable.get(email);
        if (teamName == null || email.equals(Const.GENERAL_QUESTION)) {
            return Const.USER_NOBODY_TEXT;
        }
        return teamName;
    }

    /**
     * Returns displayable email if the email of a giver/recipient in the course
     * and it is allowed to be displayed.
     * Returns Const.USER_NOBODY_TEXT otherwise.
     */
    public String getDisplayableEmail(boolean isGiver, FeedbackResponseAttributes response) {
        String participantIdentifier;
        if (isGiver) {
            participantIdentifier = response.giver;
        } else {
            participantIdentifier = response.recipient;
        }

        if (isEmailOfPerson(participantIdentifier) && isFeedbackParticipantVisible(isGiver, response)) {
            return participantIdentifier;
        }
        return Const.USER_NOBODY_TEXT;
    }

    /**
     * Returns displayable email if the email of a recipient in the course
     * and it is allowed to be displayed.
     * Returns Const.USER_NOBODY_TEXT otherwise.
     */
    public String getDisplayableEmailRecipient(FeedbackResponseAttributes response) {
        return getDisplayableEmail(false, response);
    }

    /**
     * Returns displayable email if the email of a giver in the course
     * and it is allowed to be displayed.
     * Returns Const.USER_NOBODY_TEXT otherwise.
     */
    public String getDisplayableEmailGiver(FeedbackResponseAttributes response) {
        return getDisplayableEmail(true, response);
    }

    /**
     * Returns true if the given identifier is an email of a person in the course.
     * Returns false otherwise.
     */
    public boolean isEmailOfPerson(String participantIdentifier) {
        // An email must at least contains '@' character
        boolean isIdentifierEmail = participantIdentifier.contains(""@"");

        /*
         * However, a team name may also contains '@'
         * To differentiate a team name and an email of a person,
         * we check against the name & team name associated by the participant identifier
         */
        String name = emailNameTable.get(participantIdentifier);
        boolean isIdentifierName = name != null && name.equals(participantIdentifier);
        boolean isIdentifierTeam = name != null && name.equals(Const.USER_IS_TEAM);

        String teamName = emailTeamNameTable.get(participantIdentifier);
        boolean isIdentifierTeamName = teamName != null && teamName.equals(participantIdentifier);
        return isIdentifierEmail && !(isIdentifierName || isIdentifierTeamName || isIdentifierTeam);
    }

    public String getRecipientNameForResponse(FeedbackResponseAttributes response) {
        String name = emailNameTable.get(response.recipient);
        if (name == null || name.equals(Const.USER_IS_MISSING)) {
            return Const.USER_UNKNOWN_TEXT;
        } else if (name.equals(Const.USER_IS_NOBODY)) {
            return Const.USER_NOBODY_TEXT;
        } else {
            return name;
        }
    }

    public String getGiverNameForResponse(FeedbackResponseAttributes response) {
        String name = emailNameTable.get(response.giver);
        if (name == null || name.equals(Const.USER_IS_MISSING)) {
            return Const.USER_UNKNOWN_TEXT;
        } else if (name.equals(Const.USER_IS_NOBODY)) {
            return Const.USER_NOBODY_TEXT;
        } else {
            return name;
        }
    }

    public String appendTeamNameToName(String name, String teamName) {
        String outputName;
        if (name.contains(""Anonymous"") || name.equals(Const.USER_UNKNOWN_TEXT)
                || name.equals(Const.USER_NOBODY_TEXT) || teamName.isEmpty()) {
            outputName = name;
        } else {
            outputName = name + "" ("" + teamName + "")"";
        }
        return outputName;
    }

    // TODO consider removing this to increase cohesion
    public String getQuestionText(String feedbackQuestionId) {
        return SanitizationHelper.sanitizeForHtml(questions.get(feedbackQuestionId)
                                                  .getQuestionDetails()
                                                  .getQuestionText());
    }

    // TODO: make responses to the student calling this method always on top.
    /**
     * Gets the questions and responses in this bundle as a map.
     *
     * @return An ordered {@code Map} with keys as {@link FeedbackQuestionAttributes}
     *         sorted by questionNumber.
     *         The mapped values for each key are the corresponding
     *         {@link FeedbackResponseAttributes} as a {@code List}.
     */
    public Map<FeedbackQuestionAttributes, List<FeedbackResponseAttributes>> getQuestionResponseMap() {
        if (questions == null || responses == null) {
            return null;
        }

        Map<FeedbackQuestionAttributes, List<FeedbackResponseAttributes>> sortedMap = new LinkedHashMap<>();
        List<FeedbackQuestionAttributes> sortedQuestions = new ArrayList<>(questions.values());
        // sorts the questions by its natural ordering, which is by question number
        Collections.sort(sortedQuestions);
        for (FeedbackQuestionAttributes question : sortedQuestions) {
            sortedMap.put(question, new ArrayList<FeedbackResponseAttributes>());
        }

        for (FeedbackResponseAttributes response : responses) {
            FeedbackQuestionAttributes question = questions.get(response.feedbackQuestionId);
            List<FeedbackResponseAttributes> responsesForQuestion = sortedMap.get(question);
            responsesForQuestion.add(response);
        }

        for (List<FeedbackResponseAttributes> responsesForQuestion : sortedMap.values()) {
            Collections.sort(responsesForQuestion, compareByGiverRecipient);
        }

        return sortedMap;
    }

    public Map<FeedbackQuestionAttributes, List<FeedbackResponseAttributes>> getQuestionResponseMapSortedByRecipient() {
        if (questions == null || responses == null) {
            return null;
        }

        Map<FeedbackQuestionAttributes, List<FeedbackResponseAttributes>> sortedMap = new LinkedHashMap<>();

        List<FeedbackQuestionAttributes> sortedQuestions = new ArrayList<>(questions.values());
        // sorts the questions by its natural ordering, which is by question number
        Collections.sort(sortedQuestions);
        for (FeedbackQuestionAttributes question : sortedQuestions) {
            sortedMap.put(question, new ArrayList<FeedbackResponseAttributes>());
        }

        for (FeedbackResponseAttributes response : responses) {
            FeedbackQuestionAttributes question = questions.get(response.feedbackQuestionId);
            List<FeedbackResponseAttributes> responsesForQuestion = sortedMap.get(question);
            responsesForQuestion.add(response);
        }

        for (List<FeedbackResponseAttributes> responsesForQuestion : sortedMap.values()) {
            Collections.sort(responsesForQuestion, compareByRecipientNameEmailGiverNameEmail);
        }

        return sortedMap;
    }

    /**
     * Returns an ordered Map with {@code recipientTeam} name as key
     * sorted by recipientTeam > question > recipientName > giverTeam > giverName.
     */
    public Map<String, Map<FeedbackQuestionAttributes, List<FeedbackResponseAttributes>>>
            getQuestionResponseMapByRecipientTeam() {
        LinkedHashMap<String, Map<FeedbackQuestionAttributes, List<FeedbackResponseAttributes>>> sortedMap =
                new LinkedHashMap<>();

        Collections.sort(responses, compareByTeamQuestionRecipientTeamGiver);

        for (FeedbackResponseAttributes response : responses) {
            String recipientTeam = getTeamNameForEmail(response.recipient);
            if (recipientTeam.isEmpty()) {
                recipientTeam = getNameForEmail(response.recipient);
            }

            if (!sortedMap.containsKey(recipientTeam)) {
                sortedMap.put(recipientTeam,
                        new LinkedHashMap<FeedbackQuestionAttributes, List<FeedbackResponseAttributes>>());
            }
            Map<FeedbackQuestionAttributes, List<FeedbackResponseAttributes>> responsesForOneRecipient =
                                            sortedMap.get(recipientTeam);

            FeedbackQuestionAttributes question = questions.get(response.feedbackQuestionId);
            if (!responsesForOneRecipient.containsKey(question)) {
                responsesForOneRecipient.put(question, new ArrayList<FeedbackResponseAttributes>());
            }

            List<FeedbackResponseAttributes> responsesForOneRecipientOneQuestion =
                                            responsesForOneRecipient.get(question);
            responsesForOneRecipientOneQuestion.add(response);
        }

        return sortedMap;
    }

    /**
     * Returns an ordered Map with {@code giverTeam} name as key
     * sorted by giverTeam > question > giverName > recipientTeam > recipientName.
     */
    public Map<String, Map<FeedbackQuestionAttributes, List<FeedbackResponseAttributes>>>
            getQuestionResponseMapByGiverTeam() {
        LinkedHashMap<String, Map<FeedbackQuestionAttributes, List<FeedbackResponseAttributes>>> sortedMap =
                new LinkedHashMap<>();

        Collections.sort(responses, compareByTeamQuestionGiverTeamRecipient);

        for (FeedbackResponseAttributes response : responses) {
            String giverTeam = getTeamNameForEmail(response.giver);
            if (giverTeam.isEmpty()) {
                giverTeam = getNameForEmail(response.giver);
            }

            if (!sortedMap.containsKey(giverTeam)) {
                sortedMap.put(giverTeam,
                        new LinkedHashMap<FeedbackQuestionAttributes, List<FeedbackResponseAttributes>>());
            }
            Map<FeedbackQuestionAttributes, List<FeedbackResponseAttributes>> responsesFromOneGiver =
                                            sortedMap.get(giverTeam);

            FeedbackQuestionAttributes question = questions.get(response.feedbackQuestionId);
            if (!responsesFromOneGiver.containsKey(question)) {
                responsesFromOneGiver.put(question, new ArrayList<FeedbackResponseAttributes>());
            }

            List<FeedbackResponseAttributes> responsesFromOneGiverOneQuestion = responsesFromOneGiver.get(question);
            responsesFromOneGiverOneQuestion.add(response);
        }

        return sortedMap;
    }

    /**
     * Returns responses as a {@code Map<recipientName, Map<question, List<response>>>}
     * Where the responses are sorted in the order of recipient, question, giver.
     * @return responses sorted by Recipient > Question > Giver
     */
    public Map<String, Map<FeedbackQuestionAttributes, List<FeedbackResponseAttributes>>>
            getResponsesSortedByRecipientQuestionGiver(boolean sortByTeam) {
        Map<String, Map<FeedbackQuestionAttributes, List<FeedbackResponseAttributes>>> sortedMap = new LinkedHashMap<>();

        if (sortByTeam) {
            Collections.sort(responses, compareByTeamRecipientQuestionTeamGiver);
        } else {
            Collections.sort(responses, compareByRecipientQuestionTeamGiver);
        }

        for (FeedbackResponseAttributes response : responses) {
            String recipientEmail = response.recipient;
            if (!sortedMap.containsKey(recipientEmail)) {
                sortedMap.put(recipientEmail,
                              new LinkedHashMap<FeedbackQuestionAttributes, List<FeedbackResponseAttributes>>());
            }
            Map<FeedbackQuestionAttributes, List<FeedbackResponseAttributes>> responsesForOneRecipient =
                                            sortedMap.get(recipientEmail);

            FeedbackQuestionAttributes question = questions.get(response.feedbackQuestionId);
            if (!responsesForOneRecipient.containsKey(question)) {
                responsesForOneRecipient.put(question, new ArrayList<FeedbackResponseAttributes>());
            }
            List<FeedbackResponseAttributes> responsesForOneRecipientOneQuestion =
                                            responsesForOneRecipient.get(question);
            responsesForOneRecipientOneQuestion.add(response);
        }

        return sortedMap;
    }

    /**
     * Returns the responses in this bundle as a {@code Tree} structure with no base node
     * using a {@code LinkedHashMap} implementation.
     * <br>The tree is sorted by recipientName > giverName > questionNumber.
     * <br>The key of each map represents the parent node, while the value represents the leaf.
     * <br>The top-most parent {@code String recipientName} is the recipient's name of all it's leafs.
     * <br>The inner parent {@code String giverName} is the giver's name of all it's leafs.
     * <br>The inner-most child is a {@code List<FeedbackResponseAttributes} of all the responses
     * <br>with attributes corresponding to it's parents.
     * @return The responses in this bundle sorted by recipient's name > giver's name > question number.
     */
    public Map<String, Map<String, List<FeedbackResponseAttributes>>> getResponsesSortedByRecipient() {
        return getResponsesSortedByRecipient(false);
    }

    public Map<String, Map<String, List<FeedbackResponseAttributes>>>
            getResponsesSortedByRecipient(boolean sortByTeam) {
        Map<String, Map<String, List<FeedbackResponseAttributes>>> sortedMap = new LinkedHashMap<>();

        if (sortByTeam) {
            Collections.sort(responses, compareByTeamRecipientGiverQuestion);
        } else {
            Collections.sort(responses, compareByRecipientGiverQuestion);
        }

        for (FeedbackResponseAttributes response : responses) {
            String recipientName = this.getRecipientNameForResponse(response);
            String recipientTeamName = this.getTeamNameForEmail(response.recipient);
            String recipientNameWithTeam = this.appendTeamNameToName(recipientName, recipientTeamName);
            if (!sortedMap.containsKey(recipientNameWithTeam)) {
                sortedMap.put(recipientNameWithTeam,
                        new LinkedHashMap<String, List<FeedbackResponseAttributes>>());
            }
            Map<String, List<FeedbackResponseAttributes>> responsesToOneRecipient =
                                            sortedMap.get(recipientNameWithTeam);

            String giverName = this.getGiverNameForResponse(response);
            String giverTeamName = this.getTeamNameForEmail(response.giver);
            String giverNameWithTeam = this.appendTeamNameToName(giverName, giverTeamName);
            if (!responsesToOneRecipient.containsKey(giverNameWithTeam)) {
                responsesToOneRecipient.put(giverNameWithTeam, new ArrayList<FeedbackResponseAttributes>());
            }
            List<FeedbackResponseAttributes> responsesFromOneGiverToOneRecipient =
                                            responsesToOneRecipient.get(giverNameWithTeam);
            responsesFromOneGiverToOneRecipient.add(response);
        }

        return sortedMap;
    }

    /**
     * Returns the responses in this bundle as a {@code Tree} structure with no base node
     * using a {@code LinkedHashMap} implementation.
     * <br>The tree is sorted by recipientName > giverName > questionNumber.
     * <br>The key of each map represents the parent node, while the value represents the leaf.
     * <br>The top-most parent {@code String recipientName} is the recipient's name of all it's leafs.
     * <br>The inner parent {@code String giverName} is the giver's name of all it's leafs.
     * <br>The inner-most child is a {@code List<FeedbackResponseAttributes} of all the responses
     * <br>with attributes corresponding to it's parents.
     * @return The responses in this bundle sorted by recipient identifier > giver identifier > question number.
     * @see #getResponsesSortedByRecipient
     */
    public Map<String, Map<String, List<FeedbackResponseAttributes>>>
            getResponsesSortedByRecipientGiverQuestion(boolean sortByTeam) {

        LinkedHashMap<String, Map<String, List<FeedbackResponseAttributes>>> sortedMap = new LinkedHashMap<>();

        if (sortByTeam) {
            Collections.sort(responses, compareByTeamRecipientGiverQuestion);
        } else {
            Collections.sort(responses, compareByRecipientGiverQuestion);
        }

        for (FeedbackResponseAttributes response : responses) {
            String recipientEmail = response.recipient;
            if (!sortedMap.containsKey(recipientEmail)) {
                sortedMap.put(recipientEmail,
                              new LinkedHashMap<String, List<FeedbackResponseAttributes>>());
            }
            Map<String, List<FeedbackResponseAttributes>> responsesToOneRecipient =
                                            sortedMap.get(recipientEmail);

            String giverEmail = response.giver;
            if (!responsesToOneRecipient.containsKey(giverEmail)) {
                responsesToOneRecipient.put(giverEmail, new ArrayList<FeedbackResponseAttributes>());
            }
            List<FeedbackResponseAttributes> responsesFromOneGiverToOneRecipient =
                                            responsesToOneRecipient.get(giverEmail);
            responsesFromOneGiverToOneRecipient.add(response);
        }

        return sortedMap;
    }

    /**
     * Returns responses as a {@code Map<giverName, Map<question, List<response>>>}
     * Where the responses are sorted in the order of giver, question, recipient.
     * @return responses sorted by Giver > Question > Recipient
     */
    public Map<String, Map<FeedbackQuestionAttributes, List<FeedbackResponseAttributes>>>
                getResponsesSortedByGiverQuestionRecipient(boolean sortByTeam) {
        Map<String, Map<FeedbackQuestionAttributes, List<FeedbackResponseAttributes>>> sortedMap = new LinkedHashMap<>();

        if (sortByTeam) {
            Collections.sort(responses, compareByTeamGiverQuestionTeamRecipient);
        } else {
            Collections.sort(responses, compareByGiverQuestionTeamRecipient);
        }

        for (FeedbackResponseAttributes response : responses) {
            String giverEmail = response.giver;
            if (!sortedMap.containsKey(giverEmail)) {
                sortedMap.put(giverEmail,
                        new LinkedHashMap<FeedbackQuestionAttributes, List<FeedbackResponseAttributes>>());
            }
            Map<FeedbackQuestionAttributes, List<FeedbackResponseAttributes>> responsesFromOneGiver =
                                            sortedMap.get(giverEmail);

            FeedbackQuestionAttributes question = questions.get(response.feedbackQuestionId);
            if (!responsesFromOneGiver.containsKey(question)) {
                responsesFromOneGiver.put(question, new ArrayList<FeedbackResponseAttributes>());
            }
            List<FeedbackResponseAttributes> responsesFromOneGiverOneQuestion =
                                            responsesFromOneGiver.get(question);
            responsesFromOneGiverOneQuestion.add(response);
        }

        return sortedMap;
    }

    /**
     * Returns the responses in this bundle as a {@code Tree} structure with no base node
     * using a {@code LinkedHashMap} implementation.
     * <br>The tree is sorted by giverName > recipientName > questionNumber.
     * <br>The key of each map represents the parent node, while the value represents the leaf.
     * <br>The top-most parent {@code String giverName} is the recipient's name of all it's leafs.
     * <br>The inner parent {@code String recipientName} is the giver's name of all it's leafs.
     * <br>The inner-most child is a {@code List<FeedbackResponseAttributes} of all the responses
     * <br>with attributes corresponding to it's parents.
     * @return The responses in this bundle sorted by giver's name > recipient's name > question number.
     */
    public Map<String, Map<String, List<FeedbackResponseAttributes>>> getResponsesSortedByGiver() {
        return getResponsesSortedByGiver(false);
    }

    public Map<String, Map<String, List<FeedbackResponseAttributes>>>
            getResponsesSortedByGiver(boolean sortByTeam) {
        Map<String, Map<String, List<FeedbackResponseAttributes>>> sortedMap = new LinkedHashMap<>();

        if (sortByTeam) {
            Collections.sort(responses, compareByTeamGiverRecipientQuestion);
        } else {
            Collections.sort(responses, compareByGiverRecipientQuestion);
        }

        for (FeedbackResponseAttributes response : responses) {
            String giverName = this.getGiverNameForResponse(response);
            String giverTeamName = this.getTeamNameForEmail(response.giver);
            String giverNameWithTeam = this.appendTeamNameToName(giverName, giverTeamName);
            if (!sortedMap.containsKey(giverNameWithTeam)) {
                sortedMap.put(giverNameWithTeam,
                              new LinkedHashMap<String, List<FeedbackResponseAttributes>>());
            }
            Map<String, List<FeedbackResponseAttributes>> responsesFromOneGiver = sortedMap.get(giverNameWithTeam);

            String recipientName = this.getRecipientNameForResponse(response);
            String recipientTeamName = this.getTeamNameForEmail(response.recipient);
            String recipientNameWithTeam = this.appendTeamNameToName(recipientName, recipientTeamName);
            if (!responsesFromOneGiver.containsKey(recipientNameWithTeam)) {
                responsesFromOneGiver.put(recipientNameWithTeam,
                                          new ArrayList<FeedbackResponseAttributes>());
            }
            List<FeedbackResponseAttributes> responsesFromOneGiverToOneRecipient =
                    responsesFromOneGiver.get(recipientNameWithTeam);
            responsesFromOneGiverToOneRecipient.add(response);
        }

        return sortedMap;
    }

    /**
     * Returns the responses in this bundle as a {@code Tree} structure with no base node
     * using a {@code LinkedHashMap} implementation.
     * <br>The tree is sorted by giverName > recipientName > questionNumber.
     * <br>The key of each map represents the parent node, while the value represents the leaf.
     * <br>The top-most parent {@code String giverName} is the recipient's name of all it's leafs.
     * <br>The inner parent {@code String recipientName} is the giver's name of all it's leafs.
     * <br>The inner-most child is a {@code List<FeedbackResponseAttributes} of all the responses
     * <br>with attributes corresponding to it's parents.
     * @return The responses in this bundle sorted by giver's identifier > recipient's identifier > question number.
     * @see #getResponsesSortedByGiver
     */
    public Map<String, Map<String, List<FeedbackResponseAttributes>>>
                getResponsesSortedByGiverRecipientQuestion(boolean sortByTeam) {
        if (sortByTeam) {
            Collections.sort(responses, compareByTeamGiverRecipientQuestion);
        } else {
            Collections.sort(responses, compareByGiverRecipientQuestion);
        }

        Map<String, Map<String, List<FeedbackResponseAttributes>>> sortedMap = new LinkedHashMap<>();

        for (FeedbackResponseAttributes response : responses) {
            String giverEmail = response.giver;
            if (!sortedMap.containsKey(giverEmail)) {
                sortedMap.put(giverEmail,
                              new LinkedHashMap<String, List<FeedbackResponseAttributes>>());
            }
            Map<String, List<FeedbackResponseAttributes>> responsesFromOneGiver = sortedMap.get(giverEmail);

            String recipientEmail = response.recipient;
            if (!responsesFromOneGiver.containsKey(recipientEmail)) {
                responsesFromOneGiver.put(recipientEmail,
                                          new ArrayList<FeedbackResponseAttributes>());
            }
            List<FeedbackResponseAttributes> responsesFromOneGiverToOneRecipient =
                                            responsesFromOneGiver.get(recipientEmail);
            responsesFromOneGiverToOneRecipient.add(response);
        }

        return sortedMap;
    }

    public boolean isStudentHasSomethingNewToSee(StudentAttributes student) {
        for (FeedbackResponseAttributes response : responses) {
            // There is a response not written by the student
            // which is visible to the student
            if (!response.giver.equals(student.email)) {
                return true;
            }
            // There is a response comment visible to the student
            if (responseComments.containsKey(response.getId())) {
                return true;
            }
        }
        return false;
    }

    private Map<String, Set<String>> getTeamNameToEmailsTableFromRoster(CourseRoster courseroster) {
        List<StudentAttributes> students = courseroster.getStudents();
        Map<String, Set<String>> teamNameToEmails = new HashMap<>();

        for (StudentAttributes student : students) {
            String studentTeam = student.team;
            Set<String> studentEmails;

            if (teamNameToEmails.containsKey(studentTeam)) {
                studentEmails = teamNameToEmails.get(studentTeam);
            } else {
                studentEmails = new TreeSet<>();
            }

            studentEmails.add(student.email);
            teamNameToEmails.put(studentTeam, studentEmails);
        }

        List<InstructorAttributes> instructors = courseroster.getInstructors();
        String instructorsTeam = Const.USER_TEAM_FOR_INSTRUCTOR;
        Set<String> instructorEmails = new HashSet<>();

        for (InstructorAttributes instructor : instructors) {
            instructorEmails.add(instructor.email);
            teamNameToEmails.put(instructorsTeam, instructorEmails);
        }

        return teamNameToEmails;
    }

    private Map<String, Set<String>> getSectionToTeamNamesFromRoster(CourseRoster courseroster) {
        List<StudentAttributes> students = courseroster.getStudents();
        Map<String, Set<String>> sectionToTeam = new HashMap<>();

        for (StudentAttributes student : students) {
            String studentSection = student.section;
            String studentTeam = student.team;
            Set<String> teamNames;

            if (sectionToTeam.containsKey(studentSection)) {
                teamNames = sectionToTeam.get(studentSection);
            } else {
                teamNames = new HashSet<>();
            }

            teamNames.add(studentTeam);
            sectionToTeam.put(studentSection, teamNames);
        }

        return sectionToTeam;
    }

    private int compareByQuestionNumber(FeedbackResponseAttributes r1,
                                        FeedbackResponseAttributes r2) {
        FeedbackQuestionAttributes q1 = questions.get(r1.feedbackQuestionId);
        FeedbackQuestionAttributes q2 = questions.get(r2.feedbackQuestionId);
        if (q1 == null || q2 == null) {
            return 0;
        }
        return q1.compareTo(q2);
    }

    /**
     * Compares the values of {@code name1} and {@code name2}.
     * Anonymous names are ordered later than non-anonymous names.
     * @param isFirstNameVisible  true if the first name should be visible to the user
     * @param isSecondNameVisible true if the second name should be visible to the user
     */
    private int compareByNames(String name1, String name2,
                               boolean isFirstNameVisible, boolean isSecondNameVisible) {
        if (!isFirstNameVisible && !isSecondNameVisible) {
            return 0;
        }
        if (!isFirstNameVisible && isSecondNameVisible) {
            return 1;
        } else if (isFirstNameVisible && !isSecondNameVisible) {
            return -1;
        }

        // Make class feedback always appear on top, and team responses at bottom.
        int n1Priority = 0;
        int n2Priority = 0;

        if (name1.equals(Const.USER_IS_NOBODY)) {
            n1Priority = -1;
        } else if (name1.equals(Const.USER_IS_TEAM)) {
            n1Priority = 1;
        }
        if (name2.equals(Const.USER_IS_NOBODY)) {
            n2Priority = -1;
        } else if (name2.equals(Const.USER_IS_TEAM)) {
            n2Priority = 1;
        }

        int order = Integer.compare(n1Priority, n2Priority);
        return order == 0 ? name1.compareTo(name2) : order;
    }

    private int compareByResponseString(FeedbackResponseAttributes o1, FeedbackResponseAttributes o2) {
        String responseAnswer1 = o1.getResponseDetails().getAnswerString();

        String responseAnswer2 = o2.getResponseDetails().getAnswerString();

        return responseAnswer1.compareTo(responseAnswer2);
    }

    public FeedbackSessionAttributes getFeedbackSession() {
        return feedbackSession;
    }

    public List<FeedbackResponseAttributes> getResponses() {
        return responses;
    }

    public Map<String, FeedbackQuestionAttributes> getQuestions() {
        return questions;
    }

    public Map<String, String> getEmailNameTable() {
        return emailNameTable;
    }

    public Map<String, String> getEmailLastNameTable() {
        return emailLastNameTable;
    }

    public Map<String, String> getEmailTeamNameTable() {
        return emailTeamNameTable;
    }

    public Map<String, Set<String>> getRosterTeamNameMembersTable() {
        return rosterTeamNameMembersTable;
    }

    public Set<String> sectionsInCourse() {
        return new HashSet<>(rosterSectionTeamNameTable.keySet());
    }

    public Map<String, Set<String>> getRosterSectionTeamNameTable() {
        return rosterSectionTeamNameTable;
    }

    public Map<String, boolean[]> getVisibilityTable() {
        return visibilityTable;
    }

    public FeedbackSessionResponseStatus getResponseStatus() {
        return responseStatus;
    }

    public CourseRoster getRoster() {
        return roster;
    }

    public Map<String, List<FeedbackResponseCommentAttributes>> getResponseComments() {
        return responseComments;
    }

    public boolean isComplete() {
        return isComplete;
    }

    public double getTimeZone() {
        return feedbackSession.getTimeZone();
    }

    private Map<String, String> getInstructorEmailNameTableFromRoster(CourseRoster roster) {
        Map<String, String> instructorEmailNameTable = new HashMap<>();
        List<InstructorAttributes> instructorList = roster.getInstructors();
        for (InstructorAttributes instructor : instructorList) {
            instructorEmailNameTable.put(instructor.email, instructor.name);
        }
        return instructorEmailNameTable;
    }

    public StringBuilder getCsvDetailedFeedbackResponseCommentsRow(FeedbackResponseAttributes response) {
        List<FeedbackResponseCommentAttributes> frcList = this.responseComments.get(response.getId());
        StringBuilder commentRow = new StringBuilder(200);
        for (FeedbackResponseCommentAttributes frc : frcList) {
            commentRow.append("","" + instructorEmailNameTable.get(frc.giverEmail) + "",""
                    + getTextFromComment(frc.commentText));
        }
        return commentRow;
    }

    public String getTextFromComment(Text commentText) {
        String htmlText = commentText.getValue();
        StringBuilder comment = new StringBuilder(200);
        comment.append(Jsoup.parse(htmlText).text());
        if (!(Jsoup.parse(htmlText).getElementsByTag(""img"").isEmpty())) {
            comment.append(""Images Link: "");
            Elements ele = Jsoup.parse(htmlText).getElementsByTag(""img"");
            for (Element element : ele) {
                comment.append(element.absUrl(""src"") + ' ');
            }
        }
        return SanitizationHelper.sanitizeForCsv(comment.toString());
    }
}
"
FeedbackSessionStats.java,data-transfer,"package teammates.common.datatransfer;

import teammates.common.util.Const;

/**
 * Represents submission statistics for the feedback session.
 * <br> Contains:
 * <br> * The total number of students who were expected to submit.
 * <br> * The total number of students who submitted .
 */
public class FeedbackSessionStats {
    public int submittedTotal = Const.INT_UNINITIALIZED;
    public int expectedTotal = Const.INT_UNINITIALIZED;
}
"
FeedbackSessionType.java,data-transfer,"package teammates.common.datatransfer;

public enum FeedbackSessionType {
        STANDARD, PRIVATE;
        // TODO: be a bit more specific here.
        // e.g., STANDARD_TEAM_PEER_EVAL, FULLY_CUSTOMIZABLE, PRIVATE, INSTRUCTOR_OBSERVATIONS
        // Otherwise these will have to be renamed when we add more types later.
}
"
InstructorPrivileges.java,data-transfer,"package teammates.common.datatransfer;

import java.util.Arrays;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.Map;
import java.util.Set;

import teammates.common.util.Assumption;
import teammates.common.util.Const;

/**
 * Representation of instructor privileges. Store the privileges of the instructor
 */
public final class InstructorPrivileges {

    private static final Map<String, Boolean> PRIVILEGES_COOWNER = new LinkedHashMap<>();
    private static final Map<String, Boolean> PRIVILEGES_MANAGER = new LinkedHashMap<>();
    private static final Map<String, Boolean> PRIVILEGES_OBSERVER = new LinkedHashMap<>();
    private static final Map<String, Boolean> PRIVILEGES_TUTOR = new LinkedHashMap<>();
    private static final Map<String, Boolean> PRIVILEGES_CUSTOM = new LinkedHashMap<>();

    static {
        PRIVILEGES_COOWNER.put(Const.ParamsNames.INSTRUCTOR_PERMISSION_MODIFY_COURSE, true);
        PRIVILEGES_COOWNER.put(Const.ParamsNames.INSTRUCTOR_PERMISSION_MODIFY_INSTRUCTOR, true);
        PRIVILEGES_COOWNER.put(Const.ParamsNames.INSTRUCTOR_PERMISSION_MODIFY_SESSION, true);
        PRIVILEGES_COOWNER.put(Const.ParamsNames.INSTRUCTOR_PERMISSION_MODIFY_STUDENT, true);
        PRIVILEGES_COOWNER.put(Const.ParamsNames.INSTRUCTOR_PERMISSION_VIEW_STUDENT_IN_SECTIONS, true);
        PRIVILEGES_COOWNER.put(Const.ParamsNames.INSTRUCTOR_PERMISSION_VIEW_SESSION_IN_SECTIONS, true);
        PRIVILEGES_COOWNER.put(Const.ParamsNames.INSTRUCTOR_PERMISSION_SUBMIT_SESSION_IN_SECTIONS, true);
        PRIVILEGES_COOWNER.put(Const.ParamsNames.INSTRUCTOR_PERMISSION_MODIFY_SESSION_COMMENT_IN_SECTIONS, true);

        PRIVILEGES_MANAGER.put(Const.ParamsNames.INSTRUCTOR_PERMISSION_MODIFY_COURSE, false);
        PRIVILEGES_MANAGER.put(Const.ParamsNames.INSTRUCTOR_PERMISSION_MODIFY_INSTRUCTOR, true);
        PRIVILEGES_MANAGER.put(Const.ParamsNames.INSTRUCTOR_PERMISSION_MODIFY_SESSION, true);
        PRIVILEGES_MANAGER.put(Const.ParamsNames.INSTRUCTOR_PERMISSION_MODIFY_STUDENT, true);
        PRIVILEGES_MANAGER.put(Const.ParamsNames.INSTRUCTOR_PERMISSION_VIEW_STUDENT_IN_SECTIONS, true);
        PRIVILEGES_MANAGER.put(Const.ParamsNames.INSTRUCTOR_PERMISSION_VIEW_SESSION_IN_SECTIONS, true);
        PRIVILEGES_MANAGER.put(Const.ParamsNames.INSTRUCTOR_PERMISSION_SUBMIT_SESSION_IN_SECTIONS, true);
        PRIVILEGES_MANAGER.put(Const.ParamsNames.INSTRUCTOR_PERMISSION_MODIFY_SESSION_COMMENT_IN_SECTIONS, true);

        PRIVILEGES_OBSERVER.put(Const.ParamsNames.INSTRUCTOR_PERMISSION_MODIFY_COURSE, false);
        PRIVILEGES_OBSERVER.put(Const.ParamsNames.INSTRUCTOR_PERMISSION_MODIFY_INSTRUCTOR, false);
        PRIVILEGES_OBSERVER.put(Const.ParamsNames.INSTRUCTOR_PERMISSION_MODIFY_SESSION, false);
        PRIVILEGES_OBSERVER.put(Const.ParamsNames.INSTRUCTOR_PERMISSION_MODIFY_STUDENT, false);
        PRIVILEGES_OBSERVER.put(Const.ParamsNames.INSTRUCTOR_PERMISSION_VIEW_STUDENT_IN_SECTIONS, true);
        PRIVILEGES_OBSERVER.put(Const.ParamsNames.INSTRUCTOR_PERMISSION_VIEW_SESSION_IN_SECTIONS, true);
        PRIVILEGES_OBSERVER.put(Const.ParamsNames.INSTRUCTOR_PERMISSION_SUBMIT_SESSION_IN_SECTIONS, false);
        PRIVILEGES_OBSERVER.put(Const.ParamsNames.INSTRUCTOR_PERMISSION_MODIFY_SESSION_COMMENT_IN_SECTIONS, false);

        PRIVILEGES_TUTOR.put(Const.ParamsNames.INSTRUCTOR_PERMISSION_MODIFY_COURSE, false);
        PRIVILEGES_TUTOR.put(Const.ParamsNames.INSTRUCTOR_PERMISSION_MODIFY_INSTRUCTOR, false);
        PRIVILEGES_TUTOR.put(Const.ParamsNames.INSTRUCTOR_PERMISSION_MODIFY_SESSION, false);
        PRIVILEGES_TUTOR.put(Const.ParamsNames.INSTRUCTOR_PERMISSION_MODIFY_STUDENT, false);
        PRIVILEGES_TUTOR.put(Const.ParamsNames.INSTRUCTOR_PERMISSION_VIEW_STUDENT_IN_SECTIONS, true);
        PRIVILEGES_TUTOR.put(Const.ParamsNames.INSTRUCTOR_PERMISSION_VIEW_SESSION_IN_SECTIONS, true);
        PRIVILEGES_TUTOR.put(Const.ParamsNames.INSTRUCTOR_PERMISSION_SUBMIT_SESSION_IN_SECTIONS, true);
        PRIVILEGES_TUTOR.put(Const.ParamsNames.INSTRUCTOR_PERMISSION_MODIFY_SESSION_COMMENT_IN_SECTIONS, false);

        PRIVILEGES_CUSTOM.put(Const.ParamsNames.INSTRUCTOR_PERMISSION_MODIFY_COURSE, false);
        PRIVILEGES_CUSTOM.put(Const.ParamsNames.INSTRUCTOR_PERMISSION_MODIFY_INSTRUCTOR, false);
        PRIVILEGES_CUSTOM.put(Const.ParamsNames.INSTRUCTOR_PERMISSION_MODIFY_SESSION, false);
        PRIVILEGES_CUSTOM.put(Const.ParamsNames.INSTRUCTOR_PERMISSION_MODIFY_STUDENT, false);
        PRIVILEGES_CUSTOM.put(Const.ParamsNames.INSTRUCTOR_PERMISSION_VIEW_STUDENT_IN_SECTIONS, false);
        PRIVILEGES_CUSTOM.put(Const.ParamsNames.INSTRUCTOR_PERMISSION_VIEW_SESSION_IN_SECTIONS, false);
        PRIVILEGES_CUSTOM.put(Const.ParamsNames.INSTRUCTOR_PERMISSION_SUBMIT_SESSION_IN_SECTIONS, false);
        PRIVILEGES_CUSTOM.put(Const.ParamsNames.INSTRUCTOR_PERMISSION_MODIFY_SESSION_COMMENT_IN_SECTIONS, false);
    }

    private static final String[] COURSE_LEVEL_ONLY_LIST = new String[] {
            Const.ParamsNames.INSTRUCTOR_PERMISSION_MODIFY_COURSE,
            Const.ParamsNames.INSTRUCTOR_PERMISSION_MODIFY_INSTRUCTOR,
            Const.ParamsNames.INSTRUCTOR_PERMISSION_MODIFY_SESSION,
            Const.ParamsNames.INSTRUCTOR_PERMISSION_MODIFY_STUDENT
    };

    private static final String[] SECTION_LEVEL_ONLY_LIST = new String[] {
            Const.ParamsNames.INSTRUCTOR_PERMISSION_VIEW_STUDENT_IN_SECTIONS,
    };

    private static final String[] SESSION_LEVEL_ONLY_LIST = new String[] {
            Const.ParamsNames.INSTRUCTOR_PERMISSION_VIEW_SESSION_IN_SECTIONS,
            Const.ParamsNames.INSTRUCTOR_PERMISSION_SUBMIT_SESSION_IN_SECTIONS,
            Const.ParamsNames.INSTRUCTOR_PERMISSION_MODIFY_SESSION_COMMENT_IN_SECTIONS
    };

    private static final Set<String> COURSE_LEVEL_ONLY_PRIVILEGES =
            new LinkedHashSet<>(Arrays.asList(COURSE_LEVEL_ONLY_LIST));
    private static final Set<String> SECTION_LEVEL_ONLY_PRIVILEGES =
            new LinkedHashSet<>(Arrays.asList(SECTION_LEVEL_ONLY_LIST));
    private static final Set<String> SESSION_LEVEL_ONLY_PRIVILEGES =
            new LinkedHashSet<>(Arrays.asList(SESSION_LEVEL_ONLY_LIST));

    private Map<String, Boolean> courseLevel;
    private Map<String, Map<String, Boolean>> sectionLevel;
    private Map<String, Map<String, Map<String, Boolean>>> sessionLevel;

    public InstructorPrivileges() {
        this.courseLevel = new LinkedHashMap<>();
        this.sectionLevel = new LinkedHashMap<>();
        this.sessionLevel = new LinkedHashMap<>();
    }

    public InstructorPrivileges(String instrRole) {
        this();
        switch (instrRole) {
        case Const.InstructorPermissionRoleNames.INSTRUCTOR_PERMISSION_ROLE_COOWNER:
            setDefaultPrivilegesForCoowner();
            break;
        case Const.InstructorPermissionRoleNames.INSTRUCTOR_PERMISSION_ROLE_MANAGER:
            setDefaultPrivilegesForManager();
            break;
        case Const.InstructorPermissionRoleNames.INSTRUCTOR_PERMISSION_ROLE_OBSERVER:
            setDefaultPrivilegesForObserver();
            break;
        case Const.InstructorPermissionRoleNames.INSTRUCTOR_PERMISSION_ROLE_TUTOR:
            setDefaultPrivilegesForTutor();
            break;
        case Const.InstructorPermissionRoleNames.INSTRUCTOR_PERMISSION_ROLE_CUSTOM:
            setDefaultPrivilegesForCustom();
            break;
        default:
            setDefaultPrivilegesForCustom();
            break;
        }
    }

    public static boolean isPrivilegeNameValid(String privilegeName) {
        return COURSE_LEVEL_ONLY_PRIVILEGES.contains(privilegeName)
                || SECTION_LEVEL_ONLY_PRIVILEGES.contains(privilegeName)
                || SESSION_LEVEL_ONLY_PRIVILEGES.contains(privilegeName);
    }

    public static boolean isPrivilegeNameValidForSectionLevel(String privilegeName) {
        return SECTION_LEVEL_ONLY_PRIVILEGES.contains(privilegeName)
                || SESSION_LEVEL_ONLY_PRIVILEGES.contains(privilegeName);
    }

    public static boolean isPrivilegeNameValidForSessionLevel(String privilegeName) {
        return SESSION_LEVEL_ONLY_PRIVILEGES.contains(privilegeName);
    }

    public void setDefaultPrivilegesForCoowner() {
        setDefaultPrivileges(PRIVILEGES_COOWNER);
    }

    public void setDefaultPrivilegesForManager() {
        setDefaultPrivileges(PRIVILEGES_MANAGER);
    }

    public void setDefaultPrivilegesForObserver() {
        setDefaultPrivileges(PRIVILEGES_OBSERVER);
    }

    public void setDefaultPrivilegesForTutor() {
        setDefaultPrivileges(PRIVILEGES_TUTOR);
    }

    public void setDefaultPrivilegesForCustom() {
        setDefaultPrivileges(PRIVILEGES_CUSTOM);
    }

    private void setDefaultPrivileges(Map<String, Boolean> defaultPrivileges) {
        for (Map.Entry<String, Boolean> entry : defaultPrivileges.entrySet()) {
            courseLevel.put(entry.getKey(), entry.getValue());
        }
    }

    public Map<String, Boolean> getOverallPrivilegesForSections() {
        Map<String, Boolean> privileges = new LinkedHashMap<>();

        privileges.put(Const.ParamsNames.INSTRUCTOR_PERMISSION_VIEW_STUDENT_IN_SECTIONS,
                isAllowedInCourseLevel(Const.ParamsNames.INSTRUCTOR_PERMISSION_VIEW_STUDENT_IN_SECTIONS));

        privileges.put(Const.ParamsNames.INSTRUCTOR_PERMISSION_VIEW_SESSION_IN_SECTIONS,
                isAllowedInCourseLevel(Const.ParamsNames.INSTRUCTOR_PERMISSION_VIEW_SESSION_IN_SECTIONS));
        privileges.put(Const.ParamsNames.INSTRUCTOR_PERMISSION_SUBMIT_SESSION_IN_SECTIONS,
                isAllowedInCourseLevel(Const.ParamsNames.INSTRUCTOR_PERMISSION_SUBMIT_SESSION_IN_SECTIONS));
        privileges.put(Const.ParamsNames.INSTRUCTOR_PERMISSION_MODIFY_SESSION_COMMENT_IN_SECTIONS,
                isAllowedInCourseLevel(Const.ParamsNames.INSTRUCTOR_PERMISSION_MODIFY_SESSION_COMMENT_IN_SECTIONS));

        return privileges;
    }

    public Map<String, Boolean> getOverallPrivilegesForSessionsInSection(String sectionName) {
        Map<String, Boolean> privileges = new LinkedHashMap<>();

        privileges.put(Const.ParamsNames.INSTRUCTOR_PERMISSION_VIEW_SESSION_IN_SECTIONS,
                isAllowedInSectionLevel(sectionName, Const.ParamsNames.INSTRUCTOR_PERMISSION_VIEW_SESSION_IN_SECTIONS));
        privileges.put(Const.ParamsNames.INSTRUCTOR_PERMISSION_SUBMIT_SESSION_IN_SECTIONS,
                isAllowedInSectionLevel(sectionName, Const.ParamsNames.INSTRUCTOR_PERMISSION_SUBMIT_SESSION_IN_SECTIONS));
        privileges.put(Const.ParamsNames.INSTRUCTOR_PERMISSION_MODIFY_SESSION_COMMENT_IN_SECTIONS,
                isAllowedInSectionLevel(sectionName,
                                        Const.ParamsNames.INSTRUCTOR_PERMISSION_MODIFY_SESSION_COMMENT_IN_SECTIONS));

        return privileges;
    }

    /**
     * Sets privilege for the privilege specified by privilegeName.
     */
    public void updatePrivilege(String privilegeName, boolean isAllowed) {
        updatePrivilegeInCourseLevel(privilegeName, isAllowed);
    }

    /**
     * Sets privilege for the privilege specified by privilegeName for sectionName.
     */
    public void updatePrivilege(String sectionName, String privilegeName, boolean isAllowed) {
        updatePrivilegeInSectionLevel(sectionName, privilegeName, isAllowed);
    }

    /**
     * Sets privilege for the privilege specified by privilegeName for sessionName in sectionName.
     */
    public void updatePrivilege(String sectionName, String sessionName, String privilegeName, boolean isAllowed) {
        updatePrivilegeInSessionLevel(sectionName, sessionName, privilegeName, isAllowed);
    }

    private void updatePrivilegeInCourseLevel(String privilegeName, boolean isAllowed) {
        if (!isPrivilegeNameValid(privilegeName)) {
            return;
        }
        this.courseLevel.put(privilegeName, isAllowed);
    }

    private void updatePrivilegeInSectionLevel(String sectionName, String privilegeName, boolean isAllowed) {
        if (!isPrivilegeNameValidForSectionLevel(privilegeName)) {
            return;
        }
        if (!this.sectionLevel.containsKey(sectionName)) {
            sectionLevel.put(sectionName, new LinkedHashMap<String, Boolean>());
        }
        sectionLevel.get(sectionName).put(privilegeName, isAllowed);
    }

    private void updatePrivilegeInSessionLevel(String sectionName, String sessionName,
                                               String privilegeName, boolean isAllowed) {
        if (!isPrivilegeNameValidForSessionLevel(privilegeName)) {
            return;
        }
        verifyExistenceOfsectionName(sectionName);
        if (!this.sessionLevel.get(sectionName).containsKey(sessionName)) {
            this.sessionLevel.get(sectionName).put(sessionName, new LinkedHashMap<String, Boolean>());
        }
        this.sessionLevel.get(sectionName).get(sessionName).put(privilegeName, isAllowed);
    }

    public void updatePrivileges(String sectionName, Map<String, Boolean> privileges) {
        updatePrivilegesInSectionLevel(sectionName, privileges);
    }

    public void updatePrivileges(String sectionName, String sessionName, Map<String, Boolean> privileges) {
        updatePrivilegesInSessionLevel(sectionName, sessionName, privileges);
    }

    private void updatePrivilegesInSectionLevel(String sectionName, Map<String, Boolean> privileges) {
        for (String privilegeName : privileges.keySet()) {
            if (!isPrivilegeNameValidForSectionLevel(privilegeName)) {
                return;
            }
        }
        sectionLevel.put(sectionName, new LinkedHashMap<>(privileges));
    }

    private void updatePrivilegesInSessionLevel(String sectionName, String sessionName,
                                                Map<String, Boolean> privileges) {
        for (String privilegeName : privileges.keySet()) {
            if (!isPrivilegeNameValidForSessionLevel(privilegeName)) {
                return;
            }
        }
        verifyExistenceOfsectionName(sectionName);
        this.sessionLevel.get(sectionName).put(sessionName, new LinkedHashMap<>(privileges));
    }

    private void verifyExistenceOfsectionName(String sectionName) {
        if (!this.sessionLevel.containsKey(sectionName)) {
            addSectionWithDefaultPrivileges(sectionName);
            this.sessionLevel.put(sectionName, new LinkedHashMap<String, Map<String, Boolean>>());
        }
    }

    public void addSectionWithDefaultPrivileges(String sectionName) {
        if (this.sectionLevel.containsKey(sectionName)) {
            return;
        }
        this.sectionLevel.put(sectionName, getOverallPrivilegesForSections());
    }

    public void addSessionWithDefaultPrivileges(String sectionName, String sessionName) {
        verifyExistenceOfsectionName(sectionName);
        if (this.sessionLevel.get(sectionName).containsKey(sessionName)) {
            return;
        }
        this.sessionLevel.get(sectionName).put(sessionName, getOverallPrivilegesForSessionsInSection(sectionName));
    }

    /**
     * Returns true if it is allowed for the privilege specified by privilegeName.
     */
    public boolean isAllowedForPrivilege(String privilegeName) {
        return isAllowedInCourseLevel(privilegeName);
    }

    /**
     * Returns true if it is allowed for the privilege specified by privilegeName in sectionName.
     */
    public boolean isAllowedForPrivilege(String sectionName, String privilegeName) {
        return isAllowedInSectionLevel(sectionName, privilegeName);
    }

    /**
     * Returns true if it is allowed for the privilege specified by privilegeName for sessionName in sectionName.
     */
    public boolean isAllowedForPrivilege(String sectionName, String sessionName, String privilegeName) {
        return isAllowedInSessionLevel(sectionName, sessionName, privilegeName);
    }

    /**
     * Returns true if privilege for session is present for any section.
     */
    public boolean isAllowedForPrivilegeAnySection(String sessionName, String privilegeName) {
        return isAllowedInSessionLevelAnySection(sessionName, privilegeName);
    }

    public boolean hasCoownerPrivileges() {
        return hasSamePrivileges(PRIVILEGES_COOWNER);
    }

    public boolean hasManagerPrivileges() {
        return hasSamePrivileges(PRIVILEGES_MANAGER);
    }

    public boolean hasObserverPrivileges() {
        return hasSamePrivileges(PRIVILEGES_OBSERVER);
    }

    public boolean hasTutorPrivileges() {
        return hasSamePrivileges(PRIVILEGES_TUTOR);
    }

    private boolean hasSamePrivileges(Map<String, Boolean> defaultPrivileges) {

        for (Map.Entry<String, Boolean> entry : defaultPrivileges.entrySet()) {
            if (isAllowedForPrivilege(entry.getKey()) != entry.getValue()) {
                return false;
            }
        }

        return true;
    }

    public boolean isSectionSpecial(String sectionName) {
        return this.sectionLevel.containsKey(sectionName);
    }

    public int numberOfSectionsSpecial() {
        return this.sectionLevel.keySet().size();
    }

    /**
     * Returns true if there are special settings for sectionName.
     */
    public boolean isSessionsInSectionSpecial(String sectionName) {
        return this.sessionLevel.containsKey(sectionName);
    }

    /**
     * Returns true if there are special settings for sessionName in sectionName.
     */
    public boolean isSessionInSectionSpecial(String sectionName, String sessionName) {
        return this.sessionLevel.containsKey(sectionName)
               && this.sessionLevel.get(sectionName).containsKey(sessionName);
    }

    /**
     * Removes special settings for sectionName.
     */
    public void removeSectionLevelPrivileges(String sectionName) {
        if (this.sectionLevel.containsKey(sectionName)) {
            this.sectionLevel.remove(sectionName);
        }
        this.removeSessionsPrivilegesForSection(sectionName);
    }

    /**
     * Removes special settings for all sessionNames in sectionName.
     */
    public void removeSessionsPrivilegesForSection(String sectionName) {
        if (this.sessionLevel.containsKey(sectionName)) {
            this.sessionLevel.remove(sectionName);
        }
    }

    /**
     * Removes special settings for sessionName in sectionName.
     */
    public void removeSessionPrivileges(String sectionName, String sessionName) {
        if (this.sessionLevel.containsKey(sectionName) && this.sessionLevel.get(sectionName).containsKey(sessionName)) {
            this.sessionLevel.get(sectionName).remove(sessionName);
        }
    }

    private boolean isAllowedInCourseLevel(String privilegeName) {

        Assumption.assertTrue(isPrivilegeNameValid(privilegeName));

        if (!this.courseLevel.containsKey(privilegeName)) {
            return false;
        }

        return this.courseLevel.get(privilegeName).booleanValue();
    }

    private boolean isAllowedInSectionLevel(String sectionName, String privilegeName) {

        Assumption.assertTrue(isPrivilegeNameValid(privilegeName));

        if (!this.sectionLevel.containsKey(sectionName)) {
            return isAllowedInCourseLevel(privilegeName);
        }
        if (!this.sectionLevel.get(sectionName).containsKey(privilegeName)) {
            return false;
        }
        return this.sectionLevel.get(sectionName).get(privilegeName).booleanValue();
    }

    private boolean isAllowedInSessionLevel(String sectionName, String sessionName, String privilegeName) {

        Assumption.assertTrue(isPrivilegeNameValid(privilegeName));

        if (!this.sessionLevel.containsKey(sectionName)
                || !this.sessionLevel.get(sectionName).containsKey(sessionName)) {
            return isAllowedInSectionLevel(sectionName, privilegeName);
        }
        if (!this.sessionLevel.get(sectionName).get(sessionName).containsKey(privilegeName)) {
            return false;
        }
        return this.sessionLevel.get(sectionName).get(sessionName).get(privilegeName).booleanValue();
    }

    private boolean isAllowedInSessionLevelAnySection(String sessionName, String privilegeName) {

        Assumption.assertTrue(isPrivilegeNameValid(privilegeName));

        Set<String> sections = new LinkedHashSet<>(this.sessionLevel.keySet());
        sections.addAll(this.sectionLevel.keySet());
        for (String sectionName : sections) {
            if (isAllowedInSessionLevel(sectionName, sessionName, privilegeName)) {
                return true;
            }
        }
        return false;
    }

    /**
     * Validates the privileges in course level, section level and session level.
     *
     * <p>Makes sure there is nothing wrong with privileges hierarchy by adding the
     * prerequisite privileges if they have not been granted yet.
     */
    public void validatePrivileges() {
        if (this.courseLevel.containsKey(Const.ParamsNames.INSTRUCTOR_PERMISSION_MODIFY_SESSION_COMMENT_IN_SECTIONS)
                && this.courseLevel.get(Const.ParamsNames.INSTRUCTOR_PERMISSION_MODIFY_SESSION_COMMENT_IN_SECTIONS)
                                   .booleanValue()) {
            this.courseLevel.put(Const.ParamsNames.INSTRUCTOR_PERMISSION_VIEW_SESSION_IN_SECTIONS, true);
        }
        for (Map<String, Boolean> sectionMap : this.sectionLevel.values()) {
            if (sectionMap.containsKey(Const.ParamsNames.INSTRUCTOR_PERMISSION_MODIFY_SESSION_COMMENT_IN_SECTIONS)
                    && sectionMap.get(Const.ParamsNames.INSTRUCTOR_PERMISSION_MODIFY_SESSION_COMMENT_IN_SECTIONS)
                                 .booleanValue()) {
                sectionMap.put(Const.ParamsNames.INSTRUCTOR_PERMISSION_VIEW_SESSION_IN_SECTIONS, true);
            }
        }
        for (Map<String, Map<String, Boolean>> section : this.sessionLevel.values()) {
            for (Map<String, Boolean> sessionMap : section.values()) {
                if (sessionMap.containsKey(Const.ParamsNames.INSTRUCTOR_PERMISSION_MODIFY_SESSION_COMMENT_IN_SECTIONS)
                        && sessionMap.get(Const.ParamsNames.INSTRUCTOR_PERMISSION_MODIFY_SESSION_COMMENT_IN_SECTIONS)
                                     .booleanValue()) {
                    sessionMap.put(Const.ParamsNames.INSTRUCTOR_PERMISSION_VIEW_SESSION_IN_SECTIONS, true);
                }
            }
        }
    }

    public Map<String, Boolean> getCourseLevelPrivileges() {
        return new LinkedHashMap<>(courseLevel);
    }

    public Map<String, Map<String, Boolean>> getSectionLevelPrivileges() {
        Map<String, Map<String, Boolean>> copy = new LinkedHashMap<>();
        for (Map.Entry<String, Map<String, Boolean>> sectionPrivileges : sectionLevel.entrySet()) {
            copy.put(sectionPrivileges.getKey(), new LinkedHashMap<>(sectionPrivileges.getValue()));
        }
        return copy;
    }

    public Map<String, Map<String, Map<String, Boolean>>> getSessionLevelPrivileges() {
        Map<String, Map<String, Map<String, Boolean>>> copy = new LinkedHashMap<>();
        for (Map.Entry<String, Map<String, Map<String, Boolean>>> sectionPrivileges : sessionLevel.entrySet()) {

            Map<String, Map<String, Boolean>> sectionCopy = new LinkedHashMap<>();
            for (Map.Entry<String, Map<String, Boolean>> sessionPrivileges : sectionPrivileges.getValue().entrySet()) {
                sectionCopy.put(sessionPrivileges.getKey(), new LinkedHashMap<>(sessionPrivileges.getValue()));
            }

            copy.put(sectionPrivileges.getKey(), sectionCopy);
        }
        return copy;
    }

    @Override
    public boolean equals(Object another) {
        if (!(another instanceof InstructorPrivileges)) {
            return false;
        }
        if (another == this) {
            return true;
        }

        InstructorPrivileges rhs = (InstructorPrivileges) another;
        return this.getCourseLevelPrivileges().equals(rhs.getCourseLevelPrivileges())
               && this.getSectionLevelPrivileges().equals(rhs.getSectionLevelPrivileges())
               && this.getSessionLevelPrivileges().equals(rhs.getSessionLevelPrivileges());
    }

    @Override
    public int hashCode() {
        int prime = 31;
        int result = 1;

        result = prime * result + this.getCourseLevelPrivileges().hashCode();
        result = prime * result + this.getSectionLevelPrivileges().hashCode();
        result = prime * result + this.getSessionLevelPrivileges().hashCode();

        return result;
    }

}
"
InstructorSearchResultBundle.java,data-transfer,"package teammates.common.datatransfer;

import java.util.ArrayList;
import java.util.List;

import teammates.common.datatransfer.attributes.InstructorAttributes;

/**
 * The search result bundle for {@link InstructorAttributes}.
 */
public class InstructorSearchResultBundle extends SearchResultBundle {

    public List<InstructorAttributes> instructorList = new ArrayList<>();

}
"
package-info.java,data-transfer,"/**
 * Contains lightweight data transfer objects for transferring data
 * between components, particularly those from different packages.
 */
package teammates.common.datatransfer;
"
FeedbackConstantSumQuestionDetails.java,data-transfer,"package teammates.common.datatransfer.questions;

import java.text.DecimalFormat;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.TreeMap;

import teammates.common.datatransfer.FeedbackSessionResultsBundle;
import teammates.common.datatransfer.attributes.FeedbackQuestionAttributes;
import teammates.common.datatransfer.attributes.FeedbackResponseAttributes;
import teammates.common.util.Assumption;
import teammates.common.util.Const;
import teammates.common.util.FieldValidator;
import teammates.common.util.HttpRequestHelper;
import teammates.common.util.SanitizationHelper;
import teammates.common.util.StringHelper;
import teammates.common.util.Templates;
import teammates.common.util.Templates.FeedbackQuestion.FormTemplates;
import teammates.common.util.Templates.FeedbackQuestion.Slots;
import teammates.logic.core.FeedbackQuestionsLogic;
import teammates.ui.template.InstructorFeedbackResultsResponseRow;

public class FeedbackConstantSumQuestionDetails extends FeedbackQuestionDetails {
    private int numOfConstSumOptions;
    private List<String> constSumOptions;
    private boolean distributeToRecipients;
    private boolean pointsPerOption;
    private boolean forceUnevenDistribution;
    private int points;

    public FeedbackConstantSumQuestionDetails() {
        super(FeedbackQuestionType.CONSTSUM);

        this.numOfConstSumOptions = 0;
        this.constSumOptions = new ArrayList<>();
        this.distributeToRecipients = false;
        this.pointsPerOption = false;
        this.points = 100;
        this.forceUnevenDistribution = false;
    }

    public FeedbackConstantSumQuestionDetails(String questionText,
            List<String> constSumOptions,
            boolean pointsPerOption, int points, boolean unevenDistribution) {
        super(FeedbackQuestionType.CONSTSUM, questionText);

        this.numOfConstSumOptions = constSumOptions.size();
        this.constSumOptions = constSumOptions;
        this.distributeToRecipients = false;
        this.pointsPerOption = pointsPerOption;
        this.points = points;
        this.forceUnevenDistribution = unevenDistribution;

    }

    @Override
    public boolean extractQuestionDetails(
            Map<String, String[]> requestParameters,
            FeedbackQuestionType questionType) {

        String distributeToRecipientsString =
                HttpRequestHelper.getValueFromParamMap(requestParameters,
                                                       Const.ParamsNames.FEEDBACK_QUESTION_CONSTSUMTORECIPIENTS);
        String pointsPerOptionString =
                HttpRequestHelper.getValueFromParamMap(requestParameters,
                                                       Const.ParamsNames.FEEDBACK_QUESTION_CONSTSUMPOINTSPEROPTION);
        String pointsString =
                HttpRequestHelper.getValueFromParamMap(requestParameters,
                                                       Const.ParamsNames.FEEDBACK_QUESTION_CONSTSUMPOINTS);
        String pointsForEachOptionString =
                HttpRequestHelper.getValueFromParamMap(requestParameters,
                                                       Const.ParamsNames.FEEDBACK_QUESTION_CONSTSUMPOINTSFOREACHOPTION);
        String pointsForEachRecipientString =
                HttpRequestHelper.getValueFromParamMap(requestParameters,
                                                       Const.ParamsNames.FEEDBACK_QUESTION_CONSTSUMPOINTSFOREACHRECIPIENT);

        Assumption.assertNotNull(""Null points in total"", pointsString);
        Assumption.assertNotNull(""Null points for each option"", pointsForEachOptionString);
        Assumption.assertNotNull(""Null points for each recipient"", pointsForEachRecipientString);
        String forceUnevenDistributionString =
                HttpRequestHelper.getValueFromParamMap(requestParameters,
                                                       Const.ParamsNames.FEEDBACK_QUESTION_CONSTSUMDISTRIBUTEUNEVENLY);

        boolean distributeToRecipients = ""true"".equals(distributeToRecipientsString);
        boolean pointsPerOption = ""true"".equals(pointsPerOptionString);

        int points = 0;
        if (pointsPerOption) {
            points = distributeToRecipients ? Integer.parseInt(pointsForEachRecipientString)
                                            : Integer.parseInt(pointsForEachOptionString);
        } else {
            points = Integer.parseInt(pointsString);
        }
        boolean forceUnevenDistribution = ""on"".equals(forceUnevenDistributionString);

        if (distributeToRecipients) {
            this.setConstantSumQuestionDetails(pointsPerOption, points, forceUnevenDistribution);
        } else {
            String numConstSumOptionsCreatedString =
                    HttpRequestHelper.getValueFromParamMap(requestParameters,
                                                           Const.ParamsNames.FEEDBACK_QUESTION_NUMBEROFCHOICECREATED);
            Assumption.assertNotNull(""Null number of choice for ConstSum"", numConstSumOptionsCreatedString);
            int numConstSumOptionsCreated = Integer.parseInt(numConstSumOptionsCreatedString);

            for (int i = 0; i < numConstSumOptionsCreated; i++) {
                String constSumOption =
                        HttpRequestHelper.getValueFromParamMap(
                                requestParameters, Const.ParamsNames.FEEDBACK_QUESTION_CONSTSUMOPTION + ""-"" + i);
                if (constSumOption != null && !constSumOption.trim().isEmpty()) {
                    constSumOptions.add(constSumOption);
                    numOfConstSumOptions++;
                }
            }
            this.setConstantSumQuestionDetails(constSumOptions, pointsPerOption, points, forceUnevenDistribution);
        }
        return true;
    }

    private void setConstantSumQuestionDetails(
            List<String> constSumOptions, boolean pointsPerOption,
            int points, boolean unevenDistribution) {

        this.numOfConstSumOptions = constSumOptions.size();
        this.constSumOptions = constSumOptions;
        this.distributeToRecipients = false;
        this.pointsPerOption = pointsPerOption;
        this.points = points;
        this.forceUnevenDistribution = unevenDistribution;

    }

    private void setConstantSumQuestionDetails(boolean pointsPerOption,
            int points, boolean unevenDistribution) {

        this.numOfConstSumOptions = 0;
        this.constSumOptions = new ArrayList<>();
        this.distributeToRecipients = true;
        this.pointsPerOption = pointsPerOption;
        this.points = points;
        this.forceUnevenDistribution = unevenDistribution;
    }

    @Override
    public String getQuestionTypeDisplayName() {
        if (distributeToRecipients) {
            return Const.FeedbackQuestionTypeNames.CONSTSUM_RECIPIENT;
        }
        return Const.FeedbackQuestionTypeNames.CONSTSUM_OPTION;
    }

    @Override
    public String getQuestionWithExistingResponseSubmissionFormHtml(
            boolean sessionIsOpen, int qnIdx, int responseIdx, String courseId,
            int totalNumRecipients,
            FeedbackResponseDetails existingResponseDetails) {

        FeedbackConstantSumResponseDetails existingConstSumResponse =
                (FeedbackConstantSumResponseDetails) existingResponseDetails;
        StringBuilder optionListHtml = new StringBuilder();
        String optionFragmentTemplate = FormTemplates.CONSTSUM_SUBMISSION_FORM_OPTIONFRAGMENT;

        if (distributeToRecipients) {
            String optionFragment =
                    Templates.populateTemplate(optionFragmentTemplate,
                            Slots.QUESTION_INDEX, Integer.toString(qnIdx),
                            Slots.RESPONSE_INDEX, Integer.toString(responseIdx),
                            Slots.OPTION_INDEX, ""0"",
                            Slots.DISABLED, sessionIsOpen ? """" : ""disabled"",
                            Slots.CONSTSUM_OPTION_VISIBILITY, ""style=\""display:none\"""",
                            Slots.MARGIN_LEFT, """",
                            Slots.CONSTSUM_OPTION_POINT, existingConstSumResponse.getAnswerString(),
                            Slots.FEEDBACK_RESPONSE_TEXT, Const.ParamsNames.FEEDBACK_RESPONSE_TEXT,
                            Slots.CONSTSUM_OPTION_VALUE, """");
            optionListHtml.append(optionFragment).append(Const.EOL);
        } else {
            for (int i = 0; i < constSumOptions.size(); i++) {
                String optionFragment =
                        Templates.populateTemplate(optionFragmentTemplate,
                                Slots.QUESTION_INDEX, Integer.toString(qnIdx),
                                Slots.RESPONSE_INDEX, Integer.toString(responseIdx),
                                Slots.OPTION_INDEX, Integer.toString(i),
                                Slots.DISABLED, sessionIsOpen ? """" : ""disabled"",
                                Slots.MARGIN_LEFT, ""margin-left-auto"",
                                Slots.CONSTSUM_OPTION_VISIBILITY, """",
                                Slots.CONSTSUM_OPTION_POINT,
                                        Integer.toString(existingConstSumResponse.getAnswerList().get(i)),
                                Slots.FEEDBACK_RESPONSE_TEXT, Const.ParamsNames.FEEDBACK_RESPONSE_TEXT,
                                Slots.CONSTSUM_OPTION_VALUE, SanitizationHelper.sanitizeForHtml(constSumOptions.get(i)));
                optionListHtml.append(optionFragment).append(Const.EOL);
            }
        }

        return Templates.populateTemplate(
                FormTemplates.CONSTSUM_SUBMISSION_FORM,
                Slots.CONSTSUM_SUBMISSION_FORM_OPTION_FRAGMENT, optionListHtml.toString(),
                Slots.QUESTION_INDEX, Integer.toString(qnIdx),
                Slots.RESPONSE_INDEX, Integer.toString(responseIdx),
                Slots.CONSTSUM_OPTION_VISIBILITY, distributeToRecipients ? ""style=\""display:none\"""" : """",
                Slots.CONSTSUM_TO_RECIPIENTS_VALUE, Boolean.toString(distributeToRecipients),
                Slots.CONSTSUM_POINTS_PER_OPTION_VALUE, Boolean.toString(pointsPerOption),
                Slots.CONSTSUM_NUM_OPTION_VALUE, Integer.toString(constSumOptions.size()),
                Slots.CONSTSUM_POINTS_VALUE, Integer.toString(points),
                Slots.CONSTSUM_UNEVEN_DISTRIBUTION_VALUE, Boolean.toString(forceUnevenDistribution),
                Slots.CONSTSUM_TO_RECIPIENTS, Const.ParamsNames.FEEDBACK_QUESTION_CONSTSUMTORECIPIENTS,
                Slots.CONSTSUM_POINTS_PER_OPTION, Const.ParamsNames.FEEDBACK_QUESTION_CONSTSUMPOINTSPEROPTION,
                Slots.CONSTSUM_NUM_OPTION, Const.ParamsNames.FEEDBACK_QUESTION_CONSTSUMNUMOPTION,
                Slots.CONSTSUM_PARAM_POINTS, Const.ParamsNames.FEEDBACK_QUESTION_CONSTSUMPOINTS,
                Slots.CONSTSUM_PARAM_POINTSFOREACHOPTION, Const.ParamsNames.FEEDBACK_QUESTION_CONSTSUMPOINTSFOREACHOPTION,
                Slots.CONSTSUM_PARAM_POINTSFOREACHRECIPIENT,
                        Const.ParamsNames.FEEDBACK_QUESTION_CONSTSUMPOINTSFOREACHRECIPIENT,
                Slots.CONSTSUM_PARAM_DISTRIBUTE_UNEVENLY, Const.ParamsNames.FEEDBACK_QUESTION_CONSTSUMDISTRIBUTEUNEVENLY
                );
    }

    @Override
    public String getQuestionWithoutExistingResponseSubmissionFormHtml(
            boolean sessionIsOpen, int qnIdx, int responseIdx, String courseId, int totalNumRecipients) {

        StringBuilder optionListHtml = new StringBuilder();
        String optionFragmentTemplate = FormTemplates.CONSTSUM_SUBMISSION_FORM_OPTIONFRAGMENT;

        if (distributeToRecipients) {
            String optionFragment =
                    Templates.populateTemplate(optionFragmentTemplate,
                            Slots.QUESTION_INDEX, Integer.toString(qnIdx),
                            Slots.RESPONSE_INDEX, Integer.toString(responseIdx),
                            Slots.OPTION_INDEX, ""0"",
                            Slots.DISABLED, sessionIsOpen ? """" : ""disabled"",
                            Slots.MARGIN_LEFT, """",
                            Slots.CONSTSUM_OPTION_VISIBILITY, ""style=\""display:none\"""",
                            Slots.CONSTSUM_OPTION_POINT, """",
                            Slots.FEEDBACK_RESPONSE_TEXT, Const.ParamsNames.FEEDBACK_RESPONSE_TEXT,
                            Slots.CONSTSUM_OPTION_VALUE, """");
            optionListHtml.append(optionFragment).append(Const.EOL);
        } else {
            for (int i = 0; i < constSumOptions.size(); i++) {
                String optionFragment =
                        Templates.populateTemplate(optionFragmentTemplate,
                                Slots.QUESTION_INDEX, Integer.toString(qnIdx),
                                Slots.RESPONSE_INDEX, Integer.toString(responseIdx),
                                Slots.OPTION_INDEX, Integer.toString(i),
                                Slots.DISABLED, sessionIsOpen ? """" : ""disabled"",
                                Slots.MARGIN_LEFT, ""margin-left-auto"",
                                Slots.CONSTSUM_OPTION_VISIBILITY, """",
                                Slots.CONSTSUM_OPTION_POINT, """",
                                Slots.FEEDBACK_RESPONSE_TEXT, Const.ParamsNames.FEEDBACK_RESPONSE_TEXT,
                                Slots.CONSTSUM_OPTION_VALUE, SanitizationHelper.sanitizeForHtml(constSumOptions.get(i)));
                optionListHtml.append(optionFragment).append(Const.EOL);
            }
        }

        return Templates.populateTemplate(
                FormTemplates.CONSTSUM_SUBMISSION_FORM,
                Slots.CONSTSUM_SUBMISSION_FORM_OPTION_FRAGMENT, optionListHtml.toString(),
                Slots.QUESTION_INDEX, Integer.toString(qnIdx),
                Slots.RESPONSE_INDEX, Integer.toString(responseIdx),
                Slots.CONSTSUM_OPTION_VISIBILITY, distributeToRecipients ? ""style=\""display:none\"""" : """",
                Slots.CONSTSUM_TO_RECIPIENTS_VALUE, Boolean.toString(distributeToRecipients),
                Slots.CONSTSUM_POINTS_PER_OPTION_VALUE, Boolean.toString(pointsPerOption),
                Slots.CONSTSUM_NUM_OPTION_VALUE, Integer.toString(constSumOptions.size()),
                Slots.CONSTSUM_POINTS_VALUE, Integer.toString(points),
                Slots.CONSTSUM_UNEVEN_DISTRIBUTION_VALUE, Boolean.toString(forceUnevenDistribution),
                Slots.CONSTSUM_TO_RECIPIENTS, Const.ParamsNames.FEEDBACK_QUESTION_CONSTSUMTORECIPIENTS,
                Slots.CONSTSUM_POINTS_PER_OPTION, Const.ParamsNames.FEEDBACK_QUESTION_CONSTSUMPOINTSPEROPTION,
                Slots.CONSTSUM_NUM_OPTION, Const.ParamsNames.FEEDBACK_QUESTION_CONSTSUMNUMOPTION,
                Slots.CONSTSUM_PARAM_POINTS, Const.ParamsNames.FEEDBACK_QUESTION_CONSTSUMPOINTS,
                Slots.CONSTSUM_PARAM_POINTSFOREACHOPTION, Const.ParamsNames.FEEDBACK_QUESTION_CONSTSUMPOINTSFOREACHOPTION,
                Slots.CONSTSUM_PARAM_POINTSFOREACHRECIPIENT,
                        Const.ParamsNames.FEEDBACK_QUESTION_CONSTSUMPOINTSFOREACHRECIPIENT,
                Slots.CONSTSUM_PARAM_DISTRIBUTE_UNEVENLY, Const.ParamsNames.FEEDBACK_QUESTION_CONSTSUMDISTRIBUTEUNEVENLY
                );
    }

    @Override
    public String getQuestionSpecificEditFormHtml(int questionNumber) {
        StringBuilder optionListHtml = new StringBuilder();
        String optionFragmentTemplate = FormTemplates.CONSTSUM_EDIT_FORM_OPTIONFRAGMENT;
        for (int i = 0; i < numOfConstSumOptions; i++) {
            String optionFragment =
                    Templates.populateTemplate(optionFragmentTemplate,
                            Slots.ITERATOR, Integer.toString(i),
                            Slots.CONSTSUM_OPTION_VALUE, SanitizationHelper.sanitizeForHtml(constSumOptions.get(i)),
                            Slots.CONSTSUM_PARAM_OPTION, Const.ParamsNames.FEEDBACK_QUESTION_CONSTSUMOPTION);

            optionListHtml.append(optionFragment).append(Const.EOL);
        }

        return Templates.populateTemplate(
                FormTemplates.CONSTSUM_EDIT_FORM,
                Slots.CONSTSUM_EDIT_FORM_OPTION_FRAGMENT, optionListHtml.toString(),
                Slots.QUESTION_NUMBER, Integer.toString(questionNumber),
                Slots.NUMBER_OF_CHOICE_CREATED, Const.ParamsNames.FEEDBACK_QUESTION_NUMBEROFCHOICECREATED,
                Slots.CONSTSUM_NUMBER_OF_OPTIONS, Integer.toString(numOfConstSumOptions),
                Slots.CONSTSUM_TO_RECIPIENTS_VALUE, Boolean.toString(distributeToRecipients),
                Slots.CONSTSUM_SELECTED_POINTS_PER_OPTION, pointsPerOption ? ""selected"" : """",
                Slots.CONSTSUM_OPTION_TABLE_VISIBILITY, distributeToRecipients ? ""style=\""display:none\"""" : """",
                Slots.CONSTSUM_POINTS, points == 0 ? ""100"" : Integer.toString(points),
                Slots.OPTION_DISPLAY, distributeToRecipients ? ""style=\""display:none\"""" : """",
                Slots.RECIPIENT_DISPLAY, distributeToRecipients ? """" : ""style=\""display:none\"""",
                Slots.PER_OPTION_CHECKED, !distributeToRecipients && pointsPerOption ? ""checked"" : """",
                Slots.PER_RECIPIENT_CHECKED, distributeToRecipients && pointsPerOption ? ""checked"" : """",
                Slots.OPTION_RECIPIENT_DISPLAY_NAME, distributeToRecipients ? ""recipient"" : ""option"",
                Slots.CONSTSUM_TOOLTIP_POINTS,
                        distributeToRecipients ? Const.Tooltips.FEEDBACK_QUESTION_CONSTSUMPOINTS_RECIPIENT
                                               : Const.Tooltips.FEEDBACK_QUESTION_CONSTSUMPOINTS_OPTION,
                Slots.CONSTSUM_TOOLTIP_POINTS_PER_OPTION, Const.Tooltips.FEEDBACK_QUESTION_CONSTSUMPOINTSFOREACHOPTION,
                Slots.CONSTSUM_TOOLTIP_POINTS_PER_RECIPIENT,
                        Const.Tooltips.FEEDBACK_QUESTION_CONSTSUMPOINTSFOREACHRECIPIENT,
                Slots.CONSTSUM_DISTRIBUTE_UNEVENLY, forceUnevenDistribution ? ""checked"" : """",
                Slots.CONSTSUM_TO_RECIPIENTS, Const.ParamsNames.FEEDBACK_QUESTION_CONSTSUMTORECIPIENTS,
                Slots.CONSTSUM_POINTS_PER_OPTION, Const.ParamsNames.FEEDBACK_QUESTION_CONSTSUMPOINTSPEROPTION,
                Slots.CONSTSUM_PARAM_POINTS, Const.ParamsNames.FEEDBACK_QUESTION_CONSTSUMPOINTS,
                Slots.CONSTSUM_PARAM_POINTSFOREACHOPTION, Const.ParamsNames.FEEDBACK_QUESTION_CONSTSUMPOINTSFOREACHOPTION,
                Slots.CONSTSUM_PARAM_POINTSFOREACHRECIPIENT,
                        Const.ParamsNames.FEEDBACK_QUESTION_CONSTSUMPOINTSFOREACHRECIPIENT,
                Slots.CONSTSUM_PARAM_DISTRIBUTE_UNEVENLY, Const.ParamsNames.FEEDBACK_QUESTION_CONSTSUMDISTRIBUTEUNEVENLY);

    }

    @Override
    public String getNewQuestionSpecificEditFormHtml() {
        // Add two empty options by default
        this.numOfConstSumOptions = 2;
        this.constSumOptions.add("""");
        this.constSumOptions.add("""");

        return ""<div id=\""constSumForm\"">""
                  + this.getQuestionSpecificEditFormHtml(-1)
             + ""</div>"";
    }

    @Override
    public String getQuestionAdditionalInfoHtml(int questionNumber,
            String additionalInfoId) {
        StringBuilder optionListHtml = new StringBuilder();
        String optionFragmentTemplate = FormTemplates.MSQ_ADDITIONAL_INFO_FRAGMENT;
        StringBuilder additionalInfo = new StringBuilder();

        if (distributeToRecipients) {
            additionalInfo.append(getQuestionTypeDisplayName()).append(""<br>"");
        } else if (numOfConstSumOptions > 0) {
            optionListHtml.append(""<ul style=\""list-style-type: disc;margin-left: 20px;\"" >"");
            for (int i = 0; i < numOfConstSumOptions; i++) {
                String optionFragment =
                        Templates.populateTemplate(optionFragmentTemplate,
                                Slots.MSQ_CHOICE_VALUE, constSumOptions.get(i));

                optionListHtml.append(optionFragment);
            }
            optionListHtml.append(""</ul>"");
            additionalInfo.append(Templates.populateTemplate(
                    FormTemplates.MSQ_ADDITIONAL_INFO,
                    Slots.QUESTION_TYPE_NAME, this.getQuestionTypeDisplayName(),
                    Slots.MSQ_ADDITIONAL_INFO_FRAGMENTS, optionListHtml.toString()));

        }
        //Point information
        additionalInfo.append(pointsPerOption
                              ? ""Points per "" + (distributeToRecipients ? ""recipient"" : ""option"") + "": "" + points
                              : ""Total points: "" + points);

        return Templates.populateTemplate(
                FormTemplates.FEEDBACK_QUESTION_ADDITIONAL_INFO,
                Slots.MORE, ""[more]"",
                Slots.LESS, ""[less]"",
                Slots.QUESTION_NUMBER, Integer.toString(questionNumber),
                Slots.ADDITIONAL_INFO_ID, additionalInfoId,
                Slots.QUESTION_ADDITIONAL_INFO, additionalInfo.toString());
    }

    @Override
    public String getQuestionResultStatisticsHtml(
            List<FeedbackResponseAttributes> responses,
            FeedbackQuestionAttributes question,
            String studentEmail,
            FeedbackSessionResultsBundle bundle,
            String view) {

        if (""student"".equals(view) || responses.isEmpty()) {
            return """";
        }

        StringBuilder fragments = new StringBuilder();
        List<String> options = constSumOptions;

        Map<String, List<Integer>> optionPoints = generateOptionPointsMapping(responses);

        DecimalFormat df = new DecimalFormat(""#.##"");

        Map<String, List<Integer>> sortedOptionPoints = new TreeMap<>();

        Map<String, String> identifierMap = new HashMap<>();

        if (distributeToRecipients) {
            putRecipientsInSortedMap(optionPoints, identifierMap, sortedOptionPoints, bundle);
        } else {
            putOptionsInSortedMap(optionPoints, options, sortedOptionPoints);
        }

        for (Entry<String, List<Integer>> entry : sortedOptionPoints.entrySet()) {

            List<Integer> points = entry.getValue();
            double average = computeAverage(points);
            int total = computeTotal(points);
            String pointsReceived = getListOfPointsAsString(points);

            if (distributeToRecipients) {
                String participantIdentifier = identifierMap.get(entry.getKey());
                String name = bundle.getNameForEmail(participantIdentifier);
                String teamName = bundle.getTeamNameForEmail(participantIdentifier);

                fragments.append(Templates.populateTemplate(FormTemplates.CONSTSUM_RESULT_STATS_RECIPIENTFRAGMENT,
                        Slots.CONSTSUM_OPTION_VALUE, SanitizationHelper.sanitizeForHtml(name),
                        Slots.TEAM, SanitizationHelper.sanitizeForHtml(teamName),
                        Slots.CONSTSUM_POINTS_RECEIVED, pointsReceived,
                        Slots.CONSTSUM_TOTAL_POINTS, Integer.toString(total),
                        Slots.CONSTSUM_AVERAGE_POINTS, df.format(average)));
            } else {
                String option = entry.getKey();

                fragments.append(Templates.populateTemplate(FormTemplates.CONSTSUM_RESULT_STATS_OPTIONFRAGMENT,
                        Slots.CONSTSUM_OPTION_VALUE, SanitizationHelper.sanitizeForHtml(option),
                        Slots.CONSTSUM_POINTS_RECEIVED, pointsReceived,
                        Slots.CONSTSUM_TOTAL_POINTS, Integer.toString(total),
                        Slots.CONSTSUM_AVERAGE_POINTS, df.format(average)));
            }
        }

        if (distributeToRecipients) {
            return Templates.populateTemplate(FormTemplates.CONSTSUM_RESULT_RECIPIENT_STATS,
                    Slots.OPTION_RECIPIENT_DISPLAY_NAME, ""Recipient"",
                    Slots.FRAGMENTS, fragments.toString());
        }
        return Templates.populateTemplate(FormTemplates.CONSTSUM_RESULT_OPTION_STATS,
                Slots.OPTION_RECIPIENT_DISPLAY_NAME, ""Option"",
                Slots.FRAGMENTS, fragments.toString());
    }

    @Override
    public String getQuestionResultStatisticsCsv(
            List<FeedbackResponseAttributes> responses,
            FeedbackQuestionAttributes question,
            FeedbackSessionResultsBundle bundle) {
        if (responses.isEmpty()) {
            return """";
        }

        StringBuilder fragments = new StringBuilder();
        List<String> options = constSumOptions;
        Map<String, List<Integer>> optionPoints = generateOptionPointsMapping(responses);

        DecimalFormat df = new DecimalFormat(""#.##"");

        Map<String, List<Integer>> sortedOptionPoints = new TreeMap<>();

        Map<String, String> identifierMap = new HashMap<>();

        if (distributeToRecipients) {
            putRecipientsInSortedMap(optionPoints, identifierMap, sortedOptionPoints, bundle);
        } else {
            putOptionsInSortedMap(optionPoints, options, sortedOptionPoints);
        }

        for (Entry<String, List<Integer>> entry : sortedOptionPoints.entrySet()) {
            String option;
            if (distributeToRecipients) {
                String participantIdentifier = identifierMap.get(entry.getKey());
                String teamName = bundle.getTeamNameForEmail(participantIdentifier);
                String recipientName = bundle.getNameForEmail(participantIdentifier);

                option = SanitizationHelper.sanitizeForCsv(teamName)
                         + "","" + SanitizationHelper.sanitizeForCsv(recipientName);
            } else {
                option = SanitizationHelper.sanitizeForCsv(entry.getKey());
            }

            List<Integer> points = entry.getValue();
            double average = computeAverage(points);
            double total = computeTotal(points);

            fragments.append(option)
                    .append(',').append(df.format(average))
                    .append(',').append(df.format(total))
                    .append(',').append(StringHelper.join("","", points))
                    .append(Const.EOL);

        }

        return (distributeToRecipients ? ""Team, Recipient"" : ""Option"")
               + "", Average Points, Total Points, Received Points"" + Const.EOL
               + fragments + Const.EOL;
    }

    /**
     * Puts recipients from an unsorted map to a sorted map.
     *
     * @param recipientMapping      Original map containing recipients
     * @param identifierMap         Helper map to retrieve email from name concatenated with email string
     * @param sortedOptionPoints    Sorted map to contain recipient info, recipient concatenated with email used as key
     */
    private void putRecipientsInSortedMap(
            Map<String, List<Integer>> recipientMapping, Map<String, String> identifierMap,
            Map<String, List<Integer>> sortedOptionPoints, FeedbackSessionResultsBundle bundle) {

        for (Entry<String, List<Integer>> entry : recipientMapping.entrySet()) {
            String participantIdentifier = entry.getKey();
            String name = bundle.getNameForEmail(participantIdentifier);
            String nameEmail = name + participantIdentifier;

            identifierMap.put(nameEmail, participantIdentifier);
            sortedOptionPoints.put(nameEmail, entry.getValue());
        }
    }

    /**
     * Puts options from an unsorted map to a sorted map.
     *
     * @param optionPoints          Original mapping of option points
     * @param optionList            List of options in question
     * @param sortedOptionPoints    Sorted map of option points
     */
    private void putOptionsInSortedMap(
            Map<String, List<Integer>> optionPoints, List<String> optionList,
            Map<String, List<Integer>> sortedOptionPoints) {

        for (Entry<String, List<Integer>> entry : optionPoints.entrySet()) {
            String option = optionList.get(Integer.parseInt(entry.getKey()));

            sortedOptionPoints.put(option, entry.getValue());
        }
    }

    /**
     * From the feedback responses, generate a mapping of the option to a list of points received for that option.
     * The key of the map returned is the option name / recipient's participant identifier.
     * The values of the map are list of points received by the key.
     * @param responses  a list of responses
     */
    private Map<String, List<Integer>> generateOptionPointsMapping(
            List<FeedbackResponseAttributes> responses) {

        Map<String, List<Integer>> optionPoints = new HashMap<>();
        for (FeedbackResponseAttributes response : responses) {
            FeedbackConstantSumResponseDetails frd = (FeedbackConstantSumResponseDetails) response.getResponseDetails();

            for (int i = 0; i < frd.getAnswerList().size(); i++) {
                String optionReceivingPoints =
                        distributeToRecipients ? response.recipient : String.valueOf(i);

                int pointsReceived = frd.getAnswerList().get(i);
                updateOptionPointsMapping(optionPoints, optionReceivingPoints, pointsReceived);
            }
        }
        return optionPoints;
    }

    /**
     * Used to update the OptionPointsMapping for the option optionReceivingPoints.
     */
    private void updateOptionPointsMapping(
            Map<String, List<Integer>> optionPoints,
            String optionReceivingPoints, int pointsReceived) {
        List<Integer> points = optionPoints.get(optionReceivingPoints);
        if (points == null) {
            points = new ArrayList<>();
            optionPoints.put(optionReceivingPoints, points);
        }

        points.add(pointsReceived);
    }

    /**
     * Returns the list of points as as string to display.
     */
    private String getListOfPointsAsString(List<Integer> points) {
        Collections.sort(points);
        StringBuilder pointsReceived = new StringBuilder();
        if (points.size() > 10) {
            for (int i = 0; i < 5; i++) {
                pointsReceived.append(points.get(i)).append("" , "");
            }
            pointsReceived.append(""..."");
            for (int i = points.size() - 5; i < points.size(); i++) {
                pointsReceived.append("" , "").append(points.get(i));
            }
        } else {
            for (int i = 0; i < points.size(); i++) {
                pointsReceived.append(points.get(i));
                if (i != points.size() - 1) {
                    pointsReceived.append("" , "");
                }
            }
        }
        return pointsReceived.toString();
    }

    private int computeTotal(List<Integer> points) {
        int total = 0;
        for (Integer point : points) {
            total += point;
        }
        return total;
    }

    private double computeAverage(List<Integer> points) {
        return (double) computeTotal(points) / points.size();
    }

    @Override
    public boolean isChangesRequiresResponseDeletion(
            FeedbackQuestionDetails newDetails) {
        FeedbackConstantSumQuestionDetails newConstSumDetails = (FeedbackConstantSumQuestionDetails) newDetails;

        if (this.numOfConstSumOptions != newConstSumDetails.numOfConstSumOptions
                || !this.constSumOptions.containsAll(newConstSumDetails.constSumOptions)
                || !newConstSumDetails.constSumOptions.containsAll(this.constSumOptions)) {
            return true;
        }

        if (this.distributeToRecipients != newConstSumDetails.distributeToRecipients) {
            return true;
        }

        if (this.points != newConstSumDetails.points) {
            return true;
        }

        if (this.pointsPerOption != newConstSumDetails.pointsPerOption) {
            return true;
        }

        return this.forceUnevenDistribution != newConstSumDetails.forceUnevenDistribution;
    }

    @Override
    public String getCsvHeader() {
        if (distributeToRecipients) {
            return ""Feedback"";
        }
        List<String> sanitizedOptions = SanitizationHelper.sanitizeListForCsv(constSumOptions);
        return ""Feedbacks:,"" + StringHelper.toString(sanitizedOptions, "","");
    }

    @Override
    public String getQuestionTypeChoiceOption() {
        // Constant sum has two options for user to select.
        return ""<li data-questiontype = \""CONSTSUM_OPTION\"">""
                 + ""<a href=\""javascript:;\"">"" + Const.FeedbackQuestionTypeNames.CONSTSUM_OPTION + ""</a>""
             + ""</li>""
             + ""<li data-questiontype = \""CONSTSUM_RECIPIENT\"">""
                 + ""<a href=\""javascript:;\"">"" + Const.FeedbackQuestionTypeNames.CONSTSUM_RECIPIENT + ""</a>""
             + ""</li>"";
    }

    @Override
    public List<String> validateQuestionDetails() {
        List<String> errors = new ArrayList<>();
        if (!distributeToRecipients && numOfConstSumOptions < Const.FeedbackQuestion.CONST_SUM_MIN_NUM_OF_OPTIONS) {
            errors.add(Const.FeedbackQuestion.CONST_SUM_ERROR_NOT_ENOUGH_OPTIONS
                       + Const.FeedbackQuestion.CONST_SUM_MIN_NUM_OF_OPTIONS + ""."");
        }

        if (points < Const.FeedbackQuestion.CONST_SUM_MIN_NUM_OF_POINTS) {
            errors.add(Const.FeedbackQuestion.CONST_SUM_ERROR_NOT_ENOUGH_POINTS
                       + Const.FeedbackQuestion.CONST_SUM_MIN_NUM_OF_POINTS + ""."");
        }

        if (!FieldValidator.areElementsUnique(constSumOptions)) {
            errors.add(Const.FeedbackQuestion.CONST_SUM_ERROR_DUPLICATE_OPTIONS);
        }

        return errors;
    }

    @Override
    public List<String> validateResponseAttributes(
            List<FeedbackResponseAttributes> responses,
            int numRecipients) {
        List<String> errors = new ArrayList<>();

        if (responses.isEmpty()) {
            //No responses, no errors.
            return errors;
        }

        String fqId = responses.get(0).feedbackQuestionId;
        FeedbackQuestionsLogic fqLogic = FeedbackQuestionsLogic.inst();
        FeedbackQuestionAttributes fqa = fqLogic.getFeedbackQuestion(fqId);

        int numOfResponseSpecific = fqa.numberOfEntitiesToGiveFeedbackTo;
        int maxResponsesPossible = numRecipients;
        if (numOfResponseSpecific == Const.MAX_POSSIBLE_RECIPIENTS
                || numOfResponseSpecific > maxResponsesPossible) {
            numOfResponseSpecific = maxResponsesPossible;
        }

        int numOptions = distributeToRecipients ? numOfResponseSpecific : constSumOptions.size();
        int totalPoints = pointsPerOption ? points * numOptions : points;
        int sum = 0;
        for (FeedbackResponseAttributes response : responses) {
            FeedbackConstantSumResponseDetails frd = (FeedbackConstantSumResponseDetails) response.getResponseDetails();

            //Check that all response points are >= 0
            for (Integer i : frd.getAnswerList()) {
                if (i < 0) {
                    errors.add(Const.FeedbackQuestion.CONST_SUM_ERROR_NEGATIVE);
                    return errors;
                }
            }

            //Check that points sum up properly
            if (distributeToRecipients) {
                sum += frd.getAnswerList().get(0);
            } else {
                sum = 0;
                for (Integer i : frd.getAnswerList()) {
                    sum += i;
                }
                if (sum != totalPoints || frd.getAnswerList().size() != constSumOptions.size()) {
                    errors.add(Const.FeedbackQuestion.CONST_SUM_ERROR_MISMATCH);
                    return errors;
                }
            }

            Set<Integer> answerSet = new HashSet<>();
            if (this.forceUnevenDistribution) {
                for (int i : frd.getAnswerList()) {
                    if (answerSet.contains(i)) {
                        errors.add(Const.FeedbackQuestion.CONST_SUM_ERROR_UNIQUE);
                        return errors;
                    }
                    answerSet.add(i);
                }
            }
        }
        if (distributeToRecipients && sum != totalPoints) {
            errors.add(Const.FeedbackQuestion.CONST_SUM_ERROR_MISMATCH + sum + ""/"" + totalPoints);
            return errors;
        }

        return errors;
    }

    @Override
    public Comparator<InstructorFeedbackResultsResponseRow> getResponseRowsSortOrder() {
        return null;
    }

    @Override
    public String validateGiverRecipientVisibility(FeedbackQuestionAttributes feedbackQuestionAttributes) {
        return """";
    }

    public int getNumOfConstSumOptions() {
        return numOfConstSumOptions;
    }

    public List<String> getConstSumOptions() {
        return constSumOptions;
    }

    public boolean isDistributeToRecipients() {
        return distributeToRecipients;
    }

    public boolean isPointsPerOption() {
        return pointsPerOption;
    }

    public int getPoints() {
        return points;
    }

}
"
FeedbackConstantSumResponseDetails.java,data-transfer,"package teammates.common.datatransfer.questions;

import java.util.ArrayList;
import java.util.List;

import teammates.common.util.Assumption;
import teammates.common.util.SanitizationHelper;

public class FeedbackConstantSumResponseDetails extends
        FeedbackResponseDetails {
    private List<Integer> answers;

    public FeedbackConstantSumResponseDetails() {
        super(FeedbackQuestionType.CONSTSUM);
    }

    @Override
    public void extractResponseDetails(FeedbackQuestionType questionType,
                                       FeedbackQuestionDetails questionDetails, String[] answer) {
        List<Integer> constSumAnswer = new ArrayList<>();
        for (String answerPart : answer) {
            try {
                constSumAnswer.add(Integer.parseInt(answerPart));
            } catch (NumberFormatException e) {
                constSumAnswer.add(0);
            }
        }
        FeedbackConstantSumQuestionDetails constSumQd = (FeedbackConstantSumQuestionDetails) questionDetails;
        this.setConstantSumResponseDetails(constSumAnswer,
                                           constSumQd.getConstSumOptions(),
                                           constSumQd.isDistributeToRecipients());
    }

    /**
     * Returns the list of answers (for constant sum to recipients, there will only be one answer).
     */
    public List<Integer> getAnswerList() {
        return answers;
    }

    @Override
    public String getAnswerString() {
        String listString = answers.toString(); //[1, 2, 3] format
        return listString.substring(1, listString.length() - 1); //remove []
    }

    @Override
    public String getAnswerHtmlInstructorView(FeedbackQuestionDetails questionDetails) {
        FeedbackConstantSumQuestionDetails csQd = (FeedbackConstantSumQuestionDetails) questionDetails;
        if (csQd.isDistributeToRecipients()) {
            return getAnswerString();
        }
        StringBuilder htmlBuilder = new StringBuilder(100);
        htmlBuilder.append(""<ul>"");
        for (int i = 0; i < answers.size(); i++) {
            String answerString = answers.get(i).toString();
            String optionString = csQd.getConstSumOptions().get(i);

            htmlBuilder.append(""<li>"");
            htmlBuilder.append(optionString).append("": "").append(SanitizationHelper.sanitizeForHtml(answerString));
            htmlBuilder.append(""</li>"");
        }
        htmlBuilder.append(""</ul>"");
        return htmlBuilder.toString();
    }

    @Override
    public String getAnswerCsv(FeedbackQuestionDetails questionDetails) {
        StringBuilder csvBuilder = new StringBuilder();

        for (int i = 0; i < answers.size(); i++) {
            if (!((FeedbackConstantSumQuestionDetails) questionDetails).isDistributeToRecipients()) {
                csvBuilder.append(',');
            }
            csvBuilder.append(answers.get(i));
        }

        return csvBuilder.toString();
    }

    private void setConstantSumResponseDetails(List<Integer> answers, List<String> constSumOptions,
                                               boolean distributeToRecipients) {
        this.answers = answers;
        if (!distributeToRecipients) {
            Assumption.assertEquals(""ConstSum num response does not match num of options. ""
                                            + answers.size() + ""/"" + constSumOptions.size(),
                                    answers.size(), constSumOptions.size());
        }
    }

}
"
FeedbackContributionQuestionDetails.java,data-transfer,"package teammates.common.datatransfer.questions;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

import teammates.common.datatransfer.FeedbackParticipantType;
import teammates.common.datatransfer.FeedbackSessionResultsBundle;
import teammates.common.datatransfer.StudentResultSummary;
import teammates.common.datatransfer.TeamEvalResult;
import teammates.common.datatransfer.attributes.FeedbackQuestionAttributes;
import teammates.common.datatransfer.attributes.FeedbackResponseAttributes;
import teammates.common.util.Const;
import teammates.common.util.HttpRequestHelper;
import teammates.common.util.Logger;
import teammates.common.util.SanitizationHelper;
import teammates.common.util.Templates;
import teammates.common.util.Templates.FeedbackQuestion.FormTemplates;
import teammates.common.util.Templates.FeedbackQuestion.Slots;
import teammates.ui.template.InstructorFeedbackResultsResponseRow;

public class FeedbackContributionQuestionDetails extends FeedbackQuestionDetails {

    private static final Logger log = Logger.getLogger();

    private boolean isNotSureAllowed;

    public FeedbackContributionQuestionDetails() {
        super(FeedbackQuestionType.CONTRIB);
        isNotSureAllowed = true;
    }

    public FeedbackContributionQuestionDetails(String questionText) {
        super(FeedbackQuestionType.CONTRIB, questionText);
        isNotSureAllowed = true;
    }

    private void setContributionQuestionDetails(boolean isNotSureAllowed) {
        this.isNotSureAllowed = isNotSureAllowed;
    }

    @Override
    public boolean extractQuestionDetails(
            Map<String, String[]> requestParameters,
            FeedbackQuestionType questionType) {
        String isNotSureAllowedString = HttpRequestHelper.getValueFromParamMap(
                requestParameters,
                Const.ParamsNames.FEEDBACK_QUESTION_CONTRIBISNOTSUREALLOWED);
        boolean isNotSureAllowed = ""on"".equals(isNotSureAllowedString);
        this.setContributionQuestionDetails(isNotSureAllowed);
        return true;
    }

    @Override
    public String getQuestionTypeDisplayName() {
        return Const.FeedbackQuestionTypeNames.CONTRIB;
    }

    @Override
    public boolean isChangesRequiresResponseDeletion(FeedbackQuestionDetails newDetails) {
        FeedbackContributionQuestionDetails newContribDetails = (FeedbackContributionQuestionDetails) newDetails;
        return newContribDetails.isNotSureAllowed != this.isNotSureAllowed;
    }

    @Override
    public boolean isIndividualResponsesShownToStudents() {
        return false;
    }

    @Override
    public String getQuestionWithExistingResponseSubmissionFormHtml(boolean sessionIsOpen, int qnIdx,
            int responseIdx, String courseId, int totalNumRecipients, FeedbackResponseDetails existingResponseDetails) {

        FeedbackContributionResponseDetails frd = (FeedbackContributionResponseDetails) existingResponseDetails;
        int points = frd.getAnswer();
        String optionSelectFragmentsHtml = getContributionOptionsHtml(points);

        return Templates.populateTemplate(
                FormTemplates.CONTRIB_SUBMISSION_FORM,
                Slots.QUESTION_INDEX, Integer.toString(qnIdx),
                Slots.RESPONSE_INDEX, Integer.toString(responseIdx),
                Slots.FEEDBACK_RESPONSE_TEXT, Const.ParamsNames.FEEDBACK_RESPONSE_TEXT,
                Slots.DISABLED, sessionIsOpen ? """" : ""disabled"",
                Slots.CONTRIB_SELECT_FRAGMENTS_HTML, optionSelectFragmentsHtml,
                Slots.CONTRIB_EQUAL_SHARE_HELP, getEqualShareHelpLinkIfNeeded(responseIdx));
    }

    @Override
    public String getQuestionWithoutExistingResponseSubmissionFormHtml(
            boolean sessionIsOpen, int qnIdx, int responseIdx, String courseId, int totalNumRecipients) {

        String optionSelectHtml = getContributionOptionsHtml(Const.INT_UNINITIALIZED);

        return Templates.populateTemplate(
                FormTemplates.CONTRIB_SUBMISSION_FORM,
                Slots.QUESTION_INDEX, Integer.toString(qnIdx),
                Slots.RESPONSE_INDEX, Integer.toString(responseIdx),
                Slots.FEEDBACK_RESPONSE_TEXT, Const.ParamsNames.FEEDBACK_RESPONSE_TEXT,
                Slots.DISABLED, sessionIsOpen ? """" : ""disabled"",
                Slots.CONTRIB_SELECT_FRAGMENTS_HTML, optionSelectHtml,
                Slots.CONTRIB_EQUAL_SHARE_HELP, getEqualShareHelpLinkIfNeeded(responseIdx));
    }

    @Override
    public String getQuestionSpecificEditFormHtml(int questionNumber) {
        return Templates.populateTemplate(
                FormTemplates.CONTRIB_EDIT_FORM,
                Slots.QUESTION_NUMBER, Integer.toString(questionNumber),
                Slots.CONTRIB_IS_NOT_SURE_ALLOWED_CHECKED, isNotSureAllowed ? ""checked"" : """",
                Slots.CONTRIB_PARAM_IS_NOT_SURE_ALLOWED_CHECKED,
                        Const.ParamsNames.FEEDBACK_QUESTION_CONTRIBISNOTSUREALLOWED);
    }

    @Override
    public String getNewQuestionSpecificEditFormHtml() {
        isNotSureAllowed = true;

        return ""<div id=\""contribForm\"">""
                  + getQuestionSpecificEditFormHtml(-1)
             + ""</div>"";
    }

    @Override
    public String getQuestionAdditionalInfoHtml(int questionNumber, String additionalInfoId) {
        String additionalInfo = this.getQuestionTypeDisplayName();

        return Templates.populateTemplate(
                FormTemplates.FEEDBACK_QUESTION_ADDITIONAL_INFO,
                Slots.MORE, ""[more]"",
                Slots.LESS, ""[less]"",
                Slots.QUESTION_NUMBER, Integer.toString(questionNumber),
                Slots.ADDITIONAL_INFO_ID, additionalInfoId,
                Slots.QUESTION_ADDITIONAL_INFO, additionalInfo);
    }

    /**
     * Uses classes from evaluations to calculate statistics.
     * Uses actualResponses from FeedbackSessionResultsBundle - need to hide data that should be hidden.
     *      Hide name and teamName if recipient should not be visible.
     */
    @Override
    public String getQuestionResultStatisticsHtml(List<FeedbackResponseAttributes> responses,
            FeedbackQuestionAttributes question,
            String studentEmail,
            FeedbackSessionResultsBundle bundle,
            String view) {
        if (""question"".equals(view)) { //for instructor, only question view has stats.
            return getQuestionResultsStatisticsHtmlQuestionView(responses, question, bundle);
        } else if (""student"".equals(view)) { //Student view of stats.
            return getQuestionResultStatisticsHtmlStudentView(responses, question, studentEmail, bundle);
        } else {
            return """";
        }
    }

    private String getQuestionResultStatisticsHtmlStudentView(List<FeedbackResponseAttributes> responses,
            FeedbackQuestionAttributes question,
            String studentEmail,
            FeedbackSessionResultsBundle bundle) {

        if (responses.isEmpty()) {
            return """";
        }

        String currentUserTeam = bundle.emailTeamNameTable.get(studentEmail);

        List<FeedbackResponseAttributes> actualResponses = getActualResponses(question, bundle);

        //List of teams with at least one response
        List<String> teamNames = getTeamsWithAtLeastOneResponse(actualResponses, bundle);

        //Each team's member(email) list
        Map<String, List<String>> teamMembersEmail = getTeamMembersEmail(bundle, teamNames);

        //Each team's responses
        Map<String, List<FeedbackResponseAttributes>> teamResponses = getTeamResponses(
                actualResponses, bundle, teamNames);

        //Get each team's submission array. -> int[teamSize][teamSize]
        //Where int[0][1] refers points from student 0 to student 1
        //Where student 0 is the 0th student in the list in teamMembersEmail
        Map<String, int[][]> teamSubmissionArray = getTeamSubmissionArray(
                teamNames, teamMembersEmail, teamResponses);

        //Each team's contribution question results.
        Map<String, TeamEvalResult> teamResults = getTeamResults(teamNames, teamSubmissionArray, teamMembersEmail);

        TeamEvalResult currentUserTeamResults = teamResults.get(currentUserTeam);
        if (currentUserTeamResults == null) {
            return """";
        }

        int currentUserIndex = teamMembersEmail.get(currentUserTeam).indexOf(studentEmail);
        int selfClaim = currentUserTeamResults.claimed[currentUserIndex][currentUserIndex];
        int teamClaim = currentUserTeamResults.denormalizedAveragePerceived[currentUserIndex][currentUserIndex];

        String contribAdditionalInfo = Templates.populateTemplate(
                FormTemplates.CONTRIB_ADDITIONAL_INFO,
                Slots.MORE, ""[how to interpret, etc..]"",
                Slots.LESS, ""[less]"",
                Slots.QUESTION_NUMBER, Integer.toString(question.questionNumber),
                Slots.ADDITIONAL_INFO_ID, ""contributionInfo"",
                Slots.QUESTION_ADDITIONAL_INFO, FormTemplates.CONTRIB_RESULT_STATS_STUDENT_INFO);

        return Templates.populateTemplate(
                FormTemplates.CONTRIB_RESULT_STATS_STUDENT,
                Slots.CONTRIB_ADDITIONAL_INFO, contribAdditionalInfo,
                Slots.CONTRIB_MY_VIEW_OF_ME, getPointsAsColorizedHtml(selfClaim),
                Slots.CONTRIB_MY_VIEW_OF_OTHERS,
                        getNormalizedPointsListColorizedDescending(currentUserTeamResults.claimed[currentUserIndex],
                        currentUserIndex),
                Slots.CONTRIB_TEAM_VIEW_OF_ME, getPointsAsColorizedHtml(teamClaim),
                Slots.CONTRIB_TEAM_VIEW_OF_OTHERS,
                getNormalizedPointsListColorizedDescending(
                        currentUserTeamResults.denormalizedAveragePerceived[currentUserIndex], currentUserIndex));
    }

    private String getQuestionResultsStatisticsHtmlQuestionView(List<FeedbackResponseAttributes> responses,
            FeedbackQuestionAttributes question,
            FeedbackSessionResultsBundle bundle) {

        if (responses.isEmpty()) {
            return """";
        }

        List<FeedbackResponseAttributes> actualResponses = getActualResponses(question, bundle);

        //List of teams visible to the instructor and in the selected section
        List<String> teamNames = getTeamNames(bundle);

        //Each team's member(email) list
        Map<String, List<String>> teamMembersEmail = getTeamMembersEmail(bundle, teamNames);

        //Each team's responses
        Map<String, List<FeedbackResponseAttributes>> teamResponses = getTeamResponses(
                actualResponses, bundle, teamNames);

        //Get each team's submission array. -> int[teamSize][teamSize]
        //Where int[0][1] refers points from student 0 to student 1
        //Where student 0 is the 0th student in the list in teamMembersEmail
        Map<String, int[][]> teamSubmissionArray = getTeamSubmissionArray(
                teamNames, teamMembersEmail, teamResponses);

        //Each team's eval results.
        Map<String, TeamEvalResult> teamResults = getTeamResults(teamNames, teamSubmissionArray, teamMembersEmail);

        //Each person's results summary
        Map<String, StudentResultSummary> studentResults = getStudentResults(
                teamMembersEmail, teamResults);

        //Check visibility of recipient
        boolean hideRecipient = false;
        FeedbackParticipantType type = question.recipientType;
        for (FeedbackResponseAttributes response : actualResponses) {
            if (!bundle.visibilityTable.get(response.getId())[1]
                    && type != FeedbackParticipantType.SELF
                    && type != FeedbackParticipantType.NONE) {
                hideRecipient = true;
            }
        }

        StringBuilder contribFragments = new StringBuilder();

        for (Map.Entry<String, StudentResultSummary> entry : studentResults.entrySet()) {
            StudentResultSummary summary = entry.getValue();
            String email = entry.getKey();
            String name = bundle.roster.getStudentForEmail(email).name;
            String team = bundle.roster.getStudentForEmail(email).team;

            List<String> teamEmails = teamMembersEmail.get(team);
            TeamEvalResult teamResult = teamResults.get(team);
            int studentIndx = teamEmails.indexOf(email);

            String displayName = name;
            String displayTeam = team;

            if (hideRecipient) {
                displayName = FeedbackSessionResultsBundle.getAnonName(type, name);
                displayTeam = displayName + Const.TEAM_OF_EMAIL_OWNER;
            }
            int[] incomingPoints = new int[teamResult.normalizedPeerContributionRatio.length];
            for (int i = 0; i < incomingPoints.length; i++) {
                incomingPoints[i] = teamResult.normalizedPeerContributionRatio[i][studentIndx];
            }
            contribFragments.append(Templates.populateTemplate(
                    FormTemplates.CONTRIB_RESULT_STATS_FRAGMENT,
                    Slots.CONTRIB_STUDENT_TEAM, SanitizationHelper.sanitizeForHtml(displayTeam),
                    Slots.CONTRIB_STUDENT_NAME, SanitizationHelper.sanitizeForHtml(displayName),
                    Slots.CONTRIB_CC, getPointsAsColorizedHtml(summary.claimedToInstructor),
                    Slots.CONTRIB_PC, getPointsAsColorizedHtml(summary.perceivedToInstructor),
                    Slots.CONTRIB_DIFF, getPointsDiffAsHtml(summary),
                    Slots.CONTRIB_RR, getNormalizedPointsListColorizedDescending(incomingPoints, studentIndx),
                    Slots.CONTRIB_PARAM_STUDENT_NAME, Const.ParamsNames.STUDENT_NAME));
        }

        return Templates.populateTemplate(
                FormTemplates.CONTRIB_RESULT_STATS,
                Slots.CONTRIB_FRAGMENTS, contribFragments.toString(),
                Slots.CONTRIB_TOOLTIPS_CLAIMED, SanitizationHelper.sanitizeForHtml(Const.Tooltips.CLAIMED),
                Slots.CONTRIB_TOOLTIPS_PERCEIVED, Const.Tooltips.PERCEIVED,
                Slots.CONTRIB_TOOLTIPS_POINTS_RECEIVED, Const.Tooltips.FEEDBACK_CONTRIBUTION_POINTS_RECEIVED,
                Slots.CONTRIB_TOOLTIPS_DIFF, Const.Tooltips.FEEDBACK_CONTRIBUTION_DIFF);
    }

    @Override
    public String getQuestionResultStatisticsCsv(
            List<FeedbackResponseAttributes> responses,
            FeedbackQuestionAttributes question,
            FeedbackSessionResultsBundle bundle) {

        if (responses.isEmpty()) {
            return """";
        }

        List<FeedbackResponseAttributes> actualResponses = getActualResponses(question, bundle);

        //List of teams visible to the instructor and in the selected section
        List<String> teamNames = getTeamNames(bundle);

        //Each team's member(email) list
        Map<String, List<String>> teamMembersEmail = getTeamMembersEmail(bundle, teamNames);

        //Each team's responses
        Map<String, List<FeedbackResponseAttributes>> teamResponses = getTeamResponses(
                actualResponses, bundle, teamNames);

        //Get each team's submission array. -> int[teamSize][teamSize]
        //Where int[0][1] refers points from student 0 to student 1
        //Where student 0 is the 0th student in the list in teamMembersEmail
        Map<String, int[][]> teamSubmissionArray = getTeamSubmissionArray(
                teamNames, teamMembersEmail, teamResponses);

        //Each team's eval results.
        Map<String, TeamEvalResult> teamResults = getTeamResults(teamNames, teamSubmissionArray, teamMembersEmail);

        //Each person's results summary
        Map<String, StudentResultSummary> studentResults = getStudentResults(
                teamMembersEmail, teamResults);

        //Check visibility of recipient
        boolean hideRecipient = false;

        FeedbackParticipantType type = question.recipientType;
        for (FeedbackResponseAttributes response : actualResponses) {
            if (!bundle.visibilityTable.get(response.getId())[1]
                    && type != FeedbackParticipantType.SELF
                    && type != FeedbackParticipantType.NONE) {
                hideRecipient = true;
            }
        }

        StringBuilder contribFragments = new StringBuilder();

        Map<String, String> sortedMap = new LinkedHashMap<>();

        for (Map.Entry<String, StudentResultSummary> entry : studentResults.entrySet()) {
            StudentResultSummary summary = entry.getValue();
            String email = entry.getKey();
            String name = bundle.roster.getStudentForEmail(email).name;
            String team = bundle.roster.getStudentForEmail(email).team;

            List<String> teamEmails = teamMembersEmail.get(team);
            TeamEvalResult teamResult = teamResults.get(team);
            int studentIndx = teamEmails.indexOf(email);

            String displayName;
            String displayTeam;
            String displayEmail;
            if (hideRecipient) {
                displayName = FeedbackSessionResultsBundle.getAnonName(type, name);
                displayTeam = displayName + Const.TEAM_OF_EMAIL_OWNER;
                displayEmail = Const.USER_NOBODY_TEXT;
            } else {
                displayName = name;
                displayTeam = team;
                displayEmail = email;
            }

            int[] incomingPoints = new int[teamResult.normalizedPeerContributionRatio.length];
            for (int i = 0; i < incomingPoints.length; i++) {
                incomingPoints[i] = teamResult.normalizedPeerContributionRatio[i][studentIndx];
            }

            String contribFragmentString =
                    SanitizationHelper.sanitizeForCsv(displayTeam) + "",""
                    + SanitizationHelper.sanitizeForCsv(displayName) + "",""
                    + SanitizationHelper.sanitizeForCsv(displayEmail) + "",""
                    + SanitizationHelper.sanitizeForCsv(Integer.toString(summary.claimedToInstructor)) + "",""
                    + SanitizationHelper.sanitizeForCsv(Integer.toString(summary.perceivedToInstructor)) + "",""
                    + SanitizationHelper.sanitizeForCsv(getNormalizedPointsListDescending(incomingPoints, studentIndx))
                    + Const.EOL;

            // Replace all Unset values
            contribFragmentString = contribFragmentString.replaceAll(Integer.toString(Const.INT_UNINITIALIZED), ""N/A"");
            contribFragmentString = contribFragmentString.replaceAll(Integer.toString(Const.POINTS_NOT_SURE), ""Not Sure"");
            contribFragmentString =
                    contribFragmentString.replaceAll(Integer.toString(Const.POINTS_NOT_SUBMITTED), ""Not Submitted"");

            //For sorting purposes
            sortedMap.put(displayTeam + ""-%-"" + displayName, contribFragmentString);

        }

        for (Map.Entry<String, String> entry : sortedMap.entrySet()) {
            contribFragments.append(entry.getValue());
        }

        String csvPointsExplanation =
                ""In the points given below, an equal share is equal to 100 points. ""
                + ""e.g. 80 means \""Equal share - 20%\"" and 110 means \""Equal share + 10%\""."" + Const.EOL
                + ""Claimed Contribution (CC) = the contribution claimed by the student."" + Const.EOL
                + ""Perceived Contribution (PC) = the average value of student's contribution ""
                + ""as perceived by the team members."" + Const.EOL
                + ""Team, Name, Email, CC, PC, Ratings Recieved"" + Const.EOL;
        return csvPointsExplanation + contribFragments + Const.EOL;
    }

    private List<String> getTeamNames(FeedbackSessionResultsBundle bundle) {
        List<String> teamNames = new ArrayList<>();
        for (Set<String> teamNamesForSection : bundle.sectionTeamNameTable.values()) {
            teamNames.addAll(teamNamesForSection);
        }
        Collections.sort(teamNames);
        return teamNames;
    }

    /**
     * Returns A Map with student email as key and StudentResultSummary as value for the specified question.
     */
    Map<String, StudentResultSummary> getStudentResults(FeedbackSessionResultsBundle bundle,
            FeedbackQuestionAttributes question) {

        List<FeedbackResponseAttributes> responses = getActualResponses(question, bundle);

        List<String> teamNames = getTeamsWithAtLeastOneResponse(responses, bundle);

        Map<String, List<String>> teamMembersEmail = getTeamMembersEmail(bundle, teamNames);

        Map<String, List<FeedbackResponseAttributes>> teamResponses = getTeamResponses(
                responses, bundle, teamNames);

        Map<String, int[][]> teamSubmissionArray = getTeamSubmissionArray(
                teamNames, teamMembersEmail, teamResponses);

        Map<String, TeamEvalResult> teamResults = getTeamResults(teamNames, teamSubmissionArray, teamMembersEmail);

        return getStudentResults(teamMembersEmail, teamResults);
    }

    /**
     * Returns A Map with student email as key and TeamEvalResult as value for the specified question.
     */
    Map<String, TeamEvalResult> getTeamEvalResults(FeedbackSessionResultsBundle bundle,
            FeedbackQuestionAttributes question) {

        List<FeedbackResponseAttributes> responses = getActualResponses(question, bundle);

        List<String> teamNames = getTeamsWithAtLeastOneResponse(responses, bundle);

        Map<String, List<String>> teamMembersEmail = getTeamMembersEmail(bundle, teamNames);

        Map<String, List<FeedbackResponseAttributes>> teamResponses = getTeamResponses(
                responses, bundle, teamNames);

        Map<String, int[][]> teamSubmissionArray = getTeamSubmissionArray(
                teamNames, teamMembersEmail, teamResponses);

        return getTeamResults(teamNames, teamSubmissionArray, teamMembersEmail);
    }

    private Map<String, StudentResultSummary> getStudentResults(
            Map<String, List<String>> teamMembersEmail,
            Map<String, TeamEvalResult> teamResults) {
        Map<String, StudentResultSummary> studentResults = new LinkedHashMap<>();
        for (Map.Entry<String, TeamEvalResult> entry : teamResults.entrySet()) {
            TeamEvalResult teamResult = entry.getValue();
            List<String> teamEmails = teamMembersEmail.get(entry.getKey());
            int i = 0;
            for (String studentEmail : teamEmails) {
                StudentResultSummary summary = new StudentResultSummary();
                summary.claimedToInstructor = teamResult.normalizedClaimed[i][i];
                summary.perceivedToInstructor = teamResult.normalizedAveragePerceived[i];

                studentResults.put(studentEmail, summary);

                i++;
            }
        }
        return studentResults;
    }

    @SuppressWarnings(""PMD.UnusedPrivateMethod"") // false positive by PMD.
    private Map<String, TeamEvalResult> getTeamResults(List<String> teamNames,
            Map<String, int[][]> teamSubmissionArray, Map<String, List<String>> teamMembersEmail) {
        Map<String, TeamEvalResult> teamResults = new LinkedHashMap<>();
        for (String team : teamNames) {
            TeamEvalResult teamEvalResult = new TeamEvalResult(teamSubmissionArray.get(team));
            teamEvalResult.studentEmails = teamMembersEmail.get(team);
            teamResults.put(team, teamEvalResult);
        }
        return teamResults;
    }

    private Map<String, int[][]> getTeamSubmissionArray(List<String> teamNames,
            Map<String, List<String>> teamMembersEmail,
            Map<String, List<FeedbackResponseAttributes>> teamResponses) {
        Map<String, int[][]> teamSubmissionArray = new LinkedHashMap<>();
        for (String team : teamNames) {
            int teamSize = teamMembersEmail.get(team).size();
            teamSubmissionArray.put(team, new int[teamSize][teamSize]);
            //Initialize all as not submitted.
            for (int i = 0; i < teamSize; i++) {
                for (int j = 0; j < teamSize; j++) {
                    teamSubmissionArray.get(team)[i][j] = Const.POINTS_NOT_SUBMITTED;
                }
            }
            //Fill in submitted points
            List<FeedbackResponseAttributes> teamResponseList = teamResponses.get(team);
            List<String> memberEmailList = teamMembersEmail.get(team);
            for (FeedbackResponseAttributes response : teamResponseList) {
                int giverIndx = memberEmailList.indexOf(response.giver);
                int recipientIndx = memberEmailList.indexOf(response.recipient);
                if (giverIndx == -1 || recipientIndx == -1) {
                    continue;
                }
                int points = ((FeedbackContributionResponseDetails) response.getResponseDetails()).getAnswer();
                teamSubmissionArray.get(team)[giverIndx][recipientIndx] = points;
            }
        }
        return teamSubmissionArray;
    }

    private Map<String, List<FeedbackResponseAttributes>> getTeamResponses(
            List<FeedbackResponseAttributes> responses,
            FeedbackSessionResultsBundle bundle, List<String> teamNames) {
        Map<String, List<FeedbackResponseAttributes>> teamResponses = new LinkedHashMap<>();
        for (String teamName : teamNames) {
            teamResponses.put(teamName, new ArrayList<FeedbackResponseAttributes>());
        }
        for (FeedbackResponseAttributes response : responses) {
            String team = bundle.emailTeamNameTable.get(response.giver);
            if (teamResponses.containsKey(team)) {
                teamResponses.get(team).add(response);
            }
        }
        return teamResponses;
    }

    private Map<String, List<String>> getTeamMembersEmail(
            FeedbackSessionResultsBundle bundle, List<String> teamNames) {
        Map<String, List<String>> teamMembersEmail = new LinkedHashMap<>();
        for (String teamName : teamNames) {
            if (Const.USER_TEAM_FOR_INSTRUCTOR.equals(teamName)) {
                // skip instructors team (contrib questions should only have responses from student teams)
                continue;
            }
            List<String> memberEmails = new ArrayList<>(bundle.rosterTeamNameMembersTable.get(teamName));
            Collections.sort(memberEmails);
            teamMembersEmail.put(teamName, memberEmails);
        }
        return teamMembersEmail;
    }

    private List<String> getTeamsWithAtLeastOneResponse(
            List<FeedbackResponseAttributes> responses,
            FeedbackSessionResultsBundle bundle) {
        List<String> teamNames = new ArrayList<>();
        for (FeedbackResponseAttributes response : responses) {
            String teamNameOfResponseGiver = bundle.getTeamNameForEmail(response.giver);
            if (!teamNames.contains(teamNameOfResponseGiver)) {
                teamNames.add(teamNameOfResponseGiver);
            }
        }
        return teamNames;
    }

    private List<FeedbackResponseAttributes> getActualResponses(
            FeedbackQuestionAttributes question,
            FeedbackSessionResultsBundle bundle) {
        List<FeedbackResponseAttributes> responses;
        String questionId = question.getId();
        //Get all actual responses for this question.
        responses = new ArrayList<>();
        for (FeedbackResponseAttributes response : bundle.actualResponses) {
            if (response.feedbackQuestionId.equals(questionId)) {
                responses.add(response);
            }
        }
        Collections.sort(responses, bundle.compareByGiverRecipientQuestion);
        return responses;
    }

    private static String getNormalizedPointsListColorizedDescending(int[] subs, int index) {
        List<String> result = new ArrayList<>();
        for (int i = 0; i < subs.length; i++) {
            if (i == index) {
                continue;
            }
            result.add(getPointsAsColorizedHtml(subs[i]));
        }

        if (result.isEmpty()) {
            return getPointsAsColorizedHtml(Const.POINTS_NOT_SUBMITTED);
        }
        Collections.sort(result);
        Collections.reverse(result);

        StringBuilder resultString = new StringBuilder();
        for (String s : result) {
            if (resultString.length() != 0) {
                resultString.append("", "");
            }
            resultString.append(s);
        }
        return resultString.toString();
    }

    private static String getNormalizedPointsListDescending(int[] subs, int index) {
        List<String> result = new ArrayList<>();
        for (int i = 0; i < subs.length; i++) {
            if (i == index) {
                continue;
            }
            result.add(Integer.toString(subs[i]));
        }
        if (result.isEmpty()) {
            return Integer.toString(Const.INT_UNINITIALIZED);
        }
        Collections.sort(result);
        Collections.reverse(result);

        StringBuilder resultString = new StringBuilder();
        for (String s : result) {
            if (resultString.length() != 0) {
                resultString.append("", "");
            }
            resultString.append(s);
        }
        return resultString.toString();
    }

    /**
     * Method to color the points by adding <code>span</code> tag with appropriate
     * class (posDiff and negDiff).
     * Positive points will be green, negative will be red, 0 will be black.
     * This will also put N/A or Not Sure for respective points representation.
     * The output will be E+x% for positive points, E-x% for negative points,
     * and just E for equal share.
     * Zero contribution will be printed as 0%
     * @param points
     *         In terms of full percentage, so equal share will be 100, 20% more
     *         from equal share will be 120, etc.
     */
    private static String getPointsAsColorizedHtml(int points) {
        if (points == Const.POINTS_NOT_SUBMITTED || points == Const.INT_UNINITIALIZED) {
            return ""<span class=\""color_neutral\"" data-toggle=\""tooltip\"" data-placement=\""top\"" title=\""""
                   + Const.Tooltips.FEEDBACK_CONTRIBUTION_NOT_AVAILABLE + ""\"">N/A</span>"";
        } else if (points == Const.POINTS_NOT_SURE) {
            return ""<span class=\""color-negative\"" data-toggle=\""tooltip\"" data-placement=\""top\"" title=\""""
                   + Const.Tooltips.FEEDBACK_CONTRIBUTION_NOT_SURE + ""\"">N/S</span>"";
        } else if (points == 0) {
            return ""<span class=\""color-negative\"">0%</span>"";
        } else if (points > 100) {
            return ""<span class=\""color-positive\"">E +"" + (points - 100) + ""%</span>"";
        } else if (points < 100) {
            return ""<span class=\""color-negative\"">E -"" + (100 - points) + ""%</span>"";
        } else {
            return ""<span class=\""color_neutral\"">E</span>"";
        }
    }

    private static String getPointsDiffAsHtml(StudentResultSummary summary) {
        int claimed = summary.claimedToInstructor;
        int perceived = summary.perceivedToInstructor;
        int diff = perceived - claimed;
        if (perceived == Const.POINTS_NOT_SUBMITTED || perceived == Const.INT_UNINITIALIZED
                || claimed == Const.POINTS_NOT_SUBMITTED || claimed == Const.INT_UNINITIALIZED) {
            return ""<span class=\""color_neutral\"" data-toggle=\""tooltip\"" data-placement=\""top\"" ""
                   + ""data-container=\""body\"" title=\"""" + Const.Tooltips.FEEDBACK_CONTRIBUTION_NOT_AVAILABLE
                   + ""\"">N/A</span>"";
        } else if (perceived == Const.POINTS_NOT_SURE || claimed == Const.POINTS_NOT_SURE) {
            return ""<span class=\""color-negative\"" data-toggle=\""tooltip\"" data-placement=\""top\"" ""
                   + ""data-container=\""body\"" title=\"""" + Const.Tooltips.FEEDBACK_CONTRIBUTION_NOT_SURE + ""\"">N/S""
                   + ""</span>"";
        } else if (diff > 0) {
            return ""<span class=\""color-positive\""> + "" + diff + ""%</span>"";
        } else if (diff < 0) {
            return ""<span class=\""color-negative\"">"" + diff + ""%</span>"";
        } else {
            return ""<span>"" + diff + ""</span>"";
        }
    }

    @Override
    public String getCsvHeader() {
        return ""Feedback"";
    }

    @Override
    public String getQuestionTypeChoiceOption() {
        return ""<li data-questiontype = \""CONTRIB\""><a href=\""javascript:;\"">""
               + Const.FeedbackQuestionTypeNames.CONTRIB + ""</a></li>"";
    }

    @Override
    public List<String> validateQuestionDetails() {
        return new ArrayList<>();
    }

    @Override
    public List<String> validateResponseAttributes(
            List<FeedbackResponseAttributes> responses,
            int numRecipients) {
        List<String> errors = new ArrayList<>();
        for (FeedbackResponseAttributes response : responses) {
            boolean validAnswer = false;
            FeedbackContributionResponseDetails frd = (FeedbackContributionResponseDetails) response.getResponseDetails();

            // Valid answers: 0, 10, 20, .... 190, 200
            boolean isValidRange = frd.getAnswer() >= 0 && frd.getAnswer() <= 200;
            boolean isMultipleOf10 = frd.getAnswer() % 10 == 0;
            if (isValidRange && isMultipleOf10) {
                validAnswer = true;
            }
            if (frd.getAnswer() == Const.POINTS_NOT_SURE || frd.getAnswer() == Const.POINTS_NOT_SUBMITTED) {
                validAnswer = true;
            }
            if (!validAnswer) {
                errors.add(Const.FeedbackQuestion.CONTRIB_ERROR_INVALID_OPTION);
            }
        }
        return errors;
    }

    @Override
    public String validateGiverRecipientVisibility(FeedbackQuestionAttributes feedbackQuestionAttributes) {
        String errorMsg = """";

        // giver type can only be STUDENTS
        if (feedbackQuestionAttributes.giverType != FeedbackParticipantType.STUDENTS) {
            log.severe(""Unexpected giverType for contribution question: "" + feedbackQuestionAttributes.giverType
                       + "" (forced to :"" + FeedbackParticipantType.STUDENTS + "")"");
            feedbackQuestionAttributes.giverType = FeedbackParticipantType.STUDENTS;
            errorMsg = Const.FeedbackQuestion.CONTRIB_ERROR_INVALID_FEEDBACK_PATH;
        }

        // recipient type can only be OWN_TEAM_MEMBERS_INCLUDING_SELF
        if (feedbackQuestionAttributes.recipientType != FeedbackParticipantType.OWN_TEAM_MEMBERS_INCLUDING_SELF) {
            log.severe(""Unexpected recipientType for contribution question: ""
                       + feedbackQuestionAttributes.recipientType
                       + "" (forced to :"" + FeedbackParticipantType.OWN_TEAM_MEMBERS_INCLUDING_SELF + "")"");
            feedbackQuestionAttributes.recipientType = FeedbackParticipantType.OWN_TEAM_MEMBERS_INCLUDING_SELF;
            errorMsg = Const.FeedbackQuestion.CONTRIB_ERROR_INVALID_FEEDBACK_PATH;
        }

        // restrictions on visibility options
        if (!(feedbackQuestionAttributes.showResponsesTo.contains(FeedbackParticipantType.RECEIVER)
                == feedbackQuestionAttributes.showResponsesTo.contains(FeedbackParticipantType.RECEIVER_TEAM_MEMBERS)
                && feedbackQuestionAttributes.showResponsesTo.contains(FeedbackParticipantType.RECEIVER_TEAM_MEMBERS)
                == feedbackQuestionAttributes.showResponsesTo.contains(FeedbackParticipantType.OWN_TEAM_MEMBERS))) {
            log.severe(""Unexpected showResponsesTo for contribution question: ""
                       + feedbackQuestionAttributes.showResponsesTo + "" (forced to :""
                       + Const.FeedbackQuestion.COMMON_VISIBILITY_OPTIONS
                                               .get(""ANONYMOUS_TO_RECIPIENT_AND_TEAM_VISIBLE_TO_INSTRUCTORS"")
                       + "")"");
            feedbackQuestionAttributes.showResponsesTo = Arrays.asList(FeedbackParticipantType.RECEIVER,
                                                                       FeedbackParticipantType.RECEIVER_TEAM_MEMBERS,
                                                                       FeedbackParticipantType.OWN_TEAM_MEMBERS,
                                                                       FeedbackParticipantType.INSTRUCTORS);
            errorMsg = Const.FeedbackQuestion.CONTRIB_ERROR_INVALID_VISIBILITY_OPTIONS;
        }

        return errorMsg;
    }

    static String getPerceivedContributionInEqualShareFormatHtml(int i) {
        return ""<span>&nbsp;&nbsp;[""
                + ""Perceived Contribution: ""
                + convertToEqualShareFormatHtml(i)
                + ""]</span>"";
    }

    private String getPerceivedContributionHtml(FeedbackQuestionAttributes question,
            String targetEmail, FeedbackSessionResultsBundle bundle) {

        if (hasPerceivedContribution(targetEmail, question, bundle)) {
            Map<String, StudentResultSummary> stats =
                    FeedbackContributionResponseDetails.getContribQnStudentResultSummary(question, bundle);
            StudentResultSummary studentResult = stats.get(targetEmail);
            int pc = studentResult.perceivedToInstructor;

            return FeedbackContributionQuestionDetails.getPerceivedContributionInEqualShareFormatHtml(pc);
        }
        return """";
    }

    private boolean hasPerceivedContribution(String email, FeedbackQuestionAttributes question,
                                             FeedbackSessionResultsBundle bundle) {
        Map<String, StudentResultSummary> stats =
                FeedbackContributionResponseDetails.getContribQnStudentResultSummary(question, bundle);
        return stats.containsKey(email);
    }

    /**
     * Used to display missing responses between a possible giver and a possible recipient.
     * Returns ""No Response"" with the Perceived Contribution if the giver is the recipient.
     * Otherwise, returns ""No Response"".
     */
    @Override
    public String getNoResponseTextInHtml(String giverEmail, String recipientEmail,
                                          FeedbackSessionResultsBundle bundle,
                                          FeedbackQuestionAttributes question) {
        boolean isPerceivedContributionShown = giverEmail.equals(recipientEmail)
                                               && hasPerceivedContribution(recipientEmail, question, bundle);

        // in the row for the student's self response,
        // show the perceived contribution if the student has one
        return ""<i>"" + Const.INSTRUCTOR_FEEDBACK_RESULTS_MISSING_RESPONSE + ""</i>""
               + (isPerceivedContributionShown ? getPerceivedContributionHtml(question, recipientEmail, bundle)
                                               : """");
    }

    /*
     * The functions below are taken and modified from EvalSubmissionEditPageData.java
     * -------------------------------------------------------------------------------
     */

    /**
     * Returns the options for contribution share in a team.
     */
    private String getContributionOptionsHtml(int pointsParam) {
        int points = pointsParam;
        if (points == Const.INT_UNINITIALIZED) {
            points = Const.POINTS_NOT_SUBMITTED;
        }

        StringBuilder result = new StringBuilder(200);
        result.append(""<option class=\""""
                     + getContributionOptionsColor(Const.POINTS_NOT_SUBMITTED)
                     + ""\"" value=\"""" + Const.POINTS_NOT_SUBMITTED + ""\""""
                     + (points == Const.POINTS_NOT_SUBMITTED ? "" selected"" : """") + "">""
                     + convertToEqualShareFormat(Const.POINTS_NOT_SUBMITTED) + ""</option>"");
        for (int i = 200; i >= 0; i -= 10) {
            result.append(""<option class=\""""
                        + getContributionOptionsColor(i)
                        + ""\"" value=\"""" + i + ""\""""
                        + (i == points ? ""selected"" : """")
                        + "">"" + convertToEqualShareFormat(i)
                        + ""</option>\r\n"");
        }
        if (isNotSureAllowed) {
            result.append(""<option class=\""""
                          + getContributionOptionsColor(Const.POINTS_NOT_SURE)
                          + ""\"" value=\"""" + Const.POINTS_NOT_SURE + ""\""""
                          + (points == Const.POINTS_NOT_SURE ? "" selected"" : """")
                          + "">Not Sure</option>"");
        }
        return result.toString();
    }

    /**
     * Returns the CSS color of different point.
     */
    private String getContributionOptionsColor(int points) {
        if (points == Const.POINTS_NOT_SURE
                || points == Const.POINTS_EQUAL_SHARE
                || points == Const.POINTS_NOT_SUBMITTED) {
            // Not sure, Equal Share, Not Submitted
            return ""color_neutral"";
        } else if (points < Const.POINTS_EQUAL_SHARE) {
            // Negative share
            return ""color-negative"";
        } else {
            // Positive share
            return ""color-positive"";
        }
    }

    /**
     * Converts points in integer to String.
     * @return points in text form ""Equal Share...""
     */
    static String convertToEqualShareFormat(int i) {
        if (i > 100) {
            return ""Equal share + "" + (i - 100) + ""%""; // Do more
        } else if (i == 100) {
            return ""Equal share""; // Do same
        } else if (i > 0) {
            return ""Equal share - "" + (100 - i) + ""%""; // Do less
        } else if (i == 0) {
            return ""0%""; // Do none
        } else if (i == Const.POINTS_NOT_SURE) {
            return ""Not Sure"";
        } else {
            return """";
        }
    }

    /**
     * Converts points in integer to String for HTML display.
     * @return points in text form ""Equal Share..."" with html formatting for colors.
     */
    static String convertToEqualShareFormatHtml(int i) {
        if (i == Const.INT_UNINITIALIZED) {
            return ""<span class=\""color_neutral\"">N/A</span>"";
        } else if (i == Const.POINTS_NOT_SUBMITTED) {
            return ""<span class=\""color_neutral\""></span>"";
        } else if (i == Const.POINTS_NOT_SURE) {
            return ""<span class=\""color-negative\"">Not Sure</span>"";
        } else if (i == 0) {
            return ""<span class=\""color-negative\"">0%</span>"";
        } else if (i > 100) {
            return ""<span class=\""color-positive\"">Equal Share +"" + (i - 100) + ""%</span>"";
        } else if (i < 100) {
            return ""<span class=\""color-negative\"">Equal Share -"" + (100 - i) + ""%</span>"";
        } else {
            return ""<span class=\""color_neutral\"">Equal Share</span>"";
        }
    }

    @Override
    public boolean isQuestionSkipped(String[] answer) {
        if (answer == null) {
            return true;
        }
        for (String ans : answer) {
            if (!ans.trim().isEmpty() && Integer.parseInt(ans) != Const.POINTS_NOT_SUBMITTED) {
                return false;
            }
        }
        return true;
    }

    @Override
    public Comparator<InstructorFeedbackResultsResponseRow> getResponseRowsSortOrder() {
        return null;
    }

    private String getEqualShareHelpLinkIfNeeded(int responseIdx) {
        return responseIdx == 0
                ? ""<span class=\""glyphicon glyphicon-info-sign\""></span>""
                      + "" More info about the <code>Equal Share</code> scale""
                : """";
    }

    @Override
    public boolean isCommentsOnResponsesAllowed() {
        return false;
    }
}
"
FeedbackContributionResponseDetails.java,data-transfer,"package teammates.common.datatransfer.questions;

import java.util.HashMap;
import java.util.Map;

import teammates.common.datatransfer.FeedbackSessionResultsBundle;
import teammates.common.datatransfer.StudentResultSummary;
import teammates.common.datatransfer.TeamEvalResult;
import teammates.common.datatransfer.attributes.FeedbackQuestionAttributes;
import teammates.common.datatransfer.attributes.FeedbackResponseAttributes;
import teammates.common.util.Const;
import teammates.common.util.Logger;
import teammates.common.util.SanitizationHelper;

public class FeedbackContributionResponseDetails extends FeedbackResponseDetails {

    private static final Logger log = Logger.getLogger();

    /**This is the claimed points from giver to recipient.
    */
    private int answer;

    public FeedbackContributionResponseDetails() {
        super(FeedbackQuestionType.CONTRIB);
        answer = Const.POINTS_NOT_SUBMITTED;
    }

    public FeedbackContributionResponseDetails(int answer) {
        super(FeedbackQuestionType.CONTRIB);
        this.answer = answer;
    }

    @Override
    public void extractResponseDetails(FeedbackQuestionType questionType,
                                       FeedbackQuestionDetails questionDetails, String[] answer) {
        try {
            int contribAnswer = Integer.parseInt(answer[0]);
            setAnswer(contribAnswer);
        } catch (NumberFormatException e) {
            log.severe(""Failed to parse contrib answer to integer - "" + answer[0]);
            throw e;
        }
    }

    /**
     * Gets answer in integer form.
     */
    public int getAnswer() {
        return answer;
    }

    @Override
    public String getAnswerString() {
        return Integer.toString(answer);
    }

    // Not used for contribution question, due to calculations required. See corresponding function below.
    @Override
    public String getAnswerHtmlInstructorView(FeedbackQuestionDetails questionDetails) {
        return FeedbackContributionQuestionDetails.convertToEqualShareFormatHtml(getAnswer());
    }

    // Not used for contribution question, due to calculations required. See corresponding function below.
    @Override
    public String getAnswerCsv(FeedbackQuestionDetails questionDetails) {
        return SanitizationHelper.sanitizeForCsv(FeedbackContributionQuestionDetails.convertToEqualShareFormat(getAnswer()));
    }

    @Override
    public String getAnswerHtml(FeedbackResponseAttributes response, FeedbackQuestionAttributes question,
                                FeedbackSessionResultsBundle feedbackSessionResultsBundle) {
        return getContributionQuestionResponseAnswerHtml(response, question, feedbackSessionResultsBundle);
    }

    @Override
    public String getAnswerCsv(FeedbackResponseAttributes response, FeedbackQuestionAttributes question,
                               FeedbackSessionResultsBundle feedbackSessionResultsBundle) {
        return getContributionQuestionResponseAnswerCsv(response, question, feedbackSessionResultsBundle);
    }

    private void setAnswer(int answer) {
        this.answer = answer;
    }

    private String getContributionQuestionResponseAnswerHtml(
            FeedbackResponseAttributes response,
            FeedbackQuestionAttributes question,
            FeedbackSessionResultsBundle feedbackSessionResultsBundle) {
        Map<String, TeamEvalResult> teamResults = getContribQnTeamEvalResult(question, feedbackSessionResultsBundle);

        // Need to get actual team name and giver/recipient emails here,
        // only for getting the responseAnswer.
        FeedbackResponseAttributes actualResponse = feedbackSessionResultsBundle.getActualResponse(response);
        String giverTeamName = feedbackSessionResultsBundle.emailTeamNameTable.get(actualResponse.giver);
        TeamEvalResult teamResult = teamResults.get(giverTeamName);

        int giverIndex = teamResult.studentEmails.indexOf(actualResponse.giver);
        int recipientIndex = teamResult.studentEmails.indexOf(actualResponse.recipient);

        if (giverIndex == -1 || recipientIndex == -1) {
            if (giverIndex == -1) {
                log.severe(""getContributionQuestionResponseAnswerHtml - giverIndex is -1\n""
                        + ""Cannot find giver: "" + actualResponse.giver + ""\n""
                        + ""CourseId: "" + feedbackSessionResultsBundle.feedbackSession.getCourseId() + ""\n""
                        + ""Session Name: "" + feedbackSessionResultsBundle.feedbackSession.getFeedbackSessionName() + ""\n""
                        + ""Response Id: "" + actualResponse.getId());
            }
            if (recipientIndex == -1) {
                log.severe(""getContributionQuestionResponseAnswerHtml - recipientIndex is -1\n""
                        + ""Cannot find recipient: "" + actualResponse.recipient + ""\n""
                        + ""CourseId: "" + feedbackSessionResultsBundle.feedbackSession.getCourseId() + ""\n""
                        + ""Session Name: "" + feedbackSessionResultsBundle.feedbackSession.getFeedbackSessionName() + ""\n""
                        + ""Response Id: "" + actualResponse.getId());
            }

            return """";
        }

        Map<String, StudentResultSummary> stats = getContribQnStudentResultSummary(question, feedbackSessionResultsBundle);

        if (response.giver.equals(response.recipient)) {
            StudentResultSummary studentResult = stats.get(response.giver);
            String responseAnswerHtml = FeedbackContributionQuestionDetails.convertToEqualShareFormatHtml(
                                              studentResult.claimedToInstructor);

            //For CONTRIB qns, We want to show PC if giver == recipient.
            int pc = studentResult.perceivedToInstructor;
            return responseAnswerHtml
                 + FeedbackContributionQuestionDetails.getPerceivedContributionInEqualShareFormatHtml(pc);
        }
        return FeedbackContributionQuestionDetails.convertToEqualShareFormatHtml(
                                        teamResult.normalizedPeerContributionRatio[giverIndex][recipientIndex]);
    }

    private String getContributionQuestionResponseAnswerCsv(
            FeedbackResponseAttributes response,
            FeedbackQuestionAttributes question,
            FeedbackSessionResultsBundle feedbackSessionResultsBundle) {
        Map<String, TeamEvalResult> teamResults = getContribQnTeamEvalResult(question, feedbackSessionResultsBundle);
        Map<String, StudentResultSummary> stats = getContribQnStudentResultSummary(question, feedbackSessionResultsBundle);

        // Need to get actual team name and giver/recipient emails here,
        // only for getting the responseAnswer.
        FeedbackResponseAttributes actualResponse = feedbackSessionResultsBundle.getActualResponse(response);
        String giverTeamName = feedbackSessionResultsBundle.emailTeamNameTable.get(actualResponse.giver);
        TeamEvalResult teamResult = teamResults.get(giverTeamName);

        int giverIndex = teamResult.studentEmails.indexOf(actualResponse.giver);
        int recipientIndex = teamResult.studentEmails.indexOf(actualResponse.recipient);

        String responseAnswerCsv = """";

        if (giverIndex == -1 || recipientIndex == -1) {
            if (giverIndex == -1) {
                log.severe(""getContributionQuestionResponseAnswerCsv - giverIndex is -1\n""
                        + ""Cannot find giver: "" + actualResponse.giver + ""\n""
                        + ""CourseId: "" + feedbackSessionResultsBundle.feedbackSession.getCourseId() + ""\n""
                        + ""Session Name: "" + feedbackSessionResultsBundle.feedbackSession.getFeedbackSessionName() + ""\n""
                        + ""Response Id: "" + actualResponse.getId());
            }
            if (recipientIndex == -1) {
                log.severe(""getContributionQuestionResponseAnswerCsv - recipientIndex is -1\n""
                        + ""Cannot find recipient: "" + actualResponse.recipient + ""\n""
                        + ""CourseId: "" + feedbackSessionResultsBundle.feedbackSession.getCourseId() + ""\n""
                        + ""Session Name: "" + feedbackSessionResultsBundle.feedbackSession.getFeedbackSessionName() + ""\n""
                        + ""Response Id: "" + actualResponse.getId());
            }
        } else {
            responseAnswerCsv = SanitizationHelper.sanitizeForCsv(
                    FeedbackContributionQuestionDetails.convertToEqualShareFormat(
                            teamResult.normalizedPeerContributionRatio[giverIndex][recipientIndex]));

            if (response.giver.equals(response.recipient)) {
                StudentResultSummary studentResult = stats.get(response.giver);
                responseAnswerCsv = SanitizationHelper.sanitizeForCsv(
                        FeedbackContributionQuestionDetails.convertToEqualShareFormat(
                                studentResult.claimedToInstructor));
            }
        }
        return responseAnswerCsv;
    }

    // TODO: check if this can be made non-static
    public static Map<String, StudentResultSummary> getContribQnStudentResultSummary(FeedbackQuestionAttributes question,
            FeedbackSessionResultsBundle feedbackSessionResultsBundle) {
        Map<String, StudentResultSummary> contribQnStats =
                feedbackSessionResultsBundle.contributionQuestionStudentResultSummary.get(question.getId());
        if (contribQnStats == null) {
            FeedbackContributionQuestionDetails fqcd = (FeedbackContributionQuestionDetails) question.getQuestionDetails();
            contribQnStats = fqcd.getStudentResults(feedbackSessionResultsBundle, question);

            //Convert email to anonEmail and add stats.
            Map<String, StudentResultSummary> anonContribQnStats = new HashMap<>();
            for (Map.Entry<String, StudentResultSummary> entry : contribQnStats.entrySet()) {
                anonContribQnStats.put(
                        feedbackSessionResultsBundle.getAnonEmailFromStudentEmail(entry.getKey()), entry.getValue());
            }
            for (Map.Entry<String, StudentResultSummary> entry : anonContribQnStats.entrySet()) {
                if (contribQnStats.get(entry.getKey()) == null) {
                    contribQnStats.put(entry.getKey(), entry.getValue());
                }
            }

            feedbackSessionResultsBundle.contributionQuestionStudentResultSummary.put(question.getId(), contribQnStats);
        }

        return contribQnStats;
    }

    public Map<String, TeamEvalResult> getContribQnTeamEvalResult(FeedbackQuestionAttributes question,
            FeedbackSessionResultsBundle feedbackSessionResultsBundle) {
        Map<String, TeamEvalResult> contribQnStats =
                feedbackSessionResultsBundle.contributionQuestionTeamEvalResults.get(question.getId());
        if (contribQnStats == null) {
            FeedbackContributionQuestionDetails fqcd = (FeedbackContributionQuestionDetails) question.getQuestionDetails();
            contribQnStats = fqcd.getTeamEvalResults(feedbackSessionResultsBundle, question);
            feedbackSessionResultsBundle.contributionQuestionTeamEvalResults.put(question.getId(), contribQnStats);
        }

        return contribQnStats;
    }
}
"
FeedbackMcqQuestionDetails.java,data-transfer,"package teammates.common.datatransfer.questions;

import java.text.DecimalFormat;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;

import teammates.common.datatransfer.FeedbackParticipantType;
import teammates.common.datatransfer.FeedbackSessionResultsBundle;
import teammates.common.datatransfer.TeamDetailsBundle;
import teammates.common.datatransfer.attributes.FeedbackQuestionAttributes;
import teammates.common.datatransfer.attributes.FeedbackResponseAttributes;
import teammates.common.datatransfer.attributes.InstructorAttributes;
import teammates.common.datatransfer.attributes.StudentAttributes;
import teammates.common.exception.EntityDoesNotExistException;
import teammates.common.util.Assumption;
import teammates.common.util.Const;
import teammates.common.util.HttpRequestHelper;
import teammates.common.util.SanitizationHelper;
import teammates.common.util.Templates;
import teammates.common.util.Templates.FeedbackQuestion.FormTemplates;
import teammates.common.util.Templates.FeedbackQuestion.Slots;
import teammates.logic.core.CoursesLogic;
import teammates.logic.core.InstructorsLogic;
import teammates.logic.core.StudentsLogic;
import teammates.ui.template.InstructorFeedbackResultsResponseRow;

public class FeedbackMcqQuestionDetails extends FeedbackQuestionDetails {
    private int numOfMcqChoices;
    private List<String> mcqChoices;
    private boolean otherEnabled;
    private FeedbackParticipantType generateOptionsFor;

    public FeedbackMcqQuestionDetails() {
        super(FeedbackQuestionType.MCQ);

        this.numOfMcqChoices = 0;
        this.mcqChoices = new ArrayList<>();
        this.otherEnabled = false;
        this.generateOptionsFor = FeedbackParticipantType.NONE;
    }

    public int getNumOfMcqChoices() {
        return numOfMcqChoices;
    }

    public List<String> getMcqChoices() {
        return mcqChoices;
    }

    public FeedbackParticipantType getGenerateOptionsFor() {
        return generateOptionsFor;
    }

    @Override
    public boolean extractQuestionDetails(
            Map<String, String[]> requestParameters,
            FeedbackQuestionType questionType) {

        int numOfMcqChoices = 0;
        List<String> mcqChoices = new LinkedList<>();
        boolean mcqOtherEnabled = false; // TODO change this when implementing ""other, please specify"" field

        if (""on"".equals(HttpRequestHelper.getValueFromParamMap(
                                requestParameters, Const.ParamsNames.FEEDBACK_QUESTION_MCQOTHEROPTIONFLAG))) {
            mcqOtherEnabled = true;
        }

        String generatedMcqOptions =
                HttpRequestHelper.getValueFromParamMap(requestParameters,
                                                       Const.ParamsNames.FEEDBACK_QUESTION_GENERATEDOPTIONS);

        if (generatedMcqOptions.equals(FeedbackParticipantType.NONE.toString())) {
            String numMcqChoicesCreatedString =
                    HttpRequestHelper.getValueFromParamMap(requestParameters,
                                                           Const.ParamsNames.FEEDBACK_QUESTION_NUMBEROFCHOICECREATED);
            Assumption.assertNotNull(""Null number of choice for MCQ"", numMcqChoicesCreatedString);
            int numMcqChoicesCreated = Integer.parseInt(numMcqChoicesCreatedString);

            for (int i = 0; i < numMcqChoicesCreated; i++) {
                String paramName = Const.ParamsNames.FEEDBACK_QUESTION_MCQCHOICE + ""-"" + i;
                String mcqChoice = HttpRequestHelper.getValueFromParamMap(requestParameters, paramName);
                if (mcqChoice != null && !mcqChoice.trim().isEmpty()) {
                    mcqChoices.add(mcqChoice);
                    numOfMcqChoices++;
                }
            }

            setMcqQuestionDetails(numOfMcqChoices, mcqChoices, mcqOtherEnabled);
        } else {
            setMcqQuestionDetails(FeedbackParticipantType.valueOf(generatedMcqOptions));
        }
        return true;
    }

    private void setMcqQuestionDetails(int numOfMcqChoices,
            List<String> mcqChoices,
            boolean otherEnabled) {
        this.numOfMcqChoices = numOfMcqChoices;
        this.mcqChoices = mcqChoices;
        this.otherEnabled = otherEnabled;
        this.generateOptionsFor = FeedbackParticipantType.NONE;
    }

    private void setMcqQuestionDetails(FeedbackParticipantType generateOptionsFor) {
        this.numOfMcqChoices = 0;
        this.mcqChoices = new ArrayList<>();
        this.otherEnabled = false;
        this.generateOptionsFor = generateOptionsFor;
        Assumption.assertTrue(""Can only generate students, teams or instructors"",
                generateOptionsFor == FeedbackParticipantType.STUDENTS
                || generateOptionsFor == FeedbackParticipantType.TEAMS
                || generateOptionsFor == FeedbackParticipantType.INSTRUCTORS);
    }

    @Override
    public String getQuestionTypeDisplayName() {
        return Const.FeedbackQuestionTypeNames.MCQ;
    }

    public boolean getOtherEnabled() {
        return otherEnabled;
    }

    @Override
    public boolean isChangesRequiresResponseDeletion(FeedbackQuestionDetails newDetails) {
        FeedbackMcqQuestionDetails newMcqDetails = (FeedbackMcqQuestionDetails) newDetails;

        if (this.numOfMcqChoices != newMcqDetails.numOfMcqChoices
                || !this.mcqChoices.containsAll(newMcqDetails.mcqChoices)
                || !newMcqDetails.mcqChoices.containsAll(this.mcqChoices)) {
            return true;
        }

        if (this.generateOptionsFor != newMcqDetails.generateOptionsFor) {
            return true;
        }

        return this.otherEnabled != newMcqDetails.otherEnabled;
    }

    @Override
    public String getQuestionWithExistingResponseSubmissionFormHtml(boolean sessionIsOpen, int qnIdx,
            int responseIdx, String courseId, int totalNumRecipients, FeedbackResponseDetails existingResponseDetails) {
        FeedbackMcqResponseDetails existingMcqResponse = (FeedbackMcqResponseDetails) existingResponseDetails;
        List<String> choices = generateOptionList(courseId);

        StringBuilder optionListHtml = new StringBuilder();
        String optionFragmentTemplate = FormTemplates.MCQ_SUBMISSION_FORM_OPTIONFRAGMENT;
        Boolean isOtherSelected = existingMcqResponse.isOtherOptionAnswer();

        for (int i = 0; i < choices.size(); i++) {
            String optionFragment =
                    Templates.populateTemplate(optionFragmentTemplate,
                            Slots.QUESTION_INDEX, Integer.toString(qnIdx),
                            Slots.RESPONSE_INDEX, Integer.toString(responseIdx),
                            Slots.DISABLED, sessionIsOpen ? """" : ""disabled"",
                            Slots.CHECKED,
                                    existingMcqResponse.getAnswerString().equals(choices.get(i)) ? ""checked"" : """",
                            Slots.FEEDBACK_RESPONSE_TEXT, Const.ParamsNames.FEEDBACK_RESPONSE_TEXT,
                            Slots.MCQ_CHOICE_VALUE, SanitizationHelper.sanitizeForHtml(choices.get(i)));
            optionListHtml.append(optionFragment).append(Const.EOL);
        }
        if (otherEnabled) {
            String otherOptionFragmentTemplate = FormTemplates.MCQ_SUBMISSION_FORM_OTHEROPTIONFRAGMENT;
            String otherOptionFragment =
                    Templates.populateTemplate(otherOptionFragmentTemplate,
                            Slots.QUESTION_INDEX, Integer.toString(qnIdx),
                            Slots.RESPONSE_INDEX, Integer.toString(responseIdx),
                            Slots.DISABLED, sessionIsOpen ? """" : ""disabled"",
                            Slots.TEXT_DISABLED, sessionIsOpen && isOtherSelected ? """" : ""disabled"",
                            Slots.CHECKED, isOtherSelected ? ""checked"" : """",
                            Slots.FEEDBACK_RESPONSE_TEXT, Const.ParamsNames.FEEDBACK_RESPONSE_TEXT,
                            Slots.MCQ_PARAM_IS_OTHER_OPTION_ANSWER,
                                    Const.ParamsNames.FEEDBACK_QUESTION_MCQ_ISOTHEROPTIONANSWER,
                            Slots.MCQ_CHOICE_VALUE,
                                    SanitizationHelper.sanitizeForHtml(existingMcqResponse.getOtherFieldContent()),
                            Slots.MCQ_OTHER_OPTION_ANSWER, isOtherSelected ? ""1"" : ""0"");
            optionListHtml.append(otherOptionFragment).append(Const.EOL);
        }
        return Templates.populateTemplate(
                FormTemplates.MCQ_SUBMISSION_FORM,
                Slots.MCQ_SUBMISSION_FORM_OPTION_FRAGMENTS, optionListHtml.toString());
    }

    @Override
    public String getQuestionWithoutExistingResponseSubmissionFormHtml(
            boolean sessionIsOpen, int qnIdx, int responseIdx, String courseId, int totalNumRecipients) {
        List<String> choices = generateOptionList(courseId);

        StringBuilder optionListHtml = new StringBuilder();
        String optionFragmentTemplate = FormTemplates.MCQ_SUBMISSION_FORM_OPTIONFRAGMENT;

        for (int i = 0; i < choices.size(); i++) {
            String optionFragment =
                    Templates.populateTemplate(optionFragmentTemplate,
                            Slots.QUESTION_INDEX, Integer.toString(qnIdx),
                            Slots.RESPONSE_INDEX, Integer.toString(responseIdx),
                            Slots.DISABLED, sessionIsOpen ? """" : ""disabled"",
                            Slots.CHECKED, """",
                            Slots.FEEDBACK_RESPONSE_TEXT, Const.ParamsNames.FEEDBACK_RESPONSE_TEXT,
                            Slots.MCQ_CHOICE_VALUE, SanitizationHelper.sanitizeForHtml(choices.get(i)));
            optionListHtml.append(optionFragment).append(Const.EOL);
        }

        if (otherEnabled) {
            String otherOptionFragmentTemplate = FormTemplates.MCQ_SUBMISSION_FORM_OTHEROPTIONFRAGMENT;
            String otherOptionFragment =
                       Templates.populateTemplate(otherOptionFragmentTemplate,
                            Slots.QUESTION_INDEX, Integer.toString(qnIdx),
                            Slots.RESPONSE_INDEX, Integer.toString(responseIdx),
                            Slots.DISABLED, sessionIsOpen ? """" : ""disabled"",
                            Slots.TEXT_DISABLED, ""disabled"",
                            Slots.CHECKED, """",
                            Slots.FEEDBACK_RESPONSE_TEXT, Const.ParamsNames.FEEDBACK_RESPONSE_TEXT,
                            Slots.MCQ_PARAM_IS_OTHER_OPTION_ANSWER,
                                    Const.ParamsNames.FEEDBACK_QUESTION_MCQ_ISOTHEROPTIONANSWER,
                            Slots.MCQ_CHOICE_VALUE, """",
                            Slots.MCQ_OTHER_OPTION_ANSWER, ""0"");
            optionListHtml.append(otherOptionFragment).append(Const.EOL);
        }

        return Templates.populateTemplate(
                FormTemplates.MCQ_SUBMISSION_FORM,
                Slots.MCQ_SUBMISSION_FORM_OPTION_FRAGMENTS, optionListHtml.toString());
    }

    private List<String> generateOptionList(String courseId) {
        List<String> optionList = new ArrayList<>();

        switch (generateOptionsFor) {
        case NONE:
            optionList = mcqChoices;
            break;
        case STUDENTS:
            List<StudentAttributes> studentList = StudentsLogic.inst().getStudentsForCourse(courseId);

            for (StudentAttributes student : studentList) {
                optionList.add(student.name + "" ("" + student.team + "")"");
            }

            Collections.sort(optionList);
            break;
        case TEAMS:
            try {
                List<TeamDetailsBundle> teamList = CoursesLogic.inst().getTeamsForCourse(courseId);

                for (TeamDetailsBundle team : teamList) {
                    optionList.add(team.name);
                }

                Collections.sort(optionList);
            } catch (EntityDoesNotExistException e) {
                Assumption.fail(""Course disappeared"");
            }
            break;
        case INSTRUCTORS:
            List<InstructorAttributes> instructorList =
                    InstructorsLogic.inst().getInstructorsForCourse(courseId);

            for (InstructorAttributes instructor : instructorList) {
                optionList.add(instructor.name);
            }

            Collections.sort(optionList);
            break;
        default:
            Assumption.fail(""Trying to generate options for neither students, teams nor instructors"");
            break;
        }

        return optionList;
    }

    @Override
    public String getQuestionSpecificEditFormHtml(int questionNumber) {
        StringBuilder optionListHtml = new StringBuilder();
        String optionFragmentTemplate = FormTemplates.MCQ_EDIT_FORM_OPTIONFRAGMENT;

        for (int i = 0; i < numOfMcqChoices; i++) {
            String optionFragment =
                    Templates.populateTemplate(optionFragmentTemplate,
                            Slots.ITERATOR, Integer.toString(i),
                            Slots.MCQ_CHOICE_VALUE, SanitizationHelper.sanitizeForHtml(mcqChoices.get(i)),
                            Slots.MCQ_PARAM_CHOICE, Const.ParamsNames.FEEDBACK_QUESTION_MCQCHOICE);

            optionListHtml.append(optionFragment).append(Const.EOL);
        }

        return Templates.populateTemplate(
                FormTemplates.MCQ_EDIT_FORM,
                Slots.MCQ_EDIT_FORM_OPTION_FRAGMENTS, optionListHtml.toString(),
                Slots.QUESTION_NUMBER, Integer.toString(questionNumber),
                Slots.NUMBER_OF_CHOICE_CREATED, Const.ParamsNames.FEEDBACK_QUESTION_NUMBEROFCHOICECREATED,
                Slots.MCQ_NUM_OF_MCQ_CHOICES, Integer.toString(numOfMcqChoices),
                Slots.CHECKED_OTHER_OPTION_ENABLED, otherEnabled ? ""checked"" : """",
                Slots.MCQ_PARAM_OTHER_OPTION, Const.ParamsNames.FEEDBACK_QUESTION_MCQOTHEROPTION,
                Slots.MCQ_PARAM_OTHER_OPTION_FLAG, Const.ParamsNames.FEEDBACK_QUESTION_MCQOTHEROPTIONFLAG,
                Slots.MCQ_CHECKED_GENERATED_OPTION, generateOptionsFor == FeedbackParticipantType.NONE ? """" : ""checked"",
                Slots.GENERATED_OPTIONS, Const.ParamsNames.FEEDBACK_QUESTION_GENERATEDOPTIONS,
                Slots.GENERATE_OPTIONS_FOR_VALUE, generateOptionsFor.toString(),
                Slots.STUDENT_SELECTED, generateOptionsFor == FeedbackParticipantType.STUDENTS ? ""selected"" : """",
                Slots.STUDENTS_TO_STRING, FeedbackParticipantType.STUDENTS.toString(),
                Slots.TEAM_SELECTED, generateOptionsFor == FeedbackParticipantType.TEAMS ? ""selected"" : """",
                Slots.TEAMS_TO_STRING, FeedbackParticipantType.TEAMS.toString(),
                Slots.INSTRUCTOR_SELECTED, generateOptionsFor == FeedbackParticipantType.INSTRUCTORS ? ""selected"" : """",
                Slots.INSTRUCTORS_TO_STRING, FeedbackParticipantType.INSTRUCTORS.toString());
    }

    @Override
    public String getNewQuestionSpecificEditFormHtml() {
        // Add two empty options by default
        numOfMcqChoices = 2;
        mcqChoices.add("""");
        mcqChoices.add("""");

        return ""<div id=\""mcqForm\"">""
                  + getQuestionSpecificEditFormHtml(-1)
             + ""</div>"";
    }

    @Override
    public String getQuestionAdditionalInfoHtml(int questionNumber, String additionalInfoId) {
        StringBuilder optionListHtml = new StringBuilder(200);
        String optionFragmentTemplate = FormTemplates.MCQ_ADDITIONAL_INFO_FRAGMENT;

        if (generateOptionsFor != FeedbackParticipantType.NONE) {
            String optionHelpText = String.format(
                    ""<br>The options for this question is automatically generated from the list of all %s in this course."",
                    generateOptionsFor.toString().toLowerCase());
            optionListHtml.append(optionHelpText);
        }

        if (numOfMcqChoices > 0) {
            optionListHtml.append(""<ul style=\""list-style-type: disc;margin-left: 20px;\"" >"");
            for (int i = 0; i < numOfMcqChoices; i++) {
                String optionFragment =
                        Templates.populateTemplate(optionFragmentTemplate,
                                Slots.MCQ_CHOICE_VALUE, SanitizationHelper.sanitizeForHtml(mcqChoices.get(i)));

                optionListHtml.append(optionFragment);
            }
        }
        if (otherEnabled) {
            String optionFragment =
                    Templates.populateTemplate(optionFragmentTemplate, Slots.MCQ_CHOICE_VALUE, ""Others"");
            optionListHtml.append(optionFragment);
        }
        optionListHtml.append(""</ul>"");

        String additionalInfo = Templates.populateTemplate(
                FormTemplates.MCQ_ADDITIONAL_INFO,
                Slots.QUESTION_TYPE_NAME, this.getQuestionTypeDisplayName(),
                Slots.MCQ_ADDITIONAL_INFO_FRAGMENTS, optionListHtml.toString());

        return Templates.populateTemplate(
                FormTemplates.FEEDBACK_QUESTION_ADDITIONAL_INFO,
                Slots.MORE, ""[more]"",
                Slots.LESS, ""[less]"",
                Slots.QUESTION_NUMBER, Integer.toString(questionNumber),
                Slots.ADDITIONAL_INFO_ID, additionalInfoId,
                Slots.QUESTION_ADDITIONAL_INFO, additionalInfo);
    }

    @Override
    public String getQuestionResultStatisticsHtml(List<FeedbackResponseAttributes> responses,
            FeedbackQuestionAttributes question,
            String studentEmail,
            FeedbackSessionResultsBundle bundle,
            String view) {

        if (""student"".equals(view) || responses.isEmpty()) {
            return """";
        }

        StringBuilder fragments = new StringBuilder();
        Map<String, Integer> answerFrequency = new LinkedHashMap<>();

        for (String option : mcqChoices) {
            answerFrequency.put(option, 0);
        }

        if (otherEnabled) {
            answerFrequency.put(""Other"", 0);
        }

        for (FeedbackResponseAttributes response : responses) {
            String answerString = response.getResponseDetails().getAnswerString();
            boolean isOtherOptionAnswer =
                    ((FeedbackMcqResponseDetails) response.getResponseDetails()).isOtherOptionAnswer();

            if (isOtherOptionAnswer) {
                if (!answerFrequency.containsKey(""Other"")) {
                    answerFrequency.put(""Other"", 0);
                }
                answerFrequency.put(""Other"", answerFrequency.get(""Other"") + 1);
            } else {
                if (!answerFrequency.containsKey(answerString)) {
                    answerFrequency.put(answerString, 0);
                }
                answerFrequency.put(answerString, answerFrequency.get(answerString) + 1);
            }
        }

        DecimalFormat df = new DecimalFormat(""#.##"");

        for (Entry<String, Integer> entry : answerFrequency.entrySet()) {
            fragments.append(Templates.populateTemplate(FormTemplates.MCQ_RESULT_STATS_OPTIONFRAGMENT,
                    Slots.MCQ_CHOICE_VALUE, SanitizationHelper.sanitizeForHtml(entry.getKey()),
                    Slots.COUNT, entry.getValue().toString(),
                    Slots.PERCENTAGE, df.format(100 * (double) entry.getValue() / responses.size())));
        }

        return Templates.populateTemplate(FormTemplates.MCQ_RESULT_STATS,
                Slots.FRAGMENTS, fragments.toString());
    }

    @Override
    public String getQuestionResultStatisticsCsv(
            List<FeedbackResponseAttributes> responses,
            FeedbackQuestionAttributes question,
            FeedbackSessionResultsBundle bundle) {
        if (responses.isEmpty()) {
            return """";
        }

        StringBuilder fragments = new StringBuilder();
        Map<String, Integer> answerFrequency = new LinkedHashMap<>();

        for (String option : mcqChoices) {
            answerFrequency.put(option, 0);
        }

        if (otherEnabled) {
            answerFrequency.put(""Other"", 0);
        }

        for (FeedbackResponseAttributes response : responses) {
            String answerString = response.getResponseDetails().getAnswerString();
            boolean isOtherOptionAnswer =
                    ((FeedbackMcqResponseDetails) response.getResponseDetails()).isOtherOptionAnswer();

            if (isOtherOptionAnswer) {
                if (!answerFrequency.containsKey(""Other"")) {
                    answerFrequency.put(""Other"", 0);
                }
                answerFrequency.put(""Other"", answerFrequency.get(""Other"") + 1);
            } else {
                if (!answerFrequency.containsKey(answerString)) {
                    answerFrequency.put(answerString, 0);
                }
                answerFrequency.put(answerString, answerFrequency.get(answerString) + 1);
            }
        }

        DecimalFormat df = new DecimalFormat(""#.##"");

        for (Entry<String, Integer> entry : answerFrequency.entrySet()) {
            fragments.append(SanitizationHelper.sanitizeForCsv(entry.getKey())).append(',')
                     .append(entry.getValue().toString()).append(',')
                     .append(df.format(100 * (double) entry.getValue() / responses.size())).append(Const.EOL);
        }

        return ""Choice, Response Count, Percentage"" + Const.EOL
               + fragments.toString();
    }

    @Override
    public String getCsvHeader() {
        return ""Feedback"";
    }

    @Override
    public String getQuestionTypeChoiceOption() {
        return ""<li data-questiontype = \""MCQ\""><a href=\""javascript:;\""> ""
               + Const.FeedbackQuestionTypeNames.MCQ + ""</a></li>"";
    }

    @Override
    public List<String> validateQuestionDetails() {
        List<String> errors = new ArrayList<>();
        if (generateOptionsFor == FeedbackParticipantType.NONE
                && numOfMcqChoices < Const.FeedbackQuestion.MCQ_MIN_NUM_OF_CHOICES) {
            errors.add(Const.FeedbackQuestion.MCQ_ERROR_NOT_ENOUGH_CHOICES
                       + Const.FeedbackQuestion.MCQ_MIN_NUM_OF_CHOICES + ""."");
        }
        //TODO: check that mcq options do not repeat. needed?

        return errors;
    }

    @Override
    public List<String> validateResponseAttributes(
            List<FeedbackResponseAttributes> responses,
            int numRecipients) {
        List<String> errors = new ArrayList<>();

        for (FeedbackResponseAttributes response : responses) {
            FeedbackMcqResponseDetails frd = (FeedbackMcqResponseDetails) response.getResponseDetails();

            if (!otherEnabled && generateOptionsFor == FeedbackParticipantType.NONE
                    && !mcqChoices.contains(frd.getAnswerString())) {
                errors.add(frd.getAnswerString() + Const.FeedbackQuestion.MCQ_ERROR_INVALID_OPTION);
            }
        }
        return errors;
    }

    @Override
    public Comparator<InstructorFeedbackResultsResponseRow> getResponseRowsSortOrder() {
        return null;
    }

    @Override
    public String validateGiverRecipientVisibility(FeedbackQuestionAttributes feedbackQuestionAttributes) {
        return """";
    }
}
"
FeedbackMcqResponseDetails.java,data-transfer,"package teammates.common.datatransfer.questions;

import java.util.Map;

import teammates.common.util.Const;
import teammates.common.util.HttpRequestHelper;
import teammates.common.util.SanitizationHelper;

public class FeedbackMcqResponseDetails extends FeedbackResponseDetails {
    private String answer;
    private boolean isOther;
    private String otherFieldContent; //content of other field if ""other"" is selected as the answer

    public FeedbackMcqResponseDetails() {
        super(FeedbackQuestionType.MCQ);
        answer = """";
        isOther = false;
        otherFieldContent = """";
    }

    @Override
    public void extractResponseDetails(FeedbackQuestionType questionType,
            FeedbackQuestionDetails questionDetails, String[] answer) {
        /*
         * answer[0] contains the answer given by the student, answer[1] is ""1""
         * if ""other"" is selected by the student, ""0"" if ""other"" is not
         * selected, null if ""other"" is disabled by the instructor
         */
        isOther = answer.length >= 2 && ""1"".equals(answer[1]);

        if (isOther) {
            this.answer = ""Other"";
            this.otherFieldContent = answer[0];
        } else {
            this.answer = answer[0];
            this.otherFieldContent = """";
        }
    }

    public void extractResponseDetails(FeedbackQuestionType questionType,
                                    FeedbackQuestionDetails questionDetails, String[] rawAnswer,
                                    Map<String, String[]> requestParameters, int questionIndx,
                                    int responseIndx) {

        String[] answer = appendOtherOptionFlagToAnswer(rawAnswer, requestParameters, questionIndx, responseIndx);
        /*
         * answer[0] contains the answer given by the student, answer[1] is ""1""
         * if ""other"" is selected by the student, ""0"" if ""other"" is not
         * selected, null if ""other"" is disabled by the instructor
         */
        isOther = answer.length >= 2 && ""1"".equals(answer[1]);

        if (isOther) {
            this.answer = ""Other"";
            this.otherFieldContent = answer[0];
        } else {
            this.answer = answer[0];
            this.otherFieldContent = """";
        }
    }

    @Override
    public String getAnswerString() {
        if (isOther) {
            return otherFieldContent;
        }
        return answer;
    }

    @Override
    public String getAnswerHtmlInstructorView(FeedbackQuestionDetails questionDetails) {
        return SanitizationHelper.sanitizeForHtml(getAnswerString());
    }

    @Override
    public String getAnswerCsv(FeedbackQuestionDetails questionDetails) {
        return SanitizationHelper.sanitizeForCsv(getAnswerString());
    }

    public Boolean isOtherOptionAnswer() {
        return isOther;
    }

    public String getOtherFieldContent() {
        return otherFieldContent;
    }

    private String[] appendOtherOptionFlagToAnswer(String[] answer, Map<String, String[]> requestParameters,
                                    int questionIndx, int responseIndx) {
        String isOtherOptionAnswer = HttpRequestHelper.getValueFromParamMap(
                                        requestParameters, Const.ParamsNames.FEEDBACK_QUESTION_MCQ_ISOTHEROPTIONANSWER
                                                           + ""-"" + questionIndx + ""-"" + responseIndx);
        if (answer != null) {
            String[] answerWithOtherOptionFlag = new String[answer.length + 1];

            answerWithOtherOptionFlag[0] = answer[0]; // answer given by the student
            answerWithOtherOptionFlag[1] = isOtherOptionAnswer; // ""1"" (other is selected) or ""0"" (other is not selected)
            return answerWithOtherOptionFlag;
        }
        return answer;
    }
}
"
FeedbackMsqQuestionDetails.java,data-transfer,"package teammates.common.datatransfer.questions;

import java.text.DecimalFormat;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;

import teammates.common.datatransfer.FeedbackParticipantType;
import teammates.common.datatransfer.FeedbackSessionResultsBundle;
import teammates.common.datatransfer.TeamDetailsBundle;
import teammates.common.datatransfer.attributes.FeedbackQuestionAttributes;
import teammates.common.datatransfer.attributes.FeedbackResponseAttributes;
import teammates.common.datatransfer.attributes.InstructorAttributes;
import teammates.common.datatransfer.attributes.StudentAttributes;
import teammates.common.exception.EntityDoesNotExistException;
import teammates.common.util.Assumption;
import teammates.common.util.Const;
import teammates.common.util.HttpRequestHelper;
import teammates.common.util.SanitizationHelper;
import teammates.common.util.StringHelper;
import teammates.common.util.Templates;
import teammates.common.util.Templates.FeedbackQuestion.FormTemplates;
import teammates.common.util.Templates.FeedbackQuestion.Slots;
import teammates.logic.core.CoursesLogic;
import teammates.logic.core.InstructorsLogic;
import teammates.logic.core.StudentsLogic;
import teammates.ui.template.InstructorFeedbackResultsResponseRow;

public class FeedbackMsqQuestionDetails extends FeedbackQuestionDetails {
    private int numOfMsqChoices;
    private List<String> msqChoices;
    private boolean otherEnabled;
    private FeedbackParticipantType generateOptionsFor;

    public FeedbackMsqQuestionDetails() {
        super(FeedbackQuestionType.MSQ);

        this.numOfMsqChoices = 0;
        this.msqChoices = new ArrayList<>();
        this.otherEnabled = false;
        this.generateOptionsFor = FeedbackParticipantType.NONE;
    }

    @Override
    public boolean extractQuestionDetails(
            Map<String, String[]> requestParameters,
            FeedbackQuestionType questionType) {
        int numOfMsqChoices = 0;
        List<String> msqChoices = new LinkedList<>();
        boolean msqOtherEnabled = false;

        String otherOptionFlag =
                HttpRequestHelper.getValueFromParamMap(requestParameters,
                                                       Const.ParamsNames.FEEDBACK_QUESTION_MSQOTHEROPTIONFLAG);

        if (""on"".equals(otherOptionFlag)) {
            msqOtherEnabled = true;
        }

        String generatedMsqOptions =
                HttpRequestHelper.getValueFromParamMap(requestParameters,
                                                       Const.ParamsNames.FEEDBACK_QUESTION_GENERATEDOPTIONS);
        if (generatedMsqOptions.equals(FeedbackParticipantType.NONE.toString())) {
            String numMsqChoicesCreatedString =
                    HttpRequestHelper.getValueFromParamMap(requestParameters,
                                                           Const.ParamsNames.FEEDBACK_QUESTION_NUMBEROFCHOICECREATED);
            Assumption.assertNotNull(""Null number of choice for MSQ"", numMsqChoicesCreatedString);
            int numMsqChoicesCreated = Integer.parseInt(numMsqChoicesCreatedString);

            for (int i = 0; i < numMsqChoicesCreated; i++) {
                String msqChoice =
                        HttpRequestHelper.getValueFromParamMap(
                                requestParameters, Const.ParamsNames.FEEDBACK_QUESTION_MSQCHOICE + ""-"" + i);
                if (msqChoice != null && !msqChoice.trim().isEmpty()) {
                    msqChoices.add(msqChoice);
                    numOfMsqChoices++;
                }
            }

            setMsqQuestionDetails(numOfMsqChoices, msqChoices, msqOtherEnabled);
        } else {
            setMsqQuestionDetails(FeedbackParticipantType.valueOf(generatedMsqOptions));
        }
        return true;
    }

    private void setMsqQuestionDetails(int numOfMsqChoices,
            List<String> msqChoices,
            boolean otherEnabled) {

        this.numOfMsqChoices = numOfMsqChoices;
        this.msqChoices = msqChoices;
        this.otherEnabled = otherEnabled;
        this.generateOptionsFor = FeedbackParticipantType.NONE;
    }

    private void setMsqQuestionDetails(FeedbackParticipantType generateOptionsFor) {

        this.numOfMsqChoices = 0;
        this.msqChoices = new ArrayList<>();
        this.otherEnabled = false;
        this.generateOptionsFor = generateOptionsFor;
        Assumption.assertTrue(""Can only generate students, teams or instructors"",
                generateOptionsFor == FeedbackParticipantType.STUDENTS
                || generateOptionsFor == FeedbackParticipantType.TEAMS
                || generateOptionsFor == FeedbackParticipantType.INSTRUCTORS);
    }

    @Override
    public String getQuestionTypeDisplayName() {
        return Const.FeedbackQuestionTypeNames.MSQ;
    }

    public boolean getOtherEnabled() {
        return otherEnabled;
    }

    @Override
    public boolean isChangesRequiresResponseDeletion(FeedbackQuestionDetails newDetails) {
        FeedbackMsqQuestionDetails newMsqDetails = (FeedbackMsqQuestionDetails) newDetails;

        if (this.numOfMsqChoices != newMsqDetails.numOfMsqChoices
                || !this.msqChoices.containsAll(newMsqDetails.msqChoices)
                || !newMsqDetails.msqChoices.containsAll(this.msqChoices)) {
            return true;
        }

        if (this.generateOptionsFor != newMsqDetails.generateOptionsFor) {
            return true;
        }

        return this.otherEnabled != newMsqDetails.otherEnabled;
    }

    @Override
    public String getQuestionWithExistingResponseSubmissionFormHtml(
            boolean sessionIsOpen, int qnIdx, int responseIdx, String courseId,
            int totalNumRecipients, FeedbackResponseDetails existingResponseDetails) {
        FeedbackMsqResponseDetails existingMsqResponse = (FeedbackMsqResponseDetails) existingResponseDetails;
        List<String> choices = generateOptionList(courseId);

        StringBuilder optionListHtml = new StringBuilder();
        String optionFragmentTemplate = FormTemplates.MSQ_SUBMISSION_FORM_OPTIONFRAGMENT;
        Boolean isOtherSelected = existingMsqResponse.isOtherOptionAnswer();

        for (int i = 0; i < choices.size(); i++) {
            String optionFragment =
                    Templates.populateTemplate(optionFragmentTemplate,
                            Slots.QUESTION_INDEX, Integer.toString(qnIdx),
                            Slots.RESPONSE_INDEX, Integer.toString(responseIdx),
                            Slots.DISABLED, sessionIsOpen ? """" : ""disabled"",
                            Slots.CHECKED, existingMsqResponse.contains(choices.get(i)) ? ""checked"" : """",
                            Slots.FEEDBACK_RESPONSE_TEXT, Const.ParamsNames.FEEDBACK_RESPONSE_TEXT,
                            Slots.MSQ_CHOICE_VALUE, SanitizationHelper.sanitizeForHtml(choices.get(i)),
                            Slots.MSQ_CHOICE_TEXT, SanitizationHelper.sanitizeForHtml(choices.get(i)));
            optionListHtml.append(optionFragment).append(Const.EOL);
        }

        if (otherEnabled) {
            String otherOptionFragmentTemplate = FormTemplates.MSQ_SUBMISSION_FORM_OTHEROPTIONFRAGMENT;
            String otherOptionFragment =
                    Templates.populateTemplate(otherOptionFragmentTemplate,
                            Slots.QUESTION_INDEX, Integer.toString(qnIdx),
                            Slots.RESPONSE_INDEX, Integer.toString(responseIdx),
                            Slots.DISABLED, sessionIsOpen ? """" : ""disabled"",
                            Slots.TEXT_DISABLED, sessionIsOpen && isOtherSelected ? """" : ""disabled"",
                            Slots.CHECKED, isOtherSelected ? ""checked"" : """",
                            Slots.FEEDBACK_RESPONSE_TEXT, Const.ParamsNames.FEEDBACK_RESPONSE_TEXT,
                            Slots.MSQ_PARAM_IS_OTHER_OPTION_ANSWER,
                                    Const.ParamsNames.FEEDBACK_QUESTION_MSQ_ISOTHEROPTIONANSWER,
                            Slots.MSQ_CHOICE_VALUE,
                                    SanitizationHelper.sanitizeForHtml(existingMsqResponse.getOtherFieldContent()),
                            Slots.MSQ_OTHER_OPTION_ANSWER, isOtherSelected ? ""1"" : ""0"");
            optionListHtml.append(otherOptionFragment).append(Const.EOL);
        }

        // additional checkbox for user to submit a blank response (""None of the above"")
        String optionFragment =
                Templates.populateTemplate(optionFragmentTemplate,
                        Slots.QUESTION_INDEX, Integer.toString(qnIdx),
                        Slots.RESPONSE_INDEX, Integer.toString(responseIdx),
                        Slots.DISABLED, sessionIsOpen ? """" : ""disabled"",
                        Slots.CHECKED, existingMsqResponse.contains("""") ? ""checked"" : """",
                        Slots.FEEDBACK_RESPONSE_TEXT, Const.ParamsNames.FEEDBACK_RESPONSE_TEXT,
                        Slots.MSQ_CHOICE_VALUE, """",
                        Slots.MSQ_CHOICE_TEXT, ""<i>"" + Const.NONE_OF_THE_ABOVE + ""</i>"");
        optionListHtml.append(optionFragment).append(Const.EOL);

        return Templates.populateTemplate(
                FormTemplates.MSQ_SUBMISSION_FORM,
                Slots.MSQ_SUBMISSION_FORM_OPTION_FRAGMENTS, optionListHtml.toString());
    }

    @Override
    public String getQuestionWithoutExistingResponseSubmissionFormHtml(
            boolean sessionIsOpen, int qnIdx, int responseIdx, String courseId, int totalNumRecipients) {
        List<String> choices = generateOptionList(courseId);

        StringBuilder optionListHtml = new StringBuilder();
        String optionFragmentTemplate = FormTemplates.MSQ_SUBMISSION_FORM_OPTIONFRAGMENT;
        for (int i = 0; i < choices.size(); i++) {
            String optionFragment =
                    Templates.populateTemplate(optionFragmentTemplate,
                            Slots.QUESTION_INDEX, Integer.toString(qnIdx),
                            Slots.RESPONSE_INDEX, Integer.toString(responseIdx),
                            Slots.DISABLED, sessionIsOpen ? """" : ""disabled"",
                            Slots.CHECKED, """",
                            Slots.FEEDBACK_RESPONSE_TEXT, Const.ParamsNames.FEEDBACK_RESPONSE_TEXT,
                            Slots.MSQ_CHOICE_VALUE, SanitizationHelper.sanitizeForHtml(choices.get(i)),
                            Slots.MSQ_CHOICE_TEXT, SanitizationHelper.sanitizeForHtml(choices.get(i)));
            optionListHtml.append(optionFragment);
            optionListHtml.append(Const.EOL);
        }

        if (otherEnabled) {
            String otherOptionFragmentTemplate = FormTemplates.MSQ_SUBMISSION_FORM_OTHEROPTIONFRAGMENT;
            String otherOptionFragment =
                       Templates.populateTemplate(otherOptionFragmentTemplate,
                            Slots.QUESTION_INDEX, Integer.toString(qnIdx),
                            Slots.RESPONSE_INDEX, Integer.toString(responseIdx),
                            Slots.DISABLED, sessionIsOpen ? """" : ""disabled"",
                            Slots.TEXT_DISABLED, ""disabled"",
                            Slots.CHECKED, """",
                            Slots.FEEDBACK_RESPONSE_TEXT, Const.ParamsNames.FEEDBACK_RESPONSE_TEXT,
                            Slots.MSQ_PARAM_IS_OTHER_OPTION_ANSWER,
                                    Const.ParamsNames.FEEDBACK_QUESTION_MSQ_ISOTHEROPTIONANSWER,
                            Slots.MSQ_CHOICE_VALUE, """",
                            Slots.MSQ_OTHER_OPTION_ANSWER, ""0"");
            optionListHtml.append(otherOptionFragment).append(Const.EOL);
        }

        // additional checkbox for user to submit a blank response (""None of the above"")
        String optionFragment =
                Templates.populateTemplate(optionFragmentTemplate,
                        Slots.QUESTION_INDEX, Integer.toString(qnIdx),
                        Slots.RESPONSE_INDEX, Integer.toString(responseIdx),
                        Slots.DISABLED, sessionIsOpen ? """" : ""disabled"",
                        Slots.CHECKED, """",
                        Slots.FEEDBACK_RESPONSE_TEXT, Const.ParamsNames.FEEDBACK_RESPONSE_TEXT,
                        Slots.MSQ_CHOICE_VALUE, """",
                        Slots.MSQ_CHOICE_TEXT, ""<i>"" + Const.NONE_OF_THE_ABOVE + ""</i>"");
        optionListHtml.append(optionFragment).append(Const.EOL);

        return Templates.populateTemplate(
                FormTemplates.MSQ_SUBMISSION_FORM,
                Slots.MSQ_SUBMISSION_FORM_OPTION_FRAGMENTS, optionListHtml.toString());
    }

    private List<String> generateOptionList(String courseId) {
        List<String> optionList = new ArrayList<>();

        switch (generateOptionsFor) {
        case NONE:
            optionList = msqChoices;
            break;
        case STUDENTS:
            List<StudentAttributes> studentList =
                    StudentsLogic.inst().getStudentsForCourse(courseId);

            for (StudentAttributes student : studentList) {
                optionList.add(student.name + "" ("" + student.team + "")"");
            }

            Collections.sort(optionList);
            break;
        case TEAMS:
            try {
                List<TeamDetailsBundle> teamList =
                        CoursesLogic.inst().getTeamsForCourse(courseId);

                for (TeamDetailsBundle team : teamList) {
                    optionList.add(team.name);
                }

                Collections.sort(optionList);
            } catch (EntityDoesNotExistException e) {
                Assumption.fail(""Course disappeared"");
            }
            break;
        case INSTRUCTORS:
            List<InstructorAttributes> instructorList =
                    InstructorsLogic.inst().getInstructorsForCourse(
                            courseId);

            for (InstructorAttributes instructor : instructorList) {
                optionList.add(instructor.name);
            }

            Collections.sort(optionList);
            break;
        default:
            Assumption.fail(""Trying to generate options for neither students, teams nor instructors"");
            break;
        }

        return optionList;
    }

    @Override
    public String getQuestionSpecificEditFormHtml(int questionNumber) {
        StringBuilder optionListHtml = new StringBuilder();
        String optionFragmentTemplate = FormTemplates.MSQ_EDIT_FORM_OPTIONFRAGMENT;
        for (int i = 0; i < numOfMsqChoices; i++) {
            String optionFragment =
                    Templates.populateTemplate(optionFragmentTemplate,
                            Slots.ITERATOR, Integer.toString(i),
                            Slots.MSQ_CHOICE_VALUE, SanitizationHelper.sanitizeForHtml(msqChoices.get(i)),
                            Slots.MSQ_PARAM_CHOICE, Const.ParamsNames.FEEDBACK_QUESTION_MSQCHOICE);

            optionListHtml.append(optionFragment).append(Const.EOL);
        }

        return Templates.populateTemplate(
                FormTemplates.MSQ_EDIT_FORM,
                Slots.MSQ_EDIT_FORM_OPTION_FRAGMENTS, optionListHtml.toString(),
                Slots.QUESTION_NUMBER, Integer.toString(questionNumber),
                Slots.NUMBER_OF_CHOICE_CREATED, Const.ParamsNames.FEEDBACK_QUESTION_NUMBEROFCHOICECREATED,
                Slots.MSQ_NUMBER_OF_CHOICES, Integer.toString(numOfMsqChoices),
                Slots.CHECKED_OTHER_OPTION_ENABLED, otherEnabled ? ""checked"" : """",
                Slots.MSQ_PARAM_OTHER_OPTION, Const.ParamsNames.FEEDBACK_QUESTION_MSQOTHEROPTION,
                Slots.MSQ_PARAM_OTHER_OPTION_FLAG, Const.ParamsNames.FEEDBACK_QUESTION_MSQOTHEROPTIONFLAG,
                Slots.MSQ_CHECKED_GENERATED_OPTIONS, generateOptionsFor == FeedbackParticipantType.NONE ? """" : ""checked"",
                Slots.GENERATED_OPTIONS, Const.ParamsNames.FEEDBACK_QUESTION_GENERATEDOPTIONS,
                Slots.GENERATE_OPTIONS_FOR_VALUE, generateOptionsFor.toString(),
                Slots.STUDENT_SELECTED, generateOptionsFor == FeedbackParticipantType.STUDENTS ? ""selected"" : """",
                Slots.STUDENTS_TO_STRING, FeedbackParticipantType.STUDENTS.toString(),
                Slots.TEAM_SELECTED, generateOptionsFor == FeedbackParticipantType.TEAMS ? ""selected"" : """",
                Slots.TEAMS_TO_STRING, FeedbackParticipantType.TEAMS.toString(),
                Slots.INSTRUCTOR_SELECTED, generateOptionsFor == FeedbackParticipantType.INSTRUCTORS ? ""selected"" : """",
                Slots.INSTRUCTORS_TO_STRING, FeedbackParticipantType.INSTRUCTORS.toString());
    }

    @Override
    public String getNewQuestionSpecificEditFormHtml() {
        // Add two empty options by default
        numOfMsqChoices = 2;
        msqChoices.add("""");
        msqChoices.add("""");

        return ""<div id=\""msqForm\"">""
                  + getQuestionSpecificEditFormHtml(-1)
             + ""</div>"";
    }

    @Override
    public String getQuestionAdditionalInfoHtml(int questionNumber, String additionalInfoId) {
        StringBuilder optionListHtml = new StringBuilder(200);
        String optionFragmentTemplate = FormTemplates.MSQ_ADDITIONAL_INFO_FRAGMENT;

        if (generateOptionsFor != FeedbackParticipantType.NONE) {
            String optionHelpText = String.format(
                    ""<br>The options for this question is automatically generated from the list of all %s in this course."",
                    generateOptionsFor.toString().toLowerCase());
            optionListHtml.append(optionHelpText);
        }

        if (numOfMsqChoices > 0) {
            optionListHtml.append(""<ul style=\""list-style-type: disc;margin-left: 20px;\"" >"");
            for (int i = 0; i < numOfMsqChoices; i++) {
                String optionFragment =
                        Templates.populateTemplate(optionFragmentTemplate,
                                Slots.MSQ_CHOICE_VALUE, SanitizationHelper.sanitizeForHtml(msqChoices.get(i)));

                optionListHtml.append(optionFragment);
            }

            if (otherEnabled) {
                String optionFragment =
                        Templates.populateTemplate(optionFragmentTemplate, Slots.MSQ_CHOICE_VALUE, ""Other"");
                optionListHtml.append(optionFragment);
            }

            optionListHtml.append(""</ul>"");
        }

        String additionalInfo = Templates.populateTemplate(
                FormTemplates.MSQ_ADDITIONAL_INFO,
                Slots.QUESTION_TYPE_NAME, this.getQuestionTypeDisplayName(),
                Slots.MSQ_ADDITIONAL_INFO_FRAGMENTS, optionListHtml.toString());

        return Templates.populateTemplate(
                FormTemplates.FEEDBACK_QUESTION_ADDITIONAL_INFO,
                Slots.MORE, ""[more]"",
                Slots.LESS, ""[less]"",
                Slots.QUESTION_NUMBER, Integer.toString(questionNumber),
                Slots.ADDITIONAL_INFO_ID, additionalInfoId,
                Slots.QUESTION_ADDITIONAL_INFO, additionalInfo);
    }

    @Override
    public String getQuestionResultStatisticsHtml(List<FeedbackResponseAttributes> responses,
            FeedbackQuestionAttributes question,
            String studentEmail,
            FeedbackSessionResultsBundle bundle,
            String view) {

        if (""student"".equals(view) || responses.isEmpty()) {
            return """";
        }

        Map<String, Integer> answerFrequency = new LinkedHashMap<>();
        int numChoicesSelected = getNumberOfResponses(responses, answerFrequency);
        if (numChoicesSelected == -1) {
            return """";
        }
        DecimalFormat df = new DecimalFormat(""#.##"");

        StringBuilder fragments = new StringBuilder();
        for (Entry<String, Integer> entry : answerFrequency.entrySet()) {
            fragments.append(Templates.populateTemplate(FormTemplates.MCQ_RESULT_STATS_OPTIONFRAGMENT,
                                Slots.MCQ_CHOICE_VALUE, entry.getKey(),
                                Slots.COUNT, entry.getValue().toString(),
                                Slots.PERCENTAGE,
                                df.format(100 * divideOrReturnZero(entry.getValue(), numChoicesSelected))));

        }
        //Use same template as MCQ for now, until they need to be different.
        return Templates.populateTemplate(FormTemplates.MCQ_RESULT_STATS, Slots.FRAGMENTS, fragments.toString());
    }

    @Override
    public String getQuestionResultStatisticsCsv(
            List<FeedbackResponseAttributes> responses,
            FeedbackQuestionAttributes question,
            FeedbackSessionResultsBundle bundle) {
        if (responses.isEmpty()) {
            return """";
        }

        Map<String, Integer> answerFrequency = new LinkedHashMap<>();
        int numChoicesSelected = getNumberOfResponses(responses, answerFrequency);
        if (numChoicesSelected == -1) {
            return """";
        }

        DecimalFormat df = new DecimalFormat(""#.##"");
        StringBuilder fragments = new StringBuilder();
        for (Entry<String, Integer> entry : answerFrequency.entrySet()) {
            fragments.append(SanitizationHelper.sanitizeForCsv(entry.getKey()) + ','
                             + entry.getValue().toString() + ','
                             + df.format(100 * divideOrReturnZero(entry.getValue(), numChoicesSelected))
                             + Const.EOL);
        }

        return ""Choice, Response Count, Percentage"" + Const.EOL
               + fragments + Const.EOL;
    }

    @Override
    public String getCsvHeader() {
        List<String> sanitizedChoices = SanitizationHelper.sanitizeListForCsv(msqChoices);
        return ""Feedbacks:,"" + StringHelper.toString(sanitizedChoices, "","");
    }

    @Override
    public String getQuestionTypeChoiceOption() {
        return ""<li data-questiontype = \""MSQ\""><a href=\""javascript:;\"">""
               + Const.FeedbackQuestionTypeNames.MSQ + ""</a></li>"";
    }

    @Override
    public List<String> validateQuestionDetails() {
        List<String> errors = new ArrayList<>();
        if (generateOptionsFor == FeedbackParticipantType.NONE
                && numOfMsqChoices < Const.FeedbackQuestion.MSQ_MIN_NUM_OF_CHOICES) {
            errors.add(Const.FeedbackQuestion.MSQ_ERROR_NOT_ENOUGH_CHOICES
                       + Const.FeedbackQuestion.MSQ_MIN_NUM_OF_CHOICES + ""."");
        }
        //TODO: check that msq options do not repeat. needed?

        return errors;
    }

    @Override
    public List<String> validateResponseAttributes(
            List<FeedbackResponseAttributes> responses,
            int numRecipients) {
        List<String> errors = new ArrayList<>();
        for (FeedbackResponseAttributes response : responses) {
            FeedbackMsqResponseDetails frd = (FeedbackMsqResponseDetails) response.getResponseDetails();
            if (!otherEnabled) {
                List<String> validChoices = msqChoices;
                validChoices.add("""");
                if (!validChoices.containsAll(frd.answers) && generateOptionsFor == FeedbackParticipantType.NONE) {
                    errors.add(frd.getAnswerString() + Const.FeedbackQuestion.MSQ_ERROR_INVALID_OPTION);
                }
            }
        }
        return errors;
    }

    /**
     * Checks if the question has been skipped.
     * MSQ allows a blank response, as that represents ""None of the above""
     */
    @Override
    public boolean isQuestionSkipped(String[] answer) {
        return answer == null;
    }

    @Override
    public Comparator<InstructorFeedbackResultsResponseRow> getResponseRowsSortOrder() {
        return null;
    }

    @Override
    public String validateGiverRecipientVisibility(FeedbackQuestionAttributes feedbackQuestionAttributes) {
        return """";
    }

    public int getNumOfMsqChoices() {
        return numOfMsqChoices;
    }

    public List<String> getMsqChoices() {
        return msqChoices;
    }

    /**
     * Getting number of responses.
     * @return -1 if there is no empty response else number of response.
     */
    private int getNumberOfResponses(
            List<FeedbackResponseAttributes> responses, Map<String, Integer> answerFrequency) {
        boolean isContainsNonEmptyResponse = false; // we will only show stats if there is at least one nonempty response

        for (String option : msqChoices) {
            answerFrequency.put(option, 0);
        }

        if (otherEnabled) {
            answerFrequency.put(""Other"", 0);
        }

        int numChoicesSelected = 0;
        for (FeedbackResponseAttributes response : responses) {
            List<String> answerStrings =
                    ((FeedbackMsqResponseDetails) response.getResponseDetails()).getAnswerStrings();
            boolean isOtherOptionAnswer =
                    ((FeedbackMsqResponseDetails) response.getResponseDetails()).isOtherOptionAnswer();
            String otherAnswer = """";

            if (isOtherOptionAnswer) {
                if (!answerFrequency.containsKey(""Other"")) {
                    answerFrequency.put(""Other"", 0);
                }

                answerFrequency.put(""Other"", answerFrequency.get(""Other"") + 1);

                numChoicesSelected++;
                // remove other answer temporarily to calculate stats for other options
                otherAnswer = answerStrings.get(answerStrings.size() - 1);
                answerStrings.remove(otherAnswer);
            }

            int numNonEmptyChoicesSelected = getNumberOfNonEmptyResponsesOfQuestion(answerStrings, answerFrequency);
            if (numNonEmptyChoicesSelected > 0) {
                isContainsNonEmptyResponse = true;
                numChoicesSelected += numNonEmptyChoicesSelected;
            }

            // restore other answer if any
            if (isOtherOptionAnswer) {
                answerStrings.add(otherAnswer);
            }
        }

        if (!isContainsNonEmptyResponse) {
            return -1;
        }

        return numChoicesSelected;
    }

    private int getNumberOfNonEmptyResponsesOfQuestion(List<String> answerStrings, Map<String, Integer> answerFrequency) {
        int numChoices = 0;
        for (String answerString : answerStrings) {
            if (answerString.isEmpty()) {
                continue;
            }

            numChoices++;

            if (!answerFrequency.containsKey(answerString)) {
                answerFrequency.put(answerString, 0);
            }
            answerFrequency.put(answerString, answerFrequency.get(answerString) + 1);
        }
        return numChoices;
    }

    private double divideOrReturnZero(double numerator, int denominator) {
        return (denominator == 0) ? 0 : numerator / denominator;
    }

}
"
FeedbackMsqResponseDetails.java,data-transfer,"package teammates.common.datatransfer.questions;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Map;

import teammates.common.util.Const;
import teammates.common.util.HttpRequestHelper;
import teammates.common.util.SanitizationHelper;
import teammates.common.util.StringHelper;

public class FeedbackMsqResponseDetails extends FeedbackResponseDetails {
    public List<String> answers; // answers contain the ""other"" answer, if any
    private boolean isOther;
    private String otherFieldContent; //content of other field if ""other"" is selected as the answer

    public FeedbackMsqResponseDetails() {
        super(FeedbackQuestionType.MSQ);
        this.answers = new ArrayList<>();
        isOther = false;
        otherFieldContent = """";
    }

    @Override
    public void extractResponseDetails(FeedbackQuestionType questionType,
                                       FeedbackQuestionDetails questionDetails, String[] answer) {
        this.answers = Arrays.asList(answer);
    }

    public void extractResponseDetails(FeedbackQuestionType questionType,
                                    FeedbackQuestionDetails questionDetails, String[] answer,
                                    Map<String, String[]> requestParameters, int questionIndx,
                                    int responseIndx) {

        // ""1"" if other is selected, ""0"" if other is not selected, null if other is disabled by the instructor
        String isOtherOptionAnswer = HttpRequestHelper.getValueFromParamMap(
                                        requestParameters, Const.ParamsNames.FEEDBACK_QUESTION_MSQ_ISOTHEROPTIONANSWER
                                        + ""-"" + questionIndx + ""-"" + responseIndx);

        if (""1"".equals(isOtherOptionAnswer)) {
            isOther = true;
            try {
                otherFieldContent = answer[answer.length - 1];
            } catch (IndexOutOfBoundsException e) {
                otherFieldContent = """";
            }
        }

        extractResponseDetails(questionType, questionDetails, answer);
    }

    public boolean contains(String candidateAnswer) {
        return answers.contains(candidateAnswer);
    }

    @Override
    public String getAnswerString() {
        return StringHelper.toString(answers, "", "");
    }

    public List<String> getAnswerStrings() {
        return answers;
    }

    @Override
    public String getAnswerHtmlInstructorView(FeedbackQuestionDetails questionDetails) {
        StringBuilder htmlBuilder = new StringBuilder();

        if (isAnswerBlank()) {
            // display an empty string if ""None of the above"" was selected
            htmlBuilder.append("""");
        } else {
            htmlBuilder.append(""<ul class=\""selectedOptionsList\"">"");
            for (String answer : answers) {
                htmlBuilder.append(""<li>"");
                htmlBuilder.append(SanitizationHelper.sanitizeForHtml(answer));
                htmlBuilder.append(""</li>"");
            }
            htmlBuilder.append(""</ul>"");
        }

        return htmlBuilder.toString();
    }

    @Override
    public String getAnswerCsv(FeedbackQuestionDetails questionDetails) {
        FeedbackMsqQuestionDetails msqDetails = (FeedbackMsqQuestionDetails) questionDetails;
        StringBuilder csvBuilder = new StringBuilder();

        if (isAnswerBlank()) {
            csvBuilder.append("""");
        } else {
            for (String choice : msqDetails.getMsqChoices()) {
                csvBuilder.append(',');
                if (this.contains(choice)) {
                    csvBuilder.append(SanitizationHelper.sanitizeForCsv(choice));
                }
            }
        }

        return csvBuilder.toString();
    }

    protected boolean isAnswerBlank() {
        return answers.size() == 1 && answers.get(0).isEmpty();
    }

    public Boolean isOtherOptionAnswer() {
        return isOther;
    }

    public String getOtherFieldContent() {
        return otherFieldContent;
    }

}
"
FeedbackNumericalScaleQuestionDetails.java,data-transfer,"package teammates.common.datatransfer.questions;

import java.math.RoundingMode;
import java.text.DecimalFormat;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

import teammates.common.datatransfer.FeedbackParticipantType;
import teammates.common.datatransfer.FeedbackSessionResultsBundle;
import teammates.common.datatransfer.attributes.FeedbackQuestionAttributes;
import teammates.common.datatransfer.attributes.FeedbackResponseAttributes;
import teammates.common.util.Assumption;
import teammates.common.util.Const;
import teammates.common.util.HttpRequestHelper;
import teammates.common.util.SanitizationHelper;
import teammates.common.util.StringHelper;
import teammates.common.util.Templates;
import teammates.common.util.Templates.FeedbackQuestion.FormTemplates;
import teammates.common.util.Templates.FeedbackQuestion.Slots;
import teammates.ui.template.InstructorFeedbackResultsResponseRow;

public class FeedbackNumericalScaleQuestionDetails extends
        FeedbackQuestionDetails {
    private int minScale;
    private int maxScale;
    private double step;

    public FeedbackNumericalScaleQuestionDetails() {
        super(FeedbackQuestionType.NUMSCALE);
        this.minScale = 1;
        this.maxScale = 5;
        this.step = 0.5;
    }

    @Override
    public boolean extractQuestionDetails(
            Map<String, String[]> requestParameters,
            FeedbackQuestionType questionType) {

        String minScaleString =
                HttpRequestHelper.getValueFromParamMap(requestParameters,
                                                       Const.ParamsNames.FEEDBACK_QUESTION_NUMSCALE_MIN);
        Assumption.assertNotNull(""Null minimum scale"", minScaleString);
        int minScale = Integer.parseInt(minScaleString);

        String maxScaleString =
                HttpRequestHelper.getValueFromParamMap(requestParameters,
                                                       Const.ParamsNames.FEEDBACK_QUESTION_NUMSCALE_MAX);
        Assumption.assertNotNull(""Null maximum scale"", maxScaleString);
        int maxScale = Integer.parseInt(maxScaleString);

        String stepString =
                HttpRequestHelper.getValueFromParamMap(requestParameters,
                                                       Const.ParamsNames.FEEDBACK_QUESTION_NUMSCALE_STEP);
        Assumption.assertNotNull(""Null step"", stepString);
        Double step = Double.parseDouble(stepString);

        setNumericalScaleQuestionDetails(minScale, maxScale, step);

        return true;
    }

    private void setNumericalScaleQuestionDetails(int minScale, int maxScale, double step) {
        this.minScale = minScale;
        this.maxScale = maxScale;
        this.step = step;
    }

    @Override
    public String getQuestionTypeDisplayName() {
        return Const.FeedbackQuestionTypeNames.NUMSCALE;
    }

    @Override
    public String getQuestionWithExistingResponseSubmissionFormHtml(
            boolean sessionIsOpen, int qnIdx, int responseIdx, String courseId,
            int totalNumRecipients, FeedbackResponseDetails existingResponseDetails) {
        FeedbackNumericalScaleResponseDetails numscaleResponseDetails =
                (FeedbackNumericalScaleResponseDetails) existingResponseDetails;

        return Templates.populateTemplate(
                FormTemplates.NUMSCALE_SUBMISSION_FORM,
                Slots.QUESTION_INDEX, Integer.toString(qnIdx),
                Slots.DISABLED, sessionIsOpen ? """" : ""disabled"",
                Slots.RESPONSE_INDEX, Integer.toString(responseIdx),
                Slots.MIN_SCALE, Integer.toString(minScale),
                Slots.MAX_SCALE, Integer.toString(maxScale),
                Slots.STEP, StringHelper.toDecimalFormatString(step),
                Slots.EXISTING_ANSWER, numscaleResponseDetails.getAnswerString(),
                Slots.POSSIBLE_VALUES_STRING, getPossibleValuesStringSubmit(),
                Slots.FEEDBACK_RESPONSE_TEXT, Const.ParamsNames.FEEDBACK_RESPONSE_TEXT,
                Slots.NUMSCALE_MIN, Const.ParamsNames.FEEDBACK_QUESTION_NUMSCALE_MIN,
                Slots.NUMSCALE_MAX, Const.ParamsNames.FEEDBACK_QUESTION_NUMSCALE_MAX,
                Slots.NUMSCALE_STEP, Const.ParamsNames.FEEDBACK_QUESTION_NUMSCALE_STEP);
    }

    @Override
    public String getQuestionWithoutExistingResponseSubmissionFormHtml(
            boolean sessionIsOpen, int qnIdx, int responseIdx, String courseId, int totalNumRecipients) {
        return Templates.populateTemplate(
                FormTemplates.NUMSCALE_SUBMISSION_FORM,
                Slots.QUESTION_INDEX, Integer.toString(qnIdx),
                Slots.DISABLED, sessionIsOpen ? """" : ""disabled"",
                Slots.RESPONSE_INDEX, Integer.toString(responseIdx),
                Slots.MIN_SCALE, Integer.toString(minScale),
                Slots.MAX_SCALE, Integer.toString(maxScale),
                Slots.STEP, StringHelper.toDecimalFormatString(step),
                Slots.EXISTING_ANSWER, """",
                Slots.POSSIBLE_VALUES_STRING, getPossibleValuesStringSubmit(),
                Slots.FEEDBACK_RESPONSE_TEXT, Const.ParamsNames.FEEDBACK_RESPONSE_TEXT,
                Slots.NUMSCALE_MIN, Const.ParamsNames.FEEDBACK_QUESTION_NUMSCALE_MIN,
                Slots.NUMSCALE_MAX, Const.ParamsNames.FEEDBACK_QUESTION_NUMSCALE_MAX,
                Slots.NUMSCALE_STEP, Const.ParamsNames.FEEDBACK_QUESTION_NUMSCALE_STEP);
    }

    @Override
    public String getQuestionSpecificEditFormHtml(int questionNumber) {
        return Templates.populateTemplate(
                FormTemplates.NUMSCALE_EDIT_FORM,
                Slots.QUESTION_NUMBER, Integer.toString(questionNumber),
                Slots.MIN_SCALE, Integer.toString(minScale),
                Slots.MAX_SCALE, Integer.toString(maxScale),
                Slots.STEP, StringHelper.toDecimalFormatString(step),
                Slots.POSSIBLE_VALUES, getPossibleValuesStringEdit(),
                Slots.NUMSCALE_MIN, Const.ParamsNames.FEEDBACK_QUESTION_NUMSCALE_MIN,
                Slots.NUMSCALE_MAX, Const.ParamsNames.FEEDBACK_QUESTION_NUMSCALE_MAX,
                Slots.NUMSCALE_STEP, Const.ParamsNames.FEEDBACK_QUESTION_NUMSCALE_STEP,
                Slots.NUMSCALE_TOOLTIPS_MIN, Const.Tooltips.FEEDBACK_QUESTION_NUMSCALE_MIN,
                Slots.NUMSCALE_TOOLTIPS_MAX, Const.Tooltips.FEEDBACK_QUESTION_NUMSCALE_MAX,
                Slots.NUMSCALE_TOOLTIPS_STEP, Const.Tooltips.FEEDBACK_QUESTION_NUMSCALE_STEP);
    }

    @Override
    public String getNewQuestionSpecificEditFormHtml() {
        // Set default values
        minScale = 1;
        maxScale = 5;
        step = 1;

        return ""<div id=\""numScaleForm\"">""
                  + this.getQuestionSpecificEditFormHtml(-1)
             + ""</div>"";
    }

    @Override
    public String getQuestionAdditionalInfoHtml(int questionNumber,
            String additionalInfoId) {
        String additionalInfo = getQuestionTypeDisplayName()
                              + "":<br>Minimum value: "" + minScale
                              + "". Increment: "" + step + "". Maximum value: ""
                              + maxScale + '.';

        return Templates.populateTemplate(
                FormTemplates.FEEDBACK_QUESTION_ADDITIONAL_INFO,
                Slots.MORE, ""[more]"",
                Slots.LESS, ""[less]"",
                Slots.QUESTION_NUMBER, Integer.toString(questionNumber),
                Slots.ADDITIONAL_INFO_ID, additionalInfoId,
                Slots.QUESTION_ADDITIONAL_INFO, additionalInfo);
    }

    @Override
    public String getQuestionResultStatisticsHtml(List<FeedbackResponseAttributes> responses,
            FeedbackQuestionAttributes question,
            String studentEmail,
            FeedbackSessionResultsBundle bundle,
            String view) {

        if (""student"".equals(view)) {
            return getStudentQuestionResultsStatisticsHtml(responses, studentEmail, question, bundle);
        }
        return getInstructorQuestionResultsStatisticsHtml(responses, question, bundle);
    }

    private String getInstructorQuestionResultsStatisticsHtml(
            List<FeedbackResponseAttributes> responses,
            FeedbackQuestionAttributes question, FeedbackSessionResultsBundle bundle) {
        Map<String, Double> min = new HashMap<>();
        Map<String, Double> max = new HashMap<>();
        Map<String, Double> average = new HashMap<>();
        Map<String, Double> averageExcludingSelf = new HashMap<>();
        Map<String, Double> total = new HashMap<>();
        Map<String, Double> totalExcludingSelf = new HashMap<>();
        Map<String, Integer> numResponses = new HashMap<>();
        Map<String, Integer> numResponsesExcludingSelf = new HashMap<>();

        // need to know which recipients are hidden since anonymised recipients will not appear in the summary table
        List<String> hiddenRecipients = getHiddenRecipients(responses, question, bundle);

        populateSummaryStatisticsFromResponses(responses, min, max, average, averageExcludingSelf, total,
                                               totalExcludingSelf, numResponses, numResponsesExcludingSelf);

        boolean showAvgExcludingSelf = showAverageExcludingSelf(question, averageExcludingSelf);

        String fragmentTemplateToUse = showAvgExcludingSelf
                                     ? FormTemplates.NUMSCALE_RESULTS_STATS_FRAGMENT_WITH_SELF_RESPONSE
                                     : FormTemplates.NUMSCALE_RESULTS_STATS_FRAGMENT;

        DecimalFormat df = new DecimalFormat();
        df.setMinimumFractionDigits(0);
        df.setMaximumFractionDigits(5);
        df.setRoundingMode(RoundingMode.DOWN);

        StringBuilder fragmentHtml = new StringBuilder();

        for (String recipient : numResponses.keySet()) {
            // hidden recipients do not appear in the summary table, so ignore responses with hidden recipients
            if (hiddenRecipients.contains(recipient)) {
                continue;
            }

            Double userAverageExcludingSelf = averageExcludingSelf.get(recipient);
            String userAverageExcludingSelfText =
                    getAverageExcludingSelfText(showAvgExcludingSelf, df, userAverageExcludingSelf);

            String recipientName = recipient.equals(Const.GENERAL_QUESTION) ? ""General"" : bundle.getNameForEmail(recipient);
            String recipientTeam = bundle.getTeamNameForEmail(recipient);

            fragmentHtml.append(Templates.populateTemplate(
                                    fragmentTemplateToUse,
                                    Slots.RECIPIENT_TEAM, SanitizationHelper.sanitizeForHtml(recipientTeam),
                                    Slots.RECIPIENT_NAME, SanitizationHelper.sanitizeForHtml(recipientName),
                                    Slots.AVERAGE, df.format(average.get(recipient)),
                                    Slots.MAX, df.format(max.get(recipient)),
                                    Slots.MIN, df.format(min.get(recipient)),
                                    Slots.AVERAGE_EXCLUDING_SELF_RESPONSE, userAverageExcludingSelfText));
        }

        if (fragmentHtml.length() == 0) {
            return """";
        }

        String statsTitle = ""Response Summary"";
        String templateToUse = showAvgExcludingSelf
                             ? FormTemplates.NUMSCALE_RESULT_STATS_WITH_SELF_RESPONSE
                             : FormTemplates.NUMSCALE_RESULT_STATS;
        return Templates.populateTemplate(
                        templateToUse,
                        Slots.SUMMARY_TITLE, statsTitle,
                        Slots.STATS_FRAGMENTS, fragmentHtml.toString());
    }

    private String getStudentQuestionResultsStatisticsHtml(
            List<FeedbackResponseAttributes> responses, String studentEmail,
            FeedbackQuestionAttributes question, FeedbackSessionResultsBundle bundle) {

        Map<String, Double> min = new HashMap<>();
        Map<String, Double> max = new HashMap<>();
        Map<String, Double> average = new HashMap<>();
        Map<String, Double> averageExcludingSelf = new HashMap<>();
        Map<String, Double> total = new HashMap<>();
        Map<String, Double> totalExcludingSelf = new HashMap<>();
        Map<String, Integer> numResponses = new HashMap<>();
        Map<String, Integer> numResponsesExcludingSelf = new HashMap<>();

        // need to know which recipients are hidden since anonymised recipients will not appear in the summary table
        List<String> hiddenRecipients = getHiddenRecipients(responses, question, bundle);

        populateSummaryStatisticsFromResponses(responses, min, max, average, averageExcludingSelf, total,
                                               totalExcludingSelf, numResponses, numResponsesExcludingSelf);
        boolean showAvgExcludingSelf = showAverageExcludingSelf(question, averageExcludingSelf);

        String fragmentTemplateToUse = showAvgExcludingSelf
                                     ? FormTemplates.NUMSCALE_RESULTS_STATS_FRAGMENT_WITH_SELF_RESPONSE
                                     : FormTemplates.NUMSCALE_RESULTS_STATS_FRAGMENT;

        DecimalFormat df = new DecimalFormat();
        df.setMinimumFractionDigits(0);
        df.setMaximumFractionDigits(5);
        df.setRoundingMode(RoundingMode.DOWN);

        boolean isRecipientTypeGeneral = question.recipientType == FeedbackParticipantType.NONE;
        boolean isRecipientTypeTeam = question.recipientType == FeedbackParticipantType.TEAMS
                                      || question.recipientType == FeedbackParticipantType.OWN_TEAM;
        boolean isRecipientTypeStudent = !isRecipientTypeGeneral && !isRecipientTypeTeam;

        String currentUserTeam = bundle.getTeamNameForEmail(studentEmail);
        String currentUserIdentifier = getCurrentUserIdentifier(numResponses,
                                                                isRecipientTypeStudent, studentEmail,
                                                                isRecipientTypeTeam, currentUserTeam);

        Set<String> recipientSet = numResponses.keySet();
        ArrayList<String> recipientList = new ArrayList<>();

        boolean hasCurrentUserReceivedAnyResponse = recipientSet.contains(currentUserIdentifier);

        // Move current user to the head of the recipient list
        if (hasCurrentUserReceivedAnyResponse) {
            recipientList.add(currentUserIdentifier);
        }
        for (String otherRecipient : recipientSet) {
            // Skip current user as it is added to the head of the list
            if (otherRecipient.equalsIgnoreCase(currentUserIdentifier)) {
                continue;
            }
            recipientList.add(otherRecipient);
        }

        StringBuilder fragmentHtml = new StringBuilder();
        for (String recipient : recipientList) {

            // hidden recipients do not appear in the summary table, so ignore responses with hidden recipients
            boolean isHiddenRecipient = false;
            if (hiddenRecipients.contains(recipient)) {
                isHiddenRecipient = true;
            }

            String recipientName = null;
            String recipientTeam = null;

            boolean isRecipientCurrentUser = recipient.equalsIgnoreCase(currentUserIdentifier);
            boolean isRecipientGeneral = recipient.equalsIgnoreCase(Const.GENERAL_QUESTION);

            recipientName = getDisplayableRecipientName(isHiddenRecipient,
                            isRecipientCurrentUser, hasAtLeastTwoResponses(numResponses, currentUserIdentifier),
                            isRecipientTypeStudent, hasAtLeastTwoResponsesOtherThanCurrentUser(
                                                            numResponses, currentUserIdentifier, hiddenRecipients),
                            isRecipientGeneral, bundle.getNameForEmail(recipient), currentUserTeam);

            recipientTeam = getDisplayableRecipientTeam(isHiddenRecipient,
                                                        isRecipientCurrentUser,
                                                        hasAtLeastTwoResponses(numResponses, currentUserIdentifier),
                                                        isRecipientTypeStudent,
                                                        hasAtLeastTwoResponsesOtherThanCurrentUser(numResponses,
                                                                                                   currentUserIdentifier,
                                                                                                   hiddenRecipients),
                                                        bundle.getTeamNameForEmail(recipient), currentUserTeam);

            Double minScore = null;
            Double maxScore = null;
            Double averageScore = null;
            Double averageScoreExcludingSelf = null;

            boolean isRecipientDetailsAvailable = recipientName != null && recipientTeam != null;

            if (!isRecipientDetailsAvailable) {
                continue;
            }

            minScore = min.get(recipient);
            maxScore = max.get(recipient);
            averageScore = average.get(recipient);
            averageScoreExcludingSelf = averageExcludingSelf.get(recipient);

            String averageScoreExcludingSelfText =
                    getAverageExcludingSelfText(showAvgExcludingSelf, df, averageScoreExcludingSelf);

            String recipientFragmentHtml = Templates.populateTemplate(
                    fragmentTemplateToUse,
                    Slots.RECIPIENT_TEAM, SanitizationHelper.sanitizeForHtml(recipientTeam),
                    Slots.RECIPIENT_NAME, SanitizationHelper.sanitizeForHtml(recipientName),
                    Slots.AVERAGE, df.format(averageScore),
                    Slots.MAX, df.format(maxScore),
                    Slots.MIN, df.format(minScore),
                    Slots.AVERAGE_EXCLUDING_SELF_RESPONSE, averageScoreExcludingSelfText);

            fragmentHtml.append(recipientFragmentHtml);
        }

        if (fragmentHtml.length() == 0) {
            return """";
        }

        String statsTitle = getStatsTitle(
                isRecipientTypeGeneral, isRecipientTypeTeam,
                hasAtLeastTwoResponsesOtherThanCurrentUser(numResponses, currentUserIdentifier, hiddenRecipients));
        String templateToUse = showAvgExcludingSelf
                             ? FormTemplates.NUMSCALE_RESULT_STATS_WITH_SELF_RESPONSE
                             : FormTemplates.NUMSCALE_RESULT_STATS;
        return Templates.populateTemplate(templateToUse,
                Slots.SUMMARY_TITLE, statsTitle,
                Slots.STATS_FRAGMENTS, fragmentHtml.toString());
    }

    private String getDisplayableRecipientName(boolean isHiddenRecipient,
            boolean isRecipientCurrentUser, boolean hasAtLeastTwoResponses,
            boolean isRecipientTypeStudent, boolean hasAtLeastTwoResponsesOtherThanCurrentUser,
            boolean isRecipientGeneral, String recipientName, String currentUserTeam) {

        // Replace current user name with ""You""
        if (!isHiddenRecipient && isRecipientCurrentUser && hasAtLeastTwoResponses) {
            return isRecipientTypeStudent ? ""You"" : ""Your Team ("" + currentUserTeam + "")"";
        }

        // Replace general identifier with ""General""
        if (!isHiddenRecipient && !isRecipientCurrentUser && hasAtLeastTwoResponsesOtherThanCurrentUser) {
            return isRecipientGeneral ? ""General"" : recipientName;
        }
        return null;
    }

    private String getDisplayableRecipientTeam(boolean isHiddenRecipient,
            boolean isRecipientCurrentUser, boolean hasAtLeastTwoResponses,
            boolean isRecipientTypeStudent, boolean hasAtLeastTwoResponsesOtherThanCurrentUser,
            String recipientTeamName, String currentUserTeam) {

        // Replace current user team with """" when recipient type is not student
        if (!isHiddenRecipient && isRecipientCurrentUser && hasAtLeastTwoResponses) {
            return isRecipientTypeStudent ? currentUserTeam : """";
        }

        // Display other recipients' team name
        if (!isHiddenRecipient && !isRecipientCurrentUser && hasAtLeastTwoResponsesOtherThanCurrentUser) {
            return recipientTeamName;
        }
        return null;
    }

    private String getCurrentUserIdentifier(Map<String, Integer> numResponses,
            boolean isRecipientStudent, String currentUserEmail,
            boolean isRecipientTeam, String currentUserTeam) {

        if (isRecipientStudent && numResponses.containsKey(currentUserEmail)
                && numResponses.get(currentUserEmail) >= 1) {
            return currentUserEmail;
        } else if (isRecipientTeam && numResponses.containsKey(currentUserTeam)
                   && numResponses.get(currentUserTeam) >= 1) {
            return currentUserTeam;
        } else {
            return """";
        }
    }

    private boolean hasAtLeastTwoResponses(Map<String, Integer> numResponses,
            String recipient) {
        if (numResponses == null) {
            return false;
        }
        Integer numOfResponses = numResponses.get(recipient);
        return numOfResponses != null && numOfResponses >= 2;
    }

    private String getAverageExcludingSelfText(boolean showAvgExcludingSelf, DecimalFormat df, Double averageExcludingSelf) {
        if (showAvgExcludingSelf) {
            // Display a dash if the user has only self response
            return averageExcludingSelf == null ? ""-"" : df.format(averageExcludingSelf);
        }
        return """";
    }

    @Override
    public String getQuestionResultStatisticsCsv(
            List<FeedbackResponseAttributes> responses,
            FeedbackQuestionAttributes question,
            FeedbackSessionResultsBundle bundle) {
        if (responses.isEmpty()) {
            return """";
        }

        Map<String, Double> min = new HashMap<>();
        Map<String, Double> max = new HashMap<>();
        Map<String, Double> average = new HashMap<>();
        Map<String, Double> averageExcludingSelf = new HashMap<>();
        Map<String, Double> total = new HashMap<>();
        Map<String, Double> totalExcludingSelf = new HashMap<>();
        Map<String, Integer> numResponses = new HashMap<>();
        Map<String, Integer> numResponsesExcludingSelf = new HashMap<>();

        // need to know which recipients are hidden since anonymised recipients will not appear in the summary table
        List<String> hiddenRecipients = getHiddenRecipients(responses, question, bundle);

        populateSummaryStatisticsFromResponses(responses, min, max, average, averageExcludingSelf, total,
                                               totalExcludingSelf, numResponses, numResponsesExcludingSelf);

        boolean showAvgExcludingSelf = showAverageExcludingSelf(question, averageExcludingSelf);

        DecimalFormat df = new DecimalFormat();
        df.setMinimumFractionDigits(0);
        df.setMaximumFractionDigits(5);
        df.setRoundingMode(RoundingMode.DOWN);

        String csvHeader = ""Team, Recipient, Average, Minimum, Maximum""
                         + (showAvgExcludingSelf ? "", Average excluding self response"" : """")
                         + Const.EOL;

        StringBuilder csvBody = new StringBuilder();
        for (String recipient : numResponses.keySet()) {
            // hidden recipients do not appear in the summary table, so ignore responses with hidden recipients
            if (hiddenRecipients.contains(recipient)) {
                continue;
            }

            String recipientTeam = bundle.getTeamNameForEmail(recipient);
            boolean isRecipientGeneral = recipient.equals(Const.GENERAL_QUESTION);

            Double averageScoreExcludingSelf = averageExcludingSelf.get(recipient);
            String averageScoreExcludingSelfText =
                    getAverageExcludingSelfText(showAvgExcludingSelf, df, averageScoreExcludingSelf);

            csvBody.append(SanitizationHelper.sanitizeForCsv(recipientTeam) + ','
                           + SanitizationHelper.sanitizeForCsv(isRecipientGeneral
                                                      ? ""General""
                                                      : bundle.getNameForEmail(recipient))
                           + ','
                           + df.format(average.get(recipient)) + ','
                           + df.format(min.get(recipient)) + ','
                           + df.format(max.get(recipient))
                           + (showAvgExcludingSelf ? ',' + averageScoreExcludingSelfText : """")
                           + Const.EOL);
        }

        return csvHeader + csvBody.toString();
    }

    private boolean showAverageExcludingSelf(
            FeedbackQuestionAttributes question, Map<String, Double> averageExcludingSelf) {

        if (question.recipientType == FeedbackParticipantType.NONE) {
            // General recipient type would not give self response
            // Therefore average exclude self response will always be hidden
            return false;
        }

        for (Double average : averageExcludingSelf.values()) {
            // There exists at least one average score exclude self
            if (average != null) {
                return true;
            }
        }
        return false;
    }

    private void populateSummaryStatisticsFromResponses(
            List<FeedbackResponseAttributes> responses,
            Map<String, Double> min, Map<String, Double> max,
            Map<String, Double> average, Map<String, Double> averageExcludingSelf,
            Map<String, Double> total, Map<String, Double> totalExcludingSelf,
            Map<String, Integer> numResponses,
            Map<String, Integer> numResponsesExcludingSelf) {

        for (FeedbackResponseAttributes response : responses) {
            FeedbackNumericalScaleResponseDetails responseDetails =
                    (FeedbackNumericalScaleResponseDetails) response.getResponseDetails();
            double answer = responseDetails.getAnswer();
            String giverEmail = response.giver;
            String recipientEmail = response.recipient;

            // Compute number of responses including user's self response
            if (!numResponses.containsKey(recipientEmail)) {
                numResponses.put(recipientEmail, 0);
            }
            int numOfResponses = numResponses.get(recipientEmail) + 1;
            numResponses.put(recipientEmail, numOfResponses);

            // Compute number of responses excluding user's self response
            if (!numResponsesExcludingSelf.containsKey(recipientEmail)) {
                numResponsesExcludingSelf.put(recipientEmail, 0);
            }
            boolean isSelfResponse = giverEmail.equalsIgnoreCase(recipientEmail);
            if (!isSelfResponse) {
                int numOfResponsesExcludingSelf = numResponsesExcludingSelf.get(recipientEmail) + 1;
                numResponsesExcludingSelf.put(recipientEmail, numOfResponsesExcludingSelf);
            }

            // Compute minimum score received
            if (!min.containsKey(recipientEmail)) {
                min.put(recipientEmail, answer);
            }
            double minScoreReceived = Math.min(answer, min.get(recipientEmail));
            min.put(recipientEmail, minScoreReceived);

            // Compute maximum score received
            if (!max.containsKey(recipientEmail)) {
                max.put(recipientEmail, answer);
            }
            double maxScoreReceived = Math.max(answer, max.get(recipientEmail));
            max.put(recipientEmail, maxScoreReceived);

            // Compute total score received
            if (!total.containsKey(recipientEmail)) {
                total.put(recipientEmail, 0.0);
            }
            double totalScore = total.get(recipientEmail) + answer;
            total.put(recipientEmail, totalScore);

            // Compute total score received excluding self
            if (!totalExcludingSelf.containsKey(recipientEmail)) {
                totalExcludingSelf.put(recipientEmail, null);
            }
            if (!isSelfResponse) {
                Double totalScoreExcludingSelf = totalExcludingSelf.get(recipientEmail);

                // totalScoreExcludingSelf == null when the user has only self response
                totalExcludingSelf.put(recipientEmail,
                                       totalScoreExcludingSelf == null ? answer : totalScoreExcludingSelf + answer);
            }

            // Compute average score received
            if (!average.containsKey(recipientEmail)) {
                average.put(recipientEmail, 0.0);
            }
            double averageReceived = total.get(recipientEmail) / numResponses.get(recipientEmail);
            average.put(recipientEmail, averageReceived);

            // Compute average score received excluding self
            if (!averageExcludingSelf.containsKey(recipientEmail)) {
                averageExcludingSelf.put(recipientEmail, null);
            }
            if (!isSelfResponse && totalExcludingSelf.get(recipientEmail) != null) {
                double averageReceivedExcludingSelf =
                        totalExcludingSelf.get(recipientEmail) / numResponsesExcludingSelf.get(recipientEmail);
                averageExcludingSelf.put(recipientEmail, averageReceivedExcludingSelf);
            }
        }
    }

    private List<String> getHiddenRecipients(
            List<FeedbackResponseAttributes> responses,
            FeedbackQuestionAttributes question,
            FeedbackSessionResultsBundle bundle) {
        List<String> hiddenRecipients = new ArrayList<>(); // List of recipients to hide
        FeedbackParticipantType type = question.recipientType;
        for (FeedbackResponseAttributes response : responses) {
            if (!bundle.visibilityTable.get(response.getId())[1]
                    && type != FeedbackParticipantType.SELF
                    && type != FeedbackParticipantType.NONE) {

                hiddenRecipients.add(response.recipient);
            }
        }
        return hiddenRecipients;
    }

    private String getStatsTitle(boolean isDirectedAtGeneral,
            boolean isDirectedAtTeams, boolean isAbleToSeeAllResponses) {
        String statsTitle;
        if (isDirectedAtGeneral || isAbleToSeeAllResponses) {
            statsTitle = ""Response Summary"";
        } else if (isDirectedAtTeams) {
            statsTitle = ""Summary of responses received by your team"";
        } else {
            statsTitle = ""Summary of responses received by you"";
        }
        return statsTitle;
    }

    /**
     * Return true when the number of responses for any visible recipient, other than the current user,
     * has at least 2 responses.
     * This is used for displaying the statistic for other users as it doesn't make sense when all other users
     * have only 1 response each
     * Return false otherwise.
     */
    private boolean hasAtLeastTwoResponsesOtherThanCurrentUser(
            Map<String, Integer> numResponses, String currentUserIdentifier, List<String> hiddenRecipients) {
        boolean isAtLeastTwoResponsesOtherThanCurrentUser = false;

        // At least 2 responses are given to any recipient other than current user
        for (String recipient : numResponses.keySet()) {
            if (hiddenRecipients.contains(recipient)) {
                continue;
            }

            if (hasAtLeastTwoResponses(numResponses, recipient)
                    && !recipient.equals(currentUserIdentifier)) {

                isAtLeastTwoResponsesOtherThanCurrentUser = true;
                break;
            }
        }
        return isAtLeastTwoResponsesOtherThanCurrentUser;
    }

    @Override
    public boolean isChangesRequiresResponseDeletion(
            FeedbackQuestionDetails newDetails) {
        FeedbackNumericalScaleQuestionDetails newNumScaleDetails =
                (FeedbackNumericalScaleQuestionDetails) newDetails;

        return this.minScale != newNumScaleDetails.minScale
               || this.maxScale != newNumScaleDetails.maxScale
               || this.step != newNumScaleDetails.step;
    }

    @Override
    public String getCsvHeader() {
        return ""Feedback"";
    }

    @Override
    public String getQuestionTypeChoiceOption() {
        return ""<li data-questiontype = \""NUMSCALE\""><a href=\""javascript:;\"">""
               + Const.FeedbackQuestionTypeNames.NUMSCALE + ""</a></li>"";
    }

    private String getPossibleValuesStringEdit() {
        return ""[Based on the above settings, acceptable responses are: "" + getPossibleValuesString();
    }

    private String getPossibleValuesStringSubmit() {
        return ""[Possible values: "" + getPossibleValuesString();
    }

    private String getPossibleValuesString() {
        double cur = minScale + step;
        int possibleValuesCount = 1;
        while (maxScale - cur >= -1e-9) {
            cur += step;
            possibleValuesCount++;
        }

        StringBuilder possibleValuesString = new StringBuilder();
        if (possibleValuesCount > 6) {
            possibleValuesString
                .append(StringHelper.toDecimalFormatString(minScale)).append("", "")
                .append(StringHelper.toDecimalFormatString(minScale + step)).append("", "")
                .append(StringHelper.toDecimalFormatString(minScale + 2 * step)).append("", ..., "")
                .append(StringHelper.toDecimalFormatString(maxScale - 2 * step)).append("", "")
                .append(StringHelper.toDecimalFormatString(maxScale - step)).append("", "")
                .append(StringHelper.toDecimalFormatString(maxScale));
        } else {
            possibleValuesString.append(Integer.toString(minScale));
            cur = minScale + step;
            while (maxScale - cur >= -1e-9) {
                possibleValuesString.append("", "").append(StringHelper.toDecimalFormatString(cur));
                cur += step;
            }
        }
        return possibleValuesString.toString() + ""]"";
    }

    @Override
    public List<String> validateQuestionDetails() {
        List<String> errors = new ArrayList<>();
        if (minScale >= maxScale) {
            errors.add(Const.FeedbackQuestion.NUMSCALE_ERROR_MIN_MAX);
        }
        if (step <= 0) {
            errors.add(Const.FeedbackQuestion.NUMSCALE_ERROR_STEP);
        }
        return errors;
    }

    @Override
    public List<String> validateResponseAttributes(
            List<FeedbackResponseAttributes> responses,
            int numRecipients) {
        List<String> errors = new ArrayList<>();
        for (FeedbackResponseAttributes response : responses) {
            FeedbackNumericalScaleResponseDetails frd =
                    (FeedbackNumericalScaleResponseDetails) response.getResponseDetails();
            if (frd.getAnswer() < minScale || frd.getAnswer() > maxScale) {
                errors.add(frd.getAnswerString() + Const.FeedbackQuestion.NUMSCALE_ERROR_OUT_OF_RANGE
                           + ""(min="" + minScale + "", max="" + maxScale + "")"");
            }
            //TODO: strengthen check for step
        }
        return errors;
    }

    @Override
    public Comparator<InstructorFeedbackResultsResponseRow> getResponseRowsSortOrder() {
        return null;
    }

    @Override
    public String validateGiverRecipientVisibility(FeedbackQuestionAttributes feedbackQuestionAttributes) {
        return """";
    }

    public int getMinScale() {
        return minScale;
    }

    public void setMinScale(int minScale) {
        this.minScale = minScale;
    }

    public int getMaxScale() {
        return maxScale;
    }

    public void setMaxScale(int maxScale) {
        this.maxScale = maxScale;
    }

    public double getStep() {
        return step;
    }

}
"
FeedbackNumericalScaleResponseDetails.java,data-transfer,"package teammates.common.datatransfer.questions;

import teammates.common.util.Logger;
import teammates.common.util.StringHelper;

public class FeedbackNumericalScaleResponseDetails extends FeedbackResponseDetails {

    private static final Logger log = Logger.getLogger();

    private double answer;

    public FeedbackNumericalScaleResponseDetails() {
        super(FeedbackQuestionType.NUMSCALE);
    }

    @Override
    public void extractResponseDetails(FeedbackQuestionType questionType,
            FeedbackQuestionDetails questionDetails, String[] answer) {
        try {
            double numscaleAnswer = Double.parseDouble(answer[0]);
            setAnswer(numscaleAnswer);
        } catch (NumberFormatException e) {
            log.severe(""Failed to parse numscale answer to double - "" + answer[0]);
            throw e;
        }
    }

    /**
     * Returns answer in double form.
     */
    public double getAnswer() {
        return answer;
    }

    @Override
    public String getAnswerString() {
        return StringHelper.toDecimalFormatString(answer);
    }

    @Override
    public String getAnswerHtmlInstructorView(FeedbackQuestionDetails questionDetails) {
        return getAnswerString();
    }

    @Override
    public String getAnswerCsv(FeedbackQuestionDetails questionDetails) {
        return getAnswerString();
    }

    private void setAnswer(double answer) {
        this.answer = answer;
    }

}
"
FeedbackQuestionDetails.java,data-transfer,"package teammates.common.datatransfer.questions;

import java.util.Comparator;
import java.util.List;
import java.util.Map;

import teammates.common.datatransfer.FeedbackParticipantType;
import teammates.common.datatransfer.FeedbackSessionResultsBundle;
import teammates.common.datatransfer.attributes.FeedbackQuestionAttributes;
import teammates.common.datatransfer.attributes.FeedbackResponseAttributes;
import teammates.common.util.Assumption;
import teammates.common.util.Const;
import teammates.common.util.HttpRequestHelper;
import teammates.common.util.SanitizationHelper;
import teammates.common.util.StringHelper;
import teammates.ui.template.InstructorFeedbackResultsResponseRow;

/**
 * A class holding the details for a specific question type.
 * This abstract class is inherited by concrete Feedback*QuestionDetails
 * classes which provides the implementation for the various abstract methods
 * such that pages can render the correct information/forms depending on the
 * question type
 */
public abstract class FeedbackQuestionDetails {
    private FeedbackQuestionType questionType;
    private String questionText;

    protected FeedbackQuestionDetails(FeedbackQuestionType questionType) {
        this.questionType = questionType;
    }

    protected FeedbackQuestionDetails(FeedbackQuestionType questionType, String questionText) {
        this.questionType = questionType;
        this.questionText = questionText;
    }

    public abstract String getQuestionTypeDisplayName();

    public abstract String getQuestionWithExistingResponseSubmissionFormHtml(
                                boolean sessionIsOpen, int qnIdx, int responseIdx, String courseId,
                                int totalNumRecipients,
                                FeedbackResponseDetails existingResponseDetails);

    public abstract String getQuestionWithoutExistingResponseSubmissionFormHtml(
                                boolean sessionIsOpen, int qnIdx, int responseIdx, String courseId,
                                int totalNumRecipients);

    public abstract String getQuestionSpecificEditFormHtml(int questionNumber);

    public abstract String getNewQuestionSpecificEditFormHtml();

    public abstract String getQuestionAdditionalInfoHtml(int questionNumber, String additionalInfoId);

    public abstract String getQuestionResultStatisticsHtml(List<FeedbackResponseAttributes> responses,
                                                           FeedbackQuestionAttributes question,
                                                           String studentEmail,
                                                           FeedbackSessionResultsBundle bundle,
                                                           String view);

    public abstract String getQuestionResultStatisticsCsv(List<FeedbackResponseAttributes> responses,
                                                          FeedbackQuestionAttributes question,
                                                          FeedbackSessionResultsBundle bundle);

    public abstract boolean isChangesRequiresResponseDeletion(FeedbackQuestionDetails newDetails);

    public abstract String getCsvHeader();

    /** Gets the header for detailed responses in csv format. Override in child classes if necessary. */
    public String getCsvDetailedResponsesHeader(int noOfComments) {
        return ""Team"" + "","" + ""Giver's Full Name"" + "",""
               + ""Giver's Last Name"" + "","" + ""Giver's Email"" + "",""
               + ""Recipient's Team"" + "","" + ""Recipient's Full Name"" + "",""
               + ""Recipient's Last Name"" + "","" + ""Recipient's Email"" + "",""
               + getCsvHeader()
               + getCsvDetailedFeedbackResponsesCommentsHeader(noOfComments)
               + Const.EOL;
    }

    public String getCsvDetailedResponsesRow(FeedbackSessionResultsBundle fsrBundle,
                                             FeedbackResponseAttributes feedbackResponseAttributes,
                                             FeedbackQuestionAttributes question, boolean hasCommentsForResponses) {
        // Retrieve giver details
        String giverLastName = fsrBundle.getLastNameForEmail(feedbackResponseAttributes.giver);
        String giverFullName = fsrBundle.getNameForEmail(feedbackResponseAttributes.giver);
        String giverTeamName = fsrBundle.getTeamNameForEmail(feedbackResponseAttributes.giver);
        String giverEmail = fsrBundle.getDisplayableEmailGiver(feedbackResponseAttributes);

        // Retrieve recipient details
        String recipientLastName = fsrBundle.getLastNameForEmail(feedbackResponseAttributes.recipient);
        String recipientFullName = fsrBundle.getNameForEmail(feedbackResponseAttributes.recipient);
        String recipientTeamName = fsrBundle.getTeamNameForEmail(feedbackResponseAttributes.recipient);
        String recipientEmail = fsrBundle.getDisplayableEmailRecipient(feedbackResponseAttributes);

        return SanitizationHelper.sanitizeForCsv(StringHelper.removeExtraSpace(giverTeamName))
                + "","" + SanitizationHelper.sanitizeForCsv(StringHelper.removeExtraSpace(giverFullName))
                + "","" + SanitizationHelper.sanitizeForCsv(StringHelper.removeExtraSpace(giverLastName))
                + "","" + SanitizationHelper.sanitizeForCsv(StringHelper.removeExtraSpace(giverEmail))
                + "","" + SanitizationHelper.sanitizeForCsv(StringHelper.removeExtraSpace(recipientTeamName))
                + "","" + SanitizationHelper.sanitizeForCsv(StringHelper.removeExtraSpace(recipientFullName))
                + "","" + SanitizationHelper.sanitizeForCsv(StringHelper.removeExtraSpace(recipientLastName))
                + "","" + SanitizationHelper.sanitizeForCsv(StringHelper.removeExtraSpace(recipientEmail))
                + "","" + fsrBundle.getResponseAnswerCsv(feedbackResponseAttributes, question)
                + (hasCommentsForResponses
                        ? fsrBundle.getCsvDetailedFeedbackResponseCommentsRow(feedbackResponseAttributes) : """")
                + Const.EOL;
    }

    public String getQuestionText() {
        return questionText;
    }

    /**
     * Returns a HTML option for selecting question type.
     * Used in instructorFeedbackEdit.jsp for selecting the question type for a new question.
     */
    public abstract String getQuestionTypeChoiceOption();

    /**
     * Individual responses are shown by default.
     * Override for specific question types if necessary.
     *
     * @return boolean indicating if individual responses are to be shown to students.
     */
    public boolean isIndividualResponsesShownToStudents() {
        return true;
    }

    /**
     * Validates the question details.
     *
     * @return A {@code List<String>} of error messages (to show as status message to user) if any, or an
     *         empty list if question details are valid.
     */
    public abstract List<String> validateQuestionDetails();

    /**
     * Validates {@code List<FeedbackResponseAttributes>} for the question
     * based on the current {@code Feedback*QuestionDetails}.
     *
     * @param responses - The {@code List<FeedbackResponseAttributes>} for the question to be validated
     * @return A {@code List<String>} of error messages (to show as status message to user) if any, or an
     *         empty list if question responses are valid.
     */
    public abstract List<String> validateResponseAttributes(List<FeedbackResponseAttributes> responses, int numRecipients);

    /**
     * Validates if giverType and recipientType are valid for the question type.
     * Validates visibility options as well.
     *
     * <p>Override in Feedback*QuestionDetails if necessary.
     * @return error message detailing the error, or an empty string if valid.
     */
    public abstract String validateGiverRecipientVisibility(FeedbackQuestionAttributes feedbackQuestionAttributes);

    /**
     * Extract question details and sets details accordingly.
     *
     * @return true to indicate success in extracting the details, false otherwise.
     */
    public abstract boolean extractQuestionDetails(Map<String, String[]> requestParameters,
                                                   FeedbackQuestionType questionType);

    public static FeedbackQuestionDetails createQuestionDetails(Map<String, String[]> requestParameters,
                                                                FeedbackQuestionType questionType) {
        String questionText = HttpRequestHelper.getValueFromParamMap(requestParameters,
                                                                     Const.ParamsNames.FEEDBACK_QUESTION_TEXT);
        Assumption.assertNotNull(""Null question text"", questionText);
        Assumption.assertNotEmpty(""Empty question text"", questionText);

        return questionType.getFeedbackQuestionDetailsInstance(questionText, requestParameters);
    }

    // The following function handle the display of rows between possible givers
    // and recipients who did not respond to a question in feedback sessions

    public String getNoResponseTextInHtml(String giverEmail, String recipientEmail,
                                          FeedbackSessionResultsBundle bundle,
                                          FeedbackQuestionAttributes question) {
        return ""<i>""
               + SanitizationHelper.sanitizeForHtml(getNoResponseText(giverEmail, recipientEmail, bundle, question))
               + ""</i>"";
    }

    /**
     * Returns true if 'No Response' is to be displayed in the Response rows.
     */
    public boolean shouldShowNoResponseText(FeedbackQuestionAttributes question) {
        // we do not show all possible responses
        return question.recipientType != FeedbackParticipantType.STUDENTS
            && question.recipientType != FeedbackParticipantType.TEAMS;
    }

    public String getNoResponseTextInCsv(String giverEmail, String recipientEmail,
                                         FeedbackSessionResultsBundle bundle,
                                         FeedbackQuestionAttributes question) {
        return SanitizationHelper.sanitizeForCsv(getNoResponseText(giverEmail, recipientEmail, bundle, question));
    }

    /**
     * Returns text to indicate that there is no response between the giver and recipient.
     *
     * <p>Used in instructorFeedbackResultsPage to show possible givers and recipients who did
     * not respond to the question in the feedback session.
     */
    public String getNoResponseText(String giverEmail, String recipientEmail,
                                    FeedbackSessionResultsBundle bundle,
                                    FeedbackQuestionAttributes question) {
        return Const.INSTRUCTOR_FEEDBACK_RESULTS_MISSING_RESPONSE;
    }

    /** Checks if the question has been skipped. */
    public boolean isQuestionSkipped(String[] answer) {
        if (answer == null) {
            return true;
        }

        boolean allAnswersEmpty = true;

        for (int i = 0; i < answer.length; i++) {
            if (answer[i] != null && !answer[i].trim().isEmpty()) {
                allAnswersEmpty = false;
                break;
            }
        }

        return allAnswersEmpty;
    }

    public boolean isQuestionSpecificSortingRequired() {
        return getResponseRowsSortOrder() != null;
    }

    public abstract Comparator<InstructorFeedbackResultsResponseRow> getResponseRowsSortOrder();

    public FeedbackQuestionType getQuestionType() {
        return questionType;
    }

    public void setQuestionText(String questionText) {
        this.questionText = questionText;
    }

    public boolean isCommentsOnResponsesAllowed() {
        return true;
    }

    public String getCsvDetailedFeedbackResponsesCommentsHeader(int noOfComments) {
        StringBuilder commentsHeader = new StringBuilder(200);

        for (int i = noOfComments; i > 0; i--) {
            commentsHeader.append("","" + ""Comment From"" + "","" + ""Comment"");
        }

        return commentsHeader.toString();
    }
}
"
FeedbackQuestionType.java,data-transfer,"package teammates.common.datatransfer.questions;

import java.util.Map;

import teammates.common.util.Assumption;
import teammates.common.util.Logger;

/**
 * Feedback Question Type Definitions.
 */
public enum FeedbackQuestionType {
    TEXT(FeedbackTextQuestionDetails.class, FeedbackTextResponseDetails.class),
    MCQ(FeedbackMcqQuestionDetails.class, FeedbackMcqResponseDetails.class),
    MSQ(FeedbackMsqQuestionDetails.class, FeedbackMsqResponseDetails.class),
    NUMSCALE(FeedbackNumericalScaleQuestionDetails.class, FeedbackNumericalScaleResponseDetails.class),
    CONSTSUM(FeedbackConstantSumQuestionDetails.class, FeedbackConstantSumResponseDetails.class),
    CONTRIB(FeedbackContributionQuestionDetails.class, FeedbackContributionResponseDetails.class),
    RUBRIC(FeedbackRubricQuestionDetails.class, FeedbackRubricResponseDetails.class),
    RANK_OPTIONS(FeedbackRankOptionsQuestionDetails.class, FeedbackRankOptionsResponseDetails.class),
    RANK_RECIPIENTS(FeedbackRankRecipientsQuestionDetails.class, FeedbackRankRecipientsResponseDetails.class);

    private static final Logger log = Logger.getLogger();

    private final Class<? extends FeedbackQuestionDetails> questionDetailsClass;
    private final Class<? extends FeedbackResponseDetails> responseDetailsClass;

    /**
     * Constructor for FeedbackQuestionType.
     * Pass in the corresponding questionDetailsClass and responseDetailsClass
     */
    FeedbackQuestionType(Class<? extends FeedbackQuestionDetails> questionDetailsClass,
                         Class<? extends FeedbackResponseDetails> responseDetailsClass) {
        this.questionDetailsClass = questionDetailsClass;
        this.responseDetailsClass = responseDetailsClass;
    }

    /**
     * Returns an instance of a corresponding Feedback*QuestionDetails class.
     *
     * @return FeedbackQuestionDetails
     */
    public FeedbackQuestionDetails getFeedbackQuestionDetailsInstance() {
        return getFeedbackQuestionDetailsInstance(null, null);
    }

    public FeedbackQuestionDetails getFeedbackQuestionDetailsInstance(String questionText,
                                                                      Map<String, String[]> requestParameters) {
        FeedbackQuestionDetails feedbackQuestionDetails = null;

        switch (this) {
        case TEXT:
            feedbackQuestionDetails = new FeedbackTextQuestionDetails();
            break;
        case MCQ:
            feedbackQuestionDetails = new FeedbackMcqQuestionDetails();
            break;
        case MSQ:
            feedbackQuestionDetails = new FeedbackMsqQuestionDetails();
            break;
        case NUMSCALE:
            feedbackQuestionDetails = new FeedbackNumericalScaleQuestionDetails();
            break;
        case CONSTSUM:
            feedbackQuestionDetails = new FeedbackConstantSumQuestionDetails();
            break;
        case CONTRIB:
            feedbackQuestionDetails = new FeedbackContributionQuestionDetails();
            break;
        case RUBRIC:
            feedbackQuestionDetails = new FeedbackRubricQuestionDetails();
            break;
        case RANK_OPTIONS:
            feedbackQuestionDetails = new FeedbackRankOptionsQuestionDetails();
            break;
        case RANK_RECIPIENTS:
            feedbackQuestionDetails = new FeedbackRankRecipientsQuestionDetails();
            break;
        default:
            Assumption.fail(""Failed to instantiate Feedback*QuestionDetails instance for ""
                            + this.toString() + "" question type."");
            return null;
        }

        if (questionText != null && requestParameters != null) {
            feedbackQuestionDetails.setQuestionText(questionText);
            feedbackQuestionDetails.extractQuestionDetails(requestParameters, this);
        }

        return feedbackQuestionDetails;
    }

    /**
     * Returns an instance of a corresponding Feedback*ResponseDetails class.
     *
     * @return FeedbackResponseDetails
     */
    public FeedbackResponseDetails getFeedbackResponseDetailsInstance(
            FeedbackQuestionDetails questionDetails, String[] answer, Map<String, String[]> requestParameters,
            int questionIndx, int responseIndx) {
        FeedbackResponseDetails feedbackResponseDetails = null;

        switch (this) {
        case TEXT:
            feedbackResponseDetails = new FeedbackTextResponseDetails();
            break;
        case MCQ:
            feedbackResponseDetails = new FeedbackMcqResponseDetails();
            break;
        case MSQ:
            feedbackResponseDetails = new FeedbackMsqResponseDetails();
            break;
        case NUMSCALE:
            feedbackResponseDetails = new FeedbackNumericalScaleResponseDetails();
            break;
        case CONSTSUM:
            feedbackResponseDetails = new FeedbackConstantSumResponseDetails();
            break;
        case CONTRIB:
            feedbackResponseDetails = new FeedbackContributionResponseDetails();
            break;
        case RUBRIC:
            feedbackResponseDetails = new FeedbackRubricResponseDetails();
            break;
        case RANK_OPTIONS:
            feedbackResponseDetails = new FeedbackRankOptionsResponseDetails();
            break;
        case RANK_RECIPIENTS:
            feedbackResponseDetails = new FeedbackRankRecipientsResponseDetails();
            break;
        default:
            Assumption.fail(""Failed to instantiate Feedback*ResponseDetails instance for ""
                            + this.toString() + "" question type."");
            return null;
        }

        try {
            switch (this) {
            case MCQ:
                ((FeedbackMcqResponseDetails) feedbackResponseDetails)
                        .extractResponseDetails(this, questionDetails, answer, requestParameters,
                                                questionIndx, responseIndx);
                break;
            case MSQ:
                ((FeedbackMsqResponseDetails) feedbackResponseDetails)
                        .extractResponseDetails(this, questionDetails, answer, requestParameters,
                                                questionIndx, responseIndx);
                break;
            default:
                feedbackResponseDetails.extractResponseDetails(this, questionDetails, answer);
                break;
            }
        } catch (Exception e) {
            log.warning(""Failed to extract response details.\n"" + e.toString());
            return null;
        }

        return feedbackResponseDetails;
    }

    /**
     * Getter for corresponding Feedback*QuestionDetails class.
     *
     * @return Class<? extends FeedbackQuestionDetails>
     */
    public Class<? extends FeedbackQuestionDetails> getQuestionDetailsClass() {
        return questionDetailsClass;
    }

    /**
     * Getter for corresponding Feedback*ResponseDetails class.
     *
     * @return Class<? extends FeedbackResponseDetails>
     */
    public Class<? extends FeedbackResponseDetails> getResponseDetailsClass() {
        return responseDetailsClass;
    }

    /**
     * Returns CONSTSUM if passed CONSTSUM_OPTION or CONSTSUM_RECIPIENT as argument.
     * Any other string is returned as is.
     */
    public static String standardizeIfConstSum(String questionType) {
        if (""CONSTSUM_OPTION"".equals(questionType) || ""CONSTSUM_RECIPIENT"".equals(questionType)) {
            return ""CONSTSUM"";
        }
        return questionType;
    }
}
"
FeedbackRankOptionsQuestionDetails.java,data-transfer,"package teammates.common.datatransfer.questions;

import java.text.DecimalFormat;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import teammates.common.datatransfer.FeedbackSessionResultsBundle;
import teammates.common.datatransfer.attributes.FeedbackQuestionAttributes;
import teammates.common.datatransfer.attributes.FeedbackResponseAttributes;
import teammates.common.util.Assumption;
import teammates.common.util.Const;
import teammates.common.util.HttpRequestHelper;
import teammates.common.util.SanitizationHelper;
import teammates.common.util.StringHelper;
import teammates.common.util.Templates;
import teammates.common.util.Templates.FeedbackQuestion.FormTemplates;
import teammates.common.util.Templates.FeedbackQuestion.Slots;
import teammates.ui.pagedata.PageData;
import teammates.ui.template.ElementTag;
import teammates.ui.template.InstructorFeedbackResultsResponseRow;

public class FeedbackRankOptionsQuestionDetails extends FeedbackRankQuestionDetails {
    public static final transient int MIN_NUM_OF_OPTIONS = 2;
    public static final transient String ERROR_NOT_ENOUGH_OPTIONS =
            ""Too little options for "" + Const.FeedbackQuestionTypeNames.RANK_OPTION
            + "". Minimum number of options is: "";

    List<String> options;

    public FeedbackRankOptionsQuestionDetails() {
        super(FeedbackQuestionType.RANK_OPTIONS);

        this.options = new ArrayList<>();
    }

    @Override
    public boolean extractQuestionDetails(Map<String, String[]> requestParameters,
                                          FeedbackQuestionType questionType) {
        super.extractQuestionDetails(requestParameters, questionType);
        List<String> options = new ArrayList<>();

        String numOptionsCreatedString =
                HttpRequestHelper.getValueFromParamMap(
                        requestParameters, Const.ParamsNames.FEEDBACK_QUESTION_NUMBEROFCHOICECREATED);
        Assumption.assertNotNull(""Null number of choice for Rank"", numOptionsCreatedString);
        int numOptionsCreated = Integer.parseInt(numOptionsCreatedString);

        for (int i = 0; i < numOptionsCreated; i++) {
            String rankOption = HttpRequestHelper.getValueFromParamMap(
                    requestParameters, Const.ParamsNames.FEEDBACK_QUESTION_RANKOPTION + ""-"" + i);
            if (rankOption != null && !rankOption.trim().isEmpty()) {
                options.add(rankOption);
            }
        }

        this.initialiseQuestionDetails(options);

        return true;
    }

    private void initialiseQuestionDetails(List<String> options) {
        this.options = options;
    }

    @Override
    public String getQuestionTypeDisplayName() {
        return Const.FeedbackQuestionTypeNames.RANK_OPTION;
    }

    @Override
    public String getQuestionWithExistingResponseSubmissionFormHtml(
                        boolean sessionIsOpen, int qnIdx, int responseIdx, String courseId,
                        int totalNumRecipients,
                        FeedbackResponseDetails existingResponseDetails) {

        FeedbackRankOptionsResponseDetails existingResponse = (FeedbackRankOptionsResponseDetails) existingResponseDetails;
        StringBuilder optionListHtml = new StringBuilder();
        String optionFragmentTemplate = FormTemplates.RANK_SUBMISSION_FORM_OPTIONFRAGMENT;

        for (int i = 0; i < options.size(); i++) {
            String optionFragment =
                    Templates.populateTemplate(optionFragmentTemplate,
                            Slots.QUESTION_INDEX, Integer.toString(qnIdx),
                            Slots.RESPONSE_INDEX, Integer.toString(responseIdx),
                            Slots.OPTION_INDEX, Integer.toString(i),
                            Slots.DISABLED, sessionIsOpen ? """" : ""disabled"",
                            Slots.RANK_OPTION_VISIBILITY, """",
                            Slots.OPTIONS,
                                    getSubmissionOptionsHtmlForRankingOptions(existingResponse.getAnswerList().get(i)),
                            Slots.FEEDBACK_RESPONSE_TEXT, Const.ParamsNames.FEEDBACK_RESPONSE_TEXT,
                            Slots.RANK_OPTION_VALUE, SanitizationHelper.sanitizeForHtml(options.get(i)));
            optionListHtml.append(optionFragment).append(Const.EOL);

        }

        return Templates.populateTemplate(
                FormTemplates.RANK_SUBMISSION_FORM,
                Slots.RANK_SUBMISSION_FORM_OPTION_FRAGMENTS, optionListHtml.toString(),
                Slots.QUESTION_INDEX, Integer.toString(qnIdx),
                Slots.RESPONSE_INDEX, Integer.toString(responseIdx),
                Slots.RANK_OPTION_VISIBILITY, """",
                Slots.RANK_PARAM_TO_RECIPIENT, Const.ParamsNames.FEEDBACK_QUESTION_RANKTORECIPIENTS,
                Slots.RANK_TO_RECIPIENTS_VALUE, ""false"",
                Slots.RANK_PARAM_NUM_OPTION, Const.ParamsNames.FEEDBACK_QUESTION_RANKNUMOPTIONS,
                Slots.RANK_NUM_OPTION_VALUE, Integer.toString(options.size()),
                Slots.RANK_PARAM_IS_DUPLICATES_ALLOWED, Const.ParamsNames.FEEDBACK_QUESTION_RANKISDUPLICATESALLOWED,
                Slots.RANK_ARE_DUPLICATES_ALLOWED_VALUE, Boolean.toString(isAreDuplicatesAllowed())
                );
    }

    @Override
    public String getQuestionWithoutExistingResponseSubmissionFormHtml(
            boolean sessionIsOpen, int qnIdx, int responseIdx, String courseId, int totalNumRecipients) {

        StringBuilder optionListHtml = new StringBuilder();
        String optionFragmentTemplate = FormTemplates.RANK_SUBMISSION_FORM_OPTIONFRAGMENT;

        for (int i = 0; i < options.size(); i++) {
            String optionFragment =
                    Templates.populateTemplate(optionFragmentTemplate,
                            Slots.QUESTION_INDEX, Integer.toString(qnIdx),
                            Slots.RESPONSE_INDEX, Integer.toString(responseIdx),
                            Slots.OPTION_INDEX, Integer.toString(i),
                            Slots.DISABLED, sessionIsOpen ? """" : ""disabled"",
                            Slots.RANK_OPTION_VISIBILITY, """",
                            Slots.OPTIONS, getSubmissionOptionsHtmlForRankingOptions(Const.INT_UNINITIALIZED),
                            Slots.FEEDBACK_RESPONSE_TEXT, Const.ParamsNames.FEEDBACK_RESPONSE_TEXT,
                            Slots.RANK_OPTION_VALUE, SanitizationHelper.sanitizeForHtml(options.get(i)));
            optionListHtml.append(optionFragment).append(Const.EOL);
        }

        return Templates.populateTemplate(
                FormTemplates.RANK_SUBMISSION_FORM,
                Slots.RANK_SUBMISSION_FORM_OPTION_FRAGMENTS, optionListHtml.toString(),
                Slots.QUESTION_INDEX, Integer.toString(qnIdx),
                Slots.RESPONSE_INDEX, Integer.toString(responseIdx),
                Slots.RANK_OPTION_VISIBILITY, """",
                Slots.RANK_TO_RECIPIENTS_VALUE, ""false"",
                Slots.RANK_PARAM_TO_RECIPIENT, Const.ParamsNames.FEEDBACK_QUESTION_RANKTORECIPIENTS,
                Slots.RANK_PARAM_NUM_OPTION, Const.ParamsNames.FEEDBACK_QUESTION_RANKNUMOPTIONS,
                Slots.RANK_NUM_OPTION_VALUE, Integer.toString(options.size()),
                Slots.RANK_PARAM_IS_DUPLICATES_ALLOWED, Const.ParamsNames.FEEDBACK_QUESTION_RANKISDUPLICATESALLOWED,
                Slots.RANK_ARE_DUPLICATES_ALLOWED_VALUE, Boolean.toString(isAreDuplicatesAllowed()));
    }

    private String getSubmissionOptionsHtmlForRankingOptions(int rankGiven) {
        StringBuilder result = new StringBuilder(100);

        ElementTag option = PageData.createOption("""", """", rankGiven == Const.INT_UNINITIALIZED);
        result.append(""<option""
                     + option.getAttributesToString() + "">""
                     + option.getContent()
                     + ""</option>"");
        for (int i = 1; i <= options.size(); i++) {
            option = PageData.createOption(String.valueOf(i), String.valueOf(i), rankGiven == i);
            result.append(""<option""
                        + option.getAttributesToString() + "">""
                        + option.getContent()
                        + ""</option>"");
        }

        return result.toString();
    }

    @Override
    public String getQuestionSpecificEditFormHtml(int questionNumber) {
        StringBuilder optionListHtml = new StringBuilder();
        String optionFragmentTemplate = FormTemplates.RANK_EDIT_FORM_OPTIONFRAGMENT;

        for (int i = 0; i < options.size(); i++) {
            String optionFragment =
                    Templates.populateTemplate(optionFragmentTemplate,
                            Slots.ITERATOR, Integer.toString(i),
                            Slots.RANK_OPTION_VALUE, SanitizationHelper.sanitizeForHtml(options.get(i)),
                            Slots.RANK_PARAM_OPTION, Const.ParamsNames.FEEDBACK_QUESTION_RANKOPTION);

            optionListHtml.append(optionFragment).append(Const.EOL);
        }

        return Templates.populateTemplate(
                FormTemplates.RANK_EDIT_OPTIONS_FORM,
                Slots.RANK_EDIT_FORM_OPTION_FRAGMENTS, optionListHtml.toString(),
                Slots.QUESTION_NUMBER, Integer.toString(questionNumber),
                Slots.RANK_PARAM_NUMBER_OF_CHOICE_CREATED, Const.ParamsNames.FEEDBACK_QUESTION_NUMBEROFCHOICECREATED,
                Slots.RANK_NUM_OPTIONS, String.valueOf(options.size()),
                Slots.RANK_OPTION_RECIPIENT_DISPLAY_NAME, ""option"",
                Slots.RANK_PARAM_IS_DUPLICATES_ALLOWED, Const.ParamsNames.FEEDBACK_QUESTION_RANKISDUPLICATESALLOWED,
                Slots.RANK_ARE_DUPLICATES_ALLOWED_CHECKED, isAreDuplicatesAllowed() ? ""checked"" : """");

    }

    @Override
    public String getNewQuestionSpecificEditFormHtml() {
        // Add two empty options by default
        this.options.add("""");
        this.options.add("""");

        return ""<div id=\""rankOptionsForm\"">""
              + this.getQuestionSpecificEditFormHtml(-1)
              + ""</div>"";
    }

    @Override
    public String getQuestionAdditionalInfoHtml(int questionNumber,
            String additionalInfoId) {
        StringBuilder optionListHtml = new StringBuilder(100);
        String optionFragmentTemplate = FormTemplates.MSQ_ADDITIONAL_INFO_FRAGMENT;
        String additionalInfo = """";

        optionListHtml.append(""<ul style=\""list-style-type: disc;margin-left: 20px;\"" >"");
        for (String option : options) {
            String optionFragment =
                    Templates.populateTemplate(optionFragmentTemplate,
                            Slots.MSQ_CHOICE_VALUE, option);

            optionListHtml.append(optionFragment);
        }

        optionListHtml.append(""</ul>"");
        additionalInfo = Templates.populateTemplate(
            FormTemplates.MSQ_ADDITIONAL_INFO,
            Slots.QUESTION_TYPE_NAME, this.getQuestionTypeDisplayName(),
            Slots.MSQ_ADDITIONAL_INFO_FRAGMENTS, optionListHtml.toString());

        return Templates.populateTemplate(
                FormTemplates.FEEDBACK_QUESTION_ADDITIONAL_INFO,
                Slots.MORE, ""[more]"",
                Slots.LESS, ""[less]"",
                Slots.QUESTION_NUMBER, Integer.toString(questionNumber),
                Slots.ADDITIONAL_INFO_ID, additionalInfoId,
                Slots.QUESTION_ADDITIONAL_INFO, additionalInfo);
    }

    @Override
    public String getQuestionResultStatisticsHtml(
                        List<FeedbackResponseAttributes> responses,
                        FeedbackQuestionAttributes question,
                        String studentEmail,
                        FeedbackSessionResultsBundle bundle,
                        String view) {

        if (""student"".equals(view) || responses.isEmpty()) {
            return """";
        }

        StringBuilder fragments = new StringBuilder(100);

        Map<String, List<Integer>> optionRanks = generateOptionRanksMapping(responses);

        DecimalFormat df = new DecimalFormat(""#.##"");

        for (Entry<String, List<Integer>> entry : optionRanks.entrySet()) {

            List<Integer> ranks = entry.getValue();
            double average = computeAverage(ranks);
            String ranksReceived = getListOfRanksReceivedAsString(ranks);

            String option = entry.getKey();

            fragments.append(Templates.populateTemplate(FormTemplates.RANK_RESULT_STATS_OPTIONFRAGMENT,
                    Slots.RANK_OPTION_VALUE, SanitizationHelper.sanitizeForHtml(option),
                    Slots.RANK_RECIEVED, ranksReceived,
                    Slots.RANK_AVERAGE, df.format(average)));

        }

        return Templates.populateTemplate(FormTemplates.RANK_RESULT_OPTION_STATS,
                Slots.OPTION_RECIPIENT_DISPLAY_NAME, ""Option"",
                Slots.FRAGMENTS, fragments.toString());
    }

    @Override
    public String getQuestionResultStatisticsCsv(
                        List<FeedbackResponseAttributes> responses,
                        FeedbackQuestionAttributes question,
                        FeedbackSessionResultsBundle bundle) {
        if (responses.isEmpty()) {
            return """";
        }

        StringBuilder fragments = new StringBuilder();
        Map<String, List<Integer>> optionRanks = generateOptionRanksMapping(responses);

        DecimalFormat df = new DecimalFormat(""#.##"");

        for (Entry<String, List<Integer>> entry : optionRanks.entrySet()) {
            String option = SanitizationHelper.sanitizeForCsv(entry.getKey());

            List<Integer> ranksAssigned = entry.getValue();
            double average = computeAverage(ranksAssigned);
            String fragment = option + "","" + df.format(average) + "",""
                    + StringHelper.join("","", ranksAssigned) + Const.EOL;
            fragments.append(fragment);
        }

        return ""Option, Average Rank, Ranks Received"" + Const.EOL + fragments.toString() + Const.EOL;
    }

    /**
     * From the feedback responses, generate a mapping of the option to a list of
     * ranks received for that option.
     * The key of the map returned is the option name.
     * The values of the map are list of ranks received by the key.
     * @param responses  a list of responses
     */
    private Map<String, List<Integer>> generateOptionRanksMapping(
                                            List<FeedbackResponseAttributes> responses) {
        Map<String, List<Integer>> optionRanks = new HashMap<>();
        for (FeedbackResponseAttributes response : responses) {
            FeedbackRankOptionsResponseDetails frd = (FeedbackRankOptionsResponseDetails) response.getResponseDetails();

            List<Integer> answers = frd.getAnswerList();
            Map<String, Integer> mapOfOptionToRank = new HashMap<>();

            Assumption.assertEquals(answers.size(), options.size());

            for (int i = 0; i < options.size(); i++) {
                int rankReceived = answers.get(i);
                mapOfOptionToRank.put(options.get(i), rankReceived);
            }

            Map<String, Integer> normalisedRankForOption =
                    obtainMappingToNormalisedRanksForRanking(mapOfOptionToRank, options);

            for (int i = 0; i < options.size(); i++) {
                String optionReceivingRanks = options.get(i);
                int rankReceived = normalisedRankForOption.get(optionReceivingRanks);

                if (rankReceived != Const.POINTS_NOT_SUBMITTED) {
                    updateOptionRanksMapping(optionRanks, optionReceivingRanks, rankReceived);
                }
            }
        }
        return optionRanks;
    }

    @Override
    public boolean isChangesRequiresResponseDeletion(FeedbackQuestionDetails newDetails) {
        FeedbackRankOptionsQuestionDetails newRankQuestionDetails = (FeedbackRankOptionsQuestionDetails) newDetails;

        return this.options.size() != newRankQuestionDetails.options.size()
            || !this.options.containsAll(newRankQuestionDetails.options)
            || !newRankQuestionDetails.options.containsAll(this.options);
    }

    @Override
    public String getCsvHeader() {
        StringBuilder result = new StringBuilder();
        for (int i = 0; i < this.options.size(); i++) {
            result.append(String.format(""Rank %d,"", i + 1));
        }
        result.deleteCharAt(result.length() - 1); // remove the last comma

        return result.toString();
    }

    @Override
    public String getQuestionTypeChoiceOption() {
        return ""<li data-questiontype = \"""" + FeedbackQuestionType.RANK_OPTIONS.name() + ""\"">""
                 + ""<a href=\""javascript:;\"">"" + Const.FeedbackQuestionTypeNames.RANK_OPTION + ""</a>""
             + ""</li>"";
    }

    @Override
    public List<String> validateQuestionDetails() {
        List<String> errors = new ArrayList<>();
        if (options.size() < MIN_NUM_OF_OPTIONS) {
            errors.add(ERROR_NOT_ENOUGH_OPTIONS + MIN_NUM_OF_OPTIONS + ""."");
        }
        return errors;
    }

    @Override
    public List<String> validateResponseAttributes(
            List<FeedbackResponseAttributes> responses,
            int numRecipients) {
        if (responses.isEmpty()) {
            return new ArrayList<>();
        }

        if (isAreDuplicatesAllowed()) {
            return new ArrayList<>();
        }
        List<String> errors = new ArrayList<>();

        for (FeedbackResponseAttributes response : responses) {
            FeedbackRankOptionsResponseDetails frd = (FeedbackRankOptionsResponseDetails) response.getResponseDetails();
            Set<Integer> responseRank = new HashSet<>();

            for (int answer : frd.getFilteredSortedAnswerList()) {
                if (responseRank.contains(answer)) {
                    errors.add(""Duplicate rank "" + answer);
                }
                responseRank.add(answer);
            }
        }

        return errors;
    }

    @Override
    public Comparator<InstructorFeedbackResultsResponseRow> getResponseRowsSortOrder() {
        return null;
    }

    @Override
    public String validateGiverRecipientVisibility(FeedbackQuestionAttributes feedbackQuestionAttributes) {
        return """";
    }

}
"
FeedbackRankOptionsResponseDetails.java,data-transfer,"package teammates.common.datatransfer.questions;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Map.Entry;
import java.util.SortedMap;
import java.util.TreeMap;

import teammates.common.util.Assumption;
import teammates.common.util.Const;
import teammates.common.util.SanitizationHelper;
import teammates.common.util.StringHelper;

public class FeedbackRankOptionsResponseDetails extends FeedbackRankResponseDetails {
    private List<Integer> answers;

    public FeedbackRankOptionsResponseDetails() {
        super(FeedbackQuestionType.RANK_OPTIONS);
    }

    @Override
    public void extractResponseDetails(FeedbackQuestionType questionType,
                                       FeedbackQuestionDetails questionDetails,
                                       String[] answer) {
        List<Integer> rankAnswer = new ArrayList<>();
        for (String answerPart : answer) {
            try {
                rankAnswer.add(Integer.parseInt(answerPart));
            } catch (NumberFormatException e) {
                rankAnswer.add(Const.POINTS_NOT_SUBMITTED);
            }
        }
        FeedbackRankOptionsQuestionDetails rankQuestion = (FeedbackRankOptionsQuestionDetails) questionDetails;
        this.setRankResponseDetails(rankAnswer, rankQuestion.options);
    }

    /**
     * Returns List of sorted answers, with uninitialised values filtered out.
     */
    public List<Integer> getFilteredSortedAnswerList() {
        List<Integer> filteredAnswers = new ArrayList<>();

        for (int answer : answers) {
            if (answer != Const.POINTS_NOT_SUBMITTED) {
                filteredAnswers.add(answer);
            }
        }

        Collections.sort(filteredAnswers);
        return filteredAnswers;
    }

    public List<Integer> getAnswerList() {
        return new ArrayList<>(answers);
    }

    @Override
    public String getAnswerString() {
        String listString = getFilteredSortedAnswerList().toString(); //[1, 2, 3] format
        return listString.substring(1, listString.length() - 1); //remove []
    }

    @Override
    public String getAnswerHtmlInstructorView(FeedbackQuestionDetails questionDetails) {
        FeedbackRankOptionsQuestionDetails rankQuestion = (FeedbackRankOptionsQuestionDetails) questionDetails;

        SortedMap<Integer, List<String>> orderedOptions = generateMapOfRanksToOptions(rankQuestion);

        StringBuilder htmlBuilder = new StringBuilder(100);
        htmlBuilder.append(""<ul>"");

        for (Entry<Integer, List<String>> rankAndOption : orderedOptions.entrySet()) {
            Integer rank = rankAndOption.getKey();
            if (rank == Const.POINTS_NOT_SUBMITTED) {
                continue;
            }

            List<String> optionsWithGivenRank = rankAndOption.getValue();
            for (String option : optionsWithGivenRank) {
                htmlBuilder.append(""<li>"");
                htmlBuilder.append(SanitizationHelper.sanitizeForHtml(rank.toString()));
                htmlBuilder.append("": "");
                htmlBuilder.append(option);
                htmlBuilder.append(""</li>"");
            }
        }

        htmlBuilder.append(""</ul>"");
        return htmlBuilder.toString();
    }

    @Override
    public String getAnswerCsv(FeedbackQuestionDetails questionDetails) {
        FeedbackRankOptionsQuestionDetails rankQuestion = (FeedbackRankOptionsQuestionDetails) questionDetails;

        SortedMap<Integer, List<String>> orderedOptions = generateMapOfRanksToOptions(rankQuestion);

        StringBuilder csvBuilder = new StringBuilder();

        for (int rank = 1; rank <= rankQuestion.options.size(); rank++) {
            if (!orderedOptions.containsKey(rank)) {
                csvBuilder.append(',');
                continue;
            }
            List<String> optionsWithGivenRank = orderedOptions.get(rank);

            String optionsInCsv = SanitizationHelper.sanitizeForCsv(StringHelper.toString(optionsWithGivenRank, "", ""));

            csvBuilder.append(optionsInCsv).append(',');
        }

        csvBuilder.deleteCharAt(csvBuilder.length() - 1); // remove last comma
        return csvBuilder.toString();
    }

    private SortedMap<Integer, List<String>> generateMapOfRanksToOptions(
                                    FeedbackRankOptionsQuestionDetails rankQuestion) {
        SortedMap<Integer, List<String>> orderedOptions = new TreeMap<>();
        for (int i = 0; i < answers.size(); i++) {
            String option = rankQuestion.options.get(i);
            Integer answer = answers.get(i);

            if (!orderedOptions.containsKey(answer)) {
                orderedOptions.put(answer, new ArrayList<String>());
            }
            List<String> optionsWithGivenRank = orderedOptions.get(answer);
            optionsWithGivenRank.add(option);
        }
        return orderedOptions;
    }

    private void setRankResponseDetails(List<Integer> answers, List<String> options) {
        this.answers = answers;

        Assumption.assertEquals(""Rank question: number of responses does not match number of options. ""
                                        + answers.size() + ""/"" + options.size(),
                                answers.size(), options.size());

    }

}
"
FeedbackRankQuestionDetails.java,data-transfer,"package teammates.common.datatransfer.questions;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.TreeMap;

import teammates.common.util.Const;
import teammates.common.util.HttpRequestHelper;

public abstract class FeedbackRankQuestionDetails extends FeedbackQuestionDetails {

    private boolean areDuplicatesAllowed;

    FeedbackRankQuestionDetails(FeedbackQuestionType questionType) {
        super(questionType);
    }

    public FeedbackRankQuestionDetails(FeedbackQuestionType questionType, String questionText) {
        super(questionType, questionText);
    }

    @Override
    public boolean extractQuestionDetails(Map<String, String[]> requestParameters,
                                          FeedbackQuestionType questionType) {

        String areDuplicatesAllowedString =
                HttpRequestHelper.getValueFromParamMap(
                        requestParameters, Const.ParamsNames.FEEDBACK_QUESTION_RANKISDUPLICATESALLOWED);
        boolean areDuplicatesAllowed = ""on"".equals(areDuplicatesAllowedString);

        this.areDuplicatesAllowed = areDuplicatesAllowed;
        return true;
    }

    @Override
    public abstract String getQuestionTypeDisplayName();

    @Override
    public abstract String getQuestionWithExistingResponseSubmissionFormHtml(
                        boolean sessionIsOpen, int qnIdx, int responseIdx, String courseId,
                        int totalNumRecipients,
                        FeedbackResponseDetails existingResponseDetails);

    @Override
    public abstract String getQuestionWithoutExistingResponseSubmissionFormHtml(
            boolean sessionIsOpen, int qnIdx, int responseIdx, String courseId, int totalNumRecipients);

    @Override
    public abstract String getQuestionSpecificEditFormHtml(int questionNumber);

    /**
     * Updates the mapping of ranks for the option optionReceivingPoints.
     */
    protected void updateOptionRanksMapping(
                        Map<String, List<Integer>> optionRanks,
                        String optionReceivingRanks, int rankReceived) {
        if (!optionRanks.containsKey(optionReceivingRanks)) {
            List<Integer> ranks = new ArrayList<>();
            optionRanks.put(optionReceivingRanks, ranks);
        }

        List<Integer> ranksReceived = optionRanks.get(optionReceivingRanks);
        ranksReceived.add(rankReceived);
    }

    /**
     * Returns the list of points as as string to display.
     */
    protected String getListOfRanksReceivedAsString(List<Integer> ranksReceived) {
        Collections.sort(ranksReceived);
        StringBuilder pointsReceived = new StringBuilder();

        if (ranksReceived.size() > 10) {
            for (int i = 0; i < 5; i++) {
                pointsReceived.append(ranksReceived.get(i)).append("" , "");
            }

            pointsReceived.append(""..."");

            for (int i = ranksReceived.size() - 5; i < ranksReceived.size(); i++) {
                pointsReceived.append("" , "").append(ranksReceived.get(i));
            }
        } else {
            for (int i = 0; i < ranksReceived.size(); i++) {
                pointsReceived.append(ranksReceived.get(i));

                if (i != ranksReceived.size() - 1) {
                    pointsReceived.append("" , "");
                }
            }
        }

        return pointsReceived.toString();
    }

    protected double computeAverage(List<Integer> values) {
        double average = 0;
        for (double value : values) {
            average = average + value;
        }
        return average / values.size();
    }

    /**
     * For a single set of ranking (options / feedback responses),
     * fix ties by assigning the MIN value of the ordering to all the tied options
     * e.g. the normalised ranks of the set of ranks (1,4,1,4) is (1,3,1,3)
     * @param rankOfOption  a map containing the original unfiltered answer for each options
     * @param options  a list of options
     * @return a map of the option to the normalised rank of the response
     */
    protected <K> Map<K, Integer> obtainMappingToNormalisedRanksForRanking(
                                                        Map<K, Integer> rankOfOption,
                                                        List<K> options) {
        Map<K, Integer> normalisedRankForSingleSetOfRankings = new HashMap<>();

        // group the options/feedback response by its rank
        TreeMap<Integer, List<K>> rankToAnswersMap = new TreeMap<>();
        for (K answer : options) {
            int rankGiven = rankOfOption.get(answer);
            if (rankGiven == Const.POINTS_NOT_SUBMITTED) {
                normalisedRankForSingleSetOfRankings.put(answer, Const.POINTS_NOT_SUBMITTED);
                continue;
            }

            if (!rankToAnswersMap.containsKey(rankGiven)) {
                rankToAnswersMap.put(rankGiven, new ArrayList<K>());
            }
            rankToAnswersMap.get(rankGiven).add(answer);
        }

        // every answer in the same group is given the same rank
        int currentRank = 1;
        for (List<K> answersWithSameRank : rankToAnswersMap.values()) {
            for (K answer : answersWithSameRank) {
                normalisedRankForSingleSetOfRankings.put(answer, currentRank);
            }

            currentRank += answersWithSameRank.size();
        }

        return normalisedRankForSingleSetOfRankings;
    }

    public boolean isAreDuplicatesAllowed() {
        return areDuplicatesAllowed;
    }

}
"
FeedbackRankRecipientsQuestionDetails.java,data-transfer,"package teammates.common.datatransfer.questions;

import java.text.DecimalFormat;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import teammates.common.datatransfer.FeedbackSessionResultsBundle;
import teammates.common.datatransfer.attributes.FeedbackQuestionAttributes;
import teammates.common.datatransfer.attributes.FeedbackResponseAttributes;
import teammates.common.util.Const;
import teammates.common.util.SanitizationHelper;
import teammates.common.util.StringHelper;
import teammates.common.util.Templates;
import teammates.common.util.Templates.FeedbackQuestion.FormTemplates;
import teammates.common.util.Templates.FeedbackQuestion.Slots;
import teammates.ui.pagedata.PageData;
import teammates.ui.template.ElementTag;
import teammates.ui.template.InstructorFeedbackResultsResponseRow;

public class FeedbackRankRecipientsQuestionDetails extends FeedbackRankQuestionDetails {

    public FeedbackRankRecipientsQuestionDetails() {
        super(FeedbackQuestionType.RANK_RECIPIENTS);
    }

    @Override
    public String getQuestionTypeDisplayName() {
        return Const.FeedbackQuestionTypeNames.RANK_RECIPIENT;
    }

    @Override
    public String getQuestionWithExistingResponseSubmissionFormHtml(
                        boolean sessionIsOpen, int qnIdx, int responseIdx, String courseId,
                        int totalNumRecipients,
                        FeedbackResponseDetails existingResponseDetails) {

        FeedbackRankRecipientsResponseDetails existingResponse =
                (FeedbackRankRecipientsResponseDetails) existingResponseDetails;
        StringBuilder optionListHtml = new StringBuilder();
        String optionFragmentTemplate = FormTemplates.RANK_SUBMISSION_FORM_OPTIONFRAGMENT;

        String optionFragment =
                Templates.populateTemplate(optionFragmentTemplate,
                        Slots.QUESTION_INDEX, Integer.toString(qnIdx),
                        Slots.RESPONSE_INDEX, Integer.toString(responseIdx),
                        Slots.OPTION_INDEX, ""0"",
                        Slots.DISABLED, sessionIsOpen ? """" : ""disabled"",
                        Slots.RANK_OPTION_VISIBILITY, ""style=\""display:none\"""",
                        Slots.OPTIONS, getSubmissionOptionsHtmlForRankingRecipients(
                                           totalNumRecipients, existingResponse.answer),
                        Slots.FEEDBACK_RESPONSE_TEXT, Const.ParamsNames.FEEDBACK_RESPONSE_TEXT,
                        Slots.RANK_OPTION_VALUE, """");
        optionListHtml.append(optionFragment).append(Const.EOL);

        return Templates.populateTemplate(
                FormTemplates.RANK_SUBMISSION_FORM,
                Slots.RANK_SUBMISSION_FORM_OPTION_FRAGMENTS, optionListHtml.toString(),
                Slots.QUESTION_INDEX, Integer.toString(qnIdx),
                Slots.RESPONSE_INDEX, Integer.toString(responseIdx),
                Slots.RANK_OPTION_VISIBILITY, ""style=\""display:none\"""",
                Slots.RANK_PARAM_TO_RECIPIENT, Const.ParamsNames.FEEDBACK_QUESTION_RANKTORECIPIENTS,
                Slots.RANK_TO_RECIPIENTS_VALUE, ""true"",
                Slots.RANK_PARAM_NUM_OPTION, Const.ParamsNames.FEEDBACK_QUESTION_RANKNUMOPTIONS,
                Slots.RANK_NUM_OPTION_VALUE, Integer.toString(0),
                Slots.RANK_PARAM_IS_DUPLICATES_ALLOWED, Const.ParamsNames.FEEDBACK_QUESTION_RANKISDUPLICATESALLOWED,
                Slots.RANK_ARE_DUPLICATES_ALLOWED_VALUE, Boolean.toString(isAreDuplicatesAllowed())
                );
    }

    @Override
    public String getQuestionWithoutExistingResponseSubmissionFormHtml(
            boolean sessionIsOpen, int qnIdx, int responseIdx, String courseId, int totalNumRecipients) {

        StringBuilder optionListHtml = new StringBuilder();
        String optionFragmentTemplate = FormTemplates.RANK_SUBMISSION_FORM_OPTIONFRAGMENT;

        String optionFragment =
                Templates.populateTemplate(optionFragmentTemplate,
                        Slots.QUESTION_INDEX, Integer.toString(qnIdx),
                        Slots.RESPONSE_INDEX, Integer.toString(responseIdx),
                        Slots.OPTION_INDEX, ""0"",
                        Slots.DISABLED, sessionIsOpen ? """" : ""disabled"",
                        Slots.RANK_OPTION_VISIBILITY, ""style=\""display:none\"""",
                        Slots.OPTIONS, getSubmissionOptionsHtmlForRankingRecipients(
                                           totalNumRecipients, Const.INT_UNINITIALIZED),
                        Slots.FEEDBACK_RESPONSE_TEXT, Const.ParamsNames.FEEDBACK_RESPONSE_TEXT,
                        Slots.RANK_OPTION_VALUE, """");
        optionListHtml.append(optionFragment).append(Const.EOL);

        return Templates.populateTemplate(
                FormTemplates.RANK_SUBMISSION_FORM,
                Slots.RANK_SUBMISSION_FORM_OPTION_FRAGMENTS, optionListHtml.toString(),
                Slots.QUESTION_INDEX, Integer.toString(qnIdx),
                Slots.RESPONSE_INDEX, Integer.toString(responseIdx),
                Slots.RANK_OPTION_VISIBILITY, ""style=\""display:none\"""",
                Slots.RANK_TO_RECIPIENTS_VALUE, ""true"",
                Slots.RANK_PARAM_TO_RECIPIENT, Const.ParamsNames.FEEDBACK_QUESTION_RANKTORECIPIENTS,
                Slots.RANK_PARAM_NUM_OPTION, Const.ParamsNames.FEEDBACK_QUESTION_RANKNUMOPTIONS,
                Slots.RANK_NUM_OPTION_VALUE, Integer.toString(0),
                Slots.RANK_PARAM_IS_DUPLICATES_ALLOWED, Const.ParamsNames.FEEDBACK_QUESTION_RANKISDUPLICATESALLOWED,
                Slots.RANK_ARE_DUPLICATES_ALLOWED_VALUE, Boolean.toString(isAreDuplicatesAllowed()));
    }

    private String getSubmissionOptionsHtmlForRankingRecipients(int totalNumRecipients, int rankGiven) {

        StringBuilder result = new StringBuilder(100);

        ElementTag option = PageData.createOption("""", """", rankGiven == Const.INT_UNINITIALIZED);
        result.append(""<option""
                     + option.getAttributesToString() + "">""
                     + option.getContent()
                     + ""</option>"");
        for (int i = 1; i <= totalNumRecipients; i++) {
            option = PageData.createOption(String.valueOf(i), String.valueOf(i), rankGiven == i);
            result.append(""<option""
                        + option.getAttributesToString() + "">""
                        + option.getContent()
                        + ""</option>"");
        }

        return result.toString();
    }

    @Override
    public String getQuestionSpecificEditFormHtml(int questionNumber) {

        return Templates.populateTemplate(
                FormTemplates.RANK_EDIT_RECIPIENTS_FORM,
                Slots.QUESTION_NUMBER, Integer.toString(questionNumber),
                Slots.OPTION_RECIPIENT_DISPLAY_NAME, ""recipient"",
                Slots.RANK_PARAM_IS_DUPLICATES_ALLOWED,
                        Const.ParamsNames.FEEDBACK_QUESTION_RANKISDUPLICATESALLOWED,
                Slots.RANK_ARE_DUPLICATES_ALLOWED_CHECKED, isAreDuplicatesAllowed() ? ""checked"" : """");

    }

    @Override
    public String getNewQuestionSpecificEditFormHtml() {

        return ""<div id=\""rankRecipientsForm\"">""
                + this.getQuestionSpecificEditFormHtml(-1)
                + ""</div>"";
    }

    @Override
    public String getQuestionAdditionalInfoHtml(int questionNumber,
            String additionalInfoId) {
        String additionalInfo = this.getQuestionTypeDisplayName() + ""<br>"";

        return Templates.populateTemplate(
                        FormTemplates.FEEDBACK_QUESTION_ADDITIONAL_INFO,
                        Slots.MORE, ""[more]"",
                        Slots.LESS, ""[less]"",
                        Slots.QUESTION_NUMBER, Integer.toString(questionNumber),
                        Slots.ADDITIONAL_INFO_ID, additionalInfoId,
                        Slots.QUESTION_ADDITIONAL_INFO, additionalInfo);
    }

    @Override
    public String getQuestionResultStatisticsHtml(
                        List<FeedbackResponseAttributes> responses,
                        FeedbackQuestionAttributes question,
                        String studentEmail,
                        FeedbackSessionResultsBundle bundle,
                        String view) {

        if (""student"".equals(view) || responses.isEmpty()) {
            return """";
        }

        StringBuilder fragments = new StringBuilder();

        Map<String, List<Integer>> recipientRanks = generateOptionRanksMapping(responses);

        Map<String, List<Integer>> recipientRanksExcludingSelf = getRecipientRanksExcludingSelf(responses);
        Map<String, Integer> recipientSelfRanks = generateSelfRankForEachRecipient(responses);

        String fragmentTemplateToUse = FormTemplates.RANK_RESULT_STATS_RECIPIENTFRAGMENT;
        String templateToUse = FormTemplates.RANK_RESULT_RECIPIENT_STATS;

        DecimalFormat df = new DecimalFormat(""#.##"");

        for (Entry<String, List<Integer>> entry : recipientRanks.entrySet()) {

            List<Integer> ranks = entry.getValue();
            double average = computeAverage(ranks);
            String ranksReceived = getListOfRanksReceivedAsString(ranks);

            String participantIdentifier = entry.getKey();
            String name = bundle.getNameForEmail(participantIdentifier);
            String teamName = bundle.getTeamNameForEmail(participantIdentifier);
            String userAverageExcludingSelfText =
                    getAverageExcludingSelfText(df, recipientRanksExcludingSelf, entry.getKey());
            String selfRank = recipientSelfRanks.containsKey(participantIdentifier)
                    ? Integer.toString(recipientSelfRanks.get(participantIdentifier)) : ""-"";

            fragments.append(Templates.populateTemplate(fragmentTemplateToUse,
                    Slots.RANK_OPTION_VALUE, SanitizationHelper.sanitizeForHtml(name),
                    Slots.TEAM, SanitizationHelper.sanitizeForHtml(teamName),
                    Slots.RANK_RECIEVED, ranksReceived,
                    Slots.RANK_SELF, selfRank,
                    Slots.RANK_AVERAGE, df.format(average),
                    Slots.RANK_EXCLUDING_SELF_AVERAGE, userAverageExcludingSelfText));

        }

        return Templates.populateTemplate(templateToUse,
                Slots.RANK_OPTION_RECIPIENT_DISPLAY_NAME, ""Recipient"",
                Slots.FRAGMENTS, fragments.toString());

    }

    @Override
    public String getQuestionResultStatisticsCsv(
                        List<FeedbackResponseAttributes> responses,
                        FeedbackQuestionAttributes question,
                        FeedbackSessionResultsBundle bundle) {
        if (responses.isEmpty()) {
            return """";
        }

        StringBuilder fragments = new StringBuilder();
        Map<String, List<Integer>> recipientRanks = generateOptionRanksMapping(responses);

        Map<String, List<Integer>> recipientRanksExcludingSelf = getRecipientRanksExcludingSelf(responses);
        Map<String, Integer> recipientSelfRanks = generateSelfRankForEachRecipient(responses);

        DecimalFormat df = new DecimalFormat(""#.##"");

        for (Entry<String, List<Integer>> entry : recipientRanks.entrySet()) {

            String teamName = bundle.getTeamNameForEmail(entry.getKey());
            String recipientName = bundle.getNameForEmail(entry.getKey());
            String option = SanitizationHelper.sanitizeForCsv(teamName)
                            + "",""
                            + SanitizationHelper.sanitizeForCsv(recipientName);

            String userAverageExcludingSelfText =
                    getAverageExcludingSelfText(df, recipientRanksExcludingSelf, entry.getKey());
            List<Integer> ranks = entry.getValue();
            double average = computeAverage(ranks);
            String selfRank = recipientSelfRanks.containsKey(entry.getKey())
                    ? Integer.toString(recipientSelfRanks.get(entry.getKey())) : ""-"";

            fragments.append(option);
            fragments.append(',').append(selfRank);
            fragments.append(',').append(df.format(average));
            fragments.append(',').append(userAverageExcludingSelfText);
            fragments.append(',');
            fragments.append(StringHelper.join("","", ranks));
            fragments.append(Const.EOL);
        }

        return ""Team, Recipient, Self Rank, Average Rank, Average Rank Excluding Self, Ranks Received"" + Const.EOL
                + fragments + Const.EOL;
    }

    /**
     * From the feedback responses, generate a mapping of the option to a list of
     * ranks received for that option.
     * The key of the map returned is the recipient's participant identifier.
     * The values of the map are list of ranks received by the recipient.
     * @param responses  a list of responses
     */
    private Map<String, List<Integer>> generateOptionRanksMapping(List<FeedbackResponseAttributes> responses) {

        Map<FeedbackResponseAttributes, Integer> normalisedRankOfResponse = getNormalisedRankForEachResponse(responses);

        Map<String, List<Integer>> optionRanks = new HashMap<>();
        for (FeedbackResponseAttributes response : responses) {
            updateOptionRanksMapping(optionRanks, response.recipient, normalisedRankOfResponse.get(response));
        }

        return optionRanks;
    }

    /**
     * Generates a key, value mapping. Each key corresponds to a recipient and its value is the normalised self rank.
     * @param responses  a list of responses
     */
    private Map<String, Integer> generateSelfRankForEachRecipient(List<FeedbackResponseAttributes> responses) {
        Map<FeedbackResponseAttributes, Integer> normalisedRankOfResponse = getNormalisedRankForEachResponse(responses);
        Map<String, Integer> recipientToSelfRank = new HashMap<>();

        for (FeedbackResponseAttributes response : responses) {
            if (response.recipient.equalsIgnoreCase(response.giver)) {
                recipientToSelfRank.put(response.recipient, normalisedRankOfResponse.get(response));
            }
        }

        return recipientToSelfRank;
    }

    /**
     * Returns a map of response to the normalised rank by resolving ties for each giver's set of responses.
     * @see FeedbackRankQuestionDetails#obtainMappingToNormalisedRanksForRanking(Map, List) for how ties are resolved
     */
    private Map<FeedbackResponseAttributes, Integer> getNormalisedRankForEachResponse(
                                                            List<FeedbackResponseAttributes> responses) {

        // collect each giver's responses
        Map<String, List<FeedbackResponseAttributes>> responsesGivenByPerson = new HashMap<>();
        for (FeedbackResponseAttributes response : responses) {
            if (!responsesGivenByPerson.containsKey(response.giver)) {
                responsesGivenByPerson.put(response.giver, new ArrayList<FeedbackResponseAttributes>());
            }

            responsesGivenByPerson.get(response.giver)
                                  .add(response);
        }

        // resolve ties for each giver's responses
        Map<FeedbackResponseAttributes, Integer> normalisedRankOfResponse = new HashMap<>();
        for (Map.Entry<String, List<FeedbackResponseAttributes>> entry : responsesGivenByPerson.entrySet()) {
            Map<FeedbackResponseAttributes, Integer> rankOfResponse = new HashMap<>();
            for (FeedbackResponseAttributes res : responses) {
                FeedbackRankRecipientsResponseDetails frd = (FeedbackRankRecipientsResponseDetails) res.getResponseDetails();
                rankOfResponse.put(res, frd.answer);
            }

            normalisedRankOfResponse.putAll(obtainMappingToNormalisedRanksForRanking(rankOfResponse, entry.getValue()));
        }

        return normalisedRankOfResponse;
    }

    /**
     * Returns list of responses excluding responses given to self.
     *
     * @param responses a list of responses
     * @return list of responses excluding self given responses
     */
    private List<FeedbackResponseAttributes> getResponsesExcludingSelf(List<FeedbackResponseAttributes> responses) {
        List<FeedbackResponseAttributes> responsesExcludingSelf = new ArrayList<>();
        for (FeedbackResponseAttributes response : responses) {
            if (!response.giver.equalsIgnoreCase(response.recipient)) {
                responsesExcludingSelf.add(response);
            }
        }
        return responsesExcludingSelf;
    }

    /**
     * Returns the average excluding self response text.
     * Displays a dash if the user has only self response.
     *
     * @param df decimal format
     * @param recipientRanksExcludingSelf map of recipient ranks excluding self response
     * @param recipientName recipient for which average is to be calculated
     * @return average excluding self text
     */
    private String getAverageExcludingSelfText(DecimalFormat df,
            Map<String, List<Integer>> recipientRanksExcludingSelf, String recipientName) {
        List<Integer> ranksExcludingSelf = recipientRanksExcludingSelf.get(recipientName);
        if (ranksExcludingSelf == null) {
            return ""-"";
        }
        Double averageExcludingSelf = computeAverage(ranksExcludingSelf);
        return df.format(averageExcludingSelf);
    }

    /**
     * Returns map of recipient ranks excluding self.
     *
     * @param responses list of all the responses for a question
     * @return map of recipient ranks excluding self responses
     */
    private Map<String, List<Integer>> getRecipientRanksExcludingSelf(List<FeedbackResponseAttributes> responses) {
        List<FeedbackResponseAttributes> responsesExcludingSelf = getResponsesExcludingSelf(responses);
        return generateOptionRanksMapping(responsesExcludingSelf);
    }

    @Override
    public boolean isChangesRequiresResponseDeletion(FeedbackQuestionDetails newDetails) {
        return false;
    }

    @Override
    public String getCsvHeader() {
        return ""Feedback"";
    }

    @Override
    public String getQuestionTypeChoiceOption() {
        return ""<li data-questiontype = \"""" + FeedbackQuestionType.RANK_RECIPIENTS.name() + ""\""><a href=\""javascript:;\"">""
              + Const.FeedbackQuestionTypeNames.RANK_RECIPIENT + ""</a></li>"";
    }

    @Override
    public List<String> validateQuestionDetails() {
        return new ArrayList<>();
    }

    @Override
    public List<String> validateResponseAttributes(
            List<FeedbackResponseAttributes> responses,
            int numRecipients) {
        if (responses.isEmpty()) {
            return new ArrayList<>();
        }

        if (isAreDuplicatesAllowed()) {
            return new ArrayList<>();
        }
        List<String> errors = new ArrayList<>();

        Set<Integer> responseRank = new HashSet<>();
        for (FeedbackResponseAttributes response : responses) {
            FeedbackRankRecipientsResponseDetails frd =
                    (FeedbackRankRecipientsResponseDetails) response.getResponseDetails();

            if (responseRank.contains(frd.answer)) {
                errors.add(""Duplicate rank "" + frd.answer + "" in question"");
            } else if (frd.answer > numRecipients) {
                errors.add(""Invalid rank "" + frd.answer + "" in question"");
            }
            responseRank.add(frd.answer);
        }

        return errors;
    }

    @Override
    public Comparator<InstructorFeedbackResultsResponseRow> getResponseRowsSortOrder() {
        return new Comparator<InstructorFeedbackResultsResponseRow>() {

            @Override
            public int compare(InstructorFeedbackResultsResponseRow o1,
                               InstructorFeedbackResultsResponseRow o2) {

                if (!o1.getGiverTeam().equals(o2.getGiverTeam())) {
                    return o1.getGiverTeam().compareTo(o2.getGiverTeam());
                }

                if (!o1.getGiverDisplayableIdentifier().equals(o2.getGiverDisplayableIdentifier())) {
                    return o1.getGiverDisplayableIdentifier().compareTo(o2.getGiverDisplayableIdentifier());
                }

                if (!o1.getDisplayableResponse().equals(o2.getDisplayableResponse())) {
                    return o1.getDisplayableResponse().compareTo(o2.getDisplayableResponse());
                }

                if (!o1.getRecipientTeam().equals(o2.getRecipientTeam())) {
                    return o1.getRecipientTeam().compareTo(o2.getRecipientTeam());
                }

                return o1.getRecipientDisplayableIdentifier().compareTo(o2.getRecipientDisplayableIdentifier());
            }

        };
    }

    @Override
    public String validateGiverRecipientVisibility(FeedbackQuestionAttributes feedbackQuestionAttributes) {
        return """";
    }
}
"
FeedbackRankRecipientsResponseDetails.java,data-transfer,"package teammates.common.datatransfer.questions;

public class FeedbackRankRecipientsResponseDetails extends FeedbackRankResponseDetails {
    public int answer;

    public FeedbackRankRecipientsResponseDetails() {
        super(FeedbackQuestionType.RANK_RECIPIENTS);
    }

    @Override
    public void extractResponseDetails(FeedbackQuestionType questionType,
                                       FeedbackQuestionDetails questionDetails,
                                       String[] answer) {
        this.setRankResponseDetails(Integer.parseInt(answer[0]));
    }

    @Override
    public String getAnswerString() {
        return Integer.toString(answer);
    }

    @Override
    public String getAnswerHtmlInstructorView(FeedbackQuestionDetails questionDetails) {
        return getAnswerString();
    }

    @Override
    public String getAnswerCsv(FeedbackQuestionDetails questionDetails) {
        StringBuilder csvBuilder = new StringBuilder();

        csvBuilder.append(answer);

        return csvBuilder.toString();
    }

    private void setRankResponseDetails(int answer) {
        this.answer = answer;
    }

}
"
FeedbackRankResponseDetails.java,data-transfer,"package teammates.common.datatransfer.questions;

public abstract class FeedbackRankResponseDetails extends FeedbackResponseDetails {
    public FeedbackRankResponseDetails(FeedbackQuestionType questionType) {
        super(questionType);
    }
}
"
FeedbackResponseDetails.java,data-transfer,"package teammates.common.datatransfer.questions;

import java.util.Map;

import teammates.common.datatransfer.FeedbackSessionResultsBundle;
import teammates.common.datatransfer.attributes.FeedbackQuestionAttributes;
import teammates.common.datatransfer.attributes.FeedbackResponseAttributes;

/** A class holding the details for the response of a specific question type.
 * This abstract class is inherited by concrete Feedback*ResponseDetails
 * classes which provides the implementation for the various abstract methods
 * such that pages can render the correct information depending on the
 * question type.
 */
public abstract class FeedbackResponseDetails {
    public FeedbackQuestionType questionType;

    public FeedbackResponseDetails(FeedbackQuestionType questionType) {
        this.questionType = questionType;
    }

    /**
     * Extract response details and sets details accordingly.
     */
    public abstract void extractResponseDetails(
            FeedbackQuestionType questionType,
            FeedbackQuestionDetails questionDetails,
            String[] answer);

    public abstract String getAnswerString();

    public abstract String getAnswerHtmlInstructorView(FeedbackQuestionDetails questionDetails);

    public String getAnswerHtmlStudentView(FeedbackQuestionDetails questionDetails) {
        return getAnswerHtmlInstructorView(questionDetails);
    }

    public abstract String getAnswerCsv(FeedbackQuestionDetails questionDetails);

    /**
     * getAnswerHtml with an additional parameter (FeedbackSessionResultsBundle)
     *
     * <p>default action is to call getAnswerHtml(FeedbackQuestionDetails questionDetails).
     * override in child class if necessary.
     */
    public String getAnswerHtml(FeedbackResponseAttributes response, FeedbackQuestionAttributes question,
                                FeedbackSessionResultsBundle feedbackSessionResultsBundle) {
        return getAnswerHtmlInstructorView(question.getQuestionDetails());
    }

    /**
     * getAnswerCsv with an additional parameter (FeedbackSessionResultsBundle)
     *
     * <p>default action is to call getAnswerCsv(FeedbackQuestionDetails questionDetails).
     * override in child class if necessary.
     */
    public String getAnswerCsv(FeedbackResponseAttributes response, FeedbackQuestionAttributes question,
                                    FeedbackSessionResultsBundle feedbackSessionResultsBundle) {
        return getAnswerCsv(question.getQuestionDetails());
    }

    public static FeedbackResponseDetails createResponseDetails(
            String[] answer, FeedbackQuestionType questionType,
            FeedbackQuestionDetails questionDetails,
            Map<String, String[]> requestParameters, int questionIndx, int responseIndx) {

        return questionType.getFeedbackResponseDetailsInstance(questionDetails, answer, requestParameters,
                                                               questionIndx, responseIndx);
    }
}
"
FeedbackRubricQuestionDetails.java,data-transfer,"package teammates.common.datatransfer.questions;

import java.text.DecimalFormat;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.Map;

import teammates.common.datatransfer.FeedbackParticipantType;
import teammates.common.datatransfer.FeedbackSessionResultsBundle;
import teammates.common.datatransfer.attributes.FeedbackQuestionAttributes;
import teammates.common.datatransfer.attributes.FeedbackResponseAttributes;
import teammates.common.util.Assumption;
import teammates.common.util.Const;
import teammates.common.util.HttpRequestHelper;
import teammates.common.util.Logger;
import teammates.common.util.SanitizationHelper;
import teammates.common.util.StringHelper;
import teammates.common.util.Templates;
import teammates.common.util.Templates.FeedbackQuestion.FormTemplates;
import teammates.common.util.Templates.FeedbackQuestion.Slots;
import teammates.ui.template.InstructorFeedbackResultsResponseRow;

public class FeedbackRubricQuestionDetails extends FeedbackQuestionDetails {

    private static final Logger log = Logger.getLogger();
    private static final String STATISTICS_NO_VALUE_STRING = ""-"";

    private boolean hasAssignedWeights;
    private List<Double> rubricWeights;
    private int numOfRubricChoices;
    private List<String> rubricChoices;
    private int numOfRubricSubQuestions;
    private List<String> rubricSubQuestions;
    private List<List<String>> rubricDescriptions;

    public FeedbackRubricQuestionDetails() {
        super(FeedbackQuestionType.RUBRIC);

        this.hasAssignedWeights = false;
        this.rubricWeights = new ArrayList<>();
        this.numOfRubricChoices = 0;
        this.rubricChoices = new ArrayList<>();
        this.numOfRubricSubQuestions = 0;
        this.rubricSubQuestions = new ArrayList<>();
        this.initializeRubricDescriptions();
    }

    public FeedbackRubricQuestionDetails(String questionText) {
        super(FeedbackQuestionType.RUBRIC, questionText);

        this.hasAssignedWeights = false;
        this.rubricWeights = new ArrayList<>();
        this.numOfRubricChoices = 0;
        this.rubricChoices = new ArrayList<>();
        this.numOfRubricSubQuestions = 0;
        this.rubricSubQuestions = new ArrayList<>();
        this.initializeRubricDescriptions();
    }

    @Override
    public boolean extractQuestionDetails(
            Map<String, String[]> requestParameters,
            FeedbackQuestionType questionType) {
        String numOfRubricChoicesString = HttpRequestHelper.getValueFromParamMap(requestParameters,
                                                                Const.ParamsNames.FEEDBACK_QUESTION_RUBRIC_NUM_COLS);
        String numOfRubricSubQuestionsString = HttpRequestHelper.getValueFromParamMap(requestParameters,
                                                                     Const.ParamsNames.FEEDBACK_QUESTION_RUBRIC_NUM_ROWS);

        if (numOfRubricChoicesString == null || numOfRubricSubQuestionsString == null) {
            return false;
        }

        String hasAssignedWeightsString = HttpRequestHelper.getValueFromParamMap(requestParameters,
                                                                Const.ParamsNames.FEEDBACK_QUESTION_RUBRIC_WEIGHTS_ASSIGNED);

        boolean hasAssignedWeights = ""on"".equals(hasAssignedWeightsString);
        int numOfRubricChoices = Integer.parseInt(numOfRubricChoicesString);
        int numOfRubricSubQuestions = Integer.parseInt(numOfRubricSubQuestionsString);
        List<Double> rubricWeights = getRubricWeights(requestParameters, numOfRubricChoices, hasAssignedWeights);
        List<String> rubricChoices = getRubricChoices(requestParameters, numOfRubricChoices);
        List<String> rubricSubQuestions = getSubQuestions(requestParameters, numOfRubricSubQuestions);
        List<List<String>> rubricDescriptions = getRubricQuestionDescriptions(requestParameters,
                                                                              numOfRubricChoices,
                                                                              numOfRubricSubQuestions);

        // Set details
        setRubricQuestionDetails(hasAssignedWeights, rubricWeights, rubricChoices, rubricSubQuestions, rubricDescriptions);

        if (!isValidDescriptionSize()) {
            // If description sizes are invalid, default to empty descriptions.
            initializeRubricDescriptions();
        }

        return true;
    }

    private List<Double> getRubricWeights(Map<String, String[]> requestParameters, int numOfRubricChoices,
                                         boolean hasAssignedWeights) {
        List<Double> rubricWeights = new ArrayList<>();

        if (!hasAssignedWeights) {
            return rubricWeights;
        }

        for (int i = 0; i < numOfRubricChoices; i++) {

            String weight = HttpRequestHelper.getValueFromParamMap(
                    requestParameters, Const.ParamsNames.FEEDBACK_QUESTION_RUBRIC_WEIGHT + ""-"" + i);
            String choice = HttpRequestHelper.getValueFromParamMap(
                    requestParameters, Const.ParamsNames.FEEDBACK_QUESTION_RUBRIC_CHOICE + ""-"" + i);

            if (choice == null) {
                continue;
            }

            try {
                rubricWeights.add(Double.parseDouble(weight));
            } catch (NumberFormatException e) {
                // Do not add weight to rubricWeights if the weight cannot be parsed
                log.warning(""Failed to parse weight for rubric question: "" + weight);
            }
        }

        return rubricWeights;
    }

    private List<String> getRubricChoices(Map<String, String[]> requestParameters, int numOfRubricChoices) {
        List<String> rubricChoices = new ArrayList<>();
        for (int i = 0; i < numOfRubricChoices; i++) {
            String choice = HttpRequestHelper.getValueFromParamMap(requestParameters,
                                                  Const.ParamsNames.FEEDBACK_QUESTION_RUBRIC_CHOICE + ""-"" + i);
            if (choice != null) {
                rubricChoices.add(choice);
            }
        }
        return rubricChoices;
    }

    private List<String> getSubQuestions(Map<String, String[]> requestParameters, int numOfRubricSubQuestions) {
        List<String> rubricSubQuestions = new ArrayList<>();
        for (int i = 0; i < numOfRubricSubQuestions; i++) {
            String subQuestion = HttpRequestHelper.getValueFromParamMap(requestParameters,
                                                       Const.ParamsNames.FEEDBACK_QUESTION_RUBRIC_SUBQUESTION + ""-"" + i);
            if (subQuestion != null) {
                rubricSubQuestions.add(subQuestion);
            }
        }
        return rubricSubQuestions;
    }

    private List<List<String>> getRubricQuestionDescriptions(Map<String, String[]> requestParameters,
                                                             int numOfRubricChoices, int numOfRubricSubQuestions) {
        List<List<String>> rubricDescriptions = new ArrayList<>();
        int descRows = -1;
        for (int i = 0; i < numOfRubricSubQuestions; i++) {
            boolean rowAdded = false;
            for (int j = 0; j < numOfRubricChoices; j++) {
                String paramName = Const.ParamsNames.FEEDBACK_QUESTION_RUBRIC_DESCRIPTION + ""-"" + i + ""-"" + j;
                String description = HttpRequestHelper.getValueFromParamMap(requestParameters, paramName);
                if (description != null) {
                    if (!rowAdded) {
                        descRows++;
                        rubricDescriptions.add(new ArrayList<String>());
                        rowAdded = true;
                    }
                    rubricDescriptions.get(descRows).add(description);
                }
            }
        }
        return rubricDescriptions;
    }

    /**
     * Checks if the dimensions of rubricDescription is valid according
     * to numOfRubricSubQuestions and numOfRubricChoices.
     */
    private boolean isValidDescriptionSize() {
        if (rubricDescriptions.size() != numOfRubricSubQuestions) {
            return false;
        }
        for (int i = 0; i < rubricDescriptions.size(); i++) {
            if (rubricDescriptions.get(i).size() != numOfRubricChoices) {
                return false;
            }
        }
        return true;
    }

    private void setRubricQuestionDetails(boolean hasAssignedWeights,
                                          List<Double> rubricWeights,
                                          List<String> rubricChoices,
                                          List<String> rubricSubQuestions,
                                          List<List<String>> rubricDescriptions) {
        this.hasAssignedWeights = hasAssignedWeights;
        this.rubricWeights = rubricWeights;
        this.numOfRubricChoices = rubricChoices.size();
        this.rubricChoices = rubricChoices;
        this.numOfRubricSubQuestions = rubricSubQuestions.size();
        this.rubricSubQuestions = rubricSubQuestions;
        this.rubricDescriptions = rubricDescriptions;
    }

    @Override
    public String getQuestionTypeDisplayName() {
        return Const.FeedbackQuestionTypeNames.RUBRIC;
    }

    @Override
    public boolean isChangesRequiresResponseDeletion(FeedbackQuestionDetails newDetails) {
        FeedbackRubricQuestionDetails newRubricDetails = (FeedbackRubricQuestionDetails) newDetails;
        // TODO: need to check for exact match.

        // Responses require deletion if choices change
        if (!this.rubricChoices.equals(newRubricDetails.rubricChoices)) {
            return true;
        }

        // Responses require deletion if sub-questions change
        return this.numOfRubricSubQuestions != newRubricDetails.numOfRubricSubQuestions
            || !this.rubricSubQuestions.containsAll(newRubricDetails.rubricSubQuestions)
            || !newRubricDetails.rubricSubQuestions.containsAll(this.rubricSubQuestions);
    }

    @Override
    public String getQuestionWithExistingResponseSubmissionFormHtml(boolean sessionIsOpen, int qnIdx,
            int responseIdx, String courseId, int totalNumRecipients, FeedbackResponseDetails existingResponseDetails) {
        FeedbackRubricResponseDetails frd = (FeedbackRubricResponseDetails) existingResponseDetails;

        String questionNumberString = Integer.toString(qnIdx);
        String responseNumberString = Integer.toString(responseIdx);

        String tableHeaderFragmentHtml =
                getSubmissionFormTableHeaderFragmentHtml(questionNumberString, responseNumberString);
        String tableBodyHtml =
                getSubmissionFormTableBodyHtml(questionNumberString, responseNumberString, sessionIsOpen, true, frd);
        String mobileHtml = getSubmissionFormMobileHtml(questionNumberString, responseNumberString,
                                                        sessionIsOpen, true, frd);

        // Create submission form
        return Templates.populateTemplate(
                FormTemplates.RUBRIC_SUBMISSION_FORM,
                Slots.QUESTION_INDEX, questionNumberString,
                Slots.RESPONSE_INDEX, responseNumberString,
                Slots.CURRENT_ROWS, Integer.toString(this.numOfRubricSubQuestions),
                Slots.CURRENT_COLS, Integer.toString(this.numOfRubricChoices),
                Slots.TABLE_HEADER_ROW_FRAGMENT_HTML, tableHeaderFragmentHtml,
                Slots.TABLE_BODY_HTML, tableBodyHtml,
                Slots.MOBILE_HTML, mobileHtml,
                Slots.FEEDBACK_RESPONSE_TEXT, Const.ParamsNames.FEEDBACK_RESPONSE_TEXT);
    }

    @Override
    public String getQuestionWithoutExistingResponseSubmissionFormHtml(
            boolean sessionIsOpen, int qnIdx, int responseIdx, String courseId, int totalNumRecipients) {

        String questionNumberString = Integer.toString(qnIdx);
        String responseNumberString = Integer.toString(responseIdx);

        String tableHeaderFragmentHtml =
                getSubmissionFormTableHeaderFragmentHtml(questionNumberString, responseNumberString);
        String tableBodyHtml =
                getSubmissionFormTableBodyHtml(questionNumberString, responseNumberString, sessionIsOpen, false, null);
        String mobileHtml = getSubmissionFormMobileHtml(questionNumberString, responseNumberString,
                                                        sessionIsOpen, false, null);

        // Create submission form
        return Templates.populateTemplate(
                FormTemplates.RUBRIC_SUBMISSION_FORM,
                Slots.QUESTION_INDEX, questionNumberString,
                Slots.RESPONSE_INDEX, responseNumberString,
                Slots.CURRENT_ROWS, Integer.toString(this.numOfRubricSubQuestions),
                Slots.CURRENT_COLS, Integer.toString(this.numOfRubricChoices),
                Slots.TABLE_HEADER_ROW_FRAGMENT_HTML, tableHeaderFragmentHtml,
                Slots.TABLE_BODY_HTML, tableBodyHtml,
                Slots.MOBILE_HTML, mobileHtml,
                Slots.FEEDBACK_RESPONSE_TEXT, Const.ParamsNames.FEEDBACK_RESPONSE_TEXT);
    }

    private String getSubmissionFormTableHeaderFragmentHtml(String questionNumberString, String responseNumberString) {
        StringBuilder tableHeaderFragmentHtml = new StringBuilder();
        String tableHeaderFragmentTemplate = FormTemplates.RUBRIC_SUBMISSION_FORM_HEADER_FRAGMENT;

        for (int i = 0; i < numOfRubricChoices; i++) {
            String tableHeaderCell =
                    Templates.populateTemplate(tableHeaderFragmentTemplate,
                            Slots.QUESTION_INDEX, questionNumberString,
                            Slots.RESPONSE_INDEX, responseNumberString,
                            Slots.COL, Integer.toString(i),
                            Slots.RUBRIC_CHOICE_VALUE, SanitizationHelper.sanitizeForHtml(rubricChoices.get(i)));
            // TODO display numerical value of option
            tableHeaderFragmentHtml.append(tableHeaderCell).append(Const.EOL);
        }
        return tableHeaderFragmentHtml.toString();
    }

    private String getSubmissionFormTableBodyHtml(String questionNumberString, String responseNumberString,
                                                  boolean sessionIsOpen, boolean isExistingResponse,
                                                  FeedbackRubricResponseDetails frd) {
        StringBuilder tableBodyHtml = new StringBuilder();
        String tableBodyFragmentTemplate = FormTemplates.RUBRIC_SUBMISSION_FORM_BODY_FRAGMENT;
        String tableBodyTemplate = FormTemplates.RUBRIC_SUBMISSION_FORM_BODY;

        for (int i = 0; i < numOfRubricSubQuestions; i++) {
            StringBuilder tableBodyFragmentHtml = new StringBuilder();
            for (int j = 0; j < numOfRubricChoices; j++) {
                String tableBodyCell =
                        Templates.populateTemplate(tableBodyFragmentTemplate,
                                Slots.QUESTION_INDEX, questionNumberString,
                                Slots.RESPONSE_INDEX, responseNumberString,
                                Slots.COL, Integer.toString(j),
                                Slots.ROW, Integer.toString(i),
                                Slots.DISABLED, sessionIsOpen ? """" : ""disabled"",
                                Slots.DESCRIPTION, SanitizationHelper.sanitizeForHtml(this.getDescription(i, j)),
                                // Check if existing choice for sub-question == current choice
                                Slots.CHECKED, isExistingResponse && frd.getAnswer(i) == j ? ""checked"" : """",
                                Slots.RUBRIC_PARAM_CHOICE, Const.ParamsNames.FEEDBACK_QUESTION_RUBRIC_CHOICE);
                tableBodyFragmentHtml.append(tableBodyCell).append(Const.EOL);
            }
            // Get entire row
            String tableRow =
                    Templates.populateTemplate(tableBodyTemplate,
                            Slots.QUESTION_INDEX, questionNumberString,
                            Slots.RESPONSE_INDEX, responseNumberString,
                            Slots.ROW, Integer.toString(i),
                            Slots.SUB_QUESTION, StringHelper.integerToLowerCaseAlphabeticalIndex(i + 1) + "") ""
                                              + SanitizationHelper.sanitizeForHtml(rubricSubQuestions.get(i)),
                            Slots.RUBRIC_ROW_BODY_FRAGMENTS, tableBodyFragmentHtml.toString());
            tableBodyHtml.append(tableRow).append(Const.EOL);
        }
        return tableBodyHtml.toString();
    }

    private String getSubmissionFormMobileHtml(String questionNumberString, String responseNumberString,
            boolean sessionIsOpen, boolean isExistingResponse, FeedbackRubricResponseDetails frd) {
        StringBuilder mobileHtml = new StringBuilder();
        String mobilePanelTemplate = FormTemplates.RUBRIC_SUBMISSION_FORM_MOBILE_PANEL;
        String mobilePanelFragmentTemplate = FormTemplates.RUBRIC_SUBMISSION_FORM_MOBILE_PANEL_FRAGMENT;

        for (int i = 0; i < numOfRubricSubQuestions; i++) {
            StringBuilder panelBody = new StringBuilder();
            for (int j = 0; j < numOfRubricChoices; j++) {
                String panelBodyFragment = Templates.populateTemplate(mobilePanelFragmentTemplate,
                        Slots.QUESTION_INDEX, questionNumberString,
                        Slots.RESPONSE_INDEX, responseNumberString,
                        Slots.COL, Integer.toString(j),
                        Slots.ROW, Integer.toString(i),
                        Slots.DISABLED, sessionIsOpen ? """" : ""disabled"",
                        Slots.DESCRIPTION, SanitizationHelper.sanitizeForHtml(this.getDescription(i, j)),
                        // Check if existing choice for sub-question == current choice
                        Slots.CHECKED, isExistingResponse && frd.getAnswer(i) == j ? ""checked"" : """",
                        Slots.RUBRIC_CHOICE_VALUE, SanitizationHelper.sanitizeForHtml(rubricChoices.get(j)),
                        Slots.RUBRIC_PARAM_CHOICE, Const.ParamsNames.FEEDBACK_QUESTION_RUBRIC_CHOICE);
                panelBody.append(panelBodyFragment);
            }
            String panel = Templates.populateTemplate(mobilePanelTemplate,
                    Slots.PANEL_BODY, panelBody.toString(),
                    Slots.SUB_QUESTION, StringHelper.integerToLowerCaseAlphabeticalIndex(i + 1) + "") ""
                            + SanitizationHelper.sanitizeForHtml(rubricSubQuestions.get(i)));
            mobileHtml.append(panel).append(Const.EOL);
        }
        return mobileHtml.toString();
    }

    @Override
    public String getQuestionSpecificEditFormHtml(int questionNumber) {
        String questionNumberString = Integer.toString(questionNumber);
        DecimalFormat weightFormat = new DecimalFormat(""#.##"");

        // Create table row header fragments
        StringBuilder tableHeaderFragmentHtml = new StringBuilder();
        String tableHeaderFragmentTemplate = FormTemplates.RUBRIC_EDIT_FORM_HEADER_FRAGMENT;
        for (int i = 0; i < numOfRubricChoices; i++) {
            String tableHeaderCell =
                    Templates.populateTemplate(tableHeaderFragmentTemplate,
                            Slots.QUESTION_INDEX, questionNumberString,
                            Slots.COL, Integer.toString(i),
                            Slots.RUBRIC_CHOICE_VALUE, SanitizationHelper.sanitizeForHtml(rubricChoices.get(i)),
                            Slots.RUBRIC_PARAM_CHOICE, Const.ParamsNames.FEEDBACK_QUESTION_RUBRIC_CHOICE);
            tableHeaderFragmentHtml.append(tableHeaderCell).append(Const.EOL);
        }

        // Create rubric weights row
        StringBuilder tableWeightFragmentHtml = new StringBuilder();
        String tableWeightFragmentTemplate = FormTemplates.RUBRIC_EDIT_FORM_WEIGHT_FRAGMENT;
        for (int i = 0; i < numOfRubricChoices; i++) {
            String tableWeightCell =
                    Templates.populateTemplate(tableWeightFragmentTemplate,
                            Slots.QUESTION_INDEX, questionNumberString,
                            Slots.COL, Integer.toString(i),
                            Slots.RUBRIC_WEIGHT, hasAssignedWeights ? weightFormat.format(rubricWeights.get(i)) : ""0"",
                            Slots.RUBRIC_PARAM_WEIGHT, Const.ParamsNames.FEEDBACK_QUESTION_RUBRIC_WEIGHT);
            tableWeightFragmentHtml.append(tableWeightCell).append(Const.EOL);
        }

        // Create table body
        StringBuilder tableBodyHtml = new StringBuilder();

        String tableBodyFragmentTemplate = FormTemplates.RUBRIC_EDIT_FORM_BODY_FRAGMENT;
        String tableBodyTemplate = FormTemplates.RUBRIC_EDIT_FORM_BODY;

        for (int j = 0; j < numOfRubricSubQuestions; j++) {
            StringBuilder tableBodyFragmentHtml = new StringBuilder();
            for (int i = 0; i < numOfRubricChoices; i++) {
                String tableBodyCell =
                        Templates.populateTemplate(tableBodyFragmentTemplate,
                                Slots.QUESTION_INDEX, questionNumberString,
                                Slots.COL, Integer.toString(i),
                                Slots.ROW, Integer.toString(j),
                                Slots.DESCRIPTION, SanitizationHelper.sanitizeForHtml(this.getDescription(j, i)),
                                Slots.RUBRIC_PARAM_DESCRIPTION, Const.ParamsNames.FEEDBACK_QUESTION_RUBRIC_DESCRIPTION);
                tableBodyFragmentHtml.append(tableBodyCell).append(Const.EOL);
            }

            // Get entire row
            String tableRow =
                    Templates.populateTemplate(tableBodyTemplate,
                            Slots.QUESTION_INDEX, questionNumberString,
                            Slots.ROW, Integer.toString(j),
                            Slots.SUB_QUESTION, SanitizationHelper.sanitizeForHtml(rubricSubQuestions.get(j)),
                            Slots.RUBRIC_ROW_BODY_FRAGMENTS, tableBodyFragmentHtml.toString(),
                            Slots.RUBRIC_PARAM_SUB_QUESTION, Const.ParamsNames.FEEDBACK_QUESTION_RUBRIC_SUBQUESTION);
            tableBodyHtml.append(tableRow).append(Const.EOL);
        }

        // Create rubric column options as the last row of the table
        StringBuilder rubricColumnOptionsFragments = new StringBuilder();
        String tableOptionsTemplate = FormTemplates.RUBRIC_EDIT_FORM_TABLE_OPTIONS;
        String tableOptionsFragmentTemplate = FormTemplates.RUBRIC_EDIT_FORM_TABLE_OPTIONS_FRAGMENT;

        for (int i = 0; i < numOfRubricChoices; i++) {
            String tableBodyCell = Templates.populateTemplate(tableOptionsFragmentTemplate,
                    Slots.QUESTION_INDEX, questionNumberString,
                    Slots.COL, Integer.toString(i));
            rubricColumnOptionsFragments.append(tableBodyCell).append(Const.EOL);
        }

        String tableOptions = Templates.populateTemplate(tableOptionsTemplate,
                Slots.RUBRIC_TABLE_OPTIONS_FRAGMENT, rubricColumnOptionsFragments.toString());

        StringBuilder tableOptionsHtml = new StringBuilder().append(tableOptions).append(Const.EOL);

        // Create edit form
        return Templates.populateTemplate(
                FormTemplates.RUBRIC_EDIT_FORM,
                Slots.QUESTION_INDEX, questionNumberString,
                Slots.CURRENT_ROWS, Integer.toString(this.numOfRubricSubQuestions),
                Slots.CURRENT_COLS, Integer.toString(this.numOfRubricChoices),
                Slots.TABLE_HEADER_ROW_FRAGMENT_HTML, tableHeaderFragmentHtml.toString(),
                Slots.RUBRIC_TABLE_WEIGHT_ROW_FRAGMENT_HTML, tableWeightFragmentHtml.toString(),
                Slots.TABLE_BODY_HTML, tableBodyHtml.toString(),
                Slots.RUBRIC_PARAM_NUM_ROWS, Const.ParamsNames.FEEDBACK_QUESTION_RUBRIC_NUM_ROWS,
                Slots.RUBRIC_PARAM_NUM_COLS, Const.ParamsNames.FEEDBACK_QUESTION_RUBRIC_NUM_COLS,
                Slots.CHECK_ASSIGN_WEIGHTS, hasAssignedWeights ? ""checked"" : """",
                Slots.RUBRIC_TOOLTIPS_ASSIGN_WEIGHTS, Const.Tooltips.FEEDBACK_QUESTION_RUBRIC_ASSIGN_WEIGHTS,
                Slots.RUBRIC_PARAM_ASSIGN_WEIGHTS, Const.ParamsNames.FEEDBACK_QUESTION_RUBRIC_WEIGHTS_ASSIGNED,
                Slots.RUBRIC_TABLE_OPTIONS, tableOptionsHtml.toString());
    }

    @Override
    public String getNewQuestionSpecificEditFormHtml() {
        // Add some choices by default
        numOfRubricChoices = 4;
        rubricChoices.add(""Strongly Disagree"");
        rubricChoices.add(""Disagree"");
        rubricChoices.add(""Agree"");
        rubricChoices.add(""Strongly Agree"");

        hasAssignedWeights = false;

        // Add some sub-questions by default
        numOfRubricSubQuestions = 2;
        rubricSubQuestions.add(""This student participates well in online discussions."");
        rubricSubQuestions.add(""This student completes assigned tasks on time."");

        initializeRubricDescriptions();

        setDescription(0, 0, ""Rarely or never responds."");
        setDescription(0, 1, ""Occasionally responds, but never initiates discussions."");
        setDescription(0, 2, ""Takes part in discussions and sometimes initiates discussions."");
        setDescription(0, 3, ""Initiates discussions frequently, and engages the team."");

        setDescription(1, 0, ""Rarely or never completes tasks."");
        setDescription(1, 1, ""Often misses deadlines."");
        setDescription(1, 2, ""Occasionally misses deadlines."");
        setDescription(1, 3, ""Tasks are always completed before the deadline."");

        return ""<div id=\""rubricForm\"">""
                  + getQuestionSpecificEditFormHtml(-1)
             + ""</div>"";
    }

    private void initializeRubricDescriptions() {
        rubricDescriptions = new ArrayList<>();
        for (int subQns = 0; subQns < numOfRubricSubQuestions; subQns++) {
            List<String> descList = new ArrayList<>();
            for (int ch = 0; ch < numOfRubricChoices; ch++) {
                descList.add("""");
            }
            rubricDescriptions.add(descList);
        }
    }

    private void setDescription(int row, int col, String description) {
        this.rubricDescriptions.get(row).set(col, description);
    }

    /**
     * Gets the description for given sub-question and choice.
     */
    private String getDescription(int subQuestion, int choice) {
        return rubricDescriptions.get(subQuestion).get(choice);
    }

    @Override
    public String getQuestionAdditionalInfoHtml(int questionNumber, String additionalInfoId) {
        StringBuilder subQuestionListHtml = new StringBuilder();

        if (numOfRubricSubQuestions > 0) {
            subQuestionListHtml.append(""<p>"");
            for (int i = 0; i < numOfRubricSubQuestions; i++) {
                String subQuestionFragment =
                        StringHelper.integerToLowerCaseAlphabeticalIndex(i + 1)
                        + "") "" + SanitizationHelper.sanitizeForHtml(rubricSubQuestions.get(i));
                subQuestionListHtml.append(subQuestionFragment);
                subQuestionListHtml.append(""<br>"");
            }
            subQuestionListHtml.append(""</p>"");
        }

        String additionalInfo = Templates.populateTemplate(
                FormTemplates.RUBRIC_ADDITIONAL_INFO,
                Slots.QUESTION_TYPE_NAME, this.getQuestionTypeDisplayName(),
                Slots.RUBRIC_ADDITIONAL_INFO_FRAGMENTS, subQuestionListHtml.toString());

        return Templates.populateTemplate(
                FormTemplates.FEEDBACK_QUESTION_ADDITIONAL_INFO,
                Slots.MORE, ""[more]"",
                Slots.LESS, ""[less]"",
                Slots.QUESTION_NUMBER, Integer.toString(questionNumber),
                Slots.ADDITIONAL_INFO_ID, additionalInfoId,
                Slots.QUESTION_ADDITIONAL_INFO, additionalInfo);
    }

    @Override
    public String getQuestionResultStatisticsHtml(List<FeedbackResponseAttributes> responses,
                                                  FeedbackQuestionAttributes question, String studentEmail,
                                                  FeedbackSessionResultsBundle bundle, String view) {

        List<FeedbackResponseAttributes> responsesForStatistics =
                filterResponsesForStatistics(responses, question, studentEmail, bundle, view);

        FeedbackRubricQuestionDetails fqd =
                (FeedbackRubricQuestionDetails) question.getQuestionDetails();

        RubricStatistics statistics = new RubricStatistics(responsesForStatistics, fqd);
        int[][] responseFrequency = statistics.getResponseFrequency();
        float[][] rubricStats = statistics.getPercentageFrequencyAndAverage();

        DecimalFormat weightFormat = new DecimalFormat(""#.##"");

        // Create table row header fragments
        StringBuilder tableHeaderFragmentHtml = new StringBuilder();
        String tableHeaderFragmentTemplate = FormTemplates.RUBRIC_RESULT_STATS_HEADER_FRAGMENT;
        for (int i = 0; i < numOfRubricChoices; i++) {

            String header = SanitizationHelper.sanitizeForHtml(rubricChoices.get(i))
                          + (fqd.hasAssignedWeights
                            ? ""<span style=\""font-weight:normal;\""> (Weight: ""
                              + weightFormat.format(rubricWeights.get(i)) + "")</span>""
                            : """");

            String tableHeaderCell =
                    Templates.populateTemplate(tableHeaderFragmentTemplate, Slots.RUBRIC_CHOICE_VALUE, header);
            tableHeaderFragmentHtml.append(tableHeaderCell).append(Const.EOL);
        }

        if (fqd.hasAssignedWeights) {
            String tableHeaderAverageCell =
                    Templates.populateTemplate(tableHeaderFragmentTemplate,
                            Slots.RUBRIC_CHOICE_VALUE, ""Average"");
            tableHeaderFragmentHtml.append(tableHeaderAverageCell).append(Const.EOL);
        }

        // Create table body
        StringBuilder tableBodyHtml = new StringBuilder();

        String tableBodyFragmentTemplate = FormTemplates.RUBRIC_RESULT_STATS_BODY_FRAGMENT;
        String tableBodyTemplate = FormTemplates.RUBRIC_RESULT_STATS_BODY;
        DecimalFormat df = new DecimalFormat(""#"");
        DecimalFormat dfAverage = new DecimalFormat(""0.00"");

        for (int i = 0; i < numOfRubricSubQuestions; i++) {
            StringBuilder tableBodyFragmentHtml = new StringBuilder();
            boolean isSubQuestionRespondedTo = responseFrequency[i][numOfRubricChoices] > 0;

            for (int j = 0; j < numOfRubricChoices; j++) {
                String percentageFrequencyString = isSubQuestionRespondedTo
                                                 ? df.format(rubricStats[i][j] * 100) + ""%""
                                                 : STATISTICS_NO_VALUE_STRING;
                String tableBodyCell = Templates.populateTemplate(tableBodyFragmentTemplate,
                        Slots.RUBRIC_PERCENTAGE_FREQUENCY_OR_AVERAGE,
                        percentageFrequencyString + "" ("" + responseFrequency[i][j] + "")"");
                tableBodyFragmentHtml.append(tableBodyCell).append(Const.EOL);
            }

            if (fqd.hasAssignedWeights) {
                String averageString = isSubQuestionRespondedTo
                                     ? dfAverage.format(rubricStats[i][numOfRubricChoices])
                                     : STATISTICS_NO_VALUE_STRING;
                String tableBodyAverageCell = Templates.populateTemplate(tableBodyFragmentTemplate,
                        Slots.RUBRIC_PERCENTAGE_FREQUENCY_OR_AVERAGE, averageString);
                tableBodyFragmentHtml.append(tableBodyAverageCell).append(Const.EOL);
            }

            // Get entire row
            String tableRow = Templates.populateTemplate(tableBodyTemplate,
                    Slots.SUB_QUESTION, StringHelper.integerToLowerCaseAlphabeticalIndex(i + 1) + "") ""
                            + SanitizationHelper.sanitizeForHtml(rubricSubQuestions.get(i)),
                    Slots.RUBRIC_ROW_BODY_FRAGMENTS, tableBodyFragmentHtml.toString());
            tableBodyHtml.append(tableRow).append(Const.EOL);
        }

        String statsTitle = ""Response Summary"";

        if (""student"".equals(view)) {
            if (responses.size() == responsesForStatistics.size()) {
                statsTitle = ""Response Summary (of visible responses)"";
            } else {
                statsTitle = ""Response Summary (of received responses)"";
            }
        }

        return Templates.populateTemplate(
                FormTemplates.RUBRIC_RESULT_STATS,
                Slots.STATS_TITLE, statsTitle,
                Slots.TABLE_HEADER_ROW_FRAGMENT_HTML, tableHeaderFragmentHtml.toString(),
                Slots.TABLE_BODY_HTML, tableBodyHtml.toString());
    }

    /**
     * Returns a list of FeedbackResponseAttributes filtered according to view, question recipient type
     * for the Statistics Table.
     */
    private List<FeedbackResponseAttributes> filterResponsesForStatistics(
            List<FeedbackResponseAttributes> responses, FeedbackQuestionAttributes question,
            String studentEmail, FeedbackSessionResultsBundle bundle, String view) {

        boolean isViewedByStudent = ""student"".equals(view);
        if (!isViewedByStudent) {
            return responses;
        }

        FeedbackParticipantType recipientType = question.getRecipientType();

        boolean isFilteringSkipped = recipientType.equals(FeedbackParticipantType.INSTRUCTORS)
                || recipientType.equals(FeedbackParticipantType.NONE)
                || recipientType.equals(FeedbackParticipantType.SELF);

        if (isFilteringSkipped) {
            return responses;
        }

        boolean isFilteringByTeams = recipientType.equals(FeedbackParticipantType.OWN_TEAM)
                || recipientType.equals(FeedbackParticipantType.TEAMS);

        List<FeedbackResponseAttributes> receivedResponses = new ArrayList<>();
        String recipientString = isFilteringByTeams ? bundle.getTeamNameForEmail(studentEmail) : studentEmail;

        for (FeedbackResponseAttributes response : responses) {
            boolean isReceivedResponse = response.recipient.equals(recipientString);
            if (isReceivedResponse) {
                receivedResponses.add(response);
            }
        }

        return receivedResponses;
    }

    @Override
    public String getQuestionResultStatisticsCsv(
            List<FeedbackResponseAttributes> responses,
            FeedbackQuestionAttributes question,
            FeedbackSessionResultsBundle bundle) {
        if (responses.isEmpty()) {
            return """";
        }

        StringBuilder csv = new StringBuilder();
        DecimalFormat dfWeight = new DecimalFormat(""#.##"");

        // table header
        for (int i = 0; i < rubricChoices.size(); i++) {

            String header = rubricChoices.get(i)
                          + (hasAssignedWeights
                            ? "" (Weight: "" + dfWeight.format(rubricWeights.get(i)) + "")""
                            : """");

            csv.append(',').append(SanitizationHelper.sanitizeForCsv(header));
        }

        if (hasAssignedWeights) {
            csv.append("",Average"");
        }

        csv.append(Const.EOL);

        // table body
        DecimalFormat df = new DecimalFormat(""#"");
        DecimalFormat dfAverage = new DecimalFormat(""0.00"");

        RubricStatistics statistics = new RubricStatistics(responses, this);
        int[][] responseFrequency = statistics.getResponseFrequency();
        float[][] rubricStats = statistics.getPercentageFrequencyAndAverage();

        for (int i = 0; i < rubricSubQuestions.size(); i++) {
            String alphabeticalIndex = StringHelper.integerToLowerCaseAlphabeticalIndex(i + 1);
            csv.append(SanitizationHelper.sanitizeForCsv(alphabeticalIndex + "") "" + rubricSubQuestions.get(i)));
            boolean isSubQuestionRespondedTo = responseFrequency[i][numOfRubricChoices] > 0;
            for (int j = 0; j < rubricChoices.size(); j++) {
                String percentageFrequencyString = isSubQuestionRespondedTo
                                                 ? df.format(rubricStats[i][j] * 100) + ""%""
                                                 : STATISTICS_NO_VALUE_STRING;
                csv.append("","" + percentageFrequencyString + "" ("" + responseFrequency[i][j] + "")"");
            }

            if (hasAssignedWeights) {
                String averageString = isSubQuestionRespondedTo
                                     ? dfAverage.format(rubricStats[i][rubricWeights.size()])
                                     : STATISTICS_NO_VALUE_STRING;
                csv.append(',').append(averageString);
            }

            csv.append(Const.EOL);
        }

        return csv.toString();
    }

    @Override
    public String getNoResponseTextInCsv(String giverEmail, String recipientEmail,
            FeedbackSessionResultsBundle bundle,
            FeedbackQuestionAttributes question) {
        return SanitizationHelper.sanitizeForCsv(""All Sub-Questions"") + "",""
             + SanitizationHelper.sanitizeForCsv(getNoResponseText(giverEmail, recipientEmail, bundle, question));
    }

    @Override
    public String getCsvHeader() {
        return ""Choice Value"";
    }

    @Override
    public String getCsvDetailedResponsesHeader(int noOfComments) {
        return ""Team"" + "","" + ""Giver's Full Name"" + "",""
                + ""Giver's Last Name"" + "","" + ""Giver's Email"" + "",""
                + ""Recipient's Team"" + "","" + ""Recipient's Full Name"" + "",""
                + ""Recipient's Last Name"" + "","" + ""Recipient's Email"" + "",""
                + ""Sub Question"" + "","" + getCsvHeader() + "","" + ""Choice Number""
                + getCsvDetailedFeedbackResponsesCommentsHeader(noOfComments)
                + Const.EOL;
    }

    @Override
    public String getCsvDetailedResponsesRow(FeedbackSessionResultsBundle fsrBundle,
            FeedbackResponseAttributes feedbackResponseAttributes,
            FeedbackQuestionAttributes question, boolean hasCommentsForResponses) {

        // Retrieve giver details
        String giverLastName = fsrBundle.getLastNameForEmail(feedbackResponseAttributes.giver);
        String giverFullName = fsrBundle.getNameForEmail(feedbackResponseAttributes.giver);
        String giverTeamName = fsrBundle.getTeamNameForEmail(feedbackResponseAttributes.giver);
        String giverEmail = fsrBundle.getDisplayableEmailGiver(feedbackResponseAttributes);

        // Retrieve recipient details
        String recipientLastName = fsrBundle.getLastNameForEmail(feedbackResponseAttributes.recipient);
        String recipientFullName = fsrBundle.getNameForEmail(feedbackResponseAttributes.recipient);
        String recipientTeamName = fsrBundle.getTeamNameForEmail(feedbackResponseAttributes.recipient);
        String recipientEmail = fsrBundle.getDisplayableEmailRecipient(feedbackResponseAttributes);
        //To show comment only once for each response.
        boolean shouldShowComments = hasCommentsForResponses;
        FeedbackRubricResponseDetails frd = (FeedbackRubricResponseDetails) feedbackResponseAttributes.getResponseDetails();
        StringBuilder detailedResponsesRow = new StringBuilder(100);
        for (int i = 0; i < frd.answer.size(); i++) {
            //To show comment only once for each response.
            shouldShowComments = i < 1 && shouldShowComments;
            int chosenIndex = frd.answer.get(i);
            String chosenChoiceNumber = """";
            String chosenChoiceValue = """";
            String chosenIndexString = StringHelper.integerToLowerCaseAlphabeticalIndex(i + 1);

            if (chosenIndex == -1) {
                chosenChoiceValue = Const.INSTRUCTOR_FEEDBACK_RESULTS_MISSING_RESPONSE;
            } else {
                chosenChoiceNumber = Integer.toString(chosenIndex + 1);
                chosenChoiceValue = rubricChoices.get(frd.answer.get(i));
            }

            detailedResponsesRow.append(
                    SanitizationHelper.sanitizeForCsv(StringHelper.removeExtraSpace(giverTeamName)) + ','
                    + SanitizationHelper.sanitizeForCsv(StringHelper.removeExtraSpace(giverFullName)) + ','
                    + SanitizationHelper.sanitizeForCsv(StringHelper.removeExtraSpace(giverLastName)) + ','
                    + SanitizationHelper.sanitizeForCsv(StringHelper.removeExtraSpace(giverEmail)) + ','
                    + SanitizationHelper.sanitizeForCsv(StringHelper.removeExtraSpace(recipientTeamName)) + ','
                    + SanitizationHelper.sanitizeForCsv(StringHelper.removeExtraSpace(recipientFullName)) + ','
                    + SanitizationHelper.sanitizeForCsv(StringHelper.removeExtraSpace(recipientLastName)) + ','
                    + SanitizationHelper.sanitizeForCsv(StringHelper.removeExtraSpace(recipientEmail)) + ','
                    + SanitizationHelper.sanitizeForCsv(chosenIndexString) + ','
                    + SanitizationHelper.sanitizeForCsv(chosenChoiceValue) + ','
                    + SanitizationHelper.sanitizeForCsv(chosenChoiceNumber)
                    + (shouldShowComments
                            ? fsrBundle.getCsvDetailedFeedbackResponseCommentsRow(feedbackResponseAttributes) : """")
                    + Const.EOL);
        }

        return detailedResponsesRow.toString();
    }

    @Override
    public String getQuestionTypeChoiceOption() {
        return ""<li data-questiontype = \""RUBRIC\""><a href=\""javascript:;\"">""
               + Const.FeedbackQuestionTypeNames.RUBRIC + ""</a></li>"";
    }

    @Override
    public List<String> validateQuestionDetails() {
        // For rubric questions,
        // 1) Description size should be valid
        // 2) At least 2 choices
        // 3) At least 1 sub-question
        // 4) Choices and sub-questions should not be empty
        // 5) Choices must have corresponding weights if weights are assigned

        List<String> errors = new ArrayList<>();

        if (!isValidDescriptionSize()) {
            // This should not happen.
            // Set descriptions to empty if the sizes are invalid when extracting question details.
            errors.add(Const.FeedbackQuestion.RUBRIC_ERROR_DESC_INVALID_SIZE);
        }

        if (numOfRubricChoices < Const.FeedbackQuestion.RUBRIC_MIN_NUM_OF_CHOICES) {
            errors.add(Const.FeedbackQuestion.RUBRIC_ERROR_NOT_ENOUGH_CHOICES
                       + Const.FeedbackQuestion.RUBRIC_MIN_NUM_OF_CHOICES);
        }

        if (this.numOfRubricSubQuestions < Const.FeedbackQuestion.RUBRIC_MIN_NUM_OF_SUB_QUESTIONS) {
            errors.add(Const.FeedbackQuestion.RUBRIC_ERROR_NOT_ENOUGH_SUB_QUESTIONS
                       + Const.FeedbackQuestion.RUBRIC_MIN_NUM_OF_SUB_QUESTIONS);
        }

        //Rubric choices are now allowed to be empty.
        /*
        for (String choice : this.rubricChoices) {
            if (choice.trim().isEmpty()) {
                errors.add(ERROR_RUBRIC_EMPTY_CHOICE);
                break;
            }
        }
        */

        for (String subQn : rubricSubQuestions) {
            if (subQn.trim().isEmpty()) {
                errors.add(Const.FeedbackQuestion.RUBRIC_ERROR_EMPTY_SUB_QUESTION);
                break;
            }
        }

        if (hasAssignedWeights && rubricChoices.size() != rubricWeights.size()) {
            errors.add(Const.FeedbackQuestion.RUBRIC_ERROR_INVALID_WEIGHT);
        }

        return errors;
    }

    @Override
    public List<String> validateResponseAttributes(
            List<FeedbackResponseAttributes> responses,
            int numRecipients) {
        return new ArrayList<>();
    }

    @Override
    public Comparator<InstructorFeedbackResultsResponseRow> getResponseRowsSortOrder() {
        return null;
    }

    @Override
    public String validateGiverRecipientVisibility(FeedbackQuestionAttributes feedbackQuestionAttributes) {
        return """";
    }

    boolean hasAssignedWeights() {
        return hasAssignedWeights;
    }

    List<Double> getRubricWeights() {
        return new ArrayList<>(rubricWeights);
    }

    public int getNumOfRubricChoices() {
        return numOfRubricChoices;
    }

    public void setNumOfRubricChoices(int numOfRubricChoices) {
        this.numOfRubricChoices = numOfRubricChoices;
    }

    public List<String> getRubricChoices() {
        return rubricChoices;
    }

    public int getNumOfRubricSubQuestions() {
        return numOfRubricSubQuestions;
    }

    public void setNumOfRubricSubQuestions(int numOfRubricSubQuestions) {
        this.numOfRubricSubQuestions = numOfRubricSubQuestions;
    }

    public List<String> getRubricSubQuestions() {
        return rubricSubQuestions;
    }

    /**
     * Class to calculate the statistics of responses for a rubric question.
     */
    private static class RubricStatistics {

        /**
         * Stores the frequency of being selected for each choice of each sub-question
         * and the total number of responses for each sub-question.
         *
         * <p>Last element in each row stores the total number of responses for the sub-question.
         *
         * <p>e.g.<br>
         * responseFrequency[subQuestionIndex][choiceIndex]
         * -> is the number of times choiceIndex is chosen for subQuestionIndex.<br>
         * responseFrequency[subQuestionIndex][numOfRubricChoices]
         * -> is the total number of the responses for the given sub-question.
         */
        int[][] responseFrequency;

        /**
         * Stores the percentage value between [0,1] of each choice
         * being selected for the sub-question.
         *
         * <p>Values are set to 0 if there are no responses to that sub-question.
         * Average value is set to 0 if there are no assigned weights.
         *
         * <p>e.g.<br>
         * percentageFrequencyAndAverageValue[subQuestionIndex][choiceIndex]
         * -> is the percentage choiceIndex is chosen for subQuestionIndex.<br>
         * percentageFrequencyAndAverageValue[subQuestionIndex][numOfRubricChoices]
         * -> is the average weight of the responses for the given sub-question.
         */
        float[][] percentageFrequencyAndAverage;

        List<FeedbackResponseAttributes> responses;
        FeedbackRubricQuestionDetails questionDetails;

        int numOfRubricSubQuestions;
        int numOfRubricChoices;
        int responseTotalIndex;

        RubricStatistics(List<FeedbackResponseAttributes> responses, FeedbackRubricQuestionDetails questionDetails) {

            this.responses = responses;
            this.questionDetails = questionDetails;

            this.numOfRubricSubQuestions = questionDetails.getNumOfRubricSubQuestions();
            this.numOfRubricChoices = questionDetails.getNumOfRubricChoices();
            this.responseTotalIndex = numOfRubricChoices;

            calculateResponseFrequency();
            calculatePercentageFrequencyAndAverage();
        }

        void calculateResponseFrequency() {
            responseFrequency = new int[numOfRubricSubQuestions][numOfRubricChoices + 1];
            // count frequencies
            for (FeedbackResponseAttributes response : responses) {
                FeedbackRubricResponseDetails frd = (FeedbackRubricResponseDetails) response.getResponseDetails();
                for (int i = 0; i < numOfRubricSubQuestions; i++) {
                    int chosenChoice = frd.getAnswer(i);
                    if (chosenChoice != -1) {
                        responseFrequency[i][chosenChoice] += 1;
                        responseFrequency[i][responseTotalIndex] += 1;
                    }
                }
            }
        }

        /**
         * Calculates the percentage frequencies for each choice and average value for each sub-question.
         * Precondition: responseFrequency has been calculated.
         */
        void calculatePercentageFrequencyAndAverage() {
            Assumption.assertNotNull(""Response Frequency should be initialised and calculated first."",
                                     responseFrequency);

            percentageFrequencyAndAverage = new float[numOfRubricSubQuestions][numOfRubricChoices + 1];
            // calculate percentage frequencies and average value
            for (int i = 0; i < percentageFrequencyAndAverage.length; i++) {
                int totalForSubQuestion = responseFrequency[i][responseTotalIndex];
                //continue to next row if no response for this sub-question
                if (totalForSubQuestion == 0) {
                    continue;
                }
                // divide responsesFrequency by totalForSubQuestion to get percentage
                for (int j = 0; j < numOfRubricChoices; j++) {
                    percentageFrequencyAndAverage[i][j] = (float) responseFrequency[i][j] / totalForSubQuestion;
                }
                // calculate the average for each sub-question
                if (questionDetails.hasAssignedWeights()) {
                    for (int j = 0; j < numOfRubricChoices; j++) {
                        float choiceWeight =
                                (float) (questionDetails.getRubricWeights().get(j) * percentageFrequencyAndAverage[i][j]);
                        percentageFrequencyAndAverage[i][numOfRubricChoices] += choiceWeight;
                    }
                }
            }
        }

        int[][] getResponseFrequency() {
            return responseFrequency;
        }

        float[][] getPercentageFrequencyAndAverage() {
            return percentageFrequencyAndAverage;
        }

    }

}
"
FeedbackRubricResponseDetails.java,data-transfer,"package teammates.common.datatransfer.questions;

import java.util.ArrayList;
import java.util.List;
import java.util.regex.Pattern;

import teammates.common.exception.TeammatesException;
import teammates.common.util.Const;
import teammates.common.util.Logger;
import teammates.common.util.SanitizationHelper;
import teammates.common.util.StringHelper;

public class FeedbackRubricResponseDetails extends FeedbackResponseDetails {

    private static final Logger log = Logger.getLogger();

    /**
     * List of integers, the size of the list corresponds to the number of sub-questions.
     * Each integer at index i, represents the choice chosen for sub-question i.
     */
    public List<Integer> answer;

    public FeedbackRubricResponseDetails() {
        super(FeedbackQuestionType.RUBRIC);
    }

    @Override
    public void extractResponseDetails(FeedbackQuestionType questionType,
                                       FeedbackQuestionDetails questionDetails, String[] answer) {

        /**
         * Example: a response in the form: ""0-1,1-0""
         * means that for sub-question 0, choice 1 is chosen,
         * and for sub-question 1, choice 0 is chosen.
         */

        String rawResponses = answer[0];
        FeedbackRubricQuestionDetails fqd = (FeedbackRubricQuestionDetails) questionDetails;

        initializeEmptyAnswerList(fqd.getNumOfRubricSubQuestions());

        // Parse and extract answers
        String[] subQuestionResponses = rawResponses.split(Pattern.quote("",""));
        for (String subQuestionResponse : subQuestionResponses) {
            String[] subQuestionIndexAndChoice = subQuestionResponse.split(Pattern.quote(""-""));

            if (subQuestionIndexAndChoice.length != 2) {
                // Expected length is 2.
                // Failed to parse, ignore response.
                continue;
            }

            try {
                int subQuestionIndex = Integer.parseInt(subQuestionIndexAndChoice[0]);
                int subQuestionChoice = Integer.parseInt(subQuestionIndexAndChoice[1]);
                if (subQuestionIndex >= 0 && subQuestionIndex < fqd.getNumOfRubricSubQuestions()
                        && subQuestionChoice >= 0 && subQuestionChoice < fqd.getNumOfRubricChoices()) {
                    setAnswer(subQuestionIndex, subQuestionChoice);
                } // else the indexes are invalid.
            } catch (NumberFormatException e) {
                // Failed to parse, ignore response.
                log.warning(TeammatesException.toStringWithStackTrace(e));
            }
        }
    }

    /**
     * Initializes the answer list to have empty responses.
     */
    private void initializeEmptyAnswerList(int numSubQuestions) {
        answer = new ArrayList<>();
        for (int i = 0; i < numSubQuestions; i++) {
            // -1 indicates no choice chosen
            answer.add(-1);
        }
    }

    @Override
    public String getAnswerString() {
        return this.answer.toString();
    }

    @Override
    public String getAnswerHtmlInstructorView(FeedbackQuestionDetails questionDetails) {
        FeedbackRubricQuestionDetails fqd = (FeedbackRubricQuestionDetails) questionDetails;
        StringBuilder html = new StringBuilder(100);
        for (int i = 0; i < answer.size(); i++) {
            int chosenIndex = answer.get(i);
            String chosenChoice = """";
            if (chosenIndex == -1) {
                chosenChoice = ""<span class=\""color_neutral\""><i>""
                             + Const.INSTRUCTOR_FEEDBACK_RESULTS_MISSING_RESPONSE
                             + ""</i></span>"";
                html.append(StringHelper.integerToLowerCaseAlphabeticalIndex(i + 1) + "") "" + chosenChoice + ""<br>"");
            } else {
                chosenChoice = SanitizationHelper.sanitizeForHtml(fqd.getRubricChoices().get(answer.get(i)));
                html.append(StringHelper.integerToLowerCaseAlphabeticalIndex(i + 1) + "") "" + chosenChoice
                            + "" <span class=\""color_neutral\""><i>(Choice "" + (chosenIndex + 1)
                            + "")</i></span><br>"");
            }

        }

        return html.toString();
    }

    @Override
    public String getAnswerHtmlStudentView(FeedbackQuestionDetails questionDetails) {
        FeedbackRubricQuestionDetails fqd = (FeedbackRubricQuestionDetails) questionDetails;
        StringBuilder html = new StringBuilder(100);

        html.append(""<table class=\""table table-bordered\"">"");

        StringBuilder tableHeaderHtml = new StringBuilder(100);

        tableHeaderHtml.append(
                ""<thead>""
                   + ""<tr>""
                        + ""<th>Criteria</th>"");

        List<String> subQuestions = fqd.getRubricSubQuestions();
        List<String> rubricChoices = fqd.getRubricChoices();

        for (int i = 0; i < rubricChoices.size(); i++) {
            tableHeaderHtml.append(""<th class=\""text-center\"">"");
            tableHeaderHtml.append(rubricChoices.get(i));
            tableHeaderHtml.append(""</th>"");
        }

        tableHeaderHtml.append(
                      ""</tr>""
                + ""</thead>"");

        StringBuilder tableBodyHtml = new StringBuilder(200);

        tableBodyHtml.append(""<tbody>"");

        for (int i = 0; i < answer.size(); i++) {
            int chosenIndex = answer.get(i);

            tableBodyHtml.append(
                    ""<tr>""
                        + ""<td>"");
            tableBodyHtml.append(subQuestions.get(i));
            tableBodyHtml.append(""</td>"");

            for (int j = 0; j < rubricChoices.size(); j++) {
                tableBodyHtml.append(""<td class=\""text-center\"">"");

                if (j == chosenIndex) {
                    tableBodyHtml.append(""<span class=\""glyphicon glyphicon-ok text-success\""></span>"");
                }

                tableBodyHtml.append(""</td>"");
            }
        }

        tableBodyHtml.append(""</tbody>"");
        html.append(tableHeaderHtml).append(tableBodyHtml).append(""</table>"");

        return html.toString();
    }

    @Override
    public String getAnswerCsv(FeedbackQuestionDetails questionDetails) {
        return answer.toString();
    }

    public int getAnswer(int subQuestionIndex) {
        return answer.get(subQuestionIndex);
    }

    public void setAnswer(int subQuestionIndex, int choice) {
        this.answer.set(subQuestionIndex, choice);
    }
}
"
FeedbackTextQuestionDetails.java,data-transfer,"package teammates.common.datatransfer.questions;

import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.Map;

import teammates.common.datatransfer.FeedbackSessionResultsBundle;
import teammates.common.datatransfer.attributes.FeedbackQuestionAttributes;
import teammates.common.datatransfer.attributes.FeedbackResponseAttributes;
import teammates.common.util.Const;
import teammates.common.util.HttpRequestHelper;
import teammates.common.util.SanitizationHelper;
import teammates.common.util.Templates;
import teammates.common.util.Templates.FeedbackQuestion.FormTemplates;
import teammates.common.util.Templates.FeedbackQuestion.Slots;
import teammates.ui.template.InstructorFeedbackResultsResponseRow;

public class FeedbackTextQuestionDetails extends FeedbackQuestionDetails {

    private int recommendedLength;

    public FeedbackTextQuestionDetails() {
        super(FeedbackQuestionType.TEXT);
        recommendedLength = 0;
    }

    public FeedbackTextQuestionDetails(String questionText) {
        super(FeedbackQuestionType.TEXT, questionText);
        recommendedLength = 0;
    }

    @Override
    public boolean extractQuestionDetails(
            Map<String, String[]> requestParameters,
            FeedbackQuestionType questionType) {
        String recommendedLengthString = HttpRequestHelper.getValueFromParamMap(requestParameters,
                Const.ParamsNames.FEEDBACK_QUESTION_TEXT_RECOMMENDEDLENGTH);

        recommendedLength = recommendedLengthString == null || recommendedLengthString.isEmpty() ? 0
                : Integer.parseInt(recommendedLengthString);
        return true;
    }

    @Override
    public String getQuestionTypeDisplayName() {
        return Const.FeedbackQuestionTypeNames.TEXT;
    }

    @Override
    public boolean isChangesRequiresResponseDeletion(FeedbackQuestionDetails newDetails) {
        return false;
    }

    @Override
    public String getQuestionWithExistingResponseSubmissionFormHtml(boolean sessionIsOpen, int qnIdx,
            int responseIdx, String courseId, int totalNumRecipients, FeedbackResponseDetails existingResponseDetails) {
        return Templates.populateTemplate(
                FormTemplates.TEXT_SUBMISSION_FORM,
                Slots.DISABLED, sessionIsOpen ? """" : ""disabled"",
                Slots.FEEDBACK_RESPONSE_TEXT, Const.ParamsNames.FEEDBACK_RESPONSE_TEXT,
                Slots.QUESTION_INDEX, Integer.toString(qnIdx),
                Slots.RESPONSE_INDEX, Integer.toString(responseIdx),
                ""${recommendedLengthDisplay}"", recommendedLength == 0 ? ""style=\""display:none\"""" : """",
                ""${recommendedLength}"", Integer.toString(recommendedLength),
                Slots.TEXT_EXISTING_RESPONSE,
                    SanitizationHelper.sanitizeForRichText(existingResponseDetails.getAnswerString()));
    }

    @Override
    public String getQuestionWithoutExistingResponseSubmissionFormHtml(
            boolean sessionIsOpen, int qnIdx, int responseIdx, String courseId, int totalNumRecipients) {
        return Templates.populateTemplate(
                FormTemplates.TEXT_SUBMISSION_FORM,
                Slots.DISABLED, sessionIsOpen ? """" : ""disabled"",
                Slots.FEEDBACK_RESPONSE_TEXT, Const.ParamsNames.FEEDBACK_RESPONSE_TEXT,
                Slots.QUESTION_INDEX, Integer.toString(qnIdx),
                Slots.RESPONSE_INDEX, Integer.toString(responseIdx),
                ""${recommendedLengthDisplay}"", recommendedLength == 0 ? ""style=\""display:none\"""" : """",
                ""${recommendedLength}"", Integer.toString(recommendedLength),
                Slots.TEXT_EXISTING_RESPONSE, """");
    }

    @Override
    public String getQuestionSpecificEditFormHtml(int questionNumber) {
        return Templates.populateTemplate(
                FormTemplates.TEXT_EDIT_FORM,
                ""${recommendedlength}"", recommendedLength == 0 ? """" : Integer.toString(recommendedLength));
    }

    @Override
    public String getNewQuestionSpecificEditFormHtml() {
        return ""<div id=\""textForm\"">""
                + getQuestionSpecificEditFormHtml(-1)
                + ""</div>"";
    }

    @Override
    public String getQuestionAdditionalInfoHtml(int questionNumber, String additionalInfoId) {
        return """";
    }

    @Override
    public String getQuestionResultStatisticsHtml(List<FeedbackResponseAttributes> responses,
            FeedbackQuestionAttributes question,
            String studentEmail,
            FeedbackSessionResultsBundle bundle,
            String view) {
        if (responses.isEmpty()) {
            return """";
        }

        return """";
        /*
        int averageLength = 0;
        int minLength = Integer.MAX_VALUE;
        int maxLength = Integer.MIN_VALUE;
        int numResponses = 0;
        int totalLength = 0;

        for(FeedbackResponseAttributes response : responses){
            numResponses++;
            String answerString = response.getResponseDetails().getAnswerString();
            minLength = StringHelper.countWords(answerString) < minLength
                        ? StringHelper.countWords(answerString)
                        : minLength;
            maxLength = StringHelper.countWords(answerString) > maxLength
                        ? StringHelper.countWords(answerString)
                        : maxLength;
            totalLength += StringHelper.countWords(answerString);
        }

        averageLength = totalLength/numResponses;

        html = FeedbackQuestionFormTemplates.populateTemplate(
                        FeedbackQuestionFormTemplates.TEXT_RESULT_STATS,
                        ""${averageLength}"", Integer.toString(averageLength),
                        ""${minLength}"", (minLength == Integer.MAX_VALUE)? ""-"" : Integer.toString(minLength),
                        ""${maxLength}"", (maxLength == Integer.MIN_VALUE)? ""-"" : Integer.toString(maxLength));
        */
        //TODO: evaluate what statistics are needed for text questions later.
    }

    @Override
    public String getQuestionResultStatisticsCsv(
            List<FeedbackResponseAttributes> responses,
            FeedbackQuestionAttributes question,
            FeedbackSessionResultsBundle bundle) {
        return """";
    }

    @Override
    public String getCsvHeader() {
        return ""Feedback"";
    }

    @Override
    public String getQuestionTypeChoiceOption() {
        return ""<li data-questiontype = \""TEXT\""><a href=\""javascript:;\"">""
               + Const.FeedbackQuestionTypeNames.TEXT + ""</a></li>"";
    }

    @Override
    public List<String> validateQuestionDetails() {
        return new ArrayList<>();
    }

    @Override
    public List<String> validateResponseAttributes(
            List<FeedbackResponseAttributes> responses,
            int numRecipients) {
        return new ArrayList<>();
    }

    @Override
    public Comparator<InstructorFeedbackResultsResponseRow> getResponseRowsSortOrder() {
        return null;
    }

    @Override
    public String validateGiverRecipientVisibility(FeedbackQuestionAttributes feedbackQuestionAttributes) {
        return """";
    }

}
"
FeedbackTextResponseDetails.java,data-transfer,"package teammates.common.datatransfer.questions;

import org.jsoup.Jsoup;

import teammates.common.util.SanitizationHelper;

public class FeedbackTextResponseDetails extends
        FeedbackResponseDetails {

    //For essay questions the response is saved as plain-text due to legacy format before there were multiple question types
    public String answer;

    public FeedbackTextResponseDetails() {
        super(FeedbackQuestionType.TEXT);
        this.answer = """";
    }

    public FeedbackTextResponseDetails(String answer) {
        super(FeedbackQuestionType.TEXT);
        this.answer = SanitizationHelper.sanitizeForRichText(answer);
    }

    @Override
    public void extractResponseDetails(FeedbackQuestionType questionType,
                                       FeedbackQuestionDetails questionDetails, String[] answer) {
        this.answer = SanitizationHelper.sanitizeForRichText(answer[0]);
    }

    @Override
    public String getAnswerString() {
        return SanitizationHelper.sanitizeForRichText(answer);
    }

    @Override
    public String getAnswerHtmlInstructorView(FeedbackQuestionDetails questionDetails) {
        return SanitizationHelper.sanitizeForRichText(answer);
    }

    @Override
    public String getAnswerCsv(FeedbackQuestionDetails questionDetails) {
        return SanitizationHelper.sanitizeForCsv(Jsoup.parse(answer).text());
    }

}
"
package-info.java,data-transfer,"/**
 * Contains specific question type-related classes.
 */
package teammates.common.datatransfer.questions;
"
SearchResultBundle.java,data-transfer,"package teammates.common.datatransfer;

/**
 * The basic search result bundle object.
 */
public class SearchResultBundle {

    public int numberOfResults;

    protected SearchResultBundle() {
        // prevents instantiation; to be instantiated as children classes
    }

}
"
SectionDetailsBundle.java,data-transfer,"package teammates.common.datatransfer;

import java.util.ArrayList;
import java.util.List;

/**
 * Represents details of teams in a section.
 * <br> Contains:
 * <br> * The section name .
 * <br> * {@link TeamDetailsBundle} objects for all teams in the section.
 */
public class SectionDetailsBundle {

    public String name;
    public List<TeamDetailsBundle> teams = new ArrayList<>();

}
"
StudentAttributesFactory.java,data-transfer,"package teammates.common.datatransfer;

import teammates.common.datatransfer.attributes.StudentAttributes;
import teammates.common.exception.EnrollException;
import teammates.common.util.Assumption;
import teammates.common.util.Const;
import teammates.common.util.FieldValidator;
import teammates.common.util.StringHelper;

/**
 * A factory for the creation of {@link StudentAttributes} objects.
 * It encapsulates the mechanism to create a {@link StudentAttributes} object
 * from a given enroll line.
 */
public class StudentAttributesFactory {
    public static final int MIN_FIELD_COUNT = 3;
    public static final int MAX_FIELD_COUNT = 5;

    public static final String ERROR_HEADER_ROW_FIELD_REPEATED = ""The header row contains repeated fields"";
    public static final String ERROR_HEADER_ROW_FIELD_MISSED =
            ""The following required column names are missing in the header row"";

    public static final String ERROR_ENROLL_LINE_EMPTY = ""Enroll line was empty"" + Const.HTML_BR_TAG;
    public static final String ERROR_ENROLL_LINE_TOOFEWPARTS =
            ""Enroll line had fewer than the minimally expected ""
            + MIN_FIELD_COUNT + "" columns (Team, Name and Email)"" + Const.HTML_BR_TAG;

    public static final int FIRST_COLUMN_INDEX = 0;
    public static final int SECOND_COLUMN_INDEX = 1;
    public static final int THIRD_COLUMN_INDEX = 2;
    public static final int FOURTH_COLUMN_INDEX = 3;
    public static final int FIFTH_COLUMN_INDEX = 4;

    private int sectionColumnIndex;
    private int teamColumnIndex;
    private int nameColumnIndex;
    private int emailColumnIndex;
    private int commentColumnIndex;

    private boolean hasSection;
    private boolean hasTeam;
    private boolean hasName;
    private boolean hasEmail;
    private boolean hasComment;

    public StudentAttributesFactory() throws EnrollException {
        this(""section|team|name|email|comment"");
    }

    /**
     * Construct a StudentAttributesFactory object with the given header row.<br>
     * The column names allowed in header row: {team, name, email, comment}<br>
     * They are case insensitive and plural nouns are allowed. If the header row
     * doesn't contain all required columns, then it is ignored and treated as a
     * normal enroll line. <br>
     * Pre-condition: headerRow must not be null
     */
    public StudentAttributesFactory(String headerRow) throws EnrollException {
        Assumption.assertNotNull(headerRow);

        int fieldCount = locateColumnIndexes(headerRow);

        if (fieldCount < MIN_FIELD_COUNT || !hasTeam || !hasName || !hasEmail) {
            StringBuilder missingField = new StringBuilder(50);
            if (!hasTeam) {
                missingField.append("" <mark>Team</mark>"");
            }
            if (!hasName) {
                missingField.append("" <mark>Name</mark>"");
            }
            if (!hasEmail) {
                missingField.append("" <mark>Email</mark>"");
            }
            throw new EnrollException(ERROR_HEADER_ROW_FIELD_MISSED + "":"" + missingField.toString());
        }
    }

    /**
     * Return a StudentAttributes object created from the given enrollLine.
     */
    public StudentAttributes makeStudent(String enrollLine, String courseId) throws EnrollException {
        if (enrollLine.isEmpty()) {
            throw new EnrollException(ERROR_ENROLL_LINE_EMPTY);
        }

        String[] columns = splitLineIntoColumns(enrollLine);

        boolean hasMissingFields = columns.length <= teamColumnIndex
                                   || columns.length <= nameColumnIndex
                                   || columns.length <= emailColumnIndex;

        if (hasMissingFields) {
            throw new EnrollException(ERROR_ENROLL_LINE_TOOFEWPARTS);
        }

        String paramTeam = StringHelper.removeExtraSpace(columns[teamColumnIndex]);
        String paramName = StringHelper.removeExtraSpace(columns[nameColumnIndex]);
        String paramEmail = StringHelper.removeExtraSpace(columns[emailColumnIndex]);

        String paramComment = """";

        if (hasComment && columns.length > commentColumnIndex) {
            paramComment = StringHelper.removeExtraSpace(columns[commentColumnIndex]);
        }

        String paramSection;

        if (hasSection && columns.length > sectionColumnIndex) {
            paramSection = StringHelper.removeExtraSpace(columns[sectionColumnIndex]);
        } else {
            paramSection = Const.DEFAULT_SECTION;
        }

        return new StudentAttributes(paramSection, paramTeam, paramName, paramEmail, paramComment, courseId);
    }

    private int locateColumnIndexes(String headerRow) throws EnrollException {
        int fieldCount = 0;
        int count = 0;

        hasSection = false;
        hasTeam = false;
        hasName = false;
        hasEmail = false;
        hasComment = false;

        String[] columns = splitLineIntoColumns(headerRow);

        for (int curPos = 0; curPos < columns.length; curPos++) {
            String str = columns[curPos].trim().toLowerCase();

            if (StringHelper.isAnyMatching(str, FieldValidator.REGEX_COLUMN_SECTION)) {
                sectionColumnIndex = curPos;
                count++;
                fieldCount = hasSection ? fieldCount : fieldCount + 1;
                hasSection = true;
            } else if (StringHelper.isAnyMatching(str, FieldValidator.REGEX_COLUMN_TEAM)) {
                teamColumnIndex = curPos;
                count++;
                fieldCount = hasTeam ? fieldCount : fieldCount + 1;
                hasTeam = true;
            } else if (StringHelper.isAnyMatching(str, FieldValidator.REGEX_COLUMN_NAME)) {
                nameColumnIndex = curPos;
                count++;
                fieldCount = hasName ? fieldCount : fieldCount + 1;
                hasName = true;
            } else if (StringHelper.isAnyMatching(str, FieldValidator.REGEX_COLUMN_EMAIL)) {
                emailColumnIndex = curPos;
                count++;
                fieldCount = hasEmail ? fieldCount : fieldCount + 1;
                hasEmail = true;
            } else if (StringHelper.isAnyMatching(str, FieldValidator.REGEX_COLUMN_COMMENT)) {
                commentColumnIndex = curPos;
                count++;
                fieldCount = hasComment ? fieldCount : fieldCount + 1;
                hasComment = true;
            }
        }

        if (count > fieldCount) {
            throw new EnrollException(ERROR_HEADER_ROW_FIELD_REPEATED);
        }

        return fieldCount;
    }

    private String[] splitLineIntoColumns(String line) {
        Assumption.assertNotNull(line);
        return line.replace(""|"", ""\t"").split(""\t"", -1);
    }
}
"
StudentEnrollDetails.java,data-transfer,"package teammates.common.datatransfer;

public class StudentEnrollDetails {
    public StudentUpdateStatus updateStatus;
    public String course;
    public String email;
    public String oldTeam;
    public String newTeam;
    public String oldSection;
    public String newSection;

    public StudentEnrollDetails() {
        updateStatus = StudentUpdateStatus.UNKNOWN;
        course = null;
        email = null;
        oldTeam = null;
        newTeam = null;
        oldSection = null;
        newSection = null;
    }

    public StudentEnrollDetails(StudentUpdateStatus updateStatus, String course,
            String email, String oldTeam, String newTeam, String oldSection, String newSection) {
        this.updateStatus = updateStatus;
        this.course = course;
        this.email = email;
        this.oldTeam = oldTeam;
        this.newTeam = newTeam;
        this.oldSection = oldSection;
        this.newSection = newSection;
    }
}
"
StudentResultSummary.java,data-transfer,"package teammates.common.datatransfer;

import teammates.common.util.Const;

/**
 * Represents the contribution ratings for the student for a given contribution question.
 * <br> Contains claimed and perceived values to be shown to the student and the instructor.
 */
public class StudentResultSummary {

    /** The normalized 'claimed contribution' value to be shown to the instructor. */
    public int claimedToInstructor = Const.INT_UNINITIALIZED;

    /** The normalized 'perceived contribution' value to be shown to the instructor. */
    public int perceivedToInstructor = Const.INT_UNINITIALIZED;

}
"
StudentSearchResultBundle.java,data-transfer,"package teammates.common.datatransfer;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import teammates.common.datatransfer.attributes.InstructorAttributes;
import teammates.common.datatransfer.attributes.StudentAttributes;

/**
 * The search result bundle for {@link StudentAttributes}.
 */
public class StudentSearchResultBundle extends SearchResultBundle {

    public List<StudentAttributes> studentList = new ArrayList<>();
    public Map<String, InstructorAttributes> courseIdInstructorMap = new HashMap<>();

}
"
StudentUpdateStatus.java,data-transfer,"package teammates.common.datatransfer;

/**
 * Represents a student's update status, typically after enrollment.
 */
public enum StudentUpdateStatus {

    ERROR(0),
    NEW(1),
    MODIFIED(2),
    UNMODIFIED(3),
    NOT_IN_ENROLL_LIST(4),
    UNKNOWN(5);

    public static final int STATUS_COUNT = 6;

    public final int numericRepresentation;

    StudentUpdateStatus(int numericRepresentation) {
        this.numericRepresentation = numericRepresentation;
    }

    public static StudentUpdateStatus enumRepresentation(int numericRepresentation) {
        switch (numericRepresentation) {
        case 0:
            return ERROR;
        case 1:
            return NEW;
        case 2:
            return MODIFIED;
        case 3:
            return UNMODIFIED;
        case 4:
            return NOT_IN_ENROLL_LIST;
        default:
            return UNKNOWN;
        }
    }

}
"
TeamDetailsBundle.java,data-transfer,"package teammates.common.datatransfer;

import java.util.ArrayList;
import java.util.List;

import teammates.common.datatransfer.attributes.StudentAttributes;

/**
 * Represents details of students in a team.
 * <br> Contains:
 * <br> * The team name .
 * <br> * {@link StudentAttributes} objects for all students in the team.
 */
public class TeamDetailsBundle {

    public String name;
    public List<StudentAttributes> students = new ArrayList<>();

}
"
TeamEvalResult.java,data-transfer,"package teammates.common.datatransfer;

import java.util.Arrays;
import java.util.List;

import teammates.common.util.Const;
import teammates.common.util.Logger;
import teammates.common.util.StringHelper;

/**
 * This class represents an feedback contribution question result for a given team.
 * It exposes the result via some public variables.
 */
public class TeamEvalResult {

    /** submitted value is uninitialized. */
    public static final int NA = Const.INT_UNINITIALIZED;
    /** submitted 'Not SUre'. */
    public static final int NSU = Const.POINTS_NOT_SURE;
    /** did Not SuBmit. */
    public static final int NSB = Const.POINTS_NOT_SUBMITTED;
    private static final Logger log = Logger.getLogger();

    /** submission values originally from students of the team. */
    public int[][] claimed;
    /** submission values to be shown to instructor (after normalization). */
    public int[][] normalizedClaimed;
    /** average perception of team shown to instructor. Excludes self evaluations */
    public int[] normalizedAveragePerceived;
    /** team perception shown to students. denormalized to match their own claims */
    public int[][] denormalizedAveragePerceived;

    /** the values that were used to calculate normalizedAveragePerceived values. */
    public int[][] normalizedPeerContributionRatio;

    // List of student email's.
    // The index of the student in the list is used as the index for the int arrays.
    // The 2d int arrays are of the format [giverIndex][recipientIndex]
    public List<String> studentEmails;

    public TeamEvalResult(int[][] submissionValues) {
        /*This is the only method that should be public. However, many of the
         * other methods are set as public for the ease of testing.
         */

        log.fine(""==================\n"" + ""starting result calculation for\n""
                + pointsToString(submissionValues));

        claimed = submissionValues;

        normalizedClaimed = normalizeValues(claimed);

        int[][] claimedSanitized = sanitizeInput(submissionValues);
        log.fine(""claimed values sanitized :\n""
                + pointsToString(claimedSanitized));

        double[][] claimedSanitizedNormalized = normalizeValues(intToDouble(claimedSanitized));
        log.fine(""claimed values sanitized and normalized :\n""
                + pointsToString(claimedSanitizedNormalized));

        double[][] peerContributionRatioAsDouble = calculatePeerContributionRatio(claimedSanitizedNormalized);
        log.fine(""peerContributionRatio as double :\n""
                + pointsToString(peerContributionRatioAsDouble));

        double[] averagePerceivedAsDouble = averageColumns(peerContributionRatioAsDouble);
        log.fine(""averagePerceived as double:\n""
                + replaceMagicNumbers(Arrays.toString(averagePerceivedAsDouble)));

        double[] normalizedAveragePerceivedAsDouble = normalizeValues(averagePerceivedAsDouble);
        log.fine(""normalizedAveragePerceivedAsDouble as double:\n""
                + replaceMagicNumbers(Arrays
                        .toString(normalizedAveragePerceivedAsDouble)));

        double[][] normalizedPeerContributionRatioAsDouble =
                adjustPeerContributionRatioToTallyNormalizedAveragePerceived(peerContributionRatioAsDouble);
        log.fine(""normalizedPeerContributionRatio as double :\n""
                + pointsToString(peerContributionRatioAsDouble));

        normalizedPeerContributionRatio = doubleToInt(normalizedPeerContributionRatioAsDouble);
        log.fine(""normalizedUnbiasedClaimed as int :\n""
                + pointsToString(normalizedPeerContributionRatio));

        denormalizedAveragePerceived = calculatePerceivedForStudents(
                claimedSanitized, normalizedAveragePerceivedAsDouble);
        log.fine(""perceived to students :\n""
                + pointsToString(denormalizedAveragePerceived));

        normalizedAveragePerceived = doubleToInt(normalizedAveragePerceivedAsDouble);

        log.fine(""Final result:\n"" + this.toString());

        log.fine(""=================="");
    }

    /**
     * Replaces all missing points (for various reasons such as 'not sure' or
     * 'did not submit') with NA.
     */
    private int[][] sanitizeInput(int[][] input) {
        int teamSize = input.length;
        int[][] output = new int[teamSize][teamSize];
        for (int i = 0; i < teamSize; i++) {
            for (int j = 0; j < teamSize; j++) {
                int points = input[i][j];
                boolean pointsNotGiven = points == Const.POINTS_NOT_SUBMITTED
                                         || points == Const.POINTS_NOT_SURE;
                output[i][j] = pointsNotGiven ? NA : points;
            }
        }
        return output;
    }

    private static double[][] calculatePeerContributionRatio(double[][] input) {

        int teamSize = input.length;

        double[][] selfRatingsRemoved = removeSelfRatings(input);

        double[][] selfRatingRemovedAndNormalized = new double[teamSize][teamSize];
        for (int i = 0; i < teamSize; i++) {
            selfRatingRemovedAndNormalized[i] = normalizeValues(selfRatingsRemoved[i]);
        }

        return selfRatingRemovedAndNormalized;
    }

    private static double[][] adjustPeerContributionRatioToTallyNormalizedAveragePerceived(
            double[][] peerContributionRatio) {
        double[] columnsAveraged = averageColumns(peerContributionRatio);
        double factor = calculateFactor(columnsAveraged);
        return multiplyByFactor(factor, peerContributionRatio);
    }

    private int[][] calculatePerceivedForStudents(int[][] claimedSanitized,
            double[] normalizedAveragePerceivedAsDouble) {
        int teamSize = claimedSanitized.length;
        int[][] output = new int[teamSize][teamSize];
        for (int k = 0; k < teamSize; k++) {
            output[k] = calculatePerceivedForStudent(claimedSanitized[k],
                    normalizedAveragePerceivedAsDouble);
        }
        return output;
    }

    public static int[] calculatePerceivedForStudent(int[] claimedSanitizedRow,
            double[] normalizedAveragePerceivedAsDouble) {

        verify(""Unsanitized value received "", isSanitized(claimedSanitizedRow));

        // remove from each array values matching special values in the other
        double[] filteredPerceived = purgeValuesCorrespondingToSpecialValuesInFilter(
                intToDouble(claimedSanitizedRow),
                normalizedAveragePerceivedAsDouble);
        int[] filteredSanitizedActual = doubleToInt(purgeValuesCorrespondingToSpecialValuesInFilter(
                normalizedAveragePerceivedAsDouble,
                intToDouble(claimedSanitizedRow)));

        double sumOfPerceived = sum(filteredPerceived);
        double sumOfActual = sum(filteredSanitizedActual);

        // if the student did not submit
        if (sumOfActual == NA) {
            sumOfActual = sumOfPerceived;
        }

        double factor = sumOfActual / sumOfPerceived;

        return doubleToInt(multiplyByFactor(factor,
                normalizedAveragePerceivedAsDouble));
    }

    public static boolean isSanitized(int[] array) {
        for (int i = 0; i < array.length; i++) {
            if (!isSanitized(array[i])) {
                return false;
            }
        }
        return true;
    }

    private static boolean isSanitized(int i) {
        return i != NSB && i != NSU;
    }

    private static boolean isSpecialValue(int value) {
        return value == NA || value == NSU || value == NSB;
    }

    private static double[][] multiplyByFactor(double factor, double[][] input) {
        int teamSize = input.length;
        double[][] output = new double[teamSize][teamSize];
        for (int i = 0; i < teamSize; i++) {
            output[i] = multiplyByFactor(factor, input[i]);
        }
        return output;
    }

    private static double[] multiplyByFactor(double factor, double[] input) {
        int teamSize = input.length;
        double[] output = new double[teamSize];
        for (int j = 0; j < teamSize; j++) {
            double value = input[j];
            if (isSpecialValue((int) value)) {
                output[j] = value;
            } else {
                output[j] = factor == 0 ? value : value * factor;
            }
        }
        return output;
    }

    public static double[] purgeValuesCorrespondingToSpecialValuesInFilter(
            double[] filterArray, double[] valueArray) {
        double[] returnValue = new double[filterArray.length];
        for (int i = 0; i < filterArray.length; i++) {
            int filterValue = (int) filterArray[i];
            boolean isSpecialValue = !isSanitized(filterValue)
                    || filterValue == NA;
            returnValue[i] = isSpecialValue ? NA : valueArray[i];
        }
        return returnValue;
    }

    public static double sum(double[] input) {
        if (input.length == 0) {
            return 0;
        }

        verify(""Unsanitized value in "" + Arrays.toString(input),
                isSanitized(doubleToInt(input)));

        double sum = NA;
        for (double value : input) {

            if (value != NA) {
                sum = sum == NA ? value : sum + value;
            }
        }
        return sum;
    }

    public static int sum(int[] input) {
        return (int) sum(intToDouble(input));
    }

    // TODO: methods like these private and use reflection to test
    public static double[][] removeSelfRatings(double[][] input) {
        double[][] output = new double[input.length][input.length];
        for (int i = 0; i < input.length; i++) {
            for (int j = 0; j < input[i].length; j++) {
                output[i][j] = i == j ? NA : input[i][j];
            }
        }
        return output;
    }

    private static double[][] normalizeValues(double[][] input) {
        double[][] output = new double[input.length][input.length];
        for (int i = 0; i < input.length; i++) {
            output[i] = normalizeValues(input[i]);
        }
        return output;
    }

    // TODO: make this private and use reflection to test
    public static double[] normalizeValues(double[] input) {
        double factor = calculateFactor(input);
        return multiplyByFactor(factor, input);
    }

    public static double[] normalizeValues(int[] input) {
        return normalizeValues(intToDouble(input));
    }

    public static int[][] normalizeValues(int[][] input) {
        return doubleToInt(normalizeValues(intToDouble(input)));
    }

    private static double calculateFactor(double[] input) {
        double actualSum = 0;
        int count = 0;
        for (double value : input) {
            int valueAsInt = (int) value;
            if (isSpecialValue(valueAsInt)) {
                continue;
            }
            actualSum += value;
            count++;
        }

        double idealSum = count * 100.0;
        double factor = actualSum == 0 ? 0 : idealSum / actualSum;
        log.fine(""Factor = "" + idealSum + ""/"" + actualSum + "" = "" + factor);
        return factor;
    }

    @SuppressWarnings(""PMD.AvoidArrayLoops"") // the arrays are of different types
    private static double[] intToDouble(int[] input) {
        double[] converted = new double[input.length];
        for (int i = 0; i < input.length; i++) {
            converted[i] = input[i];
        }
        return converted;
    }

    private static double[][] intToDouble(int[][] input) {
        double[][] converted = new double[input.length][input[0].length];
        for (int i = 0; i < input.length; i++) {
            converted[i] = intToDouble(input[i]);
        }
        return converted;
    }

    private static int[] doubleToInt(double[] input) {
        int[] converted = new int[input.length];
        for (int i = 0; i < input.length; i++) {
            converted[i] = (int) Math.round(input[i]);
        }
        return converted;
    }

    private static int[][] doubleToInt(double[][] input) {
        int[][] output = new int[input.length][input.length];
        for (int i = 0; i < input.length; i++) {
            output[i] = doubleToInt(input[i]);
        }
        return output;
    }

    // TODO: make this private and use reflection to test
    public static double[] averageColumns(double[][] input) {
        double[] output = new double[input.length];

        for (int i = 0; i < input.length; i++) {
            verify(""Unsanitized value in "" + Arrays.toString(input[i]),
                    isSanitized(doubleToInt(input[i])));
            output[i] = averageColumn(input, i);
        }
        log.fine(""Column averages: ""
                + replaceMagicNumbers(Arrays.toString(output)));
        return output;
    }

    private static double averageColumn(double[][] arrayOfArrays, int columnIndex) {
        double sum = 0;
        int count = 0;
        StringBuilder values = new StringBuilder();
        for (double[] array : arrayOfArrays) {
            double value = array[columnIndex];

            values.append(value).append(' ');
            if (value == NA) {
                continue;
            }
            sum += value;
            count++;
        }
        // omit calculation if no data points
        double average = count == 0 ? NA : (double) (sum / count);

        String logMessage = ""Average("" + values.toString().trim() + "") = "" + average;
        log.fine(replaceMagicNumbers(logMessage));

        return average;
    }

    public static String pointsToString(int[][] array) {
        return pointsToString(intToDouble(array)).replace("".0"", """");
    }

    private String pointsToString(int[] input) {
        return replaceMagicNumbers(Arrays.toString(input)) + Const.EOL;
    }

    public static String pointsToString(double[][] array) {
        StringBuilder returnValue = new StringBuilder();
        boolean isSquareArray = array.length == array[0].length;
        int teamSize = (array.length - 1) / 3;
        int firstDividerLocation = teamSize - 1;
        int secondDividerLocation = teamSize * 2 - 1;
        int thirdDividerLocation = secondDividerLocation + 1;
        for (int i = 0; i < array.length; i++) {
            returnValue.append(Arrays.toString(array[i])).append(Const.EOL);
            if (isSquareArray) {
                continue;
            }
            if (i == firstDividerLocation || i == secondDividerLocation || i == thirdDividerLocation) {
                returnValue.append(""======================="")
                           .append(Const.EOL);
            }
        }
        return replaceMagicNumbers(returnValue.toString());
    }

    /** replaces 999 etc. with NA, NSB, NSU etc.
     */
    public static String replaceMagicNumbers(String returnValue) {
        return returnValue.replace(NA + "".0"", "" NA"")
                          .replace(Integer.toString(NA), "" NA"")
                          .replace(NSB + "".0"", ""NSB"")
                          .replace(NSU + "".0"", ""NSU"");
    }

    @Override
    public String toString() {
        return toString(0);
    }

    public String toString(int indent) {
        String indentString = StringHelper.getIndent(indent);
        String divider = ""======================"" + Const.EOL;
        StringBuilder sb = new StringBuilder(200);
        sb.append(""           claimed from student:"");
        String filler = ""                                "";
        sb.append(indentString)
          .append(pointsToString(claimed).replace(Const.EOL,
                        Const.EOL + indentString + filler))
          .append(divider)
          .append(""              normalizedClaimed:"")
          .append(indentString)
          .append(pointsToString(normalizedClaimed).replace(Const.EOL,
                        Const.EOL + indentString + filler))
          .append(divider)
          .append(""normalizedPeerContributionRatio:"")
          .append(indentString)
          .append(pointsToString(normalizedPeerContributionRatio).replace(
                        Const.EOL, Const.EOL + indentString + filler))
          .append(divider)
          .append(""     normalizedAveragePerceived:"")
          .append(indentString)
          .append(pointsToString(normalizedAveragePerceived).replace(
                        Const.EOL, Const.EOL + indentString + filler))
          .append(divider)

          .append(""   denormalizedAveragePerceived:"")
          .append(indentString)
          .append(pointsToString(denormalizedAveragePerceived).replace(
                        Const.EOL, Const.EOL + indentString + filler))
            .append(divider);
        return sb.toString();
    }

    private static void verify(String message, boolean condition) {
        // TODO: replace with Assumption.assert*
        if (!condition) {
            throw new RuntimeException(""Internal assertion failuer : ""
                    + message);
        }
    }

}
"
UserRole.java,data-transfer,"package teammates.common.datatransfer;

/**
 * Represents the role played by the user. e.g. when loading
 * instructorHomePage, the user is playing the role INSTRUCTOR
 */
public enum UserRole {
    ADMIN, INSTRUCTOR, STUDENT
}
"
UserType.java,data-transfer,"package teammates.common.datatransfer;

import com.google.appengine.api.users.User;

/**
 * Represents a user type.
 * <br> Contains user's Google ID and flags to indicate whether the user
 *  is an admin, instructor, student.
 */
public class UserType {

    //TODO: add a com.google.appengine.api.users.User object here
    public String id;

    public boolean isAdmin;
    public boolean isInstructor;
    public boolean isStudent;

    public UserType(String googleId) {
        this.id = googleId;
    }

    public UserType(User user) {
        this.id = user.getNickname();
    }
}
"
Account.java,entity,"package teammates.storage.entity;

import java.util.Date;

import com.googlecode.objectify.Ref;
import com.googlecode.objectify.annotation.Entity;
import com.googlecode.objectify.annotation.Id;
import com.googlecode.objectify.annotation.Ignore;
import com.googlecode.objectify.annotation.Index;

/**
 * Represents a unique user in the system.
 */
@Entity
@Index
public class Account extends BaseEntity {

    @Id
    private String googleId;

    private String name;

    private boolean isInstructor;

    private String email;

    private String institute;

    private Date createdAt;

    private Ref<StudentProfile> studentProfile;

    @Ignore // used in local attribute tests that give a shell student profile (empty googleId)
    private StudentProfile localStudentProfile;

    @Ignore // session-specific based on whether profile retrieval is enabled
    private boolean isStudentProfileEnabled = true;

    @SuppressWarnings(""unused"") // required by Objectify
    private Account() {
    }

    /**
     * Instantiates a new account.
     *
     * @param googleId
     *            the Google ID of the user.
     * @param name
     *            The name of the user.
     * @param isInstructor
     *            Does this account has instructor privileges?
     * @param email
     *            The official email of the user.
     * @param institute
     *            The university/school/institute e.g., ""Abrons State University, Alaska""
     * @param studentProfile
     *            It is a StudentProfile object that contains all the attributes
     *            of a student profile
     */
    public Account(String googleId, String name, boolean isInstructor,
            String email, String institute, StudentProfile studentProfile) {
        this.setGoogleId(googleId);
        this.setName(name);
        this.setIsInstructor(isInstructor);
        this.setEmail(email);
        this.setInstitute(institute);
        this.setCreatedAt(new Date());
        this.setStudentProfile(studentProfile);
    }

    public Account(String googleId, String name, boolean isInstructor,
            String email, String institute) {
        this(googleId, name, isInstructor, email, institute, new StudentProfile(googleId));
    }

    public String getGoogleId() {
        return googleId;
    }

    public void setGoogleId(String googleId) {
        this.googleId = googleId;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public boolean isInstructor() {
        return isInstructor;
    }

    public void setIsInstructor(boolean accountIsInstructor) {
        this.isInstructor = accountIsInstructor;
    }

    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }

    public String getInstitute() {
        return institute;
    }

    public void setInstitute(String institute) {
        this.institute = institute;
    }

    public Date getCreatedAt() {
        return createdAt;
    }

    public void setCreatedAt(Date createdAt) {
        this.createdAt = createdAt;
    }

    /**
     * Fetches the student profile from the datastore the first time this is called. Returns null if student profile was
     * explicitly set to null (e.g. when the student profile is intentionally not retrieved). If a shell student profile
     * with an empty Google ID was set, simply returns this shell student profile without interacting with the datastore.
     */
    public StudentProfile getStudentProfile() {
        if (!isStudentProfileEnabled) {
            return null;
        }
        if (localStudentProfile != null && localStudentProfile.getGoogleId().isEmpty()) { // only in local attribute tests
            return localStudentProfile;
        }
        if (studentProfile == null) {
            return null;
        }
        return studentProfile.get();
    }

    /**
     * Sets a reference to {@code studentProfile} which subsequent calls to {@code getStudentProfile()} will use to fetch
     * from. To disable this behaviour (e.g. when the student profile is intentionally not retrieved), set to null. If a
     * shell student profile with an empty Google ID is set, subsequent calls to {@code getStudentProfile()} will simply
     * return the shell student profile without interacting with the datastore.
     */
    public void setStudentProfile(StudentProfile studentProfile) {
        if (studentProfile == null) {
            setIsStudentProfileEnabled(false);
            return;
        }
        setIsStudentProfileEnabled(true);
        if (studentProfile.getGoogleId().isEmpty()) { // only in local attribute tests
            this.localStudentProfile = studentProfile;
            return;
        }
        this.studentProfile = Ref.create(studentProfile);
    }

    /**
     * Sets whether or not the student profile fetch should be enabled. When the entity is fetched from the local cache,
     * this value might be outdated as it is preserved from the previous session. Hence, this property should be set on
     * every new session (every call that gets the entity).
     */
    public void setIsStudentProfileEnabled(boolean isStudentProfileEnabled) {
        this.isStudentProfileEnabled = isStudentProfileEnabled;
    }
}
"
AdminEmail.java,entity,"package teammates.storage.entity;

import java.util.ArrayList;
import java.util.Date;
import java.util.List;

import com.google.appengine.api.datastore.Text;

import com.googlecode.objectify.Key;
import com.googlecode.objectify.annotation.Entity;
import com.googlecode.objectify.annotation.Id;
import com.googlecode.objectify.annotation.Index;
import com.googlecode.objectify.annotation.Unindex;

/**
 * Represents emails composed by Admin.
 */
@Entity
@Index
public class AdminEmail extends BaseEntity {

    @Id
    private Long emailId;

    //this stores the address string eg.""example1@test.com,example2@test.com....""
    private List<String> addressReceiver = new ArrayList<>();

    //this stores the blobkey string of the email list file uploaded to Google Cloud Storage
    private List<String> groupReceiver = new ArrayList<>();

    private String subject;

    //For draft emails,this is null. For sent emails, this is not null;
    private Date sendDate;

    private Date createDate;

    @Unindex
    private Text content;

    private boolean isInTrashBin;

    @SuppressWarnings(""unused"") // required by Objectify
    private AdminEmail() {
    }

    /**
     * Instantiates a new AdminEmail.
     * @param subject
     *          email subject
     * @param content
     *          html email content
     */
    public AdminEmail(List<String> addressReceiver, List<String> groupReceiver, String subject,
                      Text content, Date sendDate) {
        this.emailId = null;
        this.addressReceiver = addressReceiver == null ? new ArrayList<String>() : addressReceiver;
        this.groupReceiver = groupReceiver == null ? new ArrayList<String>() : groupReceiver;
        this.subject = subject;
        this.content = content;
        this.sendDate = sendDate;
        this.createDate = new Date();
        this.isInTrashBin = false;
    }

    public void setAddressReceiver(List<String> receiver) {
        this.addressReceiver = receiver;
    }

    public void setGroupReceiver(List<String> receiver) {
        this.groupReceiver = receiver;
    }

    public void setSubject(String subject) {
        this.subject = subject;
    }

    public void setContent(Text content) {
        this.content = content;
    }

    public void setIsInTrashBin(boolean isInTrashBin) {
        this.isInTrashBin = isInTrashBin;
    }

    public void setSendDate(Date sendDate) {
        this.sendDate = sendDate;
    }

    public String getEmailId() {
        return Key.create(AdminEmail.class, this.emailId).toWebSafeString();
    }

    public List<String> getAddressReceiver() {
        return this.addressReceiver;
    }

    public List<String> getGroupReceiver() {
        return this.groupReceiver;
    }

    public String getSubject() {
        return this.subject;
    }

    public Date getSendDate() {
        return this.sendDate;
    }

    public Text getContent() {
        return this.content;
    }

    public boolean getIsInTrashBin() {
        return this.isInTrashBin;
    }

    public Date getCreateDate() {
        return this.createDate;
    }
}
"
BaseEntity.java,entity,"package teammates.storage.entity;

/**
 * Base class for all entities persisted to the Datastore.
 */
public abstract class BaseEntity { // NOPMD
}
"
Course.java,entity,"package teammates.storage.entity;

import java.util.Date;

import com.googlecode.objectify.annotation.Entity;
import com.googlecode.objectify.annotation.Id;
import com.googlecode.objectify.annotation.Index;

import teammates.common.util.Const;

/**
 * Represents a course entity.
 */
@Entity
@Index
public class Course extends BaseEntity {

    @Id
    private String id;

    private String name;

    private Date createdAt;

    private String timeZone;

    @SuppressWarnings(""unused"") // required by Objectify
    private Course() {
    }

    public Course(String courseId, String courseName, String courseTimeZone, Date createdAt) {
        this.setUniqueId(courseId);
        this.setName(courseName);
        if (courseTimeZone == null) {
            this.setTimeZone(Const.DEFAULT_TIMEZONE);
        } else {
            this.setTimeZone(courseTimeZone);
        }
        if (createdAt == null) {
            this.setCreatedAt(new Date());
        } else {
            this.setCreatedAt(createdAt);
        }
    }

    public String getUniqueId() {
        return id;
    }

    public void setUniqueId(String uniqueId) {
        this.id = uniqueId.trim();
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name.trim();
    }

    public Date getCreatedAt() {
        return this.createdAt;
    }

    public void setCreatedAt(Date createdAt) {
        this.createdAt = createdAt;
    }

    public String getTimeZone() {
        return timeZone;
    }

    public void setTimeZone(String timeZone) {
        this.timeZone = timeZone;
    }
}
"
CourseStudent.java,entity,"package teammates.storage.entity;

import java.security.SecureRandom;
import java.util.Date;

import com.google.gson.annotations.SerializedName;

import com.googlecode.objectify.annotation.Entity;
import com.googlecode.objectify.annotation.Id;
import com.googlecode.objectify.annotation.Ignore;
import com.googlecode.objectify.annotation.Index;
import com.googlecode.objectify.annotation.OnSave;
import com.googlecode.objectify.annotation.Unindex;

import teammates.common.util.Assumption;
import teammates.common.util.StringHelper;

/**
 * An association class that represents the association Account -->
 * [enrolled in] --> Course.
 */
@Entity
@Index
public class CourseStudent extends BaseEntity {

    /**
     * Setting this to true prevents changes to the lastUpdate time stamp.
     * Set to true when using scripts to update entities when you want to
     * preserve the lastUpdate time stamp.
     **/
    @Ignore
    public transient boolean keepUpdateTimestamp;

    /**
     * ID of the student.
     *
     * @see #makeId()
     */
    @Id
    private String id;

    private Date createdAt;

    private Date updatedAt;

    private transient String registrationKey;

    /**
     * The student's Google ID. Links to the Account object.
     * This can be null if the student hasn't joined the course yet.
     */
    @SerializedName(""google_id"")
    private String googleId;

    @SerializedName(""email"")
    private String email;

    /**
     * The student's Course ID. References the primary key of the course.
     */
    @SerializedName(""coursename"")
    private String courseId;

    @Unindex
    @SerializedName(""name"")
    private String name;

    @Unindex
    @SerializedName(""lastName"")
    private String lastName;

    @Unindex
    private String comments;

    @SerializedName(""teamname"")
    private String teamName;

    @SerializedName(""sectionname"")
    private String sectionName;

    @SuppressWarnings(""unused"") // required by Objectify
    private CourseStudent() {
    }

    public CourseStudent(String email, String name, String googleId, String comments, String courseId,
                         String teamName, String sectionName) {
        setEmail(email);
        setName(name);
        setGoogleId(googleId);
        setComments(comments);
        setCourseId(courseId);
        setTeamName(teamName);
        setSectionName(sectionName);

        setCreatedAt(new Date());

        this.id = makeId();
        registrationKey = generateRegistrationKey();
    }

    private String makeId() {
        return getEmail() + '%' + getCourseId();
    }

    public Date getCreatedAt() {
        return createdAt;
    }

    public void setCreatedAt(Date created) {
        this.createdAt = created;
        setLastUpdate(created);
    }

    public Date getUpdatedAt() {
        return updatedAt;
    }

    public void setLastUpdate(Date updatedAt) {
        if (!keepUpdateTimestamp) {
            this.updatedAt = updatedAt;
        }
    }

    public String getUniqueId() {
        return this.id;
    }

    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email.trim();
    }

    public String getGoogleId() {
        return googleId;
    }

    public void setGoogleId(String googleId) {
        this.googleId = googleId == null ? null : googleId.trim();
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        String trimmedName = name.trim();
        String processedFullName = StringHelper.splitName(trimmedName)[2];
        this.name = processedFullName.trim();
        this.setLastName(StringHelper.splitName(trimmedName)[1]);
    }

    public void setLastName(String lastName) {
        this.lastName = lastName.trim();
    }

    public String getLastName() {
        // for legacy data. do not remove even if not covered in test.
        if (this.lastName == null) {
            this.lastName = StringHelper.splitName(this.name)[1];
        }
        return lastName;
    }

    public String getComments() {
        return comments;
    }

    public void setComments(String comments) {
        this.comments = comments == null ? null : comments.trim();
    }

    public String getRegistrationKey() {
        return registrationKey;
    }

    public String getCourseId() {
        return courseId;
    }

    public void setCourseId(String courseId) {
        this.courseId = courseId.trim();
    }

    public String getTeamName() {
        return teamName;
    }

    public void setTeamName(String teamName) {
        this.teamName = teamName == null ? null : teamName.trim();
    }

    public String getSectionName() {
        return sectionName;
    }

    public void setSectionName(String sectionName) {
        this.sectionName = sectionName == null ? null : sectionName.trim();
    }

    @OnSave
    public void updateLastUpdateTimestamp() {
        this.setLastUpdate(new Date());
    }

    /**
     * Returns unique registration key for the student.
     */
    private String generateRegistrationKey() {
        String uniqueId = getUniqueId();
        Assumption.assertNotNull(uniqueId);

        SecureRandom prng = new SecureRandom();
        return uniqueId + ""%"" + prng.nextInt();
    }
}
"
FeedbackQuestion.java,entity,"package teammates.storage.entity;

import java.util.ArrayList;
import java.util.Date;
import java.util.List;

import com.google.appengine.api.datastore.Text;

import com.googlecode.objectify.Key;
import com.googlecode.objectify.annotation.Entity;
import com.googlecode.objectify.annotation.Id;
import com.googlecode.objectify.annotation.Ignore;
import com.googlecode.objectify.annotation.Index;
import com.googlecode.objectify.annotation.OnSave;

import teammates.common.datatransfer.FeedbackParticipantType;
import teammates.common.datatransfer.questions.FeedbackQuestionType;
import teammates.common.util.Const;

/**
 * Represents a feedback question.
 */
@Entity
@Index
public class FeedbackQuestion extends BaseEntity {

    // TODO: where applicable, we should specify fields as @Unindex to prevent GAE from building unnecessary indexes.

    /**
     * Setting this to true prevents changes to the lastUpdate time stamp. Set
     * to true when using scripts to update entities when you want to preserve
     * the lastUpdate time stamp.
     **/
    @Ignore
    public boolean keepUpdateTimestamp;

    @Id
    private Long feedbackQuestionId;

    private String feedbackSessionName;

    private String courseId;

    // TODO: Do we need this field since creator of FS = creator of qn? (can be removed -damith)
    private String creatorEmail;

    // TODO: rename to questionMetaData, will require database conversion
    private Text questionText;

    private Text questionDescription;

    private int questionNumber;

    private FeedbackQuestionType questionType;

    private FeedbackParticipantType giverType;

    private FeedbackParticipantType recipientType;

    // Check for consistency in questionLogic/questionAttributes.
    // (i.e. if type is own team, numberOfEntities must = 1).
    private int numberOfEntitiesToGiveFeedbackTo;

    private List<FeedbackParticipantType> showResponsesTo = new ArrayList<>();

    private List<FeedbackParticipantType> showGiverNameTo = new ArrayList<>();

    private List<FeedbackParticipantType> showRecipientNameTo = new ArrayList<>();

    private Date createdAt;

    private Date updatedAt;

    @SuppressWarnings(""unused"") // required by Objectify
    private FeedbackQuestion() {
    }

    public FeedbackQuestion(
            String feedbackSessionName, String courseId, String creatorEmail,
            Text questionText, Text questionDescription, int questionNumber, FeedbackQuestionType questionType,
            FeedbackParticipantType giverType,
            FeedbackParticipantType recipientType,
            int numberOfEntitiesToGiveFeedbackTo,
            List<FeedbackParticipantType> showResponsesTo,
            List<FeedbackParticipantType> showGiverNameTo,
            List<FeedbackParticipantType> showRecipientNameTo) {

        this.feedbackQuestionId = null; // Allow GAE to generate key.
        this.feedbackSessionName = feedbackSessionName;
        this.courseId = courseId;
        this.creatorEmail = creatorEmail;
        this.questionText = questionText;
        this.questionDescription = questionDescription;
        this.questionNumber = questionNumber;
        this.questionType = questionType;
        this.giverType = giverType;
        this.recipientType = recipientType;
        this.numberOfEntitiesToGiveFeedbackTo = numberOfEntitiesToGiveFeedbackTo;
        this.showResponsesTo = showResponsesTo == null ? new ArrayList<FeedbackParticipantType>() : showResponsesTo;
        this.showGiverNameTo = showGiverNameTo == null ? new ArrayList<FeedbackParticipantType>() : showGiverNameTo;
        this.showRecipientNameTo =
                showRecipientNameTo == null ? new ArrayList<FeedbackParticipantType>() : showRecipientNameTo;
        this.setCreatedAt(new Date());
    }

    public Date getCreatedAt() {
        return createdAt == null ? Const.TIME_REPRESENTS_DEFAULT_TIMESTAMP : createdAt;
    }

    public Date getUpdatedAt() {
        return updatedAt == null ? Const.TIME_REPRESENTS_DEFAULT_TIMESTAMP : updatedAt;
    }

    public void setCreatedAt(Date newDate) {
        this.createdAt = newDate;
        setLastUpdate(newDate);
    }

    public void setLastUpdate(Date newDate) {
        if (!keepUpdateTimestamp) {
            this.updatedAt = newDate;
        }
    }

    public String getId() {
        return Key.create(FeedbackQuestion.class, feedbackQuestionId).toWebSafeString();
    }

    public String getFeedbackSessionName() {
        return feedbackSessionName;
    }

    public void setFeedbackSessionName(String feedbackSessionName) {
        this.feedbackSessionName = feedbackSessionName;
    }

    public String getCourseId() {
        return courseId;
    }

    public void setCourseId(String courseId) {
        this.courseId = courseId;
    }

    public String getCreatorEmail() {
        return creatorEmail;
    }

    public void setCreatorEmail(String creatorEmail) {
        this.creatorEmail = creatorEmail;
    }

    public Text getQuestionMetaData() {
        return questionText;
    }

    public void setQuestionText(Text questionText) {
        this.questionText = questionText;
    }

    public Text getQuestionDescription() {
        return questionDescription;
    }

    public void setQuestionDescription(Text questionDescription) {
        this.questionDescription = questionDescription;
    }

    public FeedbackQuestionType getQuestionType() {
        return questionType;
    }

    public void setQuestionType(FeedbackQuestionType questionType) {
        this.questionType = questionType;
    }

    public int getQuestionNumber() {
        return questionNumber;
    }

    public void setQuestionNumber(int questionNumber) {
        this.questionNumber = questionNumber;
    }

    public FeedbackParticipantType getGiverType() {
        return giverType;
    }

    public void setGiverType(FeedbackParticipantType giverType) {
        this.giverType = giverType;
    }

    public FeedbackParticipantType getRecipientType() {
        return recipientType;
    }

    public void setRecipientType(FeedbackParticipantType recipientType) {
        this.recipientType = recipientType;
    }

    public int getNumberOfEntitiesToGiveFeedbackTo() {
        return numberOfEntitiesToGiveFeedbackTo;
    }

    public void setNumberOfEntitiesToGiveFeedbackTo(
            int numberOfEntitiesToGiveFeedbackTo) {
        this.numberOfEntitiesToGiveFeedbackTo = numberOfEntitiesToGiveFeedbackTo;
    }

    public List<FeedbackParticipantType> getShowResponsesTo() {
        return showResponsesTo;
    }

    public void setShowResponsesTo(List<FeedbackParticipantType> showResponsesTo) {
        this.showResponsesTo = showResponsesTo;
    }

    public List<FeedbackParticipantType> getShowGiverNameTo() {
        return showGiverNameTo;
    }

    public void setShowGiverNameTo(List<FeedbackParticipantType> showGiverNameTo) {
        this.showGiverNameTo = showGiverNameTo;
    }

    public List<FeedbackParticipantType> getShowRecipientNameTo() {
        return showRecipientNameTo;
    }

    public void setShowRecipientNameTo(
            List<FeedbackParticipantType> showRecipientNameTo) {
        this.showRecipientNameTo = showRecipientNameTo;
    }

    @OnSave
    public void updateLastUpdateTimestamp() {
        this.setLastUpdate(new Date());
    }
}
"
FeedbackResponse.java,entity,"package teammates.storage.entity;

import java.util.Date;

import com.google.appengine.api.datastore.Text;

import com.googlecode.objectify.annotation.Entity;
import com.googlecode.objectify.annotation.Id;
import com.googlecode.objectify.annotation.Ignore;
import com.googlecode.objectify.annotation.Index;
import com.googlecode.objectify.annotation.OnSave;

import teammates.common.datatransfer.questions.FeedbackQuestionType;
import teammates.common.util.Const;

/**
 * Represents a feedback response.
 */
@Entity
@Index
public class FeedbackResponse extends BaseEntity {

    /**
     * Setting this to true prevents changes to the lastUpdate time stamp. Set
     * to true when using scripts to update entities when you want to preserve
     * the lastUpdate time stamp.
     **/
    @Ignore
    public boolean keepUpdateTimestamp;

    // Format is feedbackQuestionId%giverEmail%receiver
    // i.e. if response is feedback for team: qnId%giver@gmail.com%Team1
    //         if response is feedback for person: qnId%giver@gmail.com%reciever@email.com
    @Id
    private String feedbackResponseId;

    private String feedbackSessionName;

    private String courseId;

    private String feedbackQuestionId;

    private FeedbackQuestionType feedbackQuestionType;

    private String giverEmail;

    private String giverSection;

    private String receiver;

    private String receiverSection;

    private Text answer; //TODO: rename to responseMetaData, will require database conversion

    private Date createdAt;

    private Date updatedAt;

    @SuppressWarnings(""unused"") // required by Objectify
    private FeedbackResponse() {
    }

    public FeedbackResponse(String feedbackSessionName, String courseId,
            String feedbackQuestionId, FeedbackQuestionType feedbackQuestionType,
            String giverEmail, String giverSection, String recipient, String recipientSection, Text answer) {
        this.feedbackSessionName = feedbackSessionName;
        this.courseId = courseId;
        this.feedbackQuestionId = feedbackQuestionId;
        this.feedbackQuestionType = feedbackQuestionType;
        this.giverEmail = giverEmail;
        this.giverSection = giverSection;
        this.receiver = recipient;
        this.receiverSection = recipientSection;
        this.answer = answer;

        this.feedbackResponseId = feedbackQuestionId + ""%"" + giverEmail + ""%"" + receiver;

        this.setCreatedAt(new Date());
    }

    public String getId() {
        return feedbackResponseId;
    }

    public String getFeedbackSessionName() {
        return feedbackSessionName;
    }

    public void setFeedbackSessionName(String feedbackSessionName) {
        this.feedbackSessionName = feedbackSessionName;
    }

    public String getCourseId() {
        return courseId;
    }

    public void setCourseId(String courseId) {
        this.courseId = courseId;
    }

    public String getFeedbackQuestionId() {
        return feedbackQuestionId;
    }

    public void setFeedbackQuestionId(String feedbackQuestionId) {
        this.feedbackQuestionId = feedbackQuestionId;
    }

    public FeedbackQuestionType getFeedbackQuestionType() {
        return feedbackQuestionType;
    }

    public void setFeedbackQuestionType(FeedbackQuestionType feedbackQuestionType) {
        this.feedbackQuestionType = feedbackQuestionType;
    }

    public String getGiverEmail() {
        return giverEmail;
    }

    public void setGiverEmail(String giverEmail) {
        this.giverEmail = giverEmail;
    }

    public String getGiverSection() {
        return giverSection;
    }

    public void setGiverSection(String giverSection) {
        this.giverSection = giverSection;
    }

    public String getRecipientEmail() {
        return receiver;
    }

    public void setRecipientEmail(String receiverEmail) {
        this.receiver = receiverEmail;
    }

    public String getRecipientSection() {
        return receiverSection;
    }

    public void setRecipientSection(String recipientSection) {
        this.receiverSection = recipientSection;
    }

    public Text getResponseMetaData() {
        return answer;
    }

    public void setAnswer(Text answer) {
        this.answer = answer;
    }

    public Date getCreatedAt() {
        return createdAt == null ? Const.TIME_REPRESENTS_DEFAULT_TIMESTAMP : createdAt;
    }

    public Date getUpdatedAt() {
        return updatedAt == null ? Const.TIME_REPRESENTS_DEFAULT_TIMESTAMP : updatedAt;
    }

    public void setCreatedAt(Date newDate) {
        this.createdAt = newDate;
        setLastUpdate(newDate);
    }

    public void setLastUpdate(Date newDate) {
        if (!keepUpdateTimestamp) {
            this.updatedAt = newDate;
        }
    }

    @OnSave
    public void updateLastUpdateTimestamp() {
        this.setLastUpdate(new Date());
    }
}
"
FeedbackResponseComment.java,entity,"package teammates.storage.entity;

import java.util.ArrayList;
import java.util.Date;
import java.util.List;

import com.google.appengine.api.datastore.Text;

import com.googlecode.objectify.annotation.Entity;
import com.googlecode.objectify.annotation.Id;
import com.googlecode.objectify.annotation.Index;
import com.googlecode.objectify.annotation.Unindex;

import teammates.common.datatransfer.FeedbackParticipantType;
import teammates.common.util.SanitizationHelper;

/**
 * An association class that represents the association
 * Giver --> [comments about] --> FeedbackResponse.
 * Currently giver is restricted only to Instructors.
 */
@Entity
@Index
public class FeedbackResponseComment extends BaseEntity {

    @Id
    private transient Long feedbackResponseCommentId;

    /** The foreign key to locate the Course object. */
    private String courseId;

    /** The foreign key to locate the FeedbackSession object. */
    private String feedbackSessionName;

    /** The foreign key to locate the FeedbackQuestion object. */
    private String feedbackQuestionId;

    /** The course-specific email used by the giver of the comment. */
    private String giverEmail;

    /** The foreign key to locate the FeedbackResponse object commented on. */
    private String feedbackResponseId;

    /** Response giver section. */
    private String giverSection;

    /** Response receiver section. */
    private String receiverSection;

    private List<FeedbackParticipantType> showCommentTo = new ArrayList<>();

    private List<FeedbackParticipantType> showGiverNameTo = new ArrayList<>();

    private Boolean isVisibilityFollowingFeedbackQuestion;

    /** The creation time of this comment. */
    private Date createdAt;

    /** The comment from giver about the feedback response. */
    @Unindex
    private Text commentText;

    /** The e-mail of the account that last edited the comment. */
    private String lastEditorEmail;

    /** The time in which the comment is last edited. */
    private Date lastEditedAt;

    @SuppressWarnings(""unused"") // required by Objectify
    private FeedbackResponseComment() {
    }

    public FeedbackResponseComment(String courseId, String feedbackSessionName,
            String feedbackQuestionId, String giverEmail, String feedbackResponseId,
            Date createdAt, Text commentText,
            String giverSection, String receiverSection, List<FeedbackParticipantType> showCommentTo,
            List<FeedbackParticipantType> showGiverNameTo, String lastEditorEmail, Date lastEditedAt) {
        this.feedbackResponseCommentId = null; // Auto generated by GAE
        this.courseId = courseId;
        this.feedbackSessionName = feedbackSessionName;
        this.feedbackQuestionId = feedbackQuestionId;
        this.giverEmail = giverEmail;
        this.feedbackResponseId = feedbackResponseId;
        this.createdAt = createdAt;
        this.commentText = SanitizationHelper.sanitizeForRichText(commentText);
        this.giverSection = giverSection;
        this.receiverSection = receiverSection;
        this.showCommentTo = showCommentTo == null ? new ArrayList<FeedbackParticipantType>() : showCommentTo;
        this.showGiverNameTo = showGiverNameTo == null ? new ArrayList<FeedbackParticipantType>() : showGiverNameTo;
        this.isVisibilityFollowingFeedbackQuestion = false;
        this.lastEditorEmail = lastEditorEmail == null ? giverEmail : lastEditorEmail;
        this.lastEditedAt = lastEditedAt == null ? createdAt : lastEditedAt;
    }

    /**
     * Use only if the comment already persisted in the datastore and id generated by GAE.
     * @return the feedbackResponseCommentId
     */
    public Long getFeedbackResponseCommentId() {
        return feedbackResponseCommentId;
    }

    public String getCourseId() {
        return courseId;
    }

    public void setCourseId(String courseId) {
        this.courseId = courseId;
    }

    public String getFeedbackSessionName() {
        return feedbackSessionName;
    }

    public void setFeedbackSessionName(String feedbackSessionName) {
        this.feedbackSessionName = feedbackSessionName;
    }

    public String getFeedbackQuestionId() {
        return feedbackQuestionId;
    }

    public void setFeedbackQuestionId(String feedbackQuestionId) {
        this.feedbackQuestionId = feedbackQuestionId;
    }

    public Boolean getIsVisibilityFollowingFeedbackQuestion() {
        return this.isVisibilityFollowingFeedbackQuestion;
    }

    public void setIsVisibilityFollowingFeedbackQuestion(Boolean isVisibilityFollowingFeedbackQuestion) {
        this.isVisibilityFollowingFeedbackQuestion = isVisibilityFollowingFeedbackQuestion;
    }

    public String getGiverEmail() {
        return giverEmail;
    }

    /**
     * Sets the giver email of the response comment.
     *
     * @param giverEmail the giverEmail to set.
     *         This is the email used by the user in the course, not the one associated with the user's google account.
     */
    public void setGiverEmail(String giverEmail) {
        this.giverEmail = giverEmail;
    }

    public void setShowCommentTo(List<FeedbackParticipantType> showCommentTo) {
        this.showCommentTo = showCommentTo;
    }

    public List<FeedbackParticipantType> getShowCommentTo() {
        return showCommentTo;
    }

    public void setShowGiverNameTo(List<FeedbackParticipantType> showGiverNameTo) {
        this.showGiverNameTo = showGiverNameTo;
    }

    public List<FeedbackParticipantType> getShowGiverNameTo() {
        return showGiverNameTo;
    }

    public String getFeedbackResponseId() {
        return feedbackResponseId;
    }

    public void setFeedbackResponseId(String feedbackResponseId) {
        this.feedbackResponseId = feedbackResponseId;
    }

    public Date getCreatedAt() {
        return createdAt;
    }

    public void setCreatedAt(Date createdAt) {
        this.createdAt = createdAt;
    }

    public Text getCommentText() {
        return commentText;
    }

    public void setCommentText(Text commentText) {
        this.commentText = commentText;
    }

    public String getGiverSection() {
        return giverSection;
    }

    public void setGiverSection(String giverSection) {
        this.giverSection = giverSection;
    }

    public String getReceiverSection() {
        return receiverSection;
    }

    public void setReceiverSection(String receiverSection) {
        this.receiverSection = receiverSection;
    }

    public void setLastEditorEmail(String lastEditorEmail) {
        this.lastEditorEmail = lastEditorEmail;
    }

    public String getLastEditorEmail() {
        return this.lastEditorEmail;
    }

    public Date getLastEditedAt() {
        return this.lastEditedAt;
    }

    public void setLastEditedAt(Date lastEditedAt) {
        this.lastEditedAt = lastEditedAt;
    }
}
"
FeedbackSession.java,entity,"package teammates.storage.entity;

import java.util.Date;
import java.util.HashSet;
import java.util.Set;

import com.google.appengine.api.datastore.Text;

import com.googlecode.objectify.annotation.Entity;
import com.googlecode.objectify.annotation.Id;
import com.googlecode.objectify.annotation.Index;
import com.googlecode.objectify.annotation.Unindex;

import teammates.common.datatransfer.FeedbackSessionType;
import teammates.common.util.Const;

/**
 * Represents an instructor-created Feedback Session.
 */
@Entity
@Index
public class FeedbackSession extends BaseEntity {

    // Format is feedbackSessionName%courseId
    // PMD.UnusedPrivateField and SingularField are suppressed
    // as feedbackSessionId is persisted to the database
    @SuppressWarnings({""PMD.UnusedPrivateField"", ""PMD.SingularField""})
    @Id
    private transient String feedbackSessionId;

    private String feedbackSessionName;

    private String courseId;

    private String creatorEmail; //TODO: should this be googleId?

    @Unindex
    private Set<String> respondingInstructorList = new HashSet<>();

    @Unindex
    private Set<String> respondingStudentList = new HashSet<>();

    @Unindex
    private Text instructions;

    @Unindex
    private Date createdTime;

    private Date startTime;

    private Date endTime;

    @Unindex
    private Date sessionVisibleFromTime;

    @Unindex
    private Date resultsVisibleFromTime;

    /** This is legacy data that is no longer used. <br>
     * The value is set to Const.INT_UNINITIALIZED if it is already processed or
     * the old value if it hasn't. <br>
     * TODO Remove this field
     */
    @Unindex
    private int timeZone;

    /** This replaces the legacy field timeZone. <br>
     * The value is null for legacy data. <br>
     * TODO Rename to timeZone after removing legacy field
     */
    private Double timeZoneDouble;

    @Unindex
    private int gracePeriod;

    private FeedbackSessionType feedbackSessionType;

    private boolean sentOpenEmail;

    private Boolean sentClosingEmail;

    private Boolean sentClosedEmail;

    private boolean sentPublishedEmail;

    //TODO change to primitive types and update getter
    private Boolean isOpeningEmailEnabled;

    private Boolean isClosingEmailEnabled;

    private Boolean isPublishedEmailEnabled;

    @SuppressWarnings(""unused"") // required by Objectify
    private FeedbackSession() {
    }

    public FeedbackSession(String feedbackSessionName, String courseId,
            String creatorEmail, Text instructions, Date createdTime, Date startTime, Date endTime,
            Date sessionVisibleFromTime, Date resultsVisibleFromTime, double timeZone, int gracePeriod,
            FeedbackSessionType feedbackSessionType, boolean sentOpenEmail,
            boolean sentClosingEmail, boolean sentClosedEmail, boolean sentPublishedEmail,
            boolean isOpeningEmailEnabled, boolean isClosingEmailEnabled, boolean isPublishedEmailEnabled) {
        this(feedbackSessionName, courseId, creatorEmail, instructions, createdTime, startTime, endTime,
             sessionVisibleFromTime, resultsVisibleFromTime, timeZone, gracePeriod, feedbackSessionType,
             sentOpenEmail, sentClosingEmail, sentClosedEmail, sentPublishedEmail, isOpeningEmailEnabled,
             isClosingEmailEnabled, isPublishedEmailEnabled, new HashSet<String>(), new HashSet<String>());
    }

    public FeedbackSession(String feedbackSessionName, String courseId,
            String creatorEmail, Text instructions, Date createdTime, Date startTime, Date endTime,
            Date sessionVisibleFromTime, Date resultsVisibleFromTime, double timeZone, int gracePeriod,
            FeedbackSessionType feedbackSessionType, boolean sentOpenEmail, boolean sentClosingEmail,
            boolean sentClosedEmail, boolean sentPublishedEmail,
            boolean isOpeningEmailEnabled, boolean isClosingEmailEnabled, boolean isPublishedEmailEnabled,
            Set<String> instructorList, Set<String> studentList) {
        this.feedbackSessionName = feedbackSessionName;
        this.courseId = courseId;
        this.creatorEmail = creatorEmail;
        this.instructions = instructions;
        this.createdTime = createdTime;
        this.startTime = startTime;
        this.endTime = endTime;
        this.sessionVisibleFromTime = sessionVisibleFromTime;
        this.resultsVisibleFromTime = resultsVisibleFromTime;
        this.timeZone = Const.INT_UNINITIALIZED;
        this.timeZoneDouble = timeZone;
        this.gracePeriod = gracePeriod;
        this.feedbackSessionType = feedbackSessionType;
        this.sentOpenEmail = sentOpenEmail;
        this.sentClosingEmail = sentClosingEmail;
        this.sentClosedEmail = sentClosedEmail;
        this.sentPublishedEmail = sentPublishedEmail;
        this.isOpeningEmailEnabled = isOpeningEmailEnabled;
        this.isClosingEmailEnabled = isClosingEmailEnabled;
        this.isPublishedEmailEnabled = isPublishedEmailEnabled;
        this.feedbackSessionId = this.feedbackSessionName + ""%"" + this.courseId;
        this.respondingInstructorList = instructorList == null ? new HashSet<String>() : instructorList;
        this.respondingStudentList = studentList == null ? new HashSet<String>() : studentList;
    }

    public String getFeedbackSessionName() {
        return feedbackSessionName;
    }

    public void setFeedbackSessionName(String feedbackSessionName) {
        this.feedbackSessionName = feedbackSessionName;
    }

    public String getCourseId() {
        return courseId;
    }

    public void setCourseId(String courseId) {
        this.courseId = courseId;
    }

    public String getCreatorEmail() {
        return creatorEmail;
    }

    public void setCreatorEmail(String creatorId) {
        this.creatorEmail = creatorId;
    }

    public Text getInstructions() {
        return instructions;
    }

    public void setInstructions(Text instructions) {
        this.instructions = instructions;
    }

    public Date getCreatedTime() {
        return createdTime;
    }

    public void setCreatedTime(Date createdTime) {
        this.createdTime = createdTime;
    }

    public Date getStartTime() {
        return startTime;
    }

    public void setStartTime(Date startTime) {
        this.startTime = startTime;
    }

    public Date getEndTime() {
        return endTime;
    }

    public void setEndTime(Date endTime) {
        this.endTime = endTime;
    }

    public Date getSessionVisibleFromTime() {
        return sessionVisibleFromTime;
    }

    public void setSessionVisibleFromTime(Date sessionVisibleFromTime) {
        this.sessionVisibleFromTime = sessionVisibleFromTime;
    }

    public Date getResultsVisibleFromTime() {
        return resultsVisibleFromTime;
    }

    public void setResultsVisibleFromTime(Date resultsVisibleFromTime) {
        this.resultsVisibleFromTime = resultsVisibleFromTime;
    }

    /** This method automatically converts the legacy timeZone field to
     * the new timeZoneDouble field and returns the value of timeZoneDouble.
     */
    public double getTimeZone() {
        if (timeZone != Const.INT_UNINITIALIZED) {
            timeZoneDouble = Double.valueOf(timeZone);
            timeZone = Const.INT_UNINITIALIZED;
        }
        return timeZoneDouble;
    }

    /** This method automatically marks the timeZone field as legacy
     * and store the timeZone data to the new timeZoneDouble field.
     */
    public void setTimeZone(double timeZone) {
        this.timeZone = Const.INT_UNINITIALIZED;
        this.timeZoneDouble = timeZone;
    }

    public int getGracePeriod() {
        return gracePeriod;
    }

    public void setGracePeriod(int gracePeriod) {
        this.gracePeriod = gracePeriod;
    }

    public FeedbackSessionType getFeedbackSessionType() {
        return feedbackSessionType;
    }

    public void setFeedbackSessionType(FeedbackSessionType feedbackSessionType) {
        this.feedbackSessionType = feedbackSessionType;
    }

    public boolean isSentOpenEmail() {
        return sentOpenEmail;
    }

    public void setSentOpenEmail(boolean sentOpenEmail) {
        this.sentOpenEmail = sentOpenEmail;
    }

    public boolean isSentClosingEmail() {
        // Legacy data might not have this field
        if (sentClosingEmail == null) {
            return false;
        }
        return sentClosingEmail;
    }

    public void setSentClosingEmail(boolean sentClosingEmail) {
        this.sentClosingEmail = sentClosingEmail;
    }

    public boolean isSentClosedEmail() {
        // Legacy data might not have this field
        if (sentClosedEmail == null) {
            return false;
        }
        return sentClosedEmail;
    }

    public void setSentClosedEmail(boolean sentClosedEmail) {
        this.sentClosedEmail = sentClosedEmail;
    }

    public boolean isSentPublishedEmail() {
        return sentPublishedEmail;
    }

    public void setSentPublishedEmail(boolean sentPublishedEmail) {
        this.sentPublishedEmail = sentPublishedEmail;
    }

    public boolean isOpeningEmailEnabled() {
        // Legacy data might not have this field
        if (isOpeningEmailEnabled == null) {
            isOpeningEmailEnabled = true;
        }

        return isOpeningEmailEnabled.booleanValue();
    }

    public void setIsOpeningEmailEnabled(boolean isOpeningEmailEnabled) {
        this.isOpeningEmailEnabled = isOpeningEmailEnabled;
    }

    public boolean isClosingEmailEnabled() {
        // Legacy data might not have this field
        if (isClosingEmailEnabled == null) {
            isClosingEmailEnabled = true;
        }

        return isClosingEmailEnabled.booleanValue();
    }

    public void setSendClosingEmail(boolean isClosingEmailEnabled) {
        this.isClosingEmailEnabled = isClosingEmailEnabled;
    }

    public boolean isPublishedEmailEnabled() {
        // Legacy data might not have this field
        if (isPublishedEmailEnabled == null) {
            isPublishedEmailEnabled = true;
        }

        return isPublishedEmailEnabled.booleanValue();
    }

    public void setSendPublishedEmail(boolean isPublishedEmailEnabled) {
        this.isPublishedEmailEnabled = isPublishedEmailEnabled;
    }

    public Set<String> getRespondingInstructorList() {
        return this.respondingInstructorList;
    }

    public void setRespondingInstructorList(Set<String> instructorList) {
        this.respondingInstructorList = instructorList;
    }

    public Set<String> getRespondingStudentList() {
        return this.respondingStudentList;
    }

    public void setRespondingStudentList(Set<String> studentList) {
        this.respondingStudentList = studentList;
    }

    @Override
    public String toString() {
        return ""FeedbackSession [feedbackSessionName="" + feedbackSessionName
                + "", courseId="" + courseId + "", creatorId="" + creatorEmail
                + "", instructions="" + instructions + "", createdTime=""
                + createdTime + "", startTime="" + startTime + "", endTime=""
                + endTime + "", sessionVisibleFromTime=""
                + sessionVisibleFromTime + "", resultsVisibleFromTime=""
                + resultsVisibleFromTime + "", timeZone="" + timeZone
                + "", gracePeriod="" + gracePeriod + "", feedbackSessionType=""
                + feedbackSessionType + "", sentOpenEmail="" + sentOpenEmail
                + "", sentPublishedEmail="" + sentPublishedEmail
                + "", isOpeningEmailEnabled="" + isOpeningEmailEnabled
                + "", isClosingEmailEnabled="" + isClosingEmailEnabled
                + "", isPublishedEmailEnabled="" + isPublishedEmailEnabled + ""]"";
    }

}
"
Instructor.java,entity,"package teammates.storage.entity;

import java.security.SecureRandom;

import com.google.appengine.api.datastore.Text;

import com.googlecode.objectify.annotation.Entity;
import com.googlecode.objectify.annotation.Id;
import com.googlecode.objectify.annotation.Index;
import com.googlecode.objectify.annotation.Unindex;

/**
 * An association class that represents the association Account
 * --> [is an instructor for] --> Course.
 */
@Entity
@Index
public class Instructor extends BaseEntity {

    /**
     * The primary key. Format: email%courseId e.g., adam@gmail.com%cs1101
     */
    @Id
    private String id;

    /**
     * The Google id of the instructor, used as the foreign key to locate the Account object.
     */
    private String googleId;

    /** The foreign key to locate the Course object. */
    private String courseId;

    /** new attribute. Default value: Old Entity--null  New Entity--false*/
    private Boolean isArchived;

    /** The instructor's name used for this course. */
    private String name;

    /** The instructor's email used for this course. */
    private String email;

    /** The instructor's registration key used for joining. */
    private String registrationKey;

    @Unindex
    private String role;

    @Unindex
    private Boolean isDisplayedToStudents;

    @Unindex
    private String displayedName;

    private Text instructorPrivilegesAsText;

    @SuppressWarnings(""unused"") // required by Objectify
    private Instructor() {
    }

    public Instructor(String instructorGoogleId, String courseId, Boolean isArchived, String instructorName,
                      String instructorEmail, String role, boolean isDisplayedToStudents, String displayedName,
                      String instructorPrivilegesAsText) {
        this.setGoogleId(instructorGoogleId);
        this.setCourseId(courseId);
        this.setIsArchived(isArchived);
        this.setName(instructorName);
        this.setEmail(instructorEmail);
        this.setRole(role);
        this.setIsDisplayedToStudents(isDisplayedToStudents);
        this.setDisplayedName(displayedName);
        this.setInstructorPrivilegeAsText(instructorPrivilegesAsText);
        // setId should be called after setting email and courseId
        this.setUniqueId(this.getEmail() + '%' + this.getCourseId());
        this.setRegistrationKey(generateRegistrationKey());
    }

    /**
     * Constructor used for testing purpose only.
     */
    public Instructor(String instructorGoogleId, String courseId, Boolean isArchived, String instructorName,
                      String instructorEmail, String key, String role, boolean isDisplayedToStudents,
                      String displayedName, String instructorPrivilegesAsText) {
        this.setGoogleId(instructorGoogleId);
        this.setCourseId(courseId);
        this.setIsArchived(isArchived);
        this.setName(instructorName);
        this.setEmail(instructorEmail);
        this.setRole(role);
        this.setIsDisplayedToStudents(isDisplayedToStudents);
        this.setDisplayedName(displayedName);
        this.setInstructorPrivilegeAsText(instructorPrivilegesAsText);
        // setId should be called after setting email and courseId
        this.setUniqueId(this.getEmail() + '%' + this.getCourseId());
        this.setRegistrationKey(key);
    }

    /**
     * Returns the unique ID of the entity (format: googleId%courseId).
     */
    public String getUniqueId() {
        return id;
    }

    /**
     * Sets the unique ID for the instructor entity.
     *
     * @param uniqueId
     *          The unique ID of the entity (format: googleId%courseId).
     */
    public void setUniqueId(String uniqueId) {
        this.id = uniqueId;
    }

    public String getGoogleId() {
        return googleId;
    }

    public void setGoogleId(String instructorGoogleId) {
        this.googleId = instructorGoogleId;
    }

    public String getCourseId() {
        return courseId;
    }

    public void setCourseId(String courseId) {
        this.courseId = courseId;
    }

    public Boolean getIsArchived() {
        return isArchived;
    }

    public void setIsArchived(Boolean isArchived) {
        this.isArchived = isArchived;
    }

    public String getName() {
        return name;
    }

    public void setName(String instructorName) {
        this.name = instructorName;
    }

    public String getEmail() {
        return email;
    }

    public void setEmail(String instructorEmail) {
        this.email = instructorEmail;
    }

    public String getRegistrationKey() {
        return registrationKey;
    }

    public void setRegistrationKey(String key) {
        this.registrationKey = key;
    }

    public void setGeneratedKeyIfNull() {
        if (this.registrationKey == null) {
            setRegistrationKey(generateRegistrationKey());
        }
    }

    /**
     * Generate unique registration key for the instructor.
     * The key contains random elements to avoid being guessed.
     */
    private String generateRegistrationKey() {
        String uniqueId = getUniqueId();
        SecureRandom prng = new SecureRandom();

        return uniqueId + prng.nextInt();
    }

    public String getRole() {
        return role;
    }

    public void setRole(String role) {
        this.role = role;
    }

    public boolean isDisplayedToStudents() {
        if (this.isDisplayedToStudents == null) {
            return true;
        }
        return isDisplayedToStudents;
    }

    public void setIsDisplayedToStudents(boolean shouldDisplayToStudents) {
        this.isDisplayedToStudents = shouldDisplayToStudents;
    }

    public String getDisplayedName() {
        return displayedName;
    }

    public void setDisplayedName(String displayedName) {
        this.displayedName = displayedName;
    }

    public String getInstructorPrivilegesAsText() {
        if (instructorPrivilegesAsText == null) {
            return null;
        }
        return instructorPrivilegesAsText.getValue();
    }

    public void setInstructorPrivilegeAsText(String instructorPrivilegesAsText) {
        this.instructorPrivilegesAsText = new Text(instructorPrivilegesAsText);
    }
}
"
package-info.java,entity,"/**
 * Contains classes that represent persistable entities.
 */
package teammates.storage.entity;
"
StudentProfile.java,entity,"package teammates.storage.entity;

import java.util.Date;

import com.google.appengine.api.blobstore.BlobKey;
import com.google.appengine.api.datastore.Text;

import com.googlecode.objectify.Key;
import com.googlecode.objectify.annotation.Entity;
import com.googlecode.objectify.annotation.Id;
import com.googlecode.objectify.annotation.Index;
import com.googlecode.objectify.annotation.Parent;
import com.googlecode.objectify.annotation.Unindex;

/**
 * Represents profile details for student entities associated with an
 * account entity.
 */
@Entity
@Unindex
public class StudentProfile extends BaseEntity {

    @Parent
    private Key<Account> account; // NOPMD - specifies parent as Account; used by Objectify

    @Id
    private String googleId;

    private String shortName;

    private String email;

    private String institute;

    private String nationality;

    /* only accepts ""male"", ""female"" or ""other"" */
    private String gender;

    /* must be html sanitized before saving */
    private Text moreInfo;

    private BlobKey pictureKey;

    @Index
    private Date modifiedDate;

    @SuppressWarnings(""unused"") // required by Objectify
    private StudentProfile() {
    }

    /**
     * Instantiates a new account.
     *
     * @param googleId
     *            the Google ID of the user.
     * @param shortName
     *            The shortened name of the user.
     * @param email
     *            The long-term (personal) email of the user.
     * @param institute
     *            The university/school/institute the student is from (useful
     *            for exchange students)
     * @param nationality
     *            The nationality the student is from (useful for
     *            exchange/foreign students)
     * @param gender
     *            The student's gender. Allows ""other""
     * @param moreInfo
     *            Miscellaneous information, including external profile
     */
    public StudentProfile(String googleId, String shortName, String email, String institute,
                          String nationality, String gender, Text moreInfo, BlobKey pictureKey) {
        this.setGoogleId(googleId);
        this.setShortName(shortName);
        this.setEmail(email);
        this.setInstitute(institute);
        this.setNationality(nationality);
        this.setGender(gender);
        this.setMoreInfo(moreInfo);
        this.setModifiedDate(new Date());
        this.setPictureKey(pictureKey);
    }

    public StudentProfile(String googleId) {
        this.setGoogleId(googleId);
        this.setShortName("""");
        this.setEmail("""");
        this.setInstitute("""");
        this.setNationality("""");
        this.setGender(""other"");
        this.setMoreInfo(new Text(""""));
        this.setPictureKey(new BlobKey(""""));
        this.setModifiedDate(new Date());
    }

    public String getGoogleId() {
        return this.googleId;
    }

    public void setGoogleId(String googleId) {
        this.googleId = googleId;
        if (googleId.isEmpty()) { // only in local attribute tests
            return;
        }
        this.account = Key.create(Account.class, googleId);
    }

    public String getShortName() {
        return this.shortName;
    }

    public void setShortName(String shortName) {
        this.shortName = shortName;
    }

    public String getEmail() {
        return this.email;
    }

    public void setEmail(String email) {
        this.email = email;
    }

    public String getInstitute() {
        return this.institute;
    }

    public void setInstitute(String institute) {
        this.institute = institute;
    }

    public String getNationality() {
        return this.nationality;
    }

    public void setNationality(String nationality) {
        this.nationality = nationality;
    }

    public String getGender() {
        return this.gender;
    }

    public void setGender(String gender) {
        this.gender = gender;
    }

    public Text getMoreInfo() {
        return this.moreInfo;
    }

    public void setMoreInfo(Text moreInfo) {
        this.moreInfo = moreInfo;
    }

    public BlobKey getPictureKey() {
        return this.pictureKey;
    }

    public void setPictureKey(BlobKey pictureKey) {
        this.pictureKey = pictureKey;
    }

    public Date getModifiedDate() {
        return this.modifiedDate;
    }

    public void setModifiedDate(Date modifiedDate) {
        this.modifiedDate = modifiedDate;
    }

}
"
EmailSendingException.java,exceptions,"package teammates.common.exception;

@SuppressWarnings(""serial"")
public class EmailSendingException extends TeammatesException {

    public EmailSendingException(Exception e) {
        super(e.getMessage());
    }

}
"
EnrollException.java,exceptions,"package teammates.common.exception;

@SuppressWarnings(""serial"")
public class EnrollException extends TeammatesException {
    public EnrollException(String message) {
        super(message);
    }

    public EnrollException(String specificErrorcode, String message) {
        super(specificErrorcode, message);
    }
}
"
EntityAlreadyExistsException.java,exceptions,"package teammates.common.exception;

@SuppressWarnings(""serial"")
public class EntityAlreadyExistsException extends TeammatesException {
    public EntityAlreadyExistsException(String message) {
        super(message);
    }
}
"
EntityDoesNotExistException.java,exceptions,"package teammates.common.exception;

@SuppressWarnings(""serial"")
public class EntityDoesNotExistException extends TeammatesException {
    public EntityDoesNotExistException(String message) {
        super(message);
    }

    public EntityDoesNotExistException(Throwable cause) {
        super(cause);
    }
}
"
EntityNotFoundException.java,exceptions,"package teammates.common.exception;

@SuppressWarnings(""serial"")
public class EntityNotFoundException extends RuntimeException {

    public EntityNotFoundException(EntityDoesNotExistException e) {
        super(e.getMessage());
    }

}
"
ExceedingRangeException.java,exceptions,"package teammates.common.exception;

@SuppressWarnings(""serial"")
public class ExceedingRangeException extends Exception {
    public ExceedingRangeException(String message) {
        super(message);
    }

}
"
FeedbackSessionNotVisibleException.java,exceptions,"package teammates.common.exception;

@SuppressWarnings(""serial"")
public class FeedbackSessionNotVisibleException extends UnauthorizedAccessException {

    private String startTimeString;

    public FeedbackSessionNotVisibleException(String openingDateString) {
        super();
        this.startTimeString = openingDateString;
    }

    public FeedbackSessionNotVisibleException(String message, String openingDateString) {
        super(message);
        this.startTimeString = openingDateString;
    }

    public String getStartTimeString() {
        return startTimeString;
    }
}
"
InvalidOriginException.java,exceptions,"package teammates.common.exception;

@SuppressWarnings(""serial"")
public class InvalidOriginException extends RuntimeException {
    public InvalidOriginException() {
        super();
    }

    public InvalidOriginException(String message) {
        super(message);
    }
}
"
InvalidParametersException.java,exceptions,"package teammates.common.exception;

import java.util.List;

import teammates.common.util.StringHelper;

@SuppressWarnings(""serial"")
public class InvalidParametersException extends TeammatesException {
    public InvalidParametersException(String message) {
        super(message);
    }

    public InvalidParametersException(List<String> messages) {
        super(StringHelper.toString(messages));
    }

    public InvalidParametersException(String specificErrorcode, String message) {
        super(specificErrorcode, message);
    }

    public InvalidParametersException(Throwable cause) {
        super(cause);
    }

}
"
JoinCourseException.java,exceptions,"package teammates.common.exception;

@SuppressWarnings(""serial"")
public class JoinCourseException extends TeammatesException {
    public JoinCourseException() {
        super();
    }

    public JoinCourseException(String errorcode, String message) {
        super(errorcode, message);
    }

    public JoinCourseException(String message) {
        super(message);
    }
}
"
NullPostParameterException.java,exceptions,"package teammates.common.exception;

@SuppressWarnings(""serial"")
public class NullPostParameterException extends RuntimeException {
    public NullPostParameterException(String message) {
        super(message);
    }
}
"
package-info.java,exceptions,"/**
 * Contains custom exceptions used across the application.
 */
package teammates.common.exception;
"
PageNotFoundException.java,exceptions,"package teammates.common.exception;

@SuppressWarnings(""serial"")
public class PageNotFoundException extends RuntimeException {
    public PageNotFoundException(String message) {
        super(message);
    }
}
"
TeammatesException.java,exceptions,"package teammates.common.exception;

import java.io.PrintWriter;
import java.io.StringWriter;

import teammates.common.util.Const;

@SuppressWarnings(""serial"")
public class TeammatesException extends Exception {
    public String errorCode;

    public TeammatesException() {
        super();
    }

    public TeammatesException(String message) {
        super(message);
    }

    public TeammatesException(String errorcode, String message) {
        super(message);
        errorCode = errorcode;
    }

    public TeammatesException(Throwable cause) {
        super(cause);
    }

    public static String toStringWithStackTrace(Throwable e) {
        StringWriter sw = new StringWriter();
        e.printStackTrace(new PrintWriter(sw));
        return Const.EOL + sw.toString();
    }
}
"
UnauthorizedAccessException.java,exceptions,"package teammates.common.exception;

@SuppressWarnings(""serial"")
public class UnauthorizedAccessException extends RuntimeException {
    public UnauthorizedAccessException() {
        super();
    }

    public UnauthorizedAccessException(String message) {
        super(message);
    }
}
"
EmailGenerator.java,logic-api,"package teammates.logic.api;

import java.util.ArrayList;
import java.util.Calendar;
import java.util.List;

import com.google.appengine.api.log.AppLogLine;

import teammates.common.datatransfer.attributes.AccountAttributes;
import teammates.common.datatransfer.attributes.CourseAttributes;
import teammates.common.datatransfer.attributes.FeedbackSessionAttributes;
import teammates.common.datatransfer.attributes.InstructorAttributes;
import teammates.common.datatransfer.attributes.StudentAttributes;
import teammates.common.exception.EntityDoesNotExistException;
import teammates.common.util.Config;
import teammates.common.util.Const;
import teammates.common.util.EmailType;
import teammates.common.util.EmailWrapper;
import teammates.common.util.Logger;
import teammates.common.util.SanitizationHelper;
import teammates.common.util.StringHelper;
import teammates.common.util.Templates;
import teammates.common.util.Templates.EmailTemplates;
import teammates.common.util.TimeHelper;
import teammates.logic.core.CoursesLogic;
import teammates.logic.core.FeedbackSessionsLogic;
import teammates.logic.core.InstructorsLogic;
import teammates.logic.core.StudentsLogic;

/**
 * Handles operations related to generating emails to be sent from provided templates.
 *
 * @see EmailTemplates
 * @see EmailType
 * @see EmailWrapper
 */
public class EmailGenerator {
    // status-related strings
    private static final String FEEDBACK_STATUS_SESSION_OPEN = ""is still open for submissions"";
    private static final String FEEDBACK_STATUS_SESSION_OPENING = ""is now open"";
    private static final String FEEDBACK_STATUS_SESSION_CLOSING = ""is closing soon"";
    private static final String FEEDBACK_STATUS_SESSION_CLOSED =
            ""is now closed. You can still view your submission by going to the link sent earlier, ""
            + ""but you will not be able to edit existing responses or submit new responses"";

    // feedback action strings
    private static final String FEEDBACK_ACTION_SUBMIT = ""submit"";
    private static final String FEEDBACK_ACTION_VIEW = ""view"";

    private static final Logger log = Logger.getLogger();
    private static final CoursesLogic coursesLogic = CoursesLogic.inst();
    private static final FeedbackSessionsLogic fsLogic = FeedbackSessionsLogic.inst();
    private static final InstructorsLogic instructorsLogic = InstructorsLogic.inst();
    private static final StudentsLogic studentsLogic = StudentsLogic.inst();

    /**
     * Generates the feedback session opening emails for the given {@code session}.
     */
    public List<EmailWrapper> generateFeedbackSessionOpeningEmails(FeedbackSessionAttributes session) {

        String template = EmailTemplates.USER_FEEDBACK_SESSION;

        CourseAttributes course = coursesLogic.getCourse(session.getCourseId());
        boolean isEmailNeeded = fsLogic.isFeedbackSessionForStudentsToAnswer(session);
        List<InstructorAttributes> instructors = isEmailNeeded
                                                 ? instructorsLogic.getInstructorsForCourse(session.getCourseId())
                                                 : new ArrayList<InstructorAttributes>();
        List<StudentAttributes> students = isEmailNeeded
                                           ? studentsLogic.getStudentsForCourse(session.getCourseId())
                                           : new ArrayList<StudentAttributes>();

        List<EmailWrapper> emails = generateFeedbackSessionEmailBases(course, session, students, instructors, template,
                                                                      EmailType.FEEDBACK_OPENING.getSubject());
        for (EmailWrapper email : emails) {
            email.setContent(email.getContent().replace(""${status}"", FEEDBACK_STATUS_SESSION_OPENING));
        }
        return emails;
    }

    /**
     * Generates the feedback session reminder emails for the given {@code session} for {@code students}
     * and {@code instructorsToRemind}. In addition, the emails will also be forwarded to {@code instructorsToNotify}.
     */
    public List<EmailWrapper> generateFeedbackSessionReminderEmails(
            FeedbackSessionAttributes session, List<StudentAttributes> students,
            List<InstructorAttributes> instructorsToRemind, List<InstructorAttributes> instructorsToNotify) {

        CourseAttributes course = coursesLogic.getCourse(session.getCourseId());
        String template = EmailTemplates.USER_FEEDBACK_SESSION.replace(""${status}"", FEEDBACK_STATUS_SESSION_OPEN);
        List<EmailWrapper> emails =
                generateFeedbackSessionEmailBasesForInstructorReminders(course, session, instructorsToRemind, template,
                        EmailType.FEEDBACK_SESSION_REMINDER.getSubject());
        emails.addAll(generateFeedbackSessionEmailBases(course, session, students, instructorsToNotify, template,
                                                        EmailType.FEEDBACK_SESSION_REMINDER.getSubject()));

        return emails;
    }

    /**
     * Generates the email containing the summary of the feedback sessions
     * email for the given {@code courseId} for {@code student}.
     * @param courseId - ID of the course
     * @param student - attributes of student to send feedback session summary to
     */
    public EmailWrapper generateFeedbackSessionSummaryOfCourse(String courseId, StudentAttributes student) {

        CourseAttributes course = coursesLogic.getCourse(courseId);

        List<FeedbackSessionAttributes> sessions = new ArrayList<>();
        List<FeedbackSessionAttributes> fsInCourse = fsLogic.getFeedbackSessionsForCourse(courseId);

        for (FeedbackSessionAttributes fsa : fsInCourse) {
            if (!fsa.isPrivateSession() && (fsa.isSentOpenEmail() || fsa.isSentPublishedEmail())) {
                sessions.add(fsa);
            }
        }

        StringBuffer linksFragmentValue = new StringBuffer(1000);
        String joinUrl = Config.getAppUrl(student.getRegistrationUrl()).toAbsoluteString();

        String joinFragmentValue = isYetToJoinCourse(student)
                                   ? Templates.populateTemplate(EmailTemplates.FRAGMENT_STUDENT_COURSE_JOIN,
                                           ""${joinUrl}"", joinUrl,
                                           ""${courseName}"", SanitizationHelper.sanitizeForHtml(course.getName()))
                                   : """";

        for (FeedbackSessionAttributes fsa : sessions) {

            String submitUrlHtml = ""(Feedback session is not yet opened)"";
            String reportUrlHtml = ""(Feedback session is not yet published)"";

            if (fsa.isOpened() || fsa.isClosed()) {
                String submitUrl = Config.getAppUrl(Const.ActionURIs.STUDENT_FEEDBACK_SUBMISSION_EDIT_PAGE)
                        .withCourseId(course.getId())
                        .withSessionName(fsa.getFeedbackSessionName())
                        .withRegistrationKey(StringHelper.encrypt(student.key))
                        .withStudentEmail(student.email)
                        .toAbsoluteString();
                submitUrlHtml = ""<a href=\"""" + submitUrl + ""\"">"" + submitUrl + ""</a>"";
            }

            if (fsa.isPublished()) {
                String reportUrl = Config.getAppUrl(Const.ActionURIs.STUDENT_FEEDBACK_RESULTS_PAGE)
                        .withCourseId(course.getId())
                        .withSessionName(fsa.getFeedbackSessionName())
                        .withRegistrationKey(StringHelper.encrypt(student.key))
                        .withStudentEmail(student.email)
                        .toAbsoluteString();
                reportUrlHtml = ""<a href=\"""" + reportUrl + ""\"">"" + reportUrl + ""</a>"";
            }

            linksFragmentValue.append(Templates.populateTemplate(
                    EmailTemplates.FRAGMENT_SINGLE_FEEDBACK_SESSION_LINKS,
                    ""${feedbackSessionName}"", fsa.getFeedbackSessionName(),
                    ""${deadline}"", TimeHelper.formatTime12H(fsa.getEndTime()) + (fsa.isClosed() ? "" (Passed)"" : """"),
                    ""${submitUrl}"", submitUrlHtml,
                    ""${reportUrl}"", reportUrlHtml));
        }

        String emailBody = Templates.populateTemplate(EmailTemplates.USER_FEEDBACK_SESSION_RESEND_ALL_LINKS,
                ""${userName}"", SanitizationHelper.sanitizeForHtml(student.name),
                ""${userEmail}"", student.email,
                ""${courseName}"", SanitizationHelper.sanitizeForHtml(course.getName()),
                ""${courseId}"", course.getId(),
                ""${joinFragment}"", joinFragmentValue,
                ""${linksFragment}"", linksFragmentValue.toString(),
                ""${coOwnersEmails}"", generateCoOwnersEmailsLine(courseId),
                ""${supportEmail}"", Config.SUPPORT_EMAIL);

        EmailWrapper email = getEmptyEmailAddressedToEmail(student.email);
        email.setSubject(String.format(EmailType.STUDENT_EMAIL_CHANGED.getSubject(), course.getName(), course.getId()));
        email.setContent(emailBody);

        return email;
    }

    /**
     * Generates the feedback submission confirmation email for the given {@code session} for {@code student}.
     */
    public EmailWrapper generateFeedbackSubmissionConfirmationEmailForStudent(
            FeedbackSessionAttributes session, StudentAttributes student, Calendar timestamp) {

        CourseAttributes course = coursesLogic.getCourse(session.getCourseId());
        String submitUrl = Config.getAppUrl(Const.ActionURIs.STUDENT_FEEDBACK_SUBMISSION_EDIT_PAGE)
                .withCourseId(course.getId())
                .withSessionName(session.getFeedbackSessionName())
                .withRegistrationKey(StringHelper.encrypt(student.key))
                .withStudentEmail(student.email)
                .toAbsoluteString();
        return generateSubmissionConfirmationEmail(course, session, submitUrl, student.name, student.email, timestamp);
    }

    /**
     * Generates the feedback submission confirmation email for the given {@code session} for {@code instructor}.
     */
    public EmailWrapper generateFeedbackSubmissionConfirmationEmailForInstructor(
            FeedbackSessionAttributes session, InstructorAttributes instructor, Calendar timestamp) {

        CourseAttributes course = coursesLogic.getCourse(session.getCourseId());
        String submitUrl = Config.getAppUrl(Const.ActionURIs.INSTRUCTOR_FEEDBACK_SUBMISSION_EDIT_PAGE)
                .withCourseId(course.getId())
                .withSessionName(session.getFeedbackSessionName())
                .toAbsoluteString();

        return generateSubmissionConfirmationEmail(course, session, submitUrl, instructor.name, instructor.email, timestamp);
    }

    private List<EmailWrapper> generateFeedbackSessionEmailBasesForInstructorReminders(
            CourseAttributes course, FeedbackSessionAttributes session, List<InstructorAttributes> instructors,
            String template, String subject) {

        List<EmailWrapper> emails = new ArrayList<>();
        String coOwnersLine = generateCoOwnersEmailsLine(course.getId());
        for (InstructorAttributes instructor : instructors) {
            emails.add(generateFeedbackSessionEmailBaseForInstructorReminders(course, session, instructor,
                    template, subject, coOwnersLine));
        }
        return emails;
    }

    private EmailWrapper generateSubmissionConfirmationEmail(
            CourseAttributes course, FeedbackSessionAttributes session, String submitUrl,
            String userName, String userEmail, Calendar timestamp) {
        Calendar time = TimeHelper.convertToUserTimeZone(timestamp, session.getTimeZone());
        String template = EmailTemplates.USER_FEEDBACK_SUBMISSION_CONFIRMATION;
        String subject = EmailType.FEEDBACK_SUBMISSION_CONFIRMATION.getSubject();

        String emailBody = Templates.populateTemplate(template,
                ""${userName}"", SanitizationHelper.sanitizeForHtml(userName),
                ""${courseName}"", SanitizationHelper.sanitizeForHtml(course.getName()),
                ""${courseId}"", SanitizationHelper.sanitizeForHtml(course.getId()),
                ""${feedbackSessionName}"", SanitizationHelper.sanitizeForHtml(session.getFeedbackSessionName()),
                ""${deadline}"", SanitizationHelper.sanitizeForHtml(TimeHelper.formatTime12H(session.getEndTime())),
                ""${submitUrl}"", submitUrl,
                ""${timeStamp}"", SanitizationHelper.sanitizeForHtml(TimeHelper.formatTime12H(time.getTime())),
                ""${coOwnersEmails}"", generateCoOwnersEmailsLine(course.getId()),
                ""${supportEmail}"", Config.SUPPORT_EMAIL);

        EmailWrapper email = getEmptyEmailAddressedToEmail(userEmail);
        email.setSubject(String.format(subject, course.getName(), session.getFeedbackSessionName()));
        email.setContent(emailBody);
        return email;

    }

    private EmailWrapper generateFeedbackSessionEmailBaseForInstructorReminders(
            CourseAttributes course, FeedbackSessionAttributes session, InstructorAttributes instructor,
            String template, String subject, String coOwnersLine) {

        String submitUrl = Config.getAppUrl(Const.ActionURIs.INSTRUCTOR_FEEDBACK_SUBMISSION_EDIT_PAGE)
                                 .withCourseId(course.getId())
                                 .withSessionName(session.getFeedbackSessionName())
                                 .toAbsoluteString();

        String reportUrl = Config.getAppUrl(Const.ActionURIs.INSTRUCTOR_FEEDBACK_RESULTS_PAGE)
                                 .withCourseId(course.getId())
                                 .withSessionName(session.getFeedbackSessionName())
                                 .toAbsoluteString();

        String emailBody = Templates.populateTemplate(template,
                ""${userName}"", SanitizationHelper.sanitizeForHtml(instructor.name),
                ""${courseName}"", SanitizationHelper.sanitizeForHtml(course.getName()),
                ""${courseId}"", SanitizationHelper.sanitizeForHtml(course.getId()),
                ""${feedbackSessionName}"", SanitizationHelper.sanitizeForHtml(session.getFeedbackSessionName()),
                ""${deadline}"", SanitizationHelper.sanitizeForHtml(TimeHelper.formatTime12H(session.getEndTime())),
                ""${instructorFragment}"", """",
                ""${sessionInstructions}"", session.getInstructionsString(),
                ""${submitUrl}"", submitUrl,
                ""${reportUrl}"", reportUrl,
                ""${coOwnersEmails}"", coOwnersLine,
                ""${supportEmail}"", Config.SUPPORT_EMAIL,
                ""${additionalInstructions}"", """",
                ""${feedbackAction}"", FEEDBACK_ACTION_SUBMIT);

        EmailWrapper email = getEmptyEmailAddressedToEmail(instructor.email);
        email.setSubject(String.format(subject, course.getName(), session.getFeedbackSessionName()));
        email.setContent(emailBody);
        return email;
    }

    /**
     * Generates the feedback session closing emails for the given {@code session}.
     */
    public List<EmailWrapper> generateFeedbackSessionClosingEmails(FeedbackSessionAttributes session) {

        List<StudentAttributes> students = new ArrayList<>();
        boolean isEmailNeeded = fsLogic.isFeedbackSessionForStudentsToAnswer(session);

        if (isEmailNeeded) {
            List<StudentAttributes> studentsForCourse = studentsLogic.getStudentsForCourse(session.getCourseId());

            for (StudentAttributes student : studentsForCourse) {
                try {
                    if (!fsLogic.isFeedbackSessionFullyCompletedByStudent(session.getFeedbackSessionName(),
                            session.getCourseId(), student.email)) {
                        students.add(student);
                    }
                } catch (EntityDoesNotExistException e) {
                    log.severe(""Course "" + session.getCourseId() + "" does not exist or ""
                               + ""session "" + session.getFeedbackSessionName() + "" does not exist"");
                    // Course or session cannot be found for one student => it will be the case for all students
                    // Do not waste time looping through all students
                    break;
                }
            }
        }

        String template = EmailTemplates.USER_FEEDBACK_SESSION_CLOSING
                .replace(""${status}"", FEEDBACK_STATUS_SESSION_CLOSING);
        CourseAttributes course = coursesLogic.getCourse(session.getCourseId());
        List<InstructorAttributes> instructors = isEmailNeeded
                                                 ? instructorsLogic.getInstructorsForCourse(session.getCourseId())
                                                 : new ArrayList<InstructorAttributes>();

        return generateFeedbackSessionEmailBases(course, session, students, instructors, template,
                EmailType.FEEDBACK_CLOSING.getSubject());
    }

    /**
     * Generates the feedback session closed emails for the given {@code session}.
     */
    public List<EmailWrapper> generateFeedbackSessionClosedEmails(FeedbackSessionAttributes session) {

        if (session.isPrivateSession()) {
            return new ArrayList<>();
        }

        CourseAttributes course = coursesLogic.getCourse(session.getCourseId());
        boolean isEmailNeededForStudents = false;
        try {
            isEmailNeededForStudents = fsLogic.isFeedbackSessionHasQuestionForStudents(
                    session.getFeedbackSessionName(), session.getCourseId());
        } catch (EntityDoesNotExistException e) {
            log.severe(""Course "" + session.getCourseId() + "" does not exist or ""
                    + ""session "" + session.getFeedbackSessionName() + "" does not exist"");
        }
        List<InstructorAttributes> instructors = instructorsLogic.getInstructorsForCourse(session.getCourseId());
        List<StudentAttributes> students = isEmailNeededForStudents
                                           ? studentsLogic.getStudentsForCourse(session.getCourseId())
                                           : new ArrayList<StudentAttributes>();

        String template = EmailTemplates.USER_FEEDBACK_SESSION
                .replace(""${status}"", FEEDBACK_STATUS_SESSION_CLOSED);

        return generateFeedbackSessionEmailBases(course, session, students, instructors, template,
                EmailType.FEEDBACK_CLOSED.getSubject(), EmailTemplates.FRAGMENT_CLOSED_SESSION_ADDITIONAL_INSTRUCTIONS,
                FEEDBACK_ACTION_VIEW);
    }

    /**
     * Generates the feedback session published emails for the given {@code session}.
     */
    public List<EmailWrapper> generateFeedbackSessionPublishedEmails(FeedbackSessionAttributes session) {

        String template = EmailTemplates.USER_FEEDBACK_SESSION_PUBLISHED;

        CourseAttributes course = coursesLogic.getCourse(session.getCourseId());
        boolean isEmailNeeded = fsLogic.isFeedbackSessionViewableToStudents(session);
        List<InstructorAttributes> instructors = isEmailNeeded
                                                 ? instructorsLogic.getInstructorsForCourse(session.getCourseId())
                                                 : new ArrayList<InstructorAttributes>();
        List<StudentAttributes> students = isEmailNeeded
                                           ? studentsLogic.getStudentsForCourse(session.getCourseId())
                                           : new ArrayList<StudentAttributes>();

        return generateFeedbackSessionEmailBases(course, session, students, instructors, template,
                EmailType.FEEDBACK_PUBLISHED.getSubject());
    }

    /**
     * Generates the feedback session published emails for the given {@code session}.
     */
    public List<EmailWrapper> generateFeedbackSessionUnpublishedEmails(FeedbackSessionAttributes session) {

        String template = EmailTemplates.USER_FEEDBACK_SESSION_UNPUBLISHED;

        CourseAttributes course = coursesLogic.getCourse(session.getCourseId());
        boolean isEmailNeeded = fsLogic.isFeedbackSessionViewableToStudents(session);
        List<InstructorAttributes> instructors = isEmailNeeded
                                                 ? instructorsLogic.getInstructorsForCourse(session.getCourseId())
                                                 : new ArrayList<InstructorAttributes>();
        List<StudentAttributes> students = isEmailNeeded
                                           ? studentsLogic.getStudentsForCourse(session.getCourseId())
                                           : new ArrayList<StudentAttributes>();

        return generateFeedbackSessionEmailBases(course, session, students, instructors, template,
                EmailType.FEEDBACK_UNPUBLISHED.getSubject());
    }

    private List<EmailWrapper> generateFeedbackSessionEmailBases(
            CourseAttributes course, FeedbackSessionAttributes session, List<StudentAttributes> students,
            List<InstructorAttributes> instructors, String template, String subject) {
        return generateFeedbackSessionEmailBases(course, session, students, instructors, template, subject, """",
                FEEDBACK_ACTION_SUBMIT);
    }

    private List<EmailWrapper> generateFeedbackSessionEmailBases(
            CourseAttributes course, FeedbackSessionAttributes session, List<StudentAttributes> students,
            List<InstructorAttributes> instructors, String template, String subject, String additionalInstructions,
            String feedbackAction) {

        List<EmailWrapper> emails = new ArrayList<>();
        String coOwnersLine = generateCoOwnersEmailsLine(course.getId());
        for (StudentAttributes student : students) {
            emails.add(generateFeedbackSessionEmailBaseForStudents(course, session, student,
                    template, subject, coOwnersLine, additionalInstructions, feedbackAction));
        }
        for (InstructorAttributes instructor : instructors) {
            emails.add(generateFeedbackSessionEmailBaseForInstructors(course, session, instructor,
                    template, subject, coOwnersLine, additionalInstructions, feedbackAction));
        }
        return emails;
    }

    private EmailWrapper generateFeedbackSessionEmailBaseForStudents(
            CourseAttributes course, FeedbackSessionAttributes session, StudentAttributes student, String template,
            String subject, String coOwnersLine, String additionalInstructions, String feedbackAction) {

        String submitUrl = Config.getAppUrl(Const.ActionURIs.STUDENT_FEEDBACK_SUBMISSION_EDIT_PAGE)
                                 .withCourseId(course.getId())
                                 .withSessionName(session.getFeedbackSessionName())
                                 .withRegistrationKey(StringHelper.encrypt(student.key))
                                 .withStudentEmail(student.email)
                                 .toAbsoluteString();

        String reportUrl = Config.getAppUrl(Const.ActionURIs.STUDENT_FEEDBACK_RESULTS_PAGE)
                                 .withCourseId(course.getId())
                                 .withSessionName(session.getFeedbackSessionName())
                                 .withRegistrationKey(StringHelper.encrypt(student.key))
                                 .withStudentEmail(student.email)
                                 .toAbsoluteString();

        String emailBody = Templates.populateTemplate(template,
                ""${userName}"", SanitizationHelper.sanitizeForHtml(student.name),
                ""${courseName}"", SanitizationHelper.sanitizeForHtml(course.getName()),
                ""${courseId}"", SanitizationHelper.sanitizeForHtml(course.getId()),
                ""${feedbackSessionName}"", SanitizationHelper.sanitizeForHtml(session.getFeedbackSessionName()),
                ""${deadline}"", SanitizationHelper.sanitizeForHtml(TimeHelper.formatTime12H(session.getEndTime())),
                ""${instructorFragment}"", """",
                ""${sessionInstructions}"", session.getInstructionsString(),
                ""${submitUrl}"", submitUrl,
                ""${reportUrl}"", reportUrl,
                ""${coOwnersEmails}"", coOwnersLine,
                ""${supportEmail}"", Config.SUPPORT_EMAIL,
                ""${additionalInstructions}"", additionalInstructions,
                ""${feedbackAction}"", feedbackAction);

        EmailWrapper email = getEmptyEmailAddressedToEmail(student.email);
        email.setSubject(String.format(subject, course.getName(), session.getFeedbackSessionName()));
        email.setContent(emailBody);
        return email;
    }

    /**
     * Generates the preamble for emails that are sent to students of course {@code courseId}
     * to be shown in the email copies that are sent to the instructors of the same course.
     */
    private String generateInstructorPreamble(String courseId, String courseName) {

        String courseIdentifier = ""["" + SanitizationHelper.sanitizeForHtml(courseId) + ""] ""
                + SanitizationHelper.sanitizeForHtml(courseName);

        return ""<p>The email below has been sent to students of course: ""
            + courseIdentifier + "".<br>"" + Const.EOL
            + ""<br>"" + Const.EOL
            + ""=== Email message as seen by the students ===</p>"" + Const.EOL;
    }

    private EmailWrapper generateFeedbackSessionEmailBaseForInstructors(
            CourseAttributes course, FeedbackSessionAttributes session, InstructorAttributes instructor,
            String template, String subject, String coOwnersLine, String additionalInstructions,
            String feedbackAction) {

        String instructorFragment = generateInstructorPreamble(course.getId(), course.getName());

        String emailBody = Templates.populateTemplate(template,
                ""${userName}"", SanitizationHelper.sanitizeForHtml(instructor.name),
                ""${courseName}"", SanitizationHelper.sanitizeForHtml(course.getName()),
                ""${courseId}"", SanitizationHelper.sanitizeForHtml(course.getId()),
                ""${feedbackSessionName}"", SanitizationHelper.sanitizeForHtml(session.getFeedbackSessionName()),
                ""${deadline}"", SanitizationHelper.sanitizeForHtml(TimeHelper.formatTime12H(session.getEndTime())),
                ""${instructorFragment}"", instructorFragment,
                ""${sessionInstructions}"", session.getInstructionsString(),
                ""${submitUrl}"", ""{in the actual email sent to the students, this will be the unique link}"",
                ""${reportUrl}"", ""{in the actual email sent to the students, this will be the unique link}"",
                ""${coOwnersEmails}"", coOwnersLine,
                ""${supportEmail}"", Config.SUPPORT_EMAIL,
                ""${additionalInstructions}"", additionalInstructions,
                ""${feedbackAction}"", feedbackAction);

        EmailWrapper email = getEmptyEmailAddressedToEmail(instructor.email);
        email.setSubject(String.format(subject, course.getName(), session.getFeedbackSessionName()));
        email.setContent(emailBody);
        return email;
    }

    private boolean isYetToJoinCourse(StudentAttributes student) {
        return student.googleId == null || student.googleId.isEmpty();
    }

    /**
     * Generates the new instructor account join email for the given {@code instructor}.
     */
    public EmailWrapper generateNewInstructorAccountJoinEmail(
            String instructorEmail, String instructorShortName, String joinUrl) {

        String emailBody = Templates.populateTemplate(EmailTemplates.NEW_INSTRUCTOR_ACCOUNT_WELCOME,
                ""${userName}"", SanitizationHelper.sanitizeForHtml(instructorShortName),
                ""${joinUrl}"", joinUrl);

        EmailWrapper email = getEmptyEmailAddressedToEmail(instructorEmail);
        email.setBcc(Config.SUPPORT_EMAIL);
        email.setSubject(String.format(EmailType.NEW_INSTRUCTOR_ACCOUNT.getSubject(), instructorShortName));
        email.setContent(emailBody);
        return email;
    }

    /**
     * Generates the course join email for the given {@code student} in {@code course}.
     */
    public EmailWrapper generateStudentCourseJoinEmail(CourseAttributes course, StudentAttributes student) {

        String emailBody = Templates.populateTemplate(
                fillUpStudentJoinFragment(student, EmailTemplates.USER_COURSE_JOIN),
                ""${userName}"", SanitizationHelper.sanitizeForHtml(student.name),
                ""${courseName}"", SanitizationHelper.sanitizeForHtml(course.getName()),
                ""${coOwnersEmails}"", generateCoOwnersEmailsLine(course.getId()),
                ""${supportEmail}"", Config.SUPPORT_EMAIL);

        EmailWrapper email = getEmptyEmailAddressedToEmail(student.email);
        email.setSubject(String.format(EmailType.STUDENT_COURSE_JOIN.getSubject(),
                                       course.getName(), course.getId()));
        email.setContent(emailBody);
        return email;
    }

    /**
     * Generates the course re-join email for the given {@code student} in {@code course}.
     */
    public EmailWrapper generateStudentCourseRejoinEmailAfterGoogleIdReset(
            CourseAttributes course, StudentAttributes student) {

        String emailBody = Templates.populateTemplate(
                fillUpStudentRejoinAfterGoogleIdResetFragment(student, EmailTemplates.USER_COURSE_JOIN),
                ""${userName}"", SanitizationHelper.sanitizeForHtml(student.name),
                ""${courseName}"", SanitizationHelper.sanitizeForHtml(course.getName()),
                ""${coOwnersEmails}"", generateCoOwnersEmailsLine(course.getId()),
                ""${supportEmail}"", Config.SUPPORT_EMAIL);

        EmailWrapper email = getEmptyEmailAddressedToEmail(student.email);
        email.setSubject(String.format(EmailType.STUDENT_COURSE_REJOIN_AFTER_GOOGLE_ID_RESET.getSubject(),
                                       course.getName(), course.getId()));
        email.setContent(emailBody);
        return email;
    }

    /**
     * Generates the course join email for the given {@code instructor} in {@code course}.
     * Also specifies contact information of {@code inviter}.
     */
    public EmailWrapper generateInstructorCourseJoinEmail(AccountAttributes inviter,
            InstructorAttributes instructor, CourseAttributes course) {

        String emailBody = Templates.populateTemplate(
                fillUpInstructorJoinFragment(instructor, EmailTemplates.USER_COURSE_JOIN),
                ""${userName}"", SanitizationHelper.sanitizeForHtml(instructor.getName()),
                ""${courseName}"", SanitizationHelper.sanitizeForHtml(course.getName()),
                ""${inviterName}"", SanitizationHelper.sanitizeForHtml(inviter.getName()),
                ""${inviterEmail}"", SanitizationHelper.sanitizeForHtml(inviter.getEmail()),
                ""${supportEmail}"", Config.SUPPORT_EMAIL);

        EmailWrapper email = getEmptyEmailAddressedToEmail(instructor.getEmail());
        email.setSubject(String.format(EmailType.INSTRUCTOR_COURSE_JOIN.getSubject(),
                                       course.getName(), course.getId()));
        email.setContent(emailBody);
        return email;
    }

    private String fillUpStudentJoinFragment(StudentAttributes student, String emailBody) {
        String joinUrl = Config.getAppUrl(student.getRegistrationUrl()).toAbsoluteString();

        return Templates.populateTemplate(emailBody,
                ""${joinFragment}"", EmailTemplates.FRAGMENT_STUDENT_COURSE_JOIN,
                ""${joinUrl}"", joinUrl);
    }

    private String fillUpStudentRejoinAfterGoogleIdResetFragment(StudentAttributes student, String emailBody) {
        String joinUrl = Config.getAppUrl(student.getRegistrationUrl()).toAbsoluteString();

        return Templates.populateTemplate(emailBody,
                ""${joinFragment}"", EmailTemplates.FRAGMENT_STUDENT_COURSE_REJOIN_AFTER_GOOGLE_ID_RESET,
                ""${joinUrl}"", joinUrl,
                ""${supportEmail}"", Config.SUPPORT_EMAIL);
    }

    private String fillUpInstructorJoinFragment(InstructorAttributes instructor, String emailBody) {
        String joinUrl = Config.getAppUrl(Const.ActionURIs.INSTRUCTOR_COURSE_JOIN)
                               .withRegistrationKey(StringHelper.encrypt(instructor.key))
                               .toAbsoluteString();

        return Templates.populateTemplate(emailBody,
                ""${joinFragment}"", EmailTemplates.FRAGMENT_INSTRUCTOR_COURSE_JOIN,
                ""${joinUrl}"", joinUrl);
    }

    /**
     * Generates the logs compilation email for the given {@code logs}.
     */
    public EmailWrapper generateCompiledLogsEmail(List<AppLogLine> logs) {
        StringBuilder emailBody = new StringBuilder();
        for (int i = 0; i < logs.size(); i++) {
            emailBody.append(generateSevereErrorLogLine(i, logs.get(i)));
        }

        EmailWrapper email = getEmptyEmailAddressedToEmail(Config.SUPPORT_EMAIL);
        email.setSubject(String.format(EmailType.SEVERE_LOGS_COMPILATION.getSubject(), Config.getAppVersion()));
        email.setContent(emailBody.toString());
        return email;
    }

    private String generateSevereErrorLogLine(int index, AppLogLine logLine) {
        return Templates.populateTemplate(
                EmailTemplates.SEVERE_ERROR_LOG_LINE,
                ""${index}"", String.valueOf(index),
                ""${errorType}"", logLine.getLogLevel().toString(),
                ""${errorMessage}"", logLine.getLogMessage().replace(""\n"", ""<br>""));
    }

    /**
     * Generates a generic email with the specified {@code content}, {@code subject}, and {@code recipient}.
     */
    public EmailWrapper generateAdminEmail(String content, String subject, String recipient) {
        EmailWrapper email = getEmptyEmailAddressedToEmail(recipient);
        email.setSubject(subject);
        email.setContent(content);
        return email;
    }

    private EmailWrapper getEmptyEmailAddressedToEmail(String recipient) {
        EmailWrapper email = new EmailWrapper();
        email.setRecipient(recipient);
        email.setSenderEmail(Config.EMAIL_SENDEREMAIL);
        email.setSenderName(Config.EMAIL_SENDERNAME);
        email.setReplyTo(Config.EMAIL_REPLYTO);
        return email;
    }

    private String generateCoOwnersEmailsLine(String courseId) {
        List<InstructorAttributes> coOwners = instructorsLogic.getCoOwnersForCourse(courseId);
        if (coOwners.isEmpty()) {
            return ""(No contactable instructors found)"";
        }
        StringBuilder coOwnersEmailsLine = new StringBuilder();
        for (InstructorAttributes coOwner : coOwners) {
            coOwnersEmailsLine
                    .append(coOwner.getName())
                    .append('(')
                    .append(coOwner.getEmail())
                    .append(""), "");
        }
        return coOwnersEmailsLine.substring(0, coOwnersEmailsLine.length() - 2);
    }

}
"
EmailSender.java,logic-api,"package teammates.logic.api;

import java.util.List;

import teammates.common.exception.EmailSendingException;
import teammates.common.exception.TeammatesException;
import teammates.common.util.Config;
import teammates.common.util.EmailLogEntry;
import teammates.common.util.EmailWrapper;
import teammates.common.util.Logger;
import teammates.logic.core.EmailSenderService;
import teammates.logic.core.JavamailService;
import teammates.logic.core.MailgunService;
import teammates.logic.core.MailjetService;
import teammates.logic.core.SendgridService;

/**
 * Handles operations related to sending emails.
 */
public class EmailSender {

    private static final Logger log = Logger.getLogger();

    private final EmailSenderService service;

    public EmailSender() {
        if (Config.isUsingSendgrid()) {
            service = new SendgridService();
        } else if (Config.isUsingMailgun()) {
            service = new MailgunService();
        } else if (Config.isUsingMailjet()) {
            service = new MailjetService();
        } else {
            service = new JavamailService();
        }
    }

    /**
     * Sends the given {@code message} and generates a log report.
     */
    public void sendEmail(EmailWrapper message) throws EmailSendingException {
        service.sendEmail(message);

        EmailLogEntry newEntry = new EmailLogEntry(message);
        String emailLogInfo = newEntry.generateLogMessage();
        log.info(emailLogInfo);
    }

    /**
     * Sends the given {@code message} with Javamail service regardless of configuration.
     */
    private void sendEmailCopyWithJavamail(EmailWrapper message) throws EmailSendingException {
        // GAE Javamail is used when we need a service that is not prone to configuration failures
        // and/or third-party API failures. The trade-off is the very little quota of 100 emails per day.
        JavamailService javamailService = new JavamailService();

        // GAE Javamail requires the sender email address to be of this format
        message.setSenderEmail(""admin@"" + Config.getAppId() + "".appspotmail.com"");

        message.setSubject(""[Javamail Copy] "" + message.getSubject());

        javamailService.sendEmail(message);
    }

    /**
     * Sends the given {@code report}.
     */
    public void sendReport(EmailWrapper report) {
        try {
            sendEmail(report);
            sendEmailCopyWithJavamail(report);
        } catch (Exception e) {
            log.severe(""Error in sending report: "" + (report == null ? """" : report.getInfoForLogging())
                       + ""\nReport content: "" + (report == null ? """" : report.getContent())
                       + ""\nCause: "" + TeammatesException.toStringWithStackTrace(e));
        }
    }

    /**
     * Gets the emails sent.
     * This method is used only for testing, where it is overridden.
     *
     * @throws UnsupportedOperationException if used in production, where it is not meant to be
     */
    public List<EmailWrapper> getEmailsSent() {
        throw new UnsupportedOperationException(""Method is used only for testing"");
    }

}
"
GateKeeper.java,logic-api,"package teammates.logic.api;

import com.google.appengine.api.users.User;
import com.google.appengine.api.users.UserService;
import com.google.appengine.api.users.UserServiceFactory;

import teammates.common.datatransfer.UserType;
import teammates.common.datatransfer.attributes.AccountAttributes;
import teammates.common.datatransfer.attributes.CourseAttributes;
import teammates.common.datatransfer.attributes.FeedbackSessionAttributes;
import teammates.common.datatransfer.attributes.InstructorAttributes;
import teammates.common.datatransfer.attributes.StudentAttributes;
import teammates.common.exception.FeedbackSessionNotVisibleException;
import teammates.common.exception.UnauthorizedAccessException;
import teammates.common.util.Assumption;
import teammates.common.util.Const;
import teammates.logic.core.AccountsLogic;
import teammates.logic.core.InstructorsLogic;
import teammates.logic.core.StudentsLogic;

/**
 * Provides access control mechanisms.
 */
public class GateKeeper {

    private static UserService userService = UserServiceFactory.getUserService();

    private static final AccountsLogic accountsLogic = AccountsLogic.inst();
    private static final InstructorsLogic instructorsLogic = InstructorsLogic.inst();
    private static final StudentsLogic studentsLogic = StudentsLogic.inst();

    public boolean isUserLoggedOn() {
        return userService.getCurrentUser() != null;
    }

    public UserType getCurrentUser() {
        User user = getCurrentGoogleUser();

        if (user == null) {
            return null;
        }

        UserType userType = new UserType(user);

        if (isAdministrator()) {
            userType.isAdmin = true;
        }

        if (isInstructor()) {
            userType.isInstructor = true;
        }

        if (isStudent()) {
            userType.isStudent = true;
        }

        return userType;
    }

    public String getLoginUrl(String redirectPage) {
        User user = userService.getCurrentUser();

        if (user == null) {
            return userService.createLoginURL(redirectPage);
        }
        return redirectPage;
    }

    public String getLogoutUrl(String redirectPage) {
        return userService.createLogoutURL(redirectPage);
    }

    /**
     * These methods ensures the logged in user is of a particular type.
     */

    /**
     * Verifies the user is logged in.
     */
    public void verifyLoggedInUserPrivileges() {
        if (isUserLoggedOn()) {
            return;
        }

        throw new UnauthorizedAccessException(""User is not logged in"");
    }

    /**
     * Verifies that the logged in user is the admin and there is no
     * masquerading going on.
     */
    public void verifyAdminPrivileges(AccountAttributes account) {
        if (isUserLoggedOn() && userService.isUserAdmin()
                && getCurrentGoogleUser().getNickname().equals(account.googleId)) {
            return;
        }

        throw new UnauthorizedAccessException(""User "" + getCurrentGoogleUser().getNickname()
                                              + "" does not have admin privilleges"");
    }

    /**
     * Verifies that the nominal user has instructor privileges.
     */
    public void verifyInstructorPrivileges(AccountAttributes account) {
        if (account.isInstructor) {
            return;
        }
        throw new UnauthorizedAccessException(""User "" + account.googleId
                                              + "" does not have instructor privilleges"");
    }

    /**
     * Verifies that the nominal user has student privileges. Currently, all
     * logged in users as student privileges.
     */
    public void verifyStudentPrivileges(AccountAttributes account) {
        verifyLoggedInUserPrivileges();
    }

    /**
     * These methods ensures that the nominal user specified has access to a
     * given entity.
     */

    public void verifyAccessible(StudentAttributes student, CourseAttributes course) {
        verifyNotNull(student, ""student"");
        verifyNotNull(student.course, ""student's course ID"");
        verifyNotNull(course, ""course"");
        verifyNotNull(course.getId(), ""course ID"");

        if (!student.course.equals(course.getId())) {
            throw new UnauthorizedAccessException(""Course ["" + course.getId() + ""] is not accessible to student [""
                                                  + student.email + ""]"");
        }
    }

    public void verifyAccessible(StudentAttributes student, FeedbackSessionAttributes feedbacksession) {
        verifyNotNull(student, ""student"");
        verifyNotNull(student.course, ""student's course ID"");
        verifyNotNull(feedbacksession, ""feedback session"");
        verifyNotNull(feedbacksession.getCourseId(), ""feedback session's course ID"");

        if (!student.course.equals(feedbacksession.getCourseId()) || feedbacksession.isPrivateSession()) {
            throw new UnauthorizedAccessException(""Feedback session ["" + feedbacksession.getFeedbackSessionName()
                                                  + ""] is not accessible to student ["" + student.email + ""]"");
        }

        if (!feedbacksession.isVisible()) {
            throw new FeedbackSessionNotVisibleException(
                                            ""This feedback session is not yet visible."",
                                            feedbacksession.getStartTimeString());
        }
    }

    public void verifyAccessible(InstructorAttributes instructor, CourseAttributes course) {
        verifyNotNull(instructor, ""instructor"");
        verifyNotNull(instructor.courseId, ""instructor's course ID"");
        verifyNotNull(course, ""course"");
        verifyNotNull(course.getId(), ""course ID"");

        if (!instructor.courseId.equals(course.getId())) {
            throw new UnauthorizedAccessException(""Course ["" + course.getId() + ""] is not accessible to instructor [""
                                                  + instructor.email + ""]"");
        }
    }

    /**
     * Verifies the instructor and course are not null, the instructor belongs to
     * the course and the instructor has the privilege specified by
     * privilegeName.
     */
    public void verifyAccessible(InstructorAttributes instructor, CourseAttributes course, String privilegeName) {
        verifyNotNull(instructor, ""instructor"");
        verifyNotNull(instructor.courseId, ""instructor's course ID"");
        verifyNotNull(course, ""course"");
        verifyNotNull(course.getId(), ""course ID"");

        if (!instructor.courseId.equals(course.getId())) {
            throw new UnauthorizedAccessException(""Course ["" + course.getId() + ""] is not accessible to instructor [""
                                                  + instructor.email + ""]"");
        }

        if (!instructor.isAllowedForPrivilege(privilegeName)) {
            throw new UnauthorizedAccessException(""Course ["" + course.getId() + ""] is not accessible to instructor [""
                                                  + instructor.email + ""] for privilege ["" + privilegeName + ""]"");
        }
    }

    /**
     * Verifies the instructor and course are not null, the instructor belongs to
     * the course and the instructor has the privilege specified by
     * privilegeName for sectionName.
     */
    public void verifyAccessible(InstructorAttributes instructor, CourseAttributes course, String sectionName,
                                 String privilegeName) {
        verifyNotNull(instructor, ""instructor"");
        verifyNotNull(instructor.courseId, ""instructor's course ID"");
        verifyNotNull(course, ""course"");
        verifyNotNull(course.getId(), ""course ID"");
        verifyNotNull(sectionName, ""section name"");

        if (!instructor.courseId.equals(course.getId())) {
            throw new UnauthorizedAccessException(""Course ["" + course.getId() + ""] is not accessible to instructor [""
                                                  + instructor.email + ""]"");
        }

        if (!instructor.isAllowedForPrivilege(sectionName, privilegeName)) {
            throw new UnauthorizedAccessException(""Course ["" + course.getId() + ""] is not accessible to instructor [""
                                                  + instructor.email + ""] for privilege ["" + privilegeName
                                                  + ""] on section ["" + sectionName + ""]"");
        }
    }

    public void verifyAccessible(InstructorAttributes instructor, FeedbackSessionAttributes feedbacksession,
                                 boolean creatorOnly) {
        verifyNotNull(instructor, ""instructor"");
        verifyNotNull(instructor.courseId, ""instructor's course ID"");
        verifyNotNull(feedbacksession, ""feedback session"");
        verifyNotNull(feedbacksession.getCourseId(), ""feedback session's course ID"");

        if (!instructor.courseId.equals(feedbacksession.getCourseId())) {
            throw new UnauthorizedAccessException(""Feedback session ["" + feedbacksession.getFeedbackSessionName()
                                                  + ""] is not accessible to instructor ["" + instructor.email + ""]"");
        }

        if (creatorOnly && !feedbacksession.getCreatorEmail().equals(instructor.email)) {
            throw new UnauthorizedAccessException(""Feedback session ["" + feedbacksession.getFeedbackSessionName()
                                                  + ""] is not accessible to instructor ["" + instructor.email
                                                  + ""] for this purpose"");
        }
    }

    /**
     * Verifies the instructor and course are not null, the instructor belongs to
     * the course and the instructor has the privilege specified by
     * privilegeName for feedbackSession.
     */
    public void verifyAccessible(InstructorAttributes instructor, FeedbackSessionAttributes feedbacksession,
                                 boolean creatorOnly, String privilegeName) {
        verifyNotNull(instructor, ""instructor"");
        verifyNotNull(instructor.courseId, ""instructor's course ID"");
        verifyNotNull(feedbacksession, ""feedback session"");
        verifyNotNull(feedbacksession.getCourseId(), ""feedback session's course ID"");

        if (!instructor.courseId.equals(feedbacksession.getCourseId())) {
            throw new UnauthorizedAccessException(""Feedback session ["" + feedbacksession.getFeedbackSessionName()
                                                  + ""] is not accessible to instructor ["" + instructor.email + ""]"");
        }

        if (creatorOnly && !feedbacksession.getCreatorEmail().equals(instructor.email)) {
            throw new UnauthorizedAccessException(""Feedback session ["" + feedbacksession.getFeedbackSessionName()
                                                  + ""] is not accessible to instructor ["" + instructor.email
                                                  + ""] for this purpose"");
        }

        if (!instructor.isAllowedForPrivilege(privilegeName)) {
            throw new UnauthorizedAccessException(""Feedback session ["" + feedbacksession.getFeedbackSessionName()
                                                  + ""] is not accessible to instructor ["" + instructor.email
                                                  + ""] for privilege ["" + privilegeName + ""]"");
        }
    }

    public void verifyAccessible(InstructorAttributes instructor, FeedbackSessionAttributes feedbacksession,
                                 boolean creatorOnly, String sectionName, String privilegeName) {
        verifyNotNull(instructor, ""instructor"");
        verifyNotNull(instructor.courseId, ""instructor's course ID"");
        verifyNotNull(feedbacksession, ""feedback session"");
        verifyNotNull(feedbacksession.getCourseId(), ""feedback session's course ID"");

        if (!instructor.courseId.equals(feedbacksession.getCourseId())) {
            throw new UnauthorizedAccessException(""Feedback session ["" + feedbacksession.getFeedbackSessionName()
                                                  + ""] is not accessible to instructor ["" + instructor.email + ""]"");
        }

        if (creatorOnly && !feedbacksession.getCreatorEmail().equals(instructor.email)) {
            throw new UnauthorizedAccessException(""Feedback session ["" + feedbacksession.getFeedbackSessionName()
                                                  + ""] is not accessible to instructor ["" + instructor.email
                                                  + ""] for this purpose"");
        }

        if (!instructor.isAllowedForPrivilege(sectionName, feedbacksession.getFeedbackSessionName(), privilegeName)) {
            throw new UnauthorizedAccessException(""Feedback session ["" + feedbacksession.getFeedbackSessionName()
                                                  + ""] is not accessible to instructor ["" + instructor.email
                                                  + ""] for privilege ["" + privilegeName + ""] on section [""
                                                  + sectionName + ""]"");
        }
    }

    /**
     * These methods ensures that the nominal user specified can perform the
     * specified action on a given entity.
     */

    // TODO: to be implemented when we adopt more finer-grain access control.
    private void verifyNotNull(Object object, String typeName) {
        if (object == null) {
            throw new UnauthorizedAccessException(""Trying to access system using a non-existent "" + typeName
                                                  + "" entity"");
        }

    }

    private User getCurrentGoogleUser() {
        return userService.getCurrentUser();
    }

    private boolean isAdministrator() {
        Assumption.assertTrue(isUserLoggedOn());
        return userService.isUserAdmin();
    }

    private boolean isInstructor() {
        User user = userService.getCurrentUser();
        Assumption.assertNotNull(user);
        return accountsLogic.isAccountAnInstructor(user.getNickname());
    }

    private boolean isStudent() {
        User user = userService.getCurrentUser();
        Assumption.assertNotNull(user);

        return studentsLogic.isStudentInAnyCourse(user.getNickname());
    }

    public void verifyAccessibleForCurrentUserAsInstructorOrTeamMember(AccountAttributes account, String courseId,
            String section, String email) {
        InstructorAttributes instructor = instructorsLogic.getInstructorForGoogleId(courseId, account.googleId);
        if (instructor != null) {
            verifyInstructorCanViewPhoto(instructor, section);
            return;
        }

        StudentAttributes student = studentsLogic.getStudentForCourseIdAndGoogleId(courseId, account.googleId);
        if (student != null) {
            verifyStudentCanViewPhoto(student, courseId, email);
            return;
        }

        throw new UnauthorizedAccessException(""User is not in the course that student belongs to"");
    }

    private void verifyInstructorCanViewPhoto(InstructorAttributes instructor, String section) {
        if (!instructor.isAllowedForPrivilege(section, Const.ParamsNames.INSTRUCTOR_PERMISSION_VIEW_STUDENT_IN_SECTIONS)) {
            throw new UnauthorizedAccessException(""Instructor does not have enough privileges to view the photo"");
        }
    }

    private void verifyStudentCanViewPhoto(StudentAttributes student, String courseId, String email) {
        if (!studentsLogic.isStudentsInSameTeam(courseId, email, student.email)) {
            throw new UnauthorizedAccessException(""Student does not have enough privileges to view the photo"");
        }
    }
}
"
Logic.java,logic-api,"package teammates.logic.api;

import java.util.Date;
import java.util.List;
import java.util.Map;

import com.google.appengine.api.blobstore.BlobKey;

import teammates.common.datatransfer.CourseDetailsBundle;
import teammates.common.datatransfer.CourseEnrollmentResult;
import teammates.common.datatransfer.CourseRoster;
import teammates.common.datatransfer.CourseSummaryBundle;
import teammates.common.datatransfer.FeedbackResponseCommentSearchResultBundle;
import teammates.common.datatransfer.FeedbackSessionDetailsBundle;
import teammates.common.datatransfer.FeedbackSessionQuestionsBundle;
import teammates.common.datatransfer.FeedbackSessionResponseStatus;
import teammates.common.datatransfer.FeedbackSessionResultsBundle;
import teammates.common.datatransfer.InstructorPrivileges;
import teammates.common.datatransfer.InstructorSearchResultBundle;
import teammates.common.datatransfer.SectionDetailsBundle;
import teammates.common.datatransfer.StudentEnrollDetails;
import teammates.common.datatransfer.StudentSearchResultBundle;
import teammates.common.datatransfer.TeamDetailsBundle;
import teammates.common.datatransfer.attributes.AccountAttributes;
import teammates.common.datatransfer.attributes.AdminEmailAttributes;
import teammates.common.datatransfer.attributes.CourseAttributes;
import teammates.common.datatransfer.attributes.FeedbackQuestionAttributes;
import teammates.common.datatransfer.attributes.FeedbackResponseAttributes;
import teammates.common.datatransfer.attributes.FeedbackResponseCommentAttributes;
import teammates.common.datatransfer.attributes.FeedbackSessionAttributes;
import teammates.common.datatransfer.attributes.InstructorAttributes;
import teammates.common.datatransfer.attributes.StudentAttributes;
import teammates.common.datatransfer.attributes.StudentProfileAttributes;
import teammates.common.exception.EnrollException;
import teammates.common.exception.EntityAlreadyExistsException;
import teammates.common.exception.EntityDoesNotExistException;
import teammates.common.exception.ExceedingRangeException;
import teammates.common.exception.InvalidParametersException;
import teammates.common.exception.JoinCourseException;
import teammates.common.util.Assumption;
import teammates.common.util.GoogleCloudStorageHelper;
import teammates.logic.core.AccountsLogic;
import teammates.logic.core.AdminEmailsLogic;
import teammates.logic.core.CoursesLogic;
import teammates.logic.core.FeedbackQuestionsLogic;
import teammates.logic.core.FeedbackResponseCommentsLogic;
import teammates.logic.core.FeedbackResponsesLogic;
import teammates.logic.core.FeedbackSessionsLogic;
import teammates.logic.core.InstructorsLogic;
import teammates.logic.core.ProfilesLogic;
import teammates.logic.core.StudentsLogic;

/**
 * Provides the business logic for production usage of the system.
 *
 * <p>This is a Facade class which simply forwards the method to internal classes.
 */
public class Logic {

    protected static final AccountsLogic accountsLogic = AccountsLogic.inst();
    protected static final StudentsLogic studentsLogic = StudentsLogic.inst();
    protected static final InstructorsLogic instructorsLogic = InstructorsLogic.inst();
    protected static final CoursesLogic coursesLogic = CoursesLogic.inst();
    protected static final FeedbackSessionsLogic feedbackSessionsLogic = FeedbackSessionsLogic.inst();
    protected static final FeedbackQuestionsLogic feedbackQuestionsLogic = FeedbackQuestionsLogic.inst();
    protected static final FeedbackResponsesLogic feedbackResponsesLogic = FeedbackResponsesLogic.inst();
    protected static final FeedbackResponseCommentsLogic feedbackResponseCommentsLogic =
            FeedbackResponseCommentsLogic.inst();
    protected static final AdminEmailsLogic adminEmailsLogic = AdminEmailsLogic.inst();
    protected static final ProfilesLogic profilesLogic = ProfilesLogic.inst();

    /**
     * Creates a new Account based on given values. If a profile is not given,
     * a default empty profile is created for the user<br>
     * Preconditions: <br>
     * * All parameters are non-null.
     *
     */
    public void createAccount(String googleId, String name, boolean isInstructor, String email, String institute,
                              StudentProfileAttributes studentProfileParam) throws InvalidParametersException {

        Assumption.assertNotNull(googleId);
        Assumption.assertNotNull(name);
        Assumption.assertNotNull(isInstructor);
        Assumption.assertNotNull(email);
        Assumption.assertNotNull(institute);

        StudentProfileAttributes studentProfile = studentProfileParam;
        if (studentProfile == null) {
            studentProfile = StudentProfileAttributes.builder().build();
            studentProfile.googleId = googleId;
        }
        AccountAttributes accountToAdd = new AccountAttributes(googleId, name, isInstructor, email, institute,
                                                               studentProfile);

        accountsLogic.createAccount(accountToAdd);
    }

    /**
     * Preconditions: <br>
     * * All parameters are non-null.
     * This is just for legacy code that creates an Account without the profile parameter
     */
    public void createAccount(String googleId, String name, boolean isInstructor, String email, String institute)
            throws InvalidParametersException {

        createAccount(googleId, name, isInstructor, email, institute, null);
    }

    /**
     * Preconditions: <br>
     * * All parameters are non-null.
     */
    public AccountAttributes getAccount(String googleId) {
        return accountsLogic.getAccount(googleId, false);
    }

    public AccountAttributes getAccount(String googleId, boolean retrieveStudentProfile) {
        Assumption.assertNotNull(googleId);

        return accountsLogic.getAccount(googleId, retrieveStudentProfile);
    }

    /**
     * Preconditions: <br>
     * * All parameters are non-null.
     *
     * @return Details of accounts with instruction privileges. Returns empty
     *         list if no such accounts are found.
     */
    @Deprecated //Not scalable.
    public List<AccountAttributes> getInstructorAccounts() {

        return accountsLogic.getInstructorAccounts();
    }

    /**
     * Preconditions: <br>
     * * All parameters are non-null.<br>
     * * {@code newAccountAttributes} represents an existing account.
     */
    public void updateAccount(AccountAttributes newAccountAttributes)
            throws InvalidParametersException, EntityDoesNotExistException {

        Assumption.assertNotNull(newAccountAttributes);

        accountsLogic.updateAccount(newAccountAttributes);
    }

    /**
     * Preconditions: <br>
     * * All parameters are non-null.<br>
     * * {@code newAccountAttributes} represents an existing account.
     */
    public void updateStudentProfile(StudentProfileAttributes newStudentProfileAttributes)
            throws InvalidParametersException, EntityDoesNotExistException {

        Assumption.assertNotNull(newStudentProfileAttributes);

        profilesLogic.updateStudentProfile(newStudentProfileAttributes);
    }

    /**
     * Preconditions: <br>
     * * All parameters are non-null.<br>
     * * {@code newAccountAttributes} represents an existing account.
     */
    public void updateStudentProfilePicture(String googleId, String newPictureKey)
            throws EntityDoesNotExistException {

        Assumption.assertNotNull(googleId);
        Assumption.assertNotNull(newPictureKey);

        profilesLogic.updateStudentProfilePicture(googleId, newPictureKey);
    }

    /**
     * Deletes both instructor and student privileges.
     * Does not delete courses. Can result in orphan courses
     * (to be rectified in future).
     * Fails silently if no such account. <br>
     * Preconditions: <br>
     * * All parameters are non-null.
     */
    public void deleteAccount(String googleId) {

        Assumption.assertNotNull(googleId);

        accountsLogic.deleteAccountCascade(googleId);
    }

    public void deleteStudentProfilePicture(String googleId) throws EntityDoesNotExistException {

        Assumption.assertNotNull(googleId);

        profilesLogic.deleteStudentProfilePicture(googleId);
    }

    public void deletePicture(BlobKey key) {
        Assumption.assertNotNull(key);

        profilesLogic.deletePicture(key);
    }

    /**
     * Creates an instructor and an new account if the instructor doesn't not have account yet.<br>
     * Used as a shorthand when the account entity is not important and is
     * only needed for completeness<br>
     * <b>Note: Now used for the purpose of testing only.</b><br>
     * Preconditions: <br>
     * * All parameters are non-null.
     */
    @Deprecated
    public void createInstructorAccount(String googleId, String courseId, String name, String email,
                                        Boolean isArchived, String roleParam, boolean isDisplayedToStudents,
                                        String displayedNameParam, String privileges, String institute)
            throws EntityAlreadyExistsException, InvalidParametersException {

        Assumption.assertNotNull(googleId);
        Assumption.assertNotNull(courseId);
        Assumption.assertNotNull(name);
        Assumption.assertNotNull(email);
        Assumption.assertNotNull(institute);

        if (accountsLogic.getAccount(googleId) == null) {
            AccountAttributes account = new AccountAttributes(googleId, name, true, email, institute);
            accountsLogic.createAccount(account);
        }

        // In case when roleParam is null, default values used both for role and for privileges.
        // If privileges is null and roleParam is not null, for privileges will be created value based on roleParam
        InstructorAttributes instructor = InstructorAttributes.builder(googleId, courseId, name, email)
                .withRole(roleParam).withDisplayedName(displayedNameParam)
                .withPrivileges(privileges).withIsDisplayedToStudents(isDisplayedToStudents)
                .withIsArchived(isArchived)
                .build();

        instructorsLogic.createInstructor(instructor);
    }

    /**
     * Add an instructor for a course. <br>
     * Preconditions: <br>
     * * All parameters are non-null.
     */
    @Deprecated
    public void addInstructor(String courseId, String name, String email, String role)
            throws InvalidParametersException, EntityAlreadyExistsException {

        Assumption.assertNotNull(courseId);
        Assumption.assertNotNull(name);
        Assumption.assertNotNull(email);

        InstructorAttributes instructor = InstructorAttributes.builder(null, courseId, name, email)
                .withRole(role).withPrivileges(new InstructorPrivileges(role))
                .build();
        instructorsLogic.createInstructor(instructor);
    }

    public InstructorAttributes createInstructor(InstructorAttributes instructor)
            throws InvalidParametersException, EntityAlreadyExistsException {
        return instructorsLogic.createInstructor(instructor);
    }

    /**
     * This method should be used by admin only since the searching does not restrict the
     * visibility according to the logged-in user's google ID. This is used by admin to
     * search instructors in the whole system.
     * @return Null if no match found.
     */
    public InstructorSearchResultBundle searchInstructorsInWholeSystem(String queryString) {
        Assumption.assertNotNull(queryString);

        return instructorsLogic.searchInstructorsInWholeSystem(queryString);
    }

    /**
     * Creates or updates document for the given Instructor.
     *
     * @see InstructorsLogic#putDocument(InstructorAttributes)
     */
    public void putDocument(InstructorAttributes instructor) {
        instructorsLogic.putDocument(instructor);
    }

    /**
     * Batch creates or updates documents for the given Instructors.
     *
     * @see InstructorsLogic#putDocuments(List)
     */
    public void putInstructorDocuments(List<InstructorAttributes> instructors) {
        instructorsLogic.putDocuments(instructors);
    }

    /**
     * Removes document for the given Instructor.
     *
     * @see InstructorsLogic#deleteDocument(InstructorAttributes)
     */
    public void deleteDocument(InstructorAttributes instructor) {
        instructorsLogic.deleteDocument(instructor);
    }

    /**
     * Preconditions: <br>
     * * All parameters are non-null.
     * @return null if not found.
     */
    public InstructorAttributes getInstructorForEmail(String courseId, String email) {

        Assumption.assertNotNull(courseId);
        Assumption.assertNotNull(email);

        return instructorsLogic.getInstructorForEmail(courseId, email);
    }

    /**
     * Preconditions: <br>
     * * All parameters are non-null.
     * @return null if not found.
     */
    public InstructorAttributes getInstructorForGoogleId(String courseId, String googleId) {

        Assumption.assertNotNull(googleId);
        Assumption.assertNotNull(courseId);

        return instructorsLogic.getInstructorForGoogleId(courseId, googleId);
    }

    /**
     * Preconditions: <br>
     * * All parameters are non-null.
     * @return null if not found.
     */
    public InstructorAttributes getInstructorForRegistrationKey(String encryptedKey) {

        Assumption.assertNotNull(encryptedKey);

        return instructorsLogic.getInstructorForRegistrationKey(encryptedKey);
    }

    /**
     * Preconditions: <br>
     * * All parameters are non-null.
     * @return Empty list if none found.
     */
    public List<InstructorAttributes> getInstructorsForGoogleId(String googleId) {

        Assumption.assertNotNull(googleId);

        return instructorsLogic.getInstructorsForGoogleId(googleId);
    }

    public List<InstructorAttributes> getInstructorsForGoogleId(String googleId, boolean omitArchived) {

        Assumption.assertNotNull(googleId);

        return instructorsLogic.getInstructorsForGoogleId(googleId, omitArchived);
    }

    /**
     * Preconditions: <br>
     * * All parameters are non-null.
     * @return Empty list if none found.
     */
    public List<InstructorAttributes> getInstructorsForEmail(String email) {

        Assumption.assertNotNull(email);

        return instructorsLogic.getInstructorsForEmail(email);
    }

    /**
     * Preconditions: <br>
     * * All parameters are non-null.
     * @return Empty list if none found.
     */
    public List<InstructorAttributes> getInstructorsForCourse(String courseId) {

        Assumption.assertNotNull(courseId);

        return instructorsLogic.getInstructorsForCourse(courseId);
    }

    /**
     * Get the encrypted registration key for the instructor.
     * Preconditions: <br>
     * * All parameters are non-null.
     */
    public String getEncryptedKeyForInstructor(String courseId, String email)
            throws EntityDoesNotExistException {

        Assumption.assertNotNull(courseId);
        Assumption.assertNotNull(email);

        return instructorsLogic.getEncryptedKeyForInstructor(courseId, email);
    }

    public List<FeedbackSessionAttributes> getAllOpenFeedbackSessions(Date start, Date end, double zone) {

        return feedbackSessionsLogic.getAllOpenFeedbackSessions(start, end, zone);
    }

    /**
     * Returns true if this user has instructor privileges.
     */
    public boolean isInstructor(String googleId) {

        return accountsLogic.isAccountAnInstructor(googleId);
    }

    /**
     * Returns true if this user is an instructor of the course.
     */
    public boolean isInstructorOfCourse(String googleId, String courseId) {

        return instructorsLogic.isGoogleIdOfInstructorOfCourse(googleId, courseId);
    }

    /**
     * Returns true if this email belongs to an instructor of the course.
     */
    public boolean isInstructorEmailOfCourse(String email, String courseId) {

        return instructorsLogic.isEmailOfInstructorOfCourse(email, courseId);
    }

    /**
     * Returns true if the instructor is a new user.
     *
     * @see InstructorsLogic#isNewInstructor(String)
     */
    public boolean isNewInstructor(String googleId) {

        return instructorsLogic.isNewInstructor(googleId);
    }

    /**
     * Update the name and email address of an instructor with the specific Google ID.
     * Preconditions: <br>
     * * All parameters are non-null.
     * @param instr InstructorAttributes object containing the details to be updated
     */
    public void updateInstructorByGoogleId(String googleId, InstructorAttributes instr)
            throws InvalidParametersException, EntityDoesNotExistException {

        Assumption.assertNotNull(googleId);
        Assumption.assertNotNull(instr);

        instructorsLogic.updateInstructorByGoogleId(googleId, instr);
    }

    public void updateInstructorByEmail(String email, InstructorAttributes instr)
            throws InvalidParametersException, EntityDoesNotExistException {

        Assumption.assertNotNull(email);
        Assumption.assertNotNull(instr);

        instructorsLogic.updateInstructorByEmail(email, instr);
    }

    /**
     * Make the instructor join the course, i.e. associate the Google ID to the instructor.<br>
     * Create an account for the instructor if there is no account exist for him.
     * Preconditions: <br>
     * * All parameters are non-null.
     */
    public void joinCourseForInstructor(String encryptedKey, String googleId, String institute)
            throws JoinCourseException, InvalidParametersException, EntityDoesNotExistException {

        Assumption.assertNotNull(googleId);
        Assumption.assertNotNull(encryptedKey);
        Assumption.assertNotNull(institute);

        accountsLogic.joinCourseForInstructor(encryptedKey, googleId, institute);
    }

    public void joinCourseForInstructor(String encryptedKey, String googleId)
            throws JoinCourseException, InvalidParametersException, EntityDoesNotExistException {

        Assumption.assertNotNull(googleId);
        Assumption.assertNotNull(encryptedKey);
        accountsLogic.joinCourseForInstructor(encryptedKey, googleId);
    }

    public void verifyInputForAdminHomePage(String shortName, String name, String institute, String email)
            throws InvalidParametersException {

        List<String> invalidityInfo = instructorsLogic.getInvalidityInfoForNewInstructorData(shortName, name,
                                                                                              institute, email);

        if (!invalidityInfo.isEmpty()) {
            throw new InvalidParametersException(invalidityInfo);
        }
    }

    /**
     * Removes instructor access but does not delete the account.
     * The account will continue to have student access. <br>
     * Fails silently if no match found.<br>
     * Preconditions: <br>
     * * All parameters are non-null.
     */
    public void downgradeInstructorToStudentCascade(String googleId) {

        Assumption.assertNotNull(googleId);

        accountsLogic.downgradeInstructorToStudentCascade(googleId);
    }

    /**
     * Fails silently if no match found.
     * Preconditions: <br>
     * * All parameters are non-null.
     */
    public void deleteInstructor(String courseId, String email) {

        Assumption.assertNotNull(courseId);
        Assumption.assertNotNull(email);

        instructorsLogic.deleteInstructorCascade(courseId, email);
    }

    /**
     * Creates a course and an instructor for it. <br>
     * Preconditions: <br>
     * * All parameters are non-null. <br>
     * * {@code instructorGoogleId} already has instructor privileges.
     */
    public void createCourseAndInstructor(String instructorGoogleId, String courseId, String courseName,
                                          String courseTimeZone)
            throws EntityAlreadyExistsException, InvalidParametersException {

        Assumption.assertNotNull(instructorGoogleId);
        Assumption.assertNotNull(courseId);
        Assumption.assertNotNull(courseName);
        Assumption.assertNotNull(courseTimeZone);

        coursesLogic.createCourseAndInstructor(instructorGoogleId, courseId, courseName, courseTimeZone);
    }

    /**
     * Preconditions: <br>
     * * All parameters are non-null.
     * @return null if not found.
     */
    public CourseAttributes getCourse(String courseId) {

        Assumption.assertNotNull(courseId);

        return coursesLogic.getCourse(courseId);
    }

    /**
     * Returns a detailed version of course data. <br>
     * Preconditions: <br>
     * * All parameters are non-null.
     */
    public CourseDetailsBundle getCourseDetails(String courseId) throws EntityDoesNotExistException {
        Assumption.assertNotNull(courseId);
        return coursesLogic.getCourseSummary(courseId);
    }

    /**
     * Returns a course data, including its feedback sessions, according to the instructor passed in.<br>
     * Preconditions: <br>
     * * All parameters are non-null.
     */
    public CourseSummaryBundle getCourseSummaryWithFeedbackSessions(InstructorAttributes instructor)
            throws EntityDoesNotExistException {
        Assumption.assertNotNull(instructor);
        return coursesLogic.getCourseSummaryWithFeedbackSessionsForInstructor(instructor);
    }

    /**
     * Preconditions: <br>
     * * All parameters are non-null.
     */
    public List<CourseAttributes> getCoursesForStudentAccount(String googleId) throws EntityDoesNotExistException {
        Assumption.assertNotNull(googleId);
        return coursesLogic.getCoursesForStudentAccount(googleId);
    }

    /**
     * Omits archived courses if omitArchived == true<br>
     * Preconditions: <br>
     * * All parameters are non-null.
     * @return A less detailed version of courses for this instructor without stats.
     *         Returns an empty list if none found.
     */
    public Map<String, CourseSummaryBundle> getCourseSummariesWithoutStatsForInstructor(String googleId,
                                                                                            boolean omitArchived) {

        Assumption.assertNotNull(googleId);
        return coursesLogic.getCoursesSummaryWithoutStatsForInstructor(googleId, omitArchived);
    }

    /**
     * Preconditions: <br>
     * * All parameters are non-null.
     * @return A less detailed version of courses for this instructor.
     *         Returns an empty list if none found.
     */
    public Map<String, CourseDetailsBundle> getCourseSummariesForInstructor(String googleId)
            throws EntityDoesNotExistException {

        Assumption.assertNotNull(googleId);
        return coursesLogic.getCourseSummariesForInstructor(googleId, false);
    }

    /**
     * Preconditions: <br>
     * * All parameters are non-null.
     * @return A less detailed version of courses for the specified instructor attributes.
     *         Returns an empty list if none found.
     */
    public Map<String, CourseDetailsBundle> getCourseSummariesForInstructors(List<InstructorAttributes> instructorList) {

        Assumption.assertNotNull(instructorList);
        return coursesLogic.getCourseSummariesForInstructor(instructorList);
    }

    /**
     * Preconditions: <br>
     * * All parameters are non-null.
     *
     * @return Details of courses the student is in. CourseData objects
     *         returned contain details of feedback sessions too (except the ones
     *         still AWAITING).
     */
    public List<CourseDetailsBundle> getCourseDetailsListForStudent(String googleId)
            throws EntityDoesNotExistException {

        Assumption.assertNotNull(googleId);
        return coursesLogic.getCourseDetailsListForStudent(googleId);
    }

    /**
     * Preconditions: <br>
     * * All parameters are non-null.
     *
     * @return Courses the instructor is in.
     */
    public List<CourseAttributes> getCoursesForInstructor(String googleId) {

        return getCoursesForInstructor(googleId, false);
    }

    /**
     * Omits archived courses if omitArchived == true<br>
     * Preconditions: <br>
     * * All parameters are non-null.
     *
     * @return Courses the instructor is in.
     */
    public List<CourseAttributes> getCoursesForInstructor(String googleId, boolean omitArchived) {

        Assumption.assertNotNull(googleId);
        return coursesLogic.getCoursesForInstructor(googleId, omitArchived);
    }

    /**
     * Preconditions: <br>
     * * All parameters are non-null.
     *
     * @return Courses the given instructors is in.
     */
    public List<CourseAttributes> getCoursesForInstructor(List<InstructorAttributes> instructorList) {

        Assumption.assertNotNull(instructorList);
        return coursesLogic.getCoursesForInstructor(instructorList);
    }

    /**
     * Updates the details of a course.
     *
     * @see CoursesLogic#updateCourse(CourseAttributes)
     */
    public void updateCourse(CourseAttributes course) throws InvalidParametersException,
                                                             EntityDoesNotExistException {
        Assumption.assertNotNull(course);
        coursesLogic.updateCourse(course);
    }

    /**
     * Change the archive status of a course for a instructor.<br>
     * Preconditions: <br>
     * * All parameters are non-null.
     * @param courseId The course of which the archive status is to be changed
     * @param archiveStatus The archive status to be set
     */

    public void setArchiveStatusOfInstructor(String googleId, String courseId, boolean archiveStatus)
            throws InvalidParametersException, EntityDoesNotExistException {

        Assumption.assertNotNull(googleId);
        Assumption.assertNotNull(courseId);
        Assumption.assertNotNull(archiveStatus);

        instructorsLogic.setArchiveStatusOfInstructor(googleId, courseId, archiveStatus);
    }

    /**
     * Deletes the course and all data related to the course
     * (instructors, students, feedback sessions).
     * Fails silently if no such account. <br>
     * Preconditions: <br>
     * * All parameters are non-null.
     */
    public void deleteCourse(String courseId) {
        Assumption.assertNotNull(courseId);
        coursesLogic.deleteCourseCascade(courseId);
    }

    /**
     * Creates a student. <br>
     * Preconditions: <br>
     * * All parameters are non-null.
     */
    public void createStudent(StudentAttributes student)
            throws EntityAlreadyExistsException, InvalidParametersException, EntityDoesNotExistException {

        Assumption.assertNotNull(student);
        studentsLogic.createStudentCascade(student);
    }

    public void createStudentWithoutDocument(StudentAttributes student) throws EntityAlreadyExistsException,
                                                                               InvalidParametersException,
                                                                               EntityDoesNotExistException {
        Assumption.assertNotNull(student);
        studentsLogic.createStudentCascadeWithoutDocument(student);
    }

    /**
     * Search for students. Preconditions: all parameters are non-null.
     * @param instructors   a list of InstructorAttributes associated to a googleId,
     *                      used for filtering of search result
     * @return Null if no match found
     */
    public StudentSearchResultBundle searchStudents(String queryString, List<InstructorAttributes> instructors) {
        Assumption.assertNotNull(queryString);
        Assumption.assertNotNull(instructors);
        return studentsLogic.searchStudents(queryString, instructors);
    }

    /**
     * This method should be used by admin only since the searching does not restrict the
     * visibility according to the logged-in user's google ID. This is used by admin to
     * search students in the whole system.
     * @return Null if no match found.
     */
    public StudentSearchResultBundle searchStudentsInWholeSystem(String queryString) {
        Assumption.assertNotNull(queryString);

        return studentsLogic.searchStudentsInWholeSystem(queryString);
    }

    /**
     * Preconditions: <br>
     * * All parameters are non-null.
     *
     * @return Null if no match found.
     */
    public StudentAttributes getStudentForRegistrationKey(String registrationKey) {
        Assumption.assertNotNull(registrationKey);
        return studentsLogic.getStudentForRegistrationKey(registrationKey);
    }

    /**
     * Preconditions: <br>
     * * All parameters are non-null.
     *
     * @return Null if no match found.
     */
    public StudentAttributes getStudentForEmail(String courseId, String email) {
        Assumption.assertNotNull(courseId);
        Assumption.assertNotNull(email);

        return studentsLogic.getStudentForEmail(courseId, email);
    }

    /**
     * Preconditions: <br>
     * * All parameters are non-null.
     *
     * @return Null if no match found.
     */
    public StudentAttributes getStudentForGoogleId(String courseId, String googleId) {
        Assumption.assertNotNull(courseId);
        Assumption.assertNotNull(googleId);

        return studentsLogic.getStudentForCourseIdAndGoogleId(courseId, googleId);
    }

    /**
     * Preconditions: <br>
     * * All parameters are non-null.
     *
     * @return Null if no match found.
     */
    public StudentProfileAttributes getStudentProfile(String googleId) {
        Assumption.assertNotNull(googleId);
        return profilesLogic.getStudentProfile(googleId);
    }

    /**
     * Preconditions: <br>
     * * All parameters are non-null.
     *
     * @return Empty list if no match found.
     */
    public List<StudentAttributes> getStudentsForGoogleId(String googleId) {
        Assumption.assertNotNull(googleId);
        return studentsLogic.getStudentsForGoogleId(googleId);
    }

    /**
     * Preconditions: <br>
     * * All parameters are non-null.
     * @return Empty list if none found.
     */
    public List<StudentAttributes> getStudentsForCourse(String courseId) {
        Assumption.assertNotNull(courseId);
        return studentsLogic.getStudentsForCourse(courseId);
    }

    /**
     * Preconditions: <br>
     * * All parameters are non-null.
     * @return Empty list if none found.
     */
    public List<StudentAttributes> getStudentsForSection(String section, String courseId) {
        Assumption.assertNotNull(courseId);
        Assumption.assertNotNull(section);
        return studentsLogic.getStudentsForSection(section, courseId);
    }

    /**
     * Preconditions: <br>
     * * All parameters are non-null.
     * @return Empty list if none found.
     */
    public List<StudentAttributes> getStudentsForTeam(String team, String courseId) {
        Assumption.assertNotNull(courseId);
        Assumption.assertNotNull(team);
        return studentsLogic.getStudentsForTeam(team, courseId);
    }

    /**
     * Returns a list of section names for the course with ID courseId.
     *
     * <p>Preconditions: <br>
     * * All parameters are non-null.
     *
     * @see CoursesLogic#getSectionsNameForCourse(String)
     */
    public List<String> getSectionNamesForCourse(String courseId) throws EntityDoesNotExistException {
        Assumption.assertNotNull(courseId);
        return coursesLogic.getSectionsNameForCourse(courseId);
    }

    /**
     * Returns a list of section names for the specified course.
     *
     * <p>Preconditions: <br>
     * * All parameters are non-null.
     *
     * @see CoursesLogic#getSectionsNameForCourse(CourseAttributes)
     */
    public List<String> getSectionNamesForCourse(CourseAttributes course) throws EntityDoesNotExistException {
        Assumption.assertNotNull(course);
        return coursesLogic.getSectionsNameForCourse(course);
    }

    /**
     * Returns a list of {@link SectionDetailsBundle} for a given course using courseId.
     *
     * <p>Preconditions: <br>
     * * All parameters are non-null.
     *
     * @see CoursesLogic#getSectionsForCourseWithoutStats(String)
     */
    public List<SectionDetailsBundle> getSectionsForCourse(String courseId) throws EntityDoesNotExistException {
        Assumption.assertNotNull(courseId);
        return coursesLogic.getSectionsForCourseWithoutStats(courseId);
    }

    /**
     * Preconditions: <br>
     * * All parameters are non-null.
     */
    public List<TeamDetailsBundle> getTeamsForCourse(String courseId) throws EntityDoesNotExistException {
        Assumption.assertNotNull(courseId);
        return coursesLogic.getTeamsForCourse(courseId);
    }

    /**
     * Preconditions: <br>
     * * All parameters are non-null.
     */
    public TeamDetailsBundle getTeamDetailsForStudent(StudentAttributes student) {
        Assumption.assertNotNull(student);
        return studentsLogic.getTeamDetailsForStudent(student);
    }

    /**
     * Preconditions: <br>
     * * All parameters are non-null.
     */
    public String getEncryptedKeyForStudent(String courseId, String email) throws EntityDoesNotExistException {

        Assumption.assertNotNull(courseId);
        Assumption.assertNotNull(email);

        return studentsLogic.getEncryptedKeyForStudent(courseId, email);
    }

    public void resetStudentGoogleId(String originalEmail, String courseId) throws InvalidParametersException,
                                                                                   EntityDoesNotExistException {
        Assumption.assertNotNull(originalEmail);
        Assumption.assertNotNull(courseId);
        studentsLogic.resetStudentGoogleId(originalEmail, courseId, true);
    }

    /**
     * All attributes except courseId be changed. Trying to change courseId will
     * be treated as trying to edit a student in a different course.<br>
     * Changing team name will not delete existing submissions under that team <br>
     * Cascade logic: Email changed-> changes email in all existing submissions <br>
     * Team changed-> creates new submissions for the new team, deletes
     * submissions for previous team structure. <br>
     * Preconditions: <br>
     * * All parameters are non-null.
     */
    public void updateStudent(String originalEmail, StudentAttributes student)
            throws InvalidParametersException, EntityDoesNotExistException {

        Assumption.assertNotNull(originalEmail);
        Assumption.assertNotNull(student);

        studentsLogic.updateStudentCascade(originalEmail, student);
    }

    public void updateStudentWithoutDocument(String originalEmail, StudentAttributes student)
            throws InvalidParametersException, EntityDoesNotExistException {

        Assumption.assertNotNull(originalEmail);
        Assumption.assertNotNull(student);

        studentsLogic.updateStudentCascadeWithoutDocument(originalEmail, student);
    }

    /**
     * Make the student join the course, i.e. associate the Google ID to the student.<br>
     * Create an account for the student if there is no account exist for him.
     * Preconditions: <br>
     * * All parameters are non-null.
     * @param key the encrypted registration key
     */
    public void joinCourseForStudent(String key, String googleId) throws JoinCourseException, InvalidParametersException {

        Assumption.assertNotNull(googleId);
        Assumption.assertNotNull(key);

        accountsLogic.joinCourseForStudent(key, googleId);

    }

    /**
     * Enrolls new students in the course or modifies existing students. But it
     * will not delete any students. It will not edit email address either. If
     * an existing student was enrolled with a different email address, that
     * student will be treated as a new student.<br>
     * If there is an error in the enrollLines, there will be no changes to the
     * datastore <br>
     * Preconditions: <br>
     * * All parameters are non-null.
     * @return StudentData objects in the return value contains the status of
     *         enrollment. It also includes data for other students in the
     *         course that were not touched by the operation.
     */
    public CourseEnrollmentResult enrollStudents(String enrollLines, String courseId)
            throws EnrollException, EntityDoesNotExistException, InvalidParametersException, EntityAlreadyExistsException {

        Assumption.assertNotNull(courseId);
        Assumption.assertNotNull(enrollLines);

        return studentsLogic.enrollStudents(enrollLines.trim(), courseId);

    }

    public List<StudentAttributes> getUnregisteredStudentsForCourse(String courseId) {
        Assumption.assertNotNull(courseId);
        return studentsLogic.getUnregisteredStudentsForCourse(courseId);
    }

    public boolean isFeedbackSessionCompletedByInstructor(FeedbackSessionAttributes fsa, String userEmail)
            throws EntityDoesNotExistException {
        Assumption.assertNotNull(fsa);
        Assumption.assertNotNull(userEmail);
        return feedbackSessionsLogic.isFeedbackSessionCompletedByInstructor(fsa, userEmail);
    }

    public boolean isFeedbackSessionCompletedByStudent(FeedbackSessionAttributes fsa, String userEmail) {
        Assumption.assertNotNull(fsa);
        Assumption.assertNotNull(userEmail);
        return feedbackSessionsLogic.isFeedbackSessionCompletedByStudent(fsa, userEmail);
    }

    /**
     * Deletes the student from the course including any submissions to/from
     * for this student in this course.
     * Fails silently if no match found. <br>
     * Preconditions: <br>
     * * All parameters are non-null.
     */
    public void deleteStudent(String courseId, String studentEmail) {

        Assumption.assertNotNull(courseId);
        Assumption.assertNotNull(studentEmail);

        studentsLogic.deleteStudentCascade(courseId, studentEmail);
    }

    /**
     * Deletes all the students in the course.
     *
     * @param courseId course id for the students
     */
    public void deleteAllStudentsInCourse(String courseId) {

        Assumption.assertNotNull(courseId);
        studentsLogic.deleteAllStudentsInCourse(courseId);
    }

    public void deleteStudentWithoutDocument(String courseId, String studentEmail) {

        Assumption.assertNotNull(courseId);
        Assumption.assertNotNull(studentEmail);

        studentsLogic.deleteStudentCascadeWithoutDocument(courseId, studentEmail);
    }

    /**
     *  Checks if a course has sections for each team
     *  Preconditions: <br>
     *  * All parameters are non-null.
     */
    public boolean hasIndicatedSections(String courseId) throws EntityDoesNotExistException {
        Assumption.assertNotNull(courseId);
        return coursesLogic.hasIndicatedSections(courseId);
    }

    /**
     * Validates sections for any limit violations and teams for any team name violations.
     *
     * <p>Preconditions: <br>
     * * All parameters are non-null.
     *
     * @see StudentsLogic#validateSectionsAndTeams(List, String)
     */
    public void validateSectionsAndTeams(List<StudentAttributes> studentList, String courseId) throws EnrollException {

        Assumption.assertNotNull(studentList);
        Assumption.assertNotNull(courseId);

        studentsLogic.validateSectionsAndTeams(studentList, courseId);
    }

    /**
     * Validates teams for any team name violations.
     *
     * <p>Preconditions: <br>
     * * All parameters are non-null.
     *
     * @see StudentsLogic#validateTeams(List, String)
     */
    public void validateTeams(List<StudentAttributes> studentList, String courseId) throws EnrollException {

        Assumption.assertNotNull(studentList);
        Assumption.assertNotNull(courseId);

        studentsLogic.validateTeams(studentList, courseId);
    }

    public void putDocument(StudentAttributes student) {
        studentsLogic.putDocument(student);
    }

    /**
     * Batch creates or updates search documents for the given students.
     */
    public void putStudentDocuments(List<StudentAttributes> students) {
        studentsLogic.putDocuments(students);
    }

    /**
     * Generates students list of a course in CSV format. <br>
     * Preconditions: <br>
     * * All parameters are non-null. <br>
     */
    public String getCourseStudentListAsCsv(String courseId, String googleId) throws EntityDoesNotExistException {

        Assumption.assertNotNull(courseId);
        Assumption.assertNotNull(googleId);

        return coursesLogic.getCourseStudentListAsCsv(courseId, googleId);
    }

    /**
     * Preconditions: <br>
     * * All parameters are non-null.
     */
    public void createFeedbackSession(FeedbackSessionAttributes feedbackSession)
            throws EntityAlreadyExistsException, InvalidParametersException {
        Assumption.assertNotNull(feedbackSession);
        feedbackSessionsLogic.createFeedbackSession(feedbackSession);
    }

    /**
     * Preconditions: <br>
     * * All parameters are non-null.
     */
    public FeedbackSessionAttributes copyFeedbackSession(String copiedFeedbackSessionName,
                                                         String copiedCourseId,
                                                         String feedbackSessionName,
                                                         String courseId,
                                                         String instructorEmail) throws EntityAlreadyExistsException,
                                                                                        InvalidParametersException,
                                                                                        EntityDoesNotExistException {

        Assumption.assertNotNull(copiedFeedbackSessionName);
        Assumption.assertNotNull(copiedCourseId);
        Assumption.assertNotNull(feedbackSessionName);
        Assumption.assertNotNull(courseId);
        Assumption.assertNotNull(instructorEmail);

        return feedbackSessionsLogic.copyFeedbackSession(copiedFeedbackSessionName,
                copiedCourseId, feedbackSessionName, courseId, instructorEmail);
    }

    /**
     * Preconditions: <br>
     * * All parameters are non-null.
     */
    public FeedbackSessionAttributes getFeedbackSession(String feedbackSessionName, String courseId) {

        Assumption.assertNotNull(feedbackSessionName);
        Assumption.assertNotNull(courseId);

        return feedbackSessionsLogic.getFeedbackSession(feedbackSessionName, courseId);
    }

    /**
     * Preconditions: <br>
     * * All parameters are non-null.
     */
    public List<FeedbackSessionAttributes> getFeedbackSessionsForCourse(String courseId) {
        Assumption.assertNotNull(courseId);
        return feedbackSessionsLogic.getFeedbackSessionsForCourse(courseId);
    }

    /**
     * Preconditions: <br>
     * * All parameters are non-null.
     */
    public FeedbackSessionDetailsBundle getFeedbackSessionDetails(String feedbackSessionName, String courseId)
            throws EntityDoesNotExistException {

        Assumption.assertNotNull(feedbackSessionName);
        Assumption.assertNotNull(courseId);

        FeedbackSessionAttributes fsa = feedbackSessionsLogic.getFeedbackSession(feedbackSessionName, courseId);

        return feedbackSessionsLogic.getFeedbackSessionDetails(fsa);
    }

    /**
     * Returns a {@code List} of all feedback sessions bundled with their
     * response statistics for a instructor given by his googleId.
     *
     * <p>Preconditions: <br>
     * * All parameters are non-null.
     *
     * @see FeedbackSessionsLogic#getFeedbackSessionDetailsForInstructor(String)
     */
    public List<FeedbackSessionDetailsBundle> getFeedbackSessionDetailsForInstructor(
            String googleId) throws EntityDoesNotExistException {
        Assumption.assertNotNull(googleId);
        return feedbackSessionsLogic.getFeedbackSessionDetailsForInstructor(googleId);
    }

    /**
     * Returns a {@code List} of all feedback sessions WITHOUT their response
     * statistics for a instructor given by his googleId.
     *
     * <p>Preconditions: <br>
     * * All parameters are non-null.
     *
     * @see FeedbackSessionsLogic#getFeedbackSessionsListForInstructor(String, boolean)
     */
    public List<FeedbackSessionAttributes> getFeedbackSessionsListForInstructor(String googleId, boolean omitArchived) {
        Assumption.assertNotNull(googleId);
        return feedbackSessionsLogic.getFeedbackSessionsListForInstructor(googleId, omitArchived);
    }

    public List<FeedbackSessionAttributes> getFeedbackSessionsListForInstructor(
            List<InstructorAttributes> instructorList) {
        Assumption.assertNotNull(instructorList);
        return feedbackSessionsLogic.getFeedbackSessionsListForInstructor(instructorList);
    }

    /**
     * Gets {@code FeedbackQuestions} and previously filled
     * {@code FeedbackResponses} that an instructor can view/submit as a
     * {@link FeedbackSessionQuestionsBundle}.
     *
     * <p>Preconditions: <br>
     * * All parameters are non-null.
     *
     * @see FeedbackSessionsLogic#getFeedbackSessionQuestionsForInstructor(String, String, String)
     */
    public FeedbackSessionQuestionsBundle getFeedbackSessionQuestionsBundleForInstructor(String feedbackSessionName,
                                                                                         String courseId,
                                                                                         String userEmail)
            throws EntityDoesNotExistException {

        Assumption.assertNotNull(feedbackSessionName);
        Assumption.assertNotNull(courseId);
        Assumption.assertNotNull(userEmail);

        return feedbackSessionsLogic.getFeedbackSessionQuestionsForInstructor(feedbackSessionName, courseId, userEmail);
    }

    public FeedbackSessionQuestionsBundle getFeedbackSessionQuestionsBundleForInstructor(
            String feedbackSessionName, String courseId, String questionId, String userEmail)
                throws EntityDoesNotExistException {

        Assumption.assertNotNull(feedbackSessionName);
        Assumption.assertNotNull(courseId);
        Assumption.assertNotNull(userEmail);

        return feedbackSessionsLogic
                   .getFeedbackSessionQuestionsForInstructor(feedbackSessionName, courseId, questionId, userEmail);
    }

    /**
     * Gets {@code FeedbackQuestions} and previously filled
     * {@code FeedbackResponses} that a student can view/submit as a
     * {@link FeedbackSessionQuestionsBundle}.
     *
     * <p>Preconditions: <br>
     * * All parameters are non-null.
     *
     * @see FeedbackSessionsLogic#getFeedbackSessionQuestionsForStudent(String, String, String)
     */
    public FeedbackSessionQuestionsBundle getFeedbackSessionQuestionsBundleForStudent(String feedbackSessionName,
                                                                                      String courseId,
                                                                                      String userEmail)
            throws EntityDoesNotExistException {

        Assumption.assertNotNull(feedbackSessionName);
        Assumption.assertNotNull(courseId);
        Assumption.assertNotNull(userEmail);

        return feedbackSessionsLogic.getFeedbackSessionQuestionsForStudent(feedbackSessionName, courseId, userEmail);
    }

    public FeedbackSessionQuestionsBundle getFeedbackSessionQuestionsBundleForStudent(
            String feedbackSessionName, String courseId, String questionId, String userEmail)
                throws EntityDoesNotExistException {

        Assumption.assertNotNull(feedbackSessionName);
        Assumption.assertNotNull(courseId);
        Assumption.assertNotNull(userEmail);

        return feedbackSessionsLogic
                   .getFeedbackSessionQuestionsForStudent(feedbackSessionName, courseId, questionId, userEmail);
    }

    public FeedbackQuestionAttributes getFeedbackQuestion(String feedbackSessionName,
                                                          String courseId,
                                                          int questionNumber) {
        Assumption.assertNotNull(feedbackSessionName);
        Assumption.assertNotNull(courseId);

        return feedbackQuestionsLogic.getFeedbackQuestion(feedbackSessionName, courseId, questionNumber);
    }

    /**
     * Preconditions: <br>
     * * All parameters are non-null. <br>
     *
     */
    public FeedbackQuestionAttributes getFeedbackQuestion(String feedbackQuestionId) {
        Assumption.assertNotNull(feedbackQuestionId);
        return feedbackQuestionsLogic.getFeedbackQuestion(feedbackQuestionId);
    }

    /**
     * Generates summary results (without comments) in CSV format. <br>
     * Preconditions: <br>
     * * All parameters(except questionId) are non-null. <br>
     * @see FeedbackSessionsLogic#getFeedbackSessionResultsSummaryAsCsv(String, String,
     *      String, String, boolean, boolean)
     */
    public String getFeedbackSessionResultSummaryAsCsv(
            String courseId, String feedbackSessionName, String instructorEmail,
            boolean isMissingResponsesShown, boolean isStatsShown, String questionId)
            throws EntityDoesNotExistException, ExceedingRangeException {

        Assumption.assertNotNull(courseId);
        Assumption.assertNotNull(feedbackSessionName);

        return feedbackSessionsLogic.getFeedbackSessionResultsSummaryAsCsv(
                feedbackSessionName, courseId, instructorEmail, questionId,
                isMissingResponsesShown, isStatsShown);
    }

    /**
     * Generates summary results (without comments) within a section in CSV format. <br>
     * Preconditions: <br>
     * * All parameters(except questionId) are non-null. <br>
     * @see FeedbackSessionsLogic#getFeedbackSessionResultsSummaryInSectionAsCsv(String, String, String,
     *      String, String, boolean, boolean)
     */
    public String getFeedbackSessionResultSummaryInSectionAsCsv(
            String courseId, String feedbackSessionName, String instructorEmail,
            String section, String questionId, boolean isMissingResponsesShown, boolean isStatsShown)
            throws EntityDoesNotExistException, ExceedingRangeException {

        Assumption.assertNotNull(courseId);
        Assumption.assertNotNull(feedbackSessionName);
        Assumption.assertNotNull(section);

        return feedbackSessionsLogic.getFeedbackSessionResultsSummaryInSectionAsCsv(
                feedbackSessionName, courseId, instructorEmail, section,
                questionId, isMissingResponsesShown, isStatsShown);
    }

    /**
     * Preconditions: <br>
     * * All parameters are non-null.
     * @return a list of viewable feedback sessions for any user in the course.
     */
    public List<FeedbackSessionAttributes> getFeedbackSessionsForUserInCourse(String courseId, String userEmail)
            throws EntityDoesNotExistException {
        Assumption.assertNotNull(userEmail);
        Assumption.assertNotNull(courseId);

        return feedbackSessionsLogic.getFeedbackSessionsForUserInCourse(courseId, userEmail);
    }

    /**
     * Preconditions: <br>
     * * All parameters are non-null.
     */
    public boolean hasStudentSubmittedFeedback(FeedbackSessionAttributes fsa, String studentEmail) {

        Assumption.assertNotNull(fsa);
        Assumption.assertNotNull(studentEmail);

        return feedbackSessionsLogic.isFeedbackSessionCompletedByStudent(fsa, studentEmail);
    }

    /**
     * Updates the details of a feedback session <br>
     * Does not affect the questions and responses associated with it.
     * Preconditions: <br>
     * * All parameters are non-null.
     */
    public void updateFeedbackSession(FeedbackSessionAttributes updatedSession) throws InvalidParametersException,
                                                                                       EntityDoesNotExistException {

        Assumption.assertNotNull(updatedSession);
        feedbackSessionsLogic.updateFeedbackSession(updatedSession);
    }

    public void updateRespondents(String feedbackSessionName, String courseId) throws InvalidParametersException,
                                                                                      EntityDoesNotExistException {
        Assumption.assertNotNull(feedbackSessionName);
        Assumption.assertNotNull(courseId);

        feedbackSessionsLogic.updateRespondentsForSession(feedbackSessionName, courseId);
    }

    public void addInstructorRespondent(String email, String feedbackSessionName, String courseId)
            throws EntityDoesNotExistException, InvalidParametersException {

        Assumption.assertNotNull(email);
        Assumption.assertNotNull(feedbackSessionName);
        Assumption.assertNotNull(courseId);

        feedbackSessionsLogic.addInstructorRespondent(email, feedbackSessionName, courseId);
    }

    public void addStudentRespondent(String email, String feedbackSessionName, String courseId)
            throws EntityDoesNotExistException, InvalidParametersException {

        Assumption.assertNotNull(email);
        Assumption.assertNotNull(feedbackSessionName);
        Assumption.assertNotNull(courseId);

        feedbackSessionsLogic.addStudentRespondent(email, feedbackSessionName, courseId);
    }

    public void deleteInstructorRespondent(String email, String feedbackSessionName, String courseId)
            throws EntityDoesNotExistException, InvalidParametersException {

        Assumption.assertNotNull(email);
        Assumption.assertNotNull(feedbackSessionName);
        Assumption.assertNotNull(courseId);

        feedbackSessionsLogic.deleteInstructorRespondent(email, feedbackSessionName, courseId);
    }

    public void deleteStudentRespondent(String email, String feedbackSessionName, String courseId)
            throws EntityDoesNotExistException, InvalidParametersException {

        Assumption.assertNotNull(email);
        Assumption.assertNotNull(feedbackSessionName);
        Assumption.assertNotNull(courseId);

        feedbackSessionsLogic.deleteStudentFromRespondentList(email, feedbackSessionName, courseId);
    }

    /**
     * Publishes the feedback session and send email alerts to students.
     * Preconditions: <br>
     * * All parameters are non-null. <br>
     * @throws InvalidParametersException
     *             if the feedback session is not ready to be published.
     */
    public void publishFeedbackSession(FeedbackSessionAttributes session)
            throws EntityDoesNotExistException, InvalidParametersException {

        Assumption.assertNotNull(session);

        feedbackSessionsLogic.publishFeedbackSession(session);
    }

    /**
     * Preconditions: <br>
     * * All parameters are non-null. <br>
     * @throws InvalidParametersException
     *             if the feedback session is not ready to be unpublished.
     */
    public void unpublishFeedbackSession(FeedbackSessionAttributes session)
            throws EntityDoesNotExistException, InvalidParametersException {

        Assumption.assertNotNull(session);

        feedbackSessionsLogic.unpublishFeedbackSession(session);
    }

    /**
     * Deletes the feedback session but not the questions and
     * responses associated to it.
     * Fails silently if no such feedback session. <br>
     * Preconditions: <br>
     * * All parameters are non-null.
     */
    public void deleteFeedbackSession(String feedbackSessionName, String courseId) {

        Assumption.assertNotNull(feedbackSessionName);
        Assumption.assertNotNull(courseId);

        feedbackSessionsLogic.deleteFeedbackSessionCascade(feedbackSessionName, courseId);
    }

    /**
     * Preconditions: <br>
     * * All parameters are non-null.
     */
    public void createFeedbackQuestion(FeedbackQuestionAttributes feedbackQuestion) throws InvalidParametersException {
        Assumption.assertNotNull(feedbackQuestion);
        feedbackQuestionsLogic.createFeedbackQuestion(feedbackQuestion);
    }

    /**
     * Used for creating initial questions for template sessions only.
     * Does not check if feedback session exists.
     * Does not check if question number supplied is valid(does not check for clashes, or make adjustments)
     * Preconditions: <br>
     * * All parameters are non-null.
     * * questionNumber is > 0
     */
    public FeedbackQuestionAttributes createFeedbackQuestionForTemplate(
            FeedbackQuestionAttributes feedbackQuestion, int questionNumber)
            throws InvalidParametersException {

        Assumption.assertNotNull(feedbackQuestion);
        Assumption.assertTrue(questionNumber > 0);
        return feedbackQuestionsLogic.createFeedbackQuestionNoIntegrityCheck(feedbackQuestion, questionNumber);
    }

    /**
     * Preconditions: <br>
     * * All parameters are non-null.
     */
    public FeedbackQuestionAttributes copyFeedbackQuestion(String feedbackQuestionId, String feedbackSessionName,
                                                           String courseId, String instructorEmail)
            throws InvalidParametersException {

        Assumption.assertNotNull(feedbackQuestionId);
        Assumption.assertNotNull(feedbackSessionName);
        Assumption.assertNotNull(courseId);
        Assumption.assertNotNull(instructorEmail);

        return feedbackQuestionsLogic.copyFeedbackQuestion(feedbackQuestionId, feedbackSessionName,
                                                           courseId, instructorEmail);
    }

    /**
     * Updates the question number of a Feedback Question.<br>
     * Preconditions: <br>
     * * All parameters are non-null.
     */
    public void updateFeedbackQuestionNumber(FeedbackQuestionAttributes updatedQuestion)
            throws InvalidParametersException, EntityDoesNotExistException {

        Assumption.assertNotNull(updatedQuestion);
        feedbackQuestionsLogic.updateFeedbackQuestionNumber(updatedQuestion);
    }

    /**
     * Updates the details of a Feedback Question.<br>
     * The FeedbackQuestionAttributes should have the updated attributes
     * together with the original ID of the question. Preserves null
     * attributes.
     * Preconditions: <br>
     * * All parameters are non-null.
     */
    public void updateFeedbackQuestion(FeedbackQuestionAttributes updatedQuestion)
            throws InvalidParametersException, EntityDoesNotExistException {

        Assumption.assertNotNull(updatedQuestion);
        feedbackQuestionsLogic.updateFeedbackQuestion(updatedQuestion);
    }

    /**
     * Deletes the feedback question and the responses associated to it. Fails
     * silently if there is no such feedback question. <br>
     * Preconditions: <br>
     * * All parameters are non-null.
     */
    public void deleteFeedbackQuestion(String questionId) {
        Assumption.assertNotNull(questionId);
        feedbackQuestionsLogic.deleteFeedbackQuestionCascade(questionId);
    }

    /**
     * Returns true if there is at least one response for the given feedback question,
     * false if not.
     * for the session.
     * Preconditions: <br>
     * * All parameters are non-null.
     */

    public boolean areThereResponsesForQuestion(String feedbackQuestionId) {
        return feedbackQuestionsLogic.areThereResponsesForQuestion(feedbackQuestionId);
    }

    /**
     * Gets all copiable questions for an instructor<br>
     * Returns an empty list if they are no questions
     * for the session.
     * Preconditions: <br>
     * * All parameters are non-null.
     */
    public List<FeedbackQuestionAttributes> getCopiableFeedbackQuestionsForInstructor(String googleId)
            throws EntityDoesNotExistException {
        Assumption.assertNotNull(googleId);
        return feedbackQuestionsLogic.getCopiableFeedbackQuestionsForInstructor(googleId);
    }

    /**
     * Gets all questions for a feedback session.<br>
     * Returns an empty list if they are no questions
     * for the session.
     * Preconditions: <br>
     * * All parameters are non-null.
     */
    public List<FeedbackQuestionAttributes> getFeedbackQuestionsForSession(String feedbackSessionName, String courseId)
            throws EntityDoesNotExistException {
        Assumption.assertNotNull(feedbackSessionName);
        Assumption.assertNotNull(courseId);

        return feedbackQuestionsLogic.getFeedbackQuestionsForSession(feedbackSessionName, courseId);
    }

    /**
     * Gets the response rate status for a session.
     *
     * <p>Preconditions: <br>
     * * All parameters are non-null.
     *
     * @see FeedbackSessionsLogic#getFeedbackSessionResponseStatus(String, String)
     */
    public FeedbackSessionResponseStatus getFeedbackSessionResponseStatus(String feedbackSessionName, String courseId)
            throws EntityDoesNotExistException {

        Assumption.assertNotNull(feedbackSessionName);
        Assumption.assertNotNull(courseId);

        return feedbackSessionsLogic.getFeedbackSessionResponseStatus(feedbackSessionName, courseId);
    }

    /**
     * Gets a question+response bundle for questions with responses that
     * is visible to the student for a feedback session.
     * Preconditions: <br>
     * * All parameters are non-null.
     */
    public FeedbackSessionResultsBundle getFeedbackSessionResultsForStudent(String feedbackSessionName,
                                                                            String courseId, String userEmail)
            throws EntityDoesNotExistException {
        Assumption.assertNotNull(feedbackSessionName);
        Assumption.assertNotNull(courseId);
        Assumption.assertNotNull(userEmail);

        return feedbackSessionsLogic.getFeedbackSessionResultsForStudent(feedbackSessionName, courseId, userEmail);
    }

    /**
     * Gets a question+response bundle for questions with responses that
     * is visible to the student for a feedback session.
     * Preconditions: <br>
     * * All parameters are non-null.
     */
    public FeedbackSessionResultsBundle getFeedbackSessionResultsForStudent(String feedbackSessionName,
                                                                            String courseId, String userEmail,
                                                                            CourseRoster roster)
            throws EntityDoesNotExistException {

        Assumption.assertNotNull(feedbackSessionName);
        Assumption.assertNotNull(courseId);
        Assumption.assertNotNull(userEmail);
        Assumption.assertNotNull(roster);

        return feedbackSessionsLogic.getFeedbackSessionResultsForStudent(feedbackSessionName, courseId,
                                                                         userEmail, roster);
    }

    /**
     * Gets a question+response bundle for questions with responses that
     * is visible to the instructor for a feedback session within the given range
     * Preconditions: <br>
     * * All parameters are non-null.
     */
    public FeedbackSessionResultsBundle getFeedbackSessionResultsForInstructorWithinRangeFromView(
            String feedbackSessionName, String courseId, String userEmail, int range, String viewType)
            throws EntityDoesNotExistException {

        Assumption.assertNotNull(feedbackSessionName);
        Assumption.assertNotNull(courseId);
        Assumption.assertNotNull(userEmail);
        Assumption.assertNotNull(viewType);

        return feedbackSessionsLogic.getFeedbackSessionResultsForInstructorWithinRangeFromView(feedbackSessionName,
                                                                                               courseId, userEmail,
                                                                                               range, viewType);
    }

    /**
     * Gets a question+response bundle for questions with responses that
     * is visible to the instructor for a feedback session in a section within the given range
     * Preconditions: <br>
     * * All parameters are non-null.
     */
    public FeedbackSessionResultsBundle getFeedbackSessionResultsForInstructorInSectionWithinRangeFromView(
            String feedbackSessionName, String courseId, String userEmail, String section, int range, String viewType)
            throws EntityDoesNotExistException {

        Assumption.assertNotNull(feedbackSessionName);
        Assumption.assertNotNull(courseId);
        Assumption.assertNotNull(userEmail);
        Assumption.assertNotNull(viewType);

        return feedbackSessionsLogic.getFeedbackSessionResultsForInstructorInSectionWithinRangeFromView(
                                        feedbackSessionName, courseId, userEmail, section, range, viewType);
    }

    /**
     * Gets a question+response bundle for questions with responses that
     * is visible to the instructor for a feedback session from a section within the given range
     * Preconditions: <br>
     * * All parameters are non-null.
     */
    public FeedbackSessionResultsBundle getFeedbackSessionResultsForInstructorFromSectionWithinRange(
            String feedbackSessionName, String courseId, String userEmail, String section, int range)
            throws EntityDoesNotExistException {

        Assumption.assertNotNull(feedbackSessionName);
        Assumption.assertNotNull(courseId);
        Assumption.assertNotNull(userEmail);

        return feedbackSessionsLogic.getFeedbackSessionResultsForInstructorFromSectionWithinRange(
                                        feedbackSessionName, courseId, userEmail, section, range);
    }

    /**
     * Gets a question+response bundle for questions with responses that
     * is visible to the instructor for a feedback session to a section within the given range
     * Preconditions: <br>
     * * All parameters are non-null.
     */
    public FeedbackSessionResultsBundle getFeedbackSessionResultsForInstructorToSectionWithinRange(
            String feedbackSessionName, String courseId, String userEmail, String section, int range)
            throws EntityDoesNotExistException {

        Assumption.assertNotNull(feedbackSessionName);
        Assumption.assertNotNull(courseId);
        Assumption.assertNotNull(userEmail);

        return feedbackSessionsLogic.getFeedbackSessionResultsForInstructorToSectionWithinRange(
                                        feedbackSessionName, courseId, userEmail, section, range);
    }

    /**
     * Gets a question+response bundle for questions with responses that
     * is visible to the instructor for a feedback session from a given question number
     * This will not retrieve the list of comments for this question
     * Preconditions: <br>
     * * All parameters are non-null.
     */
    public FeedbackSessionResultsBundle getFeedbackSessionResultsForInstructorFromQuestion(
            String feedbackSessionName, String courseId, String userEmail, String questionId)
            throws EntityDoesNotExistException {

        Assumption.assertNotNull(feedbackSessionName);
        Assumption.assertNotNull(courseId);
        Assumption.assertNotNull(userEmail);

        return feedbackSessionsLogic.getFeedbackSessionResultsForInstructorFromQuestion(feedbackSessionName, courseId,
                                                                                        userEmail, questionId);
    }

    /**
     * Gets a question+response bundle for questions with responses that
     * is visible to the instructor for a feedback session from a given question number
     * in a given section.
     * This will not retrieve the list of comments for this question
     * Preconditions: <br>
     * * All parameters are non-null.
     */
    public FeedbackSessionResultsBundle getFeedbackSessionResultsForInstructorFromQuestionInSection(
                                    String feedbackSessionName, String courseId, String userEmail,
                                    String questionId, String selectedSection)
            throws EntityDoesNotExistException {

        Assumption.assertNotNull(feedbackSessionName);
        Assumption.assertNotNull(courseId);
        Assumption.assertNotNull(userEmail);

        return feedbackSessionsLogic.getFeedbackSessionResultsForInstructorFromQuestionInSection(
                                            feedbackSessionName, courseId, userEmail,
                                            questionId, selectedSection);
    }

    /**
     * Gets a question+response bundle for questions with responses that
     * is visible to the instructor for a feedback session.
     * Preconditions: <br>
     * * All parameters are non-null.
     */
    public FeedbackSessionResultsBundle getFeedbackSessionResultsForInstructor(
            String feedbackSessionName, String courseId, String userEmail)
            throws EntityDoesNotExistException {

        Assumption.assertNotNull(feedbackSessionName);
        Assumption.assertNotNull(courseId);
        Assumption.assertNotNull(userEmail);

        return feedbackSessionsLogic.getFeedbackSessionResultsForInstructor(feedbackSessionName, courseId, userEmail);
    }

    /**
     * Gets a question+response bundle for questions with responses that
     * is visible to the instructor for a feedback session in a specific section.
     * Preconditions: <br>
     * * All parameters are non-null.
     */
    public FeedbackSessionResultsBundle getFeedbackSessionResultsForInstructorInSection(String feedbackSessionName,
                                                                                        String courseId,
                                                                                        String userEmail,
                                                                                        String section)
            throws EntityDoesNotExistException {

        Assumption.assertNotNull(feedbackSessionName);
        Assumption.assertNotNull(courseId);
        Assumption.assertNotNull(userEmail);
        Assumption.assertNotNull(section);

        return feedbackSessionsLogic.getFeedbackSessionResultsForInstructorInSection(feedbackSessionName, courseId,
                                                                                     userEmail, section);
    }

    /**
     * Gets a question+response bundle for questions with responses that
     * is visible to the instructor for a feedback session in a specific section.
     * Preconditions: <br>
     * * All parameters are non-null.
     */
    public FeedbackSessionResultsBundle getFeedbackSessionResultsForInstructorFromSection(String feedbackSessionName,
                                                                                          String courseId,
                                                                                          String userEmail,
                                                                                          String section)
            throws EntityDoesNotExistException {

        Assumption.assertNotNull(feedbackSessionName);
        Assumption.assertNotNull(courseId);
        Assumption.assertNotNull(userEmail);
        Assumption.assertNotNull(section);

        return feedbackSessionsLogic.getFeedbackSessionResultsForInstructorFromSection(feedbackSessionName, courseId,
                                                                                       userEmail, section);
    }

    /**
     * Gets a question+response bundle for questions with responses that
     * is visible to the instructor for a feedback session in a specific section.
     * Preconditions: <br>
     * * All parameters are non-null.
     */
    public FeedbackSessionResultsBundle getFeedbackSessionResultsForInstructorToSection(String feedbackSessionName,
                                                                                        String courseId,
                                                                                        String userEmail,
                                                                                        String section)
            throws EntityDoesNotExistException {

        Assumption.assertNotNull(feedbackSessionName);
        Assumption.assertNotNull(courseId);
        Assumption.assertNotNull(userEmail);
        Assumption.assertNotNull(section);

        return feedbackSessionsLogic.getFeedbackSessionResultsForInstructorToSection(feedbackSessionName, courseId,
                                                                                     userEmail, section);
    }

    public FeedbackResponseAttributes getFeedbackResponse(String feedbackResponseId) {
        Assumption.assertNotNull(feedbackResponseId);
        return feedbackResponsesLogic.getFeedbackResponse(feedbackResponseId);
    }

    public FeedbackResponseAttributes getFeedbackResponse(String feedbackQuestionId,
                                                          String giverEmail,
                                                          String recipient) {

        Assumption.assertNotNull(feedbackQuestionId);
        Assumption.assertNotNull(giverEmail);
        Assumption.assertNotNull(recipient);

        return feedbackResponsesLogic.getFeedbackResponse(feedbackQuestionId, giverEmail, recipient);
    }

    /**
     * Preconditions: <br>
     * * All parameters are non-null.
     */
    public void createFeedbackResponse(FeedbackResponseAttributes feedbackResponse)
            throws InvalidParametersException, EntityDoesNotExistException {

        Assumption.assertNotNull(feedbackResponse);
        feedbackResponsesLogic.createFeedbackResponse(feedbackResponse);
    }

    public void createFeedbackResponses(List<FeedbackResponseAttributes> feedbackResponses)
            throws InvalidParametersException, EntityDoesNotExistException {

        Assumption.assertNotNull(feedbackResponses);
        feedbackResponsesLogic.createFeedbackResponses(feedbackResponses);
    }

    public List<FeedbackResponseAttributes> getFeedbackResponsesForQuestion(String questionId) {
        Assumption.assertNotNull(questionId);
        return feedbackResponsesLogic.getFeedbackResponsesForQuestion(questionId);
    }

    public boolean hasGiverRespondedForSession(String userEmail, String feedbackSessionName, String courseId) {
        Assumption.assertNotNull(userEmail);
        Assumption.assertNotNull(feedbackSessionName);
        Assumption.assertNotNull(courseId);

        return feedbackResponsesLogic.hasGiverRespondedForSession(userEmail, feedbackSessionName, courseId);
    }

    public boolean hasResponsesForCourse(String courseId) {
        return feedbackResponsesLogic.hasResponsesForCourse(courseId);
    }

    public boolean isOpenOrPublishedEmailSentForTheCourse(String courseId) {
        Assumption.assertNotNull(courseId);
        return feedbackSessionsLogic.isOpenOrPublishedEmailSentForTheCourse(courseId);
    }

    /**
     * Preconditions: <br>
     * * All parameters are non-null.
     */
    public void updateFeedbackResponse(FeedbackResponseAttributes feedbackResponse)
            throws InvalidParametersException, EntityDoesNotExistException, EntityAlreadyExistsException {

        Assumption.assertNotNull(feedbackResponse);
        feedbackResponsesLogic.updateFeedbackResponse(feedbackResponse);
    }

    /**
     * Preconditions: <br>
     * * All parameters are non-null.
     */
    public void deleteFeedbackResponse(FeedbackResponseAttributes feedbackResponse) {
        Assumption.assertNotNull(feedbackResponse);
        feedbackResponsesLogic.deleteFeedbackResponseAndCascade(feedbackResponse);
    }

    /**
     * Create a feedback response comment, and return the created comment
     * Preconditions: <br>
     * * All parameters are non-null.
     */
    public FeedbackResponseCommentAttributes createFeedbackResponseComment(
            FeedbackResponseCommentAttributes feedbackResponseComment)
            throws InvalidParametersException, EntityDoesNotExistException {
        Assumption.assertNotNull(feedbackResponseComment);
        return feedbackResponseCommentsLogic.createFeedbackResponseComment(feedbackResponseComment);
    }

    public FeedbackResponseCommentAttributes getFeedbackResponseComment(Long feedbackResponseCommentId) {
        Assumption.assertNotNull(feedbackResponseCommentId);
        return feedbackResponseCommentsLogic.getFeedbackResponseComment(feedbackResponseCommentId);
    }

    public List<FeedbackResponseCommentAttributes> getFeedbackResponseCommentForGiver(String courseId,
                                                                                      String giverEmail) {
        Assumption.assertNotNull(courseId);
        Assumption.assertNotNull(giverEmail);

        return feedbackResponseCommentsLogic.getFeedbackResponseCommentsForGiver(courseId, giverEmail);
    }

    /**
     * Preconditions: <br>
     * * All parameters are non-null.
     */
    public FeedbackResponseCommentAttributes getFeedbackResponseComment(String responseId,
                                                                        String giverEmail,
                                                                        Date creationDate) {
        Assumption.assertNotNull(responseId);
        Assumption.assertNotNull(giverEmail);
        Assumption.assertNotNull(creationDate);

        return feedbackResponseCommentsLogic.getFeedbackResponseComment(responseId, giverEmail, creationDate);
    }

    /**
     * Creates or updates document for the given comment.
     *
     * @see FeedbackResponseCommentsLogic#putDocument(FeedbackResponseCommentAttributes)
     */
    public void putDocument(FeedbackResponseCommentAttributes comment) {
        feedbackResponseCommentsLogic.putDocument(comment);
    }

    /**
     * Batch creates or updates documents for the given comments.
     *
     * @see FeedbackResponseCommentsLogic#putDocuments(List)
     */
    public void putFeedbackResponseCommentDocuments(List<FeedbackResponseCommentAttributes> comments) {
        feedbackResponseCommentsLogic.putDocuments(comments);
    }

    /**
     * Removes document for the given comment.
     *
     * @see FeedbackResponseCommentsLogic#deleteDocument(FeedbackResponseCommentAttributes)
     */
    public void deleteDocument(FeedbackResponseCommentAttributes comment) {
        feedbackResponseCommentsLogic.deleteDocument(comment);
    }

    /**
     * Search for FeedbackResponseComment. Preconditions: all parameters are non-null.
     * @param instructors   a list of InstructorAttributes associated to a googleId,
     *                      used for filtering of search result
     * @return Null if no match found
     */
    public FeedbackResponseCommentSearchResultBundle searchFeedbackResponseComments(String queryString,
                                                                         List<InstructorAttributes> instructors) {
        Assumption.assertNotNull(queryString);
        Assumption.assertNotNull(instructors);
        return feedbackResponseCommentsLogic.searchFeedbackResponseComments(queryString, instructors);
    }

    /**
     * Update a feedback response comment and return the updated feedback response comment
     * Preconditions: <br>
     * * All parameters are non-null.
     */
    public FeedbackResponseCommentAttributes updateFeedbackResponseComment(
            FeedbackResponseCommentAttributes feedbackResponseComment)
            throws EntityDoesNotExistException, InvalidParametersException {

        Assumption.assertNotNull(feedbackResponseComment);
        return feedbackResponseCommentsLogic.updateFeedbackResponseComment(feedbackResponseComment);
    }

    /**
     * Preconditions: <br>
     * * All parameters are non-null.
     */
    public void deleteFeedbackResponseComment(FeedbackResponseCommentAttributes feedbackResponseComment) {
        Assumption.assertNotNull(feedbackResponseComment);
        feedbackResponseCommentsLogic.deleteFeedbackResponseComment(feedbackResponseComment);
    }

    /**
     * This method is not scalable. Not to be used unless for admin features.
     * @return the list of all adminEmails in the database.
     * <br> Empty List if no admin email found
     */
    @SuppressWarnings(""deprecation"")
    public List<AdminEmailAttributes> getAllAdminEmails() {
        return adminEmailsLogic.getAllAdminEmails();
    }

    /**
     * Gets an admin email by email id.
     *
     * @see AdminEmailsLogic#getAdminEmailById(String)
     */
    public AdminEmailAttributes getAdminEmailById(String emailId) {
        Assumption.assertNotNull(emailId);
        return adminEmailsLogic.getAdminEmailById(emailId);
    }

    public Date createAdminEmail(AdminEmailAttributes newAdminEmail) throws InvalidParametersException {
        Assumption.assertNotNull(newAdminEmail);
        return adminEmailsLogic.createAdminEmail(newAdminEmail);
    }

    /**
     * Move an admin email to trash bin.<br>
     * After this the attribute isInTrashBin will be set to true
     */
    public void moveAdminEmailToTrashBin(String adminEmailId)
            throws InvalidParametersException, EntityDoesNotExistException {

        Assumption.assertNotNull(adminEmailId);
        adminEmailsLogic.moveAdminEmailToTrashBin(adminEmailId);
    }

    /**
     * Move an admin email out of trash bin.<br>
     * After this the attribute isInTrashBin will be set to false
     */
    public void moveAdminEmailOutOfTrashBin(String adminEmailId)
            throws InvalidParametersException, EntityDoesNotExistException {

        Assumption.assertNotNull(adminEmailId);
        adminEmailsLogic.moveAdminEmailOutOfTrashBin(adminEmailId);
    }

    /**
     * Gets all admin emails that have been sent and not in trash bin.
     *
     * @see AdminEmailsLogic#getSentAdminEmails()
     */
    public List<AdminEmailAttributes> getSentAdminEmails() {
        return adminEmailsLogic.getSentAdminEmails();
    }

    /**
     * Gets all admin email drafts that have NOT been sent and NOT in trash bin.
     *
     * @see AdminEmailsLogic#getAdminEmailDrafts()
     */
    public List<AdminEmailAttributes> getAdminEmailDrafts() {
        return adminEmailsLogic.getAdminEmailDrafts();
    }

    /**
     * Gets all admin emails that have been moved into trash bin.
     *
     * @see AdminEmailsLogic#getAdminEmailsInTrashBin()
     */
    public List<AdminEmailAttributes> getAdminEmailsInTrashBin() {
        return adminEmailsLogic.getAdminEmailsInTrashBin();
    }

    /**
     * Updates an admin email by email id.
     *
     * @see AdminEmailsLogic#updateAdminEmailById(AdminEmailAttributes, String)
     */
    public void updateAdminEmailById(AdminEmailAttributes newAdminEmail, String emailId)
            throws InvalidParametersException, EntityDoesNotExistException {

        Assumption.assertNotNull(emailId);
        Assumption.assertNotNull(newAdminEmail);

        adminEmailsLogic.updateAdminEmailById(newAdminEmail, emailId);
    }

    /**
     * Gets an admin email by subject and createDate.
     *
     * @see AdminEmailsLogic#getAdminEmail(String, Date).
     */
    public AdminEmailAttributes getAdminEmail(String subject, Date createDate) {
        Assumption.assertNotNull(subject);
        Assumption.assertNotNull(createDate);

        return adminEmailsLogic.getAdminEmail(subject, createDate);
    }

    /**
     * Deletes all emails in trash bin.
     *
     * @see AdminEmailsLogic#deleteAllEmailsInTrashBin()
     */
    public void deleteAllEmailsInTrashBin() {
        adminEmailsLogic.deleteAllEmailsInTrashBin();
    }

    /**
     * Deletes files uploaded in admin email compose page.
     *
     * @see AdminEmailsLogic#deleteAdminEmailUploadedFile(BlobKey)
     */
    public void deleteAdminEmailUploadedFile(BlobKey key) {
        Assumption.assertNotNull(key);
        adminEmailsLogic.deleteAdminEmailUploadedFile(key);
    }

    /**
     * Deletes uploaded file.
     * @param key the GCS blobkey used to fetch the file in Google Cloud Storage
     */
    public void deleteUploadedFile(BlobKey key) {
        Assumption.assertNotNull(key);
        GoogleCloudStorageHelper.deleteFile(key);
    }

    public List<String> getArchivedCourseIds(List<CourseAttributes> allCourses,
                                             Map<String, InstructorAttributes> instructorsForCourses) {
        Assumption.assertNotNull(allCourses);
        Assumption.assertNotNull(instructorsForCourses);
        return coursesLogic.getArchivedCourseIds(allCourses, instructorsForCourses);
    }

    public List<FeedbackResponseAttributes>
            getFeedbackResponsesForSession(String feedbackSessionName, String courseId) {
        Assumption.assertNotNull(feedbackSessionName);
        Assumption.assertNotNull(courseId);
        return feedbackResponsesLogic.getFeedbackResponsesForSession(feedbackSessionName, courseId);
    }

    public void adjustFeedbackResponseForEnrollments(List<StudentEnrollDetails> enrollmentList,
                                                     FeedbackResponseAttributes response)
            throws InvalidParametersException, EntityDoesNotExistException {
        Assumption.assertNotNull(enrollmentList);
        Assumption.assertNotNull(response);
        studentsLogic.adjustFeedbackResponseForEnrollments(enrollmentList, response);
    }

    /**
     * Returns returns a list of sessions that were closed within past hour.
     *
     * @see FeedbackSessionsLogic#getFeedbackSessionsClosedWithinThePastHour()
     */
    public List<FeedbackSessionAttributes> getFeedbackSessionsClosedWithinThePastHour() {
        return feedbackSessionsLogic.getFeedbackSessionsClosedWithinThePastHour();
    }

    public List<FeedbackSessionAttributes> getFeedbackSessionsClosingWithinTimeLimit() {
        return feedbackSessionsLogic.getFeedbackSessionsClosingWithinTimeLimit();
    }

    /**
     * Returns a list of sessions that require automated emails to be sent as they are published.
     *
     * @see FeedbackSessionsLogic#getFeedbackSessionsWhichNeedAutomatedPublishedEmailsToBeSent()
     */
    public List<FeedbackSessionAttributes> getFeedbackSessionsWhichNeedAutomatedPublishedEmailsToBeSent() {
        return feedbackSessionsLogic.getFeedbackSessionsWhichNeedAutomatedPublishedEmailsToBeSent();
    }

    public List<FeedbackSessionAttributes> getFeedbackSessionsWhichNeedOpenEmailsToBeSent() {
        return feedbackSessionsLogic.getFeedbackSessionsWhichNeedOpenEmailsToBeSent();
    }

    public String getSectionForTeam(String courseId, String teamName) {
        Assumption.assertNotNull(courseId);
        Assumption.assertNotNull(teamName);
        return studentsLogic.getSectionForTeam(courseId, teamName);
    }

}
"
package-info.java,logic-api,"/**
 * Provides the API of the component to be accessed by the UI.
 */
package teammates.logic.api;
"
TaskQueuer.java,logic-api,"package teammates.logic.api;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

import teammates.common.datatransfer.StudentEnrollDetails;
import teammates.common.util.Const.ParamsNames;
import teammates.common.util.Const.TaskQueue;
import teammates.common.util.EmailWrapper;
import teammates.common.util.JsonUtils;
import teammates.common.util.Logger;
import teammates.common.util.TaskWrapper;
import teammates.logic.core.TaskQueuesLogic;

/**
 * Allows for adding specific type of tasks to the task queue.
 */
public class TaskQueuer {

    private static final Logger log = Logger.getLogger();

    // The following methods are facades to the actual logic for adding tasks to the queue.
    // Using this method, the actual logic can still be black-boxed
    // while at the same time allowing this API to be mocked during test.

    protected void addTask(String queueName, String workerUrl, Map<String, String> paramMap) {
        Map<String, String[]> multisetParamMap = new HashMap<>();
        for (Map.Entry<String, String> entry : paramMap.entrySet()) {
            multisetParamMap.put(entry.getKey(), new String[] { entry.getValue() });
        }
        TaskWrapper task = new TaskWrapper(queueName, workerUrl, multisetParamMap);
        new TaskQueuesLogic().addTask(task);
    }

    protected void addDeferredTask(String queueName, String workerUrl, Map<String, String> paramMap,
                                   long countdownTime) {
        Map<String, String[]> multisetParamMap = new HashMap<>();
        for (Map.Entry<String, String> entry : paramMap.entrySet()) {
            multisetParamMap.put(entry.getKey(), new String[] { entry.getValue() });
        }
        TaskWrapper task = new TaskWrapper(queueName, workerUrl, multisetParamMap);
        new TaskQueuesLogic().addDeferredTask(task, countdownTime);
    }

    protected void addTaskMultisetParam(String queueName, String workerUrl, Map<String, String[]> paramMap) {
        TaskWrapper task = new TaskWrapper(queueName, workerUrl, paramMap);
        new TaskQueuesLogic().addTask(task);
    }

    /**
     * Gets the tasks added to the queue.
     * This method is used only for testing, where it is overridden.
     *
     * @throws UnsupportedOperationException if used in production, where it is not meant to be
     */
    public List<TaskWrapper> getTasksAdded() {
        throw new UnsupportedOperationException(""Method is used only for testing"");
    }

    /**
     * Gets the number of tasks added for each queue name.
     * This method is used only for testing, where it is overridden.
     *
     * @throws UnsupportedOperationException if used in production, where it is not meant to be
     */
    public Map<String, Integer> getNumberOfTasksAdded() {
        throw new UnsupportedOperationException(""Method is used only for testing"");
    }

    // The following methods are the actual API methods to be used by the client classes

    /**
     * Schedules an admin email preparation in address mode, i.e. using the address list given directly.
     *
     * @param emailId the ID of admin email to be retrieved from the database
     * @param addressReceiverListString the list of email receivers given as String
     */
    public void scheduleAdminEmailPreparationInAddressMode(String emailId, String addressReceiverListString) {
        Map<String, String> paramMap = new HashMap<>();
        paramMap.put(ParamsNames.ADMIN_EMAIL_ID, emailId);
        paramMap.put(ParamsNames.ADMIN_EMAIL_ADDRESS_RECEIVERS, addressReceiverListString);

        addTask(TaskQueue.ADMIN_PREPARE_EMAIL_ADDRESS_MODE_QUEUE_NAME,
                TaskQueue.ADMIN_PREPARE_EMAIL_ADDRESS_MODE_WORKER_URL, paramMap);
    }

    /**
     * Schedules an admin email preparation in group mode, i.e. using the group receiver list
     * retrieved from the Google Cloud Storage (GCS).
     * <p>
     * This group receiver list is in the form of {@code List<List<String>>} accessed by two indices,
     * namely ""email list index"" for accessing the {@code List<String>} inside the {@code List<List<String>>}
     * and ""email index"" for accessing the email {@code String} inside the {@code List<String>}.
     * </p>
     *
     * @param emailId the ID of admin email to be retrieved from the database
     * @param groupReceiverListFileKey the file key for the group receiver list in GCS
     * @param emailListIndex see method description
     * @param emailIndex see method description
     */
    public void scheduleAdminEmailPreparationInGroupMode(String emailId, String groupReceiverListFileKey,
                                                         int emailListIndex, int emailIndex) {
        Map<String, String> paramMap = new HashMap<>();
        paramMap.put(ParamsNames.ADMIN_EMAIL_ID, emailId);
        paramMap.put(ParamsNames.ADMIN_EMAIL_GROUP_RECEIVER_LIST_FILE_KEY, groupReceiverListFileKey);
        paramMap.put(ParamsNames.ADMIN_GROUP_RECEIVER_EMAIL_LIST_INDEX, Integer.toString(emailListIndex));
        paramMap.put(ParamsNames.ADMIN_GROUP_RECEIVER_EMAIL_INDEX, Integer.toString(emailIndex));

        addTask(TaskQueue.ADMIN_PREPARE_EMAIL_GROUP_MODE_QUEUE_NAME,
                TaskQueue.ADMIN_PREPARE_EMAIL_GROUP_MODE_WORKER_URL, paramMap);
    }

    /**
     * Schedules an admin email to be sent.
     *
     * @param emailId the ID of admin email to be retrieved from the database (if needed)
     * @param emailReceiver the email address of the email receiver
     * @param emailSubject the subject of the email
     * @param emailContent the content of the email
     */
    public void scheduleAdminEmailForSending(String emailId, String emailReceiver, String emailSubject,
                                             String emailContent) {
        Map<String, String> paramMap = new HashMap<>();
        paramMap.put(ParamsNames.ADMIN_EMAIL_RECEIVER, emailReceiver);
        paramMap.put(ParamsNames.ADMIN_EMAIL_SUBJECT, emailSubject);
        paramMap.put(ParamsNames.ADMIN_EMAIL_CONTENT, emailContent);

        try {
            addTask(TaskQueue.ADMIN_SEND_EMAIL_QUEUE_NAME, TaskQueue.ADMIN_SEND_EMAIL_WORKER_URL, paramMap);
        } catch (IllegalArgumentException e) {
            if (e.getMessage().toLowerCase().contains(""task size too large"")) {
                log.info(""Email task size exceeds max limit. Switching to large email task mode."");
                paramMap.remove(ParamsNames.ADMIN_EMAIL_SUBJECT);
                paramMap.remove(ParamsNames.ADMIN_EMAIL_CONTENT);
                paramMap.put(ParamsNames.ADMIN_EMAIL_ID, emailId);
                addTask(TaskQueue.ADMIN_SEND_EMAIL_QUEUE_NAME, TaskQueue.ADMIN_SEND_EMAIL_WORKER_URL, paramMap);
            }
        }
    }

    /**
     * Schedules for feedback session reminders (i.e. student has not submitted responses yet)
     * for the specified feedback session.
     *
     * @param courseId the course ID of the feedback session
     * @param feedbackSessionName the name of the feedback session
     */
    public void scheduleFeedbackSessionReminders(String courseId, String feedbackSessionName) {
        Map<String, String> paramMap = new HashMap<>();
        paramMap.put(ParamsNames.SUBMISSION_FEEDBACK, feedbackSessionName);
        paramMap.put(ParamsNames.SUBMISSION_COURSE, courseId);

        addTask(TaskQueue.FEEDBACK_SESSION_REMIND_EMAIL_QUEUE_NAME,
                TaskQueue.FEEDBACK_SESSION_REMIND_EMAIL_WORKER_URL, paramMap);
    }

    /**
     * Schedules for feedback session reminders (i.e. student has not submitted responses yet)
     * for the specified feedback session for the specified group of users.
     *
     * @param courseId the course ID of the feedback session
     * @param feedbackSessionName the name of the feedback session
     * @param usersToRemind the group of users to send the reminders to
     */
    public void scheduleFeedbackSessionRemindersForParticularUsers(String courseId, String feedbackSessionName,
                                                                   String[] usersToRemind) {
        Map<String, String[]> paramMap = new HashMap<>();
        paramMap.put(ParamsNames.SUBMISSION_FEEDBACK, new String[] { feedbackSessionName });
        paramMap.put(ParamsNames.SUBMISSION_COURSE, new String[] { courseId });
        paramMap.put(ParamsNames.SUBMISSION_REMIND_USERLIST, usersToRemind);

        addTaskMultisetParam(TaskQueue.FEEDBACK_SESSION_REMIND_PARTICULAR_USERS_EMAIL_QUEUE_NAME,
                             TaskQueue.FEEDBACK_SESSION_REMIND_PARTICULAR_USERS_EMAIL_WORKER_URL, paramMap);
    }

    /**
     * Schedules for feedback session published email to be sent.
     *
     * @param courseId the course ID of the feedback session
     * @param feedbackSessionName the name of the feedback session
     */
    public void scheduleFeedbackSessionPublishedEmail(String courseId, String feedbackSessionName) {
        Map<String, String> paramMap = new HashMap<>();
        paramMap.put(ParamsNames.EMAIL_COURSE, courseId);
        paramMap.put(ParamsNames.EMAIL_FEEDBACK, feedbackSessionName);

        addTask(TaskQueue.FEEDBACK_SESSION_PUBLISHED_EMAIL_QUEUE_NAME,
                TaskQueue.FEEDBACK_SESSION_PUBLISHED_EMAIL_WORKER_URL, paramMap);
    }

    /**
     * Schedules for feedback session unpublished email to be sent.
     *
     * @param courseId the course ID of the feedback session
     * @param feedbackSessionName the name of the feedback session
     */
    public void scheduleFeedbackSessionUnpublishedEmail(String courseId, String feedbackSessionName) {
        Map<String, String> paramMap = new HashMap<>();
        paramMap.put(ParamsNames.EMAIL_COURSE, courseId);
        paramMap.put(ParamsNames.EMAIL_FEEDBACK, feedbackSessionName);

        addTask(TaskQueue.FEEDBACK_SESSION_UNPUBLISHED_EMAIL_QUEUE_NAME,
                TaskQueue.FEEDBACK_SESSION_UNPUBLISHED_EMAIL_WORKER_URL, paramMap);
    }

    /**
     * Schedules for course registration to be sent to the specified instructor.
     *
     * @param inviterGoogleId googleId of instructor or administrator who sends the invitation
     * @param courseId the target course ID
     * @param instructorEmail the email address of the invited instructor
     */
    public void scheduleCourseRegistrationInviteToInstructor(String inviterGoogleId,
            String instructorEmail, String courseId) {

        Map<String, String> paramMap = new HashMap<>();

        paramMap.put(ParamsNames.INVITER_ID, inviterGoogleId);
        paramMap.put(ParamsNames.INSTRUCTOR_EMAIL, instructorEmail);
        paramMap.put(ParamsNames.COURSE_ID, courseId);

        addTask(TaskQueue.INSTRUCTOR_COURSE_JOIN_EMAIL_QUEUE_NAME,
                TaskQueue.INSTRUCTOR_COURSE_JOIN_EMAIL_WORKER_URL, paramMap);
    }

    /**
     * Schedules for course registration to be sent to the specified student.
     *
     * @param courseId the target course ID
     * @param studentEmail the email address of the student
     */
    public void scheduleCourseRegistrationInviteToStudent(String courseId, String studentEmail, boolean isRejoining) {
        Map<String, String> paramMap = new HashMap<>();
        paramMap.put(ParamsNames.COURSE_ID, courseId);
        paramMap.put(ParamsNames.STUDENT_EMAIL, studentEmail);
        paramMap.put(ParamsNames.IS_STUDENT_REJOINING, String.valueOf(isRejoining));

        addTask(TaskQueue.STUDENT_COURSE_JOIN_EMAIL_QUEUE_NAME,
                TaskQueue.STUDENT_COURSE_JOIN_EMAIL_WORKER_URL, paramMap);
    }

    /**
     * Schedules adjustments to be done to responses of a feedback session in the database
     * after change is done to a course, typically after enrollment of new students
     * or re-enrollment of old students, or both.
     *
     * @param courseId the course ID of the feedback session
     * @param feedbackSessionName the name of the feedback session
     * @param enrollmentList the list of enrollment details
     */
    public void scheduleFeedbackResponseAdjustmentForCourse(String courseId, String feedbackSessionName,
                                                            List<StudentEnrollDetails> enrollmentList) {
        Map<String, String> paramMap = new HashMap<>();
        paramMap.put(ParamsNames.COURSE_ID, courseId);
        paramMap.put(ParamsNames.FEEDBACK_SESSION_NAME, feedbackSessionName);

        String enrollmentDetails = JsonUtils.toJson(enrollmentList);
        paramMap.put(ParamsNames.ENROLLMENT_DETAILS, enrollmentDetails);

        addTask(TaskQueue.FEEDBACK_RESPONSE_ADJUSTMENT_QUEUE_NAME,
                TaskQueue.FEEDBACK_RESPONSE_ADJUSTMENT_WORKER_URL, paramMap);
    }

    /**
     * Schedules for the given list of emails to be sent.
     *
     * @param emails the list of emails to be sent
     */
    public void scheduleEmailsForSending(List<EmailWrapper> emails) {
        if (emails.isEmpty()) {
            return;
        }

        // Equally spread out the emails to be sent over 1 hour
        // Sets interval to a maximum of 5 seconds if the interval is too large
        int oneHourInMillis = 60 * 60 * 1000;
        int emailIntervalMillis = Math.min(5000, oneHourInMillis / emails.size());

        int numberOfEmailsSent = 0;
        for (EmailWrapper email : emails) {
            long emailDelayTimer = numberOfEmailsSent * emailIntervalMillis;
            scheduleEmailForSending(email, emailDelayTimer);
            numberOfEmailsSent++;
        }
    }

    private void scheduleEmailForSending(EmailWrapper email, long emailDelayTimer) {
        String emailSubject = email.getSubject();
        String emailSenderName = email.getSenderName();
        String emailSender = email.getSenderEmail();
        String emailReceiver = email.getRecipient();
        String emailReplyToAddress = email.getReplyTo();
        try {
            Map<String, String> paramMap = new HashMap<>();
            paramMap.put(ParamsNames.EMAIL_SUBJECT, emailSubject);
            paramMap.put(ParamsNames.EMAIL_CONTENT, email.getContent());
            paramMap.put(ParamsNames.EMAIL_SENDER, emailSender);
            if (emailSenderName != null && !emailSenderName.isEmpty()) {
                paramMap.put(ParamsNames.EMAIL_SENDERNAME, emailSenderName);
            }
            paramMap.put(ParamsNames.EMAIL_RECEIVER, emailReceiver);
            paramMap.put(ParamsNames.EMAIL_REPLY_TO_ADDRESS, emailReplyToAddress);

            addDeferredTask(TaskQueue.SEND_EMAIL_QUEUE_NAME, TaskQueue.SEND_EMAIL_WORKER_URL,
                            paramMap, emailDelayTimer);
        } catch (Exception e) {
            log.severe(""Error when adding email to task queue: "" + e.getMessage() + ""\n""
                       + ""Email sender: "" + emailSender + ""\n""
                       + ""Email sender name: "" + emailSenderName + ""\n""
                       + ""Email receiver: "" + emailReceiver + ""\n""
                       + ""Email subject: "" + emailSubject + ""\n""
                       + ""Email reply-to address: "" + emailReplyToAddress);
        }
    }

}
"
BackDoorLogic.java,logic-backdoor,"package teammates.logic.backdoor;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import com.google.appengine.api.blobstore.BlobKey;
import com.google.common.collect.HashMultimap;
import com.google.common.collect.SetMultimap;

import teammates.common.datatransfer.DataBundle;
import teammates.common.datatransfer.FeedbackSessionType;
import teammates.common.datatransfer.InstructorPrivileges;
import teammates.common.datatransfer.attributes.AccountAttributes;
import teammates.common.datatransfer.attributes.AdminEmailAttributes;
import teammates.common.datatransfer.attributes.CourseAttributes;
import teammates.common.datatransfer.attributes.FeedbackQuestionAttributes;
import teammates.common.datatransfer.attributes.FeedbackResponseAttributes;
import teammates.common.datatransfer.attributes.FeedbackResponseCommentAttributes;
import teammates.common.datatransfer.attributes.FeedbackSessionAttributes;
import teammates.common.datatransfer.attributes.InstructorAttributes;
import teammates.common.datatransfer.attributes.StudentAttributes;
import teammates.common.datatransfer.attributes.StudentProfileAttributes;
import teammates.common.exception.EntityDoesNotExistException;
import teammates.common.exception.InvalidParametersException;
import teammates.common.util.Assumption;
import teammates.common.util.Const;
import teammates.common.util.GoogleCloudStorageHelper;
import teammates.common.util.JsonUtils;
import teammates.common.util.StringHelper;
import teammates.logic.api.Logic;
import teammates.storage.api.AccountsDb;
import teammates.storage.api.AdminEmailsDb;
import teammates.storage.api.CoursesDb;
import teammates.storage.api.EntitiesDb;
import teammates.storage.api.FeedbackQuestionsDb;
import teammates.storage.api.FeedbackResponseCommentsDb;
import teammates.storage.api.FeedbackResponsesDb;
import teammates.storage.api.FeedbackSessionsDb;
import teammates.storage.api.InstructorsDb;
import teammates.storage.api.StudentsDb;

/**
 * Provides additional business logic for non-production usage (e.g. testing, client scripts).
 */
public class BackDoorLogic extends Logic {
    private static final AccountsDb accountsDb = new AccountsDb();
    private static final CoursesDb coursesDb = new CoursesDb();
    private static final StudentsDb studentsDb = new StudentsDb();
    private static final InstructorsDb instructorsDb = new InstructorsDb();
    private static final FeedbackSessionsDb fbDb = new FeedbackSessionsDb();
    private static final FeedbackQuestionsDb fqDb = new FeedbackQuestionsDb();
    private static final FeedbackResponsesDb frDb = new FeedbackResponsesDb();
    private static final FeedbackResponseCommentsDb fcDb = new FeedbackResponseCommentsDb();
    private static final AdminEmailsDb adminEmailsDb = new AdminEmailsDb();

    /**
     * Persists data in the given {@link DataBundle} to the Datastore, including
     * accounts, courses, instructors, students, sessions, questions, responses, comments and admin emails.
     *
     * <p>Accounts are generated for students and instructors with Google IDs
     * if the corresponding accounts are not found in the data bundle.
     * For question ID injection in responses and comments to work properly, all questions
     * referenced by responses and comments must be included in the data bundle.
     * For session respondent lists to be properly populated, all instructors, questions and responses
     * relevant to each session must be included in the data bundle.</p>
     *
     * @return {@link Const.StatusCodes#BACKDOOR_STATUS_SUCCESS} if successful.
     * @throws InvalidParametersException if invalid data is encountered.
     */
    public String persistDataBundle(DataBundle dataBundle) throws InvalidParametersException {
        if (dataBundle == null) {
            throw new InvalidParametersException(Const.StatusCodes.NULL_PARAMETER, ""Null data bundle"");
        }

        Collection<AccountAttributes> accounts = dataBundle.accounts.values();
        Collection<CourseAttributes> courses = dataBundle.courses.values();
        Collection<InstructorAttributes> instructors = dataBundle.instructors.values();
        Collection<StudentAttributes> students = dataBundle.students.values();
        Collection<FeedbackSessionAttributes> sessions = dataBundle.feedbackSessions.values();
        Collection<FeedbackQuestionAttributes> questions = dataBundle.feedbackQuestions.values();
        Collection<FeedbackResponseAttributes> responses = dataBundle.feedbackResponses.values();
        Collection<FeedbackResponseCommentAttributes> responseComments = dataBundle.feedbackResponseComments.values();
        Collection<AdminEmailAttributes> adminEmails = dataBundle.adminEmails.values();

        // For ensuring only one account per Google ID is created
        Map<String, AccountAttributes> googleIdAccountMap = new HashMap<>();

        // For updating the student and instructor respondent lists in sessions before they are persisted
        SetMultimap<String, InstructorAttributes> courseInstructorsMap = HashMultimap.create();
        SetMultimap<String, FeedbackQuestionAttributes> sessionQuestionsMap = HashMultimap.create();
        SetMultimap<String, FeedbackResponseAttributes> sessionResponsesMap = HashMultimap.create();

        processAccountsAndPopulateAccountsMap(accounts, googleIdAccountMap);
        processInstructorsAndPopulateMapAndAccounts(instructors, courseInstructorsMap, googleIdAccountMap);
        processStudentsAndPopulateAccounts(students, googleIdAccountMap);
        processQuestionsAndPopulateMap(questions, sessionQuestionsMap);
        processResponsesAndPopulateMap(responses, sessionResponsesMap);
        processSessionsAndUpdateRespondents(sessions, courseInstructorsMap, sessionQuestionsMap, sessionResponsesMap);

        accountsDb.createEntitiesDeferred(googleIdAccountMap.values());
        coursesDb.createEntitiesDeferred(courses);
        instructorsDb.createEntitiesDeferred(instructors);
        studentsDb.createEntitiesDeferred(students);
        fbDb.createEntitiesDeferred(sessions);

        // This also flushes all previously deferred operations
        List<FeedbackQuestionAttributes> createdQuestions = fqDb.createFeedbackQuestionsWithoutExistenceCheck(questions);

        injectRealIds(responses, responseComments, createdQuestions);

        frDb.createEntitiesDeferred(responses);
        fcDb.createEntitiesDeferred(responseComments);

        adminEmailsDb.createEntitiesDeferred(adminEmails);

        EntitiesDb.flush();

        return Const.StatusCodes.BACKDOOR_STATUS_SUCCESS;
    }

    public String createFeedbackResponseAndUpdateSessionRespondents(FeedbackResponseAttributes response)
            throws InvalidParametersException, EntityDoesNotExistException {
        try {
            int questionNumber = Integer.parseInt(response.feedbackQuestionId);
            response.feedbackQuestionId = feedbackQuestionsLogic
                    .getFeedbackQuestion(response.feedbackSessionName, response.courseId, questionNumber)
                    .getId(); // inject real question ID
        } catch (NumberFormatException e) {
            // question ID already injected
        }
        frDb.createEntityWithoutExistenceCheck(response);
        updateRespondents(response.feedbackSessionName, response.courseId);
        return Const.StatusCodes.BACKDOOR_STATUS_SUCCESS;
    }

    /**
     * Creates document for entities that have document, i.e. searchable.
     * @return status of the request in the form 'status meassage'+'additional
     *         info (if any)' e.g., ""[BACKEND_STATUS_SUCCESS]"" e.g.,
     *         ""[BACKEND_STATUS_FAILURE]NullPointerException at ...""
     */
    public String putDocuments(DataBundle dataBundle) {
        // query the entity in db first to get the actual data and create document for actual entity

        Map<String, StudentAttributes> students = dataBundle.students;
        for (StudentAttributes student : students.values()) {
            StudentAttributes studentInDb = studentsDb.getStudentForEmail(student.course, student.email);
            studentsDb.putDocument(studentInDb);
        }

        Map<String, InstructorAttributes> instructors = dataBundle.instructors;
        for (InstructorAttributes instructor : instructors.values()) {
            InstructorAttributes instructorInDb =
                    instructorsDb.getInstructorForEmail(instructor.courseId, instructor.email);
            instructorsDb.putDocument(instructorInDb);
        }

        Map<String, FeedbackResponseCommentAttributes> responseComments = dataBundle.feedbackResponseComments;
        for (FeedbackResponseCommentAttributes responseComment : responseComments.values()) {
            FeedbackResponseCommentAttributes fcInDb = fcDb.getFeedbackResponseComment(
                    responseComment.courseId, responseComment.createdAt, responseComment.giverEmail);
            fcDb.putDocument(fcInDb);
        }

        return Const.StatusCodes.BACKDOOR_STATUS_SUCCESS;
    }

    public String getAccountAsJson(String googleId) {
        AccountAttributes accountData = getAccount(googleId, true);
        return JsonUtils.toJson(accountData);
    }

    public String getStudentProfileAsJson(String googleId) {
        StudentProfileAttributes profileData = getStudentProfile(googleId);
        return JsonUtils.toJson(profileData);
    }

    public String getInstructorAsJsonById(String instructorId, String courseId) {
        InstructorAttributes instructorData = getInstructorForGoogleId(courseId, instructorId);
        return JsonUtils.toJson(instructorData);
    }

    public String getInstructorAsJsonByEmail(String instructorEmail, String courseId) {
        InstructorAttributes instructorData = getInstructorForEmail(courseId, instructorEmail);
        return JsonUtils.toJson(instructorData);
    }

    public String getCourseAsJson(String courseId) {
        CourseAttributes course = getCourse(courseId);
        return JsonUtils.toJson(course);
    }

    public String getStudentAsJson(String courseId, String email) {
        StudentAttributes student = getStudentForEmail(courseId, email);
        return JsonUtils.toJson(student);
    }

    public String getAllStudentsAsJson(String courseId) {
        List<StudentAttributes> studentList = studentsLogic.getStudentsForCourse(courseId);
        return JsonUtils.toJson(studentList);
    }

    public String getFeedbackSessionAsJson(String feedbackSessionName, String courseId) {
        FeedbackSessionAttributes fs = getFeedbackSession(feedbackSessionName, courseId);
        return JsonUtils.toJson(fs);
    }

    public String getFeedbackQuestionAsJson(String feedbackSessionName, String courseId, int qnNumber) {
        FeedbackQuestionAttributes fq =
                feedbackQuestionsLogic.getFeedbackQuestion(feedbackSessionName, courseId, qnNumber);
        return JsonUtils.toJson(fq);
    }

    public String getFeedbackQuestionForIdAsJson(String questionId) {
        FeedbackQuestionAttributes fq = feedbackQuestionsLogic.getFeedbackQuestion(questionId);
        return JsonUtils.toJson(fq);
    }

    public String getFeedbackResponseAsJson(String feedbackQuestionId, String giverEmail, String recipient) {
        FeedbackResponseAttributes fq =
                feedbackResponsesLogic.getFeedbackResponse(feedbackQuestionId, giverEmail, recipient);
        return JsonUtils.toJson(fq);
    }

    public String getFeedbackResponsesForGiverAsJson(String courseId, String giverEmail) {
        List<FeedbackResponseAttributes> responseList =
                feedbackResponsesLogic.getFeedbackResponsesFromGiverForCourse(courseId, giverEmail);
        return JsonUtils.toJson(responseList);
    }

    public String getFeedbackResponsesForReceiverAsJson(String courseId, String recipient) {
        List<FeedbackResponseAttributes> responseList =
                feedbackResponsesLogic.getFeedbackResponsesForReceiverForCourse(courseId, recipient);
        return JsonUtils.toJson(responseList);
    }

    public void editAccountAsJson(String newValues)
            throws InvalidParametersException, EntityDoesNotExistException {
        AccountAttributes account = JsonUtils.fromJson(newValues, AccountAttributes.class);
        updateAccount(account);
    }

    public void editStudentAsJson(String originalEmail, String newValues)
            throws InvalidParametersException, EntityDoesNotExistException {
        StudentAttributes student = JsonUtils.fromJson(newValues, StudentAttributes.class);
        populateNullSection(student);
        updateStudentWithoutDocument(originalEmail, student);
    }

    public void editFeedbackSessionAsJson(String feedbackSessionJson)
            throws InvalidParametersException, EntityDoesNotExistException {
        FeedbackSessionAttributes feedbackSession =
                JsonUtils.fromJson(feedbackSessionJson, FeedbackSessionAttributes.class);
        updateFeedbackSession(feedbackSession);
    }

    public void editFeedbackQuestionAsJson(String feedbackQuestionJson)
            throws InvalidParametersException, EntityDoesNotExistException {
        FeedbackQuestionAttributes feedbackQuestion =
                JsonUtils.fromJson(feedbackQuestionJson, FeedbackQuestionAttributes.class);
        updateFeedbackQuestion(feedbackQuestion);
    }

    private void processAccountsAndPopulateAccountsMap(Collection<AccountAttributes> accounts,
            Map<String, AccountAttributes> googleIdAccountMap) {
        populateNullStudentProfiles(accounts);
        for (AccountAttributes account : accounts) {
            googleIdAccountMap.put(account.googleId, account);
        }
    }

    private void processInstructorsAndPopulateMapAndAccounts(Collection<InstructorAttributes> instructors,
            SetMultimap<String, InstructorAttributes> courseInstructorsMap,
            Map<String, AccountAttributes> googleIdAccountMap) {
        for (InstructorAttributes instructor : instructors) {
            validateInstructorPrivileges(instructor);

            courseInstructorsMap.put(instructor.courseId, instructor);

            if (StringHelper.isEmpty(instructor.googleId) || googleIdAccountMap.containsKey(instructor.googleId)) {
                // No account, or account already exists in the data bundle
                continue;
            }
            googleIdAccountMap.put(instructor.googleId, makeAccount(instructor));
        }
    }

    private void processStudentsAndPopulateAccounts(Collection<StudentAttributes> students,
            Map<String, AccountAttributes> googleIdAccountMap) {
        for (StudentAttributes student : students) {
            populateNullSection(student);

            if (StringHelper.isEmpty(student.googleId) || googleIdAccountMap.containsKey(student.googleId)) {
                // No account, account already exists in the data bundle,
                // or instructor account already exists (i.e. instructor is also a student)
                continue;
            }
            googleIdAccountMap.put(student.googleId, makeAccount(student));
        }
    }

    private void processQuestionsAndPopulateMap(Collection<FeedbackQuestionAttributes> questions,
            SetMultimap<String, FeedbackQuestionAttributes> sessionQuestionsMap) {
        for (FeedbackQuestionAttributes question : questions) {
            question.removeIrrelevantVisibilityOptions();

            String sessionKey = makeSessionKey(question.feedbackSessionName, question.courseId);
            sessionQuestionsMap.put(sessionKey, question);
        }
    }

    private void processResponsesAndPopulateMap(Collection<FeedbackResponseAttributes> responses,
            SetMultimap<String, FeedbackResponseAttributes> sessionResponsesMap) {
        for (FeedbackResponseAttributes response : responses) {
            String sessionKey = makeSessionKey(response.feedbackSessionName, response.courseId);
            sessionResponsesMap.put(sessionKey, response);
        }
    }

    private void processSessionsAndUpdateRespondents(Collection<FeedbackSessionAttributes> sessions,
            SetMultimap<String, InstructorAttributes> courseInstructorsMap,
            SetMultimap<String, FeedbackQuestionAttributes> sessionQuestionsMap,
            SetMultimap<String, FeedbackResponseAttributes> sessionResponsesMap) {
        for (FeedbackSessionAttributes session : sessions) {
            cleanSessionData(session);
            String sessionKey = makeSessionKey(session.getFeedbackSessionName(), session.getCourseId());

            Set<InstructorAttributes> courseInstructors = courseInstructorsMap.get(session.getCourseId());
            Set<FeedbackQuestionAttributes> sessionQuestions = sessionQuestionsMap.get(sessionKey);
            Set<FeedbackResponseAttributes> sessionResponses = sessionResponsesMap.get(sessionKey);

            updateRespondents(session, courseInstructors, sessionQuestions, sessionResponses);
        }
    }

    private void updateRespondents(FeedbackSessionAttributes session,
            Set<InstructorAttributes> courseInstructors,
            Set<FeedbackQuestionAttributes> sessionQuestions,
            Set<FeedbackResponseAttributes> sessionResponses) {
        String sessionKey = makeSessionKey(session.getFeedbackSessionName(), session.getCourseId());

        SetMultimap<String, String> instructorQuestionKeysMap = HashMultimap.create();
        for (InstructorAttributes instructor : courseInstructors) {
            List<FeedbackQuestionAttributes> questionsForInstructor =
                    feedbackQuestionsLogic.getFeedbackQuestionsForInstructor(
                            new ArrayList<>(sessionQuestions), session.isCreator(instructor.email));

            List<String> questionKeys = makeQuestionKeys(questionsForInstructor, sessionKey);
            instructorQuestionKeysMap.putAll(instructor.email, questionKeys);
        }

        Set<String> respondingInstructors = new HashSet<>();
        Set<String> respondingStudents = new HashSet<>();

        for (FeedbackResponseAttributes response : sessionResponses) {
            String respondent = response.giver;
            String responseQuestionNumber = response.feedbackQuestionId; // contains question number before injection
            String responseQuestionKey = makeQuestionKey(sessionKey, responseQuestionNumber);

            Set<String> instructorQuestionKeys = instructorQuestionKeysMap.get(respondent);
            if (instructorQuestionKeys.contains(responseQuestionKey)) {
                respondingInstructors.add(respondent);
            } else {
                respondingStudents.add(respondent);
            }
        }

        session.setRespondingInstructorList(respondingInstructors);
        session.setRespondingStudentList(respondingStudents);
    }

    private void injectRealIds(
            Collection<FeedbackResponseAttributes> responses, Collection<FeedbackResponseCommentAttributes> responseComments,
            List<FeedbackQuestionAttributes> createdQuestions) {
        Map<String, String> questionIdMap = makeQuestionIdMap(createdQuestions);

        injectRealIdsIntoResponses(responses, questionIdMap);
        injectRealIdsIntoResponseComments(responseComments, questionIdMap);
    }

    private Map<String, String> makeQuestionIdMap(List<FeedbackQuestionAttributes> createdQuestions) {
        Map<String, String> questionIdMap = new HashMap<>();
        for (FeedbackQuestionAttributes createdQuestion : createdQuestions) {
            String sessionKey = makeSessionKey(createdQuestion.feedbackSessionName, createdQuestion.courseId);
            String questionKey = makeQuestionKey(sessionKey, createdQuestion.questionNumber);
            questionIdMap.put(questionKey, createdQuestion.getId());
        }
        return questionIdMap;
    }

    /**
    * This method is necessary to generate the feedbackQuestionId of the
    * question the response is for.<br>
    * Normally, the ID is already generated on creation,
    * but the json file does not contain the actual response ID. <br>
    * Therefore the question number corresponding to the created response
    * should be inserted in the json file in place of the actual response ID.<br>
    * This method will then generate the correct ID and replace the field.
    **/
    private void injectRealIdsIntoResponses(Collection<FeedbackResponseAttributes> responses,
            Map<String, String> questionIdMap) {
        for (FeedbackResponseAttributes response : responses) {
            int questionNumber;
            try {
                questionNumber = Integer.parseInt(response.feedbackQuestionId);
            } catch (NumberFormatException e) {
                // question ID already injected
                continue;
            }
            String sessionKey = makeSessionKey(response.feedbackSessionName, response.courseId);
            String questionKey = makeQuestionKey(sessionKey, questionNumber);
            response.feedbackQuestionId = questionIdMap.get(questionKey);
        }
    }

    /**
    * This method is necessary to generate the feedbackQuestionId
    * and feedbackResponseId of the question and response the comment is for.<br>
    * Normally, the ID is already generated on creation,
    * but the json file does not contain the actual response ID. <br>
    * Therefore the question number and questionNumber%giverEmail%recipient
    * corresponding to the created comment should be inserted in the json
    * file in place of the actual ID.<br>
    * This method will then generate the correct ID and replace the field.
    **/
    private void injectRealIdsIntoResponseComments(Collection<FeedbackResponseCommentAttributes> responseComments,
            Map<String, String> questionIdMap) {
        for (FeedbackResponseCommentAttributes comment : responseComments) {
            int questionNumber;
            try {
                questionNumber = Integer.parseInt(comment.feedbackQuestionId);
            } catch (NumberFormatException e) {
                // question ID already injected
                continue;
            }
            String sessionKey = makeSessionKey(comment.feedbackSessionName, comment.courseId);
            String questionKey = makeQuestionKey(sessionKey, questionNumber);
            comment.feedbackQuestionId = questionIdMap.get(questionKey);

            String[] responseIdParam = comment.feedbackResponseId.split(""%"");
            comment.feedbackResponseId = comment.feedbackQuestionId + ""%"" + responseIdParam[1] + ""%"" + responseIdParam[2];
        }
    }

    /**
     * Checks if the role of {@code instructor} matches its privileges.
     *
     * @param instructor
     *            the {@link InstructorAttributes} of an instructor, cannot be
     *            {@code null}
     */
    private void validateInstructorPrivileges(InstructorAttributes instructor) {

        if (instructor.getRole() == null) {
            return;
        }

        InstructorPrivileges privileges = instructor.privileges;

        switch (instructor.getRole()) {

        case Const.InstructorPermissionRoleNames.INSTRUCTOR_PERMISSION_ROLE_COOWNER:
            Assumption.assertTrue(privileges.hasCoownerPrivileges());
            break;

        case Const.InstructorPermissionRoleNames.INSTRUCTOR_PERMISSION_ROLE_MANAGER:
            Assumption.assertTrue(privileges.hasManagerPrivileges());
            break;

        case Const.InstructorPermissionRoleNames.INSTRUCTOR_PERMISSION_ROLE_OBSERVER:
            Assumption.assertTrue(privileges.hasObserverPrivileges());
            break;

        case Const.InstructorPermissionRoleNames.INSTRUCTOR_PERMISSION_ROLE_TUTOR:
            Assumption.assertTrue(privileges.hasTutorPrivileges());
            break;

        case Const.InstructorPermissionRoleNames.INSTRUCTOR_PERMISSION_ROLE_CUSTOM:
            break;

        default:
            Assumption.fail(""Invalid instructor permission role name"");
            break;
        }
    }

    /**
     * This method ensures consistency for private feedback sessions
     * between the type and visibility times. This allows easier creation
     * of private sessions by setting the feedbackSessionType field as PRIVATE
     * in the json file.
     */
    private void cleanSessionData(FeedbackSessionAttributes session) {
        if (session.getFeedbackSessionType().equals(FeedbackSessionType.PRIVATE)) {
            session.setSessionVisibleFromTime(Const.TIME_REPRESENTS_NEVER);
            session.setResultsVisibleFromTime(Const.TIME_REPRESENTS_NEVER);
        }
    }

    private void populateNullStudentProfiles(Collection<AccountAttributes> accounts) {
        for (AccountAttributes account : accounts) {
            if (account.studentProfile == null) {
                account.studentProfile = StudentProfileAttributes.builder().withGoogleId(account.googleId).build();
            }
        }
    }

    private void populateNullSection(StudentAttributes student) {
        student.section = student.section == null ? ""None"" : student.section;
    }

    private AccountAttributes makeAccount(InstructorAttributes instructor) {
        return new AccountAttributes(
                instructor.googleId, instructor.name, true, instructor.email, ""TEAMMATES Test Institute 1"");
    }

    private AccountAttributes makeAccount(StudentAttributes student) {
        return new AccountAttributes(
                student.googleId, student.name, false, student.email, ""TEAMMATES Test Institute 1"");
    }

    private String makeSessionKey(String feedbackSessionName, String courseId) {
        return feedbackSessionName + ""%"" + courseId;
    }

    private List<String> makeQuestionKeys(List<FeedbackQuestionAttributes> questions, String sessionKey) {
        List<String> questionKeys = new ArrayList<>();
        for (FeedbackQuestionAttributes question : questions) {
            String questionKey = makeQuestionKey(sessionKey, question.questionNumber);
            questionKeys.add(questionKey);
        }
        return questionKeys;
    }

    private String makeQuestionKey(String sessionKey, int questionNumber) {
        return makeQuestionKey(sessionKey, String.valueOf(questionNumber));
    }

    private String makeQuestionKey(String sessionKey, String questionNumber) {
        return sessionKey + ""%"" + questionNumber;
    }

    public void removeDataBundle(DataBundle dataBundle) {

        // Questions and responses will be deleted automatically.
        // We don't attempt to delete them again, to save time.
        deleteCourses(dataBundle.courses.values());

        populateNullStudentProfiles(dataBundle.accounts.values());
        accountsDb.deleteAccounts(dataBundle.accounts.values());

        for (AdminEmailAttributes email : dataBundle.adminEmails.values()) {
            // Retrieve email by subject as fields emailId, createDate cannot be specified by dataBundle.
            AdminEmailAttributes emailInDb = adminEmailsDb.getAdminEmailBySubject(email.subject);
            // It is expected that email may not be in datastore yet, should fail silently.
            if (emailInDb == null) {
                continue;
            }
            adminEmailsDb.deleteEntity(emailInDb);
        }
    }

    private void deleteCourses(Collection<CourseAttributes> courses) {
        List<String> courseIds = new ArrayList<>();
        for (CourseAttributes course : courses) {
            courseIds.add(course.getId());
        }
        if (!courseIds.isEmpty()) {
            coursesDb.deleteEntities(courses);
            instructorsDb.deleteInstructorsForCourses(courseIds);
            studentsDb.deleteStudentsForCourses(courseIds);
            fbDb.deleteFeedbackSessionsForCourses(courseIds);
            fqDb.deleteFeedbackQuestionsForCourses(courseIds);
            frDb.deleteFeedbackResponsesForCourses(courseIds);
            fcDb.deleteFeedbackResponseCommentsForCourses(courseIds);
        }
    }

    public boolean isPicturePresentInGcs(String pictureKey) {
        return GoogleCloudStorageHelper.doesFileExistInGcs(new BlobKey(pictureKey));
    }

    public void uploadAndUpdateStudentProfilePicture(String googleId,
            byte[] pictureData) throws EntityDoesNotExistException, IOException {
        String pictureKey = GoogleCloudStorageHelper.writeImageDataToGcs(googleId, pictureData);
        updateStudentProfilePicture(googleId, pictureKey);
    }

    public boolean isGroupListFilePresentInGcs(String groupListKey) {
        return GoogleCloudStorageHelper.doesFileExistInGcs(new BlobKey(groupListKey));
    }

    public void deleteGroupListFile(String groupListFileKey) {
        GoogleCloudStorageHelper.deleteFile(new BlobKey(groupListFileKey));
    }
}
"
BackDoorOperation.java,logic-backdoor,"package teammates.logic.backdoor;

/**
 * Provides a specification of operations that can be called via BackDoor API,
 * along with the possible parameters to be included.
 *
 * @see BackDoorServlet
 */
public enum BackDoorOperation {

    /** Operation type: deleting an account from the datastore. */
    OPERATION_DELETE_ACCOUNT,

    /** Operation type: deleting a course from the datastore. */
    OPERATION_DELETE_COURSE,

    /** Operation type: deleting a feedback question from the datastore. */
    OPERATION_DELETE_FEEDBACK_QUESTION,

    /** Operation type: deleting a feedback response from the datastore. */
    OPERATION_DELETE_FEEDBACK_RESPONSE,

    /** Operation type: deleting a feedback session from the datastore. */
    OPERATION_DELETE_FEEDBACK_SESSION,

    /** Operation type: deleting an instructor from the datastore. */
    OPERATION_DELETE_INSTRUCTOR,

    /** Operation type: deleting a student from the datastore. */
    OPERATION_DELETE_STUDENT,

    /** Operation type: editing a feedback question in the datastore. */
    OPERATION_EDIT_FEEDBACK_QUESTION,

    /** Operation type: editing a feedback session in the datastore. */
    OPERATION_EDIT_FEEDBACK_SESSION,

    /** Operation type: editing a student in the datastore. */
    OPERATION_EDIT_STUDENT,

    /** Operation type: editing a student profile picture in the datastore. */
    OPERATION_EDIT_STUDENT_PROFILE_PICTURE,

    /** Operation type: getting an account data from the datastore as JSON. */
    OPERATION_GET_ACCOUNT_AS_JSON,

    /** Operation type: getting a course data from the datastore as JSON. */
    OPERATION_GET_COURSE_AS_JSON,

    /** Operation type: getting the encrypted registration key for an instructor in the datastore. */
    OPERATION_GET_ENCRYPTED_KEY_FOR_INSTRUCTOR,

    /** Operation type: getting the encrypted registration key for a student the datastore. */
    OPERATION_GET_ENCRYPTED_KEY_FOR_STUDENT,

    /** Operation type: getting a feedback question data from the datastore as JSON. */
    OPERATION_GET_FEEDBACK_QUESTION_AS_JSON,

    /** Operation type: getting a feedback question data for particular ID from the datastore as JSON. */
    OPERATION_GET_FEEDBACK_QUESTION_FOR_ID_AS_JSON,

    /** Operation type: getting a feedback response data from the datastore as JSON. */
    OPERATION_GET_FEEDBACK_RESPONSE_AS_JSON,

    /** Operation type: getting a list of feedback response data for particular giver from the datastore as JSON. */
    OPERATION_GET_FEEDBACK_RESPONSES_FOR_GIVER_AS_JSON,

    /** Operation type: getting a list of feedback response data for particular recipient from the datastore as JSON. */
    OPERATION_GET_FEEDBACK_RESPONSES_FOR_RECEIVER_AS_JSON,

    /** Operation type: getting a feedback session data from the datastore as JSON. */
    OPERATION_GET_FEEDBACK_SESSION_AS_JSON,

    /** Operation type: getting an instructor data for particular google ID from the datastore as JSON. */
    OPERATION_GET_INSTRUCTOR_AS_JSON_BY_ID,

    /** Operation type: getting an instructor data for particular email from the datastore as JSON. */
    OPERATION_GET_INSTRUCTOR_AS_JSON_BY_EMAIL,

    /** Operation type: getting a student data from the datastore as JSON. */
    OPERATION_GET_STUDENT_AS_JSON,

    /** Operation type: getting list of student data from the datastore as JSON. */
    OPERATION_GET_STUDENTS_AS_JSON,

    /** Operation type: getting a student profile data from the datastore as JSON. */
    OPERATION_GET_STUDENTPROFILE_AS_JSON,

    /** Operation type: checking if profile picture is present in GCS. */
    OPERATION_IS_PICTURE_PRESENT_IN_GCS,

    /** Operation type: creating a feedback response in the datastore. */
    OPERATION_CREATE_FEEDBACK_RESPONSE,

    /** Operation type: persisting data bundle into the datastore. */
    OPERATION_PERSIST_DATABUNDLE,

    /** Operation type: putting searchable documents into the datastore. */
    OPERATION_PUT_DOCUMENTS,

    /** Operation type: removing data bundle from the datastore and restoring it afterwards. */
    OPERATION_REMOVE_AND_RESTORE_DATABUNDLE,

    /** Operation type: removing data bundle from the datastore. */
    OPERATION_REMOVE_DATABUNDLE,

    /** Operation type: verifying uploaded group list key. */
    OPERATION_IS_GROUP_LIST_FILE_PRESENT_IN_GCS,

    /** Operation type: removing group list file. */
    OPERATION_DELETE_GROUP_LIST_FILE;

    // CHECKSTYLE.OFF:JavadocVariable self-explanatory variables
    public static final String PARAMETER_BACKDOOR_KEY = ""PARAMETER_BACKDOOR_KEY"";
    public static final String PARAMETER_BACKDOOR_OPERATION = ""PARAMETER_BACKDOOR_OPERATION"";
    public static final String PARAMETER_COURSE_ID = ""PARAMETER_COURSE_ID"";
    public static final String PARAMETER_DATABUNDLE_JSON = ""PARAMETER_DATABUNDLE_JSON"";
    public static final String PARAMETER_FEEDBACK_QUESTION_ID = ""PARAMETER_FEEDBACK_QUESTION_ID"";
    public static final String PARAMETER_FEEDBACK_QUESTION_NUMBER = ""PARAMETER_FEEDBACK_QUESTION_NUMBER"";
    public static final String PARAMETER_FEEDBACK_RESPONSE_JSON = ""PARAMETER_FEEDBACK_RESPONSE_JSON"";
    public static final String PARAMETER_FEEDBACK_SESSION_NAME = ""PARAMETER_FEEDBACK_SESSION_NAME"";
    public static final String PARAMETER_GIVER_EMAIL = ""PARAMETER_GIVER_EMAIL"";
    public static final String PARAMETER_GOOGLE_ID = ""PARAMETER_GOOGLE_ID"";
    public static final String PARAMETER_INSTRUCTOR_EMAIL = ""PARAMETER_INSTRUCTOR_EMAIL"";
    public static final String PARAMETER_JSON_STRING = ""PARAMETER_JSON_STRING"";
    public static final String PARAMETER_PICTURE_DATA = ""PARAMETER_PICTURE_DATA"";
    public static final String PARAMETER_PICTURE_KEY = ""PARAMETER_PICTURE_KEY"";
    public static final String PARAMETER_RECIPIENT = ""PARAMETER_RECIPIENT"";
    public static final String PARAMETER_STUDENT_EMAIL = ""PARAMETER_STUDENT_EMAIL"";
    public static final String PARAMETER_GROUP_LIST_FILE_KEY = ""PARAMETER_GROUP_LIST_FILE_KEY"";
    // CHECKSTYLE.ON:JavadocVariable

}
"
BackDoorServlet.java,logic-backdoor,"package teammates.logic.backdoor;

import java.io.IOException;

import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import teammates.common.datatransfer.DataBundle;
import teammates.common.datatransfer.attributes.FeedbackResponseAttributes;
import teammates.common.exception.EntityDoesNotExistException;
import teammates.common.exception.InvalidParametersException;
import teammates.common.exception.TeammatesException;
import teammates.common.util.Config;
import teammates.common.util.Const;
import teammates.common.util.JsonUtils;
import teammates.common.util.Logger;

/**
 * Servlet for the BackDoor API.
 *
 * <p>It first checks for authentication (backdoor key) and then forwards the
 * API call to the correct method as specified by the supplied parameters.
 *
 * <p>Each authorized API call will return either the return value of the called method,
 * or a status code indicating the status of the API call.
 *
 * @see BackDoorLogic
 * @see BackDoorOperation
 */
@SuppressWarnings(""serial"")
public class BackDoorServlet extends HttpServlet {

    private static final Logger log = Logger.getLogger();

    @Override
    public void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException {
        doPost(req, resp);
    }

    @Override
    public void doPost(HttpServletRequest req, HttpServletResponse resp) throws IOException {
        resp.setContentType(""text/plain; charset=utf-8"");

        String keyReceived = req.getParameter(BackDoorOperation.PARAMETER_BACKDOOR_KEY);
        boolean isAuthorized = keyReceived.equals(Config.BACKDOOR_KEY);
        if (isAuthorized) {
            String action = req.getParameter(BackDoorOperation.PARAMETER_BACKDOOR_OPERATION);
            log.info(action);

            BackDoorOperation opCode = BackDoorOperation.valueOf(action);
            String returnValue;
            try {
                returnValue = executeBackEndAction(req, opCode);
            } catch (Exception | AssertionError e) {
                log.info(e.getMessage());
                returnValue = Const.StatusCodes.BACKDOOR_STATUS_FAILURE + "" ""
                              + TeammatesException.toStringWithStackTrace(e);
            }
            resp.getWriter().write(returnValue);
        } else {
            resp.getWriter().write(""Not authorized to access Backdoor Services"");
        }
        resp.flushBuffer();
    }

    @SuppressWarnings(""PMD.SwitchStmtsShouldHaveDefault"") // no default so that each case is accounted for
    private String executeBackEndAction(HttpServletRequest req, BackDoorOperation opCode)
            throws IOException, InvalidParametersException, EntityDoesNotExistException {
        BackDoorLogic backDoorLogic = new BackDoorLogic();
        switch (opCode) {
        case OPERATION_DELETE_ACCOUNT:
            String googleId = req.getParameter(BackDoorOperation.PARAMETER_GOOGLE_ID);
            backDoorLogic.deleteAccount(googleId);
            break;
        case OPERATION_DELETE_COURSE:
            String courseId = req.getParameter(BackDoorOperation.PARAMETER_COURSE_ID);
            backDoorLogic.deleteCourse(courseId);
            break;
        case OPERATION_DELETE_FEEDBACK_QUESTION:
            String questionId = req.getParameter(BackDoorOperation.PARAMETER_FEEDBACK_QUESTION_ID);
            backDoorLogic.deleteFeedbackQuestion(questionId);
            break;
        case OPERATION_DELETE_FEEDBACK_RESPONSE:
            String feedbackQuestionId = req.getParameter(BackDoorOperation.PARAMETER_FEEDBACK_QUESTION_ID);
            String giverEmail = req.getParameter(BackDoorOperation.PARAMETER_GIVER_EMAIL);
            String recipient = req.getParameter(BackDoorOperation.PARAMETER_RECIPIENT);
            FeedbackResponseAttributes fr =
                    backDoorLogic.getFeedbackResponse(feedbackQuestionId, giverEmail, recipient);
            backDoorLogic.deleteFeedbackResponse(fr);
            break;
        case OPERATION_DELETE_FEEDBACK_SESSION:
            String feedbackSessionName = req.getParameter(BackDoorOperation.PARAMETER_FEEDBACK_SESSION_NAME);
            courseId = req.getParameter(BackDoorOperation.PARAMETER_COURSE_ID);
            backDoorLogic.deleteFeedbackSession(feedbackSessionName, courseId);
            break;
        case OPERATION_DELETE_INSTRUCTOR:
            String instructorEmail = req.getParameter(BackDoorOperation.PARAMETER_INSTRUCTOR_EMAIL);
            courseId = req.getParameter(BackDoorOperation.PARAMETER_COURSE_ID);
            backDoorLogic.deleteInstructor(courseId, instructorEmail);
            break;
        case OPERATION_DELETE_STUDENT:
            courseId = req.getParameter(BackDoorOperation.PARAMETER_COURSE_ID);
            String studentEmail = req.getParameter(BackDoorOperation.PARAMETER_STUDENT_EMAIL);
            backDoorLogic.deleteStudent(courseId, studentEmail);
            break;
        case OPERATION_EDIT_FEEDBACK_QUESTION:
            String newValues = req.getParameter(BackDoorOperation.PARAMETER_JSON_STRING);
            backDoorLogic.editFeedbackQuestionAsJson(newValues);
            break;
        case OPERATION_EDIT_FEEDBACK_SESSION:
            newValues = req.getParameter(BackDoorOperation.PARAMETER_JSON_STRING);
            backDoorLogic.editFeedbackSessionAsJson(newValues);
            break;
        case OPERATION_EDIT_STUDENT:
            studentEmail = req.getParameter(BackDoorOperation.PARAMETER_STUDENT_EMAIL);
            newValues = req.getParameter(BackDoorOperation.PARAMETER_JSON_STRING);
            backDoorLogic.editStudentAsJson(studentEmail, newValues);
            break;
        case OPERATION_EDIT_STUDENT_PROFILE_PICTURE:
            String pictureDataJsonString = req.getParameter(BackDoorOperation.PARAMETER_PICTURE_DATA);
            byte[] pictureData = JsonUtils.fromJson(pictureDataJsonString, byte[].class);
            googleId = req.getParameter(BackDoorOperation.PARAMETER_GOOGLE_ID);
            backDoorLogic.uploadAndUpdateStudentProfilePicture(googleId, pictureData);
            break;
        case OPERATION_GET_ACCOUNT_AS_JSON:
            googleId = req.getParameter(BackDoorOperation.PARAMETER_GOOGLE_ID);
            return backDoorLogic.getAccountAsJson(googleId);
        case OPERATION_GET_COURSE_AS_JSON:
            courseId = req.getParameter(BackDoorOperation.PARAMETER_COURSE_ID);
            return backDoorLogic.getCourseAsJson(courseId);
        case OPERATION_GET_ENCRYPTED_KEY_FOR_INSTRUCTOR:
            courseId = req.getParameter(BackDoorOperation.PARAMETER_COURSE_ID);
            studentEmail = req.getParameter(BackDoorOperation.PARAMETER_INSTRUCTOR_EMAIL);
            return backDoorLogic.getEncryptedKeyForInstructor(courseId, studentEmail);
        case OPERATION_GET_ENCRYPTED_KEY_FOR_STUDENT:
            courseId = req.getParameter(BackDoorOperation.PARAMETER_COURSE_ID);
            studentEmail = req.getParameter(BackDoorOperation.PARAMETER_STUDENT_EMAIL);
            return backDoorLogic.getEncryptedKeyForStudent(courseId, studentEmail);
        case OPERATION_GET_FEEDBACK_QUESTION_AS_JSON:
            feedbackSessionName = req.getParameter(BackDoorOperation.PARAMETER_FEEDBACK_SESSION_NAME);
            courseId = req.getParameter(BackDoorOperation.PARAMETER_COURSE_ID);
            int qnNumber = Integer.parseInt(req.getParameter(BackDoorOperation.PARAMETER_FEEDBACK_QUESTION_NUMBER));
            return backDoorLogic.getFeedbackQuestionAsJson(feedbackSessionName, courseId, qnNumber);
        case OPERATION_GET_FEEDBACK_QUESTION_FOR_ID_AS_JSON:
            questionId = req.getParameter(BackDoorOperation.PARAMETER_FEEDBACK_QUESTION_ID);
            return backDoorLogic.getFeedbackQuestionForIdAsJson(questionId);
        case OPERATION_GET_FEEDBACK_RESPONSE_AS_JSON:
            feedbackQuestionId = req.getParameter(BackDoorOperation.PARAMETER_FEEDBACK_QUESTION_ID);
            giverEmail = req.getParameter(BackDoorOperation.PARAMETER_GIVER_EMAIL);
            recipient = req.getParameter(BackDoorOperation.PARAMETER_RECIPIENT);
            return backDoorLogic.getFeedbackResponseAsJson(feedbackQuestionId, giverEmail, recipient);
        case OPERATION_GET_FEEDBACK_RESPONSES_FOR_GIVER_AS_JSON:
            courseId = req.getParameter(BackDoorOperation.PARAMETER_COURSE_ID);
            giverEmail = req.getParameter(BackDoorOperation.PARAMETER_GIVER_EMAIL);
            return backDoorLogic.getFeedbackResponsesForGiverAsJson(courseId, giverEmail);
        case OPERATION_GET_FEEDBACK_RESPONSES_FOR_RECEIVER_AS_JSON:
            courseId = req.getParameter(BackDoorOperation.PARAMETER_COURSE_ID);
            recipient = req.getParameter(BackDoorOperation.PARAMETER_RECIPIENT);
            return backDoorLogic.getFeedbackResponsesForReceiverAsJson(courseId, recipient);
        case OPERATION_GET_FEEDBACK_SESSION_AS_JSON:
            feedbackSessionName = req.getParameter(BackDoorOperation.PARAMETER_FEEDBACK_SESSION_NAME);
            courseId = req.getParameter(BackDoorOperation.PARAMETER_COURSE_ID);
            return backDoorLogic.getFeedbackSessionAsJson(feedbackSessionName, courseId);
        case OPERATION_GET_INSTRUCTOR_AS_JSON_BY_ID:
            googleId = req.getParameter(BackDoorOperation.PARAMETER_GOOGLE_ID);
            courseId = req.getParameter(BackDoorOperation.PARAMETER_COURSE_ID);
            return backDoorLogic.getInstructorAsJsonById(googleId, courseId);
        case OPERATION_GET_INSTRUCTOR_AS_JSON_BY_EMAIL:
            instructorEmail = req.getParameter(BackDoorOperation.PARAMETER_INSTRUCTOR_EMAIL);
            courseId = req.getParameter(BackDoorOperation.PARAMETER_COURSE_ID);
            return backDoorLogic.getInstructorAsJsonByEmail(instructorEmail, courseId);
        case OPERATION_GET_STUDENT_AS_JSON:
            courseId = req.getParameter(BackDoorOperation.PARAMETER_COURSE_ID);
            studentEmail = req.getParameter(BackDoorOperation.PARAMETER_STUDENT_EMAIL);
            return backDoorLogic.getStudentAsJson(courseId, studentEmail);
        case OPERATION_GET_STUDENTS_AS_JSON:
            courseId = req.getParameter(BackDoorOperation.PARAMETER_COURSE_ID);
            return backDoorLogic.getAllStudentsAsJson(courseId);
        case OPERATION_GET_STUDENTPROFILE_AS_JSON:
            googleId = req.getParameter(BackDoorOperation.PARAMETER_GOOGLE_ID);
            return backDoorLogic.getStudentProfileAsJson(googleId);
        case OPERATION_IS_PICTURE_PRESENT_IN_GCS:
            String pictureKey = req.getParameter(BackDoorOperation.PARAMETER_PICTURE_KEY);
            return String.valueOf(backDoorLogic.isPicturePresentInGcs(pictureKey));
        case OPERATION_CREATE_FEEDBACK_RESPONSE:
            String feedbackResponseJsonString = req.getParameter(BackDoorOperation.PARAMETER_FEEDBACK_RESPONSE_JSON);
            FeedbackResponseAttributes feedbackResponse =
                    JsonUtils.fromJson(feedbackResponseJsonString, FeedbackResponseAttributes.class);
            return backDoorLogic.createFeedbackResponseAndUpdateSessionRespondents(feedbackResponse);
        case OPERATION_PERSIST_DATABUNDLE:
            String dataBundleJsonString = req.getParameter(BackDoorOperation.PARAMETER_DATABUNDLE_JSON);
            DataBundle dataBundle = JsonUtils.fromJson(dataBundleJsonString, DataBundle.class);
            backDoorLogic.persistDataBundle(dataBundle);
            break;
        case OPERATION_PUT_DOCUMENTS:
            dataBundleJsonString = req.getParameter(BackDoorOperation.PARAMETER_DATABUNDLE_JSON);
            dataBundle = JsonUtils.fromJson(dataBundleJsonString, DataBundle.class);
            backDoorLogic.putDocuments(dataBundle);
            break;
        case OPERATION_REMOVE_AND_RESTORE_DATABUNDLE:
            dataBundleJsonString = req.getParameter(BackDoorOperation.PARAMETER_DATABUNDLE_JSON);
            dataBundle = JsonUtils.fromJson(dataBundleJsonString, DataBundle.class);
            backDoorLogic.removeDataBundle(dataBundle);
            backDoorLogic.persistDataBundle(dataBundle);
            break;
        case OPERATION_REMOVE_DATABUNDLE:
            dataBundleJsonString = req.getParameter(BackDoorOperation.PARAMETER_DATABUNDLE_JSON);
            dataBundle = JsonUtils.fromJson(dataBundleJsonString, DataBundle.class);
            backDoorLogic.removeDataBundle(dataBundle);
            break;
        case OPERATION_IS_GROUP_LIST_FILE_PRESENT_IN_GCS:
            String groupListKey = req.getParameter(BackDoorOperation.PARAMETER_GROUP_LIST_FILE_KEY);
            return String.valueOf(backDoorLogic.isGroupListFilePresentInGcs(groupListKey));
        case OPERATION_DELETE_GROUP_LIST_FILE:
            String groupListFileKey = req.getParameter(BackDoorOperation.PARAMETER_GROUP_LIST_FILE_KEY);
            backDoorLogic.deleteGroupListFile(groupListFileKey);
            break;

        }
        return Const.StatusCodes.BACKDOOR_STATUS_SUCCESS;
    }

}
"
package-info.java,logic-backdoor,"/**
 * Provides a mechanism for the test driver and client scripts to access data.
 */
package teammates.logic.backdoor;
"
AccountsLogic.java,logic-core,"package teammates.logic.core;

import java.util.List;

import teammates.common.datatransfer.attributes.AccountAttributes;
import teammates.common.datatransfer.attributes.CourseAttributes;
import teammates.common.datatransfer.attributes.InstructorAttributes;
import teammates.common.datatransfer.attributes.StudentAttributes;
import teammates.common.datatransfer.attributes.StudentProfileAttributes;
import teammates.common.exception.EntityDoesNotExistException;
import teammates.common.exception.InvalidParametersException;
import teammates.common.exception.JoinCourseException;
import teammates.common.exception.TeammatesException;
import teammates.common.util.Assumption;
import teammates.common.util.Const;
import teammates.common.util.Logger;
import teammates.common.util.StringHelper;
import teammates.storage.api.AccountsDb;

/**
 * Handles operations related to accounts.
 *
 * @see AccountAttributes
 * @see AccountsDb
 */
public final class AccountsLogic {

    private static final Logger log = Logger.getLogger();

    private static AccountsLogic instance = new AccountsLogic();

    private static final AccountsDb accountsDb = new AccountsDb();

    private static final CoursesLogic coursesLogic = CoursesLogic.inst();
    private static final InstructorsLogic instructorsLogic = InstructorsLogic.inst();
    private static final StudentsLogic studentsLogic = StudentsLogic.inst();

    private AccountsLogic() {
        // prevent initialization
    }

    public static AccountsLogic inst() {
        return instance;
    }

    public void createAccount(AccountAttributes accountData)
                    throws InvalidParametersException {

        List<String> invalidityInfo = accountData.getInvalidityInfo();
        if (!invalidityInfo.isEmpty()) {
            throw new InvalidParametersException(invalidityInfo);
        }

        log.info(""going to create account :\n"" + accountData.toString());

        accountsDb.createAccount(accountData);
    }

    public AccountAttributes getAccount(String googleId) {
        return getAccount(googleId, false);
    }

    public AccountAttributes getAccount(String googleId, boolean retrieveStudentProfile) {
        return accountsDb.getAccount(googleId, retrieveStudentProfile);
    }

    public boolean isAccountPresent(String googleId) {
        return accountsDb.getAccount(googleId) != null;
    }

    public boolean isAccountAnInstructor(String googleId) {
        AccountAttributes a = accountsDb.getAccount(googleId);
        return a != null && a.isInstructor;
    }

    public List<AccountAttributes> getInstructorAccounts() {
        return accountsDb.getInstructorAccounts();
    }

    public String getCourseInstitute(String courseId) {
        CourseAttributes cd = coursesLogic.getCourse(courseId);
        Assumption.assertNotNull(""Trying to getCourseInstitute for inexistent course with id "" + courseId, cd);
        List<InstructorAttributes> instructorList = instructorsLogic.getInstructorsForCourse(cd.getId());

        Assumption.assertTrue(""Course has no instructors: "" + cd.getId(), !instructorList.isEmpty());
        // Retrieve institute field from one of the instructors of the course
        String institute = """";
        for (int i = 0; i < instructorList.size(); i++) {
            String instructorGoogleId = instructorList.get(i).googleId;
            if (instructorGoogleId == null) {
                continue;
            }
            AccountAttributes instructorAcc = accountsDb.getAccount(instructorGoogleId);
            if (instructorAcc != null) {
                institute = instructorAcc.institute;
                break;
            }
        }
        Assumption.assertNotEmpty(""No institute found for the course"", institute);
        return institute;
    }

    public void updateAccount(AccountAttributes account)
            throws InvalidParametersException, EntityDoesNotExistException {
        accountsDb.updateAccount(account, false);
    }

    public void updateAccount(AccountAttributes account, boolean updateStudentProfile)
            throws InvalidParametersException, EntityDoesNotExistException {
        accountsDb.updateAccount(account, updateStudentProfile);
    }

    public void joinCourseForStudent(String registrationKey, String googleId)
            throws JoinCourseException, InvalidParametersException {

        verifyStudentJoinCourseRequest(registrationKey, googleId);

        StudentAttributes student = studentsLogic.getStudentForRegistrationKey(registrationKey);

        //register the student
        student.googleId = googleId;
        try {
            studentsLogic.updateStudentCascade(student.email, student);
        } catch (EntityDoesNotExistException e) {
            Assumption.fail(""Student disappered while trying to register "" + TeammatesException.toStringWithStackTrace(e));
        }

        if (accountsDb.getAccount(googleId) == null) {
            createStudentAccount(student);
        }
    }

    /**
     * Joins the user as an instructor, and sets the institute too.
     */
    public void joinCourseForInstructor(String encryptedKey, String googleId, String institute)
            throws JoinCourseException, InvalidParametersException, EntityDoesNotExistException {

        joinCourseForInstructorWithInstitute(encryptedKey, googleId, institute);

    }

    /**
     * Joins the user as an instructor.
     */
    public void joinCourseForInstructor(String encryptedKey, String googleId)
            throws JoinCourseException, InvalidParametersException, EntityDoesNotExistException {

        joinCourseForInstructorWithInstitute(encryptedKey, googleId, null);

    }

    /**
     * Institute is set only if it is not null. If it is null, this instructor
     * is given the institute of an existing instructor of the same course.
     */
    private void joinCourseForInstructorWithInstitute(String encryptedKey, String googleId, String institute)
            throws JoinCourseException, InvalidParametersException, EntityDoesNotExistException {

        confirmValidJoinCourseRequest(encryptedKey, googleId);

        InstructorAttributes instructor = instructorsLogic.getInstructorForRegistrationKey(encryptedKey);
        AccountAttributes account = accountsDb.getAccount(googleId);
        String instituteToSave = institute == null ? getCourseInstitute(instructor.courseId) : institute;

        if (account == null) {
            createAccount(new AccountAttributes(googleId,
                                                instructor.name,
                                                true,
                                                instructor.email,
                                                instituteToSave));
        } else {
            makeAccountInstructor(googleId);
        }

        instructor.googleId = googleId;
        instructorsLogic.updateInstructorByEmail(instructor.email, instructor);

        //Update the goolgeId of the student entity for the instructor which was created from sampleData.
        StudentAttributes student = studentsLogic.getStudentForEmail(instructor.courseId, instructor.email);
        if (student != null) {
            student.googleId = googleId;
            studentsLogic.updateStudentCascade(instructor.email, student);
        }

    }

    private void confirmValidJoinCourseRequest(String encryptedKey, String googleId)
            throws JoinCourseException {

        //The order in which these confirmations are done is important. Reorder with care.
        confirmValidKey(encryptedKey);

        InstructorAttributes instructorForKey = instructorsLogic.getInstructorForRegistrationKey(encryptedKey);

        confirmNotAlreadyJoinedAsInstructor(instructorForKey, googleId);
        confirmUnusedKey(instructorForKey, googleId);
        confirmNotRejoiningUsingDifferentKey(instructorForKey, googleId);

    }

    private void confirmNotRejoiningUsingDifferentKey(
            InstructorAttributes instructorForKey, String googleId) throws JoinCourseException {

        if (instructorForKey.googleId != null) { //using a used key. this means no danger of rejoining using different key
            return;
        }

        //check if this Google ID has already joined this course
        InstructorAttributes existingInstructor =
                instructorsLogic.getInstructorForGoogleId(instructorForKey.courseId, googleId);

        if (existingInstructor != null) {
            throw new JoinCourseException(
                    String.format(Const.StatusMessages.JOIN_COURSE_GOOGLE_ID_BELONGS_TO_DIFFERENT_USER,
                                  googleId));
        }

    }

    private void confirmNotAlreadyJoinedAsInstructor(InstructorAttributes instructorForKey, String googleId)
            throws JoinCourseException {
        if (instructorForKey.googleId == null || !instructorForKey.googleId.equals(googleId)) {
            return;
        }
        AccountAttributes existingAccount = accountsDb.getAccount(googleId);
        if (existingAccount != null && existingAccount.isInstructor) {
            throw new JoinCourseException(Const.StatusCodes.ALREADY_JOINED,
                                          googleId + "" has already joined this course"");
        }

    }

    private void confirmValidKey(String encryptedKey) throws JoinCourseException {
        InstructorAttributes instructorForKey = instructorsLogic.getInstructorForRegistrationKey(encryptedKey);

        if (instructorForKey == null) {
            String joinUrl = Const.ActionURIs.INSTRUCTOR_COURSE_JOIN + ""?key="" + encryptedKey;
            throw new JoinCourseException(Const.StatusCodes.INVALID_KEY,
                                          ""You have used an invalid join link: "" + joinUrl);

        }
    }

    private void confirmUnusedKey(InstructorAttributes instructorForKey, String googleId) throws JoinCourseException {
        if (instructorForKey.googleId == null) {
            return;
        }

        //We assume we have already confirmed that the key was not used by this
        //  person already.
        if (!instructorForKey.googleId.equals(googleId)) {
            throw new JoinCourseException(Const.StatusCodes.KEY_BELONGS_TO_DIFFERENT_USER,
                                          String.format(Const.StatusMessages.JOIN_COURSE_KEY_BELONGS_TO_DIFFERENT_USER,
                                                  StringHelper.obscure(instructorForKey.googleId)));
        }
    }

    private void verifyStudentJoinCourseRequest(String encryptedKey, String googleId)
            throws JoinCourseException {

        StudentAttributes studentRole = studentsLogic.getStudentForRegistrationKey(encryptedKey);

        if (studentRole == null) {
            throw new JoinCourseException(Const.StatusCodes.INVALID_KEY,
                    ""You have used an invalid join link: %s"");
        } else if (studentRole.isRegistered()) {
            if (studentRole.googleId.equals(googleId)) {
                throw new JoinCourseException(Const.StatusCodes.ALREADY_JOINED,
                        ""You ("" + googleId + "") have already joined this course"");
            }
            throw new JoinCourseException(
                    Const.StatusCodes.KEY_BELONGS_TO_DIFFERENT_USER,
                    String.format(Const.StatusMessages.JOIN_COURSE_KEY_BELONGS_TO_DIFFERENT_USER,
                                  StringHelper.obscure(studentRole.googleId)));
        }

        StudentAttributes existingStudent =
                studentsLogic.getStudentForCourseIdAndGoogleId(studentRole.course, googleId);

        if (existingStudent != null) {
            throw new JoinCourseException(
                    String.format(Const.StatusMessages.JOIN_COURSE_GOOGLE_ID_BELONGS_TO_DIFFERENT_USER,
                            googleId));
        }
    }

    public void downgradeInstructorToStudentCascade(String googleId) {
        instructorsLogic.deleteInstructorsForGoogleIdAndCascade(googleId);
        makeAccountNonInstructor(googleId);
    }

    public void makeAccountNonInstructor(String googleId) {
        AccountAttributes account = accountsDb.getAccount(googleId, true);
        if (account == null) {
            log.warning(""Accounts logic trying to modify non-existent account a non-instructor :"" + googleId);
        } else {
            account.isInstructor = false;
            try {
                accountsDb.updateAccount(account);
            } catch (InvalidParametersException | EntityDoesNotExistException e) {
                Assumption.fail(""Invalid account data detected unexpectedly ""
                                + ""while removing instruction privileges from account :"" + account.toString());
            }
        }
    }

    public void makeAccountInstructor(String googleId) {

        AccountAttributes account = accountsDb.getAccount(googleId, true);

        if (account == null) {
            log.warning(""Accounts logic trying to modify non-existent account an instructor:"" + googleId);
        } else {
            account.isInstructor = true;
            try {
                accountsDb.updateAccount(account);
            } catch (InvalidParametersException | EntityDoesNotExistException e) {
                Assumption.fail(""Invalid account data detected unexpectedly ""
                                + ""while adding instruction privileges to account :"" + account.toString());
            }
        }
    }

    public void deleteAccountCascade(String googleId) {
        instructorsLogic.deleteInstructorsForGoogleIdAndCascade(googleId);
        studentsLogic.deleteStudentsForGoogleIdAndCascade(googleId);
        accountsDb.deleteAccount(googleId);
        //TODO: deal with orphan courses, submissions etc.
    }

    private void createStudentAccount(StudentAttributes student)
            throws InvalidParametersException {
        AccountAttributes account = new AccountAttributes();
        account.googleId = student.googleId;
        account.email = student.email;
        account.name = student.name;
        account.isInstructor = false;
        account.institute = getCourseInstitute(student.course);

        StudentProfileAttributes spa = StudentProfileAttributes.builder().build();
        spa.googleId = student.googleId;
        spa.institute = account.institute;
        account.studentProfile = spa;
        accountsDb.createAccount(account);
    }

}
"
AdminEmailsLogic.java,logic-core,"package teammates.logic.core;

import java.util.Date;
import java.util.List;

import com.google.appengine.api.blobstore.BlobKey;

import teammates.common.datatransfer.attributes.AdminEmailAttributes;
import teammates.common.exception.EntityDoesNotExistException;
import teammates.common.exception.InvalidParametersException;
import teammates.common.util.Assumption;
import teammates.storage.api.AdminEmailsDb;

/**
 * Handles operations related to emails sent by the admin.
 *
 * @see AdminEmailAttributes
 * @see AdminEmailsDb
 */
public final class AdminEmailsLogic {

    private static AdminEmailsLogic instance = new AdminEmailsLogic();

    private static final AdminEmailsDb adminEmailsDb = new AdminEmailsDb();

    private AdminEmailsLogic() {
        // prevent initialization
    }

    public static AdminEmailsLogic inst() {
        return instance;
    }

    /**
     * This method is not scalable. Not to be used unless for admin features.
     * @return the list of all adminEmails in the database.
     */
    @Deprecated
    public List<AdminEmailAttributes> getAllAdminEmails() {
        return adminEmailsDb.getAllAdminEmails();
    }

    /**
     * Gets an admin email by email id.
     * @return null if no matched email found
     */
    public AdminEmailAttributes getAdminEmailById(String emailId) {
        Assumption.assertNotNull(emailId);
        return adminEmailsDb.getAdminEmailById(emailId);
    }

    /**
     * Gets an admin email by subject and createDate.
     * @return null if no matched email found
     */
    public AdminEmailAttributes getAdminEmail(String subject, Date createDate) {
        Assumption.assertNotNull(subject);
        Assumption.assertNotNull(createDate);

        return adminEmailsDb.getAdminEmail(subject, createDate);
    }

    /**
     * Gets an admin email based on subject.
     * @return null if no matched email found
     */
    public AdminEmailAttributes getAdminEmailBySubject(String subject) {
        Assumption.assertNotNull(subject);

        return adminEmailsDb.getAdminEmailBySubject(subject);
    }

    /**
     * Move an admin email to trash bin.<br>
     * After this the attribute isInTrashBin will be set to true
     */
    public void moveAdminEmailToTrashBin(String adminEmailId)
            throws InvalidParametersException, EntityDoesNotExistException {
        Assumption.assertNotNull(adminEmailId);

        AdminEmailAttributes adminEmailToUpdate = getAdminEmailById(adminEmailId);

        if (adminEmailToUpdate != null) {
            adminEmailToUpdate.isInTrashBin = true;
            adminEmailsDb.updateAdminEmail(adminEmailToUpdate);
        }
    }

    /**
     * Move an admin email out of trash bin.<br>
     * After this the attribute isInTrashBin will be set to false
     */
    public void moveAdminEmailOutOfTrashBin(String adminEmailId)
            throws InvalidParametersException, EntityDoesNotExistException {
        Assumption.assertNotNull(adminEmailId);

        AdminEmailAttributes adminEmailToUpdate = getAdminEmailById(adminEmailId);

        if (adminEmailToUpdate != null) {
            adminEmailToUpdate.isInTrashBin = false;
            adminEmailsDb.updateAdminEmail(adminEmailToUpdate);
        }
    }

    /**
     * Gets all admin emails that have been sent and not in trash bin.
     * @return empty list if no email found
     */
    public List<AdminEmailAttributes> getSentAdminEmails() {
        return adminEmailsDb.getSentAdminEmails();
    }

    /**
     * Gets all admin email drafts that have NOT been sent and NOT in trash bin.
     * @return empty list if no email found
     */
    public List<AdminEmailAttributes> getAdminEmailDrafts() {
        return adminEmailsDb.getAdminEmailDrafts();
    }

    /**
     * Gets all admin emails that have been moved into trash bin.
     * @return empty list if no email found
     */
    public List<AdminEmailAttributes> getAdminEmailsInTrashBin() {
        return adminEmailsDb.getAdminEmailsInTrashBin();
    }

    public Date createAdminEmail(AdminEmailAttributes newAdminEmail) throws InvalidParametersException {
        return adminEmailsDb.createAdminEmail(newAdminEmail);
    }

    /**
     * Updates an admin email by email id.
     */
    public void updateAdminEmailById(AdminEmailAttributes newAdminEmail, String emailId)
            throws InvalidParametersException, EntityDoesNotExistException {
        Assumption.assertNotNull(emailId);
        Assumption.assertNotNull(newAdminEmail);

        adminEmailsDb.updateAdminEmailById(newAdminEmail, emailId);
    }

    /**
     * Deletes all emails in trash bin.
     */
    public void deleteAllEmailsInTrashBin() {
        adminEmailsDb.deleteAllEmailsInTrashBin();
    }

    /**
     * Deletes files uploaded in admin email compose page.
     * @param key the GCS blobkey used to fetch the file in Google Cloud Storage
     */
    public void deleteAdminEmailUploadedFile(BlobKey key) {
        adminEmailsDb.deleteAdminEmailUploadedFile(key);
    }
}
"
CoursesLogic.java,logic-core,"package teammates.logic.core;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import teammates.common.datatransfer.CourseDetailsBundle;
import teammates.common.datatransfer.CourseSummaryBundle;
import teammates.common.datatransfer.FeedbackSessionDetailsBundle;
import teammates.common.datatransfer.InstructorPrivileges;
import teammates.common.datatransfer.SectionDetailsBundle;
import teammates.common.datatransfer.TeamDetailsBundle;
import teammates.common.datatransfer.attributes.AccountAttributes;
import teammates.common.datatransfer.attributes.CourseAttributes;
import teammates.common.datatransfer.attributes.FeedbackSessionAttributes;
import teammates.common.datatransfer.attributes.InstructorAttributes;
import teammates.common.datatransfer.attributes.StudentAttributes;
import teammates.common.exception.EntityAlreadyExistsException;
import teammates.common.exception.EntityDoesNotExistException;
import teammates.common.exception.InvalidParametersException;
import teammates.common.exception.TeammatesException;
import teammates.common.util.Assumption;
import teammates.common.util.Const;
import teammates.common.util.FieldValidator;
import teammates.common.util.Logger;
import teammates.common.util.SanitizationHelper;
import teammates.common.util.StringHelper;
import teammates.storage.api.CoursesDb;

/**
 * Handles operations related to courses.
 *
 * @see CourseAttributes
 * @see CoursesDb
 */
public final class CoursesLogic {

    private static final Logger log = Logger.getLogger();

    private static CoursesLogic instance = new CoursesLogic();

    /* Explanation: This class depends on CoursesDb class but no other *Db classes.
     * That is because reading/writing entities from/to the datastore is the
     * responsibility of the matching *Logic class.
     * However, this class can talk to other *Logic classes. That is because
     * the logic related to one entity type can involve the logic related to
     * other entity types.
     */

    private static final CoursesDb coursesDb = new CoursesDb();

    private static final AccountsLogic accountsLogic = AccountsLogic.inst();
    private static final FeedbackSessionsLogic feedbackSessionsLogic = FeedbackSessionsLogic.inst();
    private static final InstructorsLogic instructorsLogic = InstructorsLogic.inst();
    private static final StudentsLogic studentsLogic = StudentsLogic.inst();

    private CoursesLogic() {
        // prevent initialization
    }

    public static CoursesLogic inst() {
        return instance;
    }

    public void createCourse(String courseId, String courseName, String courseTimeZone)
            throws InvalidParametersException, EntityAlreadyExistsException {

        CourseAttributes courseToAdd = new CourseAttributes(courseId, courseName, courseTimeZone);
        coursesDb.createEntity(courseToAdd);
    }

    /**
     * Creates a Course object and an Instructor object for the Course.
     */
    public void createCourseAndInstructor(String instructorGoogleId, String courseId, String courseName,
                                          String courseTimeZone)
            throws InvalidParametersException, EntityAlreadyExistsException {

        AccountAttributes courseCreator = accountsLogic.getAccount(instructorGoogleId);
        Assumption.assertNotNull(""Trying to create a course for a non-existent instructor :"" + instructorGoogleId,
                                 courseCreator);
        Assumption.assertTrue(""Trying to create a course for a person who doesn't have instructor privileges :""
                                  + instructorGoogleId,
                              courseCreator.isInstructor);

        createCourse(courseId, courseName, courseTimeZone);

        /* Create the initial instructor for the course */
        InstructorPrivileges privileges = new InstructorPrivileges(
                Const.InstructorPermissionRoleNames.INSTRUCTOR_PERMISSION_ROLE_COOWNER);
        InstructorAttributes instructor = InstructorAttributes
                .builder(instructorGoogleId, courseId, courseCreator.name, courseCreator.email)
                .withPrivileges(privileges)
                .build();

        try {
            instructorsLogic.createInstructor(instructor);
        } catch (EntityAlreadyExistsException | InvalidParametersException e) {
            //roll back the transaction
            coursesDb.deleteCourse(courseId);
            String errorMessage = ""Unexpected exception while trying to create instructor for a new course "" + Const.EOL
                                  + instructor.toString() + Const.EOL
                                  + TeammatesException.toStringWithStackTrace(e);
            Assumption.fail(errorMessage);
        }
    }

    /**
     * Gets the course with the specified ID.
     */
    public CourseAttributes getCourse(String courseId) {
        return coursesDb.getCourse(courseId);
    }

    /**
     * Returns true if the course with ID courseId is present.
     */
    public boolean isCoursePresent(String courseId) {
        return coursesDb.getCourse(courseId) != null;
    }

    /**
     * Returns true if the course with ID courseId is a sample course.
     */
    public boolean isSampleCourse(String courseId) {
        Assumption.assertNotNull(""Course ID is null"", courseId);
        return StringHelper.isMatching(courseId, FieldValidator.REGEX_SAMPLE_COURSE_ID);
    }

    /**
     * Used to trigger an {@link EntityDoesNotExistException} if the course is not present.
     */
    public void verifyCourseIsPresent(String courseId) throws EntityDoesNotExistException {
        if (!isCoursePresent(courseId)) {
            throw new EntityDoesNotExistException(""Course does not exist: "" + courseId);
        }
    }

    /**
     * Returns a list of {@link CourseDetailsBundle} for all
     * courses a given student is enrolled in.
     *
     * @param googleId The Google ID of the student
     */
    public List<CourseDetailsBundle> getCourseDetailsListForStudent(String googleId)
                throws EntityDoesNotExistException {

        List<CourseAttributes> courseList = getCoursesForStudentAccount(googleId);
        CourseAttributes.sortById(courseList);
        List<CourseDetailsBundle> courseDetailsList = new ArrayList<>();

        for (CourseAttributes c : courseList) {

            StudentAttributes s = studentsLogic.getStudentForCourseIdAndGoogleId(c.getId(), googleId);

            if (s == null) {
                //TODO Remove excessive logging after the reason why s can be null is found
                StringBuilder logMsgBuilder = new StringBuilder();
                String logMsg = ""Student is null in CoursesLogic.getCourseDetailsListForStudent(String googleId)""
                        + ""<br> Student Google ID: ""
                        + googleId + ""<br> Course: "" + c.getId()
                        + ""<br> All Courses Retrieved using the Google ID:"";
                logMsgBuilder.append(logMsg);
                for (CourseAttributes course : courseList) {
                    logMsgBuilder.append(""<br>"").append(course.getId());
                }
                log.severe(logMsgBuilder.toString());

                //TODO Failing might not be the best course of action here.
                //Maybe throw a custom exception and tell user to wait due to eventual consistency?
                Assumption.fail(""Student should not be null at this point."");
            }

            // Skip the course existence check since the course ID is obtained from a
            // valid CourseAttributes resulting from query
            List<FeedbackSessionAttributes> feedbackSessionList =
                    feedbackSessionsLogic.getFeedbackSessionsForUserInCourseSkipCheck(c.getId(), s.email);

            CourseDetailsBundle cdd = new CourseDetailsBundle(c);

            for (FeedbackSessionAttributes fs : feedbackSessionList) {
                cdd.feedbackSessions.add(new FeedbackSessionDetailsBundle(fs));
            }

            courseDetailsList.add(cdd);
        }
        return courseDetailsList;
    }

    /**
     * Returns a list of section names for the course with ID courseId.
     */
    public List<String> getSectionsNameForCourse(String courseId) throws EntityDoesNotExistException {
        return getSectionsNameForCourse(courseId, false);
    }

    /**
     * Returns a list of section names for the specified course.
     */
    public List<String> getSectionsNameForCourse(CourseAttributes course) throws EntityDoesNotExistException {
        Assumption.assertNotNull(""Course is null"", course);
        return getSectionsNameForCourse(course.getId(), true);
    }

    /**
     * Returns a list of section names for a course with or without a need to
     * check if the course is existent.
     *
     * @param courseId Course ID of the course
     * @param isCourseVerified Determine whether it is necessary to check if the course exists
     */
    private List<String> getSectionsNameForCourse(String courseId, boolean isCourseVerified)
        throws EntityDoesNotExistException {
        if (!isCourseVerified) {
            verifyCourseIsPresent(courseId);
        }
        List<StudentAttributes> studentDataList = studentsLogic.getStudentsForCourse(courseId);

        Set<String> sectionNameSet = new HashSet<>();
        for (StudentAttributes sd : studentDataList) {
            if (!sd.section.equals(Const.DEFAULT_SECTION)) {
                sectionNameSet.add(sd.section);
            }
        }

        List<String> sectionNameList = new ArrayList<>(sectionNameSet);
        Collections.sort(sectionNameList);

        return sectionNameList;
    }

    /**
     * Returns a list of {@link SectionDetailsBundle} for a
     * given course using course attributes and course details bundle.
     *
     * @param course {@link CourseAttributes}
     * @param cdd {@link CourseDetailsBundle}
     */
    public List<SectionDetailsBundle> getSectionsForCourse(CourseAttributes course, CourseDetailsBundle cdd) {
        Assumption.assertNotNull(""Course is null"", course);

        List<StudentAttributes> students = studentsLogic.getStudentsForCourse(course.getId());
        StudentAttributes.sortBySectionName(students);

        List<SectionDetailsBundle> sections = new ArrayList<>();

        SectionDetailsBundle section = null;
        int teamIndexWithinSection = 0;

        for (int i = 0; i < students.size(); i++) {

            StudentAttributes s = students.get(i);
            cdd.stats.studentsTotal++;
            if (!s.isRegistered()) {
                cdd.stats.unregisteredTotal++;
            }

            if (section == null) { // First student of first section
                section = new SectionDetailsBundle();
                section.name = s.section;
                section.teams.add(new TeamDetailsBundle());
                cdd.stats.teamsTotal++;
                section.teams.get(teamIndexWithinSection).name = s.team;
                section.teams.get(teamIndexWithinSection).students.add(s);
            } else if (s.section.equals(section.name)) {
                if (s.team.equals(section.teams.get(teamIndexWithinSection).name)) {
                    section.teams.get(teamIndexWithinSection).students.add(s);
                } else {
                    teamIndexWithinSection++;
                    section.teams.add(new TeamDetailsBundle());
                    cdd.stats.teamsTotal++;
                    section.teams.get(teamIndexWithinSection).name = s.team;
                    section.teams.get(teamIndexWithinSection).students.add(s);
                }
            } else { // first student of subsequent section
                sections.add(section);
                if (!section.name.equals(Const.DEFAULT_SECTION)) {
                    cdd.stats.sectionsTotal++;
                }
                teamIndexWithinSection = 0;
                section = new SectionDetailsBundle();
                section.name = s.section;
                section.teams.add(new TeamDetailsBundle());
                cdd.stats.teamsTotal++;
                section.teams.get(teamIndexWithinSection).name = s.team;
                section.teams.get(teamIndexWithinSection).students.add(s);
            }

            boolean isLastStudent = i == students.size() - 1;
            if (isLastStudent) {
                sections.add(section);
                if (!section.name.equals(Const.DEFAULT_SECTION)) {
                    cdd.stats.sectionsTotal++;
                }
            }
        }

        return sections;
    }

    /**
     * Returns a list of {@link SectionDetailsBundle} for a given course using courseId.
     */
    public List<SectionDetailsBundle> getSectionsForCourseWithoutStats(String courseId)
            throws EntityDoesNotExistException {

        verifyCourseIsPresent(courseId);

        List<StudentAttributes> students = studentsLogic.getStudentsForCourse(courseId);
        StudentAttributes.sortBySectionName(students);

        List<SectionDetailsBundle> sections = new ArrayList<>();

        SectionDetailsBundle section = null;
        int teamIndexWithinSection = 0;

        for (int i = 0; i < students.size(); i++) {
            StudentAttributes s = students.get(i);

            if (section == null) { // First student of first section
                section = new SectionDetailsBundle();
                section.name = s.section;
                section.teams.add(new TeamDetailsBundle());
                section.teams.get(teamIndexWithinSection).name = s.team;
                section.teams.get(teamIndexWithinSection).students.add(s);
            } else if (s.section.equals(section.name)) {
                if (s.team.equals(section.teams.get(teamIndexWithinSection).name)) {
                    section.teams.get(teamIndexWithinSection).students.add(s);
                } else {
                    teamIndexWithinSection++;
                    section.teams.add(new TeamDetailsBundle());
                    section.teams.get(teamIndexWithinSection).name = s.team;
                    section.teams.get(teamIndexWithinSection).students.add(s);
                }
            } else { // first student of subsequent section
                sections.add(section);
                teamIndexWithinSection = 0;
                section = new SectionDetailsBundle();
                section.name = s.section;
                section.teams.add(new TeamDetailsBundle());
                section.teams.get(teamIndexWithinSection).name = s.team;
                section.teams.get(teamIndexWithinSection).students.add(s);
            }

            boolean isLastStudent = i == students.size() - 1;
            if (isLastStudent) {
                sections.add(section);
            }
        }

        return sections;
    }

    /**
     * Returns Teams for a particular courseId.<br>
     * <b>Note:</b><br>
     * This method does not returns any Loner information presently,<br>
     * Loner information must be returned as we decide to support loners<br>in future.
     *
     */
    public List<TeamDetailsBundle> getTeamsForCourse(String courseId) throws EntityDoesNotExistException {

        if (getCourse(courseId) == null) {
            throw new EntityDoesNotExistException(""The course "" + courseId + "" does not exist"");
        }

        List<StudentAttributes> students = studentsLogic.getStudentsForCourse(courseId);
        StudentAttributes.sortByTeamName(students);

        List<TeamDetailsBundle> teams = new ArrayList<>();

        TeamDetailsBundle team = null;

        for (int i = 0; i < students.size(); i++) {

            StudentAttributes s = students.get(i);

            // first student of first team
            if (team == null) {
                team = new TeamDetailsBundle();
                team.name = s.team;
                team.students.add(s);
            } else if (s.team.equals(team.name)) { // student in the same team as the previous student
                team.students.add(s);
            } else { // first student of subsequent teams (not the first team)
                teams.add(team);
                team = new TeamDetailsBundle();
                team.name = s.team;
                team.students.add(s);
            }

            // if last iteration
            if (i == students.size() - 1) {
                teams.add(team);
            }
        }

        return teams;
    }

    /**
     * Returns the {@link CourseDetailsBundle} course details for a course using {@link CourseAttributes}.
     */
    public CourseDetailsBundle getCourseSummary(CourseAttributes cd) {
        Assumption.assertNotNull(""Supplied parameter was null"", cd);

        CourseDetailsBundle cdd = new CourseDetailsBundle(cd);
        cdd.sections = (ArrayList<SectionDetailsBundle>) getSectionsForCourse(cd, cdd);

        return cdd;
    }

    // TODO: reduce calls to this function, use above function instead.
    /**
     * Returns the {@link CourseDetailsBundle} course details for a course using courseId.
     */
    public CourseDetailsBundle getCourseSummary(String courseId) throws EntityDoesNotExistException {
        CourseAttributes cd = coursesDb.getCourse(courseId);

        if (cd == null) {
            throw new EntityDoesNotExistException(""The course does not exist: "" + courseId);
        }

        return getCourseSummary(cd);
    }

    /**
     * Returns the {@link CourseSummaryBundle course summary}, including its
     * feedback sessions using the given {@link InstructorAttributes}.
     */
    public CourseSummaryBundle getCourseSummaryWithFeedbackSessionsForInstructor(
            InstructorAttributes instructor) throws EntityDoesNotExistException {
        CourseSummaryBundle courseSummary = getCourseSummaryWithoutStats(instructor.courseId);
        courseSummary.feedbackSessions.addAll(feedbackSessionsLogic.getFeedbackSessionListForInstructor(instructor));
        return courseSummary;
    }

    /**
     * Returns the {@link CourseSummaryBundle course summary} using the {@link CourseAttributes}.
     */
    public CourseSummaryBundle getCourseSummaryWithoutStats(CourseAttributes course) {
        Assumption.assertNotNull(""Supplied parameter was null"", course);

        return new CourseSummaryBundle(course);
    }

    /**
     * Returns the {@link CourseSummaryBundle course summary} using the courseId.
     */
    public CourseSummaryBundle getCourseSummaryWithoutStats(String courseId) throws EntityDoesNotExistException {
        CourseAttributes cd = coursesDb.getCourse(courseId);

        if (cd == null) {
            throw new EntityDoesNotExistException(""The course does not exist: "" + courseId);
        }

        return getCourseSummaryWithoutStats(cd);
    }

    /**
     * Returns a list of {@link CourseAttributes} for all courses a given student is enrolled in.
     *
     * @param googleId The Google ID of the student
     */
    public List<CourseAttributes> getCoursesForStudentAccount(String googleId) throws EntityDoesNotExistException {
        List<StudentAttributes> studentDataList = studentsLogic.getStudentsForGoogleId(googleId);

        if (studentDataList.isEmpty()) {
            throw new EntityDoesNotExistException(""Student with Google ID "" + googleId + "" does not exist"");
        }

        List<String> courseIds = new ArrayList<>();
        for (StudentAttributes s : studentDataList) {
            courseIds.add(s.course);
        }
        return coursesDb.getCourses(courseIds);
    }

    /**
     * Returns a list of {@link CourseAttributes} for all courses a given instructor belongs to.
     *
     * @param googleId The Google ID of the instructor
     */
    public List<CourseAttributes> getCoursesForInstructor(String googleId) {
        return getCoursesForInstructor(googleId, false);
    }

    /**
     * Returns a list of {@link CourseAttributes} for courses a given instructor belongs to.
     *
     * @param googleId The Google ID of the instructor
     * @param omitArchived if {@code true}, omits all the archived courses from the return
     */
    public List<CourseAttributes> getCoursesForInstructor(String googleId, boolean omitArchived) {
        List<InstructorAttributes> instructorList = instructorsLogic.getInstructorsForGoogleId(googleId, omitArchived);
        return getCoursesForInstructor(instructorList);
    }

    /**
     * Returns a list of {@link CourseAttributes} for all courses for a given list of instructors.
     */
    public List<CourseAttributes> getCoursesForInstructor(List<InstructorAttributes> instructorList) {
        Assumption.assertNotNull(""Supplied parameter was null"", instructorList);
        List<String> courseIdList = new ArrayList<>();

        for (InstructorAttributes instructor : instructorList) {
            courseIdList.add(instructor.courseId);
        }

        List<CourseAttributes> courseList = coursesDb.getCourses(courseIdList);

        // Check that all courseIds queried returned a course.
        if (courseIdList.size() > courseList.size()) {
            for (CourseAttributes ca : courseList) {
                courseIdList.remove(ca.getId());
            }
            log.severe(""Course(s) was deleted but the instructor still exists: "" + Const.EOL + courseIdList.toString());
        }

        return courseList;
    }

    /**
     * Returns course summaries for instructor.<br>
     * Omits archived courses if omitArchived == true<br>
     *
     * @param googleId The Google ID of the instructor
     * @return Map with courseId as key, and CourseDetailsBundle as value.
     *         Does not include details within the course, such as feedback sessions.
     */
    public Map<String, CourseDetailsBundle> getCourseSummariesForInstructor(String googleId, boolean omitArchived)
            throws EntityDoesNotExistException {

        instructorsLogic.verifyInstructorExists(googleId);

        List<InstructorAttributes> instructorAttributesList = instructorsLogic.getInstructorsForGoogleId(googleId,
                                                                                                         omitArchived);

        return getCourseSummariesForInstructor(instructorAttributesList);
    }

    /**
     * Returns course summaries for instructors.<br>
     *
     * @return Map with courseId as key, and CourseDetailsBundle as value.
     *         Does not include details within the course, such as feedback sessions.
     */
    public Map<String, CourseDetailsBundle> getCourseSummariesForInstructor(
            List<InstructorAttributes> instructorAttributesList) {

        HashMap<String, CourseDetailsBundle> courseSummaryList = new HashMap<>();
        List<String> courseIdList = new ArrayList<>();

        for (InstructorAttributes instructor : instructorAttributesList) {
            courseIdList.add(instructor.courseId);
        }

        List<CourseAttributes> courseList = coursesDb.getCourses(courseIdList);

        // Check that all courseIds queried returned a course.
        if (courseIdList.size() > courseList.size()) {
            for (CourseAttributes ca : courseList) {
                courseIdList.remove(ca.getId());
            }
            log.severe(""Course(s) was deleted but the instructor still exists: "" + Const.EOL + courseIdList.toString());
        }

        for (CourseAttributes ca : courseList) {
            courseSummaryList.put(ca.getId(), getCourseSummary(ca));
        }

        return courseSummaryList;
    }

    /**
     * Returns a Map (CourseId, {@link CourseSummaryBundle}
     * for all courses mapped to a given instructor.
     *
     * @param omitArchived if {@code true}, omits all the archived courses from the return
     */
    public Map<String, CourseSummaryBundle> getCoursesSummaryWithoutStatsForInstructor(
            String instructorId, boolean omitArchived) {

        List<InstructorAttributes> instructorList = instructorsLogic.getInstructorsForGoogleId(instructorId,
                                                                                               omitArchived);
        return getCourseSummaryWithoutStatsForInstructor(instructorList);
    }

    /**
     * Updates the course details.
     * @param newCourse the course object containing new details of the course
     */
    public void updateCourse(CourseAttributes newCourse) throws InvalidParametersException,
                                                                EntityDoesNotExistException {
        Assumption.assertNotNull(Const.StatusCodes.NULL_PARAMETER, newCourse);

        CourseAttributes oldCourse = coursesDb.getCourse(newCourse.getId());

        if (oldCourse == null) {
            throw new EntityDoesNotExistException(""Trying to update a course that does not exist."");
        }

        coursesDb.updateCourse(newCourse);
    }

    /**
     * Delete a course from its given corresponding ID.
     * This will also cascade the data in other databases which are related to this course.
     */
    public void deleteCourseCascade(String courseId) {
        studentsLogic.deleteStudentsForCourse(courseId);
        instructorsLogic.deleteInstructorsForCourse(courseId);
        feedbackSessionsLogic.deleteFeedbackSessionsForCourseCascade(courseId);
        coursesDb.deleteCourse(courseId);
    }

    private Map<String, CourseSummaryBundle> getCourseSummaryWithoutStatsForInstructor(
            List<InstructorAttributes> instructorAttributesList) {

        HashMap<String, CourseSummaryBundle> courseSummaryList = new HashMap<>();

        List<String> courseIdList = new ArrayList<>();

        for (InstructorAttributes ia : instructorAttributesList) {
            courseIdList.add(ia.courseId);
        }
        List<CourseAttributes> courseList = coursesDb.getCourses(courseIdList);

        // Check that all courseIds queried returned a course.
        if (courseIdList.size() > courseList.size()) {
            for (CourseAttributes ca : courseList) {
                courseIdList.remove(ca.getId());
            }
            log.severe(""Course(s) was deleted but the instructor still exists: "" + Const.EOL + courseIdList.toString());
        }

        for (CourseAttributes ca : courseList) {
            courseSummaryList.put(ca.getId(), getCourseSummaryWithoutStats(ca));
        }

        return courseSummaryList;
    }

    /**
     * Returns a CSV for the details (name, email, status) of all students belonging to a given course.
     */
    public String getCourseStudentListAsCsv(String courseId, String googleId) throws EntityDoesNotExistException {

        Map<String, CourseDetailsBundle> courses = getCourseSummariesForInstructor(googleId, false);
        CourseDetailsBundle course = courses.get(courseId);
        boolean hasSection = hasIndicatedSections(courseId);

        StringBuilder export = new StringBuilder(100);
        String courseInfo = ""Course ID,"" + SanitizationHelper.sanitizeForCsv(courseId) + Const.EOL
                      + ""Course Name,"" + SanitizationHelper.sanitizeForCsv(course.course.getName()) + Const.EOL
                      + Const.EOL + Const.EOL;
        export.append(courseInfo);

        String header = (hasSection ? ""Section,"" : """") + ""Team,Full Name,Last Name,Status,Email"" + Const.EOL;
        export.append(header);

        for (SectionDetailsBundle section : course.sections) {
            for (TeamDetailsBundle team : section.teams) {
                for (StudentAttributes student : team.students) {
                    String studentStatus = null;
                    if (student.googleId == null || student.googleId.isEmpty()) {
                        studentStatus = Const.STUDENT_COURSE_STATUS_YET_TO_JOIN;
                    } else {
                        studentStatus = Const.STUDENT_COURSE_STATUS_JOINED;
                    }

                    if (hasSection) {
                        export.append(SanitizationHelper.sanitizeForCsv(section.name)).append(',');
                    }

                    export.append(SanitizationHelper.sanitizeForCsv(team.name) + ','
                            + SanitizationHelper.sanitizeForCsv(StringHelper.removeExtraSpace(student.name)) + ','
                            + SanitizationHelper.sanitizeForCsv(StringHelper.removeExtraSpace(student.lastName)) + ','
                            + SanitizationHelper.sanitizeForCsv(studentStatus) + ','
                            + SanitizationHelper.sanitizeForCsv(student.email) + Const.EOL);
                }
            }
        }
        return export.toString();
    }

    public boolean hasIndicatedSections(String courseId) throws EntityDoesNotExistException {
        verifyCourseIsPresent(courseId);

        List<StudentAttributes> studentList = studentsLogic.getStudentsForCourse(courseId);
        for (StudentAttributes student : studentList) {
            if (!student.section.equals(Const.DEFAULT_SECTION)) {
                return true;
            }
        }
        return false;
    }

    /**
     * Returns a list of courseIds for all archived courses for all instructors.
     */
    public List<String> getArchivedCourseIds(List<CourseAttributes> allCourses,
                                             Map<String, InstructorAttributes> instructorsForCourses) {
        List<String> archivedCourseIds = new ArrayList<>();
        for (CourseAttributes course : allCourses) {
            InstructorAttributes instructor = instructorsForCourses.get(course.getId());
            if (instructor.isArchived) {
                archivedCourseIds.add(course.getId());
            }
        }
        return archivedCourseIds;
    }

}
"
EmailSenderService.java,logic-core,"package teammates.logic.core;

import teammates.common.exception.EmailSendingException;
import teammates.common.util.EmailWrapper;

/**
 * An email sender interface used by services for sending emails.
 */
public abstract class EmailSenderService {

    protected static final int SUCCESS_CODE = 200;

    /**
     * Parses the {@code wrapper} email object to specific implementations of email object
     * used by the service.
     */
    @SuppressWarnings(""PMD.SignatureDeclareThrowsException"")
    // accounts for the many different Exceptions from different email services
    public abstract Object parseToEmail(EmailWrapper wrapper) throws Exception;

    /**
     * Sends the email packaged as a {@code wrapper}.
     */
    public void sendEmail(EmailWrapper wrapper) throws EmailSendingException {
        try {
            sendEmailWithService(wrapper);
        } catch (Exception e) {
            throw new EmailSendingException(e);
        }
    }

    @SuppressWarnings(""PMD.SignatureDeclareThrowsException"")
    // accounts for the many different Exceptions from different email services
    protected abstract void sendEmailWithService(EmailWrapper wrapper) throws Exception;

}
"
FeedbackQuestionsLogic.java,logic-core,"package teammates.logic.core;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import teammates.common.datatransfer.FeedbackParticipantType;
import teammates.common.datatransfer.TeamDetailsBundle;
import teammates.common.datatransfer.attributes.CourseAttributes;
import teammates.common.datatransfer.attributes.FeedbackQuestionAttributes;
import teammates.common.datatransfer.attributes.FeedbackResponseAttributes;
import teammates.common.datatransfer.attributes.FeedbackSessionAttributes;
import teammates.common.datatransfer.attributes.InstructorAttributes;
import teammates.common.datatransfer.attributes.StudentAttributes;
import teammates.common.datatransfer.questions.FeedbackQuestionDetails;
import teammates.common.exception.EntityDoesNotExistException;
import teammates.common.exception.InvalidParametersException;
import teammates.common.util.Assumption;
import teammates.common.util.Const;
import teammates.common.util.Logger;
import teammates.storage.api.FeedbackQuestionsDb;

/**
 * Handles operations related to feedback questions.
 *
 * @see FeedbackQuestionAttributes
 * @see FeedbackQuestionsDb
 */
public final class FeedbackQuestionsLogic {

    private static final Logger log = Logger.getLogger();

    private static FeedbackQuestionsLogic instance = new FeedbackQuestionsLogic();

    private static final FeedbackQuestionsDb fqDb = new FeedbackQuestionsDb();

    private static final CoursesLogic coursesLogic = CoursesLogic.inst();
    private static final FeedbackResponsesLogic frLogic = FeedbackResponsesLogic.inst();
    private static final FeedbackSessionsLogic fsLogic = FeedbackSessionsLogic.inst();
    private static final InstructorsLogic instructorsLogic = InstructorsLogic.inst();
    private static final StudentsLogic studentsLogic = StudentsLogic.inst();

    private FeedbackQuestionsLogic() {
        // prevent initialization
    }

    public static FeedbackQuestionsLogic inst() {
        return instance;
    }

    public void createFeedbackQuestion(FeedbackQuestionAttributes fqa)
            throws InvalidParametersException {

        String feedbackSessionName = fqa.feedbackSessionName;
        String courseId = fqa.courseId;
        List<FeedbackQuestionAttributes> questions = null;

        try {
            questions = getFeedbackQuestionsForSession(feedbackSessionName, courseId);
        } catch (EntityDoesNotExistException e) {
            Assumption.fail(""Session disappeared."");
        }
        if (fqa.questionNumber < 0) {
            fqa.questionNumber = questions.size() + 1;
        }
        adjustQuestionNumbers(questions.size() + 1, fqa.questionNumber, questions);
        createFeedbackQuestionNoIntegrityCheck(fqa, fqa.questionNumber);
    }

    /**
     * Used for creating initial questions only.
     * Does not check if feedback session exists.
     * Does not check if question number supplied is valid(does not check for clashes, or make adjustments)
     */
    public FeedbackQuestionAttributes createFeedbackQuestionNoIntegrityCheck(
            FeedbackQuestionAttributes fqa, int questionNumber) throws InvalidParametersException {
        fqa.questionNumber = questionNumber;
        fqa.removeIrrelevantVisibilityOptions();
        return fqDb.createFeedbackQuestionWithoutExistenceCheck(fqa);
    }

    public FeedbackQuestionAttributes copyFeedbackQuestion(
            String feedbackQuestionId, String feedbackSessionName, String courseId, String instructorEmail)
            throws InvalidParametersException {

        FeedbackQuestionAttributes question = getFeedbackQuestion(feedbackQuestionId);
        question.feedbackSessionName = feedbackSessionName;
        question.courseId = courseId;
        question.creatorEmail = instructorEmail;
        question.questionNumber = -1;
        question.setId(null);

        createFeedbackQuestion(question);

        return question;
    }

    /**
     * Gets a single question corresponding to the given parameters. <br><br>
     * <b>Note:</b><br>
     * *    This method should only be used if the question already exists in the<br>
     * datastore and has an ID already generated.
     */
    public FeedbackQuestionAttributes getFeedbackQuestion(String feedbackQuestionId) {
        return fqDb.getFeedbackQuestion(feedbackQuestionId);
    }

    /**
     * Gets a single question corresponding to the given parameters.
     */
    public FeedbackQuestionAttributes getFeedbackQuestion(
            String feedbackSessionName,
            String courseId,
            int questionNumber) {
        return fqDb.getFeedbackQuestion(feedbackSessionName,
                courseId, questionNumber);
    }

    /**
     * Gets a {@link List} of every FeedbackQuestion in the given session.
     */
    public List<FeedbackQuestionAttributes> getFeedbackQuestionsForSession(
            String feedbackSessionName, String courseId) throws EntityDoesNotExistException {

        if (fsLogic.getFeedbackSession(feedbackSessionName, courseId) == null) {
            throw new EntityDoesNotExistException(
                    ""Trying to get questions for a feedback session that does not exist."");
        }
        List<FeedbackQuestionAttributes> questions =
                fqDb.getFeedbackQuestionsForSession(feedbackSessionName, courseId);
        Collections.sort(questions);

        if (questions.size() > 1 && !areQuestionNumbersConsistent(questions)) {
            log.severe(courseId + "": "" + feedbackSessionName + "" has invalid question numbers"");
        }

        return questions;
    }

    // TODO can be removed once we are sure that question numbers will be consistent
    private boolean areQuestionNumbersConsistent(List<FeedbackQuestionAttributes> questions) {
        Set<Integer> questionNumbersInSession = new HashSet<>();
        for (FeedbackQuestionAttributes question : questions) {
            if (!questionNumbersInSession.add(question.questionNumber)) {
                return false;
            }
        }

        for (int i = 1; i <= questions.size(); i++) {
            if (!questionNumbersInSession.contains(i)) {
                return false;
            }
        }

        return true;
    }

    /**
     *  Gets a {@link List} of every FeedbackQuestion that the instructor can copy.
     */
    public List<FeedbackQuestionAttributes> getCopiableFeedbackQuestionsForInstructor(String googleId)
            throws EntityDoesNotExistException {

        List<FeedbackQuestionAttributes> copiableQuestions = new ArrayList<>();
        List<CourseAttributes> courses = coursesLogic.getCoursesForInstructor(googleId);
        for (CourseAttributes course : courses) {
            List<FeedbackSessionAttributes> sessions = fsLogic.getFeedbackSessionsForCourse(course.getId());
            for (FeedbackSessionAttributes session : sessions) {
                List<FeedbackQuestionAttributes> questions =
                        getFeedbackQuestionsForSession(session.getFeedbackSessionName(), course.getId());
                copiableQuestions.addAll(questions);
            }
        }
        Collections.sort(copiableQuestions, new Comparator<FeedbackQuestionAttributes>() {
            @Override
            public int compare(FeedbackQuestionAttributes q1, FeedbackQuestionAttributes q2) {
                int order = q1.courseId.compareTo(q2.courseId);
                if (order != 0) {
                    return order;
                }

                order = q1.feedbackSessionName.compareTo(q2.feedbackSessionName);
                if (order != 0) {
                    return order;
                }

                FeedbackQuestionDetails q1Details = q1.getQuestionDetails();
                FeedbackQuestionDetails q2Details = q2.getQuestionDetails();

                String q1DisplayName = q1Details.getQuestionTypeDisplayName();
                String q2DisplayName = q2Details.getQuestionTypeDisplayName();

                order = q1DisplayName.compareTo(q2DisplayName);
                if (order != 0) {
                    return order;
                }

                return q1Details.getQuestionText().compareTo(q2Details.getQuestionText());
            }
        });

        return copiableQuestions;
    }

    /**
     * Gets a {@code List} of all questions for the given session for an
     * instructor to view/submit.
     */
    public List<FeedbackQuestionAttributes> getFeedbackQuestionsForInstructor(
            String feedbackSessionName, String courseId, String userEmail)
            throws EntityDoesNotExistException {

        if (fsLogic.getFeedbackSession(feedbackSessionName, courseId) == null) {
            throw new EntityDoesNotExistException(
                    ""Trying to get questions for a feedback session that does not exist."");
        }

        if (fsLogic.isCreatorOfSession(feedbackSessionName, courseId, userEmail)) {
            return getFeedbackQuestionsForCreatorInstructor(feedbackSessionName, courseId);
        }

        List<FeedbackQuestionAttributes> questions = new ArrayList<>();

        InstructorAttributes instructor = instructorsLogic.getInstructorForEmail(courseId, userEmail);
        boolean isInstructor = instructor != null;

        if (isInstructor) {
            questions.addAll(fqDb.getFeedbackQuestionsForGiverType(
                            feedbackSessionName, courseId, FeedbackParticipantType.INSTRUCTORS));
        }
        Collections.sort(questions);
        return questions;
    }

    /**
     * Gets a {@code List} of all questions for the list of questions that an
     * instructor who is the creator of the course can view/submit.
     */
    public List<FeedbackQuestionAttributes> getFeedbackQuestionsForCreatorInstructor(
                                    String feedbackSessionName, String courseId)
                    throws EntityDoesNotExistException {

        FeedbackSessionAttributes fsa = fsLogic.getFeedbackSession(feedbackSessionName, courseId);
        if (fsa == null) {
            throw new EntityDoesNotExistException(
                    ""Trying to get questions for a feedback session that does not exist."");
        }

        return getFeedbackQuestionsForCreatorInstructor(fsa);
    }

    public List<FeedbackQuestionAttributes> getFeedbackQuestionsForCreatorInstructor(
                                    FeedbackSessionAttributes fsa) {

        List<FeedbackQuestionAttributes> questions = new ArrayList<>();

        String feedbackSessionName = fsa.getFeedbackSessionName();
        String courseId = fsa.getCourseId();

        questions.addAll(fqDb.getFeedbackQuestionsForGiverType(
                                       feedbackSessionName, courseId, FeedbackParticipantType.INSTRUCTORS));

        // Return all self (creator) questions
        questions.addAll(fqDb.getFeedbackQuestionsForGiverType(feedbackSessionName,
                courseId, FeedbackParticipantType.SELF));

        Collections.sort(questions);
        return questions;
    }

    /**
     * Filters through the given list of questions and returns a {@code List} of
     * questions that an instructor can view/submit.
     */
    public List<FeedbackQuestionAttributes> getFeedbackQuestionsForInstructor(
            List<FeedbackQuestionAttributes> allQuestions, boolean isCreator) {

        List<FeedbackQuestionAttributes> questions = new ArrayList<>();

        for (FeedbackQuestionAttributes question : allQuestions) {
            if (question.giverType == FeedbackParticipantType.INSTRUCTORS
                    || question.giverType == FeedbackParticipantType.SELF && isCreator) {
                questions.add(question);
            }
        }

        return questions;
    }

    /**
     * Gets a {@code List} of all questions for the given session that
     * students can view/submit.
     */
    public List<FeedbackQuestionAttributes> getFeedbackQuestionsForStudents(
            String feedbackSessionName, String courseId) {

        List<FeedbackQuestionAttributes> questions = new ArrayList<>();

        questions.addAll(
                fqDb.getFeedbackQuestionsForGiverType(
                        feedbackSessionName, courseId, FeedbackParticipantType.STUDENTS));
        questions.addAll(
                fqDb.getFeedbackQuestionsForGiverType(
                        feedbackSessionName, courseId, FeedbackParticipantType.TEAMS));

        Collections.sort(questions);
        return questions;
    }

    /**
     * Filters through the given list of questions and returns a {@code List} of
     * questions that students can view/submit.
     */
    public List<FeedbackQuestionAttributes> getFeedbackQuestionsForStudents(
            List<FeedbackQuestionAttributes> allQuestions) {

        List<FeedbackQuestionAttributes> questions = new ArrayList<>();

        for (FeedbackQuestionAttributes question : allQuestions) {
            if (question.giverType == FeedbackParticipantType.STUDENTS
                    || question.giverType == FeedbackParticipantType.TEAMS) {
                questions.add(question);
            }
        }

        return questions;
    }

    public Map<String, String> getRecipientsForQuestion(FeedbackQuestionAttributes question, String giver)
            throws EntityDoesNotExistException {

        InstructorAttributes instructorGiver = instructorsLogic.getInstructorForEmail(question.courseId, giver);
        StudentAttributes studentGiver = studentsLogic.getStudentForEmail(question.courseId, giver);

        return getRecipientsForQuestion(question, giver, instructorGiver, studentGiver);
    }

    public Map<String, String> getRecipientsForQuestion(
            FeedbackQuestionAttributes question, String giver,
            InstructorAttributes instructorGiver, StudentAttributes studentGiver)
                    throws EntityDoesNotExistException {

        Map<String, String> recipients = new HashMap<>();

        FeedbackParticipantType recipientType = question.recipientType;

        String giverTeam = getGiverTeam(giver, instructorGiver, studentGiver);

        switch (recipientType) {
        case SELF:
            if (question.giverType == FeedbackParticipantType.TEAMS) {
                recipients.put(studentGiver.team, studentGiver.team);
            } else {
                recipients.put(giver, Const.USER_NAME_FOR_SELF);
            }
            break;
        case STUDENTS:
            List<StudentAttributes> studentsInCourse = studentsLogic.getStudentsForCourse(question.courseId);
            for (StudentAttributes student : studentsInCourse) {
                // Ensure student does not evaluate himself
                if (!giver.equals(student.email)) {
                    recipients.put(student.email, student.name);
                }
            }
            break;
        case INSTRUCTORS:
            List<InstructorAttributes> instructorsInCourse = instructorsLogic.getInstructorsForCourse(question.courseId);
            for (InstructorAttributes instr : instructorsInCourse) {
                // Ensure instructor does not evaluate himself
                if (!giver.equals(instr.email)) {
                    recipients.put(instr.email, instr.name);
                }
            }
            break;
        case TEAMS:
            List<TeamDetailsBundle> teams = coursesLogic.getTeamsForCourse(question.courseId);
            for (TeamDetailsBundle team : teams) {
                // Ensure student('s team) does not evaluate own team.
                if (!giverTeam.equals(team.name)) {
                    // recipientEmail doubles as team name in this case.
                    recipients.put(team.name, team.name);
                }
            }
            break;
        case OWN_TEAM:
            recipients.put(giverTeam, giverTeam);
            break;
        case OWN_TEAM_MEMBERS:
            List<StudentAttributes> students = studentsLogic.getStudentsForTeam(giverTeam, question.courseId);
            for (StudentAttributes student : students) {
                if (!student.email.equals(giver)) {
                    recipients.put(student.email, student.name);
                }
            }
            break;
        case OWN_TEAM_MEMBERS_INCLUDING_SELF:
            List<StudentAttributes> teamMembers = studentsLogic.getStudentsForTeam(giverTeam, question.courseId);
            for (StudentAttributes student : teamMembers) {
                // accepts self feedback too
                recipients.put(student.email, student.name);
            }
            break;
        case NONE:
            recipients.put(Const.GENERAL_QUESTION, Const.GENERAL_QUESTION);
            break;
        default:
            break;
        }
        return recipients;
    }

    private String getGiverTeam(String defaultTeam, InstructorAttributes instructorGiver,
            StudentAttributes studentGiver) {
        String giverTeam = defaultTeam;
        boolean isStudentGiver = studentGiver != null;
        boolean isInstructorGiver = instructorGiver != null;
        if (isStudentGiver) {
            giverTeam = studentGiver.team;
        } else if (isInstructorGiver) {
            giverTeam = Const.USER_TEAM_FOR_INSTRUCTOR;
        }
        return giverTeam;
    }

    public boolean areThereResponsesForQuestion(String feedbackQuestionId) {
        return !frLogic.getFeedbackResponsesForQuestionWithinRange(feedbackQuestionId, 1)
                       .isEmpty();
    }

    public boolean isQuestionFullyAnsweredByUser(FeedbackQuestionAttributes question, String email)
            throws EntityDoesNotExistException {

        int numberOfResponsesGiven =
                frLogic.getFeedbackResponsesFromGiverForQuestion(question.getId(), email).size();
        int numberOfResponsesNeeded =
                question.numberOfEntitiesToGiveFeedbackTo;

        if (numberOfResponsesNeeded == Const.MAX_POSSIBLE_RECIPIENTS) {
            numberOfResponsesNeeded = getRecipientsForQuestion(question, email).size();
        }

        return numberOfResponsesGiven >= numberOfResponsesNeeded;
    }

    /**
     * Checks if a question has been fully answered by a team.
     * @return {@code True} if there are no more recipients to give feedback to for the given
     * {@code teamName}. {@code False} if not.
     */
    public boolean isQuestionFullyAnsweredByTeam(FeedbackQuestionAttributes question,
            String teamName) throws EntityDoesNotExistException {

        List<StudentAttributes> studentsInTeam =
                studentsLogic.getStudentsForTeam(question.courseId, teamName);

        int numberOfPendingResponses =
                question.numberOfEntitiesToGiveFeedbackTo;

        if (numberOfPendingResponses == Const.MAX_POSSIBLE_RECIPIENTS) {
            numberOfPendingResponses = getRecipientsForQuestion(question, teamName).size();
        }

        for (StudentAttributes student : studentsInTeam) {
            List<FeedbackResponseAttributes> responses =
                    frLogic.getFeedbackResponsesFromGiverForQuestion(question.getId(), student.email);
            for (FeedbackResponseAttributes response : responses) {
                if (response.giver.equals(student.email)) {
                    numberOfPendingResponses -= 1;
                }
            }
        }
        return numberOfPendingResponses <= 0;
    }

    /**
     * Updates the feedback question number, shifts other questions up/down
     * depending on the change.
     */
    public void updateFeedbackQuestionNumber(FeedbackQuestionAttributes newQuestion)
        throws InvalidParametersException, EntityDoesNotExistException {

        FeedbackQuestionAttributes oldQuestion =
                fqDb.getFeedbackQuestion(newQuestion.getId());

        if (oldQuestion == null) {
            throw new EntityDoesNotExistException(""Trying to update a feedback question that does not exist."");
        }

        int oldQuestionNumber = oldQuestion.questionNumber;
        int newQuestionNumber = newQuestion.questionNumber;
        String feedbackSessionName = oldQuestion.feedbackSessionName;
        String courseId = oldQuestion.courseId;
        List<FeedbackQuestionAttributes> questions = null;

        try {
            questions = getFeedbackQuestionsForSession(feedbackSessionName, courseId);
        } catch (EntityDoesNotExistException e) {
            Assumption.fail(""Session disappeared."");
        }

        adjustQuestionNumbers(oldQuestionNumber, newQuestionNumber, questions);
        updateFeedbackQuestion(newQuestion);
    }

    /**
     * Adjust questions between the old and new number,
     * if the new number is smaller, then shift up (increase qn#) all questions in between.
     * if the new number is bigger, then shift down(decrease qn#) all questions in between.
     */
    private void adjustQuestionNumbers(int oldQuestionNumber,
            int newQuestionNumber, List<FeedbackQuestionAttributes> questions) {
        if (oldQuestionNumber > newQuestionNumber && oldQuestionNumber >= 1) {
            for (int i = oldQuestionNumber - 1; i >= newQuestionNumber; i--) {
                FeedbackQuestionAttributes question = questions.get(i - 1);
                question.questionNumber += 1;
                updateFeedbackQuestionWithoutResponseRateUpdate(question);
            }
        } else if (oldQuestionNumber < newQuestionNumber && oldQuestionNumber < questions.size()) {
            for (int i = oldQuestionNumber + 1; i <= newQuestionNumber; i++) {
                FeedbackQuestionAttributes question = questions.get(i - 1);
                question.questionNumber -= 1;
                updateFeedbackQuestionWithoutResponseRateUpdate(question);
            }
        }
    }

    /**
     * Updates the feedback question. For each attribute in
     * {@code newAttributes}, the existing value is preserved if the attribute
     * is null (due to 'keep existing' policy). Existing responses for the
     * question are automatically deleted if giverType/recipientType are
     * changed, or if the response visibility is increased. However, the
     * response rate of the feedback session is not updated.<br>
     * Precondition: <br>
     * {@code newAttributes} is not {@code null}
     */
    private void updateFeedbackQuestionWithoutResponseRateUpdate(FeedbackQuestionAttributes newAttributes) {
        try {
            updateFeedbackQuestion(newAttributes, false);
        } catch (InvalidParametersException e) {
            Assumption.fail(""Invalid question."");
        } catch (EntityDoesNotExistException e) {
            Assumption.fail(""Question disappeared."");
        }
    }

    /**
     * Updates the feedback question. For each attribute in
     * {@code newAttributes}, the existing value is preserved if the attribute
     * is null (due to 'keep existing' policy). Existing responses for the
     * question are automatically deleted and the response rate of the feedback
     * session is updated if giverType/recipientType are changed, or if the
     * response visibility is increased.<br>
     * Precondition: <br>
     * {@code newAttributes} is not {@code null}
     */
    public void updateFeedbackQuestion(FeedbackQuestionAttributes newAttributes)
            throws InvalidParametersException, EntityDoesNotExistException {

        updateFeedbackQuestion(newAttributes, true);
    }

    private void updateFeedbackQuestion(FeedbackQuestionAttributes newAttributes, boolean hasResponseRateUpdate)
            throws InvalidParametersException, EntityDoesNotExistException {
        FeedbackQuestionAttributes oldQuestion = null;
        if (newAttributes.getId() == null) {
            oldQuestion = fqDb.getFeedbackQuestion(newAttributes.feedbackSessionName,
                    newAttributes.courseId, newAttributes.questionNumber);
        } else {
            oldQuestion = fqDb.getFeedbackQuestion(newAttributes.getId());
        }

        if (oldQuestion == null) {
            throw new EntityDoesNotExistException(
                    ""Trying to update a feedback question that does not exist."");
        }

        if (oldQuestion.areResponseDeletionsRequiredForChanges(newAttributes)) {
            frLogic.deleteFeedbackResponsesForQuestionAndCascade(oldQuestion.getId(), hasResponseRateUpdate);
        }

        oldQuestion.updateValues(newAttributes);
        newAttributes.removeIrrelevantVisibilityOptions();
        fqDb.updateFeedbackQuestion(newAttributes);
    }

    public void deleteFeedbackQuestionsForSession(String feedbackSessionName, String courseId)
            throws EntityDoesNotExistException {
        List<FeedbackQuestionAttributes> questions =
                getFeedbackQuestionsForSession(feedbackSessionName, courseId);

        for (FeedbackQuestionAttributes question : questions) {
            deleteFeedbackQuestionCascadeWithoutResponseRateUpdate(question.getId());
        }

    }

    /**
     * Deletes a question by its auto-generated ID. <br>
     * Cascade the deletion of all existing responses for the question and then
     * shifts larger question numbers down by one to preserve number order. The
     * response rate of the feedback session is not updated.
     *
     * <p>Silently fails if question does not exist.
     */
    private void deleteFeedbackQuestionCascadeWithoutResponseRateUpdate(String feedbackQuestionId) {
        FeedbackQuestionAttributes questionToDeleteById =
                        getFeedbackQuestion(feedbackQuestionId);

        if (questionToDeleteById == null) {
            log.warning(""Trying to delete question that does not exist: "" + feedbackQuestionId);
        } else {
            deleteFeedbackQuestionCascade(questionToDeleteById.feedbackSessionName,
                                            questionToDeleteById.courseId,
                                            questionToDeleteById.questionNumber, false);
        }
    }

    /**
     * Deletes a question by its auto-generated ID. <br>
     * Cascade the deletion of all existing responses for the question and then
     * shifts larger question numbers down by one to preserve number order. The
     * response rate of the feedback session is updated accordingly.
     *
     * <p>Silently fail if question does not exist.
     */
    public void deleteFeedbackQuestionCascade(String feedbackQuestionId) {
        FeedbackQuestionAttributes questionToDeleteById =
                        getFeedbackQuestion(feedbackQuestionId);

        if (questionToDeleteById == null) {
            log.warning(""Trying to delete question that does not exist: "" + feedbackQuestionId);
        } else {
            deleteFeedbackQuestionCascade(questionToDeleteById.feedbackSessionName,
                                            questionToDeleteById.courseId,
                                            questionToDeleteById.questionNumber, true);
        }
    }

    /**
     * Deletes all feedback questions in all sessions of the course specified. This is
     * a non-cascade delete. The responses to the questions and the comments of these responses
     * should be handled.
     *
     */
    public void deleteFeedbackQuestionsForCourse(String courseId) {
        fqDb.deleteFeedbackQuestionsForCourse(courseId);
    }

    /**
     * Deletes a question.<br> Question is identified by it's question number, and
     * the feedback session name and course ID of the question.<br>
     * Can be used when the question ID is unknown. <br>
     * Cascade the deletion of all existing responses for the question and then
     * shifts larger question numbers down by one to preserve number order.
     */
    private void deleteFeedbackQuestionCascade(
            String feedbackSessionName, String courseId, int questionNumber, boolean hasResponseRateUpdate) {

        FeedbackQuestionAttributes questionToDelete =
                getFeedbackQuestion(feedbackSessionName, courseId, questionNumber);

        if (questionToDelete == null) {
            return; // Silently fail if question does not exist.
        }
        // Cascade delete responses for question.
        frLogic.deleteFeedbackResponsesForQuestionAndCascade(questionToDelete.getId(), hasResponseRateUpdate);

        List<FeedbackQuestionAttributes> questionsToShiftQnNumber = null;
        try {
            questionsToShiftQnNumber = getFeedbackQuestionsForSession(feedbackSessionName, courseId);
        } catch (EntityDoesNotExistException e) {
            Assumption.fail(""Session disappeared."");
        }

        fqDb.deleteEntity(questionToDelete);

        if (questionToDelete.questionNumber < questionsToShiftQnNumber.size()) {
            shiftQuestionNumbersDown(questionToDelete.questionNumber, questionsToShiftQnNumber);
        }
    }

    // Shifts all question numbers after questionNumberToShiftFrom down by one.
    private void shiftQuestionNumbersDown(int questionNumberToShiftFrom,
            List<FeedbackQuestionAttributes> questionsToShift) {
        for (FeedbackQuestionAttributes question : questionsToShift) {
            if (question.questionNumber > questionNumberToShiftFrom) {
                question.questionNumber -= 1;
                updateFeedbackQuestionWithoutResponseRateUpdate(question);
            }
        }
    }

    /*
     * Removes questions with no recipients.
     */
    public List<FeedbackQuestionAttributes> getQuestionsWithRecipients(
            List<FeedbackQuestionAttributes> questions, String giver)
            throws EntityDoesNotExistException {
        List<FeedbackQuestionAttributes> questionsWithRecipients = new ArrayList<>();
        for (FeedbackQuestionAttributes question : questions) {
            int numRecipients = question.numberOfEntitiesToGiveFeedbackTo;
            if (numRecipients == Const.MAX_POSSIBLE_RECIPIENTS) {
                numRecipients = this.getRecipientsForQuestion(question, giver)
                        .size();
            }
            if (numRecipients > 0) {
                questionsWithRecipients.add(question);
            }
        }
        return questionsWithRecipients;
    }

}
"
FeedbackResponseCommentsLogic.java,logic-core,"package teammates.logic.core;

import java.util.Date;
import java.util.List;
import java.util.Set;

import teammates.common.datatransfer.CourseRoster;
import teammates.common.datatransfer.FeedbackParticipantType;
import teammates.common.datatransfer.FeedbackResponseCommentSearchResultBundle;
import teammates.common.datatransfer.UserRole;
import teammates.common.datatransfer.attributes.FeedbackQuestionAttributes;
import teammates.common.datatransfer.attributes.FeedbackResponseAttributes;
import teammates.common.datatransfer.attributes.FeedbackResponseCommentAttributes;
import teammates.common.datatransfer.attributes.FeedbackSessionAttributes;
import teammates.common.datatransfer.attributes.InstructorAttributes;
import teammates.common.datatransfer.attributes.StudentAttributes;
import teammates.common.exception.EntityAlreadyExistsException;
import teammates.common.exception.EntityDoesNotExistException;
import teammates.common.exception.InvalidParametersException;
import teammates.common.util.Assumption;
import teammates.storage.api.FeedbackResponseCommentsDb;

/**
 * Handles operations related to feedback response comments.
 *
 * @see FeedbackResponseCommentAttributes
 * @see FeedbackResponseCommentsDb
 */
public final class FeedbackResponseCommentsLogic {

    private static FeedbackResponseCommentsLogic instance = new FeedbackResponseCommentsLogic();

    private static final FeedbackResponseCommentsDb frcDb = new FeedbackResponseCommentsDb();

    private static final CoursesLogic coursesLogic = CoursesLogic.inst();
    private static final FeedbackResponsesLogic frLogic = FeedbackResponsesLogic.inst();
    private static final FeedbackSessionsLogic fsLogic = FeedbackSessionsLogic.inst();
    private static final InstructorsLogic instructorsLogic = InstructorsLogic.inst();

    private FeedbackResponseCommentsLogic() {
        // prevent initialization
    }

    public static FeedbackResponseCommentsLogic inst() {
        return instance;
    }

    public FeedbackResponseCommentAttributes createFeedbackResponseComment(FeedbackResponseCommentAttributes frComment)
            throws InvalidParametersException, EntityDoesNotExistException {
        verifyIsCoursePresent(frComment.courseId);
        verifyIsInstructorOfCourse(frComment.courseId, frComment.giverEmail);
        verifyIsFeedbackSessionOfCourse(frComment.courseId, frComment.feedbackSessionName);

        try {
            return frcDb.createFeedbackResponseComment(frComment);
        } catch (EntityAlreadyExistsException e) {
            try {

                FeedbackResponseCommentAttributes existingComment =
                                  frcDb.getFeedbackResponseComment(frComment.feedbackResponseId, frComment.giverEmail,
                                                                   frComment.createdAt);
                if (existingComment == null) {
                    existingComment = frcDb.getFeedbackResponseComment(frComment.courseId, frComment.createdAt,
                                                                       frComment.giverEmail);
                }
                frComment.setId(existingComment.getId());

                return frcDb.updateFeedbackResponseComment(frComment);
            } catch (Exception ex) {
                Assumption.fail();
                return null;
            }
        }
    }

    public FeedbackResponseCommentAttributes getFeedbackResponseComment(Long feedbackResponseCommentId) {
        return frcDb.getFeedbackResponseComment(feedbackResponseCommentId);
    }

    public FeedbackResponseCommentAttributes getFeedbackResponseComment(String responseId, String giverEmail,
                                                                        Date creationDate) {
        return frcDb.getFeedbackResponseComment(responseId, giverEmail, creationDate);
    }

    public List<FeedbackResponseCommentAttributes> getFeedbackResponseCommentForResponse(String feedbackResponseId) {
        return frcDb.getFeedbackResponseCommentsForResponse(feedbackResponseId);
    }

    public List<FeedbackResponseCommentAttributes> getFeedbackResponseCommentForSession(String courseId,
                                                                                        String feedbackSessionName) {
        return frcDb.getFeedbackResponseCommentsForSession(courseId, feedbackSessionName);
    }

    public List<FeedbackResponseCommentAttributes> getFeedbackResponseCommentForSessionInSection(String courseId,
                                                           String feedbackSessionName, String section) {
        if (section == null) {
            return getFeedbackResponseCommentForSession(courseId, feedbackSessionName);
        }
        return frcDb.getFeedbackResponseCommentsForSessionInSection(courseId, feedbackSessionName, section);
    }

    public void updateFeedbackResponseCommentsForChangingResponseId(
            String oldResponseId, String newResponseId)
            throws InvalidParametersException, EntityDoesNotExistException {
        List<FeedbackResponseCommentAttributes> responseComments =
                getFeedbackResponseCommentForResponse(oldResponseId);
        for (FeedbackResponseCommentAttributes responseComment : responseComments) {
            responseComment.feedbackResponseId = newResponseId;
            updateFeedbackResponseComment(responseComment);
        }
    }

    /*
     * Updates all email fields of feedback response comments with the new email
     */
    public void updateFeedbackResponseCommentsEmails(String courseId, String oldEmail, String updatedEmail) {
        frcDb.updateGiverEmailOfFeedbackResponseComments(courseId, oldEmail, updatedEmail);
        frcDb.updateLastEditorEmailOfFeedbackResponseComments(courseId, oldEmail, updatedEmail);
    }

    // right now this method only updates comment's giverSection and receiverSection for a given response
    public void updateFeedbackResponseCommentsForResponse(String feedbackResponseId)
            throws InvalidParametersException, EntityDoesNotExistException {
        List<FeedbackResponseCommentAttributes> comments = getFeedbackResponseCommentForResponse(feedbackResponseId);
        FeedbackResponseAttributes response = frLogic.getFeedbackResponse(feedbackResponseId);
        for (FeedbackResponseCommentAttributes comment : comments) {
            comment.giverSection = response.giverSection;
            comment.receiverSection = response.recipientSection;
            frcDb.updateFeedbackResponseComment(comment);
        }
    }

    public FeedbackResponseCommentAttributes updateFeedbackResponseComment(
                                                     FeedbackResponseCommentAttributes feedbackResponseComment)
                                                     throws InvalidParametersException, EntityDoesNotExistException {
        return frcDb.updateFeedbackResponseComment(feedbackResponseComment);
    }

    /**
     * Creates or updates document for the given comment.
     */
    public void putDocument(FeedbackResponseCommentAttributes comment) {
        frcDb.putDocument(comment);
    }

    /**
     * Creates or updates documents for the given comments.
     */
    public void putDocuments(List<FeedbackResponseCommentAttributes> comments) {
        frcDb.putDocuments(comments);
    }

    public List<FeedbackResponseCommentAttributes> getFeedbackResponseCommentsForGiver(String courseId,
                                                                                       String giverEmail) {
        return frcDb.getFeedbackResponseCommentForGiver(courseId, giverEmail);
    }

    public FeedbackResponseCommentSearchResultBundle searchFeedbackResponseComments(String queryString,
                                                             List<InstructorAttributes> instructors) {
        return frcDb.search(queryString, instructors);
    }

    public void deleteFeedbackResponseCommentsForCourse(String courseId) {
        frcDb.deleteFeedbackResponseCommentsForCourse(courseId);
    }

    public void deleteFeedbackResponseCommentsForResponse(String responseId) {
        frcDb.deleteFeedbackResponseCommentsForResponse(responseId);
    }

    public void deleteFeedbackResponseComment(FeedbackResponseCommentAttributes feedbackResponseComment) {
        frcDb.deleteEntity(feedbackResponseComment);
    }

    /**
     * Removes document for the given comment.
     */
    public void deleteDocument(FeedbackResponseCommentAttributes commentToDelete) {
        frcDb.deleteDocument(commentToDelete);
    }

    /**
     * Returns true if the comment's giver name is visible to certain user.
     */
    public boolean isNameVisibleToUser(FeedbackResponseCommentAttributes comment, FeedbackResponseAttributes response,
                                   String userEmail, CourseRoster roster) {
        List<FeedbackParticipantType> showNameTo = comment.showGiverNameTo;
        //in the old ver, name is always visible
        if (showNameTo == null || comment.isVisibilityFollowingFeedbackQuestion) {
            return true;
        }

        //comment giver can always see
        if (userEmail.equals(comment.giverEmail)) {
            return true;
        }

        return isFeedbackParticipantNameVisibleToUser(response, userEmail, roster, showNameTo);
    }

    private boolean isFeedbackParticipantNameVisibleToUser(FeedbackResponseAttributes response,
            String userEmail, CourseRoster roster, List<FeedbackParticipantType> showNameTo) {
        String responseGiverTeam = ""giverTeam"";
        if (roster.getStudentForEmail(response.giver) != null) {
            responseGiverTeam = roster.getStudentForEmail(response.giver).team;
        }
        String responseRecipientTeam = ""recipientTeam"";
        if (roster.getStudentForEmail(response.recipient) != null) {
            responseRecipientTeam = roster.getStudentForEmail(response.recipient).team;
        }
        String currentUserTeam = ""currentUserTeam"";
        if (roster.getStudentForEmail(userEmail) != null) {
            currentUserTeam = roster.getStudentForEmail(userEmail).team;
        }
        for (FeedbackParticipantType type : showNameTo) {
            switch (type) {
            case INSTRUCTORS:
                if (roster.getInstructorForEmail(userEmail) != null) {
                    return true;
                }
                break;
            case OWN_TEAM_MEMBERS:
                if (responseGiverTeam.equals(currentUserTeam)) {
                    return true;
                }
                break;
            case RECEIVER:
                if (userEmail.equals(response.recipient)) {
                    return true;
                }
                break;
            case RECEIVER_TEAM_MEMBERS:
                if (responseRecipientTeam.equals(currentUserTeam)) {
                    return true;
                }
                break;
            case STUDENTS:
                if (roster.getStudentForEmail(userEmail) != null) {
                    return true;
                }
                break;
            case GIVER:
                if (userEmail.equals(response.giver)) {
                    return true;
                }
                break;
            default:
                break;
            }
        }
        return false;
    }

    /**
     * Verifies whether the comment is visible to certain user.
     * @return true/false
     */
    public boolean isResponseCommentVisibleForUser(String userEmail, UserRole role,
            StudentAttributes student, Set<String> studentsEmailInTeam, FeedbackResponseAttributes response,
            FeedbackQuestionAttributes relatedQuestion, FeedbackResponseCommentAttributes relatedComment) {

        if (response == null || relatedQuestion == null) {
            return false;
        }

        boolean isVisibilityFollowingFeedbackQuestion = relatedComment.isVisibilityFollowingFeedbackQuestion;
        boolean isVisibleToGiver = isVisibilityFollowingFeedbackQuestion
                                 || relatedComment.isVisibleTo(FeedbackParticipantType.GIVER);

        boolean isUserInstructor = role == UserRole.INSTRUCTOR;
        boolean isUserStudent = role == UserRole.STUDENT;

        boolean isVisibleToUser = isVisibleToUser(userEmail, response, relatedQuestion, relatedComment,
                isVisibleToGiver, isUserInstructor, isUserStudent);

        boolean isVisibleToUserTeam = isVisibleToUserTeam(student, studentsEmailInTeam, response,
                relatedQuestion, relatedComment, isUserStudent);

        return isVisibleToUser || isVisibleToUserTeam;
    }

    private boolean isVisibleToUserTeam(StudentAttributes student, Set<String> studentsEmailInTeam,
            FeedbackResponseAttributes response, FeedbackQuestionAttributes relatedQuestion,
            FeedbackResponseCommentAttributes relatedComment, boolean isUserStudent) {

        boolean isUserInResponseRecipientTeamAndRelatedResponseCommentVisibleToRecipients =
                isUserStudent
                && relatedQuestion.recipientType == FeedbackParticipantType.TEAMS
                && isResponseCommentVisibleTo(relatedQuestion, relatedComment,
                                              FeedbackParticipantType.RECEIVER)
                && response.recipient.equals(student.team);

        boolean isUserInResponseGiverTeamAndRelatedResponseCommentVisibleToGiversTeamMembers =
                (relatedQuestion.giverType == FeedbackParticipantType.TEAMS
                || isResponseCommentVisibleTo(relatedQuestion, relatedComment,
                                              FeedbackParticipantType.OWN_TEAM_MEMBERS))
                && studentsEmailInTeam.contains(response.giver);

        boolean isUserInResponseRecipientTeamAndRelatedResponseCommentVisibleToRecipientsTeamMembers =
                isResponseCommentVisibleTo(relatedQuestion, relatedComment,
                                           FeedbackParticipantType.RECEIVER_TEAM_MEMBERS)
                && studentsEmailInTeam.contains(response.recipient);

        return isUserInResponseRecipientTeamAndRelatedResponseCommentVisibleToRecipients
                || isUserInResponseGiverTeamAndRelatedResponseCommentVisibleToGiversTeamMembers
                || isUserInResponseRecipientTeamAndRelatedResponseCommentVisibleToRecipientsTeamMembers;
    }

    private boolean isVisibleToUser(String userEmail, FeedbackResponseAttributes response,
            FeedbackQuestionAttributes relatedQuestion, FeedbackResponseCommentAttributes relatedComment,
            boolean isVisibleToGiver, boolean isUserInstructor, boolean isUserStudent) {

        boolean isUserInstructorAndRelatedResponseCommentVisibleToInstructors =
                isUserInstructor && isResponseCommentVisibleTo(relatedQuestion, relatedComment,
                                                               FeedbackParticipantType.INSTRUCTORS);

        boolean isUserResponseRecipientAndRelatedResponseCommentVisibleToRecipients =
                response.recipient.equals(userEmail) && isResponseCommentVisibleTo(relatedQuestion,
                        relatedComment, FeedbackParticipantType.RECEIVER);

        boolean isUserResponseGiverAndRelatedResponseCommentVisibleToGivers =
                response.giver.equals(userEmail) && isVisibleToGiver;

        boolean isUserRelatedResponseCommentGiver = relatedComment.giverEmail.equals(userEmail);

        boolean isUserStudentAndRelatedResponseCommentVisibleToStudents =
                isUserStudent && isResponseCommentVisibleTo(relatedQuestion,
                        relatedComment, FeedbackParticipantType.STUDENTS);

        return isUserInstructorAndRelatedResponseCommentVisibleToInstructors
                || isUserResponseRecipientAndRelatedResponseCommentVisibleToRecipients
                || isUserResponseGiverAndRelatedResponseCommentVisibleToGivers
                || isUserRelatedResponseCommentGiver
                || isUserStudentAndRelatedResponseCommentVisibleToStudents;
    }

    private boolean isResponseCommentVisibleTo(FeedbackQuestionAttributes relatedQuestion,
                                               FeedbackResponseCommentAttributes relatedComment,
                                               FeedbackParticipantType viewerType) {
        boolean isVisibilityFollowingFeedbackQuestion = relatedComment.isVisibilityFollowingFeedbackQuestion;
        return isVisibilityFollowingFeedbackQuestion
                ? relatedQuestion.isResponseVisibleTo(viewerType)
                : relatedComment.isVisibleTo(viewerType);
    }

    private void verifyIsCoursePresent(String courseId) throws EntityDoesNotExistException {
        if (!coursesLogic.isCoursePresent(courseId)) {
            throw new EntityDoesNotExistException(
                    ""Trying to create feedback response comments for a course that does not exist."");
        }
    }

    private void verifyIsInstructorOfCourse(String courseId, String email) throws EntityDoesNotExistException {
        InstructorAttributes instructor = instructorsLogic.getInstructorForEmail(courseId, email);
        if (instructor == null) {
            throw new EntityDoesNotExistException(""User "" + email + "" is not a registered instructor for course ""
                                                + courseId + ""."");
        }
    }

    private void verifyIsFeedbackSessionOfCourse(String courseId, String feedbackSessionName)
            throws EntityDoesNotExistException {
        FeedbackSessionAttributes session = fsLogic.getFeedbackSession(feedbackSessionName, courseId);
        if (session == null) {
            throw new EntityDoesNotExistException(""Feedback session "" + feedbackSessionName
                                                + "" is not a session for course "" + courseId + ""."");
        }
    }

    @SuppressWarnings(""deprecation"")
    public List<FeedbackResponseCommentAttributes> getAllFeedbackResponseComments() {
        return frcDb.getAllFeedbackResponseComments();
    }
}
"
FeedbackResponsesLogic.java,logic-core,"package teammates.logic.core;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import teammates.common.datatransfer.CourseRoster;
import teammates.common.datatransfer.FeedbackParticipantType;
import teammates.common.datatransfer.StudentEnrollDetails;
import teammates.common.datatransfer.UserRole;
import teammates.common.datatransfer.attributes.FeedbackQuestionAttributes;
import teammates.common.datatransfer.attributes.FeedbackResponseAttributes;
import teammates.common.datatransfer.attributes.StudentAttributes;
import teammates.common.exception.EntityAlreadyExistsException;
import teammates.common.exception.EntityDoesNotExistException;
import teammates.common.exception.InvalidParametersException;
import teammates.common.util.Assumption;
import teammates.common.util.Logger;
import teammates.storage.api.FeedbackResponsesDb;
import teammates.storage.entity.FeedbackResponse;

/**
 * Handles operations related to feedback responses.
 *
 * @see FeedbackResponseAttributes
 * @see FeedbackResponsesDb
 */
public final class FeedbackResponsesLogic {

    private static final Logger log = Logger.getLogger();

    private static FeedbackResponsesLogic instance = new FeedbackResponsesLogic();

    private static final FeedbackResponsesDb frDb = new FeedbackResponsesDb();

    private static final FeedbackQuestionsLogic fqLogic = FeedbackQuestionsLogic.inst();
    private static final FeedbackResponseCommentsLogic frcLogic = FeedbackResponseCommentsLogic.inst();
    private static final FeedbackSessionsLogic fsLogic = FeedbackSessionsLogic.inst();
    private static final StudentsLogic studentsLogic = StudentsLogic.inst();

    private FeedbackResponsesLogic() {
        // prevent initialization
    }

    public static FeedbackResponsesLogic inst() {
        return instance;
    }

    public void createFeedbackResponse(FeedbackResponseAttributes fra)
            throws InvalidParametersException, EntityDoesNotExistException {
        try {
            frDb.createEntity(fra);
        } catch (EntityAlreadyExistsException eaee) {
            FeedbackResponse existingResponse = frDb.getFeedbackResponseEntityOptimized(fra);
            try {
                updateFeedbackResponse(fra, existingResponse);
            } catch (EntityAlreadyExistsException entityAlreadyExistsException) {
                Assumption.fail();
            }
        }
    }

    public void createFeedbackResponses(List<FeedbackResponseAttributes> fra)
            throws InvalidParametersException {
        frDb.createEntities(fra);
    }

    public FeedbackResponseAttributes getFeedbackResponse(
            String feedbackResponseId) {
        return frDb.getFeedbackResponse(feedbackResponseId);
    }

    public FeedbackResponseAttributes getFeedbackResponse(
            String feedbackQuestionId, String giverEmail, String recipient) {
        return frDb.getFeedbackResponse(feedbackQuestionId, giverEmail, recipient);
    }

    public List<FeedbackResponseAttributes> getFeedbackResponsesForSession(
            String feedbackSessionName, String courseId) {
        return frDb.getFeedbackResponsesForSession(feedbackSessionName, courseId);
    }

    public List<FeedbackResponseAttributes> getFeedbackResponsesForSessionInSection(
            String feedbackSessionName, String courseId, String section) {
        if (section == null) {
            return getFeedbackResponsesForSession(feedbackSessionName, courseId);
        }
        return frDb.getFeedbackResponsesForSessionInSection(feedbackSessionName, courseId, section);
    }

    public List<FeedbackResponseAttributes> getFeedbackResponsesForSessionFromSection(
            String feedbackSessionName, String courseId, String section) {
        if (section == null) {
            return getFeedbackResponsesForSession(feedbackSessionName, courseId);
        }
        return frDb.getFeedbackResponsesForSessionFromSection(feedbackSessionName, courseId, section);
    }

    public List<FeedbackResponseAttributes> getFeedbackResponsesForSessionToSection(
            String feedbackSessionName, String courseId, String section) {
        if (section == null) {
            return getFeedbackResponsesForSession(feedbackSessionName, courseId);
        }
        return frDb.getFeedbackResponsesForSessionToSection(feedbackSessionName, courseId, section);
    }

    public List<FeedbackResponseAttributes> getFeedbackResponsesForSessionWithinRange(
            String feedbackSessionName, String courseId, int range) {
        return frDb.getFeedbackResponsesForSessionWithinRange(feedbackSessionName, courseId, range);
    }

    public List<FeedbackResponseAttributes> getFeedbackResponsesForSessionInSectionWithinRange(
            String feedbackSessionName, String courseId, String section, int range) {
        if (section == null) {
            return getFeedbackResponsesForSessionWithinRange(feedbackSessionName, courseId, range);
        }
        return frDb.getFeedbackResponsesForSessionInSectionWithinRange(feedbackSessionName, courseId, section, range);
    }

    public List<FeedbackResponseAttributes> getFeedbackResponsesForSessionFromSectionWithinRange(
            String feedbackSessionName, String courseId, String section, int range) {
        if (section == null) {
            return getFeedbackResponsesForSessionWithinRange(feedbackSessionName, courseId, range);
        }
        return frDb.getFeedbackResponsesForSessionFromSectionWithinRange(feedbackSessionName, courseId, section, range);
    }

    public List<FeedbackResponseAttributes> getFeedbackResponsesForSessionToSectionWithinRange(
            String feedbackSessionName, String courseId, String section, int range) {
        if (section == null) {
            return getFeedbackResponsesForSessionWithinRange(feedbackSessionName, courseId, range);
        }
        return frDb.getFeedbackResponsesForSessionToSectionWithinRange(feedbackSessionName, courseId, section, range);
    }

    public List<FeedbackResponseAttributes> getFeedbackResponsesForQuestion(String feedbackQuestionId) {
        return frDb.getFeedbackResponsesForQuestion(feedbackQuestionId);
    }

    public List<FeedbackResponseAttributes> getFeedbackResponsesForQuestionWithinRange(
            String feedbackQuestionId, int range) {
        return frDb.getFeedbackResponsesForQuestionWithinRange(feedbackQuestionId, range);
    }

    public List<FeedbackResponseAttributes> getFeedbackResponsesForQuestionInSection(
            String feedbackQuestionId, String section) {
        if (section == null) {
            return getFeedbackResponsesForQuestion(feedbackQuestionId);
        }
        return frDb.getFeedbackResponsesForQuestionInSection(feedbackQuestionId, section);
    }

    public List<FeedbackResponseAttributes> getFeedbackResponsesForReceiverForQuestion(
            String feedbackQuestionId, String userEmail) {
        return frDb.getFeedbackResponsesForReceiverForQuestion(feedbackQuestionId, userEmail);
    }

    public List<FeedbackResponseAttributes> getFeedbackResponsesForReceiverForQuestionInSection(
            String feedbackQuestionId, String userEmail, String section) {

        if (section == null) {
            return getFeedbackResponsesForReceiverForQuestion(feedbackQuestionId, userEmail);
        }
        return frDb.getFeedbackResponsesForReceiverForQuestionInSection(
                    feedbackQuestionId, userEmail, section);
    }

    public List<FeedbackResponseAttributes> getFeedbackResponsesFromGiverForQuestion(
            String feedbackQuestionId, String userEmail) {
        return frDb.getFeedbackResponsesFromGiverForQuestion(feedbackQuestionId, userEmail);
    }

    public List<FeedbackResponseAttributes> getFeedbackResponsesFromGiverForQuestionInSection(
            String feedbackQuestionId, String userEmail, String section) {

        if (section == null) {
            return getFeedbackResponsesFromGiverForQuestion(feedbackQuestionId, userEmail);
        }
        return frDb.getFeedbackResponsesFromGiverForQuestionInSection(
                    feedbackQuestionId, userEmail, section);
    }

    public List<FeedbackResponseAttributes> getFeedbackResponsesFromGiverForSessionWithinRange(
            String giverEmail, String feedbackSessionName, String courseId, int range) {
        return frDb.getFeedbackResponsesFromGiverForSessionWithinRange(giverEmail, feedbackSessionName, courseId, range);
    }

    public boolean hasGiverRespondedForSession(String userEmail, String feedbackSessionName, String courseId) {

        return !getFeedbackResponsesFromGiverForSessionWithinRange(userEmail, feedbackSessionName, courseId, 1).isEmpty();
    }

    public List<FeedbackResponseAttributes> getFeedbackResponsesForReceiverForCourse(
            String courseId, String userEmail) {
        return frDb.getFeedbackResponsesForReceiverForCourse(courseId, userEmail);
    }

    public List<FeedbackResponseAttributes> getFeedbackResponsesFromGiverForCourse(
            String courseId, String userEmail) {
        return frDb.getFeedbackResponsesFromGiverForCourse(courseId, userEmail);
    }

    /**
     * Get existing feedback responses from student or his team for the given
     * question.
     */
    public List<FeedbackResponseAttributes> getFeedbackResponsesFromStudentOrTeamForQuestion(
            FeedbackQuestionAttributes question, StudentAttributes student) {
        if (question.giverType == FeedbackParticipantType.TEAMS) {
            return getFeedbackResponsesFromTeamForQuestion(
                    question.getId(), question.courseId, student.team);
        }
        return frDb.getFeedbackResponsesFromGiverForQuestion(question.getId(), student.email);
    }

    public List<FeedbackResponseAttributes> getViewableFeedbackResponsesForQuestionInSection(
            FeedbackQuestionAttributes question, String userEmail,
            UserRole role, String section) {

        List<FeedbackResponseAttributes> viewableResponses = new ArrayList<>();

        // Add responses that the user submitted himself
        addNewResponses(
                viewableResponses,
                getFeedbackResponsesFromGiverForQuestionInSection(
                        question.getId(), userEmail, section));

        // Add responses that user is a receiver of when question is visible to
        // receiver.
        if (question.isResponseVisibleTo(FeedbackParticipantType.RECEIVER)) {
            addNewResponses(
                    viewableResponses,
                    getFeedbackResponsesForReceiverForQuestionInSection(
                            question.getId(), userEmail, section));
        }

        switch (role) {
        case STUDENT:
            // many queries
            addNewResponses(viewableResponses,
                            getViewableFeedbackResponsesForStudentForQuestion(question, userEmail));
            break;
        case INSTRUCTOR:
            if (question.isResponseVisibleTo(FeedbackParticipantType.INSTRUCTORS)) {
                addNewResponses(viewableResponses,
                                getFeedbackResponsesForQuestionInSection(question.getId(), section));
            }
            break;
        default:
            Assumption.fail(""The role of the requesting use has to be Student or Instructor"");
            break;
        }

        return viewableResponses;
    }

    public boolean isNameVisibleToUser(
            FeedbackQuestionAttributes question,
            FeedbackResponseAttributes response,
            String userEmail,
            UserRole role, boolean isGiverName, CourseRoster roster) {

        if (question == null) {
            return false;
        }

        // Early return if user is giver
        if (question.giverType == FeedbackParticipantType.TEAMS) {
            // if response is given by team, then anyone in the team can see the response
            if (roster.isStudentsInSameTeam(response.giver, userEmail)) {
                return true;
            }
        } else {
            if (response.giver.equals(userEmail)) {
                return true;
            }
        }

        return isFeedbackParticipantNameVisibleToUser(question, response,
                userEmail, role, isGiverName, roster);
    }

    private boolean isFeedbackParticipantNameVisibleToUser(
            FeedbackQuestionAttributes question, FeedbackResponseAttributes response,
            String userEmail, UserRole role, boolean isGiverName, CourseRoster roster) {
        List<FeedbackParticipantType> showNameTo = isGiverName
                                                 ? question.showGiverNameTo
                                                 : question.showRecipientNameTo;
        for (FeedbackParticipantType type : showNameTo) {
            switch (type) {
            case INSTRUCTORS:
                if (roster.getInstructorForEmail(userEmail) != null && role == UserRole.INSTRUCTOR) {
                    return true;
                }
                break;
            case OWN_TEAM_MEMBERS:
            case OWN_TEAM_MEMBERS_INCLUDING_SELF:
                // Refers to Giver's Team Members
                if (roster.isStudentsInSameTeam(response.giver, userEmail)) {
                    return true;
                }
                break;
            case RECEIVER:
                // Response to team
                if (question.recipientType.isTeam()) {
                    if (roster.isStudentInTeam(userEmail, response.recipient)) {
                        // this is a team name
                        return true;
                    }
                    break;
                    // Response to individual
                } else if (response.recipient.equals(userEmail)) {
                    return true;
                } else {
                    break;
                }
            case RECEIVER_TEAM_MEMBERS:
                // Response to team; recipient = teamName
                if (question.recipientType.isTeam()) {
                    if (roster.isStudentInTeam(userEmail, response.recipient)) {
                        // this is a team name
                        return true;
                    }
                    break;
                } else if (roster.isStudentsInSameTeam(response.recipient, userEmail)) {
                    // Response to individual
                    return true;
                }
                break;
            case STUDENTS:
                if (roster.isStudentInCourse(userEmail)) {
                    return true;
                }
                break;
            default:
                Assumption.fail(""Invalid FeedbackParticipantType for showNameTo in ""
                                + ""FeedbackResponseLogic.isFeedbackParticipantNameVisibleToUser()"");
                break;
            }
        }
        return false;
    }

    /**
     * Returns true if the responses of the question are visible to students.
     */
    public boolean isResponseOfFeedbackQuestionVisibleToStudent(FeedbackQuestionAttributes question) {
        if (question.isResponseVisibleTo(FeedbackParticipantType.STUDENTS)) {
            return true;
        }
        boolean isStudentRecipientType =
                   question.recipientType.equals(FeedbackParticipantType.STUDENTS)
                || question.recipientType.equals(FeedbackParticipantType.OWN_TEAM_MEMBERS)
                || question.recipientType.equals(FeedbackParticipantType.OWN_TEAM_MEMBERS_INCLUDING_SELF)
                || question.recipientType.equals(FeedbackParticipantType.GIVER)
                   && question.giverType.equals(FeedbackParticipantType.STUDENTS);

        if ((isStudentRecipientType || question.recipientType.isTeam())
                && question.isResponseVisibleTo(FeedbackParticipantType.RECEIVER)) {
            return true;
        }
        if (question.giverType == FeedbackParticipantType.TEAMS
                || question.isResponseVisibleTo(FeedbackParticipantType.OWN_TEAM_MEMBERS)) {
            return true;
        }
        return question.isResponseVisibleTo(FeedbackParticipantType.RECEIVER_TEAM_MEMBERS);
    }

    public boolean hasResponsesForCourse(String courseId) {
        return frDb.hasFeedbackResponseEntitiesForCourse(courseId);
    }

    /**
     * Updates a {@link FeedbackResponse} based on it's {@code id}.<br>
     * If the giver/recipient field is changed, the {@link FeedbackResponse} is
     * updated by recreating the response<br>
     * in order to prevent an id clash if the previous email is reused later on.
     */
    public void updateFeedbackResponse(
            FeedbackResponseAttributes responseToUpdate)
            throws InvalidParametersException, EntityDoesNotExistException,
            EntityAlreadyExistsException {

        // Create a copy.
        FeedbackResponseAttributes newResponse = new FeedbackResponseAttributes(
                responseToUpdate);
        FeedbackResponse oldResponseEntity = null;
        if (newResponse.getId() == null) {
            oldResponseEntity = frDb.getFeedbackResponseEntityWithCheck(newResponse.feedbackQuestionId,
                    newResponse.giver, newResponse.recipient);
        } else {
            oldResponseEntity = frDb.getFeedbackResponseEntityWithCheck(newResponse.getId());
        }

        FeedbackResponseAttributes oldResponse = null;
        if (oldResponseEntity != null) {
            oldResponse = new FeedbackResponseAttributes(oldResponseEntity);
        }

        if (oldResponse == null) {
            throw new EntityDoesNotExistException(
                    ""Trying to update a feedback response that does not exist."");
        }

        updateFeedbackResponse(newResponse, oldResponseEntity);
    }

    /**
     * Updates a {@link FeedbackResponse} using a {@link FeedbackResponseAttributes} <br>
     * If the giver/recipient field is changed, the {@link FeedbackResponse} is
     * updated by recreating the response<br>
     * in order to prevent an id clash if the previous email is reused later on.
     * @param oldResponseEntity  a FeedbackResponse retrieved from the database
     * @throws EntityAlreadyExistsException  if trying to prevent an id clash by recreating a response,
     *                                       a response with the same id already exist.
     */
    public void updateFeedbackResponse(
            FeedbackResponseAttributes updatedResponse, FeedbackResponse oldResponseEntity)
            throws InvalidParametersException, EntityAlreadyExistsException, EntityDoesNotExistException {
        Assumption.assertNotNull(oldResponseEntity);

        // Create a copy.
        FeedbackResponseAttributes newResponse = new FeedbackResponseAttributes(updatedResponse);
        FeedbackResponseAttributes oldResponse = new FeedbackResponseAttributes(oldResponseEntity);

        // Copy values that cannot be changed to defensively avoid invalid
        // parameters.
        copyFixedValuesFromOldToNew(newResponse, oldResponse);

        if (newResponse.recipient.equals(oldResponse.recipient)
                && newResponse.giver.equals(oldResponse.giver)) {
            try {
                frDb.updateFeedbackResponseOptimized(newResponse, oldResponseEntity);
            } catch (EntityDoesNotExistException e) {
                Assumption.fail();
            }
        } else {
            // Recreate response to prevent possible future id conflict.
            recreateResponse(newResponse, oldResponse);
        }
    }

    /**
     * Copies values that cannot be changed to defensively avoid invalid parameters.
     * @param newResponse  values are copied from oldResponse
     * @param oldResponse  values are copied to newResponse
     */
    private void copyFixedValuesFromOldToNew(FeedbackResponseAttributes newResponse,
            FeedbackResponseAttributes oldResponse) {
        newResponse.courseId = oldResponse.courseId;
        newResponse.feedbackSessionName = oldResponse.feedbackSessionName;
        newResponse.feedbackQuestionId = oldResponse.feedbackQuestionId;
        newResponse.feedbackQuestionType = oldResponse.feedbackQuestionType;

        if (newResponse.responseMetaData == null) {
            newResponse.responseMetaData = oldResponse.responseMetaData;
        }
        if (newResponse.giver == null) {
            newResponse.giver = oldResponse.giver;
        }
        if (newResponse.recipient == null) {
            newResponse.recipient = oldResponse.recipient;
        }
        if (newResponse.giverSection == null) {
            newResponse.giverSection = oldResponse.giverSection;
        }
        if (newResponse.recipientSection == null) {
            newResponse.recipientSection = oldResponse.recipientSection;
        }
    }

    private void recreateResponse(
            FeedbackResponseAttributes newResponse, FeedbackResponseAttributes oldResponse)
            throws InvalidParametersException, EntityAlreadyExistsException, EntityDoesNotExistException {
        try {
            newResponse.setId(null);
            FeedbackResponse createdResponseEntity =
                    frDb.createEntity(newResponse);
            frDb.deleteEntity(oldResponse);
            frcLogic.updateFeedbackResponseCommentsForChangingResponseId(
                    oldResponse.getId(), createdResponseEntity.getId());
        } catch (EntityAlreadyExistsException e) {
            log.warning(""Trying to update an existing response to one that already exists."");
            throw e;
        }
    }

    /**
     * Updates responses for a student when his team changes. This is done by
     * deleting responses that are no longer relevant to him in his new team.
     */
    public void updateFeedbackResponsesForChangingTeam(
            String courseId, String userEmail, String oldTeam, String newTeam) {

        deleteResponsesFromUserToTeam(courseId, userEmail);
        deleteResponsesFromTeamToUser(courseId, userEmail);

        boolean isOldTeamEmpty = studentsLogic.getStudentsForTeam(oldTeam, courseId).isEmpty();
        if (isOldTeamEmpty) {
            deleteTeamResponses(courseId, oldTeam);
        }
    }

    private void deleteTeamResponses(String courseId, String oldTeam) {
        List<FeedbackResponseAttributes> responsesToOldTeam =
                getFeedbackResponsesForReceiverForCourse(courseId, oldTeam);
        for (FeedbackResponseAttributes response : responsesToOldTeam) {
            frDb.deleteEntity(response);
        }
    }

    private void deleteResponsesFromTeamToUser(String courseId, String userEmail) {
        FeedbackQuestionAttributes question;
        List<FeedbackResponseAttributes> responsesToUser =
                getFeedbackResponsesForReceiverForCourse(courseId, userEmail);

        for (FeedbackResponseAttributes response : responsesToUser) {
            question = fqLogic.getFeedbackQuestion(response.feedbackQuestionId);
            if (isRecipientTypeTeamMembers(question)) {
                frDb.deleteEntity(response);
            }
        }
    }

    private void deleteResponsesFromUserToTeam(String courseId, String userEmail) {
        FeedbackQuestionAttributes question;

        List<FeedbackResponseAttributes> responsesFromUser =
                getFeedbackResponsesFromGiverForCourse(courseId, userEmail);

        for (FeedbackResponseAttributes response : responsesFromUser) {
            question = fqLogic.getFeedbackQuestion(response.feedbackQuestionId);
            if (question.giverType == FeedbackParticipantType.TEAMS
                    || isRecipientTypeTeamMembers(question)) {
                frDb.deleteEntity(response);
            }
        }
    }

    /**
     * Updates responses for a student when his section changes.
     */
    public void updateFeedbackResponsesForChangingSection(
            String courseId, String userEmail, String oldSection, String newSection)
            throws EntityDoesNotExistException, InvalidParametersException {
        updateSectionOfResponsesFromUser(courseId, userEmail, newSection);
        updateSectionOfResponsesToUser(courseId, userEmail, newSection);
    }

    private void updateSectionOfResponsesToUser(String courseId, String userEmail, String newSection)
            throws InvalidParametersException, EntityDoesNotExistException {
        List<FeedbackResponseAttributes> responsesToUser =
                getFeedbackResponsesForReceiverForCourse(courseId, userEmail);

        for (FeedbackResponseAttributes response : responsesToUser) {
            response.recipientSection = newSection;
            frDb.updateFeedbackResponse(response);
            frcLogic.updateFeedbackResponseCommentsForResponse(response.getId());
        }
    }

    private void updateSectionOfResponsesFromUser(String courseId, String userEmail, String newSection)
            throws InvalidParametersException, EntityDoesNotExistException {
        List<FeedbackResponseAttributes> responsesFromUser =
                getFeedbackResponsesFromGiverForCourse(courseId, userEmail);

        for (FeedbackResponseAttributes response : responsesFromUser) {
            response.giverSection = newSection;
            frDb.updateFeedbackResponse(response);
            frcLogic.updateFeedbackResponseCommentsForResponse(response.getId());
        }
    }

    public boolean updateFeedbackResponseForChangingTeam(StudentEnrollDetails enrollment,
            FeedbackResponseAttributes response) throws InvalidParametersException, EntityDoesNotExistException {

        FeedbackQuestionAttributes question = fqLogic
                .getFeedbackQuestion(response.feedbackQuestionId);

        boolean isGiverSameForResponseAndEnrollment = response.giver
                .equals(enrollment.email);
        boolean isReceiverSameForResponseAndEnrollment = response.recipient
                .equals(enrollment.email);

        boolean shouldDeleteByChangeOfGiver = isGiverSameForResponseAndEnrollment
                                              && (question.giverType == FeedbackParticipantType.TEAMS
                                                  || isRecipientTypeTeamMembers(question));
        boolean shouldDeleteByChangeOfRecipient = isReceiverSameForResponseAndEnrollment
                                                  && isRecipientTypeTeamMembers(question);

        boolean shouldDeleteResponse = shouldDeleteByChangeOfGiver
                || shouldDeleteByChangeOfRecipient;

        if (shouldDeleteResponse) {
            frDb.deleteEntity(response);
            updateSessionResponseRateForDeletingStudentResponse(enrollment.email,
                    response.feedbackSessionName, enrollment.course);
        }

        return shouldDeleteResponse;
    }

    private void updateSessionResponseRateForDeletingStudentResponse(String studentEmail, String sessionName,
            String courseId) throws InvalidParametersException, EntityDoesNotExistException {
        if (!hasGiverRespondedForSession(studentEmail, sessionName, courseId)) {
            fsLogic.deleteStudentFromRespondentList(studentEmail, sessionName, courseId);
        }
    }

    private boolean isRecipientTypeTeamMembers(FeedbackQuestionAttributes question) {
        return question.recipientType == FeedbackParticipantType.OWN_TEAM_MEMBERS
               || question.recipientType == FeedbackParticipantType.OWN_TEAM_MEMBERS_INCLUDING_SELF;
    }

    public void updateFeedbackResponseForChangingSection(
            StudentEnrollDetails enrollment,
            FeedbackResponseAttributes response) throws InvalidParametersException, EntityDoesNotExistException {

        FeedbackResponse feedbackResponse = frDb.getFeedbackResponseEntityOptimized(response);
        boolean isGiverSameForResponseAndEnrollment = feedbackResponse.getGiverEmail()
                .equals(enrollment.email);
        boolean isReceiverSameForResponseAndEnrollment = feedbackResponse.getRecipientEmail()
                .equals(enrollment.email);

        if (isGiverSameForResponseAndEnrollment) {
            feedbackResponse.setGiverSection(enrollment.newSection);
        }

        if (isReceiverSameForResponseAndEnrollment) {
            feedbackResponse.setRecipientSection(enrollment.newSection);
        }

        frDb.saveEntity(feedbackResponse);

        if (isGiverSameForResponseAndEnrollment || isReceiverSameForResponseAndEnrollment) {
            frcLogic.updateFeedbackResponseCommentsForResponse(response.getId());
        }
    }

    /**
     * Updates responses for a student when his email changes.
     */
    // TODO: cascade the update to response comments
    public void updateFeedbackResponsesForChangingEmail(
            String courseId, String oldEmail, String newEmail)
            throws InvalidParametersException, EntityDoesNotExistException {

        List<FeedbackResponseAttributes> responsesFromUser =
                getFeedbackResponsesFromGiverForCourse(courseId, oldEmail);

        for (FeedbackResponseAttributes response : responsesFromUser) {
            response.giver = newEmail;
            try {
                updateFeedbackResponse(response);
            } catch (EntityAlreadyExistsException e) {
                Assumption
                        .fail(""Feedback response failed to update successfully""
                            + ""as email was already in use."");
            }
        }

        List<FeedbackResponseAttributes> responsesToUser =
                getFeedbackResponsesForReceiverForCourse(courseId, oldEmail);

        for (FeedbackResponseAttributes response : responsesToUser) {
            response.recipient = newEmail;
            try {
                updateFeedbackResponse(response);
            } catch (EntityAlreadyExistsException e) {
                Assumption
                        .fail(""Feedback response failed to update successfully""
                            + ""as email was already in use."");
            }
        }
    }

    public void deleteFeedbackResponseAndCascade(FeedbackResponseAttributes responseToDelete) {
        frcLogic.deleteFeedbackResponseCommentsForResponse(responseToDelete.getId());
        frDb.deleteEntity(responseToDelete);
    }

    public void deleteFeedbackResponsesForQuestionAndCascade(
            String feedbackQuestionId, boolean hasResponseRateUpdate) {
        List<FeedbackResponseAttributes> responsesForQuestion =
                getFeedbackResponsesForQuestion(feedbackQuestionId);

        Set<String> emails = new HashSet<>();

        for (FeedbackResponseAttributes response : responsesForQuestion) {
            this.deleteFeedbackResponseAndCascade(response);
            emails.add(response.giver);
        }

        if (!hasResponseRateUpdate) {
            return;
        }

        try {
            FeedbackQuestionAttributes question = fqLogic
                    .getFeedbackQuestion(feedbackQuestionId);
            boolean isInstructor = question.giverType == FeedbackParticipantType.SELF
                                   || question.giverType == FeedbackParticipantType.INSTRUCTORS;
            for (String email : emails) {
                boolean hasResponses = hasGiverRespondedForSession(email, question.feedbackSessionName, question.courseId);
                if (!hasResponses) {
                    if (isInstructor) {
                        fsLogic.deleteInstructorRespondent(email,
                                question.feedbackSessionName,
                                question.courseId);
                    } else {
                        fsLogic.deleteStudentFromRespondentList(email,
                                question.feedbackSessionName,
                                question.courseId);
                    }
                }
            }
        } catch (InvalidParametersException | EntityDoesNotExistException e) {
            Assumption.fail(""Fail to delete respondent"");
        }
    }

    public void deleteFeedbackResponsesForStudentAndCascade(String courseId, String studentEmail) {

        String studentTeam = """";
        StudentAttributes student = studentsLogic.getStudentForEmail(courseId,
                studentEmail);

        if (student != null) {
            studentTeam = student.team;
        }

        List<FeedbackResponseAttributes> responses =
                getFeedbackResponsesFromGiverForCourse(courseId, studentEmail);
        responses
                .addAll(
                getFeedbackResponsesForReceiverForCourse(courseId, studentEmail));
        // Delete responses to team as well if student is last person in team.
        if (studentsLogic.getStudentsForTeam(studentTeam, courseId).size() <= 1) {
            responses.addAll(getFeedbackResponsesForReceiverForCourse(courseId, studentTeam));
        }

        for (FeedbackResponseAttributes response : responses) {
            this.deleteFeedbackResponseAndCascade(response);
        }
    }

    /**
     * Deletes all feedback responses in every feedback session in
     * the specified course. This is a non-cascade delete and the
     * feedback response comments are not deleted, and should be handled.
     */
    public void deleteFeedbackResponsesForCourse(String courseId) {
        frDb.deleteFeedbackResponsesForCourse(courseId);
    }

    /**
     * Adds {@link FeedbackResponseAttributes} in {@code newResponses} that are
     * not already in to {@code existingResponses} to {@code existingResponses}.
     */
    private void addNewResponses(
            List<FeedbackResponseAttributes> existingResponses,
            List<FeedbackResponseAttributes> newResponses) {

        Map<String, FeedbackResponseAttributes> responses = new HashMap<>();

        for (FeedbackResponseAttributes existingResponse : existingResponses) {
            responses.put(existingResponse.getId(), existingResponse);
        }
        for (FeedbackResponseAttributes newResponse : newResponses) {
            if (!responses.containsKey(newResponse.getId())) {
                responses.put(newResponse.getId(), newResponse);
                existingResponses.add(newResponse);
            }
        }
    }

    private List<FeedbackResponseAttributes> getFeedbackResponsesFromTeamForQuestion(
            String feedbackQuestionId, String courseId, String teamName) {

        List<FeedbackResponseAttributes> responses = new ArrayList<>();
        List<StudentAttributes> studentsInTeam =
                studentsLogic.getStudentsForTeam(teamName, courseId);

        for (StudentAttributes student : studentsInTeam) {
            responses.addAll(frDb.getFeedbackResponsesFromGiverForQuestion(
                    feedbackQuestionId, student.email));
        }

        responses.addAll(frDb.getFeedbackResponsesFromGiverForQuestion(
                                        feedbackQuestionId, teamName));

        return responses;
    }

    private List<FeedbackResponseAttributes> getFeedbackResponsesForTeamMembersOfStudent(
            String feedbackQuestionId, StudentAttributes student) {

        List<StudentAttributes> studentsInTeam = studentsLogic.getStudentsForTeam(student.team, student.course);

        List<FeedbackResponseAttributes> teamResponses = new ArrayList<>();

        for (StudentAttributes studentInTeam : studentsInTeam) {
            if (studentInTeam.email.equals(student.email)) {
                continue;
            }
            List<FeedbackResponseAttributes> responses =
                    frDb.getFeedbackResponsesForReceiverForQuestion(feedbackQuestionId, studentInTeam.email);
            teamResponses.addAll(responses);
        }

        return teamResponses;
    }

    private List<FeedbackResponseAttributes> getViewableFeedbackResponsesForStudentForQuestion(
            FeedbackQuestionAttributes question, String studentEmail) {

        List<FeedbackResponseAttributes> viewableResponses = new ArrayList<>();

        if (question.isResponseVisibleTo(FeedbackParticipantType.STUDENTS)) {
            addNewResponses(viewableResponses,
                    getFeedbackResponsesForQuestion(question.getId()));

            // Early return as STUDENTS covers all other student types.
            return viewableResponses;
        }

        StudentAttributes student = studentsLogic.getStudentForEmail(question.courseId, studentEmail);
        if (question.recipientType.isTeam()
                && question.isResponseVisibleTo(FeedbackParticipantType.RECEIVER)) {
            addNewResponses(
                    viewableResponses,
                    getFeedbackResponsesForReceiverForQuestion(
                            question.getId(), student.team));
        }

        if (question.giverType == FeedbackParticipantType.TEAMS
                || question.isResponseVisibleTo(FeedbackParticipantType.OWN_TEAM_MEMBERS)) {
            addNewResponses(viewableResponses,
                    getFeedbackResponsesFromTeamForQuestion(
                            question.getId(), question.courseId, student.team));
        }
        if (question
                .isResponseVisibleTo(FeedbackParticipantType.RECEIVER_TEAM_MEMBERS)) {
            addNewResponses(
                    viewableResponses,
                    getFeedbackResponsesForTeamMembersOfStudent(
                            question.getId(), student));
        }

        return viewableResponses;
    }
}
"
FeedbackSessionsLogic.java,logic-core,"package teammates.logic.core;

import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collections;
import java.util.Comparator;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import teammates.common.datatransfer.CourseRoster;
import teammates.common.datatransfer.FeedbackParticipantType;
import teammates.common.datatransfer.FeedbackSessionDetailsBundle;
import teammates.common.datatransfer.FeedbackSessionQuestionsBundle;
import teammates.common.datatransfer.FeedbackSessionResponseStatus;
import teammates.common.datatransfer.FeedbackSessionResultsBundle;
import teammates.common.datatransfer.FeedbackSessionType;
import teammates.common.datatransfer.UserRole;
import teammates.common.datatransfer.attributes.FeedbackQuestionAttributes;
import teammates.common.datatransfer.attributes.FeedbackResponseAttributes;
import teammates.common.datatransfer.attributes.FeedbackResponseCommentAttributes;
import teammates.common.datatransfer.attributes.FeedbackSessionAttributes;
import teammates.common.datatransfer.attributes.InstructorAttributes;
import teammates.common.datatransfer.attributes.StudentAttributes;
import teammates.common.datatransfer.questions.FeedbackQuestionDetails;
import teammates.common.exception.EntityAlreadyExistsException;
import teammates.common.exception.EntityDoesNotExistException;
import teammates.common.exception.ExceedingRangeException;
import teammates.common.exception.InvalidParametersException;
import teammates.common.exception.TeammatesException;
import teammates.common.util.Assumption;
import teammates.common.util.Const;
import teammates.common.util.Const.SystemParams;
import teammates.common.util.Logger;
import teammates.common.util.SanitizationHelper;
import teammates.common.util.StringHelper;
import teammates.common.util.TimeHelper;
import teammates.storage.api.FeedbackSessionsDb;

/**
 * Handles operations related to feedback sessions.
 *
 * @see FeedbackSessionAttributes
 * @see FeedbackSessionsDb
 */
public final class FeedbackSessionsLogic {

    private static final String QUESTION_ID_FOR_RESPONSE_RATE = ""-1"";
    private static final int EMAIL_NAME_PAIR = 0;
    private static final int EMAIL_LASTNAME_PAIR = 1;
    private static final int EMAIL_TEAMNAME_PAIR = 2;

    private static final String PARAM_FROM_SECTION = ""fromSection"";
    private static final String PARAM_IN_SECTION = ""inSection"";
    private static final String PARAM_IS_INCLUDE_RESPONSE_STATUS = ""isIncludeResponseStatus"";
    private static final String PARAM_QUESTION_ID = ""questionId"";
    private static final String PARAM_RANGE = ""range"";
    private static final String PARAM_SECTION = ""section"";
    private static final String PARAM_TO_SECTION = ""toSection"";
    private static final String PARAM_VIEW_TYPE = ""viewType"";

    private static final String ASSUMPTION_FAIL_DELETE_INSTRUCTOR = ""Fail to delete instructor respondent for "";
    private static final String ASSUMPTION_FAIL_RESPONSE_ORIGIN = ""Client did not indicate the origin of the response(s)"";
    private static final String ERROR_NUMBER_OF_RESPONSES_EXCEEDS_RANGE = ""Number of responses exceeds the limited range"";
    private static final String ERROR_NON_EXISTENT_COURSE = ""Error getting feedback session(s): Course does not exist."";
    private static final String ERROR_NON_EXISTENT_STUDENT = ""Error getting feedback session(s): Student does not exist."";
    private static final String ERROR_NON_EXISTENT_FS_STRING_FORMAT = ""Trying to %s a non-existent feedback session: "";
    private static final String ERROR_NON_EXISTENT_FS_GET = String.format(ERROR_NON_EXISTENT_FS_STRING_FORMAT, ""get"");
    private static final String ERROR_NON_EXISTENT_FS_UPDATE = String.format(ERROR_NON_EXISTENT_FS_STRING_FORMAT, ""update"");
    private static final String ERROR_NON_EXISTENT_FS_CHECK = String.format(ERROR_NON_EXISTENT_FS_STRING_FORMAT, ""check"");
    private static final String ERROR_NON_EXISTENT_FS_VIEW = String.format(ERROR_NON_EXISTENT_FS_STRING_FORMAT, ""view"");
    private static final String ERROR_FS_ALREADY_PUBLISH = ""Error publishing feedback session: ""
                                                           + ""Session has already been published."";
    private static final String ERROR_FS_ALREADY_UNPUBLISH = ""Error unpublishing feedback session: ""
                                                             + ""Session has already been unpublished."";
    private static final String ERROR_FS_PRIVATE_PUBLISH = ""Error publishing feedback session: ""
                                                           + ""Session is private and can't be published."";
    private static final String ERROR_FS_PRIVATE_UNPUBLISH = ""Error unpublishing feedback session: ""
                                                             + ""Session is private and can't be unpublished."";

    private static final Logger log = Logger.getLogger();

    private static FeedbackSessionsLogic instance = new FeedbackSessionsLogic();

    private static final FeedbackSessionsDb fsDb = new FeedbackSessionsDb();

    private static final CoursesLogic coursesLogic = CoursesLogic.inst();
    private static final FeedbackQuestionsLogic fqLogic = FeedbackQuestionsLogic.inst();
    private static final FeedbackResponsesLogic frLogic = FeedbackResponsesLogic.inst();
    private static final FeedbackResponseCommentsLogic frcLogic = FeedbackResponseCommentsLogic.inst();
    private static final InstructorsLogic instructorsLogic = InstructorsLogic.inst();
    private static final StudentsLogic studentsLogic = StudentsLogic.inst();

    private FeedbackSessionsLogic() {
        // prevent initialization
    }

    public static FeedbackSessionsLogic inst() {
        return instance;
    }

    // TODO: in general, try to reduce method length and nesting-level in
    // Feedback*Logic classes.

    public void createFeedbackSession(FeedbackSessionAttributes fsa)
            throws InvalidParametersException, EntityAlreadyExistsException {
        fsDb.createEntity(fsa);
    }

    public List<FeedbackSessionAttributes> getAllOpenFeedbackSessions(Date start, Date end, double zone) {

        return fsDb.getAllOpenFeedbackSessions(start, end, zone);
    }

    /**
     * This method returns a single feedback session. Returns null if not found.
     */
    public FeedbackSessionAttributes getFeedbackSession(String feedbackSessionName, String courseId) {
        return fsDb.getFeedbackSession(courseId, feedbackSessionName);
    }

    public List<FeedbackSessionAttributes> getFeedbackSessionsForCourse(
            String courseId) {
        return fsDb.getFeedbackSessionsForCourse(courseId);
    }

    public FeedbackSessionAttributes copyFeedbackSession(String newFeedbackSessionName,
            String newCourseId, String feedbackSessionName, String courseId, String instructorEmail)
            throws InvalidParametersException, EntityAlreadyExistsException, EntityDoesNotExistException {
        FeedbackSessionAttributes copiedFeedbackSession = getFeedbackSession(feedbackSessionName, courseId);
        copiedFeedbackSession.setCreatorEmail(instructorEmail);
        copiedFeedbackSession.setFeedbackSessionName(newFeedbackSessionName);
        copiedFeedbackSession.setCourseId(newCourseId);
        copiedFeedbackSession.setCreatedTime(new Date());
        copiedFeedbackSession.setRespondingInstructorList(new HashSet<String>());
        copiedFeedbackSession.setRespondingStudentList(new HashSet<String>());
        fsDb.createEntity(copiedFeedbackSession);

        List<FeedbackQuestionAttributes> feedbackQuestions =
                fqLogic.getFeedbackQuestionsForSession(feedbackSessionName, courseId);
        for (FeedbackQuestionAttributes question : feedbackQuestions) {
            question.courseId = newCourseId;
            question.feedbackSessionName = newFeedbackSessionName;
            question.creatorEmail = instructorEmail;
            fqLogic.createFeedbackQuestionNoIntegrityCheck(question, question.questionNumber);
        }

        return copiedFeedbackSession;
    }

    /**
     * Checks if the specified course exists, then gets the feedback sessions for
     * the specified user in the course if it does exist.
     *
     * @return a list of viewable feedback sessions for any user for his course.
     */
    public List<FeedbackSessionAttributes> getFeedbackSessionsForUserInCourse(
            String courseId, String userEmail)
            throws EntityDoesNotExistException {

        if (!coursesLogic.isCoursePresent(courseId)) {
            throw new EntityDoesNotExistException(ERROR_NON_EXISTENT_COURSE);
        }
        return getFeedbackSessionsForUserInCourseSkipCheck(courseId, userEmail);
    }

    /**
     * Gets the feedback sessions for the specified user in the specified course
     * without checking for the course's existence.<br>
     * This method is usually called after the course's existence is assumed or
     * has been verified.
     *
     * @return a list of viewable feedback sessions for any user for his course.
     */
    public List<FeedbackSessionAttributes> getFeedbackSessionsForUserInCourseSkipCheck(
            String courseId, String userEmail) {
        List<FeedbackSessionAttributes> sessions =
                getFeedbackSessionsForCourse(courseId);
        List<FeedbackSessionAttributes> viewableSessions = new ArrayList<>();
        if (!sessions.isEmpty()) {
            InstructorAttributes instructor = instructorsLogic.getInstructorForEmail(courseId, userEmail);
            boolean isInstructorOfCourse = instructor != null;
            for (FeedbackSessionAttributes session : sessions) {
                if (isFeedbackSessionViewableTo(session, userEmail, isInstructorOfCourse)) {
                    viewableSessions.add(session);
                }
            }
        }

        return viewableSessions;
    }

    /**
     * Returns true if there is some open or published email sent for the course.
     *
     * @param courseId - ID of the course
     */
    public boolean isOpenOrPublishedEmailSentForTheCourse(String courseId) {
        List<FeedbackSessionAttributes> sessions = getFeedbackSessionsForCourse(courseId);

        for (FeedbackSessionAttributes session : sessions) {
            if (session.isSentOpenEmail() || session.isSentPublishedEmail()) {
                return true;
            }
        }
        return false;
    }

    /**
     * Returns a {@code List} of all feedback sessions bundled with their
     * response statistics for a instructor given by his googleId.<br>
     * Does not return private sessions unless the instructor is the creator.
     */
    public List<FeedbackSessionDetailsBundle> getFeedbackSessionDetailsForInstructor(
            String googleId)
            throws EntityDoesNotExistException {

        return getFeedbackSessionDetailsForInstructor(googleId, false);
    }

    /**
     * Returns a {@code List} of all feedback sessions bundled with their
     * response statistics for a instructor given by his googleId.<br>
     * Does not return private sessions unless the instructor is the creator.
     * <br>
     * Omits archived sessions if omitArchived == true
     */
    public List<FeedbackSessionDetailsBundle> getFeedbackSessionDetailsForInstructor(
            String googleId, boolean omitArchived)
            throws EntityDoesNotExistException {

        List<FeedbackSessionDetailsBundle> fsDetails = new ArrayList<>();
        List<InstructorAttributes> instructors =
                instructorsLogic.getInstructorsForGoogleId(googleId, omitArchived);

        for (InstructorAttributes instructor : instructors) {
            fsDetails.addAll(getFeedbackSessionDetailsForCourse(
                    instructor.courseId, instructor.email));
        }

        return fsDetails;
    }

    /**
     * Returns a {@code List} of all feedback sessions WITHOUT their response
     * statistics for a instructor given by his googleId.<br>
     * Does not return private sessions unless the instructor is the creator.
     * <br>
     * Omits sessions from archived courses if omitArchived == true
     */
    public List<FeedbackSessionAttributes> getFeedbackSessionsListForInstructor(String googleId, boolean omitArchived) {

        List<InstructorAttributes> instructorList =
                instructorsLogic.getInstructorsForGoogleId(googleId, omitArchived);

        return getFeedbackSessionsListForInstructor(instructorList);
    }

    public List<FeedbackSessionAttributes> getFeedbackSessionsListForInstructor(
            List<InstructorAttributes> instructorList) {

        List<FeedbackSessionAttributes> fsList = new ArrayList<>();

        for (InstructorAttributes instructor : instructorList) {
            fsList.addAll(getFeedbackSessionsListForCourse(instructor.courseId, instructor.email));
        }

        return fsList;
    }

    public List<FeedbackSessionAttributes> getFeedbackSessionListForInstructor(
            InstructorAttributes instructor) {
        return getFeedbackSessionsListForCourse(instructor.courseId, instructor.email);
    }

    /**
     * Gets {@code FeedbackQuestions} and previously filled
     * {@code FeedbackResponses} that an instructor can view/submit as a
     * {@link FeedbackSessionQuestionsBundle}.
     */
    public FeedbackSessionQuestionsBundle getFeedbackSessionQuestionsForInstructor(
            String feedbackSessionName, String courseId, String userEmail)
            throws EntityDoesNotExistException {

        FeedbackSessionAttributes fsa = fsDb.getFeedbackSession(
                courseId, feedbackSessionName);

        if (fsa == null) {
            throw new EntityDoesNotExistException(ERROR_NON_EXISTENT_FS_GET + courseId + ""/"" + feedbackSessionName);
        }

        InstructorAttributes instructor = instructorsLogic.getInstructorForEmail(courseId, userEmail);
        Map<FeedbackQuestionAttributes, List<FeedbackResponseAttributes>> bundle = new HashMap<>();
        Map<String, Map<String, String>> recipientList = new HashMap<>();

        List<FeedbackQuestionAttributes> questions =
                fqLogic.getFeedbackQuestionsForInstructor(feedbackSessionName,
                        courseId, userEmail);

        InstructorAttributes instructorGiver = instructor;

        for (FeedbackQuestionAttributes question : questions) {

            updateBundleAndRecipientListWithResponsesForInstructor(courseId,
                    userEmail, fsa, instructor, bundle, recipientList,
                    question, instructorGiver, null);
        }

        return new FeedbackSessionQuestionsBundle(fsa, bundle, recipientList);
    }

    public FeedbackSessionQuestionsBundle getFeedbackSessionQuestionsForInstructor(
            String feedbackSessionName, String courseId, String feedbackQuestionId, String userEmail)
            throws EntityDoesNotExistException {

        FeedbackSessionAttributes fsa = fsDb.getFeedbackSession(
                courseId, feedbackSessionName);

        if (fsa == null) {
            throw new EntityDoesNotExistException(ERROR_NON_EXISTENT_FS_GET + courseId + ""/"" + feedbackSessionName);
        }

        InstructorAttributes instructor = instructorsLogic.getInstructorForEmail(courseId, userEmail);
        Map<FeedbackQuestionAttributes, List<FeedbackResponseAttributes>> bundle = new HashMap<>();
        Map<String, Map<String, String>> recipientList = new HashMap<>();

        FeedbackQuestionAttributes question = fqLogic.getFeedbackQuestion(feedbackQuestionId);

        InstructorAttributes instructorGiver = instructor;

        updateBundleAndRecipientListWithResponsesForInstructor(courseId,
                userEmail, fsa, instructor, bundle, recipientList,
                question, instructorGiver, null);

        return new FeedbackSessionQuestionsBundle(fsa, bundle, recipientList);
    }

    private void updateBundleAndRecipientListWithResponsesForInstructor(
            String courseId,
            String userEmail,
            FeedbackSessionAttributes fsa,
            InstructorAttributes instructor,
            Map<FeedbackQuestionAttributes, List<FeedbackResponseAttributes>> bundle,
            Map<String, Map<String, String>> recipientList,
            FeedbackQuestionAttributes question,
            InstructorAttributes instructorGiver, StudentAttributes studentGiver)
            throws EntityDoesNotExistException {
        List<FeedbackResponseAttributes> responses =
                frLogic.getFeedbackResponsesFromGiverForQuestion(
                        question.getId(), userEmail);
        Map<String, String> recipients =
                fqLogic.getRecipientsForQuestion(question, userEmail, instructorGiver, studentGiver);
        // instructor can only see students in allowed sections for him/her
        if (question.recipientType.equals(FeedbackParticipantType.STUDENTS)) {
            Iterator<Map.Entry<String, String>> iter = recipients.entrySet().iterator();
            while (iter.hasNext()) {
                Map.Entry<String, String> studentEntry = iter.next();
                StudentAttributes student = studentsLogic.getStudentForEmail(courseId, studentEntry.getKey());
                if (!instructor.isAllowedForPrivilege(student.section,
                        fsa.getFeedbackSessionName(), Const.ParamsNames.INSTRUCTOR_PERMISSION_SUBMIT_SESSION_IN_SECTIONS)) {
                    iter.remove();
                }
            }
        }
        // instructor can only see teams in allowed sections for him/her
        if (question.recipientType.equals(FeedbackParticipantType.TEAMS)) {
            Iterator<Map.Entry<String, String>> iter = recipients.entrySet().iterator();
            while (iter.hasNext()) {
                Map.Entry<String, String> teamEntry = iter.next();
                String teamSection = studentsLogic.getSectionForTeam(courseId, teamEntry.getKey());
                if (!instructor.isAllowedForPrivilege(teamSection,
                        fsa.getFeedbackSessionName(), Const.ParamsNames.INSTRUCTOR_PERMISSION_SUBMIT_SESSION_IN_SECTIONS)) {
                    iter.remove();
                }
            }
        }
        normalizeMaximumResponseEntities(question, recipients);

        bundle.put(question, responses);
        recipientList.put(question.getId(), recipients);
    }

    /**
     * Gets {@code FeedbackQuestions} and previously filled
     * {@code FeedbackResponses} that a student can view/submit as a
     * {@link FeedbackSessionQuestionsBundle}.
     */
    public FeedbackSessionQuestionsBundle getFeedbackSessionQuestionsForStudent(
            String feedbackSessionName, String courseId, String userEmail)
            throws EntityDoesNotExistException {

        FeedbackSessionAttributes fsa = fsDb.getFeedbackSession(
                courseId, feedbackSessionName);

        if (fsa == null) {
            throw new EntityDoesNotExistException(ERROR_NON_EXISTENT_FS_GET + courseId + ""/"" + feedbackSessionName);
        }
        StudentAttributes student = studentsLogic.getStudentForEmail(courseId, userEmail);
        if (student == null) {
            throw new EntityDoesNotExistException(ERROR_NON_EXISTENT_STUDENT);
        }

        Map<FeedbackQuestionAttributes, List<FeedbackResponseAttributes>> bundle = new HashMap<>();
        Map<String, Map<String, String>> recipientList = new HashMap<>();

        List<FeedbackQuestionAttributes> questions = fqLogic.getFeedbackQuestionsForStudents(feedbackSessionName,
                courseId);

        Set<String> hiddenInstructorEmails = null;

        for (FeedbackQuestionAttributes question : questions) {
            if (question.getRecipientType() == FeedbackParticipantType.INSTRUCTORS) {
                hiddenInstructorEmails = getHiddenInstructorEmails(courseId);
                break;
            }
        }

        for (FeedbackQuestionAttributes question : questions) {

            updateBundleAndRecipientListWithResponsesForStudent(userEmail, student,
                    bundle, recipientList, question, hiddenInstructorEmails);
        }

        return new FeedbackSessionQuestionsBundle(fsa, bundle, recipientList);
    }

    public FeedbackSessionQuestionsBundle getFeedbackSessionQuestionsForStudent(
            String feedbackSessionName, String courseId, String feedbackQuestionId, String userEmail)
            throws EntityDoesNotExistException {

        FeedbackSessionAttributes fsa = fsDb.getFeedbackSession(
                courseId, feedbackSessionName);

        if (fsa == null) {
            throw new EntityDoesNotExistException(ERROR_NON_EXISTENT_FS_GET + courseId + ""/"" + feedbackSessionName);
        }

        StudentAttributes student = studentsLogic.getStudentForEmail(courseId, userEmail);
        if (student == null) {
            throw new EntityDoesNotExistException(ERROR_NON_EXISTENT_STUDENT);
        }

        Map<FeedbackQuestionAttributes, List<FeedbackResponseAttributes>> bundle = new HashMap<>();
        Map<String, Map<String, String>> recipientList = new HashMap<>();

        FeedbackQuestionAttributes question = fqLogic.getFeedbackQuestion(feedbackQuestionId);

        Set<String> hiddenInstructorEmails = null;

        if (question.getRecipientType() == FeedbackParticipantType.INSTRUCTORS) {
            hiddenInstructorEmails = getHiddenInstructorEmails(courseId);
        }

        updateBundleAndRecipientListWithResponsesForStudent(userEmail, student,
                bundle, recipientList, question, hiddenInstructorEmails);

        return new FeedbackSessionQuestionsBundle(fsa, bundle, recipientList);
    }

    private void updateBundleAndRecipientListWithResponsesForStudent(
            String userEmail,
            StudentAttributes student,
            Map<FeedbackQuestionAttributes, List<FeedbackResponseAttributes>> bundle,
            Map<String, Map<String, String>> recipientList,
            FeedbackQuestionAttributes question,
            Set<String> hiddenInstructorEmails)
            throws EntityDoesNotExistException {
        List<FeedbackResponseAttributes> responses =
                frLogic.getFeedbackResponsesFromStudentOrTeamForQuestion(
                        question, student);
        Map<String, String> recipients =
                fqLogic.getRecipientsForQuestion(question, userEmail, null, student);

        removeHiddenInstructors(question, responses, recipients, hiddenInstructorEmails);

        normalizeMaximumResponseEntities(question, recipients);

        bundle.put(question, responses);
        recipientList.put(question.getId(), recipients);
    }

    /**
     * Removes instructors who are not displayed to students from
     * {@code recipients}. Responses to the hidden instructors are also removed
     * from {@code responses}.
     *
     * @param question
     *            the feedback question
     * @param responses
     *            a {@link List} of feedback responses to the {@code question}
     * @param recipients
     *            a {@link Map} that maps the emails of the recipients to their
     *            names
     * @param hiddenInstructorEmails
     *            a {@link Set} of emails of the instructors who are not
     *            displayed to students
     */
    private void removeHiddenInstructors(FeedbackQuestionAttributes question,
                                         List<FeedbackResponseAttributes> responses,
                                         Map<String, String> recipients,
                                         Set<String> hiddenInstructorEmails) {

        boolean isNoChangeRequired = hiddenInstructorEmails == null
                                   || hiddenInstructorEmails.isEmpty()
                                   || question.getRecipientType() != FeedbackParticipantType.INSTRUCTORS;

        if (isNoChangeRequired) {
            return;
        }

        for (String instructorEmail : hiddenInstructorEmails) {

            if (recipients.containsKey(instructorEmail)) {
                recipients.remove(instructorEmail);
            }

            // Remove responses to the hidden instructors if they have been stored already
            Iterator<FeedbackResponseAttributes> iterResponse = responses.iterator();

            while (iterResponse.hasNext()) {

                FeedbackResponseAttributes response = iterResponse.next();

                if (response.recipient.equals(instructorEmail)) {
                    iterResponse.remove();
                }
            }
        }
    }

    /**
     * Returns a {@link Set} of emails of the instructors who are not displayed
     * to students in the course specified by {@code courseId}.
     *
     * @param courseId
     *            the ID of the course
     */
    private Set<String> getHiddenInstructorEmails(String courseId) {
        List<InstructorAttributes> instructors = instructorsLogic.getInstructorsForCourse(courseId);
        Set<String> hiddenInstructorEmails = new HashSet<>();

        for (InstructorAttributes instructor : instructors) {
            if (!instructor.isDisplayedToStudents()) {
                hiddenInstructorEmails.add(instructor.email);
            }
        }

        return hiddenInstructorEmails;
    }

    /**
     * Gets the response rate status for a session.
     */
    public FeedbackSessionResponseStatus getFeedbackSessionResponseStatus(String feedbackSessionName, String courseId)
            throws EntityDoesNotExistException {

        FeedbackSessionAttributes session = fsDb.getFeedbackSession(
                courseId, feedbackSessionName);

        if (session == null) {
            throw new EntityDoesNotExistException(ERROR_NON_EXISTENT_FS_VIEW + courseId + ""/"" + feedbackSessionName);
        }

        List<FeedbackQuestionAttributes> allQuestions = fqLogic.getFeedbackQuestionsForSession(feedbackSessionName,
                        courseId);

        CourseRoster roster = new CourseRoster(studentsLogic.getStudentsForCourse(courseId),
                                               instructorsLogic.getInstructorsForCourse(courseId));
        return getFeedbackSessionResponseStatus(session, roster, allQuestions);
    }

    /**
     * Gets results of a feedback session to show to an instructor from an indicated question.
     * This will not retrieve the list of comments for this question.
     */
    public FeedbackSessionResultsBundle getFeedbackSessionResultsForInstructorFromQuestion(
            String feedbackSessionName, String courseId, String userEmail, String questionId)
                    throws EntityDoesNotExistException {

        // Load details of students and instructors once and pass it to callee
        // methods
        // (rather than loading them many times).
        CourseRoster roster = new CourseRoster(
                studentsLogic.getStudentsForCourse(courseId),
                instructorsLogic.getInstructorsForCourse(courseId));
        Map<String, String> params = new HashMap<>();
        params.put(PARAM_IS_INCLUDE_RESPONSE_STATUS, ""true"");
        params.put(PARAM_IN_SECTION, ""false"");
        params.put(PARAM_FROM_SECTION, ""false"");
        params.put(PARAM_TO_SECTION, ""false"");
        params.put(PARAM_QUESTION_ID, questionId);

        return getFeedbackSessionResultsForUserWithParams(feedbackSessionName, courseId, userEmail,
                                                          UserRole.INSTRUCTOR, roster, params);
    }

    /**
     * Gets results of a feedback session to show to an instructor from an indicated question
     * and in a section.
     * This will not retrieve the list of comments for this question.
     */
    public FeedbackSessionResultsBundle getFeedbackSessionResultsForInstructorFromQuestionInSection(
                                                String feedbackSessionName, String courseId, String userEmail,
                                                String questionId, String selectedSection)
                                        throws EntityDoesNotExistException {

        CourseRoster roster = new CourseRoster(
                studentsLogic.getStudentsForCourse(courseId),
                instructorsLogic.getInstructorsForCourse(courseId));
        Map<String, String> params = new HashMap<>();
        params.put(PARAM_IS_INCLUDE_RESPONSE_STATUS, ""true"");
        params.put(PARAM_IN_SECTION, ""true"");
        params.put(PARAM_FROM_SECTION, ""false"");
        params.put(PARAM_TO_SECTION, ""false"");
        params.put(PARAM_QUESTION_ID, questionId);
        params.put(PARAM_SECTION, selectedSection);

        return getFeedbackSessionResultsForUserWithParams(feedbackSessionName, courseId, userEmail,
                                                          UserRole.INSTRUCTOR, roster, params);
    }

    /**
     * Gets results of a feedback session to show to an instructor in an indicated range.
     */
    public FeedbackSessionResultsBundle getFeedbackSessionResultsForInstructorWithinRangeFromView(
            String feedbackSessionName, String courseId, String userEmail, int range, String viewType)
            throws EntityDoesNotExistException {

        return getFeedbackSessionResultsForInstructorInSectionWithinRangeFromView(
                feedbackSessionName, courseId, userEmail, null, range, viewType);
    }

    /**
     * Gets results of a feedback session to show to an instructor in a section in an indicated range.
     */
    public FeedbackSessionResultsBundle getFeedbackSessionResultsForInstructorInSectionWithinRangeFromView(
            String feedbackSessionName, String courseId, String userEmail, String section, int range, String viewType)
            throws EntityDoesNotExistException {

        CourseRoster roster = new CourseRoster(
                studentsLogic.getStudentsForCourse(courseId),
                instructorsLogic.getInstructorsForCourse(courseId));
        Map<String, String> params = new HashMap<>();
        params.put(PARAM_IS_INCLUDE_RESPONSE_STATUS, ""true"");
        params.put(PARAM_IN_SECTION, ""true"");
        params.put(PARAM_FROM_SECTION, ""false"");
        params.put(PARAM_TO_SECTION, ""false"");
        params.put(PARAM_SECTION, section);
        if (range > 0) {
            params.put(PARAM_RANGE, String.valueOf(range));
        }
        params.put(PARAM_VIEW_TYPE, viewType);

        return getFeedbackSessionResultsForUserWithParams(feedbackSessionName, courseId, userEmail,
                                                          UserRole.INSTRUCTOR, roster, params);
    }

    /**
     * Gets results of a feedback session to show to an instructor in a section in an indicated range.
     */
    public FeedbackSessionResultsBundle getFeedbackSessionResultsForInstructorFromSectionWithinRange(
            String feedbackSessionName, String courseId, String userEmail, String section, int range)
            throws EntityDoesNotExistException {

        CourseRoster roster = new CourseRoster(
                studentsLogic.getStudentsForCourse(courseId),
                instructorsLogic.getInstructorsForCourse(courseId));
        Map<String, String> params = new HashMap<>();
        params.put(PARAM_IS_INCLUDE_RESPONSE_STATUS, ""true"");
        params.put(PARAM_IN_SECTION, ""false"");
        params.put(PARAM_FROM_SECTION, ""true"");
        params.put(PARAM_TO_SECTION, ""false"");
        params.put(PARAM_SECTION, section);
        if (range > 0) {
            params.put(PARAM_RANGE, String.valueOf(range));
        }
        return getFeedbackSessionResultsForUserWithParams(feedbackSessionName, courseId, userEmail,
                                                          UserRole.INSTRUCTOR, roster, params);
    }

    /**
     * Gets results of a feedback session to show to an instructor in a section in an indicated range.
     */
    public FeedbackSessionResultsBundle getFeedbackSessionResultsForInstructorToSectionWithinRange(
            String feedbackSessionName, String courseId, String userEmail, String section, int range)
            throws EntityDoesNotExistException {

        CourseRoster roster = new CourseRoster(
                studentsLogic.getStudentsForCourse(courseId),
                instructorsLogic.getInstructorsForCourse(courseId));
        Map<String, String> params = new HashMap<>();
        params.put(PARAM_IS_INCLUDE_RESPONSE_STATUS, ""true"");
        params.put(PARAM_IN_SECTION, ""false"");
        params.put(PARAM_FROM_SECTION, ""false"");
        params.put(PARAM_TO_SECTION, ""true"");
        params.put(PARAM_SECTION, section);
        if (range > 0) {
            params.put(PARAM_RANGE, String.valueOf(range));
        }
        return getFeedbackSessionResultsForUserWithParams(feedbackSessionName, courseId, userEmail,
                                                          UserRole.INSTRUCTOR, roster, params);
    }

    /**
     * Gets results of a feedback session to show to an instructor.
     */
    public FeedbackSessionResultsBundle getFeedbackSessionResultsForInstructor(
            String feedbackSessionName, String courseId, String userEmail)
            throws EntityDoesNotExistException {

        return getFeedbackSessionResultsForInstructorInSection(feedbackSessionName, courseId, userEmail, null);
    }

    /**
     * Gets results of a feedback session to show to an instructor for a specific section.
     */
    public FeedbackSessionResultsBundle getFeedbackSessionResultsForInstructorInSection(
            String feedbackSessionName, String courseId, String userEmail,
            String section)
            throws EntityDoesNotExistException {

        CourseRoster roster = new CourseRoster(
                studentsLogic.getStudentsForCourse(courseId),
                instructorsLogic.getInstructorsForCourse(courseId));
        Map<String, String> params = new HashMap<>();
        params.put(PARAM_IS_INCLUDE_RESPONSE_STATUS, ""true"");
        params.put(PARAM_IN_SECTION, ""true"");
        params.put(PARAM_FROM_SECTION, ""false"");
        params.put(PARAM_TO_SECTION, ""false"");
        params.put(PARAM_SECTION, section);
        return getFeedbackSessionResultsForUserWithParams(feedbackSessionName,
                courseId, userEmail, UserRole.INSTRUCTOR, roster, params);
    }

    /**
     * Gets results of  a feedback session to show to an instructor from a specific section.
     */
    public FeedbackSessionResultsBundle getFeedbackSessionResultsForInstructorFromSection(
            String feedbackSessionName, String courseId, String userEmail,
            String section)
            throws EntityDoesNotExistException {

        CourseRoster roster = new CourseRoster(
                studentsLogic.getStudentsForCourse(courseId),
                instructorsLogic.getInstructorsForCourse(courseId));
        Map<String, String> params = new HashMap<>();
        params.put(PARAM_IS_INCLUDE_RESPONSE_STATUS, ""false"");
        params.put(PARAM_IN_SECTION, ""false"");
        params.put(PARAM_FROM_SECTION, ""true"");
        params.put(PARAM_TO_SECTION, ""false"");
        params.put(PARAM_SECTION, section);
        return getFeedbackSessionResultsForUserWithParams(feedbackSessionName,
                courseId, userEmail, UserRole.INSTRUCTOR, roster, params);
    }

    /**
     * Gets results of  a feedback session to show to an instructor to a specific section.
     */
    public FeedbackSessionResultsBundle getFeedbackSessionResultsForInstructorToSection(
            String feedbackSessionName, String courseId, String userEmail,
            String section)
            throws EntityDoesNotExistException {

        CourseRoster roster = new CourseRoster(
                studentsLogic.getStudentsForCourse(courseId),
                instructorsLogic.getInstructorsForCourse(courseId));
        Map<String, String> params = new HashMap<>();
        params.put(PARAM_IS_INCLUDE_RESPONSE_STATUS, ""true"");
        params.put(PARAM_IN_SECTION, ""false"");
        params.put(PARAM_FROM_SECTION, ""false"");
        params.put(PARAM_TO_SECTION, ""true"");
        params.put(PARAM_SECTION, section);
        return getFeedbackSessionResultsForUserWithParams(feedbackSessionName,
                courseId, userEmail, UserRole.INSTRUCTOR, roster, params);
    }

    /**
     * Gets results of a feedback session to show to a student.
     */
    public FeedbackSessionResultsBundle getFeedbackSessionResultsForStudent(
            String feedbackSessionName, String courseId, String userEmail)
            throws EntityDoesNotExistException {
        return getFeedbackSessionResultsForUserInSectionByQuestions(
                feedbackSessionName, courseId, userEmail,
                UserRole.STUDENT, null);
    }

    /**
     * Gets results of a feedback session to show to a student.
     */
    public FeedbackSessionResultsBundle getFeedbackSessionResultsForStudent(
            String feedbackSessionName, String courseId, String userEmail, CourseRoster roster)
            throws EntityDoesNotExistException {
        return getFeedbackSessionResultsForUserInSectionByQuestions(
                feedbackSessionName, courseId, userEmail,
                UserRole.STUDENT, null, roster);
    }

    public String getFeedbackSessionResultsSummaryAsCsv(
            String feedbackSessionName, String courseId, String userEmail,
            String questionId, boolean isMissingResponsesShown, boolean isStatsShown)
            throws EntityDoesNotExistException, ExceedingRangeException {

        return getFeedbackSessionResultsSummaryInSectionAsCsv(
                feedbackSessionName, courseId, userEmail, null, questionId,
                isMissingResponsesShown, isStatsShown);
    }

    public String getFeedbackSessionResultsSummaryInSectionAsCsv(
            String feedbackSessionName, String courseId, String userEmail,
            String section, String questionId, boolean isMissingResponsesShown, boolean isStatsShown)
            throws EntityDoesNotExistException, ExceedingRangeException {

        FeedbackSessionResultsBundle results;
        int indicatedRange = section == null ? Const.INSTRUCTOR_VIEW_RESPONSE_LIMIT : -1;

        if (questionId == null) {
            results = getFeedbackSessionResultsForInstructorInSectionWithinRangeFromView(
                feedbackSessionName, courseId, userEmail, section,
                indicatedRange, Const.FeedbackSessionResults.GRQ_SORT_TYPE);
        } else if (section == null) {
            results = getFeedbackSessionResultsForInstructorFromQuestion(
                    feedbackSessionName, courseId, userEmail, questionId);
        } else {
            results = getFeedbackSessionResultsForInstructorFromQuestionInSection(
                    feedbackSessionName, courseId, userEmail, questionId, section);
        }

        if (!results.isComplete) {
            throw new ExceedingRangeException(ERROR_NUMBER_OF_RESPONSES_EXCEEDS_RANGE);
        }
        // sort responses by giver > recipient > qnNumber
        Collections.sort(results.responses,
                results.compareByGiverRecipientQuestion);

        StringBuilder exportBuilder = new StringBuilder(100);

        exportBuilder.append(String.format(""Course,%s"",
                             SanitizationHelper.sanitizeForCsv(results.feedbackSession.getCourseId())))
                     .append(Const.EOL)
                     .append(String.format(""Session Name,%s"",
                             SanitizationHelper.sanitizeForCsv(results.feedbackSession.getFeedbackSessionName())))
                     .append(Const.EOL);

        if (section != null) {
            exportBuilder.append(String.format(""Section Name,%s"", SanitizationHelper.sanitizeForCsv(section)))
                         .append(Const.EOL);
        }

        exportBuilder.append(Const.EOL).append(Const.EOL);

        Set<Entry<FeedbackQuestionAttributes, List<FeedbackResponseAttributes>>> entrySet =
                results.getQuestionResponseMap().entrySet();

        for (Map.Entry<FeedbackQuestionAttributes, List<FeedbackResponseAttributes>> entry : entrySet) {
            exportBuilder.append(getFeedbackSessionResultsForQuestionInCsvFormat(
                    results, entry, isMissingResponsesShown, isStatsShown));
        }

        return exportBuilder.toString();
    }

    private StringBuilder getFeedbackSessionResultsForQuestionInCsvFormat(
            FeedbackSessionResultsBundle fsrBundle,
            Map.Entry<FeedbackQuestionAttributes, List<FeedbackResponseAttributes>> entry,
            boolean isMissingResponsesShown, boolean isStatsShown) {

        FeedbackQuestionAttributes question = entry.getKey();
        FeedbackQuestionDetails questionDetails = question.getQuestionDetails();
        List<FeedbackResponseAttributes> allResponses = entry.getValue();

        StringBuilder exportBuilder = new StringBuilder();

        exportBuilder.append(""Question "" + Integer.toString(question.questionNumber) + "",""
                + SanitizationHelper.sanitizeForCsv(questionDetails.getQuestionText())
                + Const.EOL + Const.EOL);

        String statistics = questionDetails.getQuestionResultStatisticsCsv(allResponses,
                                    question, fsrBundle);
        if (!statistics.isEmpty() && isStatsShown) {
            exportBuilder.append(""Summary Statistics,"").append(Const.EOL);
            exportBuilder.append(statistics).append(Const.EOL);
        }

        List<String> possibleGiversWithoutResponses = fsrBundle.getPossibleGivers(question);
        List<String> possibleRecipientsForGiver = new ArrayList<>();
        String prevGiver = """";

        int maxNumOfResponseComments = getMaxNumberOfResponseComments(allResponses, fsrBundle.getResponseComments());
        exportBuilder.append(questionDetails.getCsvDetailedResponsesHeader(maxNumOfResponseComments));

        for (FeedbackResponseAttributes response : allResponses) {

            if (!fsrBundle.isRecipientVisible(response) || !fsrBundle.isGiverVisible(response)) {
                possibleGiversWithoutResponses.clear();
                possibleRecipientsForGiver.clear();
            }

            // keep track of possible recipients with no responses
            removeParticipantIdentifierFromList(question.giverType,
                    possibleGiversWithoutResponses, response.giver, fsrBundle);

            boolean isNewGiver = !prevGiver.equals(response.giver);
            // print missing responses from the current giver
            if (isNewGiver) {
                exportBuilder.append(getRowsOfPossibleRecipientsInCsvFormat(fsrBundle,
                        question, questionDetails,
                        possibleRecipientsForGiver, prevGiver));
                String giverIdentifier = question.giverType == FeedbackParticipantType.TEAMS
                                             ? fsrBundle.getFullNameFromRoster(response.giver)
                                             : response.giver;

                possibleRecipientsForGiver = fsrBundle.getPossibleRecipients(question, giverIdentifier);
            }

            removeParticipantIdentifierFromList(question.recipientType, possibleRecipientsForGiver,
                                                response.recipient, fsrBundle);
            prevGiver = response.giver;

            // do not show all possible givers and recipients if there are anonymous givers and recipients
            boolean hasCommentsForResponses = fsrBundle.responseComments.containsKey(response.getId());

            exportBuilder.append(questionDetails.getCsvDetailedResponsesRow(fsrBundle, response, question,
                    hasCommentsForResponses));
        }

        // add the rows for the possible givers and recipients who have missing responses
        if (isMissingResponsesShown) {
            exportBuilder.append(
                    getRemainingRowsInCsvFormat(
                            fsrBundle, entry, question, questionDetails,
                            possibleGiversWithoutResponses, possibleRecipientsForGiver, prevGiver));
        }

        exportBuilder.append(Const.EOL + Const.EOL);
        return exportBuilder;
    }

    private int getMaxNumberOfResponseComments(List<FeedbackResponseAttributes> allResponses,
            Map<String, List<FeedbackResponseCommentAttributes>> responseComments) {

        if (allResponses == null || allResponses.isEmpty()) {
            return 0;
        }

        int maxCommentsNum = 0;
        for (FeedbackResponseAttributes response : allResponses) {
            List<FeedbackResponseCommentAttributes> commentAttributes = responseComments.get(response.getId());
            if (commentAttributes != null && maxCommentsNum < commentAttributes.size()) {
                maxCommentsNum = commentAttributes.size();
            }
        }

        return maxCommentsNum;
    }

    /**
     * Given a participantIdentifier, remove it from participantIdentifierList.
     *
     * <p>Before removal, {@link FeedbackSessionResultsBundle#getFullNameFromRoster} is used to
     * convert the identifier into a canonical form if the participantIdentifierType is TEAMS.
     */
    private void removeParticipantIdentifierFromList(
            FeedbackParticipantType participantIdentifierType,
            List<String> participantIdentifierList, String participantIdentifier,
            FeedbackSessionResultsBundle bundle) {
        if (participantIdentifierType == FeedbackParticipantType.TEAMS) {
            participantIdentifierList.remove(bundle.getFullNameFromRoster(participantIdentifier));
        } else {
            participantIdentifierList.remove(participantIdentifier);
        }
    }

    /**
     * Generate rows of missing responses for the remaining possible givers and recipients.
     *
     * <p>If for the prevGiver, possibleRecipientsForGiver is not empty,
     * the remaining missing responses for the prevGiver will be generated first.
     * @return the remaining rows of missing responses in csv format
     */
    private StringBuilder getRemainingRowsInCsvFormat(
            FeedbackSessionResultsBundle results,
            Map.Entry<FeedbackQuestionAttributes, List<FeedbackResponseAttributes>> entry,
            FeedbackQuestionAttributes question,
            FeedbackQuestionDetails questionDetails,
            List<String> remainingPossibleGivers,
            List<String> possibleRecipientsForGiver, String prevGiver) {
        StringBuilder exportBuilder = new StringBuilder();

        if (possibleRecipientsForGiver != null) {
            exportBuilder.append(getRowsOfPossibleRecipientsInCsvFormat(results,
                    question, questionDetails, possibleRecipientsForGiver,
                    prevGiver));

        }

        removeParticipantIdentifierFromList(question.giverType, remainingPossibleGivers, prevGiver, results);

        for (String possibleGiverWithNoResponses : remainingPossibleGivers) {
            List<String> possibleRecipientsForRemainingGiver =
                    results.getPossibleRecipients(entry.getKey(), possibleGiverWithNoResponses);

            exportBuilder.append(getRowsOfPossibleRecipientsInCsvFormat(results,
                    question, questionDetails, possibleRecipientsForRemainingGiver,
                    possibleGiverWithNoResponses));
        }

        return exportBuilder;
    }

    /**
     * For a giver and a list of possibleRecipientsForGiver, generate rows
     * of missing responses between the giver and the possible recipients.
     */
    private StringBuilder getRowsOfPossibleRecipientsInCsvFormat(
            FeedbackSessionResultsBundle results,
            FeedbackQuestionAttributes question,
            FeedbackQuestionDetails questionDetails,
            List<String> possibleRecipientsForGiver, String giver) {
        StringBuilder exportBuilder = new StringBuilder();
        for (String possibleRecipient : possibleRecipientsForGiver) {
            String giverName = results.getFullNameFromRoster(giver);
            String giverLastName = results.getLastNameFromRoster(giver);
            String giverEmail = results.getDisplayableEmailFromRoster(giver);
            String possibleRecipientName = results.getFullNameFromRoster(possibleRecipient);
            String possibleRecipientLastName = results.getLastNameFromRoster(possibleRecipient);
            String possibleRecipientEmail = results.getDisplayableEmailFromRoster(possibleRecipient);

            if (questionDetails.shouldShowNoResponseText(question)) {
                exportBuilder.append(SanitizationHelper.sanitizeForCsv(results.getTeamNameFromRoster(giver))
                        + "","" + SanitizationHelper.sanitizeForCsv(StringHelper.removeExtraSpace(giverName))
                        + "","" + SanitizationHelper.sanitizeForCsv(StringHelper.removeExtraSpace(giverLastName))
                        + "","" + SanitizationHelper.sanitizeForCsv(StringHelper.removeExtraSpace(giverEmail))
                        + "","" + SanitizationHelper.sanitizeForCsv(results.getTeamNameFromRoster(possibleRecipient))
                        + "","" + SanitizationHelper.sanitizeForCsv(StringHelper.removeExtraSpace(possibleRecipientName))
                        + "","" + SanitizationHelper.sanitizeForCsv(StringHelper.removeExtraSpace(possibleRecipientLastName))
                        + "","" + SanitizationHelper.sanitizeForCsv(StringHelper.removeExtraSpace(possibleRecipientEmail))
                        + "","" + questionDetails.getNoResponseTextInCsv(giver, possibleRecipient, results, question)
                        + Const.EOL);
            }
        }
        return exportBuilder;
    }

    /**
     * Criteria: must be published, publishEmail must be enabled and
     * resultsVisibleTime must be custom.
     *
     * @return returns a list of sessions that require automated emails to be
     *         sent as they are published
     */
    public List<FeedbackSessionAttributes> getFeedbackSessionsWhichNeedAutomatedPublishedEmailsToBeSent() {
        List<FeedbackSessionAttributes> sessions =
                fsDb.getFeedbackSessionsPossiblyNeedingPublishedEmail();
        List<FeedbackSessionAttributes> sessionsToSendEmailsFor = new ArrayList<>();

        for (FeedbackSessionAttributes session : sessions) {
            // automated emails are required only for custom publish times
            if (session.isPublished() && !TimeHelper.isSpecialTime(session.getResultsVisibleFromTime())) {
                sessionsToSendEmailsFor.add(session);
            }
        }
        return sessionsToSendEmailsFor;
    }

    public List<FeedbackSessionAttributes> getFeedbackSessionsWhichNeedOpenEmailsToBeSent() {
        List<FeedbackSessionAttributes> sessions =
                fsDb.getFeedbackSessionsPossiblyNeedingOpenEmail();
        List<FeedbackSessionAttributes> sessionsToSendEmailsFor = new ArrayList<>();

        for (FeedbackSessionAttributes session : sessions) {
            if (session.getFeedbackSessionType() != FeedbackSessionType.PRIVATE && session.isOpened()) {
                sessionsToSendEmailsFor.add(session);
            }
        }
        return sessionsToSendEmailsFor;
    }

    public boolean isCreatorOfSession(String feedbackSessionName, String courseId, String userEmail) {
        FeedbackSessionAttributes fs = getFeedbackSession(feedbackSessionName, courseId);
        return fs.getCreatorEmail().equals(userEmail);
    }

    public boolean isFeedbackSessionExists(String feedbackSessionName, String courseId) {
        return fsDb.getFeedbackSession(courseId, feedbackSessionName) != null;
    }

    public boolean isFeedbackSessionHasQuestionForStudents(
            String feedbackSessionName,
            String courseId) throws EntityDoesNotExistException {
        if (!isFeedbackSessionExists(feedbackSessionName, courseId)) {
            throw new EntityDoesNotExistException(ERROR_NON_EXISTENT_FS_CHECK + courseId + ""/"" + feedbackSessionName);
        }

        List<FeedbackQuestionAttributes> allQuestions =
                fqLogic.getFeedbackQuestionsForStudents(feedbackSessionName,
                        courseId);

        return !allQuestions.isEmpty();
    }

    public boolean isFeedbackSessionCompletedByStudent(FeedbackSessionAttributes fsa, String userEmail) {
        if (fsa.getRespondingStudentList().contains(userEmail)) {
            return true;
        }

        String feedbackSessionName = fsa.getFeedbackSessionName();
        String courseId = fsa.getCourseId();
        List<FeedbackQuestionAttributes> allQuestions =
                fqLogic.getFeedbackQuestionsForStudents(feedbackSessionName, courseId);
        // if there is no question for students, session is complete
        return allQuestions.isEmpty();
    }

    public boolean isFeedbackSessionCompletedByInstructor(FeedbackSessionAttributes fsa, String userEmail)
            throws EntityDoesNotExistException {
        if (fsa.getRespondingInstructorList().contains(userEmail)) {
            return true;
        }

        String feedbackSessionName = fsa.getFeedbackSessionName();
        String courseId = fsa.getCourseId();
        List<FeedbackQuestionAttributes> allQuestions =
                fqLogic.getFeedbackQuestionsForInstructor(feedbackSessionName, courseId, userEmail);
        // if there is no question for instructor, session is complete
        return allQuestions.isEmpty();
    }

    public void updateFeedbackSession(FeedbackSessionAttributes newSession)
            throws InvalidParametersException, EntityDoesNotExistException {

        Assumption.assertNotNull(Const.StatusCodes.NULL_PARAMETER, newSession);

        FeedbackSessionAttributes oldSession =
                fsDb.getFeedbackSession(newSession.getCourseId(),
                        newSession.getFeedbackSessionName());

        if (oldSession == null) {
            throw new EntityDoesNotExistException(ERROR_NON_EXISTENT_FS_UPDATE + newSession.getCourseId()
                                                  + ""/"" + newSession.getFeedbackSessionName());
        }

        // These can't be changed anyway. Copy values to defensively avoid
        // invalid parameters.
        newSession.setCreatorEmail(oldSession.getCreatorEmail());
        newSession.setCreatedTime(oldSession.getCreatedTime());

        if (newSession.getInstructions() == null) {
            newSession.setInstructions(oldSession.getInstructions());
        }
        if (newSession.getStartTime() == null) {
            newSession.setStartTime(oldSession.getStartTime());
        }
        if (newSession.getEndTime() == null) {
            newSession.setEndTime(oldSession.getEndTime());
        }
        if (newSession.getFeedbackSessionType() == null) {
            newSession.setFeedbackSessionType(oldSession.getFeedbackSessionType());
        }
        if (newSession.getSessionVisibleFromTime() == null) {
            newSession.setSessionVisibleFromTime(oldSession.getSessionVisibleFromTime());
        }
        if (newSession.getResultsVisibleFromTime() == null) {
            newSession.setResultsVisibleFromTime(oldSession.getResultsVisibleFromTime());
        }

        makeEmailStateConsistent(oldSession, newSession);

        fsDb.updateFeedbackSession(newSession);
    }

    public void updateRespondentsForInstructor(String oldEmail, String newEmail, String courseId)
            throws InvalidParametersException, EntityDoesNotExistException {

        List<FeedbackSessionAttributes> feedbackSessions = getFeedbackSessionsForCourse(courseId);
        for (FeedbackSessionAttributes session : feedbackSessions) {
            fsDb.updateInstructorRespondent(oldEmail, newEmail, session);
        }
    }

    public void updateRespondentsForStudent(String oldEmail, String newEmail, String courseId)
            throws InvalidParametersException, EntityDoesNotExistException {

        List<FeedbackSessionAttributes> feedbackSessions = getFeedbackSessionsForCourse(courseId);
        for (FeedbackSessionAttributes session : feedbackSessions) {
            fsDb.updateStudentRespondent(oldEmail, newEmail, session);
        }
    }

    public void updateRespondentsForSession(String feedbackSessionName, String courseId)
            throws InvalidParametersException, EntityDoesNotExistException {

        clearInstructorRespondents(feedbackSessionName, courseId);
        clearStudentRespondents(feedbackSessionName, courseId);

        FeedbackSessionAttributes fsa = getFeedbackSession(feedbackSessionName, courseId);
        List<FeedbackQuestionAttributes> questions = fqLogic.getFeedbackQuestionsForSession(feedbackSessionName, courseId);
        List<InstructorAttributes> instructors = instructorsLogic.getInstructorsForCourse(courseId);

        Map<String, List<String>> instructorQuestionsMap = new HashMap<>();

        for (InstructorAttributes instructor : instructors) {
            List<FeedbackQuestionAttributes> instructorQns = fqLogic
                    .getFeedbackQuestionsForInstructor(questions,
                            fsa.isCreator(instructor.email));

            if (!instructorQns.isEmpty()) {
                List<String> questionIds = new ArrayList<>();
                for (FeedbackQuestionAttributes question : instructorQns) {
                    questionIds.add(question.getId());
                }
                instructorQuestionsMap.put(instructor.email, questionIds);
            }
        }

        Set<String> respondingStudentList = new HashSet<>();
        Set<String> respondingInstructorList = new HashSet<>();
        List<FeedbackResponseAttributes> responses = frLogic.getFeedbackResponsesForSession(feedbackSessionName, courseId);
        for (FeedbackResponseAttributes response : responses) {
            List<String> instructorQuestions = instructorQuestionsMap.get(response.giver);
            if (instructorQuestions != null && instructorQuestions.contains(response.feedbackQuestionId)) {
                respondingInstructorList.add(response.giver);
            } else {
                respondingStudentList.add(response.giver);
            }
        }

        addInstructorRespondents(new ArrayList<>(respondingInstructorList), feedbackSessionName, courseId);
        addStudentRespondents(new ArrayList<>(respondingStudentList), feedbackSessionName, courseId);
    }

    public void deleteInstructorFromRespondentsList(InstructorAttributes instructor) {
        if (instructor == null || instructor.email == null) {
            return;
        }
        List<FeedbackSessionAttributes> sessionsToUpdate =
                fsDb.getFeedbackSessionsForCourse(instructor.courseId);

        for (FeedbackSessionAttributes session : sessionsToUpdate) {
            try {
                deleteInstructorRespondent(instructor.email, session.getFeedbackSessionName(), session.getCourseId());
            } catch (InvalidParametersException | EntityDoesNotExistException e) {
                Assumption.fail(ASSUMPTION_FAIL_DELETE_INSTRUCTOR + session.getFeedbackSessionName());
            }
        }
    }

    public void deleteStudentFromRespondentsList(StudentAttributes student) {
        if (student == null || student.email == null) {
            return;
        }
        List<FeedbackSessionAttributes> sessionsToUpdate =
                fsDb.getFeedbackSessionsForCourse(student.course);

        for (FeedbackSessionAttributes session : sessionsToUpdate) {
            try {
                deleteStudentFromRespondentList(student.email, session.getFeedbackSessionName(), session.getCourseId());
            } catch (InvalidParametersException | EntityDoesNotExistException e) {
                Assumption.fail(ASSUMPTION_FAIL_DELETE_INSTRUCTOR + session.getFeedbackSessionName());
            }
        }
    }

    public void addInstructorRespondent(String email, String feedbackSessionName, String courseId)
            throws EntityDoesNotExistException, InvalidParametersException {

        Assumption.assertNotNull(Const.StatusCodes.NULL_PARAMETER, feedbackSessionName);
        Assumption.assertNotNull(Const.StatusCodes.NULL_PARAMETER, courseId);
        Assumption.assertNotNull(Const.StatusCodes.NULL_PARAMETER, email);

        FeedbackSessionAttributes sessionToUpdate = getFeedbackSession(feedbackSessionName, courseId);
        if (sessionToUpdate == null) {
            throw new EntityDoesNotExistException(ERROR_NON_EXISTENT_FS_UPDATE + courseId + ""/"" + feedbackSessionName);
        }

        fsDb.addInstructorRespondent(email, sessionToUpdate);
    }

    public void addInstructorRespondents(List<String> emails, String feedbackSessionName, String courseId)
            throws EntityDoesNotExistException, InvalidParametersException {

        Assumption.assertNotNull(Const.StatusCodes.NULL_PARAMETER, feedbackSessionName);
        Assumption.assertNotNull(Const.StatusCodes.NULL_PARAMETER, courseId);
        Assumption.assertNotNull(Const.StatusCodes.NULL_PARAMETER, emails);

        FeedbackSessionAttributes sessionToUpdate = getFeedbackSession(feedbackSessionName, courseId);
        if (sessionToUpdate == null) {
            throw new EntityDoesNotExistException(ERROR_NON_EXISTENT_FS_UPDATE + courseId + ""/"" + feedbackSessionName);
        }

        fsDb.addInstructorRespondents(emails, sessionToUpdate);
    }

    public void clearInstructorRespondents(String feedbackSessionName, String courseId)
            throws EntityDoesNotExistException, InvalidParametersException {

        Assumption.assertNotNull(Const.StatusCodes.NULL_PARAMETER, feedbackSessionName);
        Assumption.assertNotNull(Const.StatusCodes.NULL_PARAMETER, courseId);

        FeedbackSessionAttributes sessionToUpdate = getFeedbackSession(feedbackSessionName, courseId);
        if (sessionToUpdate == null) {
            throw new EntityDoesNotExistException(ERROR_NON_EXISTENT_FS_UPDATE + courseId + ""/"" + feedbackSessionName);
        }

        fsDb.clearInstructorRespondents(sessionToUpdate);
    }

    public void addStudentRespondent(String email, String feedbackSessionName, String courseId)
            throws EntityDoesNotExistException, InvalidParametersException {

        Assumption.assertNotNull(Const.StatusCodes.NULL_PARAMETER, feedbackSessionName);
        Assumption.assertNotNull(Const.StatusCodes.NULL_PARAMETER, courseId);
        Assumption.assertNotNull(Const.StatusCodes.NULL_PARAMETER, email);

        FeedbackSessionAttributes sessionToUpdate = getFeedbackSession(feedbackSessionName, courseId);
        if (sessionToUpdate == null) {
            throw new EntityDoesNotExistException(ERROR_NON_EXISTENT_FS_UPDATE + courseId + ""/"" + feedbackSessionName);
        }

        fsDb.addStudentRespondent(email, sessionToUpdate);
    }

    public void addStudentRespondents(List<String> emails, String feedbackSessionName, String courseId)
            throws EntityDoesNotExistException, InvalidParametersException {

        Assumption.assertNotNull(Const.StatusCodes.NULL_PARAMETER, feedbackSessionName);
        Assumption.assertNotNull(Const.StatusCodes.NULL_PARAMETER, courseId);
        Assumption.assertNotNull(Const.StatusCodes.NULL_PARAMETER, emails);

        FeedbackSessionAttributes sessionToUpdate = getFeedbackSession(feedbackSessionName, courseId);
        if (sessionToUpdate == null) {
            throw new EntityDoesNotExistException(ERROR_NON_EXISTENT_FS_UPDATE + courseId + ""/"" + feedbackSessionName);
        }

        fsDb.addStudentRespondents(emails, sessionToUpdate);
    }

    public void clearStudentRespondents(String feedbackSessionName, String courseId)
            throws EntityDoesNotExistException, InvalidParametersException {

        Assumption.assertNotNull(Const.StatusCodes.NULL_PARAMETER, feedbackSessionName);
        Assumption.assertNotNull(Const.StatusCodes.NULL_PARAMETER, courseId);

        FeedbackSessionAttributes sessionToUpdate = getFeedbackSession(feedbackSessionName, courseId);
        if (sessionToUpdate == null) {
            throw new EntityDoesNotExistException(ERROR_NON_EXISTENT_FS_UPDATE + courseId + ""/"" + feedbackSessionName);
        }

        fsDb.clearStudentRespondents(sessionToUpdate);
    }

    public void deleteInstructorRespondent(String email, String feedbackSessionName, String courseId)
            throws EntityDoesNotExistException, InvalidParametersException {

        Assumption.assertNotNull(Const.StatusCodes.NULL_PARAMETER, feedbackSessionName);
        Assumption.assertNotNull(Const.StatusCodes.NULL_PARAMETER, courseId);
        Assumption.assertNotNull(Const.StatusCodes.NULL_PARAMETER, email);

        FeedbackSessionAttributes sessionToUpdate = getFeedbackSession(feedbackSessionName, courseId);
        if (sessionToUpdate == null) {
            throw new EntityDoesNotExistException(ERROR_NON_EXISTENT_FS_UPDATE + courseId + ""/"" + feedbackSessionName);
        }

        fsDb.deleteInstructorRespondent(email, sessionToUpdate);
    }

    public void deleteStudentFromRespondentList(String email, String feedbackSessionName, String courseId)
            throws EntityDoesNotExistException, InvalidParametersException {

        Assumption.assertNotNull(Const.StatusCodes.NULL_PARAMETER, feedbackSessionName);
        Assumption.assertNotNull(Const.StatusCodes.NULL_PARAMETER, courseId);
        Assumption.assertNotNull(Const.StatusCodes.NULL_PARAMETER, email);

        FeedbackSessionAttributes sessionToUpdate = getFeedbackSession(feedbackSessionName, courseId);
        if (sessionToUpdate == null) {
            throw new EntityDoesNotExistException(ERROR_NON_EXISTENT_FS_UPDATE + courseId + ""/"" + feedbackSessionName);
        }

        fsDb.deleteStudentRespondent(email, sessionToUpdate);
    }

    /**
     * This method is called when the user publishes a feedback session
     * manually. Preconditions: * The feedback session has to be set as
     * manually/automatically published. The feedback session can't be private
     */
    public void publishFeedbackSession(FeedbackSessionAttributes sessionToPublish)
            throws EntityDoesNotExistException, InvalidParametersException {
        if (sessionToPublish.isPrivateSession()) {
            throw new InvalidParametersException(ERROR_FS_PRIVATE_PUBLISH);
        }

        if (sessionToPublish.isPublished()) {
            throw new InvalidParametersException(ERROR_FS_ALREADY_PUBLISH);
        }

        sessionToPublish.setResultsVisibleFromTime(currentDateTime(sessionToPublish));
        updateFeedbackSession(sessionToPublish);
    }

    private Date currentDateTime(FeedbackSessionAttributes sessionToPublish) {
        Calendar now = TimeHelper.now(sessionToPublish.getTimeZone());
        return now.getTime();
    }

    /**
     * This method is called when the user unpublishes a feedback session
     * manually. Preconditions: * The feedback session has to be set as manually
     * published.
     */
    public void unpublishFeedbackSession(FeedbackSessionAttributes sessionToUnpublish)
            throws EntityDoesNotExistException, InvalidParametersException {
        if (sessionToUnpublish.isPrivateSession()) {
            throw new InvalidParametersException(ERROR_FS_PRIVATE_UNPUBLISH);
        }

        if (!sessionToUnpublish.isPublished()) {
            throw new InvalidParametersException(ERROR_FS_ALREADY_UNPUBLISH);
        }

        sessionToUnpublish.setResultsVisibleFromTime(Const.TIME_REPRESENTS_LATER);
        updateFeedbackSession(sessionToUnpublish);
    }

    public List<FeedbackSessionAttributes> getFeedbackSessionsClosingWithinTimeLimit() {
        ArrayList<FeedbackSessionAttributes> requiredSessions = new ArrayList<>();

        List<FeedbackSessionAttributes> nonPrivateSessions =
                fsDb.getFeedbackSessionsPossiblyNeedingClosingEmail();

        for (FeedbackSessionAttributes session : nonPrivateSessions) {
            if (session.getFeedbackSessionType() != FeedbackSessionType.PRIVATE
                    && session.isClosingWithinTimeLimit(SystemParams.NUMBER_OF_HOURS_BEFORE_CLOSING_ALERT)) {
                requiredSessions.add(session);
            }
        }

        return requiredSessions;
    }

    /**
     * Returns returns a list of sessions that were closed within past hour.
     */
    public List<FeedbackSessionAttributes> getFeedbackSessionsClosedWithinThePastHour() {
        List<FeedbackSessionAttributes> requiredSessions = new ArrayList<>();
        List<FeedbackSessionAttributes> nonPrivateSessions =
                fsDb.getFeedbackSessionsPossiblyNeedingClosedEmail();

        for (FeedbackSessionAttributes session : nonPrivateSessions) {
            // is session closed in the past 1 hour
            if (session.getFeedbackSessionType() != FeedbackSessionType.PRIVATE
                    && session.isClosedWithinPastHour()) {
                requiredSessions.add(session);
            }
        }
        return requiredSessions;
    }

    /**
     * Deletes the feedback sessions in the course specified. The delete
     * is cascaded, and feedback questions, feedback responses, and
     * feedback response comments in the course are deleted.
     */
    public void deleteFeedbackSessionsForCourseCascade(String courseId) {
        frcLogic.deleteFeedbackResponseCommentsForCourse(courseId);
        frLogic.deleteFeedbackResponsesForCourse(courseId);
        fqLogic.deleteFeedbackQuestionsForCourse(courseId);
        deleteFeedbackSessionsForCourse(courseId);
    }

    /**
     * Deletes all feedback sessions the course specified. This is
     * a non-cascade delete.
     *
     * <p>The responses, questions and the comments of the responses
     * should be handled.
     */
    public void deleteFeedbackSessionsForCourse(String courseId) {
        fsDb.deleteFeedbackSessionsForCourse(courseId);
    }

    /**
     * Deletes a specific feedback session, and all its question and responses.
     */
    public void deleteFeedbackSessionCascade(String feedbackSessionName, String courseId) {

        try {
            fqLogic.deleteFeedbackQuestionsForSession(feedbackSessionName, courseId);
        } catch (EntityDoesNotExistException e) {
            // Silently fail if session does not exist
            log.warning(TeammatesException.toStringWithStackTrace(e));
        }

        FeedbackSessionAttributes sessionToDelete = new FeedbackSessionAttributes();
        sessionToDelete.setFeedbackSessionName(feedbackSessionName);
        sessionToDelete.setCourseId(courseId);

        fsDb.deleteEntity(sessionToDelete);

    }

    public FeedbackSessionDetailsBundle getFeedbackSessionDetails(
            FeedbackSessionAttributes fsa) throws EntityDoesNotExistException {

        FeedbackSessionDetailsBundle details =
                new FeedbackSessionDetailsBundle(fsa);

        details.stats.expectedTotal = 0;
        details.stats.submittedTotal = 0;

        switch (fsa.getFeedbackSessionType()) {
        case STANDARD:
            List<StudentAttributes> students = studentsLogic.getStudentsForCourse(fsa.getCourseId());
            List<InstructorAttributes> instructors = instructorsLogic.getInstructorsForCourse(fsa.getCourseId());
            List<FeedbackQuestionAttributes> questions =
                    fqLogic.getFeedbackQuestionsForSession(fsa.getFeedbackSessionName(), fsa.getCourseId());
            List<FeedbackQuestionAttributes> studentQns = fqLogic.getFeedbackQuestionsForStudents(questions);

            if (!studentQns.isEmpty()) {
                details.stats.expectedTotal += students.size();
            }

            for (InstructorAttributes instructor : instructors) {
                List<FeedbackQuestionAttributes> instructorQns =
                        fqLogic.getFeedbackQuestionsForInstructor(questions, fsa.isCreator(instructor.email));
                if (!instructorQns.isEmpty()) {
                    details.stats.expectedTotal += 1;
                }
            }

            details.stats.submittedTotal += fsa.getRespondingStudentList().size() + fsa.getRespondingInstructorList().size();

            break;

        case PRIVATE:
            List<FeedbackQuestionAttributes> instructorQuestions =
                    fqLogic.getFeedbackQuestionsForInstructor(fsa.getFeedbackSessionName(),
                                                              fsa.getCourseId(),
                                                              fsa.getCreatorEmail());
            List<FeedbackQuestionAttributes> validQuestions =
                    fqLogic.getQuestionsWithRecipients(instructorQuestions, fsa.getCreatorEmail());
            if (validQuestions.isEmpty()) {
                break;
            }
            details.stats.expectedTotal = 1;
            if (isFeedbackSessionFullyCompletedByInstructor(fsa.getFeedbackSessionName(),
                                                            fsa.getCourseId(),
                                                            fsa.getCreatorEmail())) {
                details.stats.submittedTotal = 1;
            }
            break;

        default:
            break;
        }

        return details;
    }

    /* Get the feedback results for user in a section iterated by questions */
    private FeedbackSessionResultsBundle getFeedbackSessionResultsForUserInSectionByQuestions(
            String feedbackSessionName, String courseId, String userEmail,
            UserRole role, String section)
            throws EntityDoesNotExistException {
        // Load details of students and instructors once and pass it to callee
        // methods
        // (rather than loading them many times).
        CourseRoster roster = new CourseRoster(
                studentsLogic.getStudentsForCourse(courseId),
                instructorsLogic.getInstructorsForCourse(courseId));

        return getFeedbackSessionResultsForUserInSectionByQuestions(
                feedbackSessionName, courseId, userEmail, role, section, roster);
    }

    /* Get the feedback results for user in a section iterated by questions */
    private FeedbackSessionResultsBundle getFeedbackSessionResultsForUserInSectionByQuestions(
            String feedbackSessionName, String courseId, String userEmail,
            UserRole role, String section, CourseRoster roster)
            throws EntityDoesNotExistException {

        FeedbackSessionAttributes session = fsDb.getFeedbackSession(
                courseId, feedbackSessionName);

        if (session == null) {
            throw new EntityDoesNotExistException(ERROR_NON_EXISTENT_FS_VIEW + courseId + ""/"" + feedbackSessionName);
        }

        // create empty data containers to store results
        List<FeedbackResponseAttributes> responses = new ArrayList<>();
        Map<String, FeedbackQuestionAttributes> relevantQuestions = new HashMap<>();
        Map<String, String> emailNameTable = new HashMap<>();
        Map<String, String> emailLastNameTable = new HashMap<>();
        Map<String, String> emailTeamNameTable = new HashMap<>();
        Map<String, Set<String>> sectionTeamNameTable = new HashMap<>();
        Map<String, boolean[]> visibilityTable = new HashMap<>();
        Map<String, List<FeedbackResponseCommentAttributes>> responseComments = new HashMap<>();

        FeedbackSessionResponseStatus responseStatus = new FeedbackSessionResponseStatus();

        boolean isPrivateSessionNotCreatedByThisUser = session
                .isPrivateSession() && !session.isCreator(userEmail);
        if (isPrivateSessionNotCreatedByThisUser) {
            // return empty result set
            return new FeedbackSessionResultsBundle(
                    session, responses, relevantQuestions, emailNameTable,
                    emailLastNameTable, emailTeamNameTable, sectionTeamNameTable,
                    visibilityTable, responseStatus, roster, responseComments);
        }

        List<FeedbackQuestionAttributes> allQuestions = fqLogic.getFeedbackQuestionsForSession(
                                                                    feedbackSessionName, courseId);
        Map<String, FeedbackResponseAttributes> relevantResponse = new HashMap<>();
        for (FeedbackQuestionAttributes question : allQuestions) {

            List<FeedbackResponseAttributes> responsesForThisQn;

            boolean isPrivateSessionCreatedByThisUser = session
                    .isCreator(userEmail) && session.isPrivateSession();
            if (isPrivateSessionCreatedByThisUser) {
                responsesForThisQn = frLogic
                        .getFeedbackResponsesForQuestion(question.getId());
            } else {
                responsesForThisQn = frLogic
                        .getViewableFeedbackResponsesForQuestionInSection(
                                question, userEmail, role, section);
            }

            boolean hasResponses = !responsesForThisQn.isEmpty();
            if (hasResponses) {
                relevantQuestions.put(question.getId(), question);
                responses.addAll(responsesForThisQn);
                for (FeedbackResponseAttributes response : responsesForThisQn) {
                    relevantResponse.put(response.getId(), response);
                    addEmailNamePairsToTable(emailNameTable, response,
                            question, roster);
                    addEmailLastNamePairsToTable(emailLastNameTable, response,
                            question, roster);
                    addEmailTeamNamePairsToTable(emailTeamNameTable, response,
                            question, roster);
                    addVisibilityToTable(visibilityTable, question, response,
                            userEmail, role, roster);
                }
            }
        }

        StudentAttributes student = null;
        Set<String> studentsEmailInTeam = new HashSet<>();
        if (isStudent(role)) {
            student = studentsLogic.getStudentForEmail(courseId, userEmail);
            List<StudentAttributes> studentsInTeam = studentsLogic
                    .getStudentsForTeam(student.team, courseId);
            for (StudentAttributes teammates : studentsInTeam) {
                studentsEmailInTeam.add(teammates.email);
            }
        }

        List<FeedbackResponseCommentAttributes> allResponseComments =
                frcLogic.getFeedbackResponseCommentForSession(courseId,
                        feedbackSessionName);
        for (FeedbackResponseCommentAttributes frc : allResponseComments) {
            FeedbackResponseAttributes relatedResponse = relevantResponse.get(frc.feedbackResponseId);
            FeedbackQuestionAttributes relatedQuestion = relevantQuestions.get(frc.feedbackQuestionId);
            boolean isVisibleResponseComment = frcLogic.isResponseCommentVisibleForUser(userEmail,
                    role, student, studentsEmailInTeam, relatedResponse, relatedQuestion, frc);
            if (isVisibleResponseComment) {
                if (!frcLogic.isNameVisibleToUser(frc, relatedResponse, userEmail, roster)) {
                    frc.giverEmail = ""Anonymous"";
                }

                if (responseComments.get(frc.feedbackResponseId) == null) {
                    responseComments.put(frc.feedbackResponseId,
                            new ArrayList<FeedbackResponseCommentAttributes>());
                }
                responseComments.get(frc.feedbackResponseId).add(frc);
            }
        }

        for (List<FeedbackResponseCommentAttributes> responseCommentList : responseComments
                .values()) {
            sortByCreatedDate(responseCommentList);
        }

        addSectionTeamNamesToTable(sectionTeamNameTable, roster, courseId, userEmail, role, feedbackSessionName, section);

        return new FeedbackSessionResultsBundle(
                        session, responses, relevantQuestions, emailNameTable,
                        emailLastNameTable, emailTeamNameTable, sectionTeamNameTable,
                        visibilityTable, responseStatus, roster, responseComments);
    }

    private FeedbackSessionResultsBundle getFeedbackSessionResultsForUserWithParams(
            String feedbackSessionName, String courseId, String userEmail,
            UserRole role, CourseRoster roster, Map<String, String> params)
            throws EntityDoesNotExistException {

        FeedbackSessionAttributes session = fsDb.getFeedbackSession(courseId, feedbackSessionName);

        if (session == null) {
            throw new EntityDoesNotExistException(ERROR_NON_EXISTENT_FS_VIEW + courseId + ""/"" + feedbackSessionName);
        }

        List<FeedbackQuestionAttributes> allQuestions =
                fqLogic.getFeedbackQuestionsForSession(feedbackSessionName, courseId);

        //Show all questions even if no responses, unless is an ajax request for a specific question.
        Map<String, FeedbackQuestionAttributes> relevantQuestions = getAllQuestions(role, params, allQuestions);

        boolean isPrivateSessionNotCreatedByThisUser = session.isPrivateSession() && !session.isCreator(userEmail);
        if (isPrivateSessionNotCreatedByThisUser) {
            // return empty result set
            return new FeedbackSessionResultsBundle(session, relevantQuestions, roster);
        }

        boolean isIncludeResponseStatus = Boolean.parseBoolean(params.get(PARAM_IS_INCLUDE_RESPONSE_STATUS));

        String section = params.get(PARAM_SECTION);
        String questionId = params.get(PARAM_QUESTION_ID);

        if (questionId != null) {
            return getFeedbackSessionResultsForQuestionId(feedbackSessionName, courseId, userEmail, role, roster, session,
                    allQuestions, relevantQuestions, isIncludeResponseStatus, section, questionId);
        }

        Map<String, FeedbackQuestionAttributes> allQuestionsMap = new HashMap<>();
        putQuestionsIntoMap(allQuestions, allQuestionsMap);

        List<FeedbackResponseAttributes> allResponses = getAllResponses(feedbackSessionName, courseId, params, section);

        String rangeString = params.get(PARAM_RANGE);
        boolean isComplete = rangeString == null || allResponses.size() <= Integer.parseInt(rangeString);

        if (!isComplete) {
            putQuestionsIntoMap(allQuestions, relevantQuestions);
        }

        // create empty data containers to store results
        List<FeedbackResponseAttributes> responses = new ArrayList<>();
        Map<String, String> emailNameTable = new HashMap<>();
        Map<String, String> emailLastNameTable = new HashMap<>();
        Map<String, String> emailTeamNameTable = new HashMap<>();
        Map<String, Set<String>> sectionTeamNameTable = new HashMap<>();
        Map<String, boolean[]> visibilityTable = new HashMap<>();
        FeedbackSessionResponseStatus responseStatus = section == null && isIncludeResponseStatus
                                                     ? getFeedbackSessionResponseStatus(session, roster, allQuestions)
                                                     : null;

        StudentAttributes student = getStudent(courseId, userEmail, role);
        Set<String> studentsEmailInTeam = getTeammateEmails(courseId, student);

        InstructorAttributes instructor = getInstructor(courseId, userEmail, role);

        Map<String, FeedbackResponseAttributes> relevantResponse = new HashMap<>();
        for (FeedbackResponseAttributes response : allResponses) {
            FeedbackQuestionAttributes relatedQuestion = allQuestionsMap.get(response.feedbackQuestionId);
            if (relatedQuestion != null) {
                boolean isVisibleResponse = isResponseVisibleForUser(
                        userEmail, role, student, studentsEmailInTeam, response, relatedQuestion, instructor);
                if (isVisibleResponse) {
                    responses.add(response);
                    relevantResponse.put(response.getId(), response);
                    relevantQuestions.put(relatedQuestion.getId(), relatedQuestion);
                    addEmailNamePairsToTable(emailNameTable, response, relatedQuestion, roster);
                    addEmailLastNamePairsToTable(emailLastNameTable, response, relatedQuestion, roster);
                    addEmailTeamNamePairsToTable(emailTeamNameTable, response, relatedQuestion, roster);
                    addVisibilityToTable(visibilityTable, relatedQuestion, response, userEmail, role, roster);
                }
            }
        }

        String viewType = params.get(PARAM_VIEW_TYPE);
        boolean isGrqSortType = Const.FeedbackSessionResults.GRQ_SORT_TYPE.equals(params.get(PARAM_VIEW_TYPE));
        boolean isRgqSortType = Const.FeedbackSessionResults.RGQ_SORT_TYPE.equals(params.get(PARAM_VIEW_TYPE));
        Map<String, List<FeedbackResponseCommentAttributes>> responseComments = getResponseComments(
                feedbackSessionName, courseId, userEmail, role, roster, relevantQuestions, section, student,
                studentsEmailInTeam, relevantResponse, viewType, isGrqSortType, isRgqSortType);

        addSectionTeamNamesToTable(sectionTeamNameTable, roster, courseId, userEmail, role, feedbackSessionName, section);

        return new FeedbackSessionResultsBundle(
                session, responses, relevantQuestions, emailNameTable,
                emailLastNameTable, emailTeamNameTable, sectionTeamNameTable,
                visibilityTable, responseStatus, roster, responseComments, isComplete);
    }

    private Map<String, List<FeedbackResponseCommentAttributes>> getResponseComments(
            String feedbackSessionName, String courseId, String userEmail, UserRole role, CourseRoster roster,
            Map<String, FeedbackQuestionAttributes> relevantQuestions, String section, StudentAttributes student,
            Set<String> studentsEmailInTeam, Map<String, FeedbackResponseAttributes> relevantResponse, String viewType,
            boolean isGrqSortType, boolean isRgqSortType) {

        Map<String, List<FeedbackResponseCommentAttributes>> responseComments = new HashMap<>();

        if (viewType == null || isGrqSortType || isRgqSortType) {
            List<FeedbackResponseCommentAttributes> allResponseComments =
                    frcLogic.getFeedbackResponseCommentForSessionInSection(courseId, feedbackSessionName, section);
            for (FeedbackResponseCommentAttributes frc : allResponseComments) {
                FeedbackResponseAttributes relatedResponse = relevantResponse.get(frc.feedbackResponseId);
                FeedbackQuestionAttributes relatedQuestion = relevantQuestions.get(frc.feedbackQuestionId);
                boolean isVisibleResponseComment = frcLogic.isResponseCommentVisibleForUser(
                        userEmail, role, student, studentsEmailInTeam, relatedResponse, relatedQuestion, frc);
                if (isVisibleResponseComment) {
                    if (!frcLogic.isNameVisibleToUser(frc, relatedResponse, userEmail, roster)) {
                        frc.giverEmail = ""Anonymous"";
                    }

                    List<FeedbackResponseCommentAttributes> frcList = responseComments.get(frc.feedbackResponseId);
                    if (frcList == null) {
                        frcList = new ArrayList<>();
                        frcList.add(frc);
                        responseComments.put(frc.feedbackResponseId, frcList);
                    } else {
                        frcList.add(frc);
                    }
                }
            }

            for (List<FeedbackResponseCommentAttributes> responseCommentList : responseComments.values()) {
                sortByCreatedDate(responseCommentList);
            }
        }
        return responseComments;
    }

    private void putQuestionsIntoMap(
            List<FeedbackQuestionAttributes> questions, Map<String, FeedbackQuestionAttributes> questionMap) {
        for (FeedbackQuestionAttributes qn : questions) {
            questionMap.put(qn.getId(), qn);
        }
    }

    private InstructorAttributes getInstructor(String courseId, String userEmail, UserRole role) {
        if (isInstructor(role)) {
            return instructorsLogic.getInstructorForEmail(courseId, userEmail);
        }
        return null;
    }

    /*
    * Gets emails of student's teammates if student is not null, else returns an empty Set<String>
    */
    private Set<String> getTeammateEmails(String courseId, StudentAttributes student) {
        Set<String> studentsEmailInTeam = new HashSet<>();
        if (student != null) {
            List<StudentAttributes> studentsInTeam = studentsLogic.getStudentsForTeam(student.team, courseId);
            for (StudentAttributes teammates : studentsInTeam) {
                studentsEmailInTeam.add(teammates.email);
            }
        }
        return studentsEmailInTeam;
    }

    private StudentAttributes getStudent(String courseId, String userEmail, UserRole role) {
        if (isStudent(role)) {
            return studentsLogic.getStudentForEmail(courseId, userEmail);
        }
        return null;
    }

    private FeedbackSessionResultsBundle getFeedbackSessionResultsForQuestionId(String feedbackSessionName,
                String courseId, String userEmail, UserRole role, CourseRoster roster, FeedbackSessionAttributes session,
                List<FeedbackQuestionAttributes> allQuestions, Map<String, FeedbackQuestionAttributes> relevantQuestions,
                boolean isIncludeResponseStatus, String section, String questionId) {

        List<FeedbackResponseAttributes> responses = new ArrayList<>();
        Map<String, String> emailNameTable = new HashMap<>();
        Map<String, String> emailLastNameTable = new HashMap<>();
        Map<String, String> emailTeamNameTable = new HashMap<>();
        Map<String, Set<String>> sectionTeamNameTable = new HashMap<>();
        Map<String, boolean[]> visibilityTable = new HashMap<>();
        Map<String, List<FeedbackResponseCommentAttributes>> responseComments = new HashMap<>();
        FeedbackSessionResponseStatus responseStatus = new FeedbackSessionResponseStatus();
        boolean isQueryingResponseRateStatus = questionId.equals(QUESTION_ID_FOR_RESPONSE_RATE);

        if (isQueryingResponseRateStatus) {
            responseStatus = section == null && isIncludeResponseStatus
                           ? getFeedbackSessionResponseStatus(session, roster, allQuestions)
                           : null;
        } else {
            FeedbackQuestionAttributes question = fqLogic.getFeedbackQuestion(questionId);
            if (question != null) {
                relevantQuestions.put(question.getId(), question);

                List<FeedbackResponseAttributes> responsesForThisQn;

                boolean isPrivateSessionCreatedByThisUser = session.isCreator(userEmail) && session.isPrivateSession();
                if (isPrivateSessionCreatedByThisUser) {
                    responsesForThisQn = frLogic.getFeedbackResponsesForQuestion(question.getId());
                } else {
                    responsesForThisQn = frLogic.getViewableFeedbackResponsesForQuestionInSection(
                                                    question, userEmail, UserRole.INSTRUCTOR, section);
                }

                boolean hasResponses = !responsesForThisQn.isEmpty();
                if (hasResponses) {
                    for (FeedbackResponseAttributes response : responsesForThisQn) {
                        InstructorAttributes instructor = getInstructor(courseId, userEmail, role);
                        boolean isVisibleResponse = isResponseVisibleForUser(userEmail, role, null, null, response,
                                                                             question, instructor);
                        if (isVisibleResponse) {
                            responses.add(response);
                            addEmailNamePairsToTable(emailNameTable, response, question, roster);
                            addEmailLastNamePairsToTable(emailLastNameTable, response, question, roster);
                            addEmailTeamNamePairsToTable(emailTeamNameTable, response, question, roster);
                            addVisibilityToTable(visibilityTable, question, response, userEmail, role, roster);
                        }
                    }
                }
            }
        }

        addSectionTeamNamesToTable(
                sectionTeamNameTable, roster, courseId, userEmail, role, feedbackSessionName, section);

        return new FeedbackSessionResultsBundle(
                session, responses, relevantQuestions, emailNameTable,
                emailLastNameTable, emailTeamNameTable, sectionTeamNameTable,
                visibilityTable, responseStatus, roster, responseComments, true);
    }

    private Map<String, FeedbackQuestionAttributes> getAllQuestions(
            UserRole role, Map<String, String> params, List<FeedbackQuestionAttributes> allQuestions) {
        Map<String, FeedbackQuestionAttributes> relevantQuestions = new HashMap<>();

        if (isInstructor(role) && !params.containsKey(PARAM_QUESTION_ID)) {
            putQuestionsIntoMap(allQuestions, relevantQuestions);
        }
        return relevantQuestions;
    }

    private boolean isStudent(UserRole role) {
        return role == UserRole.STUDENT;
    }

    private boolean isInstructor(UserRole role) {
        return role == UserRole.INSTRUCTOR;
    }

    private List<FeedbackResponseAttributes> getAllResponses(String feedbackSessionName, String courseId,
            Map<String, String> params, String section) {
        boolean isInSection = Boolean.parseBoolean(params.get(PARAM_IN_SECTION));
        boolean isToSection = Boolean.parseBoolean(params.get(PARAM_TO_SECTION));
        boolean isFromSection = Boolean.parseBoolean(params.get(PARAM_FROM_SECTION));

        if (params.get(PARAM_RANGE) == null) {
            if (isInSection) {
                return frLogic.getFeedbackResponsesForSessionInSection(feedbackSessionName, courseId, section);
            } else if (isFromSection) {
                return frLogic.getFeedbackResponsesForSessionFromSection(feedbackSessionName, courseId, section);
            } else if (isToSection) {
                return frLogic.getFeedbackResponsesForSessionToSection(feedbackSessionName, courseId, section);
            } else {
                Assumption.fail(ASSUMPTION_FAIL_RESPONSE_ORIGIN);
            }
        } else {
            int range = Integer.parseInt(params.get(PARAM_RANGE));
            if (isInSection) {
                return frLogic.getFeedbackResponsesForSessionInSectionWithinRange(
                        feedbackSessionName, courseId, section, range);
            } else if (isFromSection) {
                return frLogic.getFeedbackResponsesForSessionFromSectionWithinRange(
                        feedbackSessionName, courseId, section, range);
            } else if (isToSection) {
                return frLogic.getFeedbackResponsesForSessionToSectionWithinRange(
                        feedbackSessionName, courseId, section, range);
            } else {
                Assumption.fail(ASSUMPTION_FAIL_RESPONSE_ORIGIN);
            }
        }
        return new ArrayList<>();
    }

    private void addSectionTeamNamesToTable(Map<String, Set<String>> sectionTeamNameTable,
                                    CourseRoster roster, String courseId, String userEmail, UserRole role,
                                    String feedbackSessionName, String sectionToView) {
        InstructorAttributes instructor = getInstructor(courseId, userEmail, role);
        if (instructor != null) {
            for (StudentAttributes student : roster.getStudents()) {
                boolean isVisibleResponse =
                        instructor.isAllowedForPrivilege(
                                           student.section,
                                           feedbackSessionName,
                                           Const.ParamsNames.INSTRUCTOR_PERMISSION_VIEW_SESSION_IN_SECTIONS);
                boolean isStudentInSelectedSection = student.section.equals(sectionToView);
                boolean isViewingAllSections = sectionToView == null;

                if (isVisibleResponse && (isViewingAllSections
                                          || isStudentInSelectedSection)) {
                    String section = student.section;
                    if (!sectionTeamNameTable.containsKey(section)) {
                        Set<String> teamNames = new HashSet<>();
                        sectionTeamNameTable.put(section, teamNames);
                    }

                    sectionTeamNameTable.get(section).add(student.team);
                }
            }
        }
    }

    private boolean isResponseVisibleForUser(String userEmail,
            UserRole role, StudentAttributes student,
            Set<String> studentsEmailInTeam,
            FeedbackResponseAttributes response,
            FeedbackQuestionAttributes relatedQuestion, InstructorAttributes instructor) {

        boolean isVisibleResponse = false;
        if (isInstructor(role) && relatedQuestion.isResponseVisibleTo(FeedbackParticipantType.INSTRUCTORS)
                || response.recipient.equals(userEmail)
                        && relatedQuestion.isResponseVisibleTo(FeedbackParticipantType.RECEIVER)
                || response.giver.equals(userEmail)
                || isStudent(role) && relatedQuestion.isResponseVisibleTo(FeedbackParticipantType.STUDENTS)) {
            isVisibleResponse = true;
        } else if (studentsEmailInTeam != null && isStudent(role)) {
            if (relatedQuestion.recipientType == FeedbackParticipantType.TEAMS
                    && relatedQuestion.isResponseVisibleTo(FeedbackParticipantType.RECEIVER)
                    && response.recipient.equals(student.team)) {
                isVisibleResponse = true;
            } else if (relatedQuestion.giverType == FeedbackParticipantType.TEAMS
                       && studentsEmailInTeam.contains(response.giver)) {
                isVisibleResponse = true;
            } else if (relatedQuestion.isResponseVisibleTo(FeedbackParticipantType.OWN_TEAM_MEMBERS)
                       && studentsEmailInTeam.contains(response.giver)) {
                isVisibleResponse = true;
            } else if (relatedQuestion.isResponseVisibleTo(FeedbackParticipantType.RECEIVER_TEAM_MEMBERS)
                       && studentsEmailInTeam.contains(response.recipient)) {
                isVisibleResponse = true;
            }
        }
        if (isVisibleResponse && instructor != null) {
            boolean isGiverSectionRestricted =
                    !instructor.isAllowedForPrivilege(response.giverSection,
                                                      response.feedbackSessionName,
                                                      Const.ParamsNames.INSTRUCTOR_PERMISSION_VIEW_SESSION_IN_SECTIONS);
            // If instructors are not restricted to view the giver's section,
            // they are allowed to view responses to GENERAL, subject to visibility options
            boolean isRecipientSectionRestricted =
                    relatedQuestion.recipientType != FeedbackParticipantType.NONE
                    && !instructor.isAllowedForPrivilege(response.recipientSection,
                                                         response.feedbackSessionName,
                                                         Const.ParamsNames.INSTRUCTOR_PERMISSION_VIEW_SESSION_IN_SECTIONS);

            boolean isNotAllowedForInstructor = isGiverSectionRestricted || isRecipientSectionRestricted;
            if (isNotAllowedForInstructor) {
                isVisibleResponse = false;
            }
        }
        return isVisibleResponse;
    }

    private void sortByCreatedDate(List<FeedbackResponseCommentAttributes> responseCommentList) {
        Collections.sort(responseCommentList, new Comparator<FeedbackResponseCommentAttributes>() {
            @Override
            public int compare(FeedbackResponseCommentAttributes frc1,
                               FeedbackResponseCommentAttributes frc2) {
                return frc1.createdAt.compareTo(frc2.createdAt);
            }
        });
    }

    @SuppressWarnings(""PMD.UnusedPrivateMethod"") // false positive by PMD
    private void addVisibilityToTable(Map<String, boolean[]> visibilityTable,
            FeedbackQuestionAttributes question,
            FeedbackResponseAttributes response,
            String userEmail,
            UserRole role,
            CourseRoster roster) {
        boolean[] visibility = new boolean[2];
        visibility[Const.VISIBILITY_TABLE_GIVER] = frLogic.isNameVisibleToUser(
                question, response, userEmail, role, true, roster);
        visibility[Const.VISIBILITY_TABLE_RECIPIENT] = frLogic.isNameVisibleToUser(
                question, response, userEmail, role, false, roster);
        visibilityTable.put(response.getId(), visibility);
    }

    private void addEmailNamePairsToTable(Map<String, String> emailNameTable,
            FeedbackResponseAttributes response,
            FeedbackQuestionAttributes question, CourseRoster roster) {
        // keys of emailNameTable are participantIdentifiers,
        // which consists of students' email, instructors' email, team names, or %GENERAL%.
        // participants identifiers of anonymous responses are not anonymised in the tables
        addEmailNamePairsToTable(emailNameTable, response, question, roster,
                EMAIL_NAME_PAIR);
    }

    private void addEmailLastNamePairsToTable(Map<String, String> emailLastNameTable,
            FeedbackResponseAttributes response,
            FeedbackQuestionAttributes question, CourseRoster roster) {
        addEmailNamePairsToTable(emailLastNameTable, response, question, roster,
                EMAIL_LASTNAME_PAIR);
    }

    private void addEmailTeamNamePairsToTable(
            Map<String, String> emailTeamNameTable,
            FeedbackResponseAttributes response,
            FeedbackQuestionAttributes question, CourseRoster roster) {
        addEmailNamePairsToTable(emailTeamNameTable, response, question,
                roster, EMAIL_TEAMNAME_PAIR);
    }

    private void addEmailNamePairsToTable(Map<String, String> emailNameTable,
            FeedbackResponseAttributes response,
            FeedbackQuestionAttributes question, CourseRoster roster,
            int pairType) {
        if (question.giverType == FeedbackParticipantType.TEAMS
                && roster.isStudentInCourse(response.giver)) {
            if (!emailNameTable.containsKey(response.giver + Const.TEAM_OF_EMAIL_OWNER)) {
                emailNameTable.put(
                        response.giver + Const.TEAM_OF_EMAIL_OWNER,
                        getNameTeamNamePairForEmail(question.giverType,
                                response.giver, roster)[pairType]);
            }

            StudentAttributes studentGiver = roster.getStudentForEmail(response.giver);
            if (studentGiver != null && !emailNameTable.containsKey(studentGiver.team)) {
                emailNameTable.put(studentGiver.team, getNameTeamNamePairForEmail(
                                                        question.giverType,
                                                        response.giver, roster)[pairType]);
            }
        } else if (!emailNameTable.containsKey(response.giver)) {
            emailNameTable.put(
                    response.giver,
                    getNameTeamNamePairForEmail(question.giverType,
                            response.giver, roster)[pairType]);
        }

        FeedbackParticipantType recipientType = null;
        if (question.recipientType == FeedbackParticipantType.SELF) {
            recipientType = question.giverType;
        } else {
            recipientType = question.recipientType;
        }
        if (!emailNameTable.containsKey(response.recipient)) {
            emailNameTable.put(
                    response.recipient,
                    getNameTeamNamePairForEmail(recipientType,
                                                response.recipient, roster)[pairType]);

        }
    }

    private List<FeedbackSessionDetailsBundle> getFeedbackSessionDetailsForCourse(
            String courseId, String instructorEmail)
            throws EntityDoesNotExistException {

        List<FeedbackSessionDetailsBundle> fsDetailsWithoutPrivate = new ArrayList<>();
        List<FeedbackSessionAttributes> fsInCourse =
                fsDb.getFeedbackSessionsForCourse(courseId);

        for (FeedbackSessionAttributes fsa : fsInCourse) {
            if (!fsa.isPrivateSession() || fsa.isCreator(instructorEmail)) {
                fsDetailsWithoutPrivate.add(getFeedbackSessionDetails(fsa));
            }
        }

        return fsDetailsWithoutPrivate;
    }

    private List<FeedbackSessionAttributes> getFeedbackSessionsListForCourse(
            String courseId, String instructorEmail) {

        List<FeedbackSessionAttributes> fsInCourseWithoutPrivate = new ArrayList<>();
        List<FeedbackSessionAttributes> fsInCourse = fsDb.getFeedbackSessionsForCourse(courseId);

        for (FeedbackSessionAttributes fsa : fsInCourse) {
            if (!fsa.isPrivateSession() || fsa.isCreator(instructorEmail)) {
                fsInCourseWithoutPrivate.add(fsa);
            }
        }

        return fsInCourseWithoutPrivate;
    }

    private FeedbackSessionResponseStatus getFeedbackSessionResponseStatus(
            FeedbackSessionAttributes fsa, CourseRoster roster,
            List<FeedbackQuestionAttributes> questions) {

        FeedbackSessionResponseStatus responseStatus = new FeedbackSessionResponseStatus();
        List<StudentAttributes> students = roster.getStudents();
        List<InstructorAttributes> instructors = roster.getInstructors();
        List<FeedbackQuestionAttributes> studentQns = fqLogic
                .getFeedbackQuestionsForStudents(questions);

        List<String> studentNoResponses = new ArrayList<>();
        List<String> studentResponded = new ArrayList<>();
        List<String> instructorNoResponses = new ArrayList<>();

        if (!studentQns.isEmpty()) {
            for (StudentAttributes student : students) {
                studentNoResponses.add(student.email);
                responseStatus.emailNameTable.put(student.email, student.name);
                responseStatus.emailSectionTable.put(student.email, student.section);
                responseStatus.emailTeamNameTable.put(student.email, student.team);
            }
        }
        studentNoResponses.removeAll(fsa.getRespondingStudentList());
        studentResponded.addAll(fsa.getRespondingStudentList());

        for (InstructorAttributes instructor : instructors) {
            List<FeedbackQuestionAttributes> instructorQns = fqLogic
                    .getFeedbackQuestionsForInstructor(questions,
                            fsa.isCreator(instructor.email));
            if (!instructorQns.isEmpty() && responseStatus.emailNameTable.get(instructor.email) == null) {
                instructorNoResponses.add(instructor.email);
                responseStatus.emailNameTable.put(instructor.email, instructor.name);
            }
        }
        instructorNoResponses.removeAll(fsa.getRespondingInstructorList());

        responseStatus.noResponse.addAll(studentNoResponses);
        responseStatus.studentsWhoResponded.addAll(studentResponded);
        responseStatus.noResponse.addAll(instructorNoResponses);

        return responseStatus;
    }

    // return a pair of String that contains Giver/Recipient'sName (at index 0)
    // and TeamName (at index 1)
    private String[] getNameTeamNamePairForEmail(FeedbackParticipantType type,
            String email, CourseRoster roster) {
        String giverRecipientName = null;
        String giverRecipientLastName = null;
        String teamName = null;
        String name = null;
        String lastName = null;
        String team = null;

        StudentAttributes student = roster.getStudentForEmail(email);
        boolean isStudent = student != null;
        if (isStudent) {
            name = student.name;
            team = student.team;
            lastName = student.lastName;
        } else {
            InstructorAttributes instructor = roster
                    .getInstructorForEmail(email);
            boolean isInstructor = instructor != null;
            if (isInstructor) {
                name = instructor.name;
                lastName = instructor.name;
                team = Const.USER_TEAM_FOR_INSTRUCTOR;
            } else {
                if (email.equals(Const.GENERAL_QUESTION)) {
                    // Email represents that there is no specific recipient.
                    name = Const.USER_IS_NOBODY;
                    lastName = Const.USER_IS_NOBODY;
                    team = email;
                } else {
                    // The email represents a missing *Attribute.
                    // It might be a team name or the *Attribute has been deleted.
                    name = Const.USER_IS_MISSING;
                    lastName = Const.USER_IS_MISSING;
                    team = email;
                }
            }
        }

        if (type == FeedbackParticipantType.TEAMS || type == FeedbackParticipantType.OWN_TEAM) {
            giverRecipientName = team;
            giverRecipientLastName = team;
            teamName = """";
        } else {
            giverRecipientName = name;
            giverRecipientLastName = lastName;
            if (name.equals(Const.USER_IS_NOBODY) || name.equals(Const.USER_IS_MISSING)) {
                teamName = """";
            } else {
                teamName = team;
            }
        }
        return new String[] { giverRecipientName, giverRecipientLastName, teamName };
    }

    public boolean isFeedbackSessionFullyCompletedByStudent(
            String feedbackSessionName,
            String courseId, String userEmail)
            throws EntityDoesNotExistException {

        if (!isFeedbackSessionExists(feedbackSessionName, courseId)) {
            throw new EntityDoesNotExistException(ERROR_NON_EXISTENT_FS_CHECK + courseId + ""/"" + feedbackSessionName);
        }

        List<FeedbackQuestionAttributes> allQuestions =
                fqLogic.getFeedbackQuestionsForStudents(feedbackSessionName,
                        courseId);

        for (FeedbackQuestionAttributes question : allQuestions) {
            if (!fqLogic.isQuestionFullyAnsweredByUser(question, userEmail)) {
                // If any question is not completely answered, session is not
                // completed
                return false;
            }
        }
        return true;
    }

    private boolean isFeedbackSessionFullyCompletedByInstructor(
            String feedbackSessionName,
            String courseId, String userEmail)
            throws EntityDoesNotExistException {

        if (!isFeedbackSessionExists(feedbackSessionName, courseId)) {
            throw new EntityDoesNotExistException(ERROR_NON_EXISTENT_FS_CHECK + courseId + ""/"" + feedbackSessionName);
        }

        List<FeedbackQuestionAttributes> allQuestions =
                fqLogic.getFeedbackQuestionsForInstructor(feedbackSessionName,
                        courseId,
                        userEmail);

        for (FeedbackQuestionAttributes question : allQuestions) {
            if (!fqLogic.isQuestionFullyAnsweredByUser(question, userEmail)) {
                // If any question is not completely answered, session is not
                // completed
                return false;
            }
        }
        return true;
    }

    /**
     * Checks whether the feedback session is viewable to the specified user.
     */
    private boolean isFeedbackSessionViewableTo(
            FeedbackSessionAttributes session,
            String userEmail,
            boolean isInstructorOfCourse) {

        // If the session is a private session created by the same user, it is viewable to the user
        if (session.getFeedbackSessionType() == FeedbackSessionType.PRIVATE) {
            return session.getCreatorEmail().equals(userEmail);
        }

        // Allow all instructors to view always
        if (isInstructorOfCourse) {
            return true;
        }

        // Allow viewing if session is viewable to students
        return isFeedbackSessionViewableToStudents(session);
    }

    public boolean isFeedbackSessionViewableToStudents(
            FeedbackSessionAttributes session) {
        // Allow students to view the feedback session if there are questions for them
        List<FeedbackQuestionAttributes> questionsToAnswer =
                fqLogic.getFeedbackQuestionsForStudents(
                        session.getFeedbackSessionName(), session.getCourseId());

        if (session.isVisible() && !questionsToAnswer.isEmpty()) {
            return true;
        }

        // Allow students to view the feedback session
        // if there are any questions for instructors to answer
        // where the responses of the questions are visible to the students
        List<FeedbackQuestionAttributes> questionsWithVisibleResponses = new ArrayList<>();
        List<FeedbackQuestionAttributes> questionsForInstructors =
                                        fqLogic.getFeedbackQuestionsForCreatorInstructor(session);
        for (FeedbackQuestionAttributes question : questionsForInstructors) {
            if (frLogic.isResponseOfFeedbackQuestionVisibleToStudent(question)) {
                questionsWithVisibleResponses.add(question);
            }
        }

        return session.isVisible() && !questionsWithVisibleResponses.isEmpty();
    }

    /**
     * Returns true if there are any questions for students to answer.
     */
    public boolean isFeedbackSessionForStudentsToAnswer(FeedbackSessionAttributes session) {

        List<FeedbackQuestionAttributes> questionsToAnswer =
                fqLogic.getFeedbackQuestionsForStudents(
                        session.getFeedbackSessionName(), session.getCourseId());

        return session.isVisible() && !questionsToAnswer.isEmpty();
    }

    private void normalizeMaximumResponseEntities(
            FeedbackQuestionAttributes question,
            Map<String, String> recipients) {

        // change constant to actual maximum size.
        if (question.numberOfEntitiesToGiveFeedbackTo == Const.MAX_POSSIBLE_RECIPIENTS) {
            question.numberOfEntitiesToGiveFeedbackTo = recipients.size();
        }
    }

    private void makeEmailStateConsistent(FeedbackSessionAttributes oldSession,
            FeedbackSessionAttributes newSession) {

        // reset sentOpenEmail if the session has opened but is being un-opened
        // now, or else leave it as sent if so.
        if (oldSession.isSentOpenEmail()) {
            newSession.setSentOpenEmail(newSession.isOpened());
        }

        // reset sentClosedEmail if the session has closed but is being un-closed
        // now, or else leave it as sent if so.
        if (oldSession.isSentClosedEmail()) {
            newSession.setSentClosedEmail(newSession.isClosed());

            // also reset sentClosingEmail
            newSession.setSentClosingEmail(
                    newSession.isClosed()
                    || !newSession.isClosedAfter(SystemParams.NUMBER_OF_HOURS_BEFORE_CLOSING_ALERT));
        }

        // reset sentPublishedEmail if the session has been published but is
        // going to be unpublished now, or else leave it as sent if so.
        if (oldSession.isSentPublishedEmail()) {
            newSession.setSentPublishedEmail(newSession.isPublished());
        }
    }

}
"
InstructorsLogic.java,logic-core,"package teammates.logic.core;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import teammates.common.datatransfer.InstructorSearchResultBundle;
import teammates.common.datatransfer.attributes.InstructorAttributes;
import teammates.common.exception.EntityAlreadyExistsException;
import teammates.common.exception.EntityDoesNotExistException;
import teammates.common.exception.InvalidParametersException;
import teammates.common.util.Assumption;
import teammates.common.util.FieldValidator;
import teammates.common.util.Logger;
import teammates.common.util.StringHelper;
import teammates.storage.api.InstructorsDb;

/**
 * Handles operations related to instructors.
 *
 * @see InstructorAttributes
 * @see InstructorsDb
 */
public final class InstructorsLogic {

    private static final Logger log = Logger.getLogger();

    private static InstructorsLogic instance = new InstructorsLogic();

    private static final InstructorsDb instructorsDb = new InstructorsDb();

    private static final AccountsLogic accountsLogic = AccountsLogic.inst();
    private static final CoursesLogic coursesLogic = CoursesLogic.inst();
    private static final FeedbackResponseCommentsLogic frcLogic = FeedbackResponseCommentsLogic.inst();
    private static final FeedbackSessionsLogic fsLogic = FeedbackSessionsLogic.inst();

    private InstructorsLogic() {
        // prevent initialization
    }

    public static InstructorsLogic inst() {
        return instance;
    }

    /* ====================================
     * methods related to google search API
     * ====================================
     */

    /**
     * Creates or updates document for the given Instructor.
     * @param instructor to be put into documents
     */
    public void putDocument(InstructorAttributes instructor) {
        instructorsDb.putDocument(instructor);
    }

    /**
     * Batch creates or updates documents for the given Instructors.
     * @param instructors a list of instructors to be put into documents
     */
    public void putDocuments(List<InstructorAttributes> instructors) {
        instructorsDb.putDocuments(instructors);
    }

    /**
     * Removes document for the given Instructor.
     * @param instructor to be removed from documents
     */
    public void deleteDocument(InstructorAttributes instructor) {
        instructorsDb.deleteDocument(instructor);
    }

    /**
     * This method should be used by admin only since the searching does not restrict the
     * visibility according to the logged-in user's google ID. This is used by admin to
     * search instructors in the whole system.
     * @return null if no result found
     */
    public InstructorSearchResultBundle searchInstructorsInWholeSystem(String queryString) {
        return instructorsDb.searchInstructorsInWholeSystem(queryString);
    }

    /* ====================================
     * ====================================
     */

    public InstructorAttributes createInstructor(InstructorAttributes instructorToAdd)
            throws InvalidParametersException, EntityAlreadyExistsException {

        Assumption.assertNotNull(""Supplied parameter was null"", instructorToAdd);

        log.info(""going to create instructor :\n"" + instructorToAdd.toString());

        return instructorsDb.createInstructor(instructorToAdd);
    }

    public void setArchiveStatusOfInstructor(String googleId, String courseId, boolean archiveStatus)
           throws InvalidParametersException, EntityDoesNotExistException {

        InstructorAttributes instructor = instructorsDb.getInstructorForGoogleId(courseId, googleId);
        instructor.isArchived = archiveStatus;
        instructorsDb.updateInstructorByGoogleId(instructor);
    }

    public InstructorAttributes getInstructorForEmail(String courseId, String email) {

        return instructorsDb.getInstructorForEmail(courseId, email);
    }

    public InstructorAttributes getInstructorForGoogleId(String courseId, String googleId) {

        return instructorsDb.getInstructorForGoogleId(courseId, googleId);
    }

    public InstructorAttributes getInstructorForRegistrationKey(String encryptedKey) {

        return instructorsDb.getInstructorForRegistrationKey(encryptedKey);
    }

    public List<InstructorAttributes> getInstructorsForCourse(String courseId) {
        List<InstructorAttributes> instructorReturnList = instructorsDb.getInstructorsForCourse(courseId);
        Collections.sort(instructorReturnList, InstructorAttributes.compareByName);

        return instructorReturnList;
    }

    public List<InstructorAttributes> getInstructorsForGoogleId(String googleId) {

        return getInstructorsForGoogleId(googleId, false);
    }

    public List<InstructorAttributes> getInstructorsForGoogleId(String googleId, boolean omitArchived) {

        return instructorsDb.getInstructorsForGoogleId(googleId, omitArchived);
    }

    public String getEncryptedKeyForInstructor(String courseId, String email)
            throws EntityDoesNotExistException {

        verifyIsEmailOfInstructorOfCourse(email, courseId);

        InstructorAttributes instructor = getInstructorForEmail(courseId, email);

        return StringHelper.encrypt(instructor.key);
    }

    public List<InstructorAttributes> getInstructorsForEmail(String email) {

        return instructorsDb.getInstructorsForEmail(email);
    }

    /**
     * Gets all instructors in the Datastore.
     *
     * @deprecated Not scalable. Use only for admin features.
     */
    @Deprecated
    public List<InstructorAttributes> getAllInstructors() {

        return instructorsDb.getAllInstructors();
    }

    public boolean isGoogleIdOfInstructorOfCourse(String instructorId, String courseId) {

        return instructorsDb.getInstructorForGoogleId(courseId, instructorId) != null;
    }

    public boolean isEmailOfInstructorOfCourse(String instructorEmail, String courseId) {

        return instructorsDb.getInstructorForEmail(courseId, instructorEmail) != null;
    }

    /**
     * Returns whether the instructor is a new user, according to one of the following criteria:
     * <ul>
     * <li>There is only a sample course (created by system) for the instructor.</li>
     * <li>There is no any course for the instructor.</li>
     * </ul>
     */
    public boolean isNewInstructor(String googleId) {
        List<InstructorAttributes> instructorList = getInstructorsForGoogleId(googleId);
        return instructorList.isEmpty()
               || instructorList.size() == 1 && coursesLogic.isSampleCourse(instructorList.get(0).courseId);
    }

    public void verifyInstructorExists(String instructorId)
            throws EntityDoesNotExistException {

        if (!accountsLogic.isAccountAnInstructor(instructorId)) {
            throw new EntityDoesNotExistException(""Instructor does not exist :""
                    + instructorId);
        }
    }

    public void verifyIsEmailOfInstructorOfCourse(String instructorEmail, String courseId)
            throws EntityDoesNotExistException {

        if (!isEmailOfInstructorOfCourse(instructorEmail, courseId)) {
            throw new EntityDoesNotExistException(""Instructor "" + instructorEmail
                    + "" does not belong to course "" + courseId);
        }
    }

    /**
     * Update the name and email address of an instructor with the specific Google ID.
     * @param instructor InstructorAttributes object containing the details to be updated
     */
    public void updateInstructorByGoogleId(String googleId, InstructorAttributes instructor)
            throws InvalidParametersException, EntityDoesNotExistException {

        // TODO: either refactor this to constant or just remove it. check not null should be in db
        Assumption.assertNotNull(""Supplied parameter was null"", instructor);

        coursesLogic.verifyCourseIsPresent(instructor.courseId);
        verifyInstructorInDbAndCascadeEmailChange(googleId, instructor);
        checkForUpdatingRespondents(instructor);

        instructorsDb.updateInstructorByGoogleId(instructor);
    }

    private void checkForUpdatingRespondents(InstructorAttributes instructor)
            throws InvalidParametersException, EntityDoesNotExistException {

        InstructorAttributes currentInstructor = getInstructorForGoogleId(instructor.courseId, instructor.googleId);
        if (!currentInstructor.email.equals(instructor.email)) {
            fsLogic.updateRespondentsForInstructor(currentInstructor.email, instructor.email, instructor.courseId);
        }
    }

    private void verifyInstructorInDbAndCascadeEmailChange(String googleId,
            InstructorAttributes instructor) throws EntityDoesNotExistException {
        InstructorAttributes instructorInDb = instructorsDb.getInstructorForGoogleId(instructor.courseId, googleId);
        if (instructorInDb == null) {
            throw new EntityDoesNotExistException(""Instructor "" + googleId
                    + "" does not belong to course "" + instructor.courseId);
        }
        // cascade comments
        if (!instructorInDb.email.equals(instructor.email)) {
            frcLogic.updateFeedbackResponseCommentsEmails(
                    instructor.courseId, instructorInDb.email, instructor.email);
        }
    }

    /**
     * Update the Google ID and name of an instructor with the specific email.
     * @param instructor InstructorAttributes object containing the details to be updated
     */
    public void updateInstructorByEmail(String email, InstructorAttributes instructor)
            throws InvalidParametersException, EntityDoesNotExistException {

        Assumption.assertNotNull(""Supplied parameter was null"", instructor);

        coursesLogic.verifyCourseIsPresent(instructor.courseId);
        verifyIsEmailOfInstructorOfCourse(email, instructor.courseId);

        instructorsDb.updateInstructorByEmail(instructor);
    }

    public List<String> getInvalidityInfoForNewInstructorData(String shortName, String name,
                                                              String institute, String email) {

        FieldValidator validator = new FieldValidator();
        List<String> errors = new ArrayList<>();
        String error;

        error = validator.getInvalidityInfoForPersonName(shortName);
        if (!error.isEmpty()) {
            errors.add(error);
        }

        error = validator.getInvalidityInfoForPersonName(name);
        if (!error.isEmpty()) {
            errors.add(error);
        }

        error = validator.getInvalidityInfoForEmail(email);
        if (!error.isEmpty()) {
            errors.add(error);
        }

        error = validator.getInvalidityInfoForInstituteName(institute);
        if (!error.isEmpty()) {
            errors.add(error);
        }

        //No validation for isInstructor and createdAt fields.
        return errors;
    }

    public void deleteInstructorCascade(String courseId, String email) {
        fsLogic.deleteInstructorFromRespondentsList(getInstructorForEmail(courseId, email));
        instructorsDb.deleteInstructor(courseId, email);
    }

    public void deleteInstructorsForGoogleIdAndCascade(String googleId) {
        List<InstructorAttributes> instructors = instructorsDb.getInstructorsForGoogleId(googleId, false);

        //Cascade delete instructors
        for (InstructorAttributes instructor : instructors) {
            deleteInstructorCascade(instructor.courseId, instructor.email);
        }
    }

    // this method is only being used in course logic. cascade to comments is therefore not necessary
    // as it it taken care of when deleting course
    public void deleteInstructorsForCourse(String courseId) {

        instructorsDb.deleteInstructorsForCourse(courseId);
    }

    public List<InstructorAttributes> getCoOwnersForCourse(String courseId) {
        List<InstructorAttributes> instructors = getInstructorsForCourse(courseId);
        List<InstructorAttributes> instructorsWithCoOwnerPrivileges = new ArrayList<>();
        for (InstructorAttributes instructor : instructors) {
            if (!instructor.hasCoownerPrivileges()) {
                continue;
            }
            instructorsWithCoOwnerPrivileges.add(instructor);
        }
        return instructorsWithCoOwnerPrivileges;
    }

}
"
JavamailService.java,logic-core,"package teammates.logic.core;

import java.io.IOException;
import java.util.Properties;

import javax.mail.Address;
import javax.mail.Message;
import javax.mail.MessagingException;
import javax.mail.Session;
import javax.mail.Transport;
import javax.mail.internet.AddressException;
import javax.mail.internet.InternetAddress;
import javax.mail.internet.MimeMessage;

import teammates.common.util.EmailWrapper;

/**
 * Email sender service provided by JavaMail.
 * This is the default service provided by Google App Engine.
 *
 * @see <a href=""https://cloud.google.com/appengine/docs/java/mail/"">https://cloud.google.com/appengine/docs/java/mail/</a>
 * @see MimeMessage
 */
public class JavamailService extends EmailSenderService {

    /**
     * {@inheritDoc}
     */
    @Override
    public MimeMessage parseToEmail(EmailWrapper wrapper) throws AddressException, MessagingException, IOException {
        Session session = Session.getDefaultInstance(new Properties(), null);
        MimeMessage email = new MimeMessage(session);
        if (wrapper.getSenderName() == null || wrapper.getSenderName().isEmpty()) {
            email.setFrom(new InternetAddress(wrapper.getSenderEmail()));
        } else {
            email.setFrom(new InternetAddress(wrapper.getSenderEmail(), wrapper.getSenderName()));
        }
        email.setReplyTo(new Address[] { new InternetAddress(wrapper.getReplyTo()) });
        email.addRecipient(Message.RecipientType.TO, new InternetAddress(wrapper.getRecipient()));
        if (wrapper.getBcc() != null && !wrapper.getBcc().isEmpty()) {
            email.addRecipient(Message.RecipientType.BCC, new InternetAddress(wrapper.getBcc()));
        }
        email.setSubject(wrapper.getSubject());
        email.setContent(wrapper.getContent(), ""text/html"");
        return email;
    }

    @Override
    protected void sendEmailWithService(EmailWrapper wrapper) throws AddressException, MessagingException, IOException {
        MimeMessage email = parseToEmail(wrapper);
        Transport.send(email);
    }

}
"
MailgunService.java,logic-core,"package teammates.logic.core;

import javax.ws.rs.core.MediaType;

import com.sun.jersey.api.client.Client;
import com.sun.jersey.api.client.ClientResponse;
import com.sun.jersey.api.client.WebResource;
import com.sun.jersey.api.client.filter.HTTPBasicAuthFilter;
import com.sun.jersey.multipart.FormDataMultiPart;

import teammates.common.util.Config;
import teammates.common.util.EmailWrapper;
import teammates.common.util.Logger;

/**
 * Email sender service provided by Mailgun.
 *
 * @see <a href=""https://cloud.google.com/appengine/docs/java/mail/mailgun"">https://cloud.google.com/appengine/docs/java/mail/mailgun</a>
 * @see FormDataMultiPart
 */
public class MailgunService extends EmailSenderService {

    private static final Logger log = Logger.getLogger();

    /**
     * {@inheritDoc}
     */
    @Override
    public FormDataMultiPart parseToEmail(EmailWrapper wrapper) {
        FormDataMultiPart formData = new FormDataMultiPart();

        String sender = wrapper.getSenderName() == null || wrapper.getSenderName().isEmpty()
                        ? wrapper.getSenderEmail()
                        : wrapper.getSenderName() + "" <"" + wrapper.getSenderEmail() + "">"";
        formData.field(""from"", sender);

        formData.field(""to"", wrapper.getRecipient());

        if (wrapper.getBcc() != null && !wrapper.getBcc().isEmpty()) {
            formData.field(""bcc"", wrapper.getBcc());
        }

        formData.field(""h:Reply-To"", wrapper.getReplyTo());
        formData.field(""subject"", wrapper.getSubject());
        formData.field(""html"", wrapper.getContent());

        return formData;
    }

    @Override
    protected void sendEmailWithService(EmailWrapper wrapper) {
        FormDataMultiPart email = parseToEmail(wrapper);
        Client client = Client.create();
        client.addFilter(new HTTPBasicAuthFilter(""api"", Config.MAILGUN_APIKEY));
        WebResource webResource =
                client.resource(""https://api.mailgun.net/v3/"" + Config.MAILGUN_DOMAINNAME + ""/messages"");

        ClientResponse response = webResource.type(MediaType.MULTIPART_FORM_DATA_TYPE)
                                             .post(ClientResponse.class, email);
        if (response.getStatus() != SUCCESS_CODE) {
            log.severe(""Email failed to send: "" + response.getStatusInfo().getReasonPhrase());
        }
    }

}
"
MailjetService.java,logic-core,"package teammates.logic.core;

import org.json.JSONArray;
import org.json.JSONObject;
import org.jsoup.Jsoup;

import com.mailjet.client.MailjetClient;
import com.mailjet.client.MailjetRequest;
import com.mailjet.client.MailjetResponse;
import com.mailjet.client.errors.MailjetException;
import com.mailjet.client.errors.MailjetSocketTimeoutException;
import com.mailjet.client.resource.Email;

import teammates.common.util.Config;
import teammates.common.util.EmailWrapper;
import teammates.common.util.Logger;

/**
 * Email sender service provided by Mailjet.
 *
 * @see <a href=""https://cloud.google.com/appengine/docs/java/mail/mailjet"">https://cloud.google.com/appengine/docs/java/mail/mailjet</a>
 * @see MailjetClient
 * @see MailjetRequest
 * @see MailjetResponse
 */
public class MailjetService extends EmailSenderService {

    private static final Logger log = Logger.getLogger();

    /**
     * {@inheritDoc}
     */
    @Override
    public MailjetRequest parseToEmail(EmailWrapper wrapper) {
        MailjetRequest request = new MailjetRequest(Email.resource);
        request.property(Email.FROMEMAIL, wrapper.getSenderEmail());
        if (wrapper.getSenderName() != null && !wrapper.getSenderName().isEmpty()) {
            request.property(Email.FROMNAME, wrapper.getSenderName());
        }

        request.property(Email.RECIPIENTS, new JSONArray().put(new JSONObject().put(""Email"", wrapper.getRecipient())));
        if (wrapper.getBcc() != null && !wrapper.getBcc().isEmpty()) {
            request.append(Email.RECIPIENTS, new JSONObject().put(""Email"", wrapper.getBcc()));
        }

        request.property(Email.HEADERS, new JSONObject().put(""Reply-To"", wrapper.getReplyTo()));
        request.property(Email.SUBJECT, wrapper.getSubject());
        request.property(Email.HTMLPART, wrapper.getContent());
        request.property(Email.TEXTPART, Jsoup.parse(wrapper.getContent()).text());
        return request;
    }

    @Override
    protected void sendEmailWithService(EmailWrapper wrapper) throws MailjetException, MailjetSocketTimeoutException {
        MailjetRequest email = parseToEmail(wrapper);
        MailjetClient mailjet = new MailjetClient(Config.MAILJET_APIKEY, Config.MAILJET_SECRETKEY);
        MailjetResponse response = mailjet.post(email);
        if (response.getStatus() != SUCCESS_CODE) {
            log.severe(""Email failed to send: "" + response.getData().toString());
        }
    }

}
"
package-info.java,logic-core,"/**
 * Contains the core logic of the system.
 */
package teammates.logic.core;
"
ProfilesLogic.java,logic-core,"package teammates.logic.core;

import java.util.List;

import com.google.appengine.api.blobstore.BlobKey;

import teammates.common.datatransfer.attributes.StudentProfileAttributes;
import teammates.common.exception.EntityDoesNotExistException;
import teammates.common.exception.InvalidParametersException;
import teammates.storage.api.ProfilesDb;

/**
 * Handles the logic related to student profiles.
 */
public final class ProfilesLogic {

    private static ProfilesLogic instance = new ProfilesLogic();

    private static final ProfilesDb profilesDb = new ProfilesDb();

    private ProfilesLogic() {
        // prevent initialization
    }

    public static ProfilesLogic inst() {
        return instance;
    }

    public StudentProfileAttributes getStudentProfile(String googleId) {
        return profilesDb.getStudentProfile(googleId);
    }

    public void updateStudentProfile(StudentProfileAttributes newStudentProfileAttributes)
            throws InvalidParametersException, EntityDoesNotExistException {
        profilesDb.updateStudentProfile(newStudentProfileAttributes);
    }

    public void deleteStudentProfilePicture(String googleId) throws EntityDoesNotExistException {
        profilesDb.deleteStudentProfilePicture(googleId);
    }

    public void deletePicture(BlobKey key) {
        profilesDb.deletePicture(key);
    }

    public void updateStudentProfilePicture(String googleId, String newPictureKey) throws EntityDoesNotExistException {
        profilesDb.updateStudentProfilePicture(googleId, newPictureKey);
    }

    /**
     * Gets all student profiles in the Datastore.
     * @deprecated Not scalable. Use only for admin features.
     */
    @Deprecated
    public List<StudentProfileAttributes> getAllStudentProfiles() {
        return profilesDb.getAllStudentProfiles();
    }

}
"
SendgridService.java,logic-core,"package teammates.logic.core;

import org.jsoup.Jsoup;

import com.sendgrid.SendGrid;
import com.sendgrid.SendGrid.Email;
import com.sendgrid.SendGrid.Response;
import com.sendgrid.SendGridException;

import teammates.common.util.Config;
import teammates.common.util.EmailWrapper;
import teammates.common.util.Logger;

/**
 * Email sender service provided by SendGrid.
 *
 * @see <a href=""https://cloud.google.com/appengine/docs/flexible/java/sending-emails-with-sendgrid"">https://cloud.google.com/appengine/docs/flexible/java/sending-emails-with-sendgrid</a>
 * @see SendGrid
 */
public class SendgridService extends EmailSenderService {

    private static final Logger log = Logger.getLogger();

    /**
     * {@inheritDoc}
     */
    @Override
    public Email parseToEmail(EmailWrapper wrapper) {
        Email email = new Email();
        email.setFrom(wrapper.getSenderEmail());
        if (wrapper.getSenderName() != null && !wrapper.getSenderName().isEmpty()) {
            email.setFromName(wrapper.getSenderName());
        }
        email.setReplyTo(wrapper.getReplyTo());
        email.addTo(wrapper.getRecipient());
        if (wrapper.getBcc() != null && !wrapper.getBcc().isEmpty()) {
            email.addBcc(wrapper.getBcc());
        }
        email.setSubject(wrapper.getSubject());
        email.setHtml(wrapper.getContent());
        email.setText(Jsoup.parse(wrapper.getContent()).text());
        return email;
    }

    @Override
    protected void sendEmailWithService(EmailWrapper wrapper) throws SendGridException {
        Email email = parseToEmail(wrapper);
        SendGrid sendgrid = new SendGrid(Config.SENDGRID_APIKEY);
        Response response = sendgrid.send(email);
        if (response.getCode() != SUCCESS_CODE) {
            log.severe(""Email failed to send: "" + response.getMessage());
        }
    }

}
"
StudentsLogic.java,logic-core,"package teammates.logic.core;

import java.util.ArrayList;
import java.util.List;

import teammates.common.datatransfer.CourseEnrollmentResult;
import teammates.common.datatransfer.StudentAttributesFactory;
import teammates.common.datatransfer.StudentEnrollDetails;
import teammates.common.datatransfer.StudentSearchResultBundle;
import teammates.common.datatransfer.StudentUpdateStatus;
import teammates.common.datatransfer.TeamDetailsBundle;
import teammates.common.datatransfer.attributes.FeedbackResponseAttributes;
import teammates.common.datatransfer.attributes.InstructorAttributes;
import teammates.common.datatransfer.attributes.StudentAttributes;
import teammates.common.datatransfer.attributes.StudentProfileAttributes;
import teammates.common.exception.EnrollException;
import teammates.common.exception.EntityAlreadyExistsException;
import teammates.common.exception.EntityDoesNotExistException;
import teammates.common.exception.InvalidParametersException;
import teammates.common.util.Assumption;
import teammates.common.util.Const;
import teammates.common.util.FieldValidator;
import teammates.common.util.SanitizationHelper;
import teammates.common.util.StringHelper;
import teammates.storage.api.StudentsDb;

/**
 * Handles operations related to students.
 *
 * @see StudentAttributes
 * @see StudentsDb
 */
public final class StudentsLogic {

    private static final int SECTION_SIZE_LIMIT = 100;

    private static StudentsLogic instance = new StudentsLogic();

    private static final StudentsDb studentsDb = new StudentsDb();

    private static final CoursesLogic coursesLogic = CoursesLogic.inst();
    private static final FeedbackResponsesLogic frLogic = FeedbackResponsesLogic.inst();
    private static final FeedbackSessionsLogic fsLogic = FeedbackSessionsLogic.inst();
    private static final ProfilesLogic profilesLogic = ProfilesLogic.inst();

    private StudentsLogic() {
        // prevent initialization
    }

    public static StudentsLogic inst() {
        return instance;
    }

    public void createStudentCascade(StudentAttributes studentData)
            throws InvalidParametersException, EntityAlreadyExistsException,
            EntityDoesNotExistException {
        createStudentCascade(studentData, true);
    }

    public void createStudentCascadeWithoutDocument(
            StudentAttributes studentData) throws InvalidParametersException,
            EntityAlreadyExistsException, EntityDoesNotExistException {
        createStudentCascade(studentData, false);
    }

    public void createStudentCascade(StudentAttributes studentData, boolean hasDocument)
            throws InvalidParametersException, EntityAlreadyExistsException, EntityDoesNotExistException {
        studentsDb.createStudent(studentData, hasDocument);

        if (!coursesLogic.isCoursePresent(studentData.course)) {
            throw new EntityDoesNotExistException(
                    ""Course does not exist ["" + studentData.course + ""]"");
        }

    }

    /**
     * Gets all students in the database.
     */
    @SuppressWarnings(""deprecation"")
    public List<StudentAttributes> getAllStudents() {
        return studentsDb.getAllStudents();
    }

    public StudentAttributes getStudentForEmail(String courseId, String email) {
        return studentsDb.getStudentForEmail(courseId, email);
    }

    public StudentAttributes getStudentForCourseIdAndGoogleId(String courseId, String googleId) {
        return studentsDb.getStudentForGoogleId(courseId, googleId);
    }

    public StudentAttributes getStudentForRegistrationKey(String registrationKey) {
        return studentsDb.getStudentForRegistrationKey(registrationKey);
    }

    public List<StudentAttributes> getStudentsForGoogleId(String googleId) {
        return studentsDb.getStudentsForGoogleId(googleId);
    }

    public List<StudentAttributes> getStudentsForCourse(String courseId) {
        return studentsDb.getStudentsForCourse(courseId);
    }

    public List<StudentAttributes> getStudentsForTeam(String teamName, String courseId) {
        return studentsDb.getStudentsForTeam(teamName, courseId);
    }

    public List<StudentAttributes> getStudentsForSection(String sectionName, String courseId) {
        return studentsDb.getStudentsForSection(sectionName, courseId);
    }

    public List<StudentAttributes> getUnregisteredStudentsForCourse(String courseId) {
        return studentsDb.getUnregisteredStudentsForCourse(courseId);
    }

    public void deleteDocument(StudentAttributes student) {
        studentsDb.deleteDocument(student);
    }

    public StudentSearchResultBundle searchStudents(String queryString, List<InstructorAttributes> instructors) {
        return studentsDb.search(queryString, instructors);
    }

    /**
     * This method should be used by admin only since the searching does not restrict the
     * visibility according to the logged-in user's google ID. This is used by admin to
     * search students in the whole system.
     * @return null if no result found
     */
    public StudentSearchResultBundle searchStudentsInWholeSystem(String queryString) {
        return studentsDb.searchStudentsInWholeSystem(queryString);
    }

    public StudentProfileAttributes getStudentProfile(String googleId) {
        Assumption.assertNotNull(googleId);

        return profilesLogic.getStudentProfile(googleId);
    }

    public String getEncryptedKeyForStudent(String courseId, String email) throws EntityDoesNotExistException {

        StudentAttributes studentData = getStudentForEmail(courseId, email);

        if (studentData == null) {
            throw new EntityDoesNotExistException(""Student does not exist: ["" + courseId + ""/"" + email + ""]"");
        }

        return StringHelper.encrypt(studentData.key);
    }

    public boolean isStudentInAnyCourse(String googleId) {
        return studentsDb.getStudentsForGoogleId(googleId).size() != 0;
    }

    public boolean isStudentInCourse(String courseId, String studentEmail) {
        return studentsDb.getStudentForEmail(courseId, studentEmail) != null;
    }

    public boolean isStudentInTeam(String courseId, String teamName, String studentEmail) {

        StudentAttributes student = getStudentForEmail(courseId, studentEmail);
        if (student == null) {
            return false;
        }

        List<StudentAttributes> teammates = getStudentsForTeam(teamName, courseId);
        for (StudentAttributes teammate : teammates) {
            if (teammate.email.equals(student.email)) {
                return true;
            }
        }
        return false;
    }

    public boolean isStudentsInSameTeam(String courseId, String student1Email, String student2Email) {
        StudentAttributes student1 = getStudentForEmail(courseId, student1Email);
        if (student1 == null) {
            return false;
        }
        return isStudentInTeam(courseId, student1.team, student2Email);
    }

    public void updateStudentCascade(String originalEmail,
            StudentAttributes student) throws InvalidParametersException,
            EntityDoesNotExistException {
        updateStudentCascade(originalEmail, student, true);
    }

    public void updateStudentCascadeWithoutDocument(String originalEmail,
            StudentAttributes student) throws InvalidParametersException,
            EntityDoesNotExistException {
        updateStudentCascade(originalEmail, student, false);
    }

    public void updateStudentCascade(String originalEmail, StudentAttributes student, boolean hasDocument)
            throws InvalidParametersException, EntityDoesNotExistException {
        StudentAttributes originalStudent = getStudentForEmail(student.course, originalEmail);
        updateStudentCascadeWithSubmissionAdjustmentScheduled(originalEmail, student, hasDocument);

        /* finalEmail is the string to be used to represent a student's email.
         * This is because:
         *  - originalEmail cannot be used when student's email is being updated with a new valid email
         *  - student.email cannot be used always because it is null when non-email attributes
         *    of a student are being updated or when the new email to be updated is invalid
         */
        FieldValidator validator = new FieldValidator();
        //Untested case: The deletion is not persisted immediately (i.e. persistence delay)
        //       Reason: Difficult to reproduce a persistence delay during testing
        String finalEmail = student.email == null
                                || !validator.getInvalidityInfoForEmail(student.email).isEmpty()
                            ? originalEmail
                            : student.email;

        // adjust submissions if moving to a different team
        if (isTeamChanged(originalStudent.team, student.team)) {
            frLogic.updateFeedbackResponsesForChangingTeam(student.course, finalEmail, originalStudent.team, student.team);
        }

        if (isSectionChanged(originalStudent.section, student.section)) {
            frLogic.updateFeedbackResponsesForChangingSection(student.course, finalEmail, originalStudent.section,
                                                              student.section);
        }

        // TODO: check to delete comments for this section/team if the section/team is no longer existent in the course
    }

    public void updateStudentCascadeWithSubmissionAdjustmentScheduled(String originalEmail,
            StudentAttributes student, boolean hasDocument)
            throws EntityDoesNotExistException, InvalidParametersException {
        // Edit student uses KeepOriginal policy, where unchanged fields are set
        // as null. Hence, we can't do isValid() for student here.
        // After updateWithReferenceToExistingStudentRecord method called,
        // the student should be valid

        // here is like a db access that can be avoided if we really want to optimize the code
        studentsDb.verifyStudentExists(student.course, originalEmail);

        StudentAttributes originalStudent = getStudentForEmail(student.course, originalEmail);

        // prepare new student
        student.updateWithExistingRecord(originalStudent);

        if (!student.isValid()) {
            throw new InvalidParametersException(student.getInvalidityInfo());
        }

        studentsDb.updateStudent(student.course, originalEmail, student.name, student.team, student.section,
                                 student.email, student.googleId, student.comments, hasDocument, false);

        // cascade email change, if any
        if (!originalEmail.equals(student.email)) {
            frLogic.updateFeedbackResponsesForChangingEmail(student.course, originalEmail, student.email);
            fsLogic.updateRespondentsForStudent(originalEmail, student.email, student.course);
        }
    }

    public void resetStudentGoogleId(String originalEmail, String courseId, boolean hasDocument)
            throws EntityDoesNotExistException, InvalidParametersException {
        // Edit student uses KeepOriginal policy, where unchanged fields are set
        // as null. Hence, we can't do isValid() for student here.
        // After updateWithExistingRecordWithGoogleIdReset method called,
        // the student should be valid

        studentsDb.verifyStudentExists(courseId, originalEmail);
        StudentAttributes originalStudent = getStudentForEmail(courseId, originalEmail);
        originalStudent.googleId = null;

        if (!originalStudent.isValid()) {
            throw new InvalidParametersException(originalStudent.getInvalidityInfo());
        }
        studentsDb.updateStudent(originalStudent.course, originalEmail, originalStudent.name,
                                 originalStudent.team, originalStudent.section, originalStudent.email,
                                 originalStudent.googleId, originalStudent.comments, hasDocument, false);
    }

    public CourseEnrollmentResult enrollStudents(String enrollLines, String courseId)
            throws EntityDoesNotExistException, EnrollException, InvalidParametersException, EntityAlreadyExistsException {
        return enrollStudents(enrollLines, courseId, true);
    }

    public CourseEnrollmentResult enrollStudentsWithoutDocument(String enrollLines, String courseId)
            throws EntityDoesNotExistException, EnrollException, InvalidParametersException, EntityAlreadyExistsException {
        return enrollStudents(enrollLines, courseId, false);
    }

    private CourseEnrollmentResult enrollStudents(String enrollLines, String courseId, boolean hasDocument)
            throws EntityDoesNotExistException, EnrollException, InvalidParametersException, EntityAlreadyExistsException {

        if (!coursesLogic.isCoursePresent(courseId)) {
            throw new EntityDoesNotExistException(""Course does not exist :""
                    + courseId);
        }

        if (enrollLines.isEmpty()) {
            throw new EnrollException(Const.StatusMessages.ENROLL_LINE_EMPTY);
        }

        List<StudentAttributes> studentList = createStudents(enrollLines, courseId);
        ArrayList<StudentAttributes> returnList = new ArrayList<>();
        ArrayList<StudentEnrollDetails> enrollmentList = new ArrayList<>();

        verifyIsWithinSizeLimitPerEnrollment(studentList);
        validateSectionsAndTeams(studentList, courseId);

        // TODO: can we use a batch persist operation here?
        // enroll all students
        for (StudentAttributes student : studentList) {
            StudentEnrollDetails enrollmentDetails;

            enrollmentDetails = enrollStudent(student, hasDocument);
            student.updateStatus = enrollmentDetails.updateStatus;

            enrollmentList.add(enrollmentDetails);
            returnList.add(student);
        }

        // add to return list students not included in the enroll list.
        List<StudentAttributes> studentsInCourse = getStudentsForCourse(courseId);
        for (StudentAttributes student : studentsInCourse) {
            if (!isInEnrollList(student, returnList)) {
                student.updateStatus = StudentUpdateStatus.NOT_IN_ENROLL_LIST;
                returnList.add(student);
            }
        }

        return new CourseEnrollmentResult(returnList, enrollmentList);
    }

    private void verifyIsWithinSizeLimitPerEnrollment(List<StudentAttributes> students) throws EnrollException {
        if (students.size() > Const.SIZE_LIMIT_PER_ENROLLMENT) {
            throw new EnrollException(Const.StatusMessages.QUOTA_PER_ENROLLMENT_EXCEED);
        }
    }

    /**
     * Validates sections for any limit violations and teams for any team name violations.
     */
    public void validateSectionsAndTeams(List<StudentAttributes> studentList, String courseId) throws EnrollException {

        List<StudentAttributes> mergedList = getMergedList(studentList, courseId);

        if (mergedList.size() < 2) { // no conflicts
            return;
        }

        String errorMessage = getSectionInvalidityInfo(mergedList) + getTeamInvalidityInfo(mergedList);

        if (!errorMessage.isEmpty()) {
            throw new EnrollException(errorMessage);
        }

    }

    /**
     * Validates teams for any team name violations.
     */
    public void validateTeams(List<StudentAttributes> studentList, String courseId) throws EnrollException {

        List<StudentAttributes> mergedList = getMergedList(studentList, courseId);

        if (mergedList.size() < 2) { // no conflicts
            return;
        }

        String errorMessage = getTeamInvalidityInfo(mergedList);

        if (errorMessage.length() > 0) {
            throw new EnrollException(errorMessage);
        }

    }

    private List<StudentAttributes> getMergedList(List<StudentAttributes> studentList, String courseId) {

        List<StudentAttributes> mergedList = new ArrayList<>();
        List<StudentAttributes> studentsInCourse = getStudentsForCourse(courseId);

        for (StudentAttributes student : studentList) {
            mergedList.add(student);
        }

        for (StudentAttributes student : studentsInCourse) {
            if (!isInEnrollList(student, mergedList)) {
                mergedList.add(student);
            }
        }
        return mergedList;
    }

    public String getSectionForTeam(String courseId, String teamName) {

        List<StudentAttributes> students = getStudentsForTeam(teamName, courseId);
        if (students.isEmpty()) {
            return Const.DEFAULT_SECTION;
        }
        return students.get(0).section;
    }

    private String getSectionInvalidityInfo(List<StudentAttributes> mergedList) {

        StudentAttributes.sortBySectionName(mergedList);

        List<String> invalidSectionList = new ArrayList<>();
        int studentsCount = 1;
        for (int i = 1; i < mergedList.size(); i++) {
            StudentAttributes currentStudent = mergedList.get(i);
            StudentAttributes previousStudent = mergedList.get(i - 1);
            if (currentStudent.section.equals(previousStudent.section)) {
                studentsCount++;
            } else {
                if (studentsCount > SECTION_SIZE_LIMIT) {
                    invalidSectionList.add(previousStudent.section);
                }
                studentsCount = 1;
            }

            if (i == mergedList.size() - 1 && studentsCount > SECTION_SIZE_LIMIT) {
                invalidSectionList.add(currentStudent.section);
            }
        }

        StringBuilder errorMessage = new StringBuilder();
        for (String section : invalidSectionList) {
            errorMessage.append(String.format(Const.StatusMessages.SECTION_QUOTA_EXCEED, section));
        }

        return errorMessage.toString();
    }

    private String getTeamInvalidityInfo(List<StudentAttributes> mergedList) {

        StudentAttributes.sortByTeamName(mergedList);

        List<String> invalidTeamList = new ArrayList<>();
        for (int i = 1; i < mergedList.size(); i++) {
            StudentAttributes currentStudent = mergedList.get(i);
            StudentAttributes previousStudent = mergedList.get(i - 1);
            if (currentStudent.team.equals(previousStudent.team)
                    && !currentStudent.section.equals(previousStudent.section)
                    && !invalidTeamList.contains(currentStudent.team)) {
                invalidTeamList.add(currentStudent.team);
            }
        }

        StringBuilder errorMessage = new StringBuilder(100);
        for (String team : invalidTeamList) {
            errorMessage.append(String.format(Const.StatusMessages.TEAM_INVALID_SECTION_EDIT,
                                              SanitizationHelper.sanitizeForHtml(team)));
        }

        if (errorMessage.length() != 0) {
            errorMessage.append(""Please use the enroll page to edit multiple students"");
        }

        return errorMessage.toString();
    }

    public void deleteAllStudentsInCourse(String courseId) {
        List<StudentAttributes> studentsInCourse = getStudentsForCourse(courseId);
        for (StudentAttributes student : studentsInCourse) {
            deleteStudentCascade(courseId, student.email);
        }
    }

    public void deleteStudentCascade(String courseId, String studentEmail) {
        deleteStudentCascade(courseId, studentEmail, true);
    }

    public void deleteStudentCascadeWithoutDocument(String courseId, String studentEmail) {
        deleteStudentCascade(courseId, studentEmail, false);
    }

    public void deleteStudentCascade(String courseId, String studentEmail, boolean hasDocument) {
        // delete responses before deleting the student as we need to know the student's team.
        frLogic.deleteFeedbackResponsesForStudentAndCascade(courseId, studentEmail);
        fsLogic.deleteStudentFromRespondentsList(getStudentForEmail(courseId, studentEmail));
        studentsDb.deleteStudent(courseId, studentEmail, hasDocument);
    }

    public void deleteStudentsForGoogleId(String googleId) {
        List<StudentAttributes> students = studentsDb.getStudentsForGoogleId(googleId);
        for (StudentAttributes student : students) {
            fsLogic.deleteStudentFromRespondentsList(student);
        }
        studentsDb.deleteStudentsForGoogleId(googleId);
    }

    public void deleteStudentsForGoogleIdWithoutDocument(String googleId) {
        List<StudentAttributes> students = studentsDb.getStudentsForGoogleId(googleId);
        for (StudentAttributes student : students) {
            fsLogic.deleteStudentFromRespondentsList(student);
        }
        studentsDb.deleteStudentsForGoogleIdWithoutDocument(googleId);
    }

    public void deleteStudentsForGoogleIdAndCascade(String googleId) {
        List<StudentAttributes> students = studentsDb.getStudentsForGoogleId(googleId);

        // Cascade delete students
        for (StudentAttributes student : students) {
            deleteStudentCascade(student.course, student.email);
        }
    }

    public void deleteStudentsForCourse(String courseId) {
        studentsDb.deleteStudentsForCourse(courseId);
    }

    public void deleteStudentsForCourseWithoutDocument(String courseId) {
        studentsDb.deleteStudentsForCourseWithoutDocument(courseId);
    }

    public void adjustFeedbackResponseForEnrollments(
            List<StudentEnrollDetails> enrollmentList,
            FeedbackResponseAttributes response) throws InvalidParametersException, EntityDoesNotExistException {
        for (StudentEnrollDetails enrollment : enrollmentList) {
            if (enrollment.updateStatus != StudentUpdateStatus.MODIFIED) {
                continue;
            }

            boolean isResponseDeleted = false;
            if (isTeamChanged(enrollment.oldTeam, enrollment.newTeam)) {
                isResponseDeleted = frLogic.updateFeedbackResponseForChangingTeam(enrollment, response);
            }

            if (!isResponseDeleted && isSectionChanged(enrollment.oldSection, enrollment.newSection)) {
                frLogic.updateFeedbackResponseForChangingSection(enrollment, response);
            }
        }
    }

    public void putDocument(StudentAttributes student) {
        studentsDb.putDocument(student);
    }

    /**
     * Batch creates or updates documents for the given students.
     */
    public void putDocuments(List<StudentAttributes> students) {
        studentsDb.putDocuments(students);
    }

    private StudentEnrollDetails enrollStudent(StudentAttributes validStudentAttributes, Boolean hasDocument)
            throws InvalidParametersException, EntityDoesNotExistException, EntityAlreadyExistsException {
        StudentAttributes originalStudentAttributes = getStudentForEmail(
                validStudentAttributes.course, validStudentAttributes.email);

        StudentEnrollDetails enrollmentDetails = new StudentEnrollDetails();
        enrollmentDetails.course = validStudentAttributes.course;
        enrollmentDetails.email = validStudentAttributes.email;
        enrollmentDetails.newTeam = validStudentAttributes.team;
        enrollmentDetails.newSection = validStudentAttributes.section;

        boolean isModifyingExistingStudent = originalStudentAttributes != null;
        if (validStudentAttributes.isEnrollInfoSameAs(originalStudentAttributes)) {
            enrollmentDetails.updateStatus = StudentUpdateStatus.UNMODIFIED;
        } else if (isModifyingExistingStudent) {
            updateStudentCascadeWithSubmissionAdjustmentScheduled(originalStudentAttributes.email,
                                                                  validStudentAttributes, true);
            enrollmentDetails.updateStatus = StudentUpdateStatus.MODIFIED;

            if (!originalStudentAttributes.team.equals(validStudentAttributes.team)) {
                enrollmentDetails.oldTeam = originalStudentAttributes.team;
            }
            if (!originalStudentAttributes.section.equals(validStudentAttributes.section)) {
                enrollmentDetails.oldSection = originalStudentAttributes.section;
            }
        } else {
            createStudentCascade(validStudentAttributes, hasDocument);
            enrollmentDetails.updateStatus = StudentUpdateStatus.NEW;
        }

        return enrollmentDetails;
    }

    /**
     * Builds {@code studentList} from user input {@code lines}. All empty lines or lines with only white spaces will
     * be skipped.
     *
     * @param lines the enrollment lines entered by the instructor.
     * @throws EnrollException if some of the student instances created are invalid. The exception message contains
     *         invalidity info for all invalid student instances in HTML format.
     */
    public List<StudentAttributes> createStudents(String lines, String courseId) throws EnrollException {
        List<String> invalidityInfo = new ArrayList<>();
        String[] linesArray = lines.split(Const.EOL);
        ArrayList<String> studentEmailList = new ArrayList<>();
        List<StudentAttributes> studentList = new ArrayList<>();

        StudentAttributesFactory saf = new StudentAttributesFactory(linesArray[0]);

        for (int i = 1; i < linesArray.length; i++) {
            String line = linesArray[i];
            String sanitizedLine = SanitizationHelper.sanitizeForHtml(line);
            try {
                if (StringHelper.isWhiteSpace(line)) {
                    continue;
                }
                StudentAttributes student = saf.makeStudent(line, courseId);

                if (!student.isValid()) {
                    String info = StringHelper.toString(SanitizationHelper.sanitizeForHtml(student.getInvalidityInfo()),
                                                    ""<br>"" + Const.StatusMessages.ENROLL_LINES_PROBLEM_DETAIL_PREFIX + "" "");
                    invalidityInfo.add(String.format(Const.StatusMessages.ENROLL_LINES_PROBLEM, sanitizedLine, info));
                }

                if (isStudentEmailDuplicated(student.email, studentEmailList)) {
                    String info =
                            StringHelper.toString(
                                    getInvalidityInfoInDuplicatedEmail(student.email, studentEmailList, linesArray),
                                    ""<br>"" + Const.StatusMessages.ENROLL_LINES_PROBLEM_DETAIL_PREFIX + "" "");
                    invalidityInfo.add(String.format(Const.StatusMessages.ENROLL_LINES_PROBLEM, sanitizedLine, info));
                }

                studentEmailList.add(student.email);
                studentList.add(student);
            } catch (EnrollException e) {
                String info = String.format(Const.StatusMessages.ENROLL_LINES_PROBLEM, sanitizedLine, e.getMessage());
                invalidityInfo.add(info);
            }
        }

        if (!invalidityInfo.isEmpty()) {
            throw new EnrollException(StringHelper.toString(invalidityInfo, ""<br>""));
        }

        return studentList;
    }

    private List<String> getInvalidityInfoInDuplicatedEmail(String email,
            List<String> studentEmailList, String[] linesArray) {
        List<String> info = new ArrayList<>();
        info.add(""Same email address as the student in line \"""" + linesArray[studentEmailList.indexOf(email) + 1] + ""\"""");
        return info;
    }

    private boolean isStudentEmailDuplicated(String email,
            List<String> studentEmailList) {
        return studentEmailList.contains(email);
    }

    private boolean isInEnrollList(StudentAttributes student,
            List<StudentAttributes> studentInfoList) {
        for (StudentAttributes studentInfo : studentInfoList) {
            if (studentInfo.email.equalsIgnoreCase(student.email)) {
                return true;
            }
        }
        return false;
    }

    private boolean isTeamChanged(String originalTeam, String newTeam) {
        return newTeam != null && originalTeam != null
                && !originalTeam.equals(newTeam);
    }

    private boolean isSectionChanged(String originalSection, String newSection) {
        return newSection != null && originalSection != null
                && !originalSection.equals(newSection);
    }

    public TeamDetailsBundle getTeamDetailsForStudent(StudentAttributes student) {
        if (student != null) {
            TeamDetailsBundle teamResult = new TeamDetailsBundle();
            teamResult.name = student.team;
            teamResult.students = getStudentsForTeam(student.team, student.course);
            StudentAttributes.sortByNameAndThenByEmail(teamResult.students);
            return teamResult;
        }
        return null;
    }

}
"
TaskQueuesLogic.java,logic-core,"package teammates.logic.core;

import java.util.Map;

import com.google.appengine.api.taskqueue.Queue;
import com.google.appengine.api.taskqueue.QueueFactory;
import com.google.appengine.api.taskqueue.TaskOptions;

import teammates.common.util.TaskWrapper;

/**
 * Handles operations related to task queues.
 */
public class TaskQueuesLogic {

    /**
     * Adds the given task to the specified queue.
     *
     * @param task the task object containing the details of task to be added
     */
    public void addTask(TaskWrapper task) {
        addDeferredTask(task, 0);
    }

    /**
     * Adds the given task, to be run after the specified time, to the specified queue.
     *
     * @param task the task object containing the details of task to be added
     * @param countdownTime the time delay for the task to be executed
     */
    public void addDeferredTask(TaskWrapper task, long countdownTime) {
        Queue requiredQueue = QueueFactory.getQueue(task.getQueueName());
        TaskOptions taskToBeAdded = TaskOptions.Builder.withUrl(task.getWorkerUrl());
        if (countdownTime > 0) {
            taskToBeAdded.countdownMillis(countdownTime);
        }

        for (Map.Entry<String, String[]> entry : task.getParamMap().entrySet()) {
            String name = entry.getKey();
            String[] values = entry.getValue();

            for (String value : values) {
                taskToBeAdded = taskToBeAdded.param(name, value);
            }
        }

        requiredQueue.add(taskToBeAdded);
    }

}
"
FeedbackResponseCommentSearchDocument.java,search,"package teammates.storage.search;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import com.google.appengine.api.search.Document;
import com.google.appengine.api.search.Field;
import com.google.appengine.api.search.Results;
import com.google.appengine.api.search.ScoredDocument;

import teammates.common.datatransfer.FeedbackParticipantType;
import teammates.common.datatransfer.FeedbackResponseCommentSearchResultBundle;
import teammates.common.datatransfer.FeedbackSessionResultsBundle;
import teammates.common.datatransfer.attributes.CourseAttributes;
import teammates.common.datatransfer.attributes.FeedbackQuestionAttributes;
import teammates.common.datatransfer.attributes.FeedbackResponseAttributes;
import teammates.common.datatransfer.attributes.FeedbackResponseCommentAttributes;
import teammates.common.datatransfer.attributes.FeedbackSessionAttributes;
import teammates.common.datatransfer.attributes.InstructorAttributes;
import teammates.common.datatransfer.attributes.StudentAttributes;
import teammates.common.util.Const;
import teammates.common.util.JsonUtils;

/**
 * The {@link SearchDocument} object that defines how we store {@link Document} for response comments.
 */
public class FeedbackResponseCommentSearchDocument extends SearchDocument {

    private FeedbackResponseCommentAttributes comment;
    private FeedbackResponseAttributes relatedResponse;
    private String responseGiverName;
    private String responseRecipientName;
    private FeedbackQuestionAttributes relatedQuestion;
    private FeedbackSessionAttributes relatedSession;
    private CourseAttributes course;
    private InstructorAttributes giverAsInstructor; // comment giver
    private List<InstructorAttributes> relatedInstructors;
    private List<StudentAttributes> relatedStudents;

    public FeedbackResponseCommentSearchDocument(FeedbackResponseCommentAttributes comment) {
        this.comment = comment;
    }

    @Override
    protected void prepareData() {
        if (comment == null) {
            return;
        }

        relatedSession = fsDb.getFeedbackSession(comment.courseId, comment.feedbackSessionName);
        relatedQuestion = fqDb.getFeedbackQuestion(comment.feedbackQuestionId);
        relatedResponse = frDb.getFeedbackResponse(comment.feedbackResponseId);
        course = coursesDb.getCourse(comment.courseId);
        giverAsInstructor = instructorsDb.getInstructorForEmail(comment.courseId, comment.giverEmail);
        relatedInstructors = new ArrayList<>();
        relatedStudents = new ArrayList<>();

        // prepare the response giver name and recipient name
        Set<String> addedEmailSet = new HashSet<>();
        if (relatedQuestion.giverType == FeedbackParticipantType.INSTRUCTORS
                || relatedQuestion.giverType == FeedbackParticipantType.SELF) {
            InstructorAttributes ins = instructorsDb.getInstructorForEmail(comment.courseId, relatedResponse.giver);
            if (ins == null || addedEmailSet.contains(ins.email)) {
                responseGiverName = Const.USER_UNKNOWN_TEXT;
            } else {
                relatedInstructors.add(ins);
                addedEmailSet.add(ins.email);
                responseGiverName = ins.name + "" ("" + ins.displayedName + "")"";
            }
        } else {
            StudentAttributes stu = studentsDb.getStudentForEmail(comment.courseId, relatedResponse.giver);
            if (stu == null || addedEmailSet.contains(stu.email)) {
                responseGiverName = Const.USER_UNKNOWN_TEXT;
            } else {
                relatedStudents.add(stu);
                addedEmailSet.add(stu.email);
                responseGiverName = stu.name + "" ("" + stu.team + "")"";
            }
        }

        if (relatedQuestion.recipientType == FeedbackParticipantType.INSTRUCTORS) {
            InstructorAttributes ins = instructorsDb.getInstructorForEmail(comment.courseId, relatedResponse.recipient);
            if (ins != null && !addedEmailSet.contains(ins.email)) {
                relatedInstructors.add(ins);
                addedEmailSet.add(ins.email);
                responseRecipientName = ins.name + "" ("" + ins.displayedName + "")"";
            }
        } else if (relatedQuestion.recipientType == FeedbackParticipantType.SELF) {
            responseRecipientName = responseGiverName;
        } else if (relatedQuestion.recipientType == FeedbackParticipantType.NONE) {
            responseRecipientName = Const.USER_NOBODY_TEXT;
        } else {
            StudentAttributes stu = studentsDb.getStudentForEmail(comment.courseId, relatedResponse.recipient);
            if (stu != null && !addedEmailSet.contains(stu.email)) {
                relatedStudents.add(stu);
                addedEmailSet.add(stu.email);
                responseRecipientName = stu.name + "" ("" + stu.team + "")"";
            }
            List<StudentAttributes> team = studentsDb.getStudentsForTeam(relatedResponse.recipient, comment.courseId);
            if (team != null) {
                responseRecipientName = relatedResponse.recipient; // it's actually a team name here
                for (StudentAttributes studentInTeam : team) {
                    if (!addedEmailSet.contains(studentInTeam.email)) {
                        relatedStudents.add(studentInTeam);
                        addedEmailSet.add(studentInTeam.email);
                    }
                }
            }
            if (stu == null || team == null) {
                responseRecipientName = Const.USER_UNKNOWN_TEXT;
            }
        }
    }

    @Override
    public Document toDocument() {

        // populate related Students/Instructors information
        StringBuilder relatedPeopleBuilder = new StringBuilder("""");
        String delim = "","";
        int counter = 0;
        for (StudentAttributes student : relatedStudents) {
            if (counter == 25) {
                break; // in case of exceeding size limit for document
            }
            relatedPeopleBuilder.append(student.email).append(delim)
                .append(student.name).append(delim)
                .append(student.team).append(delim)
                .append(student.section).append(delim);
            counter++;
        }
        counter = 0;
        for (InstructorAttributes instructor : relatedInstructors) {
            if (counter == 25) {
                break;
            }
            relatedPeopleBuilder.append(instructor.email).append(delim)
                .append(instructor.name).append(delim)
                .append(instructor.displayedName).append(delim);
            counter++;
        }

        // produce searchableText for this feedback comment document:
        // it contains courseId, courseName, feedback session name, question number, question title,
        // response answer commentGiverEmail, commentGiverName, related people's information, and commentText
        String searchableText = comment.courseId + delim
                                + (course == null ? """" : course.getName()) + delim
                                + relatedSession.getFeedbackSessionName() + delim
                                + ""question "" + relatedQuestion.questionNumber + delim
                                + relatedQuestion.getQuestionDetails().getQuestionText() + delim
                                + relatedResponse.getResponseDetails().getAnswerString() + delim
                                + comment.giverEmail + delim
                                + (giverAsInstructor == null ? """" : giverAsInstructor.name) + delim
                                + relatedPeopleBuilder.toString() + delim
                                + comment.commentText.getValue();

        // for data-migration use
        boolean isVisibilityFollowingFeedbackQuestion = comment.isVisibilityFollowingFeedbackQuestion;
        boolean isVisibleToGiver = isVisibilityFollowingFeedbackQuestion
                                   || comment.isVisibleTo(FeedbackParticipantType.GIVER);
        boolean isVisibleToReceiver = isVisibilityFollowingFeedbackQuestion
                                    ? relatedQuestion.isResponseVisibleTo(FeedbackParticipantType.RECEIVER)
                                    : comment.isVisibleTo(FeedbackParticipantType.RECEIVER);
        boolean isVisibleToInstructor = isVisibilityFollowingFeedbackQuestion
                                      ? relatedQuestion.isResponseVisibleTo(FeedbackParticipantType.INSTRUCTORS)
                                      : comment.isVisibleTo(FeedbackParticipantType.INSTRUCTORS);

        String displayedName = giverAsInstructor == null
                               ? comment.giverEmail
                               : giverAsInstructor.displayedName + "" "" + giverAsInstructor.name;
        return Document.newBuilder()
                // these are used to filter documents visible to certain instructor
                // TODO: some of the following fields are not used anymore
                // (refer to {@link FeedbackResponseCommentSearchQuery}), can remove them
                .addField(Field.newBuilder().setName(Const.SearchDocumentField.COURSE_ID)
                                            .setText(comment.courseId))
                .addField(Field.newBuilder().setName(Const.SearchDocumentField.FEEDBACK_RESPONSE_COMMENT_GIVER_EMAIL)
                                            .setText(comment.giverEmail))
                .addField(Field.newBuilder().setName(Const.SearchDocumentField.GIVER_EMAIL)
                                            .setText(relatedResponse.giver))
                .addField(Field.newBuilder().setName(Const.SearchDocumentField.GIVER_SECTION)
                                            .setText(relatedResponse.giverSection))
                .addField(Field.newBuilder().setName(Const.SearchDocumentField.RECIPIENT_EMAIL)
                                            .setText(relatedResponse.recipient))
                .addField(Field.newBuilder().setName(Const.SearchDocumentField.RECIPIENT_SECTION)
                                            .setText(relatedResponse.recipientSection))
                .addField(Field.newBuilder().setName(Const.SearchDocumentField.IS_VISIBLE_TO_GIVER)
                                            .setText(Boolean.toString(isVisibleToGiver)))
                .addField(Field.newBuilder().setName(Const.SearchDocumentField.IS_VISIBLE_TO_RECEIVER)
                                            .setText(Boolean.toString(isVisibleToReceiver)))
                .addField(Field.newBuilder().setName(Const.SearchDocumentField.IS_VISIBLE_TO_INSTRUCTOR)
                                            .setText(Boolean.toString(isVisibleToInstructor)))
                // searchableText and createdDate are used to match the query string
                .addField(Field.newBuilder().setName(Const.SearchDocumentField.SEARCHABLE_TEXT)
                                            .setText(searchableText))
                .addField(Field.newBuilder().setName(Const.SearchDocumentField.CREATED_DATE)
                                            .setDate(comment.createdAt))
                // attribute field is used to convert a doc back to attribute
                .addField(Field.newBuilder().setName(Const.SearchDocumentField.FEEDBACK_RESPONSE_COMMENT_ATTRIBUTE)
                                            .setText(JsonUtils.toJson(comment)))
                .addField(Field.newBuilder().setName(Const.SearchDocumentField.FEEDBACK_RESPONSE_ATTRIBUTE)
                                            .setText(JsonUtils.toJson(relatedResponse)))
                .addField(Field.newBuilder().setName(Const.SearchDocumentField.FEEDBACK_RESPONSE_GIVER_NAME)
                                            .setText(JsonUtils.toJson(responseGiverName)))
                .addField(Field.newBuilder().setName(Const.SearchDocumentField.FEEDBACK_RESPONSE_RECEIVER_NAME)
                                            .setText(JsonUtils.toJson(responseRecipientName)))
                .addField(Field.newBuilder().setName(Const.SearchDocumentField.FEEDBACK_QUESTION_ATTRIBUTE)
                                            .setText(JsonUtils.toJson(relatedQuestion)))
                .addField(Field.newBuilder().setName(Const.SearchDocumentField.FEEDBACK_SESSION_ATTRIBUTE)
                                            .setText(JsonUtils.toJson(relatedSession)))
                .addField(Field.newBuilder().setName(Const.SearchDocumentField.FEEDBACK_RESPONSE_COMMENT_GIVER_NAME)
                                            .setText(JsonUtils.toJson(displayedName)))
                .setId(comment.getId().toString())
                .build();
    }

    /**
     * Produces a {@link FeedbackResponseCommentSearchResultBundle} from the {@code Results<ScoredDocument>} collection.
     * The list of {@link InstructorAttributes} is used to filter out the search result.
     */
    public static FeedbackResponseCommentSearchResultBundle fromResults(
            Results<ScoredDocument> results, List<InstructorAttributes> instructors) {
        FeedbackResponseCommentSearchResultBundle bundle = new FeedbackResponseCommentSearchResultBundle();
        if (results == null) {
            return bundle;
        }

        // get instructor's information
        bundle.instructorEmails = new HashSet<>();
        Set<String> instructorCourseIdList = new HashSet<>();
        for (InstructorAttributes ins : instructors) {
            bundle.instructorEmails.add(ins.email);
            instructorCourseIdList.add(ins.courseId);
        }

        Set<String> isAdded = new HashSet<>();

        List<ScoredDocument> filteredResults = filterOutCourseId(results, instructors);
        for (ScoredDocument doc : filteredResults) {
            // get FeedbackResponseComment from results
            FeedbackResponseCommentAttributes comment = JsonUtils.fromJson(
                    doc.getOnlyField(Const.SearchDocumentField.FEEDBACK_RESPONSE_COMMENT_ATTRIBUTE).getText(),
                    FeedbackResponseCommentAttributes.class);
            if (frcDb.getFeedbackResponseComment(comment.getId()) == null) {
                frcDb.deleteDocument(comment);
                continue;
            }
            List<FeedbackResponseCommentAttributes> commentList = bundle.comments.get(comment.feedbackResponseId);
            if (commentList == null) {
                commentList = new ArrayList<>();
                bundle.comments.put(comment.feedbackResponseId, commentList);
            }
            commentList.add(comment);

            // get related response from results
            FeedbackResponseAttributes response = JsonUtils.fromJson(
                    doc.getOnlyField(Const.SearchDocumentField.FEEDBACK_RESPONSE_ATTRIBUTE).getText(),
                    FeedbackResponseAttributes.class);
            if (frDb.getFeedbackResponse(response.getId()) == null) {
                frcDb.deleteDocument(comment);
                continue;
            }
            List<FeedbackResponseAttributes> responseList = bundle.responses.get(response.feedbackQuestionId);
            if (responseList == null) {
                responseList = new ArrayList<>();
                bundle.responses.put(response.feedbackQuestionId, responseList);
            }
            if (!isAdded.contains(response.getId())) {
                isAdded.add(response.getId());
                responseList.add(response);
            }

            // get related question from results
            FeedbackQuestionAttributes question = JsonUtils.fromJson(
                    doc.getOnlyField(Const.SearchDocumentField.FEEDBACK_QUESTION_ATTRIBUTE).getText(),
                    FeedbackQuestionAttributes.class);
            if (fqDb.getFeedbackQuestion(question.getId()) == null) {
                frcDb.deleteDocument(comment);
                continue;
            }
            List<FeedbackQuestionAttributes> questionList = bundle.questions.get(question.feedbackSessionName);
            if (questionList == null) {
                questionList = new ArrayList<>();
                bundle.questions.put(question.feedbackSessionName, questionList);
            }
            if (!isAdded.contains(question.getId())) {
                isAdded.add(question.getId());
                questionList.add(question);
            }

            // get related session from results
            FeedbackSessionAttributes session = JsonUtils.fromJson(
                    doc.getOnlyField(Const.SearchDocumentField.FEEDBACK_SESSION_ATTRIBUTE).getText(),
                    FeedbackSessionAttributes.class);
            if (fsDb.getFeedbackSession(session.getCourseId(), session.getSessionName()) == null) {
                frcDb.deleteDocument(comment);
                continue;
            }
            if (!isAdded.contains(session.getFeedbackSessionName())) {
                isAdded.add(session.getFeedbackSessionName());
                bundle.sessions.put(session.getSessionName(), session);
            }

            // get giver and recipient names
            String responseGiverName = extractContentFromQuotedString(
                    doc.getOnlyField(Const.SearchDocumentField.FEEDBACK_RESPONSE_GIVER_NAME).getText());
            bundle.responseGiverTable.put(response.getId(),
                    getFilteredGiverName(bundle, instructorCourseIdList, response, responseGiverName));

            String responseRecipientName = extractContentFromQuotedString(
                    doc.getOnlyField(Const.SearchDocumentField.FEEDBACK_RESPONSE_RECEIVER_NAME).getText());
            bundle.responseRecipientTable.put(response.getId(),
                    getFilteredRecipientName(bundle, instructorCourseIdList, response, responseRecipientName));

            String commentGiverName = extractContentFromQuotedString(
                    doc.getOnlyField(Const.SearchDocumentField.FEEDBACK_RESPONSE_COMMENT_GIVER_NAME).getText());
            bundle.commentGiverTable.put(comment.getId().toString(),
                    getFilteredCommentGiverName(bundle, instructorCourseIdList, response, comment, commentGiverName));
            bundle.instructorEmailNameTable.put(comment.giverEmail, commentGiverName);
            boolean isLastEditorEmailInMap = !comment.lastEditorEmail.isEmpty()
                    && bundle.instructorEmailNameTable.containsKey(comment.lastEditorEmail);
            if (!isLastEditorEmailInMap) {
                InstructorAttributes instructor =
                        instructorsDb.getInstructorForEmail(response.courseId, comment.lastEditorEmail);
                String commentLastEditorName = instructor.displayedName + "" "" + instructor.name;
                bundle.instructorEmailNameTable.put(comment.lastEditorEmail, commentLastEditorName);
            }
            bundle.numberOfResults++;
        }
        for (List<FeedbackQuestionAttributes> questions : bundle.questions.values()) {
            Collections.sort(questions);
        }

        for (List<FeedbackResponseAttributes> responses : bundle.responses.values()) {
            FeedbackResponseAttributes.sortFeedbackResponses(responses);
        }

        for (List<FeedbackResponseCommentAttributes> responseComments : bundle.comments.values()) {
            FeedbackResponseCommentAttributes.sortFeedbackResponseCommentsByCreationTime(responseComments);
        }

        bundle.numberOfResults =
                filterFeedbackResponseCommentResults(bundle, instructors, bundle.numberOfResults);
        removeQuestionsAndResponsesWithoutComments(bundle);
        return bundle;
    }

    private static String getFilteredCommentGiverName(FeedbackResponseCommentSearchResultBundle bundle,
                                                      Set<String> instructorCourseIdList,
                                                      FeedbackResponseAttributes response,
                                                      FeedbackResponseCommentAttributes comment, String name) {
        return isCommentGiverNameVisibleToInstructor(
                bundle.instructorEmails, instructorCourseIdList, response, comment) ? name : ""Anonymous"";
    }

    private static String getFilteredGiverName(FeedbackResponseCommentSearchResultBundle bundle,
                                               Set<String> instructorCourseIdList,
                                               FeedbackResponseAttributes response, String name) {
        FeedbackQuestionAttributes question = getFeedbackQuestion(bundle.questions, response);
        if (!isNameVisibleToInstructor(bundle.instructorEmails, instructorCourseIdList,
                                       response, question.showGiverNameTo)
                && question.giverType != FeedbackParticipantType.SELF) {
            return FeedbackSessionResultsBundle.getAnonName(question.giverType, name);
        }
        return name;
    }

    private static String getFilteredRecipientName(FeedbackResponseCommentSearchResultBundle bundle,
                                                   Set<String> instructorCourseIdList,
                                                   FeedbackResponseAttributes response, String name) {
        FeedbackQuestionAttributes question = getFeedbackQuestion(bundle.questions, response);
        if (!isNameVisibleToInstructor(bundle.instructorEmails, instructorCourseIdList,
                                       response, question.showRecipientNameTo)
                && question.recipientType != FeedbackParticipantType.SELF
                && question.recipientType != FeedbackParticipantType.NONE) {
            return FeedbackSessionResultsBundle.getAnonName(question.recipientType, name);
        }
        return name;
    }

    private static FeedbackQuestionAttributes getFeedbackQuestion(
            Map<String, List<FeedbackQuestionAttributes>> questions, FeedbackResponseAttributes response) {
        FeedbackQuestionAttributes question = null;
        for (FeedbackQuestionAttributes qn : questions.get(response.feedbackSessionName)) {
            if (qn.getId().equals(response.feedbackQuestionId)) {
                question = qn;
                break;
            }
        }
        return question;
    }

    private static boolean isCommentGiverNameVisibleToInstructor(
            Set<String> instructorEmails, Set<String> instructorCourseIdList,
            FeedbackResponseAttributes response, FeedbackResponseCommentAttributes comment) {
        // in the old ver, name is always visible
        if (comment.isVisibilityFollowingFeedbackQuestion) {
            return true;
        }

        // comment giver can always see
        if (instructorEmails.contains(comment.giverEmail)) {
            return true;
        }
        List<FeedbackParticipantType> showNameTo = comment.showGiverNameTo;
        for (FeedbackParticipantType type : showNameTo) {
            if (type == FeedbackParticipantType.GIVER
                    && instructorEmails.contains(response.giver)) {
                return true;
            } else if (type == FeedbackParticipantType.INSTRUCTORS
                    && instructorCourseIdList.contains(response.courseId)) {
                return true;
            } else if (type == FeedbackParticipantType.RECEIVER
                    && instructorEmails.contains(response.recipient)) {
                return true;
            }
        }
        return false;
    }

    private static boolean isNameVisibleToInstructor(
            Set<String> instructorEmails, Set<String> instructorCourseIdList,
            FeedbackResponseAttributes response, List<FeedbackParticipantType> showNameTo) {
        // giver can always see
        if (instructorEmails.contains(response.giver)) {
            return true;
        }
        for (FeedbackParticipantType type : showNameTo) {
            if (type == FeedbackParticipantType.INSTRUCTORS
                    && instructorCourseIdList.contains(response.courseId)) {
                return true;
            } else if (type == FeedbackParticipantType.RECEIVER
                    && instructorEmails.contains(response.recipient)) {
                return true;
            }
        }
        return false;
    }

    private static int filterFeedbackResponseCommentResults(
            FeedbackResponseCommentSearchResultBundle frCommentSearchResults,
            List<InstructorAttributes> instructors, int totalResultsSize) {

        Iterator<Entry<String, List<FeedbackResponseAttributes>>> iterFr =
                frCommentSearchResults.responses.entrySet().iterator();

        int filteredResultsSize = totalResultsSize;
        while (iterFr.hasNext()) {
            List<FeedbackResponseAttributes> frs = iterFr.next().getValue();
            Iterator<FeedbackResponseAttributes> fr = frs.iterator();

            while (fr.hasNext()) {
                FeedbackResponseAttributes response = fr.next();
                InstructorAttributes instructor = getInstructorForCourseId(response.courseId, instructors);

                boolean isVisibleResponse = true;
                boolean isNotAllowedForInstructor =
                        instructor == null
                        || !instructor.isAllowedForPrivilege(
                                response.giverSection, response.feedbackSessionName,
                                Const.ParamsNames.INSTRUCTOR_PERMISSION_VIEW_SESSION_IN_SECTIONS)
                        || !instructor.isAllowedForPrivilege(
                                response.recipientSection, response.feedbackSessionName,
                                Const.ParamsNames.INSTRUCTOR_PERMISSION_VIEW_SESSION_IN_SECTIONS);

                if (isNotAllowedForInstructor) {
                    isVisibleResponse = false;
                }
                if (!isVisibleResponse) {
                    int sizeOfCommentList = frCommentSearchResults.comments.get(response.getId()).size();
                    filteredResultsSize -= sizeOfCommentList;
                    // TODO: also need to decrease the size for (fr)CommentSearchResults|studentSearchResults
                    frCommentSearchResults.comments.remove(response.getId());
                    fr.remove();
                }
            }
        }

        Set<String> emailList = frCommentSearchResults.instructorEmails;
        Iterator<Entry<String, List<FeedbackQuestionAttributes>>> iterQn =
                frCommentSearchResults.questions.entrySet().iterator();
        while (iterQn.hasNext()) {
            String fsName = iterQn.next().getKey();
            List<FeedbackQuestionAttributes> questionList = frCommentSearchResults.questions.get(fsName);

            for (int i = questionList.size() - 1; i >= 0; i--) {
                FeedbackQuestionAttributes question = questionList.get(i);
                List<FeedbackResponseAttributes> responseList = frCommentSearchResults.responses.get(question.getId());

                for (int j = responseList.size() - 1; j >= 0; j--) {
                    FeedbackResponseAttributes response = responseList.get(j);
                    List<FeedbackResponseCommentAttributes> commentList =
                            frCommentSearchResults.comments.get(response.getId());

                    for (int k = commentList.size() - 1; k >= 0; k--) {
                        FeedbackResponseCommentAttributes comment = commentList.get(k);

                        if (emailList.contains(comment.giverEmail)) {
                            continue;
                        }

                        boolean isVisibilityFollowingFeedbackQuestion = comment.isVisibilityFollowingFeedbackQuestion;
                        boolean isVisibleToGiver = isVisibilityFollowingFeedbackQuestion
                                || comment.isVisibleTo(FeedbackParticipantType.GIVER);

                        if (isVisibleToGiver && emailList.contains(response.giver)) {
                            continue;
                        }

                        boolean isVisibleToReceiver = isVisibilityFollowingFeedbackQuestion
                                ? question.isResponseVisibleTo(FeedbackParticipantType.RECEIVER)
                                : comment.isVisibleTo(FeedbackParticipantType.RECEIVER);

                        if (isVisibleToReceiver && emailList.contains(response.recipient)) {
                            continue;
                        }

                        boolean isVisibleToInstructor = isVisibilityFollowingFeedbackQuestion
                                ? question.isResponseVisibleTo(FeedbackParticipantType.INSTRUCTORS)
                                : comment.isVisibleTo(FeedbackParticipantType.INSTRUCTORS);

                        if (isVisibleToInstructor) {
                            continue;
                        }
                        commentList.remove(k);
                    }
                    if (commentList.isEmpty()) {
                        responseList.remove(j);
                    }
                }
                if (responseList.isEmpty()) {
                    questionList.remove(i);
                }
            }
            if (questionList.isEmpty()) {
                iterQn.remove();
            }
        }

        return filteredResultsSize;
    }

    private static InstructorAttributes getInstructorForCourseId(String courseId, List<InstructorAttributes> instructors) {
        for (InstructorAttributes instructor : instructors) {
            if (instructor.courseId.equals(courseId)) {
                return instructor;
            }
        }

        return null;
    }

    private static void removeQuestionsAndResponsesWithoutComments(
            FeedbackResponseCommentSearchResultBundle frCommentSearchResults) {
        Iterator<Entry<String, List<FeedbackQuestionAttributes>>> fqsIter =
                frCommentSearchResults.questions.entrySet().iterator();

        while (fqsIter.hasNext()) {
            Iterator<FeedbackQuestionAttributes> fqIter = fqsIter.next().getValue().iterator();

            while (fqIter.hasNext()) {
                FeedbackQuestionAttributes fq = fqIter.next();
                if (frCommentSearchResults.responses.get(fq.getId()).isEmpty()) {
                    fqIter.remove();
                }
            }
        }
    }
}
"
FeedbackResponseCommentSearchQuery.java,search,"package teammates.storage.search;

import java.util.List;

import teammates.common.datatransfer.attributes.InstructorAttributes;
import teammates.common.util.Const;

/**
 * The {@link SearchQuery} object that defines how we query
 * {@link com.google.appengine.api.search.Document} for response comments.
 */
public class FeedbackResponseCommentSearchQuery extends SearchQuery {

    public FeedbackResponseCommentSearchQuery(List<InstructorAttributes> instructors, String queryString) {
        super(instructors, queryString);
    }

    @Override
    protected String prepareVisibilityQueryString(List<InstructorAttributes> instructors) {
        StringBuilder courseIdLimit = new StringBuilder(""("");
        String delim = """";
        for (InstructorAttributes ins : instructors) {
            courseIdLimit.append(delim).append(ins.courseId);
            delim = OR;
        }
        courseIdLimit.append(')');

        //TODO: verify section
        return Const.SearchDocumentField.COURSE_ID + "":"" + courseIdLimit.toString();
    }

}
"
InstructorSearchDocument.java,search,"package teammates.storage.search;

import java.util.Collections;
import java.util.Comparator;
import java.util.List;

import com.google.appengine.api.search.Document;
import com.google.appengine.api.search.Field;
import com.google.appengine.api.search.Results;
import com.google.appengine.api.search.ScoredDocument;

import teammates.common.datatransfer.InstructorSearchResultBundle;
import teammates.common.datatransfer.attributes.CourseAttributes;
import teammates.common.datatransfer.attributes.InstructorAttributes;
import teammates.common.util.Const;
import teammates.common.util.JsonUtils;
import teammates.common.util.StringHelper;

/**
 * The {@link SearchDocument} object that defines how we store {@link Document} for instructors.
 */
public class InstructorSearchDocument extends SearchDocument {

    private InstructorAttributes instructor;
    private CourseAttributes course;

    public InstructorSearchDocument(InstructorAttributes instructor) {
        this.instructor = instructor;
    }

    @Override
    protected void prepareData() {
        if (instructor == null) {
            return;
        }

        course = coursesDb.getCourse(instructor.courseId);
    }

    @Override
    protected Document toDocument() {

        String delim = "","";

        // produce searchableText for this instructor document:
        // contains courseId, courseName, instructorName, instructorEmail, instructorGoogleId, instructorRole, displayedName
        String searchableText = instructor.courseId + delim
                                + (course == null ? """" : course.getName()) + delim
                                + instructor.name + delim
                                + instructor.email + delim
                                + (instructor.googleId == null ? """" : instructor.googleId) + delim
                                + instructor.role + delim
                                + instructor.displayedName;

        return Document.newBuilder()
                // searchableText is used to match the query string
                .addField(Field.newBuilder().setName(Const.SearchDocumentField.SEARCHABLE_TEXT)
                                            .setText(searchableText))
                // attribute field is used to convert a doc back to attribute
                .addField(Field.newBuilder().setName(Const.SearchDocumentField.INSTRUCTOR_ATTRIBUTE)
                                            .setText(JsonUtils.toJson(instructor)))
                .setId(StringHelper.encrypt(instructor.key))
                .build();
    }

    /**
     * Produces an {@link InstructorSearchResultBundle} from the {@code Results<ScoredDocument>} collection.
     *
     * <p>This method should be used by admin only since the searching does not restrict the
     * visibility according to the logged-in user's google ID.
     */
    public static InstructorSearchResultBundle fromResults(Results<ScoredDocument> results) {
        InstructorSearchResultBundle bundle = new InstructorSearchResultBundle();
        if (results == null) {
            return bundle;
        }

        for (ScoredDocument doc : results) {
            InstructorAttributes instructor = JsonUtils.fromJson(
                    doc.getOnlyField(Const.SearchDocumentField.INSTRUCTOR_ATTRIBUTE).getText(),
                    InstructorAttributes.class);

            if (instructorsDb.getInstructorForRegistrationKey(StringHelper.encrypt(instructor.key)) == null) {
                instructorsDb.deleteDocument(instructor);
                continue;
            }

            bundle.instructorList.add(instructor);
            bundle.numberOfResults++;
        }

        sortInstructorResultList(bundle.instructorList);

        return bundle;
    }

    private static void sortInstructorResultList(List<InstructorAttributes> instructorList) {

        Collections.sort(instructorList, new Comparator<InstructorAttributes>() {
            @Override
            public int compare(InstructorAttributes ins1, InstructorAttributes ins2) {
                int compareResult = ins1.courseId.compareTo(ins2.courseId);
                if (compareResult != 0) {
                    return compareResult;
                }

                compareResult = ins1.role.compareTo(ins2.role);
                if (compareResult != 0) {
                    return compareResult;
                }

                compareResult = ins1.name.compareTo(ins2.name);
                if (compareResult != 0) {
                    return compareResult;
                }

                return ins1.email.compareTo(ins2.email);
            }
        });
    }

}
"
InstructorSearchQuery.java,search,"package teammates.storage.search;

import java.util.List;

import teammates.common.datatransfer.attributes.InstructorAttributes;

/**
 * The {@link SearchQuery} object that defines how we query
 * {@link com.google.appengine.api.search.Document} for instructors.
 */
public class InstructorSearchQuery extends SearchQuery {

    /**
     * This constructor should be used by admin only since the searching does not restrict the
     * visibility according to the logged-in user's google ID. This is used by amdin to
     * search instructors in the whole system.
     */
    public InstructorSearchQuery(String queryString) {
        super(queryString);
    }

    @Override
    protected String prepareVisibilityQueryString(List<InstructorAttributes> instructors) {
        return null; // method not used
    }

}
"
package-info.java,search,"/**
 * Contains classes for dealing with searching and indexing.
 */
package teammates.storage.search;
"
SearchDocument.java,search,"package teammates.storage.search;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import com.google.appengine.api.search.Document;
import com.google.appengine.api.search.Results;
import com.google.appengine.api.search.ScoredDocument;

import teammates.common.datatransfer.attributes.InstructorAttributes;
import teammates.common.util.Const;
import teammates.storage.api.CoursesDb;
import teammates.storage.api.FeedbackQuestionsDb;
import teammates.storage.api.FeedbackResponseCommentsDb;
import teammates.storage.api.FeedbackResponsesDb;
import teammates.storage.api.FeedbackSessionsDb;
import teammates.storage.api.InstructorsDb;
import teammates.storage.api.StudentsDb;

/**
 * Defines how we store {@link Document} for indexing/searching.
 */
public abstract class SearchDocument {

    protected static final CoursesDb coursesDb = new CoursesDb();
    protected static final FeedbackQuestionsDb fqDb = new FeedbackQuestionsDb();
    protected static final FeedbackResponseCommentsDb frcDb = new FeedbackResponseCommentsDb();
    protected static final FeedbackResponsesDb frDb = new FeedbackResponsesDb();
    protected static final FeedbackSessionsDb fsDb = new FeedbackSessionsDb();
    protected static final InstructorsDb instructorsDb = new InstructorsDb();
    protected static final StudentsDb studentsDb = new StudentsDb();

    /**
     * Builds the search document.
     */
    public Document build() {
        prepareData();
        return toDocument();
    }

    protected abstract void prepareData();

    protected abstract Document toDocument();

    protected static String extractContentFromQuotedString(String quotedString) {
        if (quotedString.matches(""^\"".*\""$"")) {
            return quotedString.substring(1, quotedString.length() - 1);
        }
        return quotedString;
    }

    /**
     * This method must be called to filter out the search result for course Id.
     */
    protected static List<ScoredDocument> filterOutCourseId(Results<ScoredDocument> results,
                                                            List<InstructorAttributes> instructors) {
        Set<String> courseIdSet = new HashSet<>();
        for (InstructorAttributes ins : instructors) {
            courseIdSet.add(ins.courseId);
        }

        List<ScoredDocument> filteredResults = new ArrayList<>();
        for (ScoredDocument document : results) {
            String resultCourseId = document.getOnlyField(Const.SearchDocumentField.COURSE_ID).getText();
            if (courseIdSet.contains(resultCourseId)) {
                filteredResults.add(document);
            }
        }
        return filteredResults;
    }

}
"
SearchManager.java,search,"package teammates.storage.search;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import com.google.appengine.api.search.Document;
import com.google.appengine.api.search.Index;
import com.google.appengine.api.search.IndexSpec;
import com.google.appengine.api.search.OperationResult;
import com.google.appengine.api.search.PutException;
import com.google.appengine.api.search.PutResponse;
import com.google.appengine.api.search.Query;
import com.google.appengine.api.search.Results;
import com.google.appengine.api.search.ScoredDocument;
import com.google.appengine.api.search.SearchServiceFactory;
import com.google.appengine.api.search.StatusCode;

import teammates.common.exception.TeammatesException;
import teammates.common.util.Logger;
import teammates.common.util.retry.MaximumRetriesExceededException;
import teammates.common.util.retry.RetryManager;
import teammates.common.util.retry.RetryableTaskThrows;

/**
 * Manages {@link Document} and {@link Index} in the Datastore for use of search functions.
 *
 * @see <a href=""https://cloud.google.com/appengine/docs/java/search/"">https://cloud.google.com/appengine/docs/java/search/</a>
 */
public final class SearchManager {

    private static final String ERROR_NON_TRANSIENT_BACKEND_ISSUE =
            ""Failed to put document(s) %s into search index %s due to non-transient backend issue: "";
    private static final String ERROR_MAXIMUM_RETRIES_EXCEEDED =
            ""Failed to put document(s) %s into search index %s after maximum retries: %s: "";
    private static final Logger log = Logger.getLogger();
    private static final ThreadLocal<Map<String, Index>> PER_THREAD_INDICES_TABLE = new ThreadLocal<>();

    private static final RetryManager RM = new RetryManager(8);

    private SearchManager() {
        // utility class
    }

    /**
     * Creates or updates the search document for the given document and index.
     */
    public static void putDocument(String indexName, Document document) {
        try {
            putDocumentWithRetry(indexName, document);
        } catch (PutException e) {
            log.severe(String.format(ERROR_NON_TRANSIENT_BACKEND_ISSUE, document, indexName)
                    + TeammatesException.toStringWithStackTrace(e));
        } catch (MaximumRetriesExceededException e) {
            log.severe(String.format(ERROR_MAXIMUM_RETRIES_EXCEEDED, document, indexName, e.finalMessage)
                    + TeammatesException.toStringWithStackTrace(e));
        }
    }

    /**
     * Tries putting a document, handling transient errors by retrying with exponential backoff.
     *
     * @throws PutException if a non-transient error is encountered.
     * @throws MaximumRetriesExceededException with final {@link OperationResult}'s message as final message,
     *         if operation fails after maximum retries.
     */
    private static void putDocumentWithRetry(String indexName, final Document document)
            throws PutException, MaximumRetriesExceededException {
        final Index index = getIndex(indexName);

        /*
         * The GAE Search API signals put document failure in two ways: it either
         * returns a PutResponse containing an OperationResult with a non-OK StatusCode, or
         * throws a PutException that also contains an embedded OperationResult.
         * We handle both ways by examining the OperationResult to determine what kind of error it is. If it is
         * transient, we use RetryManager to retry the operation; if it is
         * non-transient, we do not retry but throw a PutException upwards instead.
         */
        RM.runUntilSuccessful(new RetryableTaskThrows<PutException>(""Put document"") {

            private OperationResult lastResult;

            @Override
            public void run() {
                try {
                    PutResponse response = index.put(document);
                    lastResult = response.getResults().get(0);

                } catch (PutException e) {
                    lastResult = e.getOperationResult();
                }
            }

            @Override
            public boolean isSuccessful() throws PutException {
                // Update the final message to be shown if the task fails after maximum retries
                finalMessage = lastResult.getMessage();

                if (StatusCode.OK.equals(lastResult.getCode())) {
                    return true;
                } else if (StatusCode.TRANSIENT_ERROR.equals(lastResult.getCode())) {
                    // A transient error can be retried
                    return false;
                } else {
                    // A non-transient error signals that the operation should not be retried
                    throw new PutException(lastResult);
                }
            }
        });
    }

    /**
     * Batch creates or updates the search documents for the given documents and index.
     */
    public static void putDocuments(String indexName, List<Document> documents) {
        try {
            putDocumentsWithRetry(indexName, documents);
        } catch (PutException e) {
            log.severe(String.format(ERROR_NON_TRANSIENT_BACKEND_ISSUE, documents, indexName)
                    + TeammatesException.toStringWithStackTrace(e));
        } catch (MaximumRetriesExceededException e) {
            Object failedDocuments = e.finalData;
            log.severe(String.format(ERROR_MAXIMUM_RETRIES_EXCEEDED, failedDocuments, indexName, e.finalMessage)
                    + TeammatesException.toStringWithStackTrace(e));
        }
    }

    /**
     * Tries putting multiple documents, handling transient errors by retrying with exponential backoff.
     *
     * @throws PutException when only non-transient errors are encountered.
     * @throws MaximumRetriesExceededException with list of failed {@link Document}s as final data and
     *         final {@link OperationResult}'s message as final message, if operation fails after maximum retries.
     */
    private static void putDocumentsWithRetry(String indexName, final List<Document> documents)
            throws PutException, MaximumRetriesExceededException {
        final Index index = getIndex(indexName);

        /*
         * The GAE Search API allows batch putting a List of Documents.
         * Results for each document are reported via a List of OperationResults.
         * We use RetryManager to retry putting a List of Documents, with each retry re-putting only
         * the documents that failed in the previous retry.
         * If we encounter one or more transient errors, we retry the operation.
         * If all results are non-transient errors, we give up and throw a PutException upwards.
         */
        RM.runUntilSuccessful(new RetryableTaskThrows<PutException>(""Put documents"") {

            private List<Document> documentsToPut = documents;
            private List<OperationResult> lastResults;
            private List<String> lastIds;

            @Override
            public void run() throws PutException {
                try {
                    PutResponse response = index.put(documentsToPut);
                    lastResults = response.getResults();
                    lastIds = response.getIds();

                } catch (PutException e) {
                    lastResults = e.getResults();
                    lastIds = e.getIds();
                }
            }

            @Override
            public boolean isSuccessful() {
                boolean hasTransientError = false;

                List<Document> failedDocuments = new ArrayList<>();
                for (int i = 0; i < documentsToPut.size(); i++) {
                    StatusCode code = lastResults.get(i).getCode();
                    if (!StatusCode.OK.equals(code)) {
                        failedDocuments.add(documentsToPut.get(i));
                        if (StatusCode.TRANSIENT_ERROR.equals(code)) {
                            hasTransientError = true;
                        }
                    }
                }

                // Update the list of documents to be put during the next retry
                documentsToPut = failedDocuments;

                // Update the final message and data to be shown if the task fails after maximum retries
                finalMessage = lastResults.get(0).getMessage();
                finalData = documentsToPut;

                if (documentsToPut.isEmpty()) {
                    return true;
                } else if (hasTransientError) {
                    // If there is at least one transient error, continue retrying
                    return false;
                } else {
                    // If all errors are non-transient, do not continue retrying
                    throw new PutException(lastResults.get(0), lastResults, lastIds);
                }
            }
        });
    }

    /**
     * Searches document by the given query.
     */
    public static Results<ScoredDocument> searchDocuments(String indexName, Query query) {
        return getIndex(indexName).search(query);
    }

    /**
     * Deletes document by documentId.
     */
    public static void deleteDocument(String indexName, String documentId) {
        getIndex(indexName).deleteAsync(documentId);
    }

    private static Index getIndex(String indexName) {
        Map<String, Index> indicesTable = getIndicesTable();
        Index index = indicesTable.get(indexName);
        if (index == null) {
            IndexSpec indexSpec = IndexSpec.newBuilder().setName(indexName).build();
            index = SearchServiceFactory.getSearchService().getIndex(indexSpec);
            indicesTable.put(indexName, index);
        }
        return index;
    }

    private static Map<String, Index> getIndicesTable() {
        Map<String, Index> indicesTable = PER_THREAD_INDICES_TABLE.get();
        if (indicesTable == null) {
            indicesTable = new HashMap<>();
            PER_THREAD_INDICES_TABLE.set(indicesTable);
        }
        return indicesTable;
    }

}
"
SearchQuery.java,search,"package teammates.storage.search;

import java.util.ArrayList;
import java.util.List;

import com.google.appengine.api.search.Query;
import com.google.appengine.api.search.QueryOptions;

import teammates.common.datatransfer.attributes.InstructorAttributes;
import teammates.common.util.Const;
import teammates.common.util.Logger;

/**
 * Defines how we query {@link com.google.appengine.api.search.Document}.
 */
public abstract class SearchQuery {

    protected static final String AND = "" AND "";
    protected static final String OR = "" OR "";
    protected static final String NOT = "" NOT "";

    private static final Logger log = Logger.getLogger();

    private String visibilityQueryString;

    private QueryOptions options;
    private List<String> textQueryStrings = new ArrayList<>();

    protected SearchQuery(List<InstructorAttributes> instructors, String queryString) {
        options = QueryOptions.newBuilder()
                .setLimit(20)
                .build();
        visibilityQueryString = instructors == null ? """" : prepareVisibilityQueryString(instructors);
        setTextFilter(Const.SearchDocumentField.SEARCHABLE_TEXT, queryString);
    }

    protected SearchQuery(String queryString) {
        this(null, queryString);
    }

    protected abstract String prepareVisibilityQueryString(List<InstructorAttributes> instructors);

    /**
     * Returns how many query strings a SearchQuery object has.
     */
    public int getFilterSize() {
        return textQueryStrings.size();
    }

    private void setTextFilter(String textField, String queryString) {

        String trimmedQueryString = queryString.toLowerCase().trim();

        if (trimmedQueryString.isEmpty()) {
            return;
        }

        String preparedOrQueryString = prepareOrQueryString(trimmedQueryString);
        textQueryStrings.add(textField + "":"" + preparedOrQueryString);
    }

    private String prepareOrQueryString(String queryString) {
        String[] splitStrings = queryString.replaceAll(""\"""", "" \"" "").trim().split(""\\s+"");

        List<String> keywords = new ArrayList<>();
        StringBuilder key = new StringBuilder();
        boolean isStartQuote = false;
        for (String splitString : splitStrings) {
            if (""\"""".equals(splitString)) {
                if (isStartQuote) {
                    String trimmedKey = key.toString().trim();
                    isStartQuote = false;
                    if (!trimmedKey.isEmpty()) {
                        keywords.add(trimmedKey);
                    }
                    key.setLength(0);
                } else {
                    isStartQuote = true;
                }
            } else {
                if (isStartQuote) {
                    key.append(' ').append(splitString);
                } else {
                    keywords.add(splitString);
                }
            }
        }

        String trimmedKey = key.toString().trim();
        if (isStartQuote && !trimmedKey.isEmpty()) {
            keywords.add(trimmedKey);
        }

        if (keywords.isEmpty()) {
            return """";
        }

        StringBuilder preparedQueryString = new StringBuilder(""(\"""" + keywords.get(0) + ""\"""");

        for (int i = 1; i < keywords.size(); i++) {
            preparedQueryString.append(OR).append(""\"""" + keywords.get(i) + ""\"""");
        }
        return preparedQueryString.toString() + "")"";
    }

    /**
     * Builds the {@link Query} object.
     */
    public Query toQuery() {
        return Query.newBuilder().setOptions(options).build(toString());
    }

    @Override
    public String toString() {
        StringBuilder queryStringBuilder = new StringBuilder(visibilityQueryString);

        boolean isfirstElement = visibilityQueryString.isEmpty();

        for (String textQuery : textQueryStrings) {
            if (isfirstElement) {
                queryStringBuilder.append(textQuery);
                isfirstElement = false;
            } else {
                queryStringBuilder.append(AND).append(textQuery);
            }
        }
        log.info(""Query: "" + queryStringBuilder.toString());
        return queryStringBuilder.toString();
    }
}
"
StudentSearchDocument.java,search,"package teammates.storage.search;

import java.util.Collections;
import java.util.Comparator;
import java.util.List;

import com.google.appengine.api.search.Document;
import com.google.appengine.api.search.Field;
import com.google.appengine.api.search.Results;
import com.google.appengine.api.search.ScoredDocument;

import teammates.common.datatransfer.StudentSearchResultBundle;
import teammates.common.datatransfer.attributes.CourseAttributes;
import teammates.common.datatransfer.attributes.InstructorAttributes;
import teammates.common.datatransfer.attributes.StudentAttributes;
import teammates.common.util.Const;
import teammates.common.util.JsonUtils;
import teammates.common.util.StringHelper;

/**
 * The {@link SearchDocument} object that defines how we store {@link Document} for students.
 */
public class StudentSearchDocument extends SearchDocument {

    private StudentAttributes student;
    private CourseAttributes course;

    public StudentSearchDocument(StudentAttributes student) {
        this.student = student;
    }

    @Override
    protected void prepareData() {
        if (student == null) {
            return;
        }

        course = coursesDb.getCourse(student.course);
    }

    @Override
    public Document toDocument() {

        String delim = "","";

        // produce searchableText for this student document:
        // it contains courseId, courseName, studentEmail, studentName studentTeam and studentSection
        String searchableText = student.course + delim
                                + (course == null ? """" : course.getName()) + delim
                                + student.email + delim
                                + student.name + delim
                                + student.team + delim
                                + student.section;

        return Document.newBuilder()
                // this is used to filter documents visible to certain instructor
                .addField(Field.newBuilder().setName(Const.SearchDocumentField.COURSE_ID)
                                            .setText(student.course))
                // searchableText and createdDate are used to match the query string
                .addField(Field.newBuilder().setName(Const.SearchDocumentField.SEARCHABLE_TEXT)
                                            .setText(searchableText))
                // attribute field is used to convert a doc back to attribute
                .addField(Field.newBuilder().setName(Const.SearchDocumentField.STUDENT_ATTRIBUTE)
                                            .setText(JsonUtils.toJson(student)))
                .setId(student.key)
                .build();
    }

    /**
     * Produces a {@link StudentSearchResultBundle} from the {@code Results<ScoredDocument>} collection.
     * The list of {@link InstructorAttributes} is used to filter out the search result.
     *
     * <p>This method should be used by admin only since the searching does not restrict the
     * visibility according to the logged-in user's google ID.
     */
    public static StudentSearchResultBundle fromResults(Results<ScoredDocument> results) {
        StudentSearchResultBundle bundle = new StudentSearchResultBundle();
        if (results == null) {
            return bundle;
        }

        for (ScoredDocument doc : results) {
            StudentAttributes student = JsonUtils.fromJson(
                    doc.getOnlyField(Const.SearchDocumentField.STUDENT_ATTRIBUTE).getText(),
                    StudentAttributes.class);
            if (student.key == null
                    || studentsDb.getStudentForRegistrationKey(StringHelper.encrypt(student.key)) == null) {
                studentsDb.deleteDocument(student);
                continue;
            }

            bundle.studentList.add(student);
            bundle.numberOfResults++;
        }

        sortStudentResultList(bundle.studentList);

        return bundle;
    }

    /**
     * Produces a {@link StudentSearchResultBundle} from the {@code Results<ScoredDocument>} collection.
     * The list of {@link InstructorAttributes} is used to filter out the search result.
     */
    public static StudentSearchResultBundle fromResults(Results<ScoredDocument> results,
                                                        List<InstructorAttributes> instructors) {
        StudentSearchResultBundle bundle = new StudentSearchResultBundle();
        if (results == null) {
            return bundle;
        }

        for (InstructorAttributes ins : instructors) {
            bundle.courseIdInstructorMap.put(ins.courseId, ins);
        }

        List<ScoredDocument> filteredResults = filterOutCourseId(results, instructors);
        for (ScoredDocument doc : filteredResults) {
            StudentAttributes student = JsonUtils.fromJson(
                    doc.getOnlyField(Const.SearchDocumentField.STUDENT_ATTRIBUTE).getText(),
                    StudentAttributes.class);
            if (student.key == null
                    || studentsDb.getStudentForRegistrationKey(StringHelper.encrypt(student.key)) == null) {
                studentsDb.deleteDocument(student);
                continue;
            }

            bundle.studentList.add(student);
            bundle.numberOfResults++;
        }

        sortStudentResultList(bundle.studentList);

        return bundle;
    }

    private static void sortStudentResultList(List<StudentAttributes> studentList) {

        Collections.sort(studentList, new Comparator<StudentAttributes>() {
            @Override
            public int compare(StudentAttributes s1, StudentAttributes s2) {
                int compareResult = s1.course.compareTo(s2.course);
                if (compareResult != 0) {
                    return compareResult;
                }

                compareResult = s1.section.compareTo(s2.section);
                if (compareResult != 0) {
                    return compareResult;
                }

                compareResult = s1.team.compareTo(s2.team);
                if (compareResult != 0) {
                    return compareResult;
                }

                compareResult = s1.name.compareTo(s2.name);
                if (compareResult != 0) {
                    return compareResult;
                }

                return s1.email.compareTo(s2.email);
            }
        });
    }

}
"
StudentSearchQuery.java,search,"package teammates.storage.search;

import java.util.List;

import teammates.common.datatransfer.attributes.InstructorAttributes;
import teammates.common.util.Const;

/**
 * The {@link SearchQuery} object that defines how we query
 * {@link com.google.appengine.api.search.Document} for students.
 */
public class StudentSearchQuery extends SearchQuery {

    public StudentSearchQuery(List<InstructorAttributes> instructors, String queryString) {
        super(instructors, queryString);
    }

    /**
     * This constructor should be used by admin only since the searching does not restrict the
     * visibility according to the logged-in user's google ID. This is used by amdin to
     * search students in the whole system.
     */
    public StudentSearchQuery(String queryString) {
        super(queryString);
    }

    @Override
    protected String prepareVisibilityQueryString(List<InstructorAttributes> instructors) {
        StringBuilder courseIdLimit = new StringBuilder(""("");
        String delim = """";
        for (InstructorAttributes ins : instructors) {
            courseIdLimit.append(delim).append(ins.courseId);
            delim = OR;
        }
        courseIdLimit.append(')');

        return Const.SearchDocumentField.COURSE_ID + "":"" + courseIdLimit.toString();
    }

}
"
AccountsDb.java,storage-api,"package teammates.storage.api;

import static com.googlecode.objectify.ObjectifyService.ofy;

import java.util.Collection;
import java.util.LinkedList;
import java.util.List;

import com.google.appengine.api.blobstore.BlobKey;
import com.googlecode.objectify.Key;
import com.googlecode.objectify.cmd.LoadType;
import com.googlecode.objectify.cmd.QueryKeys;

import teammates.common.datatransfer.attributes.AccountAttributes;
import teammates.common.datatransfer.attributes.StudentProfileAttributes;
import teammates.common.exception.EntityAlreadyExistsException;
import teammates.common.exception.EntityDoesNotExistException;
import teammates.common.exception.InvalidParametersException;
import teammates.common.util.Assumption;
import teammates.common.util.Const;
import teammates.common.util.ThreadHelper;
import teammates.storage.entity.Account;
import teammates.storage.entity.StudentProfile;

/**
 * Handles CRUD operations for accounts.
 *
 * @see Account
 * @see AccountAttributes
 */
public class AccountsDb extends EntitiesDb<Account, AccountAttributes> {
    private ProfilesDb profilesDb = new ProfilesDb();

    /**
     * Preconditions:
     * <br> * {@code accountToAdd} is not null and has valid data.
     */
    public void createAccount(AccountAttributes accountToAdd)
            throws InvalidParametersException {
        // TODO: use createEntity once there is a proper way to add instructor accounts.
        try {
            // this is for legacy code to be handled
            if (accountToAdd != null && accountToAdd.studentProfile == null) {
                accountToAdd.studentProfile = StudentProfileAttributes.builder().build();
                accountToAdd.studentProfile.googleId = accountToAdd.googleId;
            }
            createEntity(accountToAdd);

        } catch (EntityAlreadyExistsException e) {
            // We update the account instead if it already exists. This is due to how
            // adding of instructor accounts work.
            try {
                updateAccount(accountToAdd, true);
            } catch (EntityDoesNotExistException edne) {
                // This situation is not tested as replicating such a situation is
                // difficult during testing
                Assumption.fail(""Account found to be already existing and not existing simultaneously"");
            }
        }

        try {
            profilesDb.createEntity(accountToAdd.studentProfile);
        } catch (EntityAlreadyExistsException e) {
            try {
                profilesDb.updateStudentProfile(accountToAdd.studentProfile);
            } catch (EntityDoesNotExistException edne) {
                // This situation is not tested as replicating such a situation is
                // difficult during testing
                Assumption.fail(""StudentProfile found to be already existing and not existing simultaneously"");
            }
        }
    }

    @Override
    public List<Account> createEntitiesDeferred(Collection<AccountAttributes> accountsToAdd)
            throws InvalidParametersException {
        List<StudentProfileAttributes> profilesToAdd = new LinkedList<>();
        for (AccountAttributes accountToAdd : accountsToAdd) {
            profilesToAdd.add(accountToAdd.studentProfile);
        }
        profilesDb.createEntitiesDeferred(profilesToAdd);
        return super.createEntitiesDeferred(accountsToAdd);
    }

    /**
     * Gets the data transfer version of the account. Does not retrieve the profile
     * if the given parameter is false<br>
     * Preconditions:
     * <br> * All parameters are non-null.
     * @return Null if not found.
     */
    public AccountAttributes getAccount(String googleId, boolean retrieveStudentProfile) {
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, googleId);
        return googleId.isEmpty() ? null : makeAttributesOrNull(getAccountEntity(googleId, retrieveStudentProfile));
    }

    public AccountAttributes getAccount(String googleId) {
        return getAccount(googleId, false);
    }

    /**
     * Returns {@link AccountAttributes} objects for all accounts with instructor privileges.
     *         Returns an empty list if no such accounts are found.
     */
    public List<AccountAttributes> getInstructorAccounts() {
        return makeAttributes(
                load().filter(""isInstructor ="", true).list());
    }

    /**
     * Preconditions:
     * <br> * {@code accountToAdd} is not null and has valid data.
     */
    public void updateAccount(AccountAttributes a, boolean updateStudentProfile)
            throws InvalidParametersException, EntityDoesNotExistException {
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, a);

        if (!a.isValid()) {
            throw new InvalidParametersException(a.getInvalidityInfo());
        }

        Account accountToUpdate = getAccountEntity(a.googleId, updateStudentProfile);

        if (accountToUpdate == null) {
            throw new EntityDoesNotExistException(ERROR_UPDATE_NON_EXISTENT_ACCOUNT + a.googleId
                + ThreadHelper.getCurrentThreadStack());
        }

        a.sanitizeForSaving();
        accountToUpdate.setName(a.name);
        accountToUpdate.setEmail(a.email);
        accountToUpdate.setIsInstructor(a.isInstructor);
        accountToUpdate.setInstitute(a.institute);

        if (updateStudentProfile) {
            StudentProfile existingProfile = accountToUpdate.getStudentProfile();
            if (existingProfile == null) {
                existingProfile = new StudentProfile(a.studentProfile.googleId);
            }

            StudentProfileAttributes existingProfileAttributes = StudentProfileAttributes.valueOf(existingProfile);
            a.studentProfile.modifiedDate = existingProfileAttributes.modifiedDate;

            // if the student profile has changed then update the store
            // this is to maintain integrity of the modified date.
            if (!existingProfileAttributes.toString().equals(a.studentProfile.toString())) {
                StudentProfile updatedProfile = a.studentProfile.toEntity();
                accountToUpdate.setStudentProfile(updatedProfile);
                profilesDb.saveEntity(updatedProfile);
            }
        }
        saveEntity(accountToUpdate, a);
    }

    public void updateAccount(AccountAttributes a)
            throws InvalidParametersException, EntityDoesNotExistException {
        if (a != null && a.studentProfile == null) {
            a.studentProfile = StudentProfileAttributes.builder().build();
            a.studentProfile.googleId = a.googleId;
        }
        updateAccount(a, false);
    }

    /**
     * Note: This is a non-cascade delete. <br>
     *   <br> Fails silently if there is no such account.
     * <br> Preconditions:
     * <br> * {@code googleId} is not null.
     */
    public void deleteAccount(String googleId) {
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, googleId);

        Account accountToDelete = getAccountEntity(googleId, true);

        if (accountToDelete == null) {
            return;
        }

        StudentProfile studentProfile = accountToDelete.getStudentProfile();
        if (studentProfile != null) {
            BlobKey pictureKey = studentProfile.getPictureKey();
            if (!pictureKey.getKeyString().isEmpty()) {
                deletePicture(pictureKey);
            }
            profilesDb.deleteEntityDirect(studentProfile);
        }

        deleteEntityDirect(accountToDelete);
    }

    public void deleteAccounts(Collection<AccountAttributes> accounts) {
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, accounts);

        for (AccountAttributes accountToDelete : accounts) {
            deleteAccount(accountToDelete.googleId);
        }
    }

    private Account getAccountEntity(String googleId, boolean retrieveStudentProfile) {
        Account account = load().id(googleId).now();
        if (account == null) {
            return null;
        }

        account.setIsStudentProfileEnabled(retrieveStudentProfile);

        return account;
    }

    private Account getAccountEntity(String googleId) {
        return getAccountEntity(googleId, false);
    }

    @Override
    protected LoadType<Account> load() {
        return ofy().load().type(Account.class);
    }

    @Override
    protected Account getEntity(AccountAttributes entity) {
        return getAccountEntity(entity.googleId);
    }

    @Override
    protected QueryKeys<Account> getEntityQueryKeys(AccountAttributes attributes) {
        Key<Account> keyToFind = Key.create(Account.class, attributes.googleId);
        return load().filterKey(keyToFind).keys();
    }

    @Override
    protected AccountAttributes makeAttributes(Account entity) {
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, entity);

        return new AccountAttributes(entity);
    }
}
"
AdminEmailsDb.java,storage-api,"package teammates.storage.api;

import static com.googlecode.objectify.ObjectifyService.ofy;

import java.util.Date;
import java.util.List;

import com.google.appengine.api.blobstore.BlobKey;
import com.googlecode.objectify.Key;
import com.googlecode.objectify.cmd.LoadType;
import com.googlecode.objectify.cmd.Query;
import com.googlecode.objectify.cmd.QueryKeys;

import teammates.common.datatransfer.attributes.AdminEmailAttributes;
import teammates.common.exception.EntityAlreadyExistsException;
import teammates.common.exception.EntityDoesNotExistException;
import teammates.common.exception.InvalidParametersException;
import teammates.common.util.Assumption;
import teammates.common.util.Const;
import teammates.common.util.GoogleCloudStorageHelper;
import teammates.common.util.ThreadHelper;
import teammates.storage.entity.AdminEmail;

/**
 * Handles CRUD operations for emails sent by the admin.
 *
 * @see AdminEmail
 * @see AdminEmailAttributes
 */
public class AdminEmailsDb extends EntitiesDb<AdminEmail, AdminEmailAttributes> {

    public Date createAdminEmail(AdminEmailAttributes adminEmailToAdd) throws InvalidParametersException {
        try {
            AdminEmail ae = createEntity(adminEmailToAdd);
            return ae.getCreateDate();
        } catch (EntityAlreadyExistsException e) {
            try {
                updateAdminEmail(adminEmailToAdd);
                return adminEmailToAdd.getCreateDate();
            } catch (EntityDoesNotExistException ednee) {
                Assumption.fail(""Entity found be already existing and not existing simultaneously"");
                return null;
            }
        }

    }

    public void updateAdminEmail(AdminEmailAttributes ae) throws InvalidParametersException, EntityDoesNotExistException {
        if (!ae.isValid()) {
            throw new InvalidParametersException(ae.getInvalidityInfo());
        }

        AdminEmail adminEmailToUpdate = getAdminEmailEntity(ae.emailId);

        if (adminEmailToUpdate == null) {
            throw new EntityDoesNotExistException(
                    ERROR_UPDATE_NON_EXISTENT_ACCOUNT + ae.getSubject()
                    + ""/"" + ae.getSendDate()
                    + ThreadHelper.getCurrentThreadStack());
        }

        ae.sanitizeForSaving();

        adminEmailToUpdate.setContent(ae.content);
        adminEmailToUpdate.setAddressReceiver(ae.addressReceiver);
        adminEmailToUpdate.setGroupReceiver(ae.groupReceiver);
        adminEmailToUpdate.setSubject(ae.subject);
        adminEmailToUpdate.setIsInTrashBin(ae.isInTrashBin);
        adminEmailToUpdate.setSendDate(ae.sendDate);

        saveEntity(adminEmailToUpdate, ae);
    }

    /**
     * Deletes files uploaded in admin email compose page.
     * @param key the GCS blobkey used to fetch the file in Google Cloud Storage
     */
    public void deleteAdminEmailUploadedFile(BlobKey key) {
        GoogleCloudStorageHelper.deleteFile(key);
    }

    /**
     * Deletes all emails in trash bin, related group receiver text file will be removed from
     * Google Cloud Storage.
     */
    public void deleteAllEmailsInTrashBin() {

        List<AdminEmailAttributes> emailsInTrashBin = getAdminEmailsInTrashBin();

        for (AdminEmailAttributes a : emailsInTrashBin) {
            if (a.getGroupReceiver() != null) {
                for (String key : a.getGroupReceiver()) {
                    BlobKey blobKey = new BlobKey(key);
                    deleteAdminEmailUploadedFile(blobKey);
                }
            }
        }
        deleteEntities(emailsInTrashBin);
    }

    public void updateAdminEmailById(AdminEmailAttributes newAdminEmail, String emailId)
            throws InvalidParametersException, EntityDoesNotExistException {
        if (!newAdminEmail.isValid()) {
            throw new InvalidParametersException(newAdminEmail.getInvalidityInfo());
        }

        AdminEmail adminEmailToUpdate = getAdminEmailEntity(emailId);
        if (adminEmailToUpdate == null) {
            throw new EntityDoesNotExistException(
                    ERROR_UPDATE_NON_EXISTENT_ACCOUNT + ""with Id : "" + emailId
                    + ThreadHelper.getCurrentThreadStack());
        }

        newAdminEmail.sanitizeForSaving();

        adminEmailToUpdate.setContent(newAdminEmail.content);
        adminEmailToUpdate.setAddressReceiver(newAdminEmail.addressReceiver);
        adminEmailToUpdate.setGroupReceiver(newAdminEmail.groupReceiver);
        adminEmailToUpdate.setSubject(newAdminEmail.subject);
        adminEmailToUpdate.setIsInTrashBin(newAdminEmail.isInTrashBin);
        adminEmailToUpdate.setSendDate(newAdminEmail.sendDate);

        saveEntity(adminEmailToUpdate, newAdminEmail);
    }

    /**
     * This method is not scalable. Not to be used unless for admin features.
     * @return the list of all adminEmails in the database.
     */
    @Deprecated
    public List<AdminEmailAttributes> getAllAdminEmails() {
        return makeAttributes(getAdminEmailEntities());
    }

    /**
     * Gets an admin email by email id.
     * @return null if no matched email found
     */
    public AdminEmailAttributes getAdminEmailById(String emailId) {
        return makeAttributesOrNull(getAdminEmailEntity(emailId));
    }

    /**
     * Gets an admin email by subject and createDate.
     * @return null if no matched email found
     */
    public AdminEmailAttributes getAdminEmail(String subject, Date createDate) {
        return makeAttributesOrNull(getAdminEmailEntity(subject, createDate));
    }

    /**
     * Gets an admin email based on subject.
     * @return null if no matched email found
     */
    public AdminEmailAttributes getAdminEmailBySubject(String subject) {
        return makeAttributesOrNull(getAdminEmailEntityBySubject(subject));
    }

    /**
     * Gets all admin email drafts that have NOT been sent and NOT in trash bin.
     * @return empty list if no email found
     */
    public List<AdminEmailAttributes> getAdminEmailDrafts() {
        return makeAttributes(
                load()
                .filter(""isInTrashBin ="", false)
                .filter(""sendDate ="", null)
                .list());
    }

    /**
     * Gets all admin emails that have been sent and not in trash bin.
     * @return empty list if no email found
     */
    public List<AdminEmailAttributes> getSentAdminEmails() {
        return makeAttributes(
                load()
                .filter(""isInTrashBin ="", false)
                .filter(""sendDate !="", null)
                .list());
    }

    /**
     * Gets all admin emails (including sent and draft mails) that have been moved into trash bin.
     * @return empty list if no email found
     */
    public List<AdminEmailAttributes> getAdminEmailsInTrashBin() {
        return makeAttributes(
                load().filter(""isInTrashBin ="", true).list());
    }

    private List<AdminEmail> getAdminEmailEntities() {
        return load().list();
    }

    private AdminEmail getAdminEmailEntity(String adminEmailId) {
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, adminEmailId);

        Key<AdminEmail> key = makeKeyOrNullFromWebSafeString(adminEmailId);
        if (key == null) {
            return null;
        }

        return ofy().load().key(key).now();
    }

    private AdminEmail getAdminEmailEntity(String subject, Date createDate) {
        return load()
                .filter(""subject ="", subject)
                .filter(""createDate ="", createDate)
                .first().now();
    }

    private AdminEmail getAdminEmailEntityBySubject(String subject) {
        return load().filter(""subject ="", subject).first().now();
    }

    @Override
    protected LoadType<AdminEmail> load() {
        return ofy().load().type(AdminEmail.class);
    }

    @Override
    protected AdminEmail getEntity(AdminEmailAttributes adminEmailToGet) {
        if (adminEmailToGet.getEmailId() != null) {
            return getAdminEmailEntity(adminEmailToGet.getEmailId());
        }

        return getAdminEmailEntity(adminEmailToGet.getSubject(),
                                   adminEmailToGet.getCreateDate());
    }

    @Override
    protected QueryKeys<AdminEmail> getEntityQueryKeys(AdminEmailAttributes attributes) {
        Key<AdminEmail> key = makeKeyOrNullFromWebSafeString(attributes.emailId);

        Query<AdminEmail> query;
        if (key == null) {
            query = load()
                    .filter(""subject ="", attributes.subject)
                    .filter(""createDate ="", attributes.createDate);
        } else {
            query = load().filterKey(key);
        }

        return query.keys();
    }

    @Override
    protected AdminEmailAttributes makeAttributes(AdminEmail entity) {
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, entity);

        return new AdminEmailAttributes(entity);
    }
}
"
CoursesDb.java,storage-api,"package teammates.storage.api;

import static com.googlecode.objectify.ObjectifyService.ofy;

import java.util.ArrayList;
import java.util.Collection;
import java.util.List;

import com.googlecode.objectify.Key;
import com.googlecode.objectify.cmd.LoadType;
import com.googlecode.objectify.cmd.QueryKeys;

import teammates.common.datatransfer.attributes.CourseAttributes;
import teammates.common.exception.EntityDoesNotExistException;
import teammates.common.exception.InvalidParametersException;
import teammates.common.util.Assumption;
import teammates.common.util.Const;
import teammates.storage.entity.Course;

/**
 * Handles CRUD operations for courses.
 *
 * @see Course
 * @see CourseAttributes
 */
public class CoursesDb extends EntitiesDb<Course, CourseAttributes> {

    /*
     * Explanation: Based on our policies for the storage component, this class does not handle cascading.
     * It treats invalid values as an exception.
     */

    public static final String ERROR_UPDATE_NON_EXISTENT_COURSE = ""Trying to update a Course that doesn't exist: "";

    public void createCourses(Collection<CourseAttributes> coursesToAdd) throws InvalidParametersException {
        List<CourseAttributes> coursesToUpdate = createEntities(coursesToAdd);
        for (CourseAttributes course : coursesToUpdate) {
            try {
                updateCourse(course);
            } catch (EntityDoesNotExistException e) {
                // This situation is not tested as replicating such a situation is
                // difficult during testing
                Assumption.fail(""Entity found be already existing and not existing simultaneously"");
            }
        }
    }

    /**
     * Preconditions: <br>
     * * All parameters are non-null.
     * @return Null if not found.
     */
    public CourseAttributes getCourse(String courseId) {
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, courseId);

        return makeAttributesOrNull(getCourseEntity(courseId));
    }

    public List<CourseAttributes> getCourses(List<String> courseIds) {
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, courseIds);

        return makeAttributes(getCourseEntities(courseIds));
    }

    /**
     * Gets all courses in the Datastore.
     *
     * @deprecated Not scalable. Use only in admin features.
     */
    @Deprecated
    public List<CourseAttributes> getAllCourses() {
        return makeAttributes(load().list());
    }

    /**
     * Updates the course.<br>
     * Updates only name and course archive status.<br>
     * Preconditions: <br>
     * * {@code courseToUpdate} is non-null.<br>
     * @throws InvalidParametersException, EntityDoesNotExistException
     */
    public void updateCourse(CourseAttributes courseToUpdate) throws InvalidParametersException,
                                                                     EntityDoesNotExistException {
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, courseToUpdate);

        courseToUpdate.sanitizeForSaving();

        if (!courseToUpdate.isValid()) {
            throw new InvalidParametersException(courseToUpdate.getInvalidityInfo());
        }

        Course courseEntityToUpdate = getCourseEntity(courseToUpdate.getId());

        if (courseEntityToUpdate == null) {
            throw new EntityDoesNotExistException(ERROR_UPDATE_NON_EXISTENT_COURSE);
        }

        courseEntityToUpdate.setName(courseToUpdate.getName());
        courseEntityToUpdate.setTimeZone(courseToUpdate.getTimeZone());

        saveEntity(courseEntityToUpdate, courseToUpdate);
    }

    /**
     * Note: This is a non-cascade delete.<br>
     *   <br> Fails silently if there is no such object.
     * <br> Preconditions:
     * <br> * {@code courseId} is not null.
     */
    public void deleteCourse(String courseId) {
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, courseId);

        // only the courseId is important here, everything else are placeholders
        deleteEntity(new CourseAttributes(courseId, ""Non-existent course"", ""UTC""));
    }

    @Override
    protected LoadType<Course> load() {
        return ofy().load().type(Course.class);
    }

    @Override
    protected Course getEntity(CourseAttributes attributes) {
        return getCourseEntity(attributes.getId());
    }

    @Override
    protected QueryKeys<Course> getEntityQueryKeys(CourseAttributes attributes) {
        Key<Course> keyToFind = Key.create(Course.class, attributes.getId());
        return load().filterKey(keyToFind).keys();
    }

    private Course getCourseEntity(String courseId) {
        return load().id(courseId).now();
    }

    private List<Course> getCourseEntities(List<String> courseIds) {
        if (courseIds.isEmpty()) {
            return new ArrayList<>();
        }

        return new ArrayList<>(
                load().ids(courseIds).values());
    }

    @Override
    protected CourseAttributes makeAttributes(Course entity) {
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, entity);

        return new CourseAttributes(entity);
    }
}
"
EntitiesDb.java,storage-api,"package teammates.storage.api;

import static com.googlecode.objectify.ObjectifyService.ofy;

import java.util.ArrayList;
import java.util.Collection;
import java.util.LinkedList;
import java.util.List;

import com.google.appengine.api.blobstore.BlobKey;
import com.google.appengine.api.search.Document;
import com.google.appengine.api.search.Results;
import com.google.appengine.api.search.ScoredDocument;
import com.google.appengine.api.search.SearchQueryException;
import com.googlecode.objectify.Key;
import com.googlecode.objectify.cmd.LoadType;
import com.googlecode.objectify.cmd.QueryKeys;

import teammates.common.datatransfer.attributes.EntityAttributes;
import teammates.common.exception.EntityAlreadyExistsException;
import teammates.common.exception.InvalidParametersException;
import teammates.common.util.Assumption;
import teammates.common.util.Const;
import teammates.common.util.GoogleCloudStorageHelper;
import teammates.common.util.Logger;
import teammates.storage.entity.BaseEntity;
import teammates.storage.search.SearchDocument;
import teammates.storage.search.SearchManager;
import teammates.storage.search.SearchQuery;

/**
 * Base class for all classes performing CRUD operations against the Datastore.
 * @param <E> Specific entity class
 * @param <A> Specific attributes class
 */
public abstract class EntitiesDb<E extends BaseEntity, A extends EntityAttributes<E>> {

    public static final String ERROR_CREATE_ENTITY_ALREADY_EXISTS = ""Trying to create a %s that exists: "";
    public static final String ERROR_UPDATE_NON_EXISTENT = ""Trying to update non-existent Entity: "";
    public static final String ERROR_UPDATE_NON_EXISTENT_ACCOUNT = ""Trying to update non-existent Account: "";
    public static final String ERROR_UPDATE_NON_EXISTENT_ADMIN_EMAIL = ""Trying to update non-existent Admin Email: "";
    public static final String ERROR_UPDATE_NON_EXISTENT_STUDENT = ""Trying to update non-existent Student: "";
    public static final String ERROR_UPDATE_NON_EXISTENT_STUDENT_PROFILE = ""Trying to update non-existent Student Profile: "";
    public static final String ERROR_UPDATE_NON_EXISTENT_COURSE = ""Trying to update non-existent Course: "";
    public static final String ERROR_UPDATE_NON_EXISTENT_INSTRUCTOR_PERMISSION =
            ""Trying to update non-existing InstructorPermission: "";
    public static final String ERROR_UPDATE_TO_EXISTENT_INSTRUCTOR_PERMISSION =
            ""Trying to update to existent InstructorPermission: "";
    public static final String ERROR_CREATE_INSTRUCTOR_ALREADY_EXISTS = ""Trying to create a Instructor that exists: "";
    public static final String ERROR_TRYING_TO_MAKE_NON_EXISTENT_ACCOUNT_AN_INSTRUCTOR =
            ""Trying to make an non-existent account an Instructor :"";

    private static final Logger log = Logger.getLogger();

    /**
     * Preconditions:
     * <br> * {@code entityToAdd} is not null and has valid data.
     */
    public E createEntity(A entityToAdd) throws InvalidParametersException, EntityAlreadyExistsException {
        return createEntity(entityToAdd, true);
    }

    public List<A> createEntities(Collection<A> entitiesToAdd) throws InvalidParametersException {
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, entitiesToAdd);

        List<A> entitiesToUpdate = new ArrayList<>();
        List<E> entities = new ArrayList<>();

        for (A entityToAdd : entitiesToAdd) {
            entityToAdd.sanitizeForSaving();

            if (!entityToAdd.isValid()) {
                throw new InvalidParametersException(entityToAdd.getInvalidityInfo());
            }

            if (hasEntity(entityToAdd)) {
                entitiesToUpdate.add(entityToAdd);
            } else {
                E entity = entityToAdd.toEntity();
                entities.add(entity);
            }
        }

        saveEntities(entities, entitiesToAdd);

        return entitiesToUpdate;
    }

    /**
     * Creates multiple entities without checking for existence. Also calls {@link #flush()},
     * leading to any previously deferred operations being written immediately.
     *
     * @return list of created entities.
     */
    @SuppressWarnings(""PMD.UnnecessaryLocalBeforeReturn"") // Needs to flush before returning
    public List<E> createEntitiesWithoutExistenceCheck(Collection<A> entitiesToAdd) throws InvalidParametersException {
        List<E> createdEntities = createEntitiesDeferred(entitiesToAdd);
        flush();
        return createdEntities;
    }

    /**
     * Queues creation of multiple entities. No actual writes are done until {@link #flush()} is called.
     * Note that there is no check for existence - existing entities will be overwritten.
     * If multiple entities with the same key are queued, only the last one queued will be created.
     *
     * @return list of created entities.
     */
    public List<E> createEntitiesDeferred(Collection<A> entitiesToAdd) throws InvalidParametersException {
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, entitiesToAdd);

        List<E> entities = new ArrayList<>();

        for (A entityToAdd : entitiesToAdd) {
            entityToAdd.sanitizeForSaving();

            if (!entityToAdd.isValid()) {
                throw new InvalidParametersException(entityToAdd.getInvalidityInfo());
            }

            E entity = entityToAdd.toEntity();
            entities.add(entity);
        }

        saveEntitiesDeferred(entities, entitiesToAdd);

        return entities;
    }

    /**
     * Warning: Do not use this method unless a previous update might cause
     * adding of the new entity to fail due to EntityAlreadyExists exception
     * Preconditions:
     * <br> * {@code entityToAdd} is not null and has valid data.
     */
    public E createEntityWithoutExistenceCheck(A entityToAdd) throws InvalidParametersException {
        try {
            return createEntity(entityToAdd, false);
        } catch (EntityAlreadyExistsException e) {
            Assumption.fail(""Caught exception thrown by existence check even with existence check disabled"");
            return null;
        }
    }

    private E createEntity(A entityToAdd, boolean shouldCheckExistence)
            throws InvalidParametersException, EntityAlreadyExistsException {
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, entityToAdd);

        entityToAdd.sanitizeForSaving();

        if (!entityToAdd.isValid()) {
            throw new InvalidParametersException(entityToAdd.getInvalidityInfo());
        }

        // TODO: Do we really need special identifiers? Can just use ToString()?
        // Answer: Yes. We can use toString.
        if (shouldCheckExistence && hasEntity(entityToAdd)) {
            String error = String.format(ERROR_CREATE_ENTITY_ALREADY_EXISTS, entityToAdd.getEntityTypeAsString())
                    + entityToAdd.getIdentificationString();
            log.info(error);
            throw new EntityAlreadyExistsException(error);
        }

        E entity = entityToAdd.toEntity();

        saveEntity(entity, entityToAdd);

        return entity;
    }

    public void saveEntity(E entityToSave) {
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, entityToSave);

        saveEntity(entityToSave, makeAttributes(entityToSave));
    }

    protected void saveEntity(E entityToSave, A entityToSaveAttributesForLogging) {
        ofy().save().entity(entityToSave).now();
        log.info(entityToSaveAttributesForLogging.getBackupIdentifier());
    }

    protected void saveEntities(Collection<E> entitiesToSave) {
        saveEntities(entitiesToSave, makeAttributes(entitiesToSave));
    }

    protected void saveEntities(Collection<E> entitiesToSave, Collection<A> entitiesToSaveAttributesForLogging) {
        for (A attributes : entitiesToSaveAttributesForLogging) {
            log.info(attributes.getBackupIdentifier());
        }
        ofy().save().entities(entitiesToSave).now();
    }

    protected void saveEntitiesDeferred(Collection<E> entitiesToSave) {
        saveEntitiesDeferred(entitiesToSave, makeAttributes(entitiesToSave));
    }

    protected void saveEntitiesDeferred(Collection<E> entitiesToSave, Collection<A> entitiesToSaveAttributesForLogging) {
        for (A attributes : entitiesToSaveAttributesForLogging) {
            log.info(attributes.getBackupIdentifier());
        }
        ofy().defer().save().entities(entitiesToSave);
    }

    public static void flush() {
        ofy().flush();
    }

    // TODO: use this method for subclasses.
    /**
     * Note: This is a non-cascade delete.<br>
     *   <br> Fails silently if there is no such object.
     */
    public void deleteEntity(A entityToDelete) {
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, entityToDelete);

        ofy().delete().keys(getEntityQueryKeys(entityToDelete)).now();
        log.info(entityToDelete.getBackupIdentifier());
    }

    public void deleteEntities(Collection<A> entitiesToDelete) {
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, entitiesToDelete);

        List<Key<E>> keysToDelete = new ArrayList<>();
        for (A entityToDelete : entitiesToDelete) {
            Key<E> keyToDelete = getEntityQueryKeys(entityToDelete).first().now();
            if (keyToDelete == null) {
                continue;
            }
            keysToDelete.add(keyToDelete);
            log.info(entityToDelete.getBackupIdentifier());
        }

        ofy().delete().keys(keysToDelete).now();
    }

    protected void deleteEntityDirect(E entityToDelete) {
        deleteEntityDirect(entityToDelete, makeAttributes(entityToDelete));
    }

    protected void deleteEntityDirect(E entityToDelete, A entityToDeleteAttributesForLogging) {
        ofy().delete().entity(entityToDelete).now();
        log.info(entityToDeleteAttributesForLogging.getBackupIdentifier());
    }

    protected void deleteEntitiesDirect(Collection<E> entitiesToDelete) {
        deleteEntitiesDirect(entitiesToDelete, makeAttributes(entitiesToDelete));
    }

    protected void deleteEntitiesDirect(Collection<E> entitiesToDelete, Collection<A> entitiesToDeleteAttributesForLogging) {
        for (A attributes : entitiesToDeleteAttributesForLogging) {
            log.info(attributes.getBackupIdentifier());
        }
        ofy().delete().entities(entitiesToDelete).now();
    }

    public void deletePicture(BlobKey key) {
        GoogleCloudStorageHelper.deleteFile(key);
    }

    protected abstract LoadType<E> load();

    /**
     * NOTE: This method must be overriden for all subclasses such that it will return the
     * Entity matching the EntityAttributes in the parameter.
     * @return    the Entity which matches the given {@link EntityAttributes} {@code attributes}
     *             based on the default key identifiers.
     */
    protected abstract E getEntity(A attributes);

    /**
     * NOTE: This method must be overriden for all subclasses such that it will return the key query for the
     * Entity matching the EntityAttributes in the parameter.
     * @return    the key query for the Entity which matches the given {@link EntityAttributes} {@code attributes}
     *             based on the default key identifiers.
     */
    protected abstract QueryKeys<E> getEntityQueryKeys(A attributes);

    public boolean hasEntity(A attributes) {
        return getEntityQueryKeys(attributes).first().now() != null;
    }

    protected abstract A makeAttributes(E entity);

    protected A makeAttributesOrNull(E entity) {
        return makeAttributesOrNull(entity, null);
    }

    protected A makeAttributesOrNull(E entity, String logMessage) {
        if (entity != null) {
            return makeAttributes(entity);
        }
        if (logMessage != null) {
            log.info(logMessage);
        }
        return null;
    }

    protected List<A> makeAttributes(Collection<E> entities) {
        List<A> attributes = new LinkedList<>();
        for (E entity : entities) {
            attributes.add(makeAttributes(entity));
        }
        return attributes;
    }

    protected Key<E> makeKeyOrNullFromWebSafeString(String webSafeString) {
        if (webSafeString == null) {
            return null;
        }
        try {
            return Key.create(webSafeString);
        } catch (IllegalArgumentException e) {
            return null;
        }
    }

    //the followings APIs are used by Teammates' search engine
    protected void putDocument(String indexName, SearchDocument document) {
        try {
            SearchManager.putDocument(indexName, document.build());
        } catch (Exception e) {
            log.severe(""Failed to put searchable document in "" + indexName + "" for "" + document.toString());
        }
    }

    protected void putDocuments(String indexName, List<SearchDocument> documents) {
        List<Document> searchDocuments = new ArrayList<>();
        for (SearchDocument document : documents) {
            searchDocuments.add(document.build());
        }
        try {
            SearchManager.putDocuments(indexName, searchDocuments);
        } catch (Exception e) {
            log.severe(""Failed to batch put searchable documents in "" + indexName + "" for "" + documents.toString());
        }
    }

    protected Results<ScoredDocument> searchDocuments(String indexName, SearchQuery query) {
        try {
            if (query.getFilterSize() > 0) {
                return SearchManager.searchDocuments(indexName, query.toQuery());
            }
            return null;
        } catch (SearchQueryException e) {
            log.info(""Unsupported query for this query string: "" + query.toString());
            return null;
        }
    }

    protected void deleteDocument(String indexName, String documentId) {
        try {
            SearchManager.deleteDocument(indexName, documentId);
        } catch (Exception e) {
            log.info(""Unable to delete document in the index: "" + indexName + "" with document id "" + documentId);
        }
    }

}
"
FeedbackQuestionsDb.java,storage-api,"package teammates.storage.api;

import static com.googlecode.objectify.ObjectifyService.ofy;

import java.util.Arrays;
import java.util.Collection;
import java.util.List;

import com.googlecode.objectify.Key;
import com.googlecode.objectify.cmd.LoadType;
import com.googlecode.objectify.cmd.Query;
import com.googlecode.objectify.cmd.QueryKeys;

import teammates.common.datatransfer.FeedbackParticipantType;
import teammates.common.datatransfer.attributes.FeedbackQuestionAttributes;
import teammates.common.exception.EntityDoesNotExistException;
import teammates.common.exception.InvalidParametersException;
import teammates.common.util.Assumption;
import teammates.common.util.Const;
import teammates.storage.entity.FeedbackQuestion;

/**
 * Handles CRUD operations for feedback questions.
 *
 * @see FeedbackQuestion
 * @see FeedbackQuestionAttributes
 */
public class FeedbackQuestionsDb extends EntitiesDb<FeedbackQuestion, FeedbackQuestionAttributes> {
    public static final String ERROR_UPDATE_NON_EXISTENT = ""Trying to update non-existent Feedback Question : "";

    public void createFeedbackQuestions(Collection<FeedbackQuestionAttributes> questionsToAdd)
            throws InvalidParametersException {
        List<FeedbackQuestionAttributes> questionsToUpdate = createEntities(questionsToAdd);
        for (FeedbackQuestionAttributes question : questionsToUpdate) {
            try {
                updateFeedbackQuestion(question);
            } catch (EntityDoesNotExistException e) {
                // This situation is not tested as replicating such a situation is
                // difficult during testing
                Assumption.fail(""Entity found be already existing and not existing simultaneously"");
            }
        }
    }

    /**
     * Creates multiple questions without checking for existence. Also calls {@link #flush()},
     * leading to any previously deferred operations being written immediately. This is needed
     * to update the question entities with actual question IDs.
     *
     * @returns list of created {@link FeedbackQuestionAttributes} containing actual question IDs.
     */
    public List<FeedbackQuestionAttributes> createFeedbackQuestionsWithoutExistenceCheck(
            Collection<FeedbackQuestionAttributes> questions) throws InvalidParametersException {
        List<FeedbackQuestion> createdQuestions = createEntitiesWithoutExistenceCheck(questions);
        return makeAttributes(createdQuestions);
    }

    /**
     * Preconditions: <br>
     * * All parameters are non-null.
     * @return Null if not found.
     */
    public FeedbackQuestionAttributes getFeedbackQuestion(String feedbackQuestionId) {
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, feedbackQuestionId);

        return makeAttributesOrNull(getFeedbackQuestionEntity(feedbackQuestionId),
                ""Trying to get non-existent Question: "" + feedbackQuestionId);
    }

    public FeedbackQuestionAttributes createFeedbackQuestionWithoutExistenceCheck(
            FeedbackQuestionAttributes entityToAdd) throws InvalidParametersException {
        return makeAttributes(createEntityWithoutExistenceCheck(entityToAdd));
    }

    /**
     * Preconditions: <br>
     * * All parameters are non-null.
     * @return Null if not found.
     */
    public FeedbackQuestionAttributes getFeedbackQuestion(
            String feedbackSessionName,
            String courseId,
            int questionNumber) {
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, feedbackSessionName);
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, courseId);
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, questionNumber);

        return makeAttributesOrNull(getFeedbackQuestionEntity(feedbackSessionName, courseId, questionNumber),
                ""Trying to get non-existent Question: "" + questionNumber + ""."" + feedbackSessionName + ""/"" + courseId);
    }

    /**
     * Preconditions: <br>
     * * All parameters are non-null.
     * @return An empty list if no such questions are found.
     */
    public List<FeedbackQuestionAttributes> getFeedbackQuestionsForSession(
            String feedbackSessionName, String courseId) {
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, feedbackSessionName);
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, courseId);

        return makeAttributes(getFeedbackQuestionEntitiesForSession(feedbackSessionName, courseId));
    }

    /**
     * Preconditions: <br>
     * * All parameters are non-null.
     * @return An empty list if no such questions are found.
     */
    public List<FeedbackQuestionAttributes> getFeedbackQuestionsForGiverType(
            String feedbackSessionName, String courseId, FeedbackParticipantType giverType) {
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, feedbackSessionName);
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, courseId);
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, giverType);

        return makeAttributes(getFeedbackQuestionEntitiesForGiverType(feedbackSessionName, courseId, giverType));
    }

    /**
     * Preconditions: <br>
     * * All parameters are non-null.
     * @return An empty list if no such questions are found.
     */
    public List<FeedbackQuestionAttributes> getFeedbackQuestionsForCourse(String courseId) {
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, courseId);

        return makeAttributes(getFeedbackQuestionEntitiesForCourse(courseId));
    }

    /**
     * Updates the feedback question identified by `{@code newAttributes.getId()}
     *   and changes the {@code updatedAt} timestamp to be the time of update.
     * For the remaining parameters, the existing value is preserved
     *   if the parameter is null (due to 'keep existing' policy).<br>
     *
     * <p>Preconditions:
     * {@code newAttributes.getId()} is non-null and correspond to an existing feedback question.
     */
    public void updateFeedbackQuestion(FeedbackQuestionAttributes newAttributes)
            throws InvalidParametersException, EntityDoesNotExistException {
        updateFeedbackQuestion(newAttributes, false);
    }

    /**
     * Updates the feedback question identified by `{@code newAttributes.getId()}
     * For the remaining parameters, the existing value is preserved
     *   if the parameter is null (due to 'keep existing' policy).<br>
     * The timestamp for {@code updatedAt} is independent of the {@code newAttributes}
     *   and depends on the value of {@code keepUpdateTimestamp}
     * Preconditions: <br>
     * * {@code newAttributes.getId()} is non-null and
     *  correspond to an existing feedback question. <br>
     */
    public void updateFeedbackQuestion(FeedbackQuestionAttributes newAttributes, boolean keepUpdateTimestamp)
            throws InvalidParametersException, EntityDoesNotExistException {
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, newAttributes);

        // TODO: Sanitize values and update tests accordingly

        if (!newAttributes.isValid()) {
            throw new InvalidParametersException(newAttributes.getInvalidityInfo());
        }

        FeedbackQuestion fq = getEntity(newAttributes);

        if (fq == null) {
            throw new EntityDoesNotExistException(ERROR_UPDATE_NON_EXISTENT + newAttributes.toString());
        }

        fq.setQuestionNumber(newAttributes.questionNumber);
        fq.setQuestionText(newAttributes.questionMetaData);
        fq.setQuestionDescription(newAttributes.questionDescription);
        fq.setQuestionType(newAttributes.questionType);
        fq.setGiverType(newAttributes.giverType);
        fq.setRecipientType(newAttributes.recipientType);
        fq.setShowResponsesTo(newAttributes.showResponsesTo);
        fq.setShowGiverNameTo(newAttributes.showGiverNameTo);
        fq.setShowRecipientNameTo(newAttributes.showRecipientNameTo);
        fq.setNumberOfEntitiesToGiveFeedbackTo(newAttributes.numberOfEntitiesToGiveFeedbackTo);

        //set true to prevent changes to last update timestamp
        fq.keepUpdateTimestamp = keepUpdateTimestamp;

        saveEntity(fq, newAttributes);
    }

    public void deleteFeedbackQuestionsForCourse(String courseId) {
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, courseId);

        deleteFeedbackQuestionsForCourses(Arrays.asList(courseId));
    }

    public void deleteFeedbackQuestionsForCourses(List<String> courseIds) {
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, courseIds);

        ofy().delete().keys(load().filter(""courseId in"", courseIds).keys()).now();
    }

    // Gets a question entity if its Key (feedbackQuestionId) is known.
    private FeedbackQuestion getFeedbackQuestionEntity(String feedbackQuestionId) {
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, feedbackQuestionId);

        Key<FeedbackQuestion> key = makeKeyOrNullFromWebSafeString(feedbackQuestionId);
        if (key == null) {
            return null;
        }

        return ofy().load().key(key).now();
    }

    // Gets a feedbackQuestion based on feedbackSessionName and questionNumber.
    private FeedbackQuestion getFeedbackQuestionEntity(
            String feedbackSessionName, String courseId, int questionNumber) {
        return load()
                .filter(""feedbackSessionName ="", feedbackSessionName)
                .filter(""courseId ="", courseId)
                .filter(""questionNumber ="", questionNumber)
                .first().now();
    }

    private List<FeedbackQuestion> getFeedbackQuestionEntitiesForSession(
            String feedbackSessionName, String courseId) {
        return load()
                .filter(""feedbackSessionName ="", feedbackSessionName)
                .filter(""courseId ="", courseId)
                .list();
    }

    private List<FeedbackQuestion> getFeedbackQuestionEntitiesForCourse(String courseId) {
        return load()
                .filter(""courseId ="", courseId)
                .list();
    }

    private List<FeedbackQuestion> getFeedbackQuestionEntitiesForGiverType(
            String feedbackSessionName, String courseId, FeedbackParticipantType giverType) {
        return load()
                .filter(""feedbackSessionName ="", feedbackSessionName)
                .filter(""courseId ="", courseId)
                .filter(""giverType ="", giverType)
                .list();
    }

    @Override
    protected LoadType<FeedbackQuestion> load() {
        return ofy().load().type(FeedbackQuestion.class);
    }

    @Override
    protected FeedbackQuestion getEntity(FeedbackQuestionAttributes attributes) {
        if (attributes.getId() != null) {
            return getFeedbackQuestionEntity(attributes.getId());
        }

        return getFeedbackQuestionEntity(attributes.feedbackSessionName, attributes.courseId, attributes.questionNumber);
    }

    @Override
    protected QueryKeys<FeedbackQuestion> getEntityQueryKeys(FeedbackQuestionAttributes attributes) {
        Key<FeedbackQuestion> key = makeKeyOrNullFromWebSafeString(attributes.getId());

        Query<FeedbackQuestion> query;
        if (key == null) {
            query = load()
                    .filter(""feedbackSessionName ="", attributes.feedbackSessionName)
                    .filter(""courseId ="", attributes.courseId)
                    .filter(""questionNumber ="", attributes.questionNumber);
        } else {
            query = load().filterKey(key);
        }

        return query.keys();
    }

    @Override
    protected FeedbackQuestionAttributes makeAttributes(FeedbackQuestion entity) {
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, entity);

        return new FeedbackQuestionAttributes(entity);
    }
}
"
FeedbackResponseCommentsDb.java,storage-api,"package teammates.storage.api;

import static com.googlecode.objectify.ObjectifyService.ofy;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import com.google.appengine.api.search.Results;
import com.google.appengine.api.search.ScoredDocument;
import com.googlecode.objectify.Key;
import com.googlecode.objectify.cmd.LoadType;
import com.googlecode.objectify.cmd.Query;
import com.googlecode.objectify.cmd.QueryKeys;

import teammates.common.datatransfer.FeedbackResponseCommentSearchResultBundle;
import teammates.common.datatransfer.attributes.FeedbackResponseCommentAttributes;
import teammates.common.datatransfer.attributes.InstructorAttributes;
import teammates.common.exception.EntityAlreadyExistsException;
import teammates.common.exception.EntityDoesNotExistException;
import teammates.common.exception.InvalidParametersException;
import teammates.common.util.Assumption;
import teammates.common.util.Const;
import teammates.common.util.Logger;
import teammates.storage.entity.FeedbackResponseComment;
import teammates.storage.search.FeedbackResponseCommentSearchDocument;
import teammates.storage.search.FeedbackResponseCommentSearchQuery;
import teammates.storage.search.SearchDocument;

/**
 * Handles CRUD operations for feedback response comments.
 *
 * @see FeedbackResponseComment
 * @see FeedbackResponseCommentAttributes
 */
public class FeedbackResponseCommentsDb extends EntitiesDb<FeedbackResponseComment, FeedbackResponseCommentAttributes> {

    private static final Logger log = Logger.getLogger();

    public void createFeedbackResponseComments(Collection<FeedbackResponseCommentAttributes> commentsToAdd)
            throws InvalidParametersException {
        List<FeedbackResponseCommentAttributes> commentsToUpdate = createEntities(commentsToAdd);
        for (FeedbackResponseCommentAttributes comment : commentsToUpdate) {
            try {
                updateFeedbackResponseComment(comment);
            } catch (EntityDoesNotExistException e) {
                // This situation is not tested as replicating such a situation is
                // difficult during testing
                Assumption.fail(""Entity found be already existing and not existing simultaneously"");
            }
        }
    }

    /**
     * Preconditions:
     * <br> * {@code entityToAdd} is not null and has valid data.
     */
    public FeedbackResponseCommentAttributes createFeedbackResponseComment(FeedbackResponseCommentAttributes entityToAdd)
            throws InvalidParametersException, EntityAlreadyExistsException {
        return makeAttributesOrNull(createEntity(entityToAdd),
                ""Trying to get non-existent FeedbackResponseComment, possibly entity not persistent yet."");
    }

    /*
     * Remove search document for the given comment
     */
    public void deleteDocument(FeedbackResponseCommentAttributes commentToDelete) {
        Long id = commentToDelete.getId();

        if (id == null) {
            Key<FeedbackResponseComment> key = getEntityQueryKeys(commentToDelete).first().now();

            if (key == null) {
                return;
            }

            id = key.getId();
        }

        deleteDocument(Const.SearchIndex.FEEDBACK_RESPONSE_COMMENT, id.toString());
    }

    /**
     * Preconditions: <br>
     * * All parameters are non-null.
     * @return Null if not found.
     */
    public FeedbackResponseCommentAttributes getFeedbackResponseComment(Long feedbackResponseCommentId) {
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, feedbackResponseCommentId);

        return makeAttributesOrNull(getFeedbackResponseCommentEntity(feedbackResponseCommentId),
                ""Trying to get non-existent response comment: "" + feedbackResponseCommentId + ""."");
    }

    /**
     * Preconditions: <br>
     * * All parameters are non-null.
     * @return Null if not found.
     */
    public FeedbackResponseCommentAttributes getFeedbackResponseComment(
            String feedbackResponseId, String giverEmail, Date createdAt) {
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, feedbackResponseId);
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, giverEmail);
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, createdAt);

        return makeAttributesOrNull(getFeedbackResponseCommentEntity(feedbackResponseId, giverEmail, createdAt),
                ""Trying to get non-existent response comment: "" + feedbackResponseId + ""/from: "" + giverEmail
                + ""created at: "" + createdAt);
    }

    /**
     * Preconditions: <br>
     * * All parameters are non-null.
     * @return Null if not found.
     */
    public FeedbackResponseCommentAttributes getFeedbackResponseComment(
            String courseId, Date createdAt, String giverEmail) {
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, courseId);
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, giverEmail);
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, createdAt);

        return makeAttributesOrNull(getFeedbackResponseCommentEntity(courseId, createdAt, giverEmail),
                ""Trying to get non-existent response comment: from: "" + giverEmail + "" in the course "" + courseId
                + "" created at: "" + createdAt);
    }

    /**
     * Preconditions: <br>
     * * All parameters are non-null.
     * @return Null if not found.
     */
    public List<FeedbackResponseCommentAttributes> getFeedbackResponseCommentForGiver(String courseId, String giverEmail) {
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, courseId);
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, giverEmail);

        return makeAttributes(getFeedbackResponseCommentEntitiesForGiverInCourse(courseId, giverEmail));
    }

    /*
     * Get response comments for the response Id
     */
    public List<FeedbackResponseCommentAttributes> getFeedbackResponseCommentsForResponse(String feedbackResponseId) {
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, feedbackResponseId);

        return makeAttributes(getFeedbackResponseCommentEntitiesForResponse(feedbackResponseId));
    }

    /*
     * Remove response comments for the response Id
     */
    public void deleteFeedbackResponseCommentsForResponse(String responseId) {
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, responseId);

        ofy().delete().keys(getFeedbackResponseCommentsForResponseQuery(responseId).keys()).now();
    }

    /*
     * Remove response comments for the course Ids
     */
    public void deleteFeedbackResponseCommentsForCourses(List<String> courseIds) {
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, courseIds);

        ofy().delete().keys(getFeedbackResponseCommentsForCoursesQuery(courseIds).keys()).now();
    }

    public void deleteFeedbackResponseCommentsForCourse(String courseId) {
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, courseId);

        deleteFeedbackResponseCommentsForCourses(Arrays.asList(courseId));
    }

    private Query<FeedbackResponseComment> getFeedbackResponseCommentsForCoursesQuery(List<String> courseIds) {
        return load().filter(""courseId in"", courseIds);
    }

    /*
     * Get response comments for the course
     */
    public List<FeedbackResponseCommentAttributes> getFeedbackResponseCommentsForCourse(String courseId) {
        return makeAttributes(getFeedbackResponseCommentEntitiesForCourse(courseId));
    }

    /**
     * Preconditions: <br>
     * * All parameters are non-null.
     */
    public List<FeedbackResponseCommentAttributes> getFeedbackResponseCommentsForSession(
            String courseId, String feedbackSessionName) {
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, courseId);
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, feedbackSessionName);

        return makeAttributes(getFeedbackResponseCommentEntitiesForSession(courseId, feedbackSessionName));
    }

    /**
     * Preconditions: <br>
     * * All parameters are non-null.
     */
    public List<FeedbackResponseCommentAttributes> getFeedbackResponseCommentsForSessionInSection(
            String courseId, String feedbackSessionName, String section) {
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, courseId);
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, feedbackSessionName);
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, section);

        return makeAttributes(getFeedbackResponseCommentEntitiesForSessionInSection(courseId, feedbackSessionName, section));
    }

    /**
     * Preconditions: <br>
     * * All parameters are non-null.
     */
    public FeedbackResponseCommentAttributes updateFeedbackResponseComment(FeedbackResponseCommentAttributes newAttributes)
            throws InvalidParametersException, EntityDoesNotExistException {
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, newAttributes);

        newAttributes.sanitizeForSaving();

        if (!newAttributes.isValid()) {
            throw new InvalidParametersException(newAttributes.getInvalidityInfo());
        }
        FeedbackResponseComment frc = getEntity(newAttributes);

        if (frc == null) {
            throw new EntityDoesNotExistException(ERROR_UPDATE_NON_EXISTENT + newAttributes.toString());
        }

        frc.setCommentText(newAttributes.commentText);
        frc.setGiverSection(newAttributes.giverSection);
        frc.setReceiverSection(newAttributes.receiverSection);
        frc.setShowCommentTo(newAttributes.showCommentTo);
        frc.setShowGiverNameTo(newAttributes.showGiverNameTo);
        frc.setIsVisibilityFollowingFeedbackQuestion(false);
        frc.setLastEditorEmail(newAttributes.giverEmail);
        frc.setLastEditedAt(newAttributes.createdAt);

        if (newAttributes.feedbackResponseId != null) {
            frc.setFeedbackResponseId(newAttributes.feedbackResponseId);
        }

        saveEntity(frc, newAttributes);

        return makeAttributes(frc);
    }

    /*
     * Update giver email (normally an instructor email) with the new one
     */
    public void updateGiverEmailOfFeedbackResponseComments(String courseId, String oldEmail, String updatedEmail) {
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, courseId);
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, oldEmail);
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, updatedEmail);

        if (oldEmail.equals(updatedEmail)) {
            return;
        }

        List<FeedbackResponseComment> responseComments =
                getFeedbackResponseCommentEntitiesForGiverInCourse(courseId, oldEmail);

        for (FeedbackResponseComment responseComment : responseComments) {
            responseComment.setGiverEmail(updatedEmail);
        }

        saveEntities(responseComments);
    }

    /*
     * Updates last editor for all comments last edited by the given instructor with the instructor's new email
     */
    public void updateLastEditorEmailOfFeedbackResponseComments(String courseId, String oldEmail, String updatedEmail) {
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, courseId);
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, oldEmail);
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, updatedEmail);

        if (oldEmail.equals(updatedEmail)) {
            return;
        }

        List<FeedbackResponseComment> responseComments =
                getFeedbackResponseCommentEntitiesForLastEditorInCourse(courseId, oldEmail);

        for (FeedbackResponseComment responseComment : responseComments) {
            responseComment.setLastEditorEmail(updatedEmail);
        }

        saveEntities(responseComments);
        log.info(""updating last editor email from: "" + oldEmail + "" to: "" + updatedEmail
                 + "" for feedback response comments in the course: "" + courseId);
    }

    /*
     * Create or update search document for the given comment
     */
    public void putDocument(FeedbackResponseCommentAttributes comment) {
        putDocument(Const.SearchIndex.FEEDBACK_RESPONSE_COMMENT, new FeedbackResponseCommentSearchDocument(comment));
    }

    /*
     * Batch creates or updates search documents for the given comments
     */
    public void putDocuments(List<FeedbackResponseCommentAttributes> comments) {
        List<SearchDocument> frcSearchDocuments = new ArrayList<>();
        for (FeedbackResponseCommentAttributes comment : comments) {
            frcSearchDocuments.add(new FeedbackResponseCommentSearchDocument(comment));
        }
        putDocuments(Const.SearchIndex.FEEDBACK_RESPONSE_COMMENT, frcSearchDocuments);
    }

    /**
     * Searches for response comments.
     * @return {@link FeedbackResponseCommentSearchResultBundle}
     */
    public FeedbackResponseCommentSearchResultBundle search(String queryString, List<InstructorAttributes> instructors) {
        if (queryString.trim().isEmpty()) {
            return new FeedbackResponseCommentSearchResultBundle();
        }

        Results<ScoredDocument> results = searchDocuments(Const.SearchIndex.FEEDBACK_RESPONSE_COMMENT,
                new FeedbackResponseCommentSearchQuery(instructors, queryString));

        return FeedbackResponseCommentSearchDocument.fromResults(results, instructors);
    }

    /**
     * Returns all feedback response comments in the Datastore.
     *
     * @deprecated Not scalable. Don't use unless in admin features.
     */
    @Deprecated
    public List<FeedbackResponseCommentAttributes> getAllFeedbackResponseComments() {
        return makeAttributes(load().list());
    }

    private FeedbackResponseComment getFeedbackResponseCommentEntity(String courseId, Date createdAt, String giverEmail) {
        return load()
                .filter(""courseId ="", courseId)
                .filter(""createdAt ="", createdAt)
                .filter(""giverEmail ="", giverEmail)
                .first().now();
    }

    private FeedbackResponseComment getFeedbackResponseCommentEntity(Long feedbackResponseCommentId) {
        return load().id(feedbackResponseCommentId).now();
    }

    private FeedbackResponseComment getFeedbackResponseCommentEntity(
            String feedbackResponseId, String giverEmail, Date createdAt) {
        return load()
                .filter(""feedbackResponseId ="", feedbackResponseId)
                .filter(""giverEmail ="", giverEmail)
                .filter(""createdAt ="", createdAt)
                .first().now();
    }

    private List<FeedbackResponseComment> getFeedbackResponseCommentEntitiesForGiverInCourse(
            String courseId, String giverEmail) {
        return load()
                .filter(""courseId ="", courseId)
                .filter(""giverEmail ="", giverEmail)
                .list();
    }

    /*
     * Gets a list of FeedbackResponseComments which have a last editor associated with the given email
     */
    private List<FeedbackResponseComment> getFeedbackResponseCommentEntitiesForLastEditorInCourse(
            String courseId, String lastEditorEmail) {
        return load()
                .filter(""courseId ="", courseId)
                .filter(""lastEditorEmail ="", lastEditorEmail)
                .list();
    }

    private Query<FeedbackResponseComment> getFeedbackResponseCommentsForResponseQuery(String feedbackResponseId) {
        return load().filter(""feedbackResponseId ="", feedbackResponseId);
    }

    private List<FeedbackResponseComment> getFeedbackResponseCommentEntitiesForResponse(String feedbackResponseId) {
        return getFeedbackResponseCommentsForResponseQuery(feedbackResponseId).list();
    }

    private List<FeedbackResponseComment> getFeedbackResponseCommentEntitiesForSession(
            String courseId, String feedbackSessionName) {
        return load()
                .filter(""courseId ="", courseId)
                .filter(""feedbackSessionName ="", feedbackSessionName)
                .list();
    }

    private List<FeedbackResponseComment> getFeedbackResponseCommentEntitiesForCourse(String courseId) {
        return load()
                .filter(""courseId ="", courseId)
                .list();
    }

    private Collection<FeedbackResponseComment> getFeedbackResponseCommentEntitiesForSessionInSection(
            String courseId, String feedbackSessionName, String section) {
        Map<Long, FeedbackResponseComment> comments = new HashMap<>();

        List<FeedbackResponseComment> firstQueryResponseComments = load()
                .filter(""courseId ="", courseId)
                .filter(""feedbackSessionName ="", feedbackSessionName)
                .filter(""giverSection ="", section)
                .list();

        for (FeedbackResponseComment comment : firstQueryResponseComments) {
            comments.put(comment.getFeedbackResponseCommentId(), comment);
        }

        List<FeedbackResponseComment> secondQueryResponseComments = load()
                .filter(""courseId ="", courseId)
                .filter(""feedbackSessionName ="", feedbackSessionName)
                .filter(""receiverSection ="", section)
                .list();

        for (FeedbackResponseComment comment : secondQueryResponseComments) {
            comments.put(comment.getFeedbackResponseCommentId(), comment);
        }

        return comments.values();
    }

    @Override
    protected LoadType<FeedbackResponseComment> load() {
        return ofy().load().type(FeedbackResponseComment.class);
    }

    @Override
    protected FeedbackResponseComment getEntity(FeedbackResponseCommentAttributes attributes) {
        if (attributes.getId() != null) {
            return getFeedbackResponseCommentEntity(attributes.getId());
        }

        return getFeedbackResponseCommentEntity(attributes.courseId, attributes.createdAt, attributes.giverEmail);
    }

    @Override
    protected QueryKeys<FeedbackResponseComment> getEntityQueryKeys(FeedbackResponseCommentAttributes attributes) {
        Long id = attributes.getId();

        Query<FeedbackResponseComment> query;
        if (id == null) {
            query = load()
                    .filter(""courseId ="", attributes.courseId)
                    .filter(""createdAt ="", attributes.createdAt)
                    .filter(""giverEmail ="", attributes.giverEmail);
        } else {
            query = load().filterKey(Key.create(FeedbackResponseComment.class, id));
        }

        return query.keys();
    }

    @Override
    protected FeedbackResponseCommentAttributes makeAttributes(FeedbackResponseComment entity) {
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, entity);

        return new FeedbackResponseCommentAttributes(entity);
    }
}
"
FeedbackResponsesDb.java,storage-api,"package teammates.storage.api;

import static com.googlecode.objectify.ObjectifyService.ofy;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import com.googlecode.objectify.Key;
import com.googlecode.objectify.cmd.LoadType;
import com.googlecode.objectify.cmd.Query;
import com.googlecode.objectify.cmd.QueryKeys;

import teammates.common.datatransfer.attributes.FeedbackResponseAttributes;
import teammates.common.exception.EntityDoesNotExistException;
import teammates.common.exception.InvalidParametersException;
import teammates.common.util.Assumption;
import teammates.common.util.Const;
import teammates.common.util.Logger;
import teammates.storage.entity.FeedbackResponse;

/**
 * Handles CRUD operations for feedback responses.
 *
 * @see FeedbackResponse
 * @see FeedbackResponseAttributes
 */
public class FeedbackResponsesDb extends EntitiesDb<FeedbackResponse, FeedbackResponseAttributes> {

    private static final Logger log = Logger.getLogger();

    public void createFeedbackResponses(Collection<FeedbackResponseAttributes> responsesToAdd)
            throws InvalidParametersException {
        List<FeedbackResponseAttributes> responsesToUpdate = createEntities(responsesToAdd);
        for (FeedbackResponseAttributes response : responsesToUpdate) {
            try {
                updateFeedbackResponse(response);
            } catch (EntityDoesNotExistException e) {
                // This situation is not tested as replicating such a situation is
                // difficult during testing
                Assumption.fail(""Entity found be already existing and not existing simultaneously"");
            }
        }
    }

    /**
     * Preconditions: <br>
     * * All parameters are non-null.
     * @return Null if not found.
     */
    public FeedbackResponseAttributes getFeedbackResponse(String feedbackResponseId) {
        return makeAttributesOrNull(getFeedbackResponseEntityWithCheck(feedbackResponseId));
    }

    /**
     * Preconditions: <br>
     * * All parameters are non-null.
     * @return Null if not found.
     */
    public FeedbackResponseAttributes getFeedbackResponse(
            String feedbackQuestionId, String giverEmail, String receiverEmail) {
        return makeAttributesOrNull(getFeedbackResponseEntityWithCheck(feedbackQuestionId, giverEmail, receiverEmail));
    }

    /**
     * Preconditions: <br>
     * * All parameters are non-null.
     * @return Null if not found.
     */
    public FeedbackResponse getFeedbackResponseEntityWithCheck(String feedbackResponseId) {
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, feedbackResponseId);

        FeedbackResponse fr = getFeedbackResponseEntity(feedbackResponseId);
        if (fr == null) {
            log.info(""Trying to get non-existent response: "" + feedbackResponseId + ""."");
            return null;
        }
        return fr;
    }

    /**
     * Preconditions: <br>
     * * All parameters are non-null.
     * @return Null if not found.
     */
    public FeedbackResponse getFeedbackResponseEntityWithCheck(
            String feedbackQuestionId, String giverEmail, String receiverEmail) {
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, feedbackQuestionId);
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, giverEmail);
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, receiverEmail);

        FeedbackResponse fr = getFeedbackResponseEntity(feedbackQuestionId, giverEmail, receiverEmail);
        if (fr == null) {
            log.warning(""Trying to get non-existent response: "" + feedbackQuestionId + ""/"" + ""from: "" + giverEmail
                    + "" to: "" + receiverEmail);
            return null;
        }
        return fr;
    }

    /**
     * Preconditions: <br>
     * * All parameters are non-null.
     * @return Null if not found.
     */
    public FeedbackResponse getFeedbackResponseEntityOptimized(FeedbackResponseAttributes response) {
        return getEntity(response);
    }

    /**
     * Preconditions: <br>
     * * All parameters are non-null.
     * @return An empty list if no such responses are found.
     */
    public List<FeedbackResponseAttributes> getFeedbackResponsesForQuestionInSection(
            String feedbackQuestionId, String section) {
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, feedbackQuestionId);
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, section);

        return makeAttributes(getFeedbackResponseEntitiesForQuestionInSection(feedbackQuestionId, section));
    }

    /**
     * Preconditions: <br>
     * * All parameters are non-null.
     * @return An empty list if no such responses are found.
     */
    public List<FeedbackResponseAttributes> getFeedbackResponsesForQuestion(
            String feedbackQuestionId) {
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, feedbackQuestionId);

        return makeAttributes(getFeedbackResponseEntitiesForQuestion(feedbackQuestionId));
    }

    /**
     * Finds the responses for a specified question within a given range.
     *
     * @return An empty list if no such responses are found.
     */
    public List<FeedbackResponseAttributes> getFeedbackResponsesForQuestionWithinRange(
            String feedbackQuestionId, int range) {
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, feedbackQuestionId);

        return makeAttributes(getFeedbackResponseEntitiesForQuestionWithinRange(feedbackQuestionId, range));
    }

    /**
     * Preconditions: <br>
     * * All parameters are non-null.
     * @return An empty list if no such responses are found.
     */
    public List<FeedbackResponseAttributes> getFeedbackResponsesForSession(
            String feedbackSessionName, String courseId) {
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, feedbackSessionName);
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, courseId);

        return makeAttributes(getFeedbackResponseEntitiesForSession(feedbackSessionName, courseId));
    }

    /**
     * Preconditions: <br>
     * * All parameters are non-null.
     * @return An empty list if no such responses are found.
     */
    public List<FeedbackResponseAttributes> getFeedbackResponsesForSessionWithinRange(
            String feedbackSessionName, String courseId, int range) {
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, feedbackSessionName);
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, courseId);

        return makeAttributes(getFeedbackResponseEntitiesForSessionWithinRange(feedbackSessionName, courseId, range));
    }

    /**
     * Preconditions: <br>
     * * All parameters are non-null.
     * @return An empty list if no such responses are found.
     */
    public List<FeedbackResponseAttributes> getFeedbackResponsesForSessionInSection(
            String feedbackSessionName, String courseId, String section) {
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, feedbackSessionName);
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, courseId);
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, section);

        return makeAttributes(getFeedbackResponseEntitiesForSessionInSection(feedbackSessionName, courseId, section));
    }

    /**
     * Preconditions: <br>
     * * All parameters are non-null.
     * @return An empty list if no such responses are found.
     */
    public List<FeedbackResponseAttributes> getFeedbackResponsesForSessionFromSection(
            String feedbackSessionName, String courseId, String section) {
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, feedbackSessionName);
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, courseId);
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, section);

        return makeAttributes(getFeedbackResponseEntitiesForSessionFromSection(feedbackSessionName, courseId, section));
    }

    /**
     * Preconditions: <br>
     * * All parameters are non-null.
     * @return An empty list if no such responses are found.
     */
    public List<FeedbackResponseAttributes> getFeedbackResponsesForSessionToSection(
            String feedbackSessionName, String courseId, String section) {
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, feedbackSessionName);
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, courseId);
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, section);

        return makeAttributes(getFeedbackResponseEntitiesForSessionToSection(feedbackSessionName, courseId, section));
    }

    /**
     * Preconditions: <br>
     * * All parameters are non-null.
     * @return An empty list if no such responses are found.
     */
    public List<FeedbackResponseAttributes> getFeedbackResponsesForSessionInSectionWithinRange(
            String feedbackSessionName, String courseId, String section, int range) {
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, feedbackSessionName);
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, courseId);
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, section);

        return makeAttributes(
                getFeedbackResponseEntitiesForSessionInSectionWithinRange(
                        feedbackSessionName, courseId, section, range));
    }

    /**
     * Preconditions: <br>
     * * All parameters are non-null.
     * @return An empty list if no such responses are found.
     */
    public List<FeedbackResponseAttributes> getFeedbackResponsesForSessionFromSectionWithinRange(
            String feedbackSessionName, String courseId, String section, int range) {
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, feedbackSessionName);
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, courseId);
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, section);

        return makeAttributes(
                getFeedbackResponseEntitiesForSessionFromSectionWithinRange(
                        feedbackSessionName, courseId, section, range));
    }

    /**
     * Preconditions: <br>
     * * All parameters are non-null.
     * @return An empty list if no such responses are found.
     */
    public List<FeedbackResponseAttributes> getFeedbackResponsesForSessionToSectionWithinRange(
            String feedbackSessionName, String courseId, String section, int range) {
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, feedbackSessionName);
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, courseId);
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, section);

        return makeAttributes(
                getFeedbackResponseEntitiesForSessionToSectionWithinRange(
                        feedbackSessionName, courseId, section, range));
    }

    /**
     * Preconditions: <br>
     * * All parameters are non-null.
     * @return An empty list if no such responses are found.
     */
    public List<FeedbackResponseAttributes> getFeedbackResponsesForReceiverForQuestion(
            String feedbackQuestionId, String receiver) {
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, feedbackQuestionId);
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, receiver);

        return makeAttributes(getFeedbackResponseEntitiesForReceiverForQuestion(feedbackQuestionId, receiver));
    }

    /**
     * Preconditions: <br>
     * * All parameters are non-null.
     * @return An empty list if no such responses are found.
     */
    public List<FeedbackResponseAttributes> getFeedbackResponsesForReceiverForQuestionInSection(
            String feedbackQuestionId, String receiver, String section) {
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, feedbackQuestionId);
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, receiver);
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, section);

        return makeAttributes(
                getFeedbackResponseEntitiesForReceiverForQuestionInSection(feedbackQuestionId, receiver, section));
    }

    /**
     * Preconditions: <br>
     * * All parameters are non-null.
     * @return An empty list if no such responses are found.
     */
    public List<FeedbackResponseAttributes> getFeedbackResponsesFromGiverForQuestion(
            String feedbackQuestionId, String giverEmail) {
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, feedbackQuestionId);
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, giverEmail);

        return makeAttributes(getFeedbackResponseEntitiesFromGiverForQuestion(feedbackQuestionId, giverEmail));
    }

    /**
     * Preconditions: <br>
     * * All parameters are non-null.
     * @return An empty list if no such responses are found.
     */
    public List<FeedbackResponseAttributes> getFeedbackResponsesFromGiverForQuestionInSection(
            String feedbackQuestionId, String giverEmail, String section) {
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, feedbackQuestionId);
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, giverEmail);
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, section);

        return makeAttributes(
                getFeedbackResponseEntitiesFromGiverForQuestionInSection(feedbackQuestionId, giverEmail, section));
    }

    /**
     *  Preconditions: <br>
     * * All parameters are non-null.
     *  @return An empty list if no such responses are found.
     */
    public List<FeedbackResponseAttributes> getFeedbackResponsesFromGiverForSessionWithinRange(
            String giverEmail, String feedbackSessionName, String courseId, int range) {
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, giverEmail);
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, feedbackSessionName);
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, courseId);

        return makeAttributes(getFeedbackResponseEntitiesFromGiverForSessionWithinRange(
                giverEmail, feedbackSessionName, courseId, range));
    }

    /**
     * Preconditions: <br>
     * * All parameters are non-null.
     * @return An empty list if no such responses are found.
     */
    public List<FeedbackResponseAttributes> getFeedbackResponsesForReceiverForCourse(
            String courseId, String receiver) {
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, courseId);
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, receiver);

        return makeAttributes(getFeedbackResponseEntitiesForReceiverForCourse(courseId, receiver));
    }

    /**
     * Preconditions: <br>
     * * All parameters are non-null.
     * @return An empty list if no such responses are found.
     */
    public List<FeedbackResponseAttributes> getFeedbackResponsesFromGiverForCourse(
            String courseId, String giverEmail) {
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, courseId);
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, giverEmail);

        return makeAttributes(getFeedbackResponseEntitiesFromGiverForCourse(courseId, giverEmail));
    }

    /**
     * Updates the feedback response identified by {@code newAttributes.getId()} and
     *   changes the {@code updatedAt} timestamp to be the time of update.
     * For the remaining parameters, the existing value is preserved
     *   if the parameter is null (due to 'keep existing' policy).<br>
     * Preconditions: <br>
     * * {@code newAttributes.getId()} is non-null and correspond to an existing feedback response.
     */
    public void updateFeedbackResponse(FeedbackResponseAttributes newAttributes)
            throws InvalidParametersException, EntityDoesNotExistException {
        updateFeedbackResponse(newAttributes, false);
    }

    /**
     * Updates the feedback response identified by {@code newAttributes.getId()}
     * For the remaining parameters, the existing value is preserved
     *   if the parameter is null (due to 'keep existing' policy).<br>
     * The timestamp for {@code updatedAt} is independent of the {@code newAttributes}
     *   and depends on the value of {@code keepUpdateTimestamp}
     * Preconditions: <br>
     * * {@code newAttributes.getId()} is non-null and correspond to an existing feedback response.
     */
    public void updateFeedbackResponse(FeedbackResponseAttributes newAttributes, boolean keepUpdateTimestamp)
            throws InvalidParametersException, EntityDoesNotExistException {
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, newAttributes);

        if (!newAttributes.isValid()) {
            throw new InvalidParametersException(newAttributes.getInvalidityInfo());
        }

        updateFeedbackResponseOptimized(newAttributes, getEntity(newAttributes), keepUpdateTimestamp);
    }

    /**
     * Optimized to take in FeedbackResponse entity if available, to prevent reading the entity again.
     * Updates the feedback response identified by {@code newAttributes.getId()}
     * For the remaining parameters, the existing value is preserved
     *   if the parameter is null (due to 'keep existing' policy).<br>
     * The timestamp for {@code updatedAt} is independent of the {@code newAttributes}
     *   and depends on the value of {@code keepUpdateTimestamp}
     * Preconditions: <br>
     * * {@code newAttributes.getId()} is non-null and correspond to an existing feedback response.
     */
    private void updateFeedbackResponseOptimized(FeedbackResponseAttributes newAttributes, FeedbackResponse fr,
            boolean keepUpdateTimestamp) throws InvalidParametersException, EntityDoesNotExistException {
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, newAttributes);

        //TODO: Sanitize values and update tests accordingly

        if (!newAttributes.isValid()) {
            throw new InvalidParametersException(newAttributes.getInvalidityInfo());
        }

        if (fr == null) {
            throw new EntityDoesNotExistException(ERROR_UPDATE_NON_EXISTENT + newAttributes.toString());
        }

        fr.keepUpdateTimestamp = keepUpdateTimestamp;
        fr.setAnswer(newAttributes.responseMetaData);
        fr.setRecipientEmail(newAttributes.recipient);
        fr.setGiverSection(newAttributes.giverSection);
        fr.setRecipientSection(newAttributes.recipientSection);

        saveEntity(fr, newAttributes);
    }

    public void updateFeedbackResponseOptimized(FeedbackResponseAttributes newAttributes, FeedbackResponse fr)
            throws InvalidParametersException, EntityDoesNotExistException {
        updateFeedbackResponseOptimized(newAttributes, fr, false);
    }

    public void deleteFeedbackResponsesForCourse(String courseId) {
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, courseId);

        deleteFeedbackResponsesForCourses(Arrays.asList(courseId));
    }

    public void deleteFeedbackResponsesForCourses(List<String> courseIds) {
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, courseIds);

        ofy().delete().keys(getFeedbackResponsesForCoursesQuery(courseIds).keys()).now();
    }

    private Query<FeedbackResponse> getFeedbackResponsesForCoursesQuery(List<String> courseIds) {
        return load().filter(""courseId in"", courseIds);
    }

    public List<FeedbackResponse> getFeedbackResponseEntitiesForCourses(List<String> courseIds) {
        return getFeedbackResponsesForCoursesQuery(courseIds).list();
    }

    public List<FeedbackResponseAttributes> getFeedbackResponsesForCourse(String courseId) {
        return makeAttributes(getFeedbackResponseEntitiesForCourse(courseId));
    }

    private List<FeedbackResponse> getFeedbackResponseEntitiesForCourse(String courseId) {
        return load().filter(""courseId ="", courseId).list();
    }

    /**
     * Returns true if there are existing responses in any feedback session in the course.
     */
    public boolean hasFeedbackResponseEntitiesForCourse(String courseId) {
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, courseId);
        return !getFeedbackResponseEntitiesForCourseWithinRange(courseId, 1).isEmpty();
    }

    private List<FeedbackResponse> getFeedbackResponseEntitiesForCourseWithinRange(String courseId, int range) {
        return load().filter(""courseId ="", courseId).limit(range).list();
    }

    private FeedbackResponse getFeedbackResponseEntity(String feedbackResponseId) {
        return load().id(feedbackResponseId).now();
    }

    private FeedbackResponse getFeedbackResponseEntity(
            String feedbackQuestionId, String giverEmail, String receiver) {
        return load()
                .filter(""feedbackQuestionId ="", feedbackQuestionId)
                .filter(""giverEmail ="", giverEmail)
                .filter(""receiver ="", receiver)
                .first().now();
    }

    private List<FeedbackResponse> getFeedbackResponseEntitiesForQuestionInSection(
                String feedbackQuestionId, String section) {
        List<FeedbackResponse> feedbackResponses = new ArrayList<>();

        feedbackResponses.addAll(load()
                .filter(""feedbackQuestionId ="", feedbackQuestionId)
                .filter(""giverSection ="", section)
                .filter(""receiverSection ="", section)
                .list());

        feedbackResponses.addAll(load()
                .filter(""feedbackQuestionId ="", feedbackQuestionId)
                .filter(""giverSection ="", section)
                .filter(""receiverSection ="", ""None"")
                .list());

        feedbackResponses.addAll(load()
                .filter(""feedbackQuestionId ="", feedbackQuestionId)
                .filter(""giverSection ="", ""None"")
                .filter(""receiverSection ="", section)
                .list());

        return feedbackResponses;
    }

    private List<FeedbackResponse> getFeedbackResponseEntitiesForQuestion(String feedbackQuestionId) {
        return getFeedbackResponseEntitiesForQuestionWithinRange(feedbackQuestionId, -1);
    }

    private List<FeedbackResponse> getFeedbackResponseEntitiesForQuestionWithinRange(String feedbackQuestionId, int range) {
        return load()
                .filter(""feedbackQuestionId ="", feedbackQuestionId)
                .limit(range + 1).list();
    }

    private List<FeedbackResponse> getFeedbackResponseEntitiesForSession(
            String feedbackSessionName, String courseId) {
        return getFeedbackResponseEntitiesForSessionWithinRange(feedbackSessionName, courseId, -1);
    }

    private List<FeedbackResponse> getFeedbackResponseEntitiesForSessionWithinRange(
            String feedbackSessionName, String courseId, int range) {
        return load()
                .filter(""feedbackSessionName ="", feedbackSessionName)
                .filter(""courseId ="", courseId)
                .limit(range + 1).list();
    }

    private Collection<FeedbackResponse> getFeedbackResponseEntitiesForSessionInSection(
            String feedbackSessionName, String courseId, String section) {
        Map<String, FeedbackResponse> feedbackResponses = new HashMap<>();

        for (FeedbackResponse result : getFeedbackResponseEntitiesForSessionFromSection(
                feedbackSessionName, courseId, section)) {
            feedbackResponses.put(result.getId(), result);
        }

        for (FeedbackResponse result : getFeedbackResponseEntitiesForSessionToSection(
                feedbackSessionName, courseId, section)) {
            feedbackResponses.put(result.getId(), result);
        }

        return feedbackResponses.values();
    }

    private List<FeedbackResponse> getFeedbackResponseEntitiesForSessionFromSection(
            String feedbackSessionName, String courseId, String section) {
        return getFeedbackResponseEntitiesForSessionFromSectionWithinRange(feedbackSessionName, courseId, section, -1);
    }

    private List<FeedbackResponse> getFeedbackResponseEntitiesForSessionToSection(
            String feedbackSessionName, String courseId, String section) {
        return getFeedbackResponseEntitiesForSessionToSectionWithinRange(feedbackSessionName, courseId, section, -1);
    }

    private Collection<FeedbackResponse> getFeedbackResponseEntitiesForSessionInSectionWithinRange(
            String feedbackSessionName, String courseId, String section, int range) {
        Map<String, FeedbackResponse> feedbackResponses = new HashMap<>();

        for (FeedbackResponse result : getFeedbackResponseEntitiesForSessionFromSectionWithinRange(
                feedbackSessionName, courseId, section, range)) {
            feedbackResponses.put(result.getId(), result);
        }

        for (FeedbackResponse result : getFeedbackResponseEntitiesForSessionToSectionWithinRange(
                feedbackSessionName, courseId, section, range)) {
            feedbackResponses.put(result.getId(), result);
        }

        return feedbackResponses.values();
    }

    private List<FeedbackResponse> getFeedbackResponseEntitiesForSessionFromSectionWithinRange(
            String feedbackSessionName, String courseId, String section, int range) {
        return load()
                .filter(""feedbackSessionName ="", feedbackSessionName)
                .filter(""courseId ="", courseId)
                .filter(""giverSection ="", section)
                .limit(range + 1).list();
    }

    private List<FeedbackResponse> getFeedbackResponseEntitiesForSessionToSectionWithinRange(
            String feedbackSessionName, String courseId, String section, int range) {
        return load()
                .filter(""feedbackSessionName ="", feedbackSessionName)
                .filter(""courseId ="", courseId)
                .filter(""receiverSection ="", section)
                .limit(range + 1).list();
    }

    private List<FeedbackResponse> getFeedbackResponseEntitiesForReceiverForQuestion(
            String feedbackQuestionId, String receiver) {
        return load()
                .filter(""feedbackQuestionId ="", feedbackQuestionId)
                .filter(""receiver ="", receiver)
                .list();
    }

    private Collection<FeedbackResponse> getFeedbackResponseEntitiesForReceiverForQuestionInSection(
            String feedbackQuestionId, String receiver, String section) {
        Map<String, FeedbackResponse> feedbackResponses = new HashMap<>();

        List<FeedbackResponse> firstQueryResponses = load()
                .filter(""feedbackQuestionId ="", feedbackQuestionId)
                .filter(""receiver ="", receiver)
                .filter(""giverSection ="", section)
                .list();

        for (FeedbackResponse response : firstQueryResponses) {
            feedbackResponses.put(response.getId(), response);
        }

        List<FeedbackResponse> secondQueryResponses = load()
                .filter(""feedbackQuestionId ="", feedbackQuestionId)
                .filter(""receiver ="", receiver)
                .filter(""receiverSection ="", section)
                .list();

        for (FeedbackResponse response : secondQueryResponses) {
            feedbackResponses.put(response.getId(), response);
        }

        return feedbackResponses.values();
    }

    private List<FeedbackResponse> getFeedbackResponseEntitiesFromGiverForQuestion(
            String feedbackQuestionId, String giverEmail) {
        return load()
                .filter(""feedbackQuestionId ="", feedbackQuestionId)
                .filter(""giverEmail ="", giverEmail)
                .list();
    }

    private Collection<FeedbackResponse> getFeedbackResponseEntitiesFromGiverForQuestionInSection(
            String feedbackQuestionId, String giverEmail, String section) {
        Map<String, FeedbackResponse> feedbackResponses = new HashMap<>();

        List<FeedbackResponse> firstQueryResponses = load()
                .filter(""feedbackQuestionId ="", feedbackQuestionId)
                .filter(""giverEmail ="", giverEmail)
                .filter(""giverSection ="", section)
                .list();

        for (FeedbackResponse response : firstQueryResponses) {
            feedbackResponses.put(response.getId(), response);
        }

        List<FeedbackResponse> secondQueryResponses = load()
                .filter(""feedbackQuestionId ="", feedbackQuestionId)
                .filter(""giverEmail ="", giverEmail)
                .filter(""receiverSection ="", section)
                .list();

        for (FeedbackResponse response : secondQueryResponses) {
            feedbackResponses.put(response.getId(), response);
        }

        return feedbackResponses.values();
    }

    private List<FeedbackResponse> getFeedbackResponseEntitiesFromGiverForSessionWithinRange(
            String giverEmail, String feedbackSessionName, String courseId, int range) {
        return load()
                .filter(""giverEmail ="", giverEmail)
                .filter(""feedbackSessionName ="", feedbackSessionName)
                .filter(""courseId ="", courseId)
                .limit(range + 1).list();
    }

    private List<FeedbackResponse> getFeedbackResponseEntitiesForReceiverForCourse(
            String courseId, String receiver) {
        return load()
                .filter(""courseId ="", courseId)
                .filter(""receiver ="", receiver)
                .list();
    }

    private List<FeedbackResponse> getFeedbackResponseEntitiesFromGiverForCourse(
            String courseId, String giverEmail) {
        return load()
                .filter(""courseId ="", courseId)
                .filter(""giverEmail ="", giverEmail)
                .list();
    }

    @Override
    protected LoadType<FeedbackResponse> load() {
        return ofy().load().type(FeedbackResponse.class);
    }

    @Override
    protected FeedbackResponse getEntity(FeedbackResponseAttributes attributes) {
        if (attributes.getId() != null) {
            return getFeedbackResponseEntity(attributes.getId());
        }

        return getFeedbackResponseEntity(attributes.feedbackQuestionId, attributes.giver, attributes.recipient);
    }

    @Override
    protected QueryKeys<FeedbackResponse> getEntityQueryKeys(FeedbackResponseAttributes attributes) {
        String id = attributes.getId();

        Query<FeedbackResponse> query;
        if (id == null) {
            query = load()
                    .filter(""feedbackQuestionId ="", attributes.feedbackQuestionId)
                    .filter(""giverEmail ="", attributes.giver)
                    .filter(""receiver ="", attributes.recipient);
        } else {
            query = load().filterKey(Key.create(FeedbackResponse.class, id));
        }

        return query.keys();
    }

    @Override
    protected FeedbackResponseAttributes makeAttributes(FeedbackResponse entity) {
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, entity);

        return new FeedbackResponseAttributes(entity);
    }
}
"
FeedbackSessionsDb.java,storage-api,"package teammates.storage.api;

import static com.googlecode.objectify.ObjectifyService.ofy;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.Collection;
import java.util.Date;
import java.util.LinkedList;
import java.util.List;

import com.googlecode.objectify.cmd.LoadType;
import com.googlecode.objectify.cmd.QueryKeys;

import teammates.common.datatransfer.FeedbackSessionType;
import teammates.common.datatransfer.attributes.FeedbackSessionAttributes;
import teammates.common.exception.EntityDoesNotExistException;
import teammates.common.exception.InvalidParametersException;
import teammates.common.util.Assumption;
import teammates.common.util.Const;
import teammates.common.util.TimeHelper;
import teammates.storage.entity.FeedbackSession;

/**
 * Handles CRUD operations for feedback sessions.
 *
 * @see FeedbackSession
 * @see FeedbackSessionAttributes
 */
public class FeedbackSessionsDb extends EntitiesDb<FeedbackSession, FeedbackSessionAttributes> {

    public static final String ERROR_UPDATE_NON_EXISTENT = ""Trying to update non-existent Feedback Session : "";

    public void createFeedbackSessions(Collection<FeedbackSessionAttributes> feedbackSessionsToAdd)
            throws InvalidParametersException {
        List<FeedbackSessionAttributes> feedbackSessionsToUpdate = createEntities(feedbackSessionsToAdd);
        for (FeedbackSessionAttributes session : feedbackSessionsToUpdate) {
            try {
                updateFeedbackSession(session);
            } catch (EntityDoesNotExistException e) {
                // This situation is not tested as replicating such a situation is
                // difficult during testing
                Assumption.fail(""Entity found be already existing and not existing simultaneously"");
            }
        }
    }

    public List<FeedbackSessionAttributes> getAllOpenFeedbackSessions(Date start, Date end, double zone) {
        List<FeedbackSessionAttributes> list = new LinkedList<>();

        Calendar startCal = Calendar.getInstance();
        startCal.setTime(start);
        Calendar endCal = Calendar.getInstance();
        endCal.setTime(end);

        Date curStart = TimeHelper.convertToUserTimeZone(startCal, -25).getTime();
        Date curEnd = TimeHelper.convertToUserTimeZone(endCal, 25).getTime();

        List<FeedbackSession> endEntities = load()
                .filter(""endTime >"", curStart)
                .filter(""endTime <="", curEnd)
                .list();

        List<FeedbackSession> startEntities = load()
                .filter(""startTime >="", curStart)
                .filter(""startTime <"", curEnd)
                .list();

        List<FeedbackSession> endTimeEntities = new ArrayList<>(endEntities);
        List<FeedbackSession> startTimeEntities = new ArrayList<>(startEntities);

        endTimeEntities.removeAll(startTimeEntities);
        startTimeEntities.removeAll(endTimeEntities);
        endTimeEntities.addAll(startTimeEntities);

        for (FeedbackSession feedbackSession : endTimeEntities) {
            startCal.setTime(start);
            endCal.setTime(end);
            FeedbackSessionAttributes fs = makeAttributes(feedbackSession);

            Date standardStart = TimeHelper.convertToUserTimeZone(startCal, fs.getTimeZone() - zone).getTime();
            Date standardEnd = TimeHelper.convertToUserTimeZone(endCal, fs.getTimeZone() - zone).getTime();

            boolean isStartTimeWithinRange =
                    TimeHelper.isTimeWithinPeriod(standardStart, standardEnd, fs.getStartTime(), true, false);
            boolean isEndTimeWithinRange =
                    TimeHelper.isTimeWithinPeriod(standardStart, standardEnd, fs.getEndTime(), false, true);

            if (isStartTimeWithinRange || isEndTimeWithinRange) {
                list.add(fs);
            }
        }

        return list;
    }

    /**
     * Preconditions: <br>
     * * All parameters are non-null.
     * @return Null if not found.
     */
    public FeedbackSessionAttributes getFeedbackSession(String courseId, String feedbackSessionName) {
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, feedbackSessionName);
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, courseId);

        return makeAttributesOrNull(getFeedbackSessionEntity(feedbackSessionName, courseId),
                ""Trying to get non-existent Session: "" + feedbackSessionName + ""/"" + courseId);
    }

    /**
     * Returns empty list if none found.
     * @deprecated Not scalable. Created for data migration purposes.
     */
    @Deprecated
    public List<FeedbackSessionAttributes> getAllFeedbackSessions() {
        return makeAttributes(getAllFeedbackSessionEntities());
    }

    /**
     * Preconditions: <br>
     * * All parameters are non-null.
     * @return An empty list if no sessions are found for the given course.
     */
    public List<FeedbackSessionAttributes> getFeedbackSessionsForCourse(String courseId) {
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, courseId);

        return makeAttributes(getFeedbackSessionEntitiesForCourse(courseId));
    }

    /**
     * Returns An empty list if no sessions are found that have unsent open emails.
     */
    public List<FeedbackSessionAttributes> getFeedbackSessionsPossiblyNeedingOpenEmail() {
        return makeAttributes(getFeedbackSessionEntitiesPossiblyNeedingOpenEmail());
    }

    /**
     * Returns An empty list if no sessions are found that have unsent closing emails.
     */
    public List<FeedbackSessionAttributes> getFeedbackSessionsPossiblyNeedingClosingEmail() {
        return makeAttributes(getFeedbackSessionEntitiesPossiblyNeedingClosingEmail());
    }

    /**
     * Returns An empty list if no sessions are found that have unsent closed emails.
     */
    public List<FeedbackSessionAttributes> getFeedbackSessionsPossiblyNeedingClosedEmail() {
        return makeAttributes(getFeedbackSessionEntitiesPossiblyNeedingClosedEmail());
    }

    /**
     * Returns An empty list if no sessions are found that have unsent published emails.
     */
    public List<FeedbackSessionAttributes> getFeedbackSessionsPossiblyNeedingPublishedEmail() {
        return makeAttributes(getFeedbackSessionEntitiesPossiblyNeedingPublishedEmail());
    }

    /**
     * Updates the feedback session identified by {@code newAttributes.feedbackSesionName}
     * and {@code newAttributes.courseId}.
     * For the remaining parameters, the existing value is preserved
     *   if the parameter is null (due to 'keep existing' policy).<br>
     * Preconditions: <br>
     * * {@code newAttributes.feedbackSesionName} and {@code newAttributes.courseId}
     *  are non-null and correspond to an existing feedback session. <br>
     */
    public void updateFeedbackSession(FeedbackSessionAttributes newAttributes)
        throws InvalidParametersException, EntityDoesNotExistException {
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, newAttributes);

        newAttributes.sanitizeForSaving();

        if (!newAttributes.isValid()) {
            throw new InvalidParametersException(newAttributes.getInvalidityInfo());
        }

        FeedbackSession fs = getEntity(newAttributes);

        if (fs == null) {
            throw new EntityDoesNotExistException(
                    ERROR_UPDATE_NON_EXISTENT + newAttributes.toString());
        }
        fs.setInstructions(newAttributes.getInstructions());
        fs.setStartTime(newAttributes.getStartTime());
        fs.setEndTime(newAttributes.getEndTime());
        fs.setSessionVisibleFromTime(newAttributes.getSessionVisibleFromTime());
        fs.setResultsVisibleFromTime(newAttributes.getResultsVisibleFromTime());
        fs.setTimeZone(newAttributes.getTimeZone());
        fs.setGracePeriod(newAttributes.getGracePeriod());
        fs.setFeedbackSessionType(newAttributes.getFeedbackSessionType());
        fs.setSentOpenEmail(newAttributes.isSentOpenEmail());
        fs.setSentClosingEmail(newAttributes.isSentClosingEmail());
        fs.setSentClosedEmail(newAttributes.isSentClosedEmail());
        fs.setSentPublishedEmail(newAttributes.isSentPublishedEmail());
        fs.setIsOpeningEmailEnabled(newAttributes.isOpeningEmailEnabled());
        fs.setSendClosingEmail(newAttributes.isClosingEmailEnabled());
        fs.setSendPublishedEmail(newAttributes.isPublishedEmailEnabled());

        saveEntity(fs, newAttributes);
    }

    public void addInstructorRespondent(String email, FeedbackSessionAttributes feedbackSession)
            throws InvalidParametersException, EntityDoesNotExistException {
        List<String> emails = new ArrayList<>();
        emails.add(email);
        addInstructorRespondents(emails, feedbackSession);
    }

    public void addInstructorRespondents(List<String> emails, FeedbackSessionAttributes feedbackSession)
            throws InvalidParametersException, EntityDoesNotExistException {
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, emails);
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, feedbackSession);

        feedbackSession.sanitizeForSaving();

        if (!feedbackSession.isValid()) {
            throw new InvalidParametersException(feedbackSession.getInvalidityInfo());
        }

        FeedbackSession fs = getEntity(feedbackSession);
        if (fs == null) {
            throw new EntityDoesNotExistException(ERROR_UPDATE_NON_EXISTENT + feedbackSession.toString());
        }

        fs.getRespondingInstructorList().addAll(emails);

        saveEntity(fs, feedbackSession);
    }

    public void updateInstructorRespondent(String oldEmail, String newEmail, FeedbackSessionAttributes feedbackSession)
            throws InvalidParametersException, EntityDoesNotExistException {
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, oldEmail);
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, newEmail);
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, feedbackSession);

        feedbackSession.sanitizeForSaving();

        if (!feedbackSession.isValid()) {
            throw new InvalidParametersException(feedbackSession.getInvalidityInfo());
        }

        FeedbackSession fs = getEntity(feedbackSession);
        if (fs == null) {
            throw new EntityDoesNotExistException(ERROR_UPDATE_NON_EXISTENT + feedbackSession.toString());
        }

        if (fs.getRespondingInstructorList().contains(oldEmail)) {
            fs.getRespondingInstructorList().remove(oldEmail);
            fs.getRespondingInstructorList().add(newEmail);
        }

        saveEntity(fs, feedbackSession);
    }

    public void clearInstructorRespondents(FeedbackSessionAttributes feedbackSession)
            throws InvalidParametersException, EntityDoesNotExistException {
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, feedbackSession);

        feedbackSession.sanitizeForSaving();

        if (!feedbackSession.isValid()) {
            throw new InvalidParametersException(feedbackSession.getInvalidityInfo());
        }

        FeedbackSession fs = getEntity(feedbackSession);
        if (fs == null) {
            throw new EntityDoesNotExistException(ERROR_UPDATE_NON_EXISTENT + feedbackSession.toString());
        }

        fs.getRespondingInstructorList().clear();

        saveEntity(fs, feedbackSession);
    }

    public void addStudentRespondent(String email, FeedbackSessionAttributes feedbackSession)
            throws EntityDoesNotExistException, InvalidParametersException {
        List<String> emails = new ArrayList<>();
        emails.add(email);
        addStudentRespondents(emails, feedbackSession);
    }

    public void deleteInstructorRespondent(String email, FeedbackSessionAttributes feedbackSession)
            throws InvalidParametersException, EntityDoesNotExistException {
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, email);
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, feedbackSession);

        feedbackSession.sanitizeForSaving();

        if (!feedbackSession.isValid()) {
            throw new InvalidParametersException(feedbackSession.getInvalidityInfo());
        }

        FeedbackSession fs = getEntity(feedbackSession);
        if (fs == null) {
            throw new EntityDoesNotExistException(ERROR_UPDATE_NON_EXISTENT + feedbackSession.toString());
        }

        fs.getRespondingInstructorList().remove(email);

        saveEntity(fs, feedbackSession);
    }

    public void addStudentRespondents(List<String> emails, FeedbackSessionAttributes feedbackSession)
            throws InvalidParametersException, EntityDoesNotExistException {
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, emails);
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, feedbackSession);

        feedbackSession.sanitizeForSaving();

        if (!feedbackSession.isValid()) {
            throw new InvalidParametersException(feedbackSession.getInvalidityInfo());
        }

        FeedbackSession fs = getEntity(feedbackSession);
        if (fs == null) {
            throw new EntityDoesNotExistException(ERROR_UPDATE_NON_EXISTENT + feedbackSession.toString());
        }

        fs.getRespondingStudentList().addAll(emails);

        saveEntity(fs, feedbackSession);
    }

    public void updateStudentRespondent(String oldEmail, String newEmail, FeedbackSessionAttributes feedbackSession)
            throws InvalidParametersException, EntityDoesNotExistException {
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, oldEmail);
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, newEmail);
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, feedbackSession);

        feedbackSession.sanitizeForSaving();

        if (!feedbackSession.isValid()) {
            throw new InvalidParametersException(feedbackSession.getInvalidityInfo());
        }

        FeedbackSession fs = getEntity(feedbackSession);
        if (fs == null) {
            throw new EntityDoesNotExistException(ERROR_UPDATE_NON_EXISTENT + feedbackSession.toString());
        }

        if (fs.getRespondingStudentList().contains(oldEmail)) {
            fs.getRespondingStudentList().remove(oldEmail);
            fs.getRespondingStudentList().add(newEmail);
        }

        saveEntity(fs, feedbackSession);
    }

    public void clearStudentRespondents(FeedbackSessionAttributes feedbackSession)
            throws InvalidParametersException, EntityDoesNotExistException {
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, feedbackSession);

        feedbackSession.sanitizeForSaving();

        if (!feedbackSession.isValid()) {
            throw new InvalidParametersException(feedbackSession.getInvalidityInfo());
        }

        FeedbackSession fs = getEntity(feedbackSession);
        if (fs == null) {
            throw new EntityDoesNotExistException(ERROR_UPDATE_NON_EXISTENT + feedbackSession.toString());
        }

        fs.getRespondingStudentList().clear();

        saveEntity(fs, feedbackSession);
    }

    public void deleteStudentRespondent(String email, FeedbackSessionAttributes feedbackSession)
            throws EntityDoesNotExistException, InvalidParametersException {
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, email);
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, feedbackSession);

        feedbackSession.sanitizeForSaving();

        if (!feedbackSession.isValid()) {
            throw new InvalidParametersException(feedbackSession.getInvalidityInfo());
        }

        FeedbackSession fs = getEntity(feedbackSession);
        if (fs == null) {
            throw new EntityDoesNotExistException(
                    ERROR_UPDATE_NON_EXISTENT + feedbackSession.toString());
        }

        fs.getRespondingStudentList().remove(email);

        saveEntity(fs, feedbackSession);
    }

    public void deleteFeedbackSessionsForCourse(String courseId) {
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, courseId);

        deleteFeedbackSessionsForCourses(Arrays.asList(courseId));
    }

    public void deleteFeedbackSessionsForCourses(List<String> courseIds) {
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, courseIds);

        ofy().delete().keys(load().filter(""courseId in"", courseIds).keys()).now();
    }

    private List<FeedbackSession> getAllFeedbackSessionEntities() {
        return load().list();
    }

    private List<FeedbackSession> getFeedbackSessionEntitiesForCourse(String courseId) {
        return load().filter(""courseId ="", courseId).list();
    }

    private List<FeedbackSession> getFeedbackSessionEntitiesPossiblyNeedingOpenEmail() {
        return load()
                .filter(""startTime >"", TimeHelper.getDateOffsetToCurrentTime(-2))
                .filter(""sentOpenEmail ="", false)
                .list();
    }

    private List<FeedbackSession> getFeedbackSessionEntitiesPossiblyNeedingClosingEmail() {
        return load()
                .filter(""endTime >"", TimeHelper.getDateOffsetToCurrentTime(-2))
                .filter(""sentClosingEmail ="", false)
                .filter(""isClosingEmailEnabled ="", true)
                .list();
    }

    private List<FeedbackSession> getFeedbackSessionEntitiesPossiblyNeedingClosedEmail() {
        return load()
                .filter(""endTime >"", TimeHelper.getDateOffsetToCurrentTime(-2))
                .filter(""sentClosedEmail ="", false)
                .filter(""isClosingEmailEnabled ="", true)
                .list();
    }

    private List<FeedbackSession> getFeedbackSessionEntitiesPossiblyNeedingPublishedEmail() {
        return load()
                .filter(""sentPublishedEmail ="", false)
                .filter(""isPublishedEmailEnabled ="", true)
                .filter(""feedbackSessionType !="", FeedbackSessionType.PRIVATE)
                .list();
    }

    private FeedbackSession getFeedbackSessionEntity(String feedbackSessionName, String courseId) {
        return load()
                .filter(""feedbackSessionName ="", feedbackSessionName)
                .filter(""courseId ="", courseId)
                .first().now();
    }

    @Override
    protected LoadType<FeedbackSession> load() {
        return ofy().load().type(FeedbackSession.class);
    }

    @Override
    protected FeedbackSession getEntity(FeedbackSessionAttributes attributes) {
        return getFeedbackSessionEntity(attributes.getFeedbackSessionName(), attributes.getCourseId());
    }

    @Override
    protected QueryKeys<FeedbackSession> getEntityQueryKeys(FeedbackSessionAttributes attributes) {
        return load()
                .filter(""feedbackSessionName ="", attributes.getFeedbackSessionName())
                .filter(""courseId ="", attributes.getCourseId()).keys();
    }

    @Override
    protected FeedbackSessionAttributes makeAttributes(FeedbackSession entity) {
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, entity);

        return new FeedbackSessionAttributes(entity);
    }
}
"
InstructorsDb.java,storage-api,"package teammates.storage.api;

import static com.googlecode.objectify.ObjectifyService.ofy;

import java.util.ArrayList;
import java.util.Collection;
import java.util.List;

import com.google.appengine.api.search.Results;
import com.google.appengine.api.search.ScoredDocument;
import com.googlecode.objectify.cmd.LoadType;
import com.googlecode.objectify.cmd.QueryKeys;

import teammates.common.datatransfer.InstructorSearchResultBundle;
import teammates.common.datatransfer.attributes.InstructorAttributes;
import teammates.common.exception.EntityAlreadyExistsException;
import teammates.common.exception.EntityDoesNotExistException;
import teammates.common.exception.InvalidParametersException;
import teammates.common.util.Assumption;
import teammates.common.util.Const;
import teammates.common.util.StringHelper;
import teammates.common.util.ThreadHelper;
import teammates.storage.entity.Instructor;
import teammates.storage.search.InstructorSearchDocument;
import teammates.storage.search.InstructorSearchQuery;
import teammates.storage.search.SearchDocument;

/**
 * Handles CRUD operations for instructors.
 *
 * @see Instructor
 * @see InstructorAttributes
 */
public class InstructorsDb extends EntitiesDb<Instructor, InstructorAttributes> {

    /* =========================================================================
     * Methods related to Google Search API
     * =========================================================================
     */

    public void putDocument(InstructorAttributes instructorParam) {
        InstructorAttributes instructor = instructorParam;
        if (instructor.key == null) {
            instructor = this.getInstructorForEmail(instructor.courseId, instructor.email);
        }
        // defensive coding for legacy data
        if (instructor.key != null) {
            putDocument(Const.SearchIndex.INSTRUCTOR, new InstructorSearchDocument(instructor));
        }
    }

    /**
     * Batch creates or updates documents for the given instructors.
     */
    public void putDocuments(List<InstructorAttributes> instructorParams) {
        List<SearchDocument> instructorDocuments = new ArrayList<>();
        for (InstructorAttributes instructor : instructorParams) {
            if (instructor.key == null) {
                instructor = this.getInstructorForEmail(instructor.courseId, instructor.email);
            }
            // defensive coding for legacy data
            if (instructor.key != null) {
                instructorDocuments.add(new InstructorSearchDocument(instructor));
            }
        }
        putDocuments(Const.SearchIndex.INSTRUCTOR, instructorDocuments);
    }

    public void deleteDocument(InstructorAttributes instructorToDelete) {
        if (instructorToDelete.key == null) {
            InstructorAttributes instructor =
                    getInstructorForEmail(instructorToDelete.courseId, instructorToDelete.email);

            // handle legacy data which do not have key attribute (key == null)
            if (instructor.key != null) {
                deleteDocument(Const.SearchIndex.INSTRUCTOR, StringHelper.encrypt(instructor.key));
            }
        } else {
            deleteDocument(Const.SearchIndex.INSTRUCTOR, StringHelper.encrypt(instructorToDelete.key));
        }
    }

    /**
     * This method should be used by admin only since the searching does not restrict the
     * visibility according to the logged-in user's google ID. This is used by admin to
     * search instructors in the whole system.
     * @return null if no result found
     */

    public InstructorSearchResultBundle searchInstructorsInWholeSystem(String queryString) {

        if (queryString.trim().isEmpty()) {
            return new InstructorSearchResultBundle();
        }

        Results<ScoredDocument> results = searchDocuments(Const.SearchIndex.INSTRUCTOR,
                                                          new InstructorSearchQuery(queryString));

        return InstructorSearchDocument.fromResults(results);
    }

    /* =========================================================================
     * =========================================================================
     */

    public void createInstructors(Collection<InstructorAttributes> instructorsToAdd) throws InvalidParametersException {

        List<InstructorAttributes> instructorsToUpdate = createEntities(instructorsToAdd);

        for (InstructorAttributes instructor : instructorsToAdd) {
            if (!instructorsToUpdate.contains(instructor)) {
                putDocument(instructor);
            }
        }

        for (InstructorAttributes instructor : instructorsToUpdate) {
            try {
                updateInstructorByEmail(instructor);
            } catch (EntityDoesNotExistException e) {
                // This situation is not tested as replicating such a situation is
                // difficult during testing
                Assumption.fail(""Entity found be already existing and not existing simultaneously"");
            }
            putDocument(instructor);
        }
    }

    public InstructorAttributes createInstructor(InstructorAttributes instructorToAdd)
            throws InvalidParametersException, EntityAlreadyExistsException {
        Instructor instructor = createEntity(instructorToAdd);
        if (instructor == null) {
            throw new InvalidParametersException(""Created instructor is null."");
        }
        InstructorAttributes createdInstructor = makeAttributes(instructor);
        putDocument(createdInstructor);
        return createdInstructor;
    }

    /**
     * Returns null if no matching objects.
     */
    public InstructorAttributes getInstructorForEmail(String courseId, String email) {
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, email);
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, courseId);

        return makeAttributesOrNull(getInstructorEntityForEmail(courseId, email),
                ""Trying to get non-existent Instructor: "" + courseId + ""/"" + email);
    }

    /**
     * Returns null if no matching objects.
     */
    public InstructorAttributes getInstructorForGoogleId(String courseId, String googleId) {
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, googleId);
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, courseId);

        return makeAttributesOrNull(getInstructorEntityForGoogleId(courseId, googleId),
                ""Trying to get non-existent Instructor: "" + googleId);
    }

    /**
     * Returns null if no matching instructor.
     */
    public InstructorAttributes getInstructorForRegistrationKey(String encryptedKey) {
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, encryptedKey);

        String decryptedKey;
        try {
            decryptedKey = StringHelper.decrypt(encryptedKey.trim());
        } catch (InvalidParametersException e) {
            return null;
        }

        return makeAttributesOrNull(getInstructorEntityForRegistrationKey(decryptedKey));
    }

    /**
     * Preconditions: <br>
     *  * All parameters are non-null.
     * @return empty list if no matching objects.
     */
    public List<InstructorAttributes> getInstructorsForEmail(String email) {
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, email);

        return makeAttributes(getInstructorEntitiesForEmail(email));
    }

    /**
     * Preconditions: <br>
     *  * All parameters are non-null.
     *
     * @return empty list if no matching objects.
     */
    public List<InstructorAttributes> getInstructorsForGoogleId(String googleId, boolean omitArchived) {
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, googleId);

        return makeAttributes(getInstructorEntitiesForGoogleId(googleId, omitArchived));
    }

    /**
     * Preconditions: <br>
     *  * All parameters are non-null.
     * @return empty list if no matching objects.
     */
    public List<InstructorAttributes> getInstructorsForCourse(String courseId) {
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, courseId);

        return makeAttributes(getInstructorEntitiesForCourse(courseId));
    }

    /**
     * Not scalable. Don't use unless for admin features.
     * @return {@code InstructorAttributes} objects for all instructor roles in the system
     */
    @Deprecated
    public List<InstructorAttributes> getAllInstructors() {
        return makeAttributes(getInstructorEntities());
    }

    /**
     * Updates the instructor. Cannot modify Course ID or google id.
     */
    public void updateInstructorByGoogleId(InstructorAttributes instructorAttributesToUpdate)
            throws InvalidParametersException, EntityDoesNotExistException {
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, instructorAttributesToUpdate);

        if (!instructorAttributesToUpdate.isValid()) {
            throw new InvalidParametersException(instructorAttributesToUpdate.getInvalidityInfo());
        }
        instructorAttributesToUpdate.sanitizeForSaving();

        Instructor instructorToUpdate = getInstructorEntityForGoogleId(
                instructorAttributesToUpdate.courseId,
                instructorAttributesToUpdate.googleId);

        if (instructorToUpdate == null) {
            throw new EntityDoesNotExistException(ERROR_UPDATE_NON_EXISTENT_ACCOUNT + instructorAttributesToUpdate.googleId
                        + ThreadHelper.getCurrentThreadStack());
        }

        instructorToUpdate.setName(instructorAttributesToUpdate.name);
        instructorToUpdate.setEmail(instructorAttributesToUpdate.email);
        instructorToUpdate.setIsArchived(instructorAttributesToUpdate.isArchived);
        instructorToUpdate.setRole(instructorAttributesToUpdate.role);
        instructorToUpdate.setIsDisplayedToStudents(instructorAttributesToUpdate.isDisplayedToStudents);
        instructorToUpdate.setDisplayedName(instructorAttributesToUpdate.displayedName);
        instructorToUpdate.setInstructorPrivilegeAsText(instructorAttributesToUpdate.getTextFromInstructorPrivileges());

        //TODO: make courseId+email the non-modifiable values

        putDocument(makeAttributes(instructorToUpdate));
        saveEntity(instructorToUpdate, instructorAttributesToUpdate);
    }

    /**
     * Updates the instructor. Cannot modify Course ID or email.
     */
    public void updateInstructorByEmail(InstructorAttributes instructorAttributesToUpdate)
            throws InvalidParametersException, EntityDoesNotExistException {
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, instructorAttributesToUpdate);

        if (!instructorAttributesToUpdate.isValid()) {
            throw new InvalidParametersException(instructorAttributesToUpdate.getInvalidityInfo());
        }
        instructorAttributesToUpdate.sanitizeForSaving();

        Instructor instructorToUpdate = getInstructorEntityForEmail(
                instructorAttributesToUpdate.courseId,
                instructorAttributesToUpdate.email);

        if (instructorToUpdate == null) {
            throw new EntityDoesNotExistException(ERROR_UPDATE_NON_EXISTENT_ACCOUNT + instructorAttributesToUpdate.email
                        + ThreadHelper.getCurrentThreadStack());
        }

        instructorToUpdate.setGoogleId(instructorAttributesToUpdate.googleId);
        instructorToUpdate.setName(instructorAttributesToUpdate.name);
        instructorToUpdate.setIsArchived(instructorAttributesToUpdate.isArchived);
        instructorToUpdate.setRole(instructorAttributesToUpdate.role);
        instructorToUpdate.setIsDisplayedToStudents(instructorAttributesToUpdate.isDisplayedToStudents);
        instructorToUpdate.setDisplayedName(instructorAttributesToUpdate.displayedName);
        instructorToUpdate.setInstructorPrivilegeAsText(instructorAttributesToUpdate.getTextFromInstructorPrivileges());

        //TODO: make courseId+email the non-modifiable values
        putDocument(makeAttributes(instructorToUpdate));
        saveEntity(instructorToUpdate, instructorAttributesToUpdate);
    }

    /**
     * Deletes the instructor specified by courseId and email.
     */
    public void deleteInstructor(String courseId, String email) {
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, email);
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, courseId);

        Instructor instructorToDelete = getInstructorEntityForEmail(courseId, email);

        if (instructorToDelete == null) {
            return;
        }

        InstructorAttributes instructorToDeleteAttributes = makeAttributes(instructorToDelete);

        deleteDocument(instructorToDeleteAttributes);
        deleteEntityDirect(instructorToDelete, instructorToDeleteAttributes);

        Instructor instructorCheck = getInstructorEntityForEmail(courseId, email);
        if (instructorCheck != null) {
            putDocument(makeAttributes(instructorCheck));
        }

        //TODO: reuse the method in the parent class instead
    }

    public void deleteInstructorsForCourses(List<String> courseIds) {
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, courseIds);

        deleteInstructors(getInstructorEntitiesForCourses(courseIds));
    }

    /**
     * Deletes all instructors with the given googleId.
     */
    public void deleteInstructorsForGoogleId(String googleId) {
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, googleId);

        deleteInstructors(getInstructorEntitiesForGoogleId(googleId));
    }

    /**
     * Deletes all instructors for the course specified by courseId.
     */
    public void deleteInstructorsForCourse(String courseId) {
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, courseId);

        deleteInstructors(getInstructorEntitiesForCourse(courseId));
    }

    private void deleteInstructors(List<Instructor> instructors) {
        for (Instructor instructor : instructors) {
            deleteDocument(makeAttributes(instructor));
        }
        ofy().delete().entities(instructors).now();
    }

    private Instructor getInstructorEntityForGoogleId(String courseId, String googleId) {
        return load()
                .filter(""courseId ="", courseId)
                .filter(""googleId ="", googleId)
                .first().now();
    }

    private Instructor getInstructorEntityForEmail(String courseId, String email) {
        return load()
                .filter(""courseId ="", courseId)
                .filter(""email ="", email)
                .first().now();
    }

    private List<Instructor> getInstructorEntitiesForCourses(List<String> courseIds) {
        return load().filter(""courseId in"", courseIds).list();
    }

    private Instructor getInstructorEntityForRegistrationKey(String key) {
        return load().filter(""registrationKey ="", key).first().now();
    }

    private List<Instructor> getInstructorEntitiesForGoogleId(String googleId) {
        return load().filter(""googleId ="", googleId).list();
    }

    /**
     * Omits instructors with isArchived == omitArchived.
     * This means that the corresponding course is archived by the instructor.
     */
    private List<Instructor> getInstructorEntitiesForGoogleId(String googleId, boolean omitArchived) {
        if (omitArchived) {
            return load()
                    .filter(""googleId ="", googleId)
                    .filter(""isArchived !="", true)
                    .list();
        }
        return getInstructorEntitiesForGoogleId(googleId);
    }

    private List<Instructor> getInstructorEntitiesForEmail(String email) {
        return load().filter(""email ="", email).list();
    }

    private List<Instructor> getInstructorEntitiesForCourse(String courseId) {
        return load().filter(""courseId ="", courseId).list();
    }

    private List<Instructor> getInstructorEntities() {
        return load().list();
    }

    @Override
    protected LoadType<Instructor> load() {
        return ofy().load().type(Instructor.class);
    }

    @Override
    protected Instructor getEntity(InstructorAttributes instructorToGet) {
        return getInstructorEntityForEmail(instructorToGet.courseId, instructorToGet.email);
    }

    @Override
    protected QueryKeys<Instructor> getEntityQueryKeys(InstructorAttributes attributes) {
        return load()
                .filter(""courseId ="", attributes.courseId)
                .filter(""email ="", attributes.email)
                .keys();
    }

    @Override
    protected InstructorAttributes makeAttributes(Instructor entity) {
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, entity);

        return InstructorAttributes.valueOf(entity);
    }

}
"
OfyHelper.java,storage-api,"package teammates.storage.api;

import javax.servlet.ServletContextEvent;
import javax.servlet.ServletContextListener;

import com.googlecode.objectify.ObjectifyService;

import teammates.storage.entity.Account;
import teammates.storage.entity.AdminEmail;
import teammates.storage.entity.Course;
import teammates.storage.entity.CourseStudent;
import teammates.storage.entity.FeedbackQuestion;
import teammates.storage.entity.FeedbackResponse;
import teammates.storage.entity.FeedbackResponseComment;
import teammates.storage.entity.FeedbackSession;
import teammates.storage.entity.Instructor;
import teammates.storage.entity.StudentProfile;

/**
 * Setup in web.xml to register Objectify at application startup.
 **/
public class OfyHelper implements ServletContextListener {

    /**
     * Register entity classes in Objectify service.
     */
    public static void registerEntityClasses() {
        ObjectifyService.register(Account.class);
        ObjectifyService.register(AdminEmail.class);
        ObjectifyService.register(Course.class);
        ObjectifyService.register(CourseStudent.class);
        ObjectifyService.register(FeedbackQuestion.class);
        ObjectifyService.register(FeedbackResponse.class);
        ObjectifyService.register(FeedbackResponseComment.class);
        ObjectifyService.register(FeedbackSession.class);
        ObjectifyService.register(Instructor.class);
        ObjectifyService.register(StudentProfile.class);
    }

    @Override
    public void contextInitialized(ServletContextEvent event) {
        // Invoked by GAE at application startup.
        registerEntityClasses();
    }

    @Override
    public void contextDestroyed(ServletContextEvent event) {
        // GAE does not currently invoke this method.
    }
}
"
package-info.java,storage-api,"/**
 * Provides the API of the component to be accessed by the logic component.
 */
package teammates.storage.api;
"
ProfilesDb.java,storage-api,"package teammates.storage.api;

import static com.googlecode.objectify.ObjectifyService.ofy;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Date;
import java.util.List;

import com.google.appengine.api.blobstore.BlobKey;
import com.google.appengine.api.datastore.Text;
import com.googlecode.objectify.Key;
import com.googlecode.objectify.cmd.LoadType;
import com.googlecode.objectify.cmd.QueryKeys;

import teammates.common.datatransfer.attributes.StudentProfileAttributes;
import teammates.common.exception.EntityDoesNotExistException;
import teammates.common.exception.InvalidParametersException;
import teammates.common.util.Assumption;
import teammates.common.util.Const;
import teammates.common.util.Logger;
import teammates.common.util.ThreadHelper;
import teammates.storage.entity.Account;
import teammates.storage.entity.StudentProfile;

/**
 * Handles CRUD operations for student profiles.
 *
 * @see StudentProfile
 * @see StudentProfileAttributes
 */
public class ProfilesDb extends EntitiesDb<StudentProfile, StudentProfileAttributes> {

    private static final Logger log = Logger.getLogger();

    /**
     * Gets the datatransfer (*Attributes) version of the profile
     * corresponding to the googleId given. Returns null if the
     * profile was not found
     */
    public StudentProfileAttributes getStudentProfile(String accountGoogleId) {
        return makeAttributesOrNull(getStudentProfileEntityFromDb(accountGoogleId));
    }

    /**
     * Updates the entire profile based on the given new profile attributes.
     * Assumes that the googleId remains the same and so updates the profile
     * with the given googleId.
     */
    // TODO: update the profile with whatever given values are valid and ignore those that are not valid.
    public void updateStudentProfile(StudentProfileAttributes newSpa)
            throws InvalidParametersException, EntityDoesNotExistException {
        validateNewProfile(newSpa);

        StudentProfile profileToUpdate = getCurrentProfileFromDb(newSpa.googleId);
        if (hasNoNewChangesToProfile(newSpa, profileToUpdate)) {
            return;
        }

        updateProfileWithNewValues(newSpa, profileToUpdate);
    }

    private void validateNewProfile(StudentProfileAttributes newSpa) throws InvalidParametersException {
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, newSpa);

        if (!newSpa.isValid()) {
            throw new InvalidParametersException(newSpa.getInvalidityInfo());
        }
    }

    private boolean hasNoNewChangesToProfile(StudentProfileAttributes newSpa, StudentProfile profileToUpdate) {
        StudentProfileAttributes newSpaCopy = newSpa.getCopy();
        StudentProfileAttributes existingProfile = StudentProfileAttributes.valueOf(profileToUpdate);

        newSpaCopy.modifiedDate = existingProfile.modifiedDate;
        return existingProfile.toString().equals(newSpaCopy.toString());
    }

    private void updateProfileWithNewValues(StudentProfileAttributes newSpa, StudentProfile profileToUpdate) {
        newSpa.sanitizeForSaving();

        profileToUpdate.setShortName(newSpa.shortName);
        profileToUpdate.setEmail(newSpa.email);
        profileToUpdate.setInstitute(newSpa.institute);
        profileToUpdate.setNationality(newSpa.nationality);
        profileToUpdate.setGender(newSpa.gender);
        profileToUpdate.setMoreInfo(new Text(newSpa.moreInfo));
        profileToUpdate.setModifiedDate(new Date());

        boolean hasNewNonEmptyPictureKey = !newSpa.pictureKey.isEmpty()
                && !newSpa.pictureKey.equals(profileToUpdate.getPictureKey().getKeyString());
        if (hasNewNonEmptyPictureKey) {
            profileToUpdate.setPictureKey(new BlobKey(newSpa.pictureKey));
        }

        saveEntity(profileToUpdate);
    }

    /**
     * Updates the pictureKey of the profile with given GoogleId.
     * Deletes existing picture if key is different and updates
     * modifiedDate
     */
    public void updateStudentProfilePicture(String googleId, String newPictureKey) throws EntityDoesNotExistException {
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, googleId);
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, newPictureKey);
        Assumption.assertNotEmpty(""GoogleId is empty"", googleId);
        Assumption.assertNotEmpty(""PictureKey is empty"", newPictureKey);

        StudentProfile profileToUpdate = getCurrentProfileFromDb(googleId);

        boolean hasNewNonEmptyPictureKey = !newPictureKey.isEmpty()
                && !newPictureKey.equals(profileToUpdate.getPictureKey().getKeyString());
        if (hasNewNonEmptyPictureKey) {
            profileToUpdate.setPictureKey(new BlobKey(newPictureKey));
            profileToUpdate.setModifiedDate(new Date());
        }

        saveEntity(profileToUpdate);
    }

    @Override
    public void deleteEntity(StudentProfileAttributes entityToDelete) {
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, entityToDelete);

        Key<StudentProfile> keyToDelete = getEntityQueryKeys(entityToDelete).first().now();
        if (keyToDelete == null) {
            ofy().delete().keys(getEntityQueryKeysForLegacyData(entityToDelete)).now();
        } else {
            ofy().delete().key(keyToDelete).now();
        }

        log.info(entityToDelete.getBackupIdentifier());
    }

    @Override
    public void deleteEntities(Collection<StudentProfileAttributes> entitiesToDelete) {
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, entitiesToDelete);

        ArrayList<Key<StudentProfile>> keysToDelete = new ArrayList<>();
        for (StudentProfileAttributes entityToDelete : entitiesToDelete) {
            Key<StudentProfile> keyToDelete = getEntityQueryKeys(entityToDelete).first().now();
            if (keyToDelete == null) {
                keyToDelete = getEntityQueryKeysForLegacyData(entityToDelete).first().now();
            }
            if (keyToDelete == null) {
                continue;
            }
            keysToDelete.add(keyToDelete);
            log.info(entityToDelete.getBackupIdentifier());
        }

        ofy().delete().keys(keysToDelete).now();
    }

    /**
     * Deletes the profile picture from GCS and
     * updates the profile entity:
     *     empties the key and updates the modifiedDate.
     */
    public void deleteStudentProfilePicture(String googleId) throws EntityDoesNotExistException {
        StudentProfile sp = getCurrentProfileFromDb(googleId);

        if (!sp.getPictureKey().equals(new BlobKey(""""))) {
            deletePicture(sp.getPictureKey());
            sp.setPictureKey(new BlobKey(""""));
            sp.setModifiedDate(new Date());
        }

        saveEntity(sp);
    }

    /**
     * This method is not scalable. Not to be used unless for admin features.
     *
     * @return the list of all student profiles in the database.
     */
    @Deprecated
    public List<StudentProfileAttributes> getAllStudentProfiles() {
        return makeAttributes(getStudentProfileEntities());
    }

    //-------------------------------------------------------------------------------------------------------
    //-------------------------------------- Helper Functions -----------------------------------------------
    //-------------------------------------------------------------------------------------------------------

    private StudentProfile getCurrentProfileFromDb(String googleId) throws EntityDoesNotExistException {
        StudentProfile profileToUpdate = getStudentProfileEntityFromDb(googleId);

        if (profileToUpdate == null) {
            throw new EntityDoesNotExistException(ERROR_UPDATE_NON_EXISTENT_STUDENT_PROFILE + googleId
                    + ThreadHelper.getCurrentThreadStack());
        }

        return profileToUpdate;
    }

    /**
     * Checks if an account entity exists for the given googleId and creates
     * a profile entity for this account. This is only used for porting
     * legacy account entities on the fly.
     */
    // TODO: remove this function once legacy data have been ported over
    private StudentProfile getStudentProfileEntityForLegacyData(String googleId) {
        Account account = ofy().load().type(Account.class).id(googleId).now();

        if (account == null) {
            return null;
        }

        StudentProfile profile = new StudentProfile(account.getGoogleId());
        account.setStudentProfile(profile);

        return profile;
    }

    /**
     * Gets the profile entity associated with given googleId.
     * If the profile does not exist, it tries to get the
     * profile from the function
     * 'getStudentProfileEntityForLegacyData'.
     */
    // TODO: update this function once legacy data have been ported over
    private StudentProfile getStudentProfileEntityFromDb(String googleId) {
        Key<Account> parentKey = Key.create(Account.class, googleId);
        Key<StudentProfile> childKey = Key.create(parentKey, StudentProfile.class, googleId);
        StudentProfile profile = ofy().load().key(childKey).now();

        if (profile == null) {
            return getStudentProfileEntityForLegacyData(googleId);
        }

        return profile;
    }

    @Override
    protected LoadType<StudentProfile> load() {
        return ofy().load().type(StudentProfile.class);
    }

    @Override
    protected StudentProfile getEntity(StudentProfileAttributes attributes) {
        // this method is never used and is here only for future expansion and completeness
        return getStudentProfileEntityFromDb(attributes.googleId);
    }

    @Override
    protected QueryKeys<StudentProfile> getEntityQueryKeys(StudentProfileAttributes attributes) {
        Key<Account> parentKey = Key.create(Account.class, attributes.googleId);
        Key<StudentProfile> childKey = Key.create(parentKey, StudentProfile.class, attributes.googleId);
        return load().filterKey(childKey).keys();
    }

    private QueryKeys<StudentProfile> getEntityQueryKeysForLegacyData(StudentProfileAttributes attributes) {
        Key<StudentProfile> legacyKey = Key.create(StudentProfile.class, attributes.googleId);
        return load().filterKey(legacyKey).keys();
    }

    @Override
    public boolean hasEntity(StudentProfileAttributes attributes) {
        if (getEntityQueryKeys(attributes).first().now() == null) {
            return getEntityQueryKeysForLegacyData(attributes).first().now() != null;
        }
        return true;
    }

    /**
     * Retrieves all student profile entities. This function is not scalable.
     */
    @Deprecated
    private List<StudentProfile> getStudentProfileEntities() {
        return load().list();
    }

    @Override
    protected StudentProfileAttributes makeAttributes(StudentProfile entity) {
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, entity);

        return StudentProfileAttributes.valueOf(entity);
    }
}
"
StudentsDb.java,storage-api,"package teammates.storage.api;

import static com.googlecode.objectify.ObjectifyService.ofy;

import java.util.ArrayList;
import java.util.Collection;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

import com.google.appengine.api.search.Results;
import com.google.appengine.api.search.ScoredDocument;
import com.googlecode.objectify.cmd.LoadType;
import com.googlecode.objectify.cmd.Query;
import com.googlecode.objectify.cmd.QueryKeys;

import teammates.common.datatransfer.StudentSearchResultBundle;
import teammates.common.datatransfer.attributes.InstructorAttributes;
import teammates.common.datatransfer.attributes.StudentAttributes;
import teammates.common.exception.EntityAlreadyExistsException;
import teammates.common.exception.EntityDoesNotExistException;
import teammates.common.exception.InvalidParametersException;
import teammates.common.exception.TeammatesException;
import teammates.common.util.Assumption;
import teammates.common.util.Const;
import teammates.common.util.Logger;
import teammates.common.util.StringHelper;
import teammates.storage.entity.CourseStudent;
import teammates.storage.search.SearchDocument;
import teammates.storage.search.StudentSearchDocument;
import teammates.storage.search.StudentSearchQuery;

/**
 * Handles CRUD operations for students.
 *
 * @see CourseStudent
 * @see StudentAttributes
 */
public class StudentsDb extends EntitiesDb<CourseStudent, StudentAttributes> {

    public static final String ERROR_UPDATE_EMAIL_ALREADY_USED = ""Trying to update to an email that is already used by: "";

    private static final Logger log = Logger.getLogger();

    public void putDocument(StudentAttributes student) {
        putDocument(Const.SearchIndex.STUDENT, new StudentSearchDocument(student));
    }

    /**
     * Batch creates or updates search documents for the given students.
     */
    public void putDocuments(List<StudentAttributes> students) {
        List<SearchDocument> studentDocuments = new ArrayList<>();
        for (StudentAttributes student : students) {
            studentDocuments.add(new StudentSearchDocument(student));
        }
        putDocuments(Const.SearchIndex.STUDENT, studentDocuments);
    }

    /**
     * Searches for students.
     * @return {@link StudentSearchResultBundle}
     */
    public StudentSearchResultBundle search(String queryString, List<InstructorAttributes> instructors) {
        if (queryString.trim().isEmpty()) {
            return new StudentSearchResultBundle();
        }

        Results<ScoredDocument> results = searchDocuments(Const.SearchIndex.STUDENT,
                new StudentSearchQuery(instructors, queryString));

        return StudentSearchDocument.fromResults(results, instructors);
    }

    /**
     * This method should be used by admin only since the searching does not restrict the
     * visibility according to the logged-in user's google ID. This is used by admin to
     * search students in the whole system.
     * @return null if no result found
     */
    public StudentSearchResultBundle searchStudentsInWholeSystem(String queryString) {
        if (queryString.trim().isEmpty()) {
            return new StudentSearchResultBundle();
        }

        Results<ScoredDocument> results = searchDocuments(Const.SearchIndex.STUDENT,
                new StudentSearchQuery(queryString));

        return StudentSearchDocument.fromResults(results);
    }

    public void deleteDocument(StudentAttributes studentToDelete) {
        String key = studentToDelete.key;
        if (key == null) {
            StudentAttributes student = getStudentForEmail(studentToDelete.course, studentToDelete.email);
            if (student == null) {
                return;
            }
            key = student.key;
        }
        deleteDocument(Const.SearchIndex.STUDENT, key);
    }

    /**
     * Creates students' records without searchability.
     */
    public void createStudentsWithoutSearchability(Collection<StudentAttributes> studentsToAdd)
            throws InvalidParametersException {

        List<StudentAttributes> studentsToUpdate = createEntities(studentsToAdd);
        for (StudentAttributes student : studentsToUpdate) {
            try {
                updateStudentWithoutSearchability(student.course, student.email, student.name, student.team,
                                                  student.section, student.email, student.googleId, student.comments);
            } catch (EntityDoesNotExistException e) {
                // This situation is not tested as replicating such a situation is
                // difficult during testing
                Assumption.fail(""Entity found be already existing and not existing simultaneously"");
            }
        }
    }

    public void createStudent(StudentAttributes student)
            throws InvalidParametersException, EntityAlreadyExistsException {
        createStudent(student, true);
    }

    public void createStudentWithoutDocument(StudentAttributes student)
            throws InvalidParametersException, EntityAlreadyExistsException {
        createStudent(student, false);
    }

    public void createStudent(StudentAttributes student, boolean hasDocument)
            throws InvalidParametersException, EntityAlreadyExistsException {
        CourseStudent createdStudent = createEntity(student);
        if (hasDocument) {
            putDocument(makeAttributes(createdStudent));
        }
    }

    /**
     * Preconditions: <br>
     * * All parameters are non-null.
     *
     * @return The data for Student with the courseId and email. Returns null if
     *         there is no such student.
     */
    public StudentAttributes getStudentForEmail(String courseId, String email) {
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, courseId);
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, email);

        return makeAttributesOrNull(getCourseStudentEntityForEmail(courseId, email));
    }

    /**
     * Preconditions:
     * <br> * All parameters are non-null.
     * @return null if no such student is found.
     */
    public StudentAttributes getStudentForGoogleId(String courseId, String googleId) {
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, googleId);
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, courseId);

        CourseStudent student = load()
                .filter(""courseId ="", courseId)
                .filter(""googleId ="", googleId)
                .first().now();

        return makeAttributesOrNull(student);
    }

    /**
     * Works only for encrypted keys.
     *
     * <p>Preconditions: <br>
     * All parameters are non-null.
     *
     * @return null if no matching student.
     */
    public StudentAttributes getStudentForRegistrationKey(String encryptedRegistrationKey) {
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, encryptedRegistrationKey);

        try {
            String decryptedKey = StringHelper.decrypt(encryptedRegistrationKey.trim());
            return makeAttributesOrNull(getCourseStudentEntityForRegistrationKey(decryptedKey));
        } catch (InvalidParametersException e) {
            return null; // invalid registration key cannot be decrypted
        } catch (Exception e) {
            // TODO change this to an Assumption.fail
            log.severe(""Exception thrown trying to retrieve CourseStudent \n""
                    + TeammatesException.toStringWithStackTrace(e));
            return null;
        }

    }

    /**
     * Preconditions:
     * <br> * All parameters are non-null.
     * @return an empty list if no such students are found.
     */
    public List<StudentAttributes> getStudentsForGoogleId(String googleId) {
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, googleId);

        return makeAttributes(getCourseStudentEntitiesForGoogleId(googleId));
    }

    /**
     * Preconditions: <br>
     *  * All parameters are non-null.
     * @return an empty list if no students in the course.
     */
    public List<StudentAttributes> getStudentsForCourse(String courseId) {
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, courseId);

        return makeAttributes(getCourseStudentEntitiesForCourse(courseId));
    }

    /**
     * Preconditions: <br>
     *  * All parameters are non-null.
     * @return an empty list if no students in the course.
     */
    public List<StudentAttributes> getStudentsForTeam(String teamName, String courseId) {
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, teamName);
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, courseId);

        return makeAttributes(getCourseStudentEntitiesForTeam(teamName, courseId));
    }

    /**
     * Preconditions: <br>
     * All parameters are non-null.
     * @return an empty list if no students in this section
     */
    public List<StudentAttributes> getStudentsForSection(String sectionName, String courseId) {
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, sectionName);
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, courseId);

        return makeAttributes(getCourseStudentEntitiesForSection(sectionName, courseId));
    }

    /**
     * Preconditions: <br>
     *  * All parameters are non-null.
     * @return an empty list if no students in the course.
     */
    public List<StudentAttributes> getUnregisteredStudentsForCourse(String courseId) {
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, courseId);

        List<StudentAttributes> allStudents = getStudentsForCourse(courseId);
        ArrayList<StudentAttributes> unregistered = new ArrayList<>();

        for (StudentAttributes s : allStudents) {
            if (s.googleId == null || s.googleId.trim().isEmpty()) {
                unregistered.add(s);
            }
        }
        return unregistered;
    }

    /**
     * This method is not scalable. Not to be used unless for admin features.
     * @return the list of all students in the database.
     */
    // TODO remove this method once all Students have been migrated to CourseStudents
    @Deprecated
    public List<StudentAttributes> getAllStudents() {
        Map<String, StudentAttributes> result = new LinkedHashMap<>();

        for (StudentAttributes student : getAllCourseStudents()) {
            result.put(student.getId(), student);
        }
        return new ArrayList<>(result.values());
    }

    /**
     * This method is not scalable. Not to be used unless for admin features.
     * @return the list of all students in the database.
     */
    @Deprecated
    public List<StudentAttributes> getAllCourseStudents() {
        return makeAttributes(getCourseStudentEntities());
    }

    /**
     * Updates the student identified by {@code courseId} and {@code email}.
     * For the remaining parameters, the existing value is preserved
     *   if the parameter is null (due to 'keep existing' policy)<br>
     * Preconditions: <br>
     * * {@code courseId} and {@code email} are non-null and correspond to an existing student. <br>
     * @param keepUpdateTimestamp Set true to prevent changes to updatedAt. Use when updating entities with scripts.
     */
    public void updateStudent(String courseId, String email, String newName,
                                    String newTeamName, String newSectionName, String newEmail,
                                    String newGoogleId,
                                    String newComments,
                                    boolean keepUpdateTimestamp) throws InvalidParametersException,
                                    EntityDoesNotExistException {
        updateStudent(courseId, email, newName, newTeamName, newSectionName,
                newEmail, newGoogleId, newComments, true, keepUpdateTimestamp);
    }

    public void updateStudent(String courseId, String email, String newName,
            String newTeamName, String newSectionName, String newEmail,
            String newGoogleId,
            String newComments) throws InvalidParametersException,
            EntityDoesNotExistException {
        updateStudent(courseId, email, newName, newTeamName, newSectionName,
                newEmail, newGoogleId, newComments, true, false);
    }

    /**
     * Update student's record without searchability
     * This function is only used for testing, its purpose is to not create document if not necessary.
     * @param keepUpdateTimestamp Set true to prevent changes to updatedAt. Use when updating entities with scripts.
     */
    public void updateStudentWithoutSearchability(String courseId, String email,
            String newName,
            String newTeamName, String newSectionName, String newEmail,
            String newGoogleId,
            String newComments,
            boolean keepUpdateTimestamp) throws InvalidParametersException,
            EntityDoesNotExistException {
        updateStudent(courseId, email, newName, newTeamName, newSectionName,
                                        newEmail, newGoogleId, newComments, false, keepUpdateTimestamp);
    }

    public void updateStudentWithoutSearchability(String courseId, String email,
            String newName,
            String newTeamName, String newSectionName, String newEmail,
            String newGoogleId,
            String newComments) throws InvalidParametersException,
            EntityDoesNotExistException {
        updateStudent(courseId, email, newName, newTeamName, newSectionName,
                newEmail, newGoogleId, newComments, false, false);
    }

    public void updateStudent(String courseId, String email, String newName,
            String newTeamName, String newSectionName, String newEmail, String newGoogleId,
            String newComments, boolean hasDocument, boolean keepUpdateTimestamp)
            throws InvalidParametersException, EntityDoesNotExistException {
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, courseId);
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, email);

        verifyStudentExists(courseId, email);

        // Update CourseStudent if it exists.
        CourseStudent courseStudent = getCourseStudentEntityForEmail(courseId, email);
        if (courseStudent != null) {
            boolean isEmailChanged = !email.equals(newEmail);
            String lastName = StringHelper.splitName(newName)[1];

            if (isEmailChanged) {
                CourseStudent newCourseStudent = new CourseStudent(newEmail, newName, newGoogleId, newComments,
                                                                   courseId, newTeamName, newSectionName);
                recreateStudentWithNewEmail(newCourseStudent, lastName, courseStudent, hasDocument,
                                            keepUpdateTimestamp, courseId, email);
            } else {
                updateStudentDetails(newName, newTeamName, newSectionName, newGoogleId,
                                     newComments, hasDocument, keepUpdateTimestamp, courseStudent, lastName);
            }
        }
    }

    @SuppressWarnings(""PMD.PreserveStackTrace"")
    private void recreateStudentWithNewEmail(
            CourseStudent newCourseStudent, String lastName, CourseStudent courseStudent,
            boolean hasDocument, boolean keepUpdateTimestamp, String courseId, String email)
            throws InvalidParametersException {
        newCourseStudent.setLastName(lastName);
        newCourseStudent.setCreatedAt(courseStudent.getCreatedAt());
        if (keepUpdateTimestamp) {
            newCourseStudent.setLastUpdate(courseStudent.getUpdatedAt());
        }

        StudentAttributes newCourseStudentAttributes = makeAttributes(newCourseStudent);
        try {
            createStudent(newCourseStudentAttributes, hasDocument);
        } catch (EntityAlreadyExistsException e) {
            CourseStudent existingStudent = getEntity(newCourseStudentAttributes);
            String error = ERROR_UPDATE_EMAIL_ALREADY_USED + existingStudent.getName() + ""/"" + existingStudent.getEmail();
            throw new InvalidParametersException(error);
        }

        deleteStudent(courseId, email);
    }

    private void updateStudentDetails(String newName, String newTeamName, String newSectionName,
            String newGoogleId, String newComments, boolean hasDocument,
            boolean keepUpdateTimestamp, CourseStudent courseStudent, String lastName) {
        courseStudent.setName(newName);
        courseStudent.setLastName(lastName);
        courseStudent.setComments(newComments);
        courseStudent.setGoogleId(newGoogleId);
        courseStudent.setTeamName(newTeamName);
        courseStudent.setSectionName(newSectionName);

        StudentAttributes attributes = makeAttributes(courseStudent);

        if (hasDocument) {
            putDocument(attributes);
        }

        // Set true to prevent changes to last update timestamp
        courseStudent.keepUpdateTimestamp = keepUpdateTimestamp;
        saveEntity(courseStudent, attributes);
    }

    //TODO: add an updateStudent(StudentAttributes) version and make the above private

    /**
     * Fails silently if no such student. <br>
     * Preconditions: <br>
     *  * All parameters are non-null.
     *
     */

    public void deleteStudent(String courseId, String email) {
        deleteStudent(courseId, email, true);
    }

    public void deleteStudentWithoutDocument(String courseId, String email) {
        deleteStudent(courseId, email, false);
    }

    public void deleteStudent(String courseId, String email, boolean hasDocument) {
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, courseId);
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, email);

        if (hasDocument) {
            CourseStudent courseStudentToDelete = getCourseStudentEntityForEmail(courseId, email);
            if (courseStudentToDelete != null) {
                StudentAttributes courseStudentToDeleteAttributes = makeAttributes(courseStudentToDelete);
                deleteDocument(courseStudentToDeleteAttributes);
                deleteEntityDirect(courseStudentToDelete, courseStudentToDeleteAttributes);
            }
        } else {
            ofy().delete().keys(getCourseStudentForEmailQuery(courseId, email).keys()).now();
        }
    }

    /**
     * Fails silently if no such student. <br>
     * Preconditions: <br>
     *  * All parameters are non-null.
     *
     */

    public void deleteStudentsForGoogleId(String googleId) {
        deleteStudentsForGoogleId(googleId, true);
    }

    public void deleteStudentsForGoogleIdWithoutDocument(String googleId) {
        deleteStudentsForGoogleId(googleId, false);
    }

    public void deleteStudentsForGoogleId(String googleId, boolean hasDocument) {
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, googleId);

        if (hasDocument) {
            deleteStudentsCascadeDocuments(getCourseStudentEntitiesForGoogleId(googleId));
        } else {
            ofy().delete().keys(getCourseStudentsForGoogleIdQuery(googleId).keys());
        }
    }

    /**
     * Fails silently if no such student or no such course. <br>
     * Preconditions: <br>
     *  * All parameters are non-null.
     *
     */

    public void deleteStudentsForCourse(String courseId) {
        deleteStudentsForCourse(courseId, true);
    }

    public void deleteStudentsForCourseWithoutDocument(String courseId) {
        deleteStudentsForCourse(courseId, false);
    }

    public void deleteStudentsForCourse(String courseId, boolean hasDocument) {
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, courseId);

        if (hasDocument) {
            deleteStudentsCascadeDocuments(getCourseStudentEntitiesForCourse(courseId));
        } else {
            ofy().delete().keys(getCourseStudentsForCourseQuery(courseId).keys());
        }
    }

    public void deleteStudentsForCourses(List<String> courseIds) {
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, courseIds);

        ofy().delete().keys(getCourseStudentsForCoursesQuery(courseIds).keys());
    }

    /**
     * Verifies that the student with the specified {@code email} exists in the course {@code courseId}.
     *
     * @throws EntityDoesNotExistException if the student specified by courseId and email does not exist,
     */
    public void verifyStudentExists(String courseId, String email)
            throws EntityDoesNotExistException {
        if (getStudentForEmail(courseId, email) == null) {
            String error = ERROR_UPDATE_NON_EXISTENT_STUDENT + courseId + ""/"" + email;
            throw new EntityDoesNotExistException(error);
        }
    }

    private Query<CourseStudent> getCourseStudentForEmailQuery(String courseId, String email) {
        return load()
                .filter(""courseId ="", courseId)
                .filter(""email ="", email);
    }

    private CourseStudent getCourseStudentEntityForEmail(String courseId, String email) {
        return getCourseStudentForEmailQuery(courseId, email).first().now();
    }

    private CourseStudent getCourseStudentEntityForRegistrationKey(String registrationKey) {
        List<CourseStudent> studentList = load().filter(""registrationKey ="", registrationKey).list();

        // If registration key detected is not unique, something is wrong
        if (studentList.size() > 1) {
            StringBuilder duplicatedStudentsUniqueIds = new StringBuilder();
            for (CourseStudent s : studentList) {
                duplicatedStudentsUniqueIds.append(s.getUniqueId() + '\n');
            }
            log.severe(""Duplicate registration keys detected for: \n"" + duplicatedStudentsUniqueIds);
        }

        if (studentList.isEmpty()) {
            return null;
        }

        return studentList.get(0);
    }

    private Query<CourseStudent> getCourseStudentsForCourseQuery(String courseId) {
        return load().filter(""courseId ="", courseId);
    }

    public List<CourseStudent> getCourseStudentEntitiesForCourse(String courseId) {
        return getCourseStudentsForCourseQuery(courseId).list();
    }

    private Query<CourseStudent> getCourseStudentsForCoursesQuery(List<String> courseIds) {
        return load().filter(""courseId in"", courseIds);
    }

    private Query<CourseStudent> getCourseStudentsForGoogleIdQuery(String googleId) {
        return load().filter(""googleId ="", googleId);
    }

    private List<CourseStudent> getCourseStudentEntitiesForGoogleId(String googleId) {
        return getCourseStudentsForGoogleIdQuery(googleId).list();
    }

    private List<CourseStudent> getCourseStudentEntitiesForTeam(String teamName, String courseId) {
        return load()
                .filter(""teamName ="", teamName)
                .filter(""courseId ="", courseId)
                .list();
    }

    private List<CourseStudent> getCourseStudentEntitiesForSection(String sectionName, String courseId) {
        return load()
                .filter(""sectionName ="", sectionName)
                .filter(""courseId ="", courseId)
                .list();
    }

    @Deprecated
    /**
     * Retrieves all course student entities. This function is not scalable.
     */
    public List<CourseStudent> getCourseStudentEntities() {
        return load().list();
    }

    @Override
    protected LoadType<CourseStudent> load() {
        return ofy().load().type(CourseStudent.class);
    }

    @Override
    protected CourseStudent getEntity(StudentAttributes studentToGet) {
        return getCourseStudentEntityForEmail(studentToGet.course, studentToGet.email);
    }

    @Override
    protected QueryKeys<CourseStudent> getEntityQueryKeys(StudentAttributes attributes) {
        return getCourseStudentForEmailQuery(attributes.course, attributes.email).keys();
    }

    private void deleteStudentsCascadeDocuments(List<CourseStudent> students) {
        List<StudentAttributes> studentsAttributes = new ArrayList<>();
        for (CourseStudent student : students) {
            StudentAttributes studentAttributes = makeAttributes(student);
            studentsAttributes.add(studentAttributes);
            deleteDocument(studentAttributes);
        }
        deleteEntitiesDirect(students, studentsAttributes);
    }

    @Override
    protected StudentAttributes makeAttributes(CourseStudent entity) {
        Assumption.assertNotNull(Const.StatusCodes.DBLEVEL_NULL_INPUT, entity);

        return new StudentAttributes(entity);
    }
}
"
AdminPrepareEmailAddressModeWorkerAction.java,ui-automated,"package teammates.ui.automated;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import teammates.common.datatransfer.attributes.AdminEmailAttributes;
import teammates.common.util.Assumption;
import teammates.common.util.Const.ParamsNames;
import teammates.common.util.Logger;

/**
 * Task queue worker action: prepares admin email to be sent via task queue in address mode,
 * i.e. using the address list given directly.
 */
public class AdminPrepareEmailAddressModeWorkerAction extends AutomatedAction {

    private static final Logger log = Logger.getLogger();

    @Override
    protected String getActionDescription() {
        return null;
    }

    @Override
    protected String getActionMessage() {
        return null;
    }

    @Override
    public void execute() {
        log.info(""Preparing admin email task queue in address mode..."");

        String emailId = getRequestParamValue(ParamsNames.ADMIN_EMAIL_ID);
        Assumption.assertPostParamNotNull(ParamsNames.ADMIN_EMAIL_ID, emailId);

        String addressReceiverListString = getRequestParamValue(ParamsNames.ADMIN_EMAIL_ADDRESS_RECEIVERS);
        Assumption.assertPostParamNotNull(ParamsNames.ADMIN_EMAIL_ADDRESS_RECEIVERS, addressReceiverListString);

        AdminEmailAttributes adminEmail = logic.getAdminEmailById(emailId);
        Assumption.assertNotNull(adminEmail);
        List<String> addressList = new ArrayList<>();

        if (addressReceiverListString.contains("","")) {
            addressList.addAll(Arrays.asList(addressReceiverListString.split("","")));
        } else {
            addressList.add(addressReceiverListString);
        }

        for (String emailAddress : addressList) {
            taskQueuer.scheduleAdminEmailForSending(emailId, emailAddress, adminEmail.getSubject(),
                                                    adminEmail.getContentValue());
        }
    }

}
"
AdminPrepareEmailGroupModeWorkerAction.java,ui-automated,"package teammates.ui.automated;

import java.io.IOException;
import java.util.List;

import com.google.appengine.api.blobstore.BlobKey;
import com.google.apphosting.api.ApiProxy;

import teammates.common.datatransfer.attributes.AdminEmailAttributes;
import teammates.common.exception.TeammatesException;
import teammates.common.util.Assumption;
import teammates.common.util.Const.ParamsNames;
import teammates.common.util.GoogleCloudStorageHelper;
import teammates.common.util.Logger;

/**
 * Task queue worker action: prepares admin email to be sent via task queue in group mode,
 * i.e. using the group receiver list retrieved from the Google Cloud Storage (GCS).
 */
public class AdminPrepareEmailGroupModeWorkerAction extends AutomatedAction {

    private static final Logger log = Logger.getLogger();

    @Override
    protected String getActionDescription() {
        return null;
    }

    @Override
    protected String getActionMessage() {
        return null;
    }

    @Override
    public void execute() {
        log.info(""Preparing admin email task queue in group mode..."");

        String emailId = getRequestParamValue(ParamsNames.ADMIN_EMAIL_ID);
        Assumption.assertPostParamNotNull(ParamsNames.ADMIN_EMAIL_ID, emailId);

        String groupReceiverListFileKey = getRequestParamValue(ParamsNames.ADMIN_EMAIL_GROUP_RECEIVER_LIST_FILE_KEY);
        Assumption.assertPostParamNotNull(ParamsNames.ADMIN_EMAIL_GROUP_RECEIVER_LIST_FILE_KEY, groupReceiverListFileKey);

        String indexOfEmailListToResumeAsString =
                getRequestParamValue(ParamsNames.ADMIN_GROUP_RECEIVER_EMAIL_LIST_INDEX);
        String indexOfEmailToResumeAsString = getRequestParamValue(ParamsNames.ADMIN_GROUP_RECEIVER_EMAIL_INDEX);

        int indexOfEmailListToResume = indexOfEmailListToResumeAsString == null
                                       ? 0
                                       : Integer.parseInt(indexOfEmailListToResumeAsString);
        int indexOfEmailToResume = indexOfEmailToResumeAsString == null
                                   ? 0
                                   : Integer.parseInt(indexOfEmailToResumeAsString);

        try {
            List<List<String>> processedReceiverEmails =
                    GoogleCloudStorageHelper.getGroupReceiverList(new BlobKey(groupReceiverListFileKey));
            addAdminEmailToTaskQueue(emailId, groupReceiverListFileKey, processedReceiverEmails,
                                     indexOfEmailListToResume, indexOfEmailToResume);
        } catch (IOException e) {
            log.severe(""Unexpected error while adding admin email tasks: ""
                       + TeammatesException.toStringWithStackTrace(e));
        }
    }

    private boolean isNearDeadline() {
        long timeLeftInMillis = ApiProxy.getCurrentEnvironment().getRemainingMillis();
        return timeLeftInMillis / 1000 < 100;
    }

    private void addAdminEmailToTaskQueue(String emailId, String groupReceiverListFileKey,
            List<List<String>> processedReceiverEmails,
            int indexOfEmailListToResume, int indexOfEmailToResume) {
        AdminEmailAttributes adminEmail = logic.getAdminEmailById(emailId);
        Assumption.assertNotNull(adminEmail);

        log.info(""Resume adding group mail tasks for mail with id "" + emailId + "" from list index: ""
                 + indexOfEmailListToResume + "" and email index: "" + indexOfEmailToResume);

        int indexOfLastEmailList = 0;
        int indexOfLastEmail = 0;

        for (int i = indexOfEmailListToResume; i < processedReceiverEmails.size(); i++) {
            List<String> currentEmailList = processedReceiverEmails.get(i);
            for (int j = indexOfEmailToResume; j < currentEmailList.size(); j++) {
                String receiverEmail = currentEmailList.get(j);
                taskQueuer.scheduleAdminEmailForSending(emailId, receiverEmail, adminEmail.getSubject(),
                                                        adminEmail.getContentValue());
                if (isNearDeadline()) {
                    taskQueuer.scheduleAdminEmailPreparationInGroupMode(emailId, groupReceiverListFileKey, i, j);
                    log.info(""Adding group mail tasks for mail with id "" + emailId
                             + "" have been paused with list index: "" + i + "" and email index: "" + j);
                    return;
                }
                indexOfLastEmail = j;
            }
            indexOfLastEmailList = i;
        }

        log.info(""Adding group mail tasks for mail with id "" + emailId
                 + ""was complete with last reached list index: "" + indexOfLastEmailList
                 + "" and last reached email index: "" + indexOfLastEmail);
    }

}
"
AdminSendEmailWorkerAction.java,ui-automated,"package teammates.ui.automated;

import teammates.common.datatransfer.attributes.AdminEmailAttributes;
import teammates.common.exception.TeammatesException;
import teammates.common.util.Assumption;
import teammates.common.util.Const.ParamsNames;
import teammates.common.util.EmailWrapper;
import teammates.common.util.Logger;
import teammates.logic.api.EmailGenerator;

/**
 * Task queue worker action: sends queued admin email.
 */
public class AdminSendEmailWorkerAction extends AutomatedAction {

    private static final Logger log = Logger.getLogger();

    @Override
    protected String getActionDescription() {
        return null;
    }

    @Override
    protected String getActionMessage() {
        return null;
    }

    @Override
    public void execute() {
        String receiverEmail = getRequestParamValue(ParamsNames.ADMIN_EMAIL_RECEIVER);
        Assumption.assertPostParamNotNull(ParamsNames.ADMIN_EMAIL_RECEIVER, receiverEmail);

        String emailContent = getRequestParamValue(ParamsNames.ADMIN_EMAIL_CONTENT);
        String emailSubject = getRequestParamValue(ParamsNames.ADMIN_EMAIL_SUBJECT);

        if (emailContent == null || emailSubject == null) {
            String emailId = getRequestParamValue(ParamsNames.ADMIN_EMAIL_ID);
            Assumption.assertPostParamNotNull(ParamsNames.ADMIN_EMAIL_ID, emailId);

            log.info(""Sending large email. Going to retrieve email content and subject from datastore."");
            AdminEmailAttributes adminEmail = logic.getAdminEmailById(emailId);
            Assumption.assertNotNull(adminEmail);

            emailContent = adminEmail.getContentValue();
            emailSubject = adminEmail.getSubject();
        }

        Assumption.assertNotNull(emailContent);
        Assumption.assertNotNull(emailSubject);

        try {
            EmailWrapper email =
                    new EmailGenerator().generateAdminEmail(emailContent, emailSubject, receiverEmail);
            emailSender.sendEmail(email);
            log.info(""Email sent to "" + receiverEmail);
        } catch (Exception e) {
            log.severe(""Unexpected error while sending admin emails: "" + TeammatesException.toStringWithStackTrace(e));
        }
    }

}
"
AutomatedAction.java,ui-automated,"package teammates.ui.automated;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import teammates.common.util.Assumption;
import teammates.common.util.HttpRequestHelper;
import teammates.logic.api.EmailSender;
import teammates.logic.api.Logic;
import teammates.logic.api.TaskQueuer;

/**
 * An automated ""action"" to be performed by the system, triggered by cron jobs or task queues.
 * <p>
 * This class of action is different from the non-automated ones in the following manner:
 * <ul>
 *     <li>Non-administrators are barred from performing it.</li>
 *     <li>The limit for request is 10 minutes instead of 1 minute.</li>
 * </ul>
 * </p>
 */
public abstract class AutomatedAction {

    protected Logic logic;
    protected TaskQueuer taskQueuer;
    protected EmailSender emailSender;

    protected HttpServletRequest request;
    protected HttpServletResponse response;

    protected void initialiseAttributes(HttpServletRequest request, HttpServletResponse response) {
        this.request = request;
        this.response = response;
        this.logic = new Logic();
        setTaskQueuer(new TaskQueuer());
        setEmailSender(new EmailSender());
    }

    public TaskQueuer getTaskQueuer() {
        return taskQueuer;
    }

    public void setTaskQueuer(TaskQueuer taskQueuer) {
        this.taskQueuer = taskQueuer;
    }

    public EmailSender getEmailSender() {
        return emailSender;
    }

    public void setEmailSender(EmailSender emailSender) {
        this.emailSender = emailSender;
    }

    protected String getRequestParamValue(String paramName) {
        return HttpRequestHelper.getValueFromRequestParameterMap(request, paramName);
    }

    /**
     * Returns the value for the specified parameter expected to be present in the http request.
     * Assumption: the requested parameter is not null.
     *
     * @param paramName  a constant from the {@link teammates.common.util.Const.ParamsNames} class.
     */
    protected String getNonNullRequestParamValue(String paramName) {
        return getNonNullRequestParamValues(paramName)[0];
    }

    protected String[] getRequestParamValues(String paramName) {
        return HttpRequestHelper.getValuesFromRequestParameterMap(request, paramName);
    }

    /**
     * Returns the values for the specified parameter expected to be present in the http request.
     * Assumption: the requested parameter is not null.
     *
     * @param paramName  a constant from the {@link teammates.common.util.Const.ParamsNames} class.
     */
    protected String[] getNonNullRequestParamValues(String paramName) {
        String[] values = getRequestParamValues(paramName);
        Assumption.assertPostParamNotNull(paramName, values);
        return values;
    }

    protected void setForRetry() {
        // Sets an arbitrary retry code outside of the range 200-299 so GAE will automatically retry upon failure
        response.setStatus(100);
    }

    protected abstract String getActionDescription();

    protected abstract String getActionMessage();

    /** Executes the action. */
    public abstract void execute();

}
"
AutomatedActionFactory.java,ui-automated,"package teammates.ui.automated;

import java.util.HashMap;
import java.util.Map;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import teammates.common.exception.PageNotFoundException;
import teammates.common.exception.TeammatesException;
import teammates.common.util.Const.ActionURIs;
import teammates.common.util.Const.TaskQueue;

/**
 * Generates the matching {@link AutomatedAction} for a given URI.
 */
public class AutomatedActionFactory {

    private static Map<String, Class<? extends AutomatedAction>> actionMappings = new HashMap<>();

    static {
        // Cron jobs
        map(ActionURIs.AUTOMATED_LOG_COMPILATION, CompileLogsAction.class);
        map(ActionURIs.AUTOMATED_FEEDBACK_OPENING_REMINDERS, FeedbackSessionOpeningRemindersAction.class);
        map(ActionURIs.AUTOMATED_FEEDBACK_CLOSED_REMINDERS, FeedbackSessionClosedRemindersAction.class);
        map(ActionURIs.AUTOMATED_FEEDBACK_CLOSING_REMINDERS, FeedbackSessionClosingRemindersAction.class);
        map(ActionURIs.AUTOMATED_FEEDBACK_PUBLISHED_REMINDERS, FeedbackSessionPublishedRemindersAction.class);

        // Task queue workers
        map(TaskQueue.ADMIN_PREPARE_EMAIL_ADDRESS_MODE_WORKER_URL, AdminPrepareEmailAddressModeWorkerAction.class);
        map(TaskQueue.ADMIN_PREPARE_EMAIL_GROUP_MODE_WORKER_URL, AdminPrepareEmailGroupModeWorkerAction.class);
        map(TaskQueue.ADMIN_SEND_EMAIL_WORKER_URL, AdminSendEmailWorkerAction.class);
        map(TaskQueue.FEEDBACK_RESPONSE_ADJUSTMENT_WORKER_URL, FeedbackResponseAdjustmentWorkerAction.class);
        map(TaskQueue.FEEDBACK_SESSION_PUBLISHED_EMAIL_WORKER_URL, FeedbackSessionPublishedEmailWorkerAction.class);
        map(TaskQueue.FEEDBACK_SESSION_REMIND_EMAIL_WORKER_URL, FeedbackSessionRemindEmailWorkerAction.class);
        map(TaskQueue.FEEDBACK_SESSION_REMIND_PARTICULAR_USERS_EMAIL_WORKER_URL,
                FeedbackSessionRemindParticularUsersEmailWorkerAction.class);
        map(TaskQueue.FEEDBACK_SESSION_UNPUBLISHED_EMAIL_WORKER_URL, FeedbackSessionUnpublishedEmailWorkerAction.class);
        map(TaskQueue.INSTRUCTOR_COURSE_JOIN_EMAIL_WORKER_URL, InstructorCourseJoinEmailWorkerAction.class);
        map(TaskQueue.SEND_EMAIL_WORKER_URL, SendEmailWorkerAction.class);
        map(TaskQueue.STUDENT_COURSE_JOIN_EMAIL_WORKER_URL, StudentCourseJoinEmailWorkerAction.class);
    }

    private static void map(String actionUri, Class<? extends AutomatedAction> actionClass) {
        actionMappings.put(actionUri, actionClass);
    }

    /**
     * Returns the matching {@link AutomatedAction} object for the URI in the {@code req}.
     */
    public AutomatedAction getAction(HttpServletRequest req, HttpServletResponse resp) {
        String uri = req.getRequestURI();
        if (uri.contains("";"")) {
            uri = uri.split("";"")[0];
        }

        AutomatedAction action = getAction(uri);
        action.initialiseAttributes(req, resp);
        return action;
    }

    private AutomatedAction getAction(String uri) {
        Class<? extends AutomatedAction> action = actionMappings.get(uri);

        if (action == null) {
            throw new PageNotFoundException(""Page not found for "" + uri);
        }

        try {
            return action.newInstance();
        } catch (Exception e) {
            throw new RuntimeException(""Could not create the action for "" + uri + "": ""
                                       + TeammatesException.toStringWithStackTrace(e));
        }
    }

}
"
AutomatedServlet.java,ui-automated,"package teammates.ui.automated;

import java.util.Map;

import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import teammates.common.exception.TeammatesException;
import teammates.common.util.HttpRequestHelper;
import teammates.common.util.LogMessageGenerator;
import teammates.common.util.Logger;

/**
 * Receives automated requests from the App Engine server and executes the matching automated action.
 */
@SuppressWarnings(""serial"")
public class AutomatedServlet extends HttpServlet {

    private static final Logger log = Logger.getLogger();

    @Override
    public void doGet(HttpServletRequest req, HttpServletResponse resp) {
        doPost(req, resp);
    }

    @Override
    public void doPost(HttpServletRequest req, HttpServletResponse resp) {
        try {
            AutomatedAction action = new AutomatedActionFactory().getAction(req, resp);

            String url = HttpRequestHelper.getRequestedUrl(req);
            // Do not log task queue worker actions to prevent excessive logging
            if (!url.startsWith(""/worker/"")) {
                Map<String, String[]> params = HttpRequestHelper.getParameterMap(req);
                // no logged-in user for automated servlet
                LogMessageGenerator logGenerator = new LogMessageGenerator();
                log.info(logGenerator.generateBasicActivityLogMessage(url, params, action.getActionMessage(), null));
            }

            action.execute();
        } catch (Exception e) {
            String requestUrl = req.getRequestURL().toString();
            String requestParams = HttpRequestHelper.printRequestParameters(req);
            log.severe(""Exception occured while performing "" + requestUrl + ""|||""
                       + requestParams + ""|||"" + TeammatesException.toStringWithStackTrace(e));
        }
    }

}
"
CompileLogsAction.java,ui-automated,"package teammates.ui.automated;

import java.util.ArrayList;
import java.util.Date;
import java.util.List;

import com.google.appengine.api.log.AppLogLine;
import com.google.appengine.api.log.LogQuery;
import com.google.appengine.api.log.LogService;
import com.google.appengine.api.log.LogService.LogLevel;
import com.google.appengine.api.log.LogServiceFactory;
import com.google.appengine.api.log.RequestLogs;

import teammates.common.util.EmailWrapper;
import teammates.logic.api.EmailGenerator;

/**
 * Cron job: compiles application logs and sends severe logs compilation to the support email.
 */
public class CompileLogsAction extends AutomatedAction {

    @Override
    protected String getActionDescription() {
        return ""send severe log notifications"";
    }

    @Override
    protected String getActionMessage() {
        return ""Compiling logs for email notification"";
    }

    @Override
    public void execute() {
        List<AppLogLine> errorLogs = getErrorLogs();
        sendEmail(errorLogs);
    }

    private List<AppLogLine> getErrorLogs() {
        LogService logService = LogServiceFactory.getLogService();

        long endTime = new Date().getTime();
        // Sets the range to 6 minutes to slightly overlap the 5 minute email timer
        long queryRange = 1000 * 60 * 6;
        long startTime = endTime - queryRange;

        LogQuery q = LogQuery.Builder.withDefaults()
                                     .includeAppLogs(true)
                                     .startTimeMillis(startTime)
                                     .endTimeMillis(endTime)
                                     .minLogLevel(LogLevel.ERROR);

        Iterable<RequestLogs> logs = logService.fetch(q);
        List<AppLogLine> errorLogs = new ArrayList<>();

        for (RequestLogs requestLogs : logs) {
            List<AppLogLine> logList = requestLogs.getAppLogLines();

            for (AppLogLine currentLog : logList) {
                LogLevel logLevel = currentLog.getLogLevel();

                if (LogLevel.FATAL == logLevel || LogLevel.ERROR == logLevel) {
                    errorLogs.add(currentLog);
                }
            }
        }

        return errorLogs;
    }

    private void sendEmail(List<AppLogLine> logs) {
        // Do not send any emails if there are no severe logs; prevents spamming
        if (!logs.isEmpty()) {
            EmailWrapper message = new EmailGenerator().generateCompiledLogsEmail(logs);
            emailSender.sendReport(message);
        }
    }

}
"
FeedbackResponseAdjustmentWorkerAction.java,ui-automated,"package teammates.ui.automated;

import java.util.List;
import java.util.Map;

import com.google.gson.reflect.TypeToken;

import teammates.common.datatransfer.StudentEnrollDetails;
import teammates.common.datatransfer.attributes.FeedbackResponseAttributes;
import teammates.common.datatransfer.attributes.FeedbackSessionAttributes;
import teammates.common.util.Assumption;
import teammates.common.util.Const.ParamsNames;
import teammates.common.util.HttpRequestHelper;
import teammates.common.util.JsonUtils;
import teammates.common.util.LogMessageGenerator;
import teammates.common.util.Logger;

/**
 * Task queue worker action: adjusts feedback responses in the database due to
 * change in student enrollment details of a course.
 */
public class FeedbackResponseAdjustmentWorkerAction extends AutomatedAction {

    private static final Logger log = Logger.getLogger();

    @Override
    protected String getActionDescription() {
        return null;
    }

    @Override
    protected String getActionMessage() {
        return null;
    }

    @Override
    public void execute() {
        String courseId = getRequestParamValue(ParamsNames.COURSE_ID);
        Assumption.assertPostParamNotNull(ParamsNames.COURSE_ID, courseId);

        String sessionName = getRequestParamValue(ParamsNames.FEEDBACK_SESSION_NAME);
        Assumption.assertPostParamNotNull(ParamsNames.FEEDBACK_SESSION_NAME, sessionName);

        String enrollmentDetails = getRequestParamValue(ParamsNames.ENROLLMENT_DETAILS);
        Assumption.assertPostParamNotNull(ParamsNames.ENROLLMENT_DETAILS, enrollmentDetails);

        log.info(""Adjusting submissions for feedback session :"" + sessionName + ""in course : "" + courseId);

        FeedbackSessionAttributes feedbackSession = logic.getFeedbackSession(sessionName, courseId);

        String errorString = ""Error encountered while adjusting feedback session responses of %s in course %s: %s%n%s"";

        if (feedbackSession == null) {
            log.severe(String.format(errorString, sessionName, courseId, ""feedback session is null"", """"));
            setForRetry();
            return;
        }

        List<FeedbackResponseAttributes> allResponses =
                logic.getFeedbackResponsesForSession(feedbackSession.getFeedbackSessionName(),
                                                     feedbackSession.getCourseId());
        List<StudentEnrollDetails> enrollmentList =
                JsonUtils.fromJson(enrollmentDetails, new TypeToken<List<StudentEnrollDetails>>(){}.getType());
        for (FeedbackResponseAttributes response : allResponses) {
            try {
                logic.adjustFeedbackResponseForEnrollments(enrollmentList, response);
            } catch (Exception e) {
                String url = HttpRequestHelper.getRequestedUrl(request);
                Map<String, String[]> params = HttpRequestHelper.getParameterMap(request);
                // no logged-in user for worker
                String logMessage = new LogMessageGenerator().generateActionFailureLogMessage(url, params, e, null);
                log.severe(String.format(errorString, sessionName, courseId, e.getMessage(), logMessage));
                setForRetry();
                return;
            }
        }
    }

}
"
FeedbackSessionClosedRemindersAction.java,ui-automated,"package teammates.ui.automated;

import java.util.List;

import teammates.common.datatransfer.attributes.FeedbackSessionAttributes;
import teammates.common.exception.TeammatesException;
import teammates.common.util.EmailWrapper;
import teammates.common.util.Logger;
import teammates.logic.api.EmailGenerator;

/**
 * Cron job: schedules feedback session closed emails to be sent.
 */
public class FeedbackSessionClosedRemindersAction extends AutomatedAction {

    private static final Logger log = Logger.getLogger();

    @Override
    protected String getActionDescription() {
        return ""send closed reminders"";
    }

    @Override
    protected String getActionMessage() {
        return ""Generating reminders for closed feedback sessions."";
    }

    @Override
    public void execute() {
        List<FeedbackSessionAttributes> sessions = logic.getFeedbackSessionsClosedWithinThePastHour();

        for (FeedbackSessionAttributes session : sessions) {
            List<EmailWrapper> emailsToBeSent = new EmailGenerator().generateFeedbackSessionClosedEmails(session);
            try {
                taskQueuer.scheduleEmailsForSending(emailsToBeSent);
                session.setSentClosedEmail(true);
                logic.updateFeedbackSession(session);
            } catch (Exception e) {
                log.severe(""Unexpected error: "" + TeammatesException.toStringWithStackTrace(e));
            }
        }
    }

}
"
FeedbackSessionClosingRemindersAction.java,ui-automated,"package teammates.ui.automated;

import java.util.List;

import teammates.common.datatransfer.attributes.FeedbackSessionAttributes;
import teammates.common.exception.TeammatesException;
import teammates.common.util.EmailWrapper;
import teammates.common.util.Logger;
import teammates.logic.api.EmailGenerator;

/**
 * Cron job: schedules feedback session closing emails to be sent.
 */
public class FeedbackSessionClosingRemindersAction extends AutomatedAction {

    private static final Logger log = Logger.getLogger();

    @Override
    protected String getActionDescription() {
        return ""send closing reminders"";
    }

    @Override
    protected String getActionMessage() {
        return ""Generating reminders for closing feedback sessions."";
    }

    @Override
    public void execute() {
        List<FeedbackSessionAttributes> sessions = logic.getFeedbackSessionsClosingWithinTimeLimit();

        for (FeedbackSessionAttributes session : sessions) {
            List<EmailWrapper> emailsToBeSent = new EmailGenerator().generateFeedbackSessionClosingEmails(session);
            try {
                taskQueuer.scheduleEmailsForSending(emailsToBeSent);
                session.setSentClosingEmail(true);
                logic.updateFeedbackSession(session);
            } catch (Exception e) {
                log.severe(""Unexpected error: "" + TeammatesException.toStringWithStackTrace(e));
            }
        }
    }

}
"
FeedbackSessionOpeningRemindersAction.java,ui-automated,"package teammates.ui.automated;

import java.util.List;

import teammates.common.datatransfer.attributes.FeedbackSessionAttributes;
import teammates.common.exception.TeammatesException;
import teammates.common.util.EmailWrapper;
import teammates.common.util.Logger;
import teammates.logic.api.EmailGenerator;

/**
 * Cron job: schedules feedback session opening emails to be sent.
 */
public class FeedbackSessionOpeningRemindersAction extends AutomatedAction {

    private static final Logger log = Logger.getLogger();

    @Override
    protected String getActionDescription() {
        return ""send opening reminders"";
    }

    @Override
    protected String getActionMessage() {
        return ""Generating reminders for opening feedback sessions."";
    }

    @Override
    public void execute() {
        List<FeedbackSessionAttributes> sessions = logic.getFeedbackSessionsWhichNeedOpenEmailsToBeSent();

        for (FeedbackSessionAttributes session : sessions) {
            List<EmailWrapper> emailsToBeSent = new EmailGenerator().generateFeedbackSessionOpeningEmails(session);
            try {
                taskQueuer.scheduleEmailsForSending(emailsToBeSent);
                session.setSentOpenEmail(true);
                logic.updateFeedbackSession(session);
            } catch (Exception e) {
                log.severe(""Unexpected error: "" + TeammatesException.toStringWithStackTrace(e));
            }
        }
    }

}
"
FeedbackSessionPublishedEmailWorkerAction.java,ui-automated,"package teammates.ui.automated;

import java.util.List;

import teammates.common.datatransfer.attributes.FeedbackSessionAttributes;
import teammates.common.exception.TeammatesException;
import teammates.common.util.Assumption;
import teammates.common.util.Const.ParamsNames;
import teammates.common.util.EmailWrapper;
import teammates.common.util.Logger;
import teammates.logic.api.EmailGenerator;

/**
 * Task queue worker action: prepares session published reminder for a particular session to be sent.
 */
public class FeedbackSessionPublishedEmailWorkerAction extends AutomatedAction {

    private static final Logger log = Logger.getLogger();

    @Override
    protected String getActionDescription() {
        return null;
    }

    @Override
    protected String getActionMessage() {
        return null;
    }

    @Override
    public void execute() {
        String feedbackSessionName = getRequestParamValue(ParamsNames.EMAIL_FEEDBACK);
        Assumption.assertPostParamNotNull(ParamsNames.EMAIL_FEEDBACK, feedbackSessionName);

        String courseId = getRequestParamValue(ParamsNames.EMAIL_COURSE);
        Assumption.assertPostParamNotNull(ParamsNames.EMAIL_COURSE, courseId);

        FeedbackSessionAttributes session = logic.getFeedbackSession(feedbackSessionName, courseId);
        if (session == null) {
            log.severe(""Feedback session object for feedback session name: "" + feedbackSessionName
                       + "" for course: "" + courseId + "" could not be fetched."");
            return;
        }
        List<EmailWrapper> emailsToBeSent =
                new EmailGenerator().generateFeedbackSessionPublishedEmails(session);
        try {
            taskQueuer.scheduleEmailsForSending(emailsToBeSent);
            session.setSentPublishedEmail(true);
            logic.updateFeedbackSession(session);
        } catch (Exception e) {
            log.severe(""Unexpected error: "" + TeammatesException.toStringWithStackTrace(e));
        }
    }

}
"
FeedbackSessionPublishedRemindersAction.java,ui-automated,"package teammates.ui.automated;

import java.util.List;

import teammates.common.datatransfer.attributes.FeedbackSessionAttributes;

/**
 * Cron job: schedules feedback session published emails to be sent.
 */
public class FeedbackSessionPublishedRemindersAction extends AutomatedAction {

    @Override
    protected String getActionDescription() {
        return ""send published reminders"";
    }

    @Override
    protected String getActionMessage() {
        return ""Generating reminders for published feedback sessions."";
    }

    @Override
    public void execute() {
        List<FeedbackSessionAttributes> sessions =
                logic.getFeedbackSessionsWhichNeedAutomatedPublishedEmailsToBeSent();
        for (FeedbackSessionAttributes session : sessions) {
            taskQueuer.scheduleFeedbackSessionPublishedEmail(session.getCourseId(), session.getFeedbackSessionName());
        }
    }

}
"
FeedbackSessionRemindEmailWorkerAction.java,ui-automated,"package teammates.ui.automated;

import java.util.ArrayList;
import java.util.List;

import teammates.common.datatransfer.attributes.FeedbackSessionAttributes;
import teammates.common.datatransfer.attributes.InstructorAttributes;
import teammates.common.datatransfer.attributes.StudentAttributes;
import teammates.common.exception.TeammatesException;
import teammates.common.util.Assumption;
import teammates.common.util.Const.ParamsNames;
import teammates.common.util.EmailWrapper;
import teammates.common.util.Logger;
import teammates.logic.api.EmailGenerator;

/**
 * Task queue worker action: sends feedback session reminder email to a course.
 */
public class FeedbackSessionRemindEmailWorkerAction extends AutomatedAction {

    private static final Logger log = Logger.getLogger();

    @Override
    protected String getActionDescription() {
        return null;
    }

    @Override
    protected String getActionMessage() {
        return null;
    }

    @Override
    public void execute() {
        String feedbackSessionName = getRequestParamValue(ParamsNames.SUBMISSION_FEEDBACK);
        Assumption.assertPostParamNotNull(ParamsNames.SUBMISSION_FEEDBACK, feedbackSessionName);

        String courseId = getRequestParamValue(ParamsNames.SUBMISSION_COURSE);
        Assumption.assertPostParamNotNull(ParamsNames.SUBMISSION_COURSE, courseId);

        try {
            FeedbackSessionAttributes session = logic.getFeedbackSession(feedbackSessionName, courseId);
            List<StudentAttributes> studentList = logic.getStudentsForCourse(courseId);
            List<InstructorAttributes> instructorList = logic.getInstructorsForCourse(courseId);

            List<StudentAttributes> studentsToRemindList = new ArrayList<>();
            for (StudentAttributes student : studentList) {
                if (!logic.isFeedbackSessionCompletedByStudent(session, student.email)) {
                    studentsToRemindList.add(student);
                }
            }

            // Filter out instructors who have submitted the feedback session
            List<InstructorAttributes> instructorsToRemindList = new ArrayList<>();
            for (InstructorAttributes instructor : instructorList) {
                if (!logic.isFeedbackSessionCompletedByInstructor(session, instructor.email)) {
                    instructorsToRemindList.add(instructor);
                }
            }

            List<EmailWrapper> emails = new EmailGenerator().generateFeedbackSessionReminderEmails(
                    session, studentsToRemindList, instructorsToRemindList, instructorList);
            taskQueuer.scheduleEmailsForSending(emails);
        } catch (Exception e) {
            log.severe(""Unexpected error while sending emails: "" + TeammatesException.toStringWithStackTrace(e));
        }
    }

}
"
FeedbackSessionRemindParticularUsersEmailWorkerAction.java,ui-automated,"package teammates.ui.automated;

import java.util.ArrayList;
import java.util.List;

import teammates.common.datatransfer.attributes.FeedbackSessionAttributes;
import teammates.common.datatransfer.attributes.InstructorAttributes;
import teammates.common.datatransfer.attributes.StudentAttributes;
import teammates.common.exception.TeammatesException;
import teammates.common.util.Const.ParamsNames;
import teammates.common.util.EmailWrapper;
import teammates.common.util.Logger;
import teammates.logic.api.EmailGenerator;

/**
 * Task queue worker action: sends feedback session reminder email to particular students of a course.
 */
public class FeedbackSessionRemindParticularUsersEmailWorkerAction extends AutomatedAction {

    private static final Logger log = Logger.getLogger();

    @Override
    protected String getActionDescription() {
        return null;
    }

    @Override
    protected String getActionMessage() {
        return null;
    }

    @Override
    public void execute() {
        String feedbackSessionName = getNonNullRequestParamValue(ParamsNames.SUBMISSION_FEEDBACK);
        String courseId = getNonNullRequestParamValue(ParamsNames.SUBMISSION_COURSE);
        String[] usersToRemind = getNonNullRequestParamValues(ParamsNames.SUBMISSION_REMIND_USERLIST);

        try {
            FeedbackSessionAttributes session = logic.getFeedbackSession(feedbackSessionName, courseId);
            List<StudentAttributes> studentsToRemindList = new ArrayList<>();
            List<InstructorAttributes> instructorsToRemindList = new ArrayList<>();

            for (String userEmail : usersToRemind) {
                StudentAttributes student = logic.getStudentForEmail(courseId, userEmail);
                if (student != null) {
                    studentsToRemindList.add(student);
                }

                InstructorAttributes instructor = logic.getInstructorForEmail(courseId, userEmail);
                if (instructor != null) {
                    instructorsToRemindList.add(instructor);
                }
            }

            List<EmailWrapper> emails = new EmailGenerator().generateFeedbackSessionReminderEmails(
                    session, studentsToRemindList, instructorsToRemindList, new ArrayList<InstructorAttributes>());
            taskQueuer.scheduleEmailsForSending(emails);
        } catch (Exception e) {
            log.severe(""Unexpected error while sending emails: "" + TeammatesException.toStringWithStackTrace(e));
        }
    }

}
"
FeedbackSessionUnpublishedEmailWorkerAction.java,ui-automated,"package teammates.ui.automated;

import java.util.List;

import teammates.common.datatransfer.attributes.FeedbackSessionAttributes;
import teammates.common.exception.TeammatesException;
import teammates.common.util.Assumption;
import teammates.common.util.Const.ParamsNames;
import teammates.common.util.EmailWrapper;
import teammates.common.util.Logger;
import teammates.logic.api.EmailGenerator;

/**
 * Task queue worker action: prepares session unpublished reminder for a particular session to be sent.
 */
public class FeedbackSessionUnpublishedEmailWorkerAction extends AutomatedAction {

    private static final Logger log = Logger.getLogger();

    @Override
    protected String getActionDescription() {
        return null;
    }

    @Override
    protected String getActionMessage() {
        return null;
    }

    @Override
    public void execute() {
        String feedbackSessionName = getRequestParamValue(ParamsNames.EMAIL_FEEDBACK);
        Assumption.assertPostParamNotNull(ParamsNames.EMAIL_FEEDBACK, feedbackSessionName);

        String courseId = getRequestParamValue(ParamsNames.EMAIL_COURSE);
        Assumption.assertPostParamNotNull(ParamsNames.EMAIL_COURSE, courseId);

        FeedbackSessionAttributes session = logic.getFeedbackSession(feedbackSessionName, courseId);
        if (session == null) {
            log.severe(""Feedback session object for feedback session name: "" + feedbackSessionName
                       + "" for course: "" + courseId + "" could not be fetched."");
            return;
        }
        List<EmailWrapper> emailsToBeSent =
                new EmailGenerator().generateFeedbackSessionUnpublishedEmails(session);
        try {
            taskQueuer.scheduleEmailsForSending(emailsToBeSent);
            session.setSentPublishedEmail(false);
            logic.updateFeedbackSession(session);
        } catch (Exception e) {
            log.severe(""Unexpected error: "" + TeammatesException.toStringWithStackTrace(e));
        }
    }

}
"
InstructorCourseJoinEmailWorkerAction.java,ui-automated,"package teammates.ui.automated;

import teammates.common.datatransfer.attributes.AccountAttributes;
import teammates.common.datatransfer.attributes.CourseAttributes;
import teammates.common.datatransfer.attributes.InstructorAttributes;
import teammates.common.util.Assumption;
import teammates.common.util.Const.ParamsNames;
import teammates.common.util.EmailWrapper;
import teammates.logic.api.EmailGenerator;

/**
 * Task queue worker action: sends registration email for an instructor of a course.
 */
public class InstructorCourseJoinEmailWorkerAction extends AutomatedAction {

    @Override
    protected String getActionDescription() {
        return null;
    }

    @Override
    protected String getActionMessage() {
        return null;
    }

    @Override
    public void execute() {
        String inviterId = getRequestParamValue(ParamsNames.INVITER_ID);
        Assumption.assertPostParamNotNull(ParamsNames.INVITER_ID, inviterId);
        String courseId = getRequestParamValue(ParamsNames.COURSE_ID);
        Assumption.assertPostParamNotNull(ParamsNames.COURSE_ID, courseId);
        String instructorEmail = getRequestParamValue(ParamsNames.INSTRUCTOR_EMAIL);
        Assumption.assertPostParamNotNull(ParamsNames.INSTRUCTOR_EMAIL, instructorEmail);

        AccountAttributes inviter = logic.getAccount(inviterId);
        Assumption.assertNotNull(inviter);

        CourseAttributes course = logic.getCourse(courseId);
        Assumption.assertNotNull(course);

        InstructorAttributes instructor = logic.getInstructorForEmail(courseId, instructorEmail);
        Assumption.assertNotNull(instructor);

        EmailWrapper email = new EmailGenerator()
                .generateInstructorCourseJoinEmail(inviter, instructor, course);
        try {
            emailSender.sendEmail(email);
        } catch (Exception e) {
            throw new RuntimeException(""Unexpected error while sending email"", e);
        }
    }

}
"
package-info.java,ui-automated,"/**
 * Contains servlets and action classes for automated actions (i.e. cron jobs, task queue workers).
 */
package teammates.ui.automated;
"
SendEmailWorkerAction.java,ui-automated,"package teammates.ui.automated;

import teammates.common.exception.TeammatesException;
import teammates.common.util.Assumption;
import teammates.common.util.Const.ParamsNames;
import teammates.common.util.EmailWrapper;
import teammates.common.util.Logger;

/**
 * Task queue worker action: sends queued email.
 */
public class SendEmailWorkerAction extends AutomatedAction {

    private static final Logger log = Logger.getLogger();

    @Override
    protected String getActionDescription() {
        return null;
    }

    @Override
    protected String getActionMessage() {
        return null;
    }

    @Override
    public void execute() {
        String emailSubject = getRequestParamValue(ParamsNames.EMAIL_SUBJECT);
        Assumption.assertPostParamNotNull(ParamsNames.EMAIL_SUBJECT, emailSubject);

        String emailContent = getRequestParamValue(ParamsNames.EMAIL_CONTENT);
        Assumption.assertPostParamNotNull(ParamsNames.EMAIL_CONTENT, emailContent);

        String emailSenderEmail = getRequestParamValue(ParamsNames.EMAIL_SENDER);
        Assumption.assertPostParamNotNull(ParamsNames.EMAIL_SENDER, emailSenderEmail);

        String emailSenderName = getRequestParamValue(ParamsNames.EMAIL_SENDERNAME);

        String emailReceiver = getRequestParamValue(ParamsNames.EMAIL_RECEIVER);
        Assumption.assertPostParamNotNull(ParamsNames.EMAIL_RECEIVER, emailReceiver);

        String emailReply = getRequestParamValue(ParamsNames.EMAIL_REPLY_TO_ADDRESS);
        Assumption.assertPostParamNotNull(ParamsNames.EMAIL_REPLY_TO_ADDRESS, emailReply);

        EmailWrapper message = new EmailWrapper();
        message.setRecipient(emailReceiver);
        message.setSenderEmail(emailSenderEmail);
        if (emailSenderName != null) {
            message.setSenderName(emailSenderName);
        }
        message.setContent(emailContent);
        message.setSubject(emailSubject);
        message.setReplyTo(emailReply);

        try {
            emailSender.sendEmail(message);
        } catch (Exception e) {
            log.severe(""Error while sending email via servlet: "" + TeammatesException.toStringWithStackTrace(e));
            setForRetry();
        }
    }

}
"
StudentCourseJoinEmailWorkerAction.java,ui-automated,"package teammates.ui.automated;

import teammates.common.datatransfer.attributes.CourseAttributes;
import teammates.common.datatransfer.attributes.StudentAttributes;
import teammates.common.util.Assumption;
import teammates.common.util.Const.ParamsNames;
import teammates.common.util.EmailWrapper;
import teammates.logic.api.EmailGenerator;

/**
 * Task queue worker action: sends registration email for a student of a course.
 */
public class StudentCourseJoinEmailWorkerAction extends AutomatedAction {

    @Override
    protected String getActionDescription() {
        return null;
    }

    @Override
    protected String getActionMessage() {
        return null;
    }

    @Override
    public void execute() {
        String courseId = getRequestParamValue(ParamsNames.COURSE_ID);
        Assumption.assertPostParamNotNull(ParamsNames.COURSE_ID, courseId);
        String studentEmail = getRequestParamValue(ParamsNames.STUDENT_EMAIL);
        Assumption.assertPostParamNotNull(ParamsNames.STUDENT_EMAIL, studentEmail);
        String isRejoinString = getRequestParamValue(ParamsNames.IS_STUDENT_REJOINING);
        Assumption.assertPostParamNotNull(ParamsNames.IS_STUDENT_REJOINING, isRejoinString);
        boolean isRejoin = Boolean.parseBoolean(isRejoinString);

        CourseAttributes course = logic.getCourse(courseId);
        Assumption.assertNotNull(course);
        StudentAttributes student = logic.getStudentForEmail(courseId, studentEmail);
        Assumption.assertNotNull(student);

        EmailWrapper email = isRejoin
                ? new EmailGenerator().generateStudentCourseRejoinEmailAfterGoogleIdReset(course, student)
                : new EmailGenerator().generateStudentCourseJoinEmail(course, student);
        try {
            emailSender.sendEmail(email);
        } catch (Exception e) {
            throw new RuntimeException(""Unexpected error while sending email"", e);
        }
    }

}
"
Action.java,ui-controller,"package teammates.ui.controller;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpSession;

import teammates.common.datatransfer.UserType;
import teammates.common.datatransfer.attributes.AccountAttributes;
import teammates.common.datatransfer.attributes.StudentAttributes;
import teammates.common.exception.EntityDoesNotExistException;
import teammates.common.exception.EntityNotFoundException;
import teammates.common.exception.InvalidOriginException;
import teammates.common.exception.UnauthorizedAccessException;
import teammates.common.util.Assumption;
import teammates.common.util.Config;
import teammates.common.util.Const;
import teammates.common.util.CryptoHelper;
import teammates.common.util.HttpRequestHelper;
import teammates.common.util.LogMessageGenerator;
import teammates.common.util.SanitizationHelper;
import teammates.common.util.StatusMessage;
import teammates.common.util.StatusMessageColor;
import teammates.common.util.StringHelper;
import teammates.common.util.Url;
import teammates.logic.api.EmailSender;
import teammates.logic.api.GateKeeper;
import teammates.logic.api.Logic;
import teammates.logic.api.TaskQueuer;
import teammates.ui.pagedata.PageData;

/** An 'action' to be performed by the system. If the logged in user is allowed
 * to perform the requested action, this object can talk to the back end to
 * perform that action.
 */
public abstract class Action {

    /** This is used to ensure unregistered users don't access certain pages in the system. */
    public String regkey;

    /** The regkey may also contain a next url parameter as well. */
    public String nextUrlFromRegkey;

    /** This will be the admin user if the application is running under the masquerade mode. */
    public AccountAttributes loggedInUser;

    /** This is the 'nominal' user. Need not be the logged in user */
    public AccountAttributes account;

    /** This is the unregistered and not loggedin student's attributes. */
    public StudentAttributes student;

    protected Logic logic;
    protected GateKeeper gateKeeper;
    protected TaskQueuer taskQueuer;
    protected EmailSender emailSender;

    /** The full request URL e.g., {@code /page/instructorHome?user=abc&course=c1}. */
    protected String requestUrl;

    /** Parameters received with the request. */
    protected Map<String, String[]> requestParameters;

    /** Execution status info to be shown to he admin (in 'activity log'). */
    protected String statusToAdmin; // TODO: make this a list?

    /** Execution status info to be shown to the user. */
    protected List<StatusMessage> statusToUser = new ArrayList<>();

    /**
     * Whether the execution completed without any errors or
     * when we are unable to perform the requested action(s).
     **/
    protected boolean isError;

    /** Session that contains status message information. */
    protected HttpSession session;

    /** Session token used in forms/links to actions requiring origin validation. */
    protected String sessionToken;

    /** This is to get the blobInfo for any file upload from prev pages. */
    protected HttpServletRequest request;

    /** This is for authentication at Action Level. */
    private String authenticationRedirectUrl = """";

    /** Initializes variables.
     * Aborts with an {@link UnauthorizedAccessException} if the user is not
     * logged in or if a non-admin tried to masquerade as another user.
     *
     */
    public void init(HttpServletRequest req) {
        initialiseAttributes(req);
        validateOriginIfRequired();
        authenticateUser();
    }

    @SuppressWarnings(""unchecked"")
    protected void initialiseAttributes(HttpServletRequest req) {
        request = req;
        requestUrl = HttpRequestHelper.getRequestedUrl(request);
        logic = new Logic();
        gateKeeper = new GateKeeper();
        setTaskQueuer(new TaskQueuer());
        setEmailSender(new EmailSender());
        requestParameters = request.getParameterMap();
        session = request.getSession();
        sessionToken = CryptoHelper.computeSessionToken(session.getId());
        parseAndInitializeRegkeyFromRequest();
        // Set error status forwarded from the previous action
        isError = getRequestParamAsBoolean(Const.ParamsNames.ERROR);
    }

    /**
     * Parses and initializes the regkey from the http request.
     */
    private void parseAndInitializeRegkeyFromRequest() {
        String regkeyFromRequest = getRegkeyFromRequest();
        boolean isNextParamInRegkey = regkeyFromRequest != null
                                      && regkeyFromRequest.contains(""${amp}"" + Const.ParamsNames.NEXT_URL + ""="");
        if (isNextParamInRegkey) {
            /*
             * Here regkey may contain the nextUrl as well. This is due to
             * a workaround which replaces ""&"" with a placeholder ""${amp}"", thus the
             * next parameter, nextUrl, is treated as part of the ""regkey"".
             */
            String[] split = regkeyFromRequest.split(""\\$\\{amp\\}"" + Const.ParamsNames.NEXT_URL + ""="");
            regkey = split[0];
            nextUrlFromRegkey = SanitizationHelper.desanitizeFromNextUrl(split[1]);
        } else {
            regkey = regkeyFromRequest;
            nextUrlFromRegkey = null;
        }
    }

    public TaskQueuer getTaskQueuer() {
        return taskQueuer;
    }

    public void setTaskQueuer(TaskQueuer taskQueuer) {
        this.taskQueuer = taskQueuer;
    }

    public EmailSender getEmailSender() {
        return emailSender;
    }

    public void setEmailSender(EmailSender emailSender) {
        this.emailSender = emailSender;
    }

    // These methods are used for Cross-Site Request Forgery (CSRF) prevention

    private void validateOriginIfRequired() {
        if (!Const.SystemParams.PAGES_REQUIRING_ORIGIN_VALIDATION.contains(request.getRequestURI())) {
            return;
        }

        String referrer = request.getHeader(""referer"");
        if (referrer == null) {
            throw new InvalidOriginException(""Missing HTTP referrer"");
        }

        if (!isHttpReferrerValid(referrer)) {
            throw new InvalidOriginException(""Invalid HTTP referrer"");
        }

        String sessionToken = getRequestParamValue(Const.ParamsNames.SESSION_TOKEN);
        if (sessionToken == null) {
            throw new InvalidOriginException(""Missing session token"");
        }

        if (!isSessionTokenValid(sessionToken)) {
            throw new InvalidOriginException(""Invalid session token"");
        }
    }

    /**
     * Validates the HTTP referrer against the request URL. The origin is the
     * base URL of the HTTP referrer, which includes the protocol and authority
     * (host name + port number if specified). Similarly, the target is the base
     * URL of the requested action URL. For the referrer to be considered valid,
     * origin and target must match exactly. Otherwise, the request is likely to
     * be a CSRF attack, and is considered invalid.
     *
     * <p>Example of malicious request originating from embedded image in email:
     * <pre>
     * Request URL: https://teammatesv4.appspot.com/page/instructorCourseDelete?courseid=abcdef
     * Referrer:    https://mail.google.com/mail/u/0/
     *
     * Target: https://teammatesv4.appspot.com
     * Origin: https://mail.google.com
     * </pre>
     * Origin does not match target. This request is invalid.</p>
     *
     * <p>Example of legitimate request originating from instructor courses page:
     * <pre>
     * Request URL: https://teammatesv4.appspot.com/page/instructorCourseDelete?courseid=abcdef
     * Referrer:    https://teammatesv4.appspot.com/page/instructorCoursesPage
     *
     * Target: https://teammatesv4.appspot.com
     * Origin: https://teammatesv4.appspot.com
     * </pre>
     * Origin matches target. This request is valid.</p>
     */
    private boolean isHttpReferrerValid(String referrer) {
        String origin;
        try {
            origin = new Url(referrer).getBaseUrl();
        } catch (AssertionError e) { // due to MalformedURLException
            return false;
        }

        String requestUrl = request.getRequestURL().toString();
        String target = new Url(requestUrl).getBaseUrl();

        return origin.equals(target);
    }

    private boolean isSessionTokenValid(String actualToken) {
        String sessionId = request.getRequestedSessionId();
        if (sessionId == null) {
            // Newly-created session
            sessionId = session.getId();
        }

        String expectedToken = CryptoHelper.computeSessionToken(sessionId);

        return actualToken.equals(expectedToken);
    }

    // These methods are used for user authentication

    protected void authenticateUser() {
        UserType currentUser = gateKeeper.getCurrentUser();
        loggedInUser = authenticateAndGetActualUser(currentUser);
        if (isValidUser()) {
            account = authenticateAndGetNominalUser(currentUser);
        }
    }

    protected AccountAttributes authenticateAndGetActualUser(UserType currentUser) {
        if (doesUserNeedToLogin(currentUser)) {
            return null;
        }

        AccountAttributes loggedInUser = null;

        String email = getRequestParamValue(Const.ParamsNames.STUDENT_EMAIL);
        String courseId = getRequestParamValue(Const.ParamsNames.COURSE_ID);

        if (currentUser == null) {
            Assumption.assertPostParamNotNull(Const.ParamsNames.REGKEY, regkey);
            loggedInUser = authenticateNotLoggedInUser(email, courseId);
        } else {
            loggedInUser = logic.getAccount(currentUser.id);
            if (doesRegkeyMatchLoggedInUserGoogleId(currentUser.id)) {
                loggedInUser = createDummyAccountIfUserIsUnregistered(currentUser, loggedInUser);
            }
        }

        return loggedInUser;
    }

    /**
     * Retrieves registration key from the HTTP request.
     *
     * @return Registration key or null if key not in HTTP request
     */
    protected String getRegkeyFromRequest() {
        return getRequestParamValue(Const.ParamsNames.REGKEY);
    }

    protected AccountAttributes createDummyAccountIfUserIsUnregistered(UserType currentUser,
            AccountAttributes loggedInUser) {
        if (loggedInUser == null) { // Unregistered but loggedin user
            AccountAttributes newLoggedInUser = new AccountAttributes();
            newLoggedInUser.googleId = currentUser.id;
            return newLoggedInUser;
        }
        return loggedInUser;
    }

    protected boolean doesRegkeyMatchLoggedInUserGoogleId(
            String loggedInUserId) {
        if (regkey != null && loggedInUserId != null) {
            student = logic.getStudentForRegistrationKey(regkey);
            boolean isKnownKey = student != null;
            if (isKnownKey && student.isRegistered() && !loggedInUserId.equals(student.googleId)) {
                String expectedId = StringHelper.obscure(student.googleId);
                expectedId = StringHelper.encrypt(expectedId);
                String redirectUrl = Config.getAppUrl(Const.ActionURIs.LOGOUT)
                                          .withUserId(StringHelper.encrypt(loggedInUserId))
                                          .withParam(Const.ParamsNames.NEXT_URL, gateKeeper.getLoginUrl(requestUrl))
                                          .withParam(Const.ParamsNames.HINT, expectedId)
                                          .toString();

                setRedirectPage(redirectUrl);
                return false;
            }
        }
        return true;
    }

    protected AccountAttributes authenticateNotLoggedInUser(String email, String courseId) {
        student = logic.getStudentForRegistrationKey(regkey);
        boolean isUnknownKey = student == null;
        boolean isARegisteredUser = !isUnknownKey && student.googleId != null && !student.googleId.isEmpty();
        boolean isMissingAdditionalAuthenticationInfo = email == null || courseId == null;
        boolean isAuthenticationFailure = !isUnknownKey
                                          && (!student.email.equals(email) || !student.course.equals(courseId));

        AccountAttributes loggedInUser = null;

        if (isUnknownKey) {
            throw new UnauthorizedAccessException(""Unknown Registration Key "" + regkey);
        } else if (isARegisteredUser) {
            setRedirectPage(gateKeeper.getLoginUrl(requestUrl));
            return null;
        } else if (isNotLegacyLink() && isMissingAdditionalAuthenticationInfo) {
            throw new UnauthorizedAccessException(""Insufficient information to authenticate user"");
        } else if (isNotLegacyLink() && isAuthenticationFailure) {
            throw new UnauthorizedAccessException(""Invalid email/course for given Registration Key"");
        } else {
            // Unregistered and not logged in access given to page
            loggedInUser = new AccountAttributes();
            loggedInUser.email = student.email;
        }

        return loggedInUser;
    }

    private boolean isNotLegacyLink() {
        return !Const.SystemParams.LEGACY_PAGES_WITH_REDUCED_SECURITY.contains(request.getRequestURI());
    }

    private boolean doesUserNeedToLogin(UserType currentUser) {
        boolean isGoogleLoginRequired =
                !Const.SystemParams.PAGES_ACCESSIBLE_WITHOUT_GOOGLE_LOGIN.contains(request.getRequestURI());
        boolean isUserLoggedIn = currentUser != null;
        boolean hasRegkey = getRegkeyFromRequest() != null;

        if (!isUserLoggedIn && (isGoogleLoginRequired || !hasRegkey)) {
            setRedirectPage(gateKeeper.getLoginUrl(requestUrl));
            return true;
        }

        return false;
    }

    protected AccountAttributes authenticateAndGetNominalUser(UserType loggedInUserType) {
        String paramRequestedUserId = request.getParameter(Const.ParamsNames.USER_ID);

        AccountAttributes account = null;

        if (isMasqueradeModeRequested(loggedInUser, paramRequestedUserId)) {
            if (loggedInUserType.isAdmin) {
                // Allowing admin to masquerade as another user
                account = logic.getAccount(paramRequestedUserId);
                if (account == null) { // Unregistered user
                    if (regkey == null) {
                        // since admin is masquerading, fabricate a regkey
                        regkey = ""any-non-null-value"";
                    }
                    account = new AccountAttributes();
                    account.googleId = paramRequestedUserId;
                }
                return account;
            }
            throw new UnauthorizedAccessException(""User "" + loggedInUserType.id
                                                + "" is trying to masquerade as "" + paramRequestedUserId
                                                + "" without admin permission."");
        }

        account = loggedInUser;
        if (isPersistenceIssue() && isHomePage()) {
            // let the user go through as this is a persistence issue
        } else if (doesUserNeedRegistration(account) && !loggedInUserType.isAdmin) {
            if (regkey != null && student != null) {
                // TODO: encrypt the email as currently anyone with the regkey can
                //       get the email because of this redirect:
                String joinUrl = Config.getAppUrl(student.getRegistrationUrl())
                                    .withParam(Const.ParamsNames.NEXT_URL, requestUrl)
                                    .toString();
                setRedirectPage(joinUrl);
                return null;
            }

            throw new UnauthorizedAccessException(""Unregistered user for a page that needs registration"");
        }

        boolean isUserLoggedIn = account.googleId != null;
        if (isPageNotCourseJoinRelated() && doesRegkeyBelongToUnregisteredStudent() && isUserLoggedIn) {
            String redirectUrl = Config.getAppUrl(student.getRegistrationUrl())
                                  .withParam(Const.ParamsNames.NEXT_URL, requestUrl)
                                  .toString();
            setRedirectPage(redirectUrl);
            return null;
        }

        return account;
    }

    protected boolean isPersistenceIssue() {
        String persistenceCheckString1 =
                getRequestParamValue(Const.ParamsNames.CHECK_PERSISTENCE_COURSE);

        return persistenceCheckString1 != null;
    }

    private boolean isPageNotCourseJoinRelated() {
        String currentUri = request.getRequestURI();
        return !currentUri.equals(Const.ActionURIs.STUDENT_COURSE_JOIN)
               && !currentUri.equals(Const.ActionURIs.STUDENT_COURSE_JOIN_NEW)
               && !currentUri.equals(Const.ActionURIs.STUDENT_COURSE_JOIN_AUTHENTICATED);
    }

    private boolean isHomePage() {
        String currentUri = request.getRequestURI();
        return currentUri.equals(Const.ActionURIs.STUDENT_HOME_PAGE)
               || currentUri.equals(Const.ActionURIs.INSTRUCTOR_HOME_PAGE);
    }

    private boolean doesRegkeyBelongToUnregisteredStudent() {
        return student != null && !student.isRegistered();
    }

    private boolean doesUserNeedRegistration(AccountAttributes user) {
        boolean userNeedsRegistrationForPage =
                !Const.SystemParams.PAGES_ACCESSIBLE_WITHOUT_REGISTRATION.contains(request.getRequestURI())
                && !Const.SystemParams.PAGES_ACCESSIBLE_WITHOUT_GOOGLE_LOGIN.contains(request.getRequestURI());
        boolean userIsNotRegistered = user.createdAt == null;
        return userNeedsRegistrationForPage && userIsNotRegistered;
    }

    // These methods are used for CRUD operations on urls used for redirecting users to login page

    public boolean isValidUser() {
        return authenticationRedirectUrl.isEmpty();
    }

    private void setRedirectPage(String redirectUrl) {
        authenticationRedirectUrl = redirectUrl;
        statusToAdmin = ""Redirecting user to "" + redirectUrl;
    }

    public String getAuthenticationRedirectUrl() {
        return authenticationRedirectUrl;
    }

    /** ------------------------------------------------ */

    /**
     * Executes the action (as implemented by a child class). Before passing
     * the result to the caller, it does some post processing: <br>
     * 1. If the original request contained a URL to redirect after performing
     *    the action, the result will be replaced with a new 'redirect' type
     *    result. Note: Redirection is not allowed to third-party destinations. <br>
     * 2. User ID, error flag, and the status message will be added to the response,
     *    to be encoded into the URL. The error flag is also added to the
     *    {@code isError} flag in the {@link ActionResult} object.
     */
    public ActionResult executeAndPostProcess() {
        if (!isValidUser()) {
            return createRedirectResult(getAuthenticationRedirectUrl());
        }

        // get the result from the child class.
        ActionResult response;
        try {
            response = execute();
        } catch (EntityDoesNotExistException e) {
            throw new EntityNotFoundException(e);
        }

        // set error flag of the result
        response.isError = isError;

        // Set the common parameters for the response
        if (gateKeeper.getCurrentUser() != null) {
            response.responseParams.put(Const.ParamsNames.USER_ID, account.googleId);
        }

        if (regkey != null) {
            response.responseParams.put(Const.ParamsNames.REGKEY, getRegkeyFromRequest());

            if (student != null) {
                response.responseParams.put(Const.ParamsNames.STUDENT_EMAIL, student.email);
                response.responseParams.put(Const.ParamsNames.COURSE_ID, student.course);
            }

            if (getRequestParamValue(Const.ParamsNames.FEEDBACK_SESSION_NAME) != null) {
                response.responseParams.put(Const.ParamsNames.FEEDBACK_SESSION_NAME,
                        getRequestParamValue(Const.ParamsNames.FEEDBACK_SESSION_NAME));
            }
        }
        response.responseParams.put(Const.ParamsNames.ERROR, Boolean.toString(response.isError));

        // Pass status message using session to prevent XSS attack
        if (!response.getStatusMessage().isEmpty()) {
            putStatusMessageToSession(response);
        }

        return response;
    }

    /**
     * Adds the list of status messages from ActionResult into session variables.
     * @param response ActionResult
     */
    protected void putStatusMessageToSession(ActionResult response) {
        @SuppressWarnings(""unchecked"")
        List<StatusMessage> statusMessagesToUser =
                (List<StatusMessage>) session.getAttribute(Const.ParamsNames.STATUS_MESSAGES_LIST);

        if (statusMessagesToUser == null) {
            statusMessagesToUser = new ArrayList<>();
        }

        statusMessagesToUser.addAll(response.statusToUser);
        session.setAttribute(Const.ParamsNames.STATUS_MESSAGES_LIST, statusMessagesToUser);
    }

    /**
     * The method is expected to: <br>
     * 1. Check if the user has rights to execute this action. <br>
     * 2. Execute the action.<br>
     * 3. If the action requires showing a page, prepare the matching PageData object.<br>
     * 4. Set the status messages to be shown to the user (if any) and to the admin (compulsory).
     *    The latter is used for generating the adminActivityLogPage.
     */
    // TODO handle the EntityDoesNotExistException properly in the method body so it does not
    // have to be re-thrown here
    protected abstract ActionResult execute() throws EntityDoesNotExistException;

    /**
     * Returns The log message in the special format used for generating the 'activity log' for the Admin.
     */
    public String getLogMessage() {
        UserType currUser = gateKeeper.getCurrentUser();
        return new LogMessageGenerator().generatePageActionLogMessage(requestUrl, requestParameters, currUser,
                                                                      account, student, statusToAdmin);
    }

    /**
     * Returns null if the specified parameter was not found in the request.
     */
    public String getRequestParamValue(String paramName) {
        return HttpRequestHelper.getValueFromParamMap(requestParameters, paramName);
    }

    /**
     * Returns the value for the specified parameter expected to be present in the http request.
     * Assumption: the requested parameter is not null.
     *
     * @param paramName  a constant from the {@link Const.ParamsNames} class.
     */
    public String getNonNullRequestParamValue(String paramName) {
        return getNonNullRequestParamValues(paramName)[0];
    }

    /**
     * Returns null if the specified parameter was not found in the request.
     */
    public String[] getRequestParamValues(String paramName) {
        return HttpRequestHelper.getValuesFromParamMap(requestParameters, paramName);
    }

    /**
     * Returns the values for the specified parameter expected to be present in the http request.
     * Assumption: the requested parameter is not null.
     *
     * @param paramName  a constant from the {@link Const.ParamsNames} class.
     */
    public String[] getNonNullRequestParamValues(String paramName) {
        String[] values = getRequestParamValues(paramName);
        Assumption.assertPostParamNotNull(paramName, values);
        return values;
    }

    /**
     * Returns false if the specified parameter was not found in the request.
     */
    public boolean getRequestParamAsBoolean(String paramName) {
        return Boolean.parseBoolean(getRequestParamValue(paramName));
    }

    /**
     * Generates a {@link ShowPageResult} with the information in this object.
     */
    public ShowPageResult createShowPageResult(String destination, PageData pageData) {
        return new ShowPageResult(destination,
                                  account,
                                  pageData,
                                  statusToUser);
    }

    //TODO: Replace this with a overloaded constructor in AjaxResult?
    /**
     * Generates a {@link AjaxResult} with the information in this object.
     */
    public AjaxResult createAjaxResult(PageData pageData) {
        return new AjaxResult(account,
                              statusToUser,
                              pageData);
    }

    /**
     * Generates a {@link AjaxResult} with the information in the {@code pageData},
     * but without removing any status message from the session.
     */
    public AjaxResult createAjaxResultWithoutClearingStatusMessage(PageData pageData) {
        return new AjaxResult(account,
                              statusToUser,
                              pageData, false);
    }

    protected boolean isJoinedCourse(String courseId) {
        if (student == null) {
            return logic.getStudentForGoogleId(courseId, account.googleId) != null;
        }
        return true;
    }

    /**
     * Generates a {@link RedirectResult} with the information in this object.
     */
    public RedirectResult createRedirectResult(String destination) {
        return new RedirectResult(destination,
                                  account,
                                  statusToUser);
    }

    /**
     * Generates a {@link FileDownloadResult} with the information in this object.
     */
    public FileDownloadResult createFileDownloadResult(String fileName, String fileContent) {
        return new FileDownloadResult(""filedownload"",
                                      account,
                                      statusToUser,
                                      fileName,
                                      fileContent);
    }

    protected ActionResult createPleaseJoinCourseResponse(String courseId) {
        String errorMessage = ""You are not registered in the course "" + SanitizationHelper.sanitizeForHtml(courseId);
        statusToUser.add(new StatusMessage(errorMessage, StatusMessageColor.DANGER));
        isError = true;
        statusToAdmin = Const.ACTION_RESULT_FAILURE + "" : "" + errorMessage;
        return createRedirectResult(Const.ActionURIs.STUDENT_HOME_PAGE);
    }

    protected ActionResult createImageResult(String blobKey) {
        return new ImageResult(""imagedisplay"",
                               blobKey,
                               account,
                               statusToUser);
    }

    /**
     * Status messages to be shown to the user and the admin will be set based
     * on the error message in the exception {@code e}.<br>
     * {@code isError} is also set to true.
     */
    protected void setStatusForException(Exception e) {
        isError = true;

        String exceptionMessageForHtml = e.getMessage().replace(Const.EOL, Const.HTML_BR_TAG);
        statusToUser.add(new StatusMessage(exceptionMessageForHtml, StatusMessageColor.DANGER));
        statusToAdmin = Const.ACTION_RESULT_FAILURE + "" : "" + exceptionMessageForHtml;
    }

    /**
     * Status messages to be shown to the admin will be set based
     * on the error message in the exception {@code e}.<br>
     * Status message to be shown to the user will be set as {@code statusMessageToUser}.<br>
     * {@code isError} is also set to true.
     */
    protected void setStatusForException(Exception e, String statusMessageToUser) {
        isError = true;

        String statusMessageForHtml = statusMessageToUser.replace(Const.EOL, Const.HTML_BR_TAG);
        statusToUser.add(new StatusMessage(statusMessageForHtml, StatusMessageColor.DANGER));

        String exceptionMessageForHtml = e.getMessage().replace(Const.EOL, Const.HTML_BR_TAG);
        statusToAdmin = Const.ACTION_RESULT_FAILURE + "" : "" + exceptionMessageForHtml;
    }

    private boolean isMasqueradeModeRequested(AccountAttributes loggedInUser, String requestedUserId) {
        return loggedInUser != null && requestedUserId != null
               && !""null"".equals(requestedUserId.trim())
               && loggedInUser.googleId != null
               && !loggedInUser.googleId.equals(requestedUserId);
    }

    // ===================== Utility methods used by some child classes========

    protected void excludeStudentDetailsFromResponseParams() {
        regkey = null;
    }
}
"
ActionFactory.java,ui-controller,"package teammates.ui.controller;

// CHECKSTYLE.OFF:AvoidStarImport as there would be many (>100) import lines added if we were to import all of the ActionURIs
import static teammates.common.util.Const.ActionURIs.*;
// CHECKSTYLE.ON:AvoidStarImport

import java.util.HashMap;
import java.util.Map;

import javax.servlet.http.HttpServletRequest;

import teammates.common.exception.PageNotFoundException;
import teammates.common.exception.TeammatesException;
import teammates.common.util.Logger;

/**
 * Is used to generate the matching {@link Action} for a given URI.
 */
public class ActionFactory {
    private static final Logger log = Logger.getLogger();

    private static Map<String, Class<? extends Action>> actionMappings = new HashMap<>();

    static {
        map(ADMIN_HOME_PAGE, AdminHomePageAction.class);
        map(ADMIN_ACCOUNT_DELETE, AdminAccountDeleteAction.class);
        map(ADMIN_ACTIVITY_LOG_PAGE, AdminActivityLogPageAction.class);
        map(ADMIN_ACCOUNT_DETAILS_PAGE, AdminAccountDetailsPageAction.class);
        map(ADMIN_ACCOUNT_MANAGEMENT_PAGE, AdminAccountManagementPageAction.class);
        map(ADMIN_EXCEPTION_TEST, AdminExceptionTestAction.class);
        map(ADMIN_INSTRUCTORACCOUNT_ADD, AdminInstructorAccountAddAction.class);
        map(ADMIN_SESSIONS_PAGE, AdminSessionsPageAction.class);
        map(ADMIN_SEARCH_PAGE, AdminSearchPageAction.class);
        map(ADMIN_STUDENT_GOOGLE_ID_RESET, AdminStudentGoogleIdResetAction.class);
        map(ADMIN_EMAIL_COMPOSE_PAGE, AdminEmailComposePageAction.class);
        map(ADMIN_EMAIL_COMPOSE_SAVE, AdminEmailComposeSaveAction.class);
        map(ADMIN_EMAIL_COMPOSE_SEND, AdminEmailComposeSendAction.class);
        map(ADMIN_EMAIL_IMAGE_UPLOAD, AdminEmailImageUploadAction.class);
        map(ADMIN_EMAIL_GROUP_RECEIVER_LIST_UPLOAD, AdminEmailGroupReceiverListUploadAction.class);
        map(ADMIN_EMAIL_CREATE_IMAGE_UPLOAD_URL, AdminEmailCreateImageUploadUrlAction.class);
        map(ADMIN_EMAIL_CREATE_GROUP_RECEIVER_LIST_UPLOAD_URL, AdminEmailCreateGroupReceiverListUploadUrlAction.class);
        map(ADMIN_EMAIL_SENT_PAGE, AdminEmailSentPageAction.class);
        map(ADMIN_EMAIL_TRASH_PAGE, AdminEmailTrashPageAction.class);
        map(ADMIN_EMAIL_TRASH_DELETE, AdminEmailTrashDeleteAction.class);
        map(ADMIN_EMAIL_DRAFT_PAGE, AdminEmailDraftPageAction.class);
        map(ADMIN_EMAIL_MOVE_TO_TRASH, AdminEmailTrashAction.class);
        map(ADMIN_EMAIL_MOVE_OUT_TRASH, AdminEmailTrashAction.class);
        map(ADMIN_EMAIL_LOG_PAGE, AdminEmailLogPageAction.class);

        map(INSTRUCTOR_COURSES_PAGE, InstructorCoursesPageAction.class);
        map(INSTRUCTOR_COURSE_STATS_PAGE, CourseStatsPageAction.class);
        map(INSTRUCTOR_COURSE_ADD, InstructorCourseAddAction.class);
        map(INSTRUCTOR_COURSE_DELETE, InstructorCourseDeleteAction.class);
        map(INSTRUCTOR_COURSE_ARCHIVE, InstructorCourseArchiveAction.class);
        map(INSTRUCTOR_COURSE_DETAILS_PAGE, InstructorCourseDetailsPageAction.class);
        map(INSTRUCTOR_COURSE_JOIN, InstructorCourseJoinAction.class);
        map(INSTRUCTOR_COURSE_JOIN_AUTHENTICATED, InstructorCourseJoinAuthenticatedAction.class);
        map(INSTRUCTOR_COURSE_REMIND, InstructorCourseRemindAction.class);
        map(INSTRUCTOR_COURSE_EDIT_PAGE, InstructorCourseEditPageAction.class);
        map(INSTRUCTOR_COURSE_EDIT_SAVE, InstructorCourseEditSaveAction.class);
        map(INSTRUCTOR_COURSE_INSTRUCTOR_ADD, InstructorCourseInstructorAddAction.class);
        map(INSTRUCTOR_COURSE_INSTRUCTOR_EDIT_SAVE, InstructorCourseInstructorEditSaveAction.class);
        map(INSTRUCTOR_COURSE_INSTRUCTOR_DELETE, InstructorCourseInstructorDeleteAction.class);
        map(INSTRUCTOR_COURSE_ENROLL_PAGE, InstructorCourseEnrollPageAction.class);
        map(INSTRUCTOR_COURSE_ENROLL_SAVE, InstructorCourseEnrollSaveAction.class);
        map(INSTRUCTOR_COURSE_STUDENT_DELETE, InstructorCourseStudentDeleteAction.class);
        map(INSTRUCTOR_COURSE_STUDENT_DELETE_ALL, InstructorCourseStudentDeleteAllAction.class);
        map(INSTRUCTOR_COURSE_STUDENT_LIST_DOWNLOAD, InstructorCourseStudentListDownloadAction.class);
        map(INSTRUCTOR_COURSE_STUDENT_DETAILS_PAGE, InstructorCourseStudentDetailsPageAction.class);
        map(INSTRUCTOR_COURSE_STUDENT_DETAILS_EDIT, InstructorCourseStudentDetailsEditPageAction.class);
        map(INSTRUCTOR_COURSE_STUDENT_DETAILS_EDIT_SAVE, InstructorCourseStudentDetailsEditSaveAction.class);
        map(INSTRUCTOR_EDIT_STUDENT_FEEDBACK_PAGE, InstructorEditStudentFeedbackPageAction.class);
        map(INSTRUCTOR_EDIT_STUDENT_FEEDBACK_SAVE, InstructorEditStudentFeedbackSaveAction.class);
        map(INSTRUCTOR_EDIT_INSTRUCTOR_FEEDBACK_PAGE, InstructorEditInstructorFeedbackPageAction.class);
        map(INSTRUCTOR_EDIT_INSTRUCTOR_FEEDBACK_SAVE, InstructorEditInstructorFeedbackSaveAction.class);
        map(INSTRUCTOR_FEEDBACK_SESSIONS_PAGE, InstructorFeedbackSessionsPageAction.class);
        map(INSTRUCTOR_FEEDBACK_ADD, InstructorFeedbackAddAction.class);
        map(INSTRUCTOR_FEEDBACK_COPY, InstructorFeedbackCopyAction.class);
        map(INSTRUCTOR_FEEDBACK_DELETE, InstructorFeedbackDeleteAction.class);
        map(INSTRUCTOR_FEEDBACK_EDIT_COPY_PAGE, InstructorFeedbackEditCopyPageAction.class);
        map(INSTRUCTOR_FEEDBACK_EDIT_COPY, InstructorFeedbackEditCopyAction.class);
        map(INSTRUCTOR_FEEDBACK_EDIT_PAGE, InstructorFeedbackEditPageAction.class);
        map(INSTRUCTOR_FEEDBACK_EDIT_SAVE, InstructorFeedbackEditSaveAction.class);
        map(INSTRUCTOR_FEEDBACK_REMIND, InstructorFeedbackRemindAction.class);
        map(INSTRUCTOR_FEEDBACK_REMIND_PARTICULAR_STUDENTS_PAGE, InstructorFeedbackRemindParticularStudentsPageAction.class);
        map(INSTRUCTOR_FEEDBACK_REMIND_PARTICULAR_STUDENTS, InstructorFeedbackRemindParticularStudentsAction.class);
        map(INSTRUCTOR_FEEDBACK_PUBLISH, InstructorFeedbackPublishAction.class);
        map(INSTRUCTOR_FEEDBACK_UNPUBLISH, InstructorFeedbackUnpublishAction.class);
        map(INSTRUCTOR_FEEDBACK_QUESTION_ADD, InstructorFeedbackQuestionAddAction.class);
        map(INSTRUCTOR_FEEDBACK_QUESTION_COPY_PAGE, InstructorFeedbackQuestionCopyPageAction.class);
        map(INSTRUCTOR_FEEDBACK_QUESTION_COPY, InstructorFeedbackQuestionCopyAction.class);
        map(INSTRUCTOR_FEEDBACK_QUESTION_EDIT, InstructorFeedbackQuestionEditAction.class);
        map(INSTRUCTOR_FEEDBACK_QUESTION_VISIBILITY_MESSAGE, InstructorFeedbackQuestionVisibilityMessageAction.class);
        map(INSTRUCTOR_FEEDBACK_RESULTS_PAGE, InstructorFeedbackResultsPageAction.class);
        map(INSTRUCTOR_FEEDBACK_RESULTS_DOWNLOAD, InstructorFeedbackResultsDownloadAction.class);
        map(INSTRUCTOR_FEEDBACK_RESPONSE_COMMENT_ADD, InstructorFeedbackResponseCommentAddAction.class);
        map(INSTRUCTOR_FEEDBACK_RESPONSE_COMMENT_EDIT, InstructorFeedbackResponseCommentEditAction.class);
        map(INSTRUCTOR_FEEDBACK_RESPONSE_COMMENT_DELETE, InstructorFeedbackResponseCommentDeleteAction.class);
        map(INSTRUCTOR_FEEDBACK_PREVIEW_ASSTUDENT, InstructorFeedbackPreviewAsStudentAction.class);
        map(INSTRUCTOR_FEEDBACK_PREVIEW_ASINSTRUCTOR, InstructorFeedbackPreviewAsInstructorAction.class);
        map(INSTRUCTOR_FEEDBACK_STATS_PAGE, FeedbackSessionStatsPageAction.class);
        map(INSTRUCTOR_FEEDBACK_SUBMISSION_EDIT_PAGE, InstructorFeedbackSubmissionEditPageAction.class);
        map(INSTRUCTOR_FEEDBACK_SUBMISSION_EDIT_SAVE, InstructorFeedbackSubmissionEditSaveAction.class);
        map(INSTRUCTOR_HOME_PAGE, InstructorHomePageAction.class);
        map(INSTRUCTOR_SEARCH_PAGE, InstructorSearchPageAction.class);
        map(INSTRUCTOR_STUDENT_LIST_PAGE, InstructorStudentListPageAction.class);
        map(INSTRUCTOR_STUDENT_LIST_AJAX_PAGE, InstructorStudentListAjaxPageAction.class);
        map(INSTRUCTOR_STUDENT_RECORDS_PAGE, InstructorStudentRecordsPageAction.class);
        map(INSTRUCTOR_STUDENT_RECORDS_AJAX_PAGE, InstructorStudentRecordsAjaxPageAction.class);

        map(STUDENT_COURSE_DETAILS_PAGE, StudentCourseDetailsPageAction.class);
        map(STUDENT_COURSE_JOIN, StudentCourseJoinAction.class);
        map(STUDENT_COURSE_JOIN_NEW, StudentCourseJoinAction.class);
        map(STUDENT_COURSE_JOIN_AUTHENTICATED, StudentCourseJoinAuthenticatedAction.class);
        map(STUDENT_FEEDBACK_RESULTS_PAGE, StudentFeedbackResultsPageAction.class);
        map(STUDENT_FEEDBACK_SUBMISSION_EDIT_PAGE, StudentFeedbackSubmissionEditPageAction.class);
        map(STUDENT_FEEDBACK_SUBMISSION_EDIT_SAVE, StudentFeedbackSubmissionEditSaveAction.class);
        map(STUDENT_PROFILE_PAGE, StudentProfilePageAction.class);
        map(STUDENT_PROFILE_PICTURE, StudentProfilePictureAction.class);
        map(STUDENT_PROFILE_PICTURE_UPLOAD, StudentProfilePictureUploadAction.class);
        map(STUDENT_PROFILE_PICTURE_EDIT, StudentProfilePictureEditAction.class);
        map(STUDENT_PROFILE_CREATEUPLOADFORMURL, StudentProfileCreateFormUrlAction.class);
        map(STUDENT_PROFILE_EDIT_SAVE, StudentProfileEditSaveAction.class);
        map(STUDENT_HOME_PAGE, StudentHomePageAction.class);

        map(CREATE_IMAGE_UPLOAD_URL, CreateImageUploadUrlAction.class);
        map(IMAGE_UPLOAD, ImageUploadAction.class);
    }

    /**
     * Returns the matching {@link Action} object for the URI in the {@code req}.
     */
    public Action getAction(HttpServletRequest req) {

        String url = req.getRequestURL().toString();
        log.info(""URL received : ["" + req.getMethod() + ""] "" + url);

        String uri = req.getRequestURI();
        if (uri.contains("";"")) {
            uri = uri.split("";"")[0];
        }
        Action c = getAction(uri);
        c.init(req);
        return c;

    }

    private static Action getAction(String uri) {
        Class<? extends Action> controllerClass = actionMappings.get(uri);

        if (controllerClass == null) {
            throw new PageNotFoundException(uri);
        }

        try {
            return controllerClass.newInstance();
        } catch (Exception e) {
            throw new RuntimeException(""Could not create the action for "" + uri + "": ""
                                       + TeammatesException.toStringWithStackTrace(e));
        }

    }

    private static void map(String actionUri, Class<? extends Action> actionClass) {
        actionMappings.put(actionUri, actionClass);
    }

}
"
ActionResult.java,ui-controller,"package teammates.ui.controller;

import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.servlet.ServletException;
import javax.servlet.http.Cookie;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import teammates.common.datatransfer.attributes.AccountAttributes;
import teammates.common.util.Const;
import teammates.common.util.CryptoHelper;
import teammates.common.util.HttpRequestHelper;
import teammates.common.util.StatusMessage;
import teammates.common.util.StringHelper;
import teammates.common.util.Url;

/**
 * The result of executing an {@link Action}.
 */
public abstract class ActionResult {

    /** The URI that represents the result.
     * e.g., ""/page/instructorHome"" ""/jsp/instructorHome.jsp""
     */
    public String destination;

    /** True if the action did not complete successfully. */
    public boolean isError;

    /** The 'nominal' user for whom the action was executed. */
    protected AccountAttributes account;

    /** A list of status messages to be shown to the user. */
    protected List<StatusMessage> statusToUser = new ArrayList<>();

    /**
     * Parameters to be sent with the result. These will be automatically added
     * to the {@code destination} of the result. For example, if the {@code destination}
     * is {@code /page/instructorHome} and if we have {@code user=abc} in this map,
     * the result will be sent to {@code /page/instructorHome?user=abc}
     */
    protected Map<String, String> responseParams = new HashMap<>();

    public ActionResult(
            String destination,
            AccountAttributes account,
            List<StatusMessage> status) {

        this.destination = destination;
        this.account = account;
        this.statusToUser = status;
    }

    /**
     * Returns Concatenated version of the status messages collected during the
     *         execution of the action. Messages are separated by {@code '<br>'}
     */
    public String getStatusMessage() {
        List<String> statusMessageTexts = new ArrayList<>();

        for (StatusMessage msg : statusToUser) {
            statusMessageTexts.add(msg.getText());
        }

        return StringHelper.toString(statusMessageTexts, ""<br>"");
    }

    public String getStatusMessageColor() {
        return statusToUser == null || statusToUser.isEmpty() ? ""info"" : statusToUser.get(0).getColor();
    }

    /**
     * Add a (key,value) pair ot the list of response parameters.
     */
    public void addResponseParam(String key, String value) {
        responseParams.put(key, value);
    }

    /**
     * Returns Destination of the result, including parameters.
     *         e.g. {@code /page/instructorHome?user=abc}
     */
    public String getDestinationWithParams() {
        return appendParameters(destination, responseParams);
    }

    /**
     * Compute session token a.k.a CSRF token from request session ID and write to cookie in response.
     * Don't set if a valid token already exists.
     * This cookie is used to add CSRF tokens to dynamically-generated links from JS code on the front-end.
     */
    public void writeSessionTokenToCookieIfRequired(HttpServletRequest req, HttpServletResponse resp) {
        String sessionToken = CryptoHelper.computeSessionToken(req.getSession().getId());
        String existingSessionToken = HttpRequestHelper.getCookieValueFromRequest(req, Const.ParamsNames.SESSION_TOKEN);

        if (sessionToken.equals(existingSessionToken)) {
            return;
        }

        resp.addCookie(new Cookie(Const.ParamsNames.SESSION_TOKEN, sessionToken));
    }

    /**
     * Sends the result to the intended URL.
     */
    public abstract void send(HttpServletRequest req, HttpServletResponse resp)
            throws IOException, ServletException;

    private String appendParameters(String url, Map<String, String> params) {
        String returnValue = url;
        for (Map.Entry<String, String> entry : params.entrySet()) {
            returnValue = Url.addParamToUrl(returnValue, entry.getKey(), entry.getValue());
        }
        return returnValue;
    }
}
"
AdminAccountDeleteAction.java,ui-controller,"package teammates.ui.controller;

import teammates.common.datatransfer.attributes.InstructorAttributes;
import teammates.common.datatransfer.attributes.StudentAttributes;
import teammates.common.util.Const;
import teammates.common.util.StatusMessage;
import teammates.common.util.StatusMessageColor;

public class AdminAccountDeleteAction extends Action {

    @Override
    protected ActionResult execute() {

        gateKeeper.verifyAdminPrivileges(account);

        String instructorId = getRequestParamValue(Const.ParamsNames.INSTRUCTOR_ID);
        String courseId = getRequestParamValue(Const.ParamsNames.COURSE_ID);
        String account = getRequestParamValue(""account"");

        //TODO: We should extract these into separate actions e.g., AdminInstructorDowngradeAction
        if (courseId == null && account == null) {
            //delete instructor status
            logic.downgradeInstructorToStudentCascade(instructorId);
            statusToUser.add(new StatusMessage(Const.StatusMessages.INSTRUCTOR_STATUS_DELETED, StatusMessageColor.SUCCESS));
            statusToAdmin = ""Instructor Status for <span class=\""bold\"">"" + instructorId + ""</span> has been deleted."";
            return createRedirectResult(Const.ActionURIs.ADMIN_ACCOUNT_MANAGEMENT_PAGE);
        }

        if (courseId == null && account != null) {
            //delete entire account
            logic.deleteAccount(instructorId);
            statusToUser.add(new StatusMessage(Const.StatusMessages.INSTRUCTOR_ACCOUNT_DELETED, StatusMessageColor.SUCCESS));
            statusToAdmin = ""Instructor Account for <span class=\""bold\"">"" + instructorId + ""</span> has been deleted."";
            return createRedirectResult(Const.ActionURIs.ADMIN_ACCOUNT_MANAGEMENT_PAGE);
        }

        String studentId = getRequestParamValue(Const.ParamsNames.STUDENT_ID);
        if (courseId != null && studentId != null) {
            //remove student from course
            StudentAttributes student = logic.getStudentForGoogleId(courseId, studentId);
            logic.deleteStudent(courseId, student.email);
            statusToUser.add(new StatusMessage(Const.StatusMessages.STUDENT_DELETED,
                                               StatusMessageColor.SUCCESS));
            statusToAdmin = ""Instructor <span class=\""bold\"">"" + instructorId
                            + ""</span>'s student status in Course""
                            + ""<span class=\""bold\"">["" + courseId + ""]</span> has been deleted"";
            return createRedirectResult(Const.ActionURIs.ADMIN_ACCOUNT_DETAILS_PAGE + ""?instructorid="" + studentId);
        }

        //remove instructor from course
        InstructorAttributes instructor = logic.getInstructorForGoogleId(courseId, instructorId);
        logic.deleteInstructor(courseId, instructor.email);
        statusToUser.add(new StatusMessage(Const.StatusMessages.INSTRUCTOR_REMOVED_FROM_COURSE, StatusMessageColor.SUCCESS));
        statusToAdmin = ""Instructor <span class=\""bold\"">"" + instructorId
                      + ""</span> has been deleted from Course<span class=\""bold\"">["" + courseId + ""]</span>"";
        return createRedirectResult(Const.ActionURIs.ADMIN_ACCOUNT_DETAILS_PAGE + ""?instructorid="" + instructorId);
    }

}
"
AdminAccountDetailsPageAction.java,ui-controller,"package teammates.ui.controller;

import java.util.ArrayList;
import java.util.List;

import teammates.common.datatransfer.CourseDetailsBundle;
import teammates.common.datatransfer.attributes.AccountAttributes;
import teammates.common.datatransfer.attributes.CourseAttributes;
import teammates.common.exception.EntityDoesNotExistException;
import teammates.common.util.Const;
import teammates.ui.pagedata.AdminAccountDetailsPageData;

public class AdminAccountDetailsPageAction extends Action {

    @Override
    protected ActionResult execute() {

        gateKeeper.verifyAdminPrivileges(account);

        String googleId = getRequestParamValue(Const.ParamsNames.INSTRUCTOR_ID);
        AccountAttributes accountInformation = logic.getAccount(googleId);

        List<CourseDetailsBundle> instructorCourseList;
        try {
            instructorCourseList = new ArrayList<>(logic.getCourseSummariesForInstructor(googleId).values());
        } catch (EntityDoesNotExistException e) {
            //Not an instructor of any course
            instructorCourseList = null;
        }

        List<CourseAttributes> studentCourseList;
        try {
            studentCourseList = logic.getCoursesForStudentAccount(googleId);
        } catch (EntityDoesNotExistException e) {
            //Not a student of any course
            studentCourseList = null;
        }

        AdminAccountDetailsPageData data = new AdminAccountDetailsPageData(account, sessionToken, accountInformation,
                                                                           instructorCourseList, studentCourseList);
        statusToAdmin = ""adminAccountDetails Page Load<br>""
                + ""Viewing details for "" + data.getAccountInformation().name + ""("" + googleId + "")"";

        return createShowPageResult(Const.ViewURIs.ADMIN_ACCOUNT_DETAILS, data);
    }

}
"
AdminAccountManagementPageAction.java,ui-controller,"package teammates.ui.controller;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import teammates.common.datatransfer.attributes.AccountAttributes;
import teammates.common.datatransfer.attributes.InstructorAttributes;
import teammates.common.util.Const;
import teammates.ui.pagedata.AdminAccountManagementPageData;

public class AdminAccountManagementPageAction extends Action {

    @Override
    protected ActionResult execute() {
        gateKeeper.verifyAdminPrivileges(account);

        String instructorGoogleId = this.getRequestParamValue(""googleId"");
        if (instructorGoogleId == null) {
            instructorGoogleId = """";
        }

        Map<String, ArrayList<InstructorAttributes>> instructorCoursesTable = new HashMap<>();
        Map<String, AccountAttributes> instructorAccountsTable = new HashMap<>();

        List<InstructorAttributes> instructorsList = logic.getInstructorsForGoogleId(instructorGoogleId);
        AccountAttributes instructorAccount = logic.getAccount(instructorGoogleId);

        boolean isToShowAll = this.getRequestParamAsBoolean(""all"");
        boolean isAccountExisting = instructorAccount != null;
        if (isAccountExisting) {
            instructorAccountsTable.put(instructorAccount.googleId, instructorAccount);

            for (InstructorAttributes instructor : instructorsList) {
                ArrayList<InstructorAttributes> courseList = instructorCoursesTable.get(instructor.googleId);
                if (courseList == null) {
                    courseList = new ArrayList<>();
                    instructorCoursesTable.put(instructor.googleId, courseList);
                }

                courseList.add(instructor);
            }
        }

        AdminAccountManagementPageData data = new AdminAccountManagementPageData(account, sessionToken,
                instructorAccountsTable, instructorCoursesTable, isToShowAll);

        statusToAdmin = ""Admin Account Management Page Load<br>""
                        + ""<span class=\""bold\"">Total Instructors:</span> "" + instructorAccountsTable.size();

        return createShowPageResult(Const.ViewURIs.ADMIN_ACCOUNT_MANAGEMENT, data);
    }

}
"
AdminActivityLogPageAction.java,ui-controller,"package teammates.ui.controller;

import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.LinkedList;
import java.util.List;

import com.google.appengine.api.log.AppLogLine;

import teammates.common.datatransfer.attributes.CourseAttributes;
import teammates.common.datatransfer.attributes.FeedbackSessionAttributes;
import teammates.common.exception.EntityDoesNotExistException;
import teammates.common.util.ActivityLogEntry;
import teammates.common.util.AdminLogQuery;
import teammates.common.util.Const;
import teammates.common.util.GaeLogApi;
import teammates.common.util.GaeVersionApi;
import teammates.common.util.StatusMessage;
import teammates.common.util.StatusMessageColor;
import teammates.common.util.TimeHelper;
import teammates.common.util.Version;
import teammates.ui.pagedata.AdminActivityLogPageData;

public class AdminActivityLogPageAction extends Action {
    private static final int RELEVANT_LOGS_PER_PAGE = 50;
    /**
     * The maximum time period to retrieve logs with time increment.
     */
    private static final int MAX_SEARCH_PERIOD = 24 * 60 * 60 * 1000; // 24 hrs in milliseconds
    private static final int SEARCH_TIME_INCREMENT = 2 * 60 * 60 * 1000; // two hours in milliseconds
    /*
     * The maximum number of times to retrieve logs with time increment.
     */
    private static final int MAX_SEARCH_TIMES = MAX_SEARCH_PERIOD / SEARCH_TIME_INCREMENT;
    /**
     * Maximum number of versions to query.
     */
    private static final int MAX_VERSIONS_TO_QUERY = 1 + 5; //the current version and its 5 preceding versions

    private int totalLogsSearched;
    private Long nextEndTimeToSearch;

    @Override
    protected ActionResult execute() {
        gateKeeper.verifyAdminPrivileges(account);

        AdminActivityLogPageData data = new AdminActivityLogPageData(account, sessionToken);

        String searchTimeOffset = getRequestParamValue(""searchTimeOffset"");
        if (searchTimeOffset == null) {
            searchTimeOffset = """";
        }

        String logRoleFromAjax = getRequestParamValue(""logRole"");
        String logGoogleIdFromAjax = getRequestParamValue(""logGoogleId"");
        String logTimeInAdminTimeZoneFromAjax = getRequestParamValue(""logTimeInAdminTimeZone"");

        boolean isLoadingLocalTimeAjax = logRoleFromAjax != null
                                         && logGoogleIdFromAjax != null
                                         && logTimeInAdminTimeZoneFromAjax != null;

        if (isLoadingLocalTimeAjax) {
            data.setLogLocalTime(getLocalTimeInfo(logGoogleIdFromAjax,
                                                  logRoleFromAjax,
                                                  logTimeInAdminTimeZoneFromAjax));
            return createAjaxResult(data);
        }

        // This parameter determines whether the logs with requests contained in ""excludedLogRequestURIs""
        // in AdminActivityLogPageData should be shown. Use ""?all=true"" in URL to show all logs.
        // This will keep showing all logs despite any action or change in the page unless
        // the page is reloaded with ""?all=false"" or simply reloaded with this parameter omitted.
        boolean shouldShowAllLogs = getRequestParamAsBoolean(""all"");
        data.setShowAllLogs(shouldShowAllLogs);

        // This determines whether the logs related to testing data should be shown. Use ""testdata=true"" in URL
        // to show all testing logs. This will keep showing all logs from testing data despite any action
        // or change in the page unless the page is reloaded with ""?testdata=false""
        // or simply reloaded with this parameter omitted.
        boolean shouldShowTestData = getRequestParamAsBoolean(""testdata"");
        data.setShowTestData(shouldShowTestData);

        String filterQuery = getRequestParamValue(""filterQuery"");
        if (filterQuery == null) {
            filterQuery = """";
        }
        //This is used to parse the filterQuery. If the query is not parsed, the filter function would ignore the query
        data.generateQueryParameters(filterQuery);

        boolean isContinueFromPreviousSearch = !data.isFromDateSpecifiedInQuery() && !searchTimeOffset.isEmpty();
        if (isContinueFromPreviousSearch) {
            data.setToDate(Long.parseLong(searchTimeOffset));
        }

        List<String> versionToQuery = getVersionsForQuery(data.getVersions());
        AdminLogQuery query = new AdminLogQuery(versionToQuery, data.getFromDate(), data.getToDate());

        List<ActivityLogEntry> logs = null;
        if (data.isFromDateSpecifiedInQuery()) {
            logs = searchLogsWithExactTimePeriod(query, data);
        } else {
            logs = searchLogsWithTimeIncrement(query, data);
        }

        String courseIdFromSearchPage = getRequestParamValue(""courseId"");
        generateStatusMessage(versionToQuery, data, logs, courseIdFromSearchPage);
        data.init(logs);

        if (searchTimeOffset.isEmpty()) {
            return createShowPageResult(Const.ViewURIs.ADMIN_ACTIVITY_LOG, data);
        }

        return createShowPageResult(Const.ViewURIs.ADMIN_ACTIVITY_LOG_AJAX, data);
    }

    /**
     * Selects versions for query. If versions are not specified, it will return
     * MAX_VERSIONS_TO_QUERY most recent versions used for query.
     */
    private List<String> getVersionsForQuery(List<String> versions) {
        boolean isVersionSpecifiedInRequest = versions != null && !versions.isEmpty();
        if (isVersionSpecifiedInRequest) {
            return versions;
        }
        GaeVersionApi versionApi = new GaeVersionApi();
        return versionApi.getMostRecentVersions(MAX_VERSIONS_TO_QUERY);
    }

    private void generateStatusMessage(List<String> versionToQuery,
                                       AdminActivityLogPageData data,
                                       List<ActivityLogEntry> logs, String courseId) {
        StringBuilder status = new StringBuilder(500);
        status.append(""Total Logs gone through in last search: "" + totalLogsSearched
                    + ""<br>Total Relevant Logs found in last search: ""
                    + String.format(""%s<br>"", logs.size()));

        long earliestSearchTime = data.getFromDate();
        ActivityLogEntry earliestLogChecked = null;
        if (!logs.isEmpty()) {
            earliestLogChecked = logs.get(logs.size() - 1);
        }
        //  if the search space is limited to a certain log
        if (logs.size() >= RELEVANT_LOGS_PER_PAGE && earliestLogChecked != null) {
            earliestSearchTime = earliestLogChecked.getLogTime();
        }

        double targetTimeZone = Const.DOUBLE_UNINITIALIZED;
        if (data.isPersonSpecified()) {
            String targetUserGoogleId = data.getPersonSpecified();
            targetTimeZone = getLocalTimeZoneForRequest(targetUserGoogleId, """");

            if (targetTimeZone == Const.DOUBLE_UNINITIALIZED && courseId != null && !courseId.isEmpty()) {
                // if the user is unregistered, try finding the timezone by course id passed from Search page
                targetTimeZone = getLocalTimeZoneForUnregisteredUserRequest(courseId);
            }
        } else {
            targetTimeZone = Const.SystemParams.ADMIN_TIME_ZONE_DOUBLE;
        }

        double adminTimeZone = Const.SystemParams.ADMIN_TIME_ZONE_DOUBLE;
        String timeInAdminTimeZone = computeTimeWithOffset(adminTimeZone, earliestSearchTime);
        String timeInUserTimeZone = computeTimeWithOffset(targetTimeZone, earliestSearchTime);

        status.append(""The earliest log entry checked on <b>"" + timeInAdminTimeZone + ""</b> in Admin Time Zone (""
                      + adminTimeZone + "") and "");
        if (targetTimeZone == Const.DOUBLE_UNINITIALIZED) {
            status.append(timeInUserTimeZone).append("".<br>"");
        } else {
            status.append(""on <b>"" + timeInUserTimeZone + ""</b> in Local Time Zone ("" + targetTimeZone + "").<br>"");
        }

        status.append(""Logs are from following version(s): "");
        for (int i = 0; i < versionToQuery.size(); i++) {
            String version = versionToQuery.get(i).replace('-', '.');
            if (i < versionToQuery.size() - 1) {
                status.append(version).append("", "");
            } else {
                status.append(version).append(""<br>"");
            }
        }

        status.append(""All available version(s): "");
        GaeVersionApi versionApi = new GaeVersionApi();
        List<Version> versionList = versionApi.getAvailableVersions();
        for (int i = 0; i < versionList.size(); i++) {
            String version = versionList.get(i).toString();
            if (i < versionList.size() - 1) {
                status.append(version).append("", "");
            } else {
                status.append(version).append(""<br>"");
            }
        }

        // the ""Search More"" button to continue searching from the previous fromDate
        status.append(""<button class=\""btn-link\"" id=\""button_older\"" data-next-end-time-to-search=\""""
                      + nextEndTimeToSearch
                      + ""\"">Search More</button><input id=\""ifShowAll\"" type=\""hidden\"" value=\""""
                      + data.getShouldShowAllLogs()
                      + ""\""/><input id=\""ifShowTestData\"" type=\""hidden\"" value=\""""
                      + data.getShouldShowTestData() + ""\""/>"");

        String statusString = status.toString();
        data.setStatusForAjax(statusString);
        statusToUser.add(new StatusMessage(statusString, StatusMessageColor.INFO));
    }

    /**
     * Retrieves enough logs within MAX_SEARCH_PERIOD hours.
     */
    private List<ActivityLogEntry> searchLogsWithTimeIncrement(AdminLogQuery query, AdminActivityLogPageData data) {
        List<ActivityLogEntry> appLogs = new LinkedList<>();

        totalLogsSearched = 0;
        GaeLogApi logApi = new GaeLogApi();

        long startTime = query.getEndTime() - SEARCH_TIME_INCREMENT;
        query.setTimePeriod(startTime, query.getEndTime());

        for (int i = 0; i < MAX_SEARCH_TIMES; i++) {
            if (appLogs.size() >= RELEVANT_LOGS_PER_PAGE) {
                break;
            }
            List<AppLogLine> searchResult = logApi.fetchLogs(query);
            List<ActivityLogEntry> filteredLogs = filterLogsForActivityLogPage(searchResult, data);
            appLogs.addAll(filteredLogs);
            totalLogsSearched += searchResult.size();
            query.moveTimePeriodBackward(SEARCH_TIME_INCREMENT);
        }
        data.setFromDate(query.getStartTime() + SEARCH_TIME_INCREMENT);
        nextEndTimeToSearch = query.getEndTime();
        return appLogs;
    }

    /**
     * Retrieves all logs in the time period specified in the query.
     */
    private List<ActivityLogEntry> searchLogsWithExactTimePeriod(AdminLogQuery query, AdminActivityLogPageData data) {
        GaeLogApi logApi = new GaeLogApi();
        List<AppLogLine> searchResult = logApi.fetchLogs(query);

        nextEndTimeToSearch = data.getFromDate() - 1;
        totalLogsSearched = searchResult.size();
        return filterLogsForActivityLogPage(searchResult, data);
    }

    /**
     * Filters logs that should be shown on Admin Activity Log Page.
     */
    private List<ActivityLogEntry> filterLogsForActivityLogPage(List<AppLogLine> appLogLines,
                                                                AdminActivityLogPageData data) {
        List<ActivityLogEntry> appLogs = new LinkedList<>();
        for (AppLogLine appLog : appLogLines) {
            String logMsg = appLog.getLogMessage();
            boolean isNotTeammatesLog = !logMsg.contains(""TEAMMATESLOG"");
            boolean isLogFromAdminActivityLogPage = logMsg.contains(""adminActivityLogPage"");
            if (isNotTeammatesLog || isLogFromAdminActivityLogPage) {
                continue;
            }

            ActivityLogEntry activityLogEntry = ActivityLogEntry.buildFromAppLog(appLog);
            boolean isToShow = data.filterLog(activityLogEntry)
                    && (!activityLogEntry.isTestingData() || data.getShouldShowTestData());

            if (!isToShow) {
                continue;
            }

            appLogs.add(activityLogEntry);
        }
        return appLogs;
    }

    private double getLocalTimeZoneForRequest(String userGoogleId, String userRole) {

        if (userRole != null && (userRole.contentEquals(""Admin"") || userRole.contains(""(M)""))) {
            return Const.SystemParams.ADMIN_TIME_ZONE_DOUBLE;
        }

        double localTimeZone = Const.DOUBLE_UNINITIALIZED;
        if (userGoogleId != null && !userGoogleId.isEmpty()) {
            localTimeZone = findAvailableTimeZoneFromCourses(logic.getCoursesForInstructor(userGoogleId));

            if (localTimeZone != Const.DOUBLE_UNINITIALIZED) {
                return localTimeZone;
            }

            try {
                localTimeZone = findAvailableTimeZoneFromCourses(logic.getCoursesForStudentAccount(userGoogleId));
            } catch (EntityDoesNotExistException e) {
                localTimeZone = Const.DOUBLE_UNINITIALIZED;
            }

            if (localTimeZone != Const.DOUBLE_UNINITIALIZED) {
                return localTimeZone;
            }
        }

        return localTimeZone;
    }

    private double findAvailableTimeZoneFromCourses(List<CourseAttributes> courses) {
        double localTimeZone = Const.DOUBLE_UNINITIALIZED;

        if (courses == null) {
            return localTimeZone;
        }

        for (CourseAttributes course : courses) {
            List<FeedbackSessionAttributes> fsl = logic.getFeedbackSessionsForCourse(course.getId());
            if (!fsl.isEmpty()) {
                return fsl.get(0).getTimeZone();
            }
        }

        return localTimeZone;
    }

    private double getLocalTimeZoneForUnregisteredUserRequest(String courseId) {
        double localTimeZone = Const.DOUBLE_UNINITIALIZED;

        if (courseId == null || courseId.isEmpty()) {
            return localTimeZone;
        }

        List<FeedbackSessionAttributes> fsl = logic.getFeedbackSessionsForCourse(courseId);
        if (!fsl.isEmpty()) {
            return fsl.get(0).getTimeZone();
        }

        return localTimeZone;
    }

    private double getLocalTimeZoneInfo(String logGoogleId, String logRole) {
        if (!logGoogleId.contentEquals(""Unknown"") && !logGoogleId.contentEquals(""Unregistered"")) {
            return getLocalTimeZoneForRequest(logGoogleId, logRole);
        }
        if (logRole.contains(""Unregistered"") && !logRole.contentEquals(""Unregistered"")) {
            String courseId = logRole.split("":"")[1];
            return getLocalTimeZoneForUnregisteredUserRequest(courseId);
        }

        return Const.DOUBLE_UNINITIALIZED;
    }

    private String getLocalTimeInfo(String logGoogleId, String logRole, String logTimeInAdminTimeZone) {
        double timeZone = getLocalTimeZoneInfo(logGoogleId, logRole);
        if (timeZone == Const.DOUBLE_UNINITIALIZED) {
            return ""Local Time Unavailable"";
        }
        double timeZoneOffset = timeZone - Const.SystemParams.ADMIN_TIME_ZONE_DOUBLE;
        return computeTimeWithOffset(timeZoneOffset, Long.parseLong(logTimeInAdminTimeZone));
    }

    private String computeTimeWithOffset(double timeZoneOffset, long logTime) {
        Calendar appCal = Calendar.getInstance();
        SimpleDateFormat sdf = new SimpleDateFormat(""dd-MM-yyyy HH:mm:ss"");
        appCal.setTimeInMillis(logTime);
        appCal = TimeHelper.convertToUserTimeZone(appCal, timeZoneOffset);
        return sdf.format(appCal.getTime());
    }

}
"
AdminEmailComposePageAction.java,ui-controller,"package teammates.ui.controller;

import teammates.common.util.Const;
import teammates.common.util.SanitizationHelper;
import teammates.common.util.StatusMessage;
import teammates.common.util.StatusMessageColor;
import teammates.ui.pagedata.AdminEmailComposePageData;

public class AdminEmailComposePageAction extends Action {

    @Override
    protected ActionResult execute() {

        gateKeeper.verifyAdminPrivileges(account);
        AdminEmailComposePageData data = new AdminEmailComposePageData(account, sessionToken);

        String idOfEmailToEdit = getRequestParamValue(Const.ParamsNames.ADMIN_EMAIL_ID);

        boolean isEmailEdit = idOfEmailToEdit != null;

        if (isEmailEdit) {

            data.emailToEdit = logic.getAdminEmailById(idOfEmailToEdit);
            statusToAdmin =
                    data.emailToEdit == null
                    ? ""adminEmailComposePage Page Load : "" + Const.StatusMessages.EMAIL_NOT_FOUND
                    : ""adminEmailComposePage Page Load : Edit Email ""
                      + ""["" + SanitizationHelper.sanitizeForHtml(data.emailToEdit.getSubject()) + ""]"";

            if (data.emailToEdit == null) {
                isError = true;
                statusToUser.add(new StatusMessage(Const.StatusMessages.EMAIL_NOT_FOUND, StatusMessageColor.WARNING));
            }

            return createShowPageResult(Const.ViewURIs.ADMIN_EMAIL, data);
        }
        statusToAdmin = ""adminEmailComposePage Page Load"";
        data.init();

        return createShowPageResult(Const.ViewURIs.ADMIN_EMAIL, data);
    }

}
"
AdminEmailComposeSaveAction.java,ui-controller,"package teammates.ui.controller;

import java.util.ArrayList;
import java.util.List;

import com.google.appengine.api.datastore.Text;

import teammates.common.datatransfer.attributes.AdminEmailAttributes;
import teammates.common.exception.EntityDoesNotExistException;
import teammates.common.exception.InvalidParametersException;
import teammates.common.util.Const;
import teammates.common.util.SanitizationHelper;
import teammates.common.util.StatusMessage;
import teammates.common.util.StatusMessageColor;
import teammates.ui.pagedata.AdminEmailComposePageData;

public class AdminEmailComposeSaveAction extends Action {

    private List<String> addressReceiver = new ArrayList<>();
    private List<String> groupReceiver = new ArrayList<>();

    @Override
    protected ActionResult execute() {

        gateKeeper.verifyAdminPrivileges(account);
        AdminEmailComposePageData data = new AdminEmailComposePageData(account, sessionToken);

        String emailContent = getRequestParamValue(Const.ParamsNames.ADMIN_EMAIL_CONTENT);
        String subject = getRequestParamValue(Const.ParamsNames.ADMIN_EMAIL_SUBJECT);
        String addressReceiverListString = getRequestParamValue(Const.ParamsNames.ADMIN_EMAIL_ADDRESS_RECEIVERS);

        String groupReceiverListFileKey = getRequestParamValue(Const.ParamsNames.ADMIN_EMAIL_GROUP_RECEIVER_LIST_FILE_KEY);

        String emailId = getRequestParamValue(Const.ParamsNames.ADMIN_EMAIL_ID);

        addressReceiver.add(addressReceiverListString);

        if (groupReceiverListFileKey != null && !groupReceiverListFileKey.isEmpty()) {
            groupReceiver.add(groupReceiverListFileKey);
        }

        boolean isNewDraft = emailId == null;

        if (isNewDraft) {
            //this is a new email draft, so create a new admin email entity
            createAndSaveNewDraft(subject, addressReceiver, groupReceiver, emailContent);
        } else {
            //currently editing a previous email draft, so we need to update the previous draft
            //instead of creating a new admin email entity

            //retrieve the previous draft email
            AdminEmailAttributes previousDraft = logic.getAdminEmailById(emailId);

            if (previousDraft == null) {
                //the previous draft is not found (eg. deleted by accident when editing)
                createAndSaveNewDraft(subject, addressReceiver, groupReceiver, emailContent);
            } else {
                //the previous draft exists so simply update it with the latest email info
                updatePreviousEmailDraft(previousDraft.getEmailId(), subject, addressReceiver, groupReceiver, emailContent);
            }
        }

        if (isError) {
            data.emailToEdit = new AdminEmailAttributes(subject,
                                                        addressReceiver,
                                                        groupReceiver,
                                                        new Text(emailContent),
                                                        null);
            data.emailToEdit.emailId = emailId;
        } else {
            statusToAdmin = Const.StatusMessages.EMAIL_DRAFT_SAVED + "": <br>""
                    + ""Subject: "" + SanitizationHelper.sanitizeForHtml(subject);
            statusToUser.add(new StatusMessage(Const.StatusMessages.EMAIL_DRAFT_SAVED, StatusMessageColor.SUCCESS));
        }

        return createShowPageResult(Const.ViewURIs.ADMIN_EMAIL, data);
    }

    private void updatePreviousEmailDraft(String previousEmailId,
                                          String subject,
                                          List<String> addressReceiver,
                                          List<String> groupReceiver,
                                          String content
                                          ) {

        AdminEmailAttributes newDraft = new AdminEmailAttributes(subject,
                                                                 addressReceiver,
                                                                 groupReceiver,
                                                                 new Text(content),
                                                                 null);
        try {
            logic.updateAdminEmailById(newDraft, previousEmailId);
        } catch (InvalidParametersException | EntityDoesNotExistException e) {
            isError = true;
            setStatusForException(e);
        }

    }

    private void createAndSaveNewDraft(String subject,
                                       List<String> addressReceiver,
                                       List<String> groupReceiver,
                                       String content) {

        AdminEmailAttributes newDraft = new AdminEmailAttributes(subject,
                                                                 addressReceiver,
                                                                 groupReceiver,
                                                                 new Text(content),
                                                                 null);
        try {
            logic.createAdminEmail(newDraft);
        } catch (InvalidParametersException e) {
            isError = true;
            setStatusForException(e, e.getMessage());
        }
    }

}
"
AdminEmailComposeSendAction.java,ui-controller,"package teammates.ui.controller;

import java.util.ArrayList;
import java.util.Date;
import java.util.List;

import com.google.appengine.api.blobstore.BlobKey;
import com.google.appengine.api.datastore.Text;

import teammates.common.datatransfer.attributes.AdminEmailAttributes;
import teammates.common.exception.EntityDoesNotExistException;
import teammates.common.exception.InvalidParametersException;
import teammates.common.util.Const;
import teammates.common.util.FieldValidator;
import teammates.common.util.GoogleCloudStorageHelper;
import teammates.common.util.StatusMessage;
import teammates.common.util.StatusMessageColor;
import teammates.ui.pagedata.AdminEmailComposePageData;

public class AdminEmailComposeSendAction extends Action {

    private List<String> addressReceiver = new ArrayList<>();
    private List<String> groupReceiver = new ArrayList<>();

    private boolean isAddressModeOn;
    private boolean isGroupModeOn;

    //params needed to move heavy jobs into a address mode task
    private String addressReceiverListString;

    //params needed to move heavy jobs into a group mode task
    private String groupReceiverListFileKey;
    private String emailId;

    @Override
    protected ActionResult execute() {

        gateKeeper.verifyAdminPrivileges(account);
        AdminEmailComposePageData data = new AdminEmailComposePageData(account, sessionToken);

        String emailContent = getRequestParamValue(Const.ParamsNames.ADMIN_EMAIL_CONTENT);
        String subject = getRequestParamValue(Const.ParamsNames.ADMIN_EMAIL_SUBJECT);

        addressReceiverListString = getRequestParamValue(Const.ParamsNames.ADMIN_EMAIL_ADDRESS_RECEIVERS);
        isAddressModeOn = addressReceiverListString != null && !addressReceiverListString.isEmpty();
        emailId = getRequestParamValue(Const.ParamsNames.ADMIN_EMAIL_ID);
        groupReceiverListFileKey = getRequestParamValue(Const.ParamsNames.ADMIN_EMAIL_GROUP_RECEIVER_LIST_FILE_KEY);
        isGroupModeOn = groupReceiverListFileKey != null && !groupReceiverListFileKey.isEmpty();

        if (isGroupModeOn) {
            try {
                groupReceiver.add(groupReceiverListFileKey);
                GoogleCloudStorageHelper.getGroupReceiverList(new BlobKey(groupReceiverListFileKey));
            } catch (Exception e) {
                isError = true;
                setStatusForException(e, ""An error occurred when retrieving receiver list, please try again"");
            }
        }

        if (isAddressModeOn) {
            addressReceiver.add(addressReceiverListString);
            try {
                checkAddressReceiverString(addressReceiverListString);
            } catch (InvalidParametersException e) {
                isError = true;
                setStatusForException(e);
            }
        }

        if (!isAddressModeOn && !isGroupModeOn) {
            isError = true;
            statusToAdmin = ""Error : No receiver address or file given"";
            statusToUser.add(new StatusMessage(""Error : No receiver address or file given"", StatusMessageColor.DANGER));
        }

        if (isError) {
            data.emailToEdit = new AdminEmailAttributes(subject,
                                                        addressReceiver,
                                                        groupReceiver,
                                                        new Text(emailContent),
                                                        null);
            data.emailToEdit.emailId = emailId;
            return createShowPageResult(Const.ViewURIs.ADMIN_EMAIL, data);
        }

        boolean isEmailDraft = emailId != null && !emailId.isEmpty();

        if (isEmailDraft) {
            updateDraftEmailToSent(emailId, subject, addressReceiver, groupReceiver, emailContent);
        } else {
            recordNewSentEmail(subject, addressReceiver, groupReceiver, emailContent);
        }

        if (isError) {
            data.emailToEdit = new AdminEmailAttributes(subject,
                                                        addressReceiver,
                                                        groupReceiver,
                                                        new Text(emailContent),
                                                        null);
            data.emailToEdit.emailId = emailId;
        }

        return createShowPageResult(Const.ViewURIs.ADMIN_EMAIL, data);
    }

    private void checkAddressReceiverString(String addressReceiverString) throws InvalidParametersException {
        FieldValidator validator = new FieldValidator();

        String[] emails = addressReceiverString.split("","");
        for (String email : emails) {
            String error = validator.getInvalidityInfoForEmail(email);
            if (!error.isEmpty()) {
                isError = true;
                statusToUser.add(new StatusMessage(error, StatusMessageColor.DANGER));
                throw new InvalidParametersException(""<strong>Email Format Error</strong>"");
            }
        }

    }

    private void moveJobToGroupModeTaskQueue() {
        if (!isGroupModeOn) {
            return;
        }
        taskQueuer.scheduleAdminEmailPreparationInGroupMode(emailId, groupReceiverListFileKey, 0, 0);

        statusToAdmin += ""<br/>"" + ""Group receiver's list "" + groupReceiverListFileKey;
        statusToUser.add(new StatusMessage(""Email will be sent within an hour to uploaded group receiver's list."",
                     StatusMessageColor.SUCCESS));
    }

    private void moveJobToAddressModeTaskQueue() {
        if (!isAddressModeOn) {
            return;
        }
        taskQueuer.scheduleAdminEmailPreparationInAddressMode(emailId, addressReceiverListString);

        statusToAdmin += ""<br/>"" + ""Recipient: "" + addressReceiverListString;
        statusToUser.add(new StatusMessage(""Email will be sent within an hour to "" + addressReceiverListString,
                     StatusMessageColor.SUCCESS));
    }

    private void recordNewSentEmail(String subject,
                                    List<String> addressReceiver,
                                    List<String> groupReceiver,
                                    String content) {

        AdminEmailAttributes newDraft = new AdminEmailAttributes(subject,
                                                                 addressReceiver,
                                                                 groupReceiver,
                                                                 new Text(content),
                                                                 new Date());
        try {
            Date createDate = logic.createAdminEmail(newDraft);
            emailId = logic.getAdminEmail(subject, createDate).getEmailId();
        } catch (Exception e) {
            isError = true;
            setStatusForException(e, e.getMessage());
            return;
        }
        statusToAdmin = ""Email queued for sending."";

        moveJobToGroupModeTaskQueue();
        moveJobToAddressModeTaskQueue();
    }

    private void updateDraftEmailToSent(String emailId,
                                        String subject,
                                        List<String> addressReceiver,
                                        List<String> groupReceiver,
                                        String content) {

        AdminEmailAttributes finalisedEmail = new AdminEmailAttributes(subject,
                                            addressReceiver,
                                            groupReceiver,
                                            new Text(content),
                                            new Date());

        try {
            logic.updateAdminEmailById(finalisedEmail, emailId);
        } catch (InvalidParametersException | EntityDoesNotExistException e) {
            isError = true;
            setStatusForException(e);
            return;
        }
        moveJobToGroupModeTaskQueue();
        moveJobToAddressModeTaskQueue();
    }

}
"
AdminEmailCreateGroupReceiverListUploadUrlAction.java,ui-controller,"package teammates.ui.controller;

import com.google.appengine.api.blobstore.BlobstoreFailureException;

import teammates.common.util.Const;
import teammates.common.util.GoogleCloudStorageHelper;
import teammates.common.util.Url;
import teammates.ui.pagedata.AdminEmailCreateGroupReceiverListUploadUrlAjaxPageData;

public class AdminEmailCreateGroupReceiverListUploadUrlAction extends Action {

    @Override
    protected ActionResult execute() {

        gateKeeper.verifyAdminPrivileges(account);

        AdminEmailCreateGroupReceiverListUploadUrlAjaxPageData data =
                new AdminEmailCreateGroupReceiverListUploadUrlAjaxPageData(account, sessionToken);

        try {
            String callbackUrl = Url.addParamToUrl(Const.ActionURIs.ADMIN_EMAIL_GROUP_RECEIVER_LIST_UPLOAD,
                                                   Const.ParamsNames.SESSION_TOKEN,
                                                   sessionToken);
            data.nextUploadUrl =
                    GoogleCloudStorageHelper.getNewUploadUrl(callbackUrl);
            data.ajaxStatus = ""Group receiver list upload url created, proceed to uploading"";
        } catch (BlobstoreFailureException | IllegalArgumentException e) {
            data.nextUploadUrl = null;
            isError = true;
            data.ajaxStatus = ""An error occurred when creating upload URL, please try again"";
        }

        return createAjaxResult(data);

    }

}
"
AdminEmailCreateImageUploadUrlAction.java,ui-controller,"package teammates.ui.controller;

import teammates.common.util.Const;
import teammates.common.util.GoogleCloudStorageHelper;
import teammates.common.util.Url;

/**
 * Action: creates a URL for uploading an image in admin email.
 */
public class AdminEmailCreateImageUploadUrlAction extends CreateImageUploadUrlAction {

    @Override
    protected ActionResult execute() {
        verifyPrivileges();
        return createAjaxResult(getCreateImageUploadUrlPageData());
    }

    private void verifyPrivileges() {
        gateKeeper.verifyAdminPrivileges(account);
    }

    @Override
    protected String getUploadUrl() {
        String callbackUrl =
                Url.addParamToUrl(Const.ActionURIs.ADMIN_EMAIL_IMAGE_UPLOAD, Const.ParamsNames.SESSION_TOKEN, sessionToken);
        return GoogleCloudStorageHelper.getNewUploadUrl(callbackUrl);
    }

}
"
AdminEmailDraftPageAction.java,ui-controller,"package teammates.ui.controller;

import teammates.common.util.Const;
import teammates.ui.pagedata.AdminEmailDraftPageData;

public class AdminEmailDraftPageAction extends Action {

    @Override
    protected ActionResult execute() {
        gateKeeper.verifyAdminPrivileges(account);
        AdminEmailDraftPageData data = new AdminEmailDraftPageData(account, sessionToken);

        data.draftEmailList = logic.getAdminEmailDrafts();
        statusToAdmin = ""adminEmailDraftPage Page Load"";
        data.init();

        return createShowPageResult(Const.ViewURIs.ADMIN_EMAIL, data);
    }

}
"
AdminEmailGroupReceiverListUploadAction.java,ui-controller,"package teammates.ui.controller;

import java.io.IOException;
import java.util.List;
import java.util.Map;

import com.google.appengine.api.blobstore.BlobInfo;
import com.google.appengine.api.blobstore.BlobKey;
import com.google.appengine.api.blobstore.BlobstoreFailureException;
import com.google.appengine.api.blobstore.BlobstoreServiceFactory;

import teammates.common.util.Const;
import teammates.common.util.GoogleCloudStorageHelper;
import teammates.common.util.Logger;
import teammates.ui.pagedata.AdminEmailComposePageData;

public class AdminEmailGroupReceiverListUploadAction extends Action {

    private static final Logger log = Logger.getLogger();

    private AdminEmailComposePageData data;

    @Override
    protected ActionResult execute() {
        gateKeeper.verifyAdminPrivileges(account);

        data = new AdminEmailComposePageData(account, sessionToken);
        BlobInfo blobInfo = extractGroupReceiverListFileKey();

        if (blobInfo == null) {
            data.isFileUploaded = false;
            data.fileSrcUrl = null;

            log.info(""Group Receiver List Upload Failed"");
            statusToAdmin = ""Group Receiver List Upload Failed"";
            data.ajaxStatus = ""Group receiver list upload failed. Please try again."";
            return createAjaxResult(data);
        }

        try {
            List<List<String>> groupReceiverList =
                    GoogleCloudStorageHelper.getGroupReceiverList(blobInfo.getBlobKey());

            // log all email addresses retrieved from the txt file
            int i = 0;

            for (List<String> list : groupReceiverList) {
                for (String str : list) {
                    log.info(str + "" - "" + i + "" \n"");
                    i++;
                }
            }
        } catch (IOException e) {
            data.isFileUploaded = false;
            data.fileSrcUrl = null;

            log.info(""Group Receiver List Upload Failed: uploaded file is corrupted"");
            statusToAdmin = ""Group Receiver List Upload Failed: uploaded file is corrupted"";
            data.ajaxStatus = ""Group receiver list upload failed: uploaded file is corrupted. ""
                              + ""Please make sure the txt file contains only email addresses ""
                              + ""separated by comma"";
            deleteGroupReceiverListFile(blobInfo.getBlobKey());
            return createAjaxResult(data);
        }

        BlobKey blobKey = blobInfo.getBlobKey();

        data.groupReceiverListFileKey = blobKey.getKeyString();

        data.isFileUploaded = true;
        statusToAdmin = ""New Group Receiver List Uploaded"";
        data.ajaxStatus = ""Group receiver list successfully uploaded to Google Cloud Storage"";

        return createAjaxResult(data);
    }

    private BlobInfo extractGroupReceiverListFileKey() {
        try {
            Map<String, List<BlobInfo>> blobsMap = BlobstoreServiceFactory.getBlobstoreService().getBlobInfos(request);
            List<BlobInfo> blobs = blobsMap.get(Const.ParamsNames.ADMIN_EMAIL_GROUP_RECEIVER_LIST_TO_UPLOAD);

            if (blobs == null || blobs.isEmpty()) {
                data.ajaxStatus = Const.StatusMessages.NO_GROUP_RECEIVER_LIST_FILE_GIVEN;
                isError = true;
                return null;
            }

            BlobInfo groupReceiverListFile = blobs.get(0);
            return validateGroupReceiverListFile(groupReceiverListFile);
        } catch (IllegalStateException e) {
            return null;
        }
    }

    private BlobInfo validateGroupReceiverListFile(BlobInfo groupReceiverListFile) {
        if (!groupReceiverListFile.getContentType().contains(""text/"")) {
            deleteGroupReceiverListFile(groupReceiverListFile.getBlobKey());
            isError = true;
            data.ajaxStatus = Const.StatusMessages.NOT_A_RECEIVER_LIST_FILE;
            return null;
        }

        return groupReceiverListFile;
    }

    private void deleteGroupReceiverListFile(BlobKey blobKey) {
        if (blobKey.equals(new BlobKey(""""))) {
            return;
        }

        try {
            logic.deleteAdminEmailUploadedFile(blobKey);
        } catch (BlobstoreFailureException bfe) {
            statusToAdmin = Const.ACTION_RESULT_FAILURE
                    + "" : Unable to delete group receiver list file (possible unused file with key: ""
                    + blobKey.getKeyString()
                    + "" || Error Message: ""
                    + bfe.getMessage() + Const.EOL;
        }
    }

}
"
AdminEmailImageUploadAction.java,ui-controller,"package teammates.ui.controller;

import com.google.appengine.api.blobstore.BlobKey;

import teammates.common.util.Const;
import teammates.ui.pagedata.AdminEmailComposePageData;
import teammates.ui.pagedata.FileUploadPageData;

/**
 * Action: uploads an image for admin email.
 */
public class AdminEmailImageUploadAction extends ImageUploadAction {

    @Override
    protected ActionResult execute() {
        gateKeeper.verifyAdminPrivileges(account);

        FileUploadPageData uploadPageData = prepareData();
        AdminEmailComposePageData data = new AdminEmailComposePageData(account, sessionToken);
        data.isFileUploaded = uploadPageData.isFileUploaded;
        data.fileSrcUrl = uploadPageData.fileSrcUrl;
        data.ajaxStatus = uploadPageData.ajaxStatus;

        return createAjaxResult(data);
    }

    @Override
    protected String getImageKeyParam() {
        return Const.ParamsNames.ADMIN_EMAIL_IMAGE_TO_UPLOAD;
    }

    @Override
    protected void deleteUploadedFile(BlobKey blobKey) {
        logic.deleteAdminEmailUploadedFile(blobKey);
    }
}
"
AdminEmailLogPageAction.java,ui-controller,"package teammates.ui.controller;

import java.util.LinkedList;
import java.util.List;

import com.google.appengine.api.log.AppLogLine;

import teammates.common.util.AdminLogQuery;
import teammates.common.util.Const;
import teammates.common.util.EmailLogEntry;
import teammates.common.util.GaeLogApi;
import teammates.common.util.GaeVersionApi;
import teammates.common.util.StatusMessage;
import teammates.common.util.StatusMessageColor;
import teammates.ui.pagedata.AdminEmailLogPageData;

public class AdminEmailLogPageAction extends Action {
    private static final int LOGS_PER_PAGE = 50;
    /**
     * The maximum time period to retrieve logs with time increment.
     */
    private static final int MAX_SEARCH_PERIOD = 24 * 60 * 60 * 1000; // 24 hrs in milliseconds
    private static final int SEARCH_TIME_INCREMENT = 2 * 60 * 60 * 1000; // two hours in milliseconds
    /**
     * The maximum number of times to retrieve logs with time increment.
     */
    private static final int MAX_SEARCH_TIMES = MAX_SEARCH_PERIOD / SEARCH_TIME_INCREMENT;
    /**
     * Maximum number of versions to query.
     */
    private static final int MAX_VERSIONS_TO_QUERY = 1 + 5; //the current version and its 5 preceding versions

    @Override
    protected ActionResult execute() {
        gateKeeper.verifyAdminPrivileges(account);

        AdminEmailLogPageData data = new AdminEmailLogPageData(account, sessionToken, getRequestParamValue(""filterQuery""),
                                                               getRequestParamAsBoolean(""all""));

        if (data.getFilterQuery() == null) {
            data.setFilterQuery("""");
        }

        //This is used to parse the filterQuery. If the query is not parsed, the filter function would ignore the query
        data.generateQueryParameters(data.getFilterQuery());

        String timeOffset = getRequestParamValue(""offset"");
        if (timeOffset != null && !timeOffset.isEmpty()) {
            data.setToDate(Long.parseLong(timeOffset));
        }

        if (data.isFromDateInQuery()) {
            searchEmailLogsWithExactTimePeriod(data);
        } else {
            searchEmailLogsWithTimeIncrement(data);
        }

        statusToAdmin = ""adminEmailLogPage Page Load"";

        if (timeOffset == null) {
            return createShowPageResult(Const.ViewURIs.ADMIN_EMAIL_LOG, data);
        }

        return createShowPageResult(Const.ViewURIs.ADMIN_EMAIL_LOG_AJAX, data);
    }

    /**
     * Selects versions for query. If versions are not specified, it will return
     * MAX_VERSIONS_TO_QUERY most recent versions used for query.
     */
    private List<String> getVersionsForQuery(List<String> versions) {
        boolean isVersionSpecifiedInRequest = versions != null && !versions.isEmpty();
        if (isVersionSpecifiedInRequest) {
            return versions;
        }
        GaeVersionApi versionApi = new GaeVersionApi();
        return versionApi.getMostRecentVersions(MAX_VERSIONS_TO_QUERY);
    }

    /**
     * Searches all logs in the time period specified in the query.
     */
    private void searchEmailLogsWithExactTimePeriod(AdminEmailLogPageData data) {
        List<String> versionToQuery = getVersionsForQuery(data.getVersions());
        AdminLogQuery query = new AdminLogQuery(versionToQuery, data.getFromDate(), data.getToDate());

        List<AppLogLine> searchResult = new GaeLogApi().fetchLogs(query);
        data.setLogs(filterLogsForEmailLogPage(searchResult, data));

        long nextEndTimeToSearch = data.getFromDate() - 1;
        int totalLogsSearched = searchResult.size();

        String status = ""&nbsp;&nbsp;Total Logs gone through in last search: ""
                + totalLogsSearched + ""<br>""
                + ""<button class=\""btn-link\"" id=\""button_older\"" data-next-end-time-to-search=\""""
                + nextEndTimeToSearch + ""\"">Search More</button>"";
        data.setStatusForAjax(status);
        statusToUser.add(new StatusMessage(status, StatusMessageColor.INFO));
    }

    /**
     * Searches enough email logs within MAX_SEARCH_PERIOD hours.
     */
    private void searchEmailLogsWithTimeIncrement(AdminEmailLogPageData data) {
        List<EmailLogEntry> emailLogs = new LinkedList<>();
        List<String> versionToQuery = getVersionsForQuery(data.getVersions());
        AdminLogQuery query = new AdminLogQuery(versionToQuery, null, data.getToDate());

        int totalLogsSearched = 0;

        GaeLogApi logApi = new GaeLogApi();

        long startTime = query.getEndTime() - SEARCH_TIME_INCREMENT;
        query.setTimePeriod(startTime, query.getEndTime());

        for (int i = 0; i < MAX_SEARCH_TIMES; i++) {
            if (emailLogs.size() >= LOGS_PER_PAGE) {
                break;
            }
            List<AppLogLine> searchResult = logApi.fetchLogs(query);
            List<EmailLogEntry> filteredLogs = filterLogsForEmailLogPage(searchResult, data);
            emailLogs.addAll(filteredLogs);
            totalLogsSearched += searchResult.size();
            query.moveTimePeriodBackward(SEARCH_TIME_INCREMENT);
        }

        data.setLogs(emailLogs);

        long nextEndTimeToSearch = query.getEndTime();
        String status = ""&nbsp;&nbsp;Total Logs gone through in last search: ""
                      + totalLogsSearched + ""<br>""
                      + ""<button class=\""btn-link\"" id=\""button_older\"" data-next-end-time-to-search=\""""
                      + nextEndTimeToSearch + ""\"">Search More</button>"";
        data.setStatusForAjax(status);
        statusToUser.add(new StatusMessage(status, StatusMessageColor.INFO));
    }

    private List<EmailLogEntry> filterLogsForEmailLogPage(List<AppLogLine> appLogLines,
                                                          AdminEmailLogPageData data) {
        List<EmailLogEntry> emailLogs = new LinkedList<>();

        for (AppLogLine appLog : appLogLines) {
            String logMsg = appLog.getLogMessage();
            boolean isNotEmailLog = !logMsg.contains(""TEAMMATESEMAILLOG"");
            if (isNotEmailLog) {
                continue;
            }

            EmailLogEntry emailLogEntry = new EmailLogEntry(appLog);
            if (data.shouldShowLog(emailLogEntry)) {
                emailLogs.add(emailLogEntry);
            }
        }

        return emailLogs;
    }
}
"
AdminEmailSentPageAction.java,ui-controller,"package teammates.ui.controller;

import teammates.common.util.Const;
import teammates.ui.pagedata.AdminEmailSentPageData;

public class AdminEmailSentPageAction extends Action {

    @Override
    protected ActionResult execute() {
        gateKeeper.verifyAdminPrivileges(account);
        AdminEmailSentPageData data = new AdminEmailSentPageData(account, sessionToken);

        data.adminSentEmailList = logic.getSentAdminEmails();

        statusToAdmin = ""adminEmailSentPage Page Load"";

        data.init();

        return createShowPageResult(Const.ViewURIs.ADMIN_EMAIL, data);

    }

}
"
AdminEmailTrashAction.java,ui-controller,"package teammates.ui.controller;

import teammates.common.exception.EntityDoesNotExistException;
import teammates.common.exception.InvalidParametersException;
import teammates.common.util.Const;
import teammates.common.util.StatusMessage;
import teammates.common.util.StatusMessageColor;

public class AdminEmailTrashAction extends Action {

    @Override
    protected ActionResult execute() {

        gateKeeper.verifyAdminPrivileges(account);

        String emailId = getRequestParamValue(Const.ParamsNames.ADMIN_EMAIL_ID);

        String redirect = getRequestParamValue(Const.ParamsNames.ADMIN_EMAIL_TRASH_ACTION_REDIRECT);
        if (redirect == null) {
            redirect = Const.ActionURIs.ADMIN_EMAIL_TRASH_PAGE;
        }

        if (redirect.contains(""sentpage"")) {
            redirect = Const.ActionURIs.ADMIN_EMAIL_SENT_PAGE;
        } else if (redirect.contains(""draftpage"")) {
            redirect = Const.ActionURIs.ADMIN_EMAIL_DRAFT_PAGE;
        } else {
            redirect = Const.ActionURIs.ADMIN_EMAIL_TRASH_PAGE;
        }

        if (emailId == null || emailId.isEmpty()) {
            statusToAdmin = ""Invalid parameter : email id cannot be null or empty"";
            statusToUser.add(new StatusMessage(""Invalid parameter : email id cannot be null or empty"",
                                               StatusMessageColor.DANGER));
            return createRedirectResult(redirect);
        }

        if (requestUrl.contains(Const.ActionURIs.ADMIN_EMAIL_MOVE_TO_TRASH)) {
            try {
                logic.moveAdminEmailToTrashBin(emailId);
                statusToAdmin = ""Email with id"" + emailId + "" has been moved to trash bin"";
                statusToUser.add(new StatusMessage(""The item has been moved to trash bin"", StatusMessageColor.SUCCESS));
            } catch (InvalidParametersException | EntityDoesNotExistException e) {
                setStatusForException(e, ""An error has occurred when moving email to trash bin"");
            }

            return createRedirectResult(redirect);

        } else if (requestUrl.contains(Const.ActionURIs.ADMIN_EMAIL_MOVE_OUT_TRASH)) {
            try {
                logic.moveAdminEmailOutOfTrashBin(emailId);
                statusToAdmin = ""Email with id"" + emailId + "" has been moved out of trash bin"";
                statusToUser.add(new StatusMessage(""The item has been moved out of trash bin"", StatusMessageColor.SUCCESS));
            } catch (InvalidParametersException | EntityDoesNotExistException e) {
                setStatusForException(e, ""An error has occurred when moving email out of trash bin"");
            }

            return createRedirectResult(Const.ActionURIs.ADMIN_EMAIL_TRASH_PAGE);
        }

        return createRedirectResult(redirect);

    }

}
"
AdminEmailTrashDeleteAction.java,ui-controller,"package teammates.ui.controller;

import com.google.appengine.api.blobstore.BlobstoreFailureException;

import teammates.common.util.Const;
import teammates.common.util.StatusMessage;
import teammates.common.util.StatusMessageColor;

public class AdminEmailTrashDeleteAction extends Action {

    @Override
    protected ActionResult execute() {

        gateKeeper.verifyAdminPrivileges(account);

        boolean shouldEmptyTrashBin = getRequestParamAsBoolean(Const.ParamsNames.ADMIN_EMAIL_EMPTY_TRASH_BIN);

        if (shouldEmptyTrashBin) {
            try {
                logic.deleteAllEmailsInTrashBin();
                statusToAdmin = ""All emails in trash bin has been deleted"";
                statusToUser.add(new StatusMessage(""All emails in trash bin has been deleted"", StatusMessageColor.SUCCESS));
            } catch (BlobstoreFailureException e) {
                statusToAdmin = ""Blobstore connection failure"";
                statusToUser.add(new StatusMessage(""Blobstore connection failure"", StatusMessageColor.DANGER));
            }
        }

        return createRedirectResult(Const.ActionURIs.ADMIN_EMAIL_TRASH_PAGE);
    }

}
"
AdminEmailTrashPageAction.java,ui-controller,"package teammates.ui.controller;

import teammates.common.util.Const;
import teammates.ui.pagedata.AdminEmailTrashPageData;

public class AdminEmailTrashPageAction extends Action {

    @Override
    protected ActionResult execute() {
        gateKeeper.verifyAdminPrivileges(account);
        AdminEmailTrashPageData data = new AdminEmailTrashPageData(account, sessionToken);

        data.adminTrashEmailList = logic.getAdminEmailsInTrashBin();
        statusToAdmin = ""adminEmailTrashPage Page Load"";
        data.init();

        return createShowPageResult(Const.ViewURIs.ADMIN_EMAIL, data);
    }

}
"
AdminExceptionTestAction.java,ui-controller,"package teammates.ui.controller;

import com.google.apphosting.api.DeadlineExceededException;

import teammates.common.exception.EntityDoesNotExistException;
import teammates.common.exception.NullPostParameterException;
import teammates.common.exception.UnauthorizedAccessException;
import teammates.common.util.Const;

public class AdminExceptionTestAction extends Action {

    @Override
    @SuppressWarnings(""PMD.AvoidThrowingNullPointerException"") // deliberately done for testing
    protected ActionResult execute() throws EntityDoesNotExistException {

        gateKeeper.verifyAdminPrivileges(account);

        String error = getRequestParamValue(Const.ParamsNames.ERROR);

        if (error.equals(AssertionError.class.getSimpleName())) {
            throw new AssertionError(""AssertionError Testing"");

        } else if (error.equals(EntityDoesNotExistException.class.getSimpleName())) {
            throw new EntityDoesNotExistException(""EntityDoesNotExistException Testing"");

        } else if (error.equals(UnauthorizedAccessException.class.getSimpleName())) {
            throw new UnauthorizedAccessException();

        } else if (error.equals(NullPointerException.class.getSimpleName())) {
            throw new NullPointerException();

        } else if (error.equals(DeadlineExceededException.class.getSimpleName())) {
            throw new DeadlineExceededException();
        } else if (error.equals(NullPostParameterException.class.getSimpleName())) {
            throw new NullPostParameterException(""test null post param exception"");
        }

        statusToAdmin = ""adminExceptionTest"";

        return createRedirectResult(Const.ActionURIs.ADMIN_HOME_PAGE);
    }

}
"
AdminHomePageAction.java,ui-controller,"package teammates.ui.controller;

import teammates.common.util.Const;
import teammates.ui.pagedata.AdminHomePageData;

public class AdminHomePageAction extends Action {

    @Override
    protected ActionResult execute() {

        gateKeeper.verifyAdminPrivileges(account);

        AdminHomePageData data = new AdminHomePageData(account, sessionToken);

        data.instructorShortName = """";
        data.instructorName = """";
        data.instructorEmail = """";
        data.instructorInstitution = """";

        statusToAdmin = ""Admin Home Page Load"";

        return createShowPageResult(Const.ViewURIs.ADMIN_HOME, data);
    }

}
"
AdminInstructorAccountAddAction.java,ui-controller,"package teammates.ui.controller;

import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.List;
import java.util.TimeZone;

import teammates.common.datatransfer.DataBundle;
import teammates.common.datatransfer.attributes.FeedbackResponseCommentAttributes;
import teammates.common.datatransfer.attributes.InstructorAttributes;
import teammates.common.datatransfer.attributes.StudentAttributes;
import teammates.common.exception.EmailSendingException;
import teammates.common.exception.EntityDoesNotExistException;
import teammates.common.exception.InvalidParametersException;
import teammates.common.exception.TeammatesException;
import teammates.common.util.Config;
import teammates.common.util.Const;
import teammates.common.util.EmailWrapper;
import teammates.common.util.FieldValidator;
import teammates.common.util.JsonUtils;
import teammates.common.util.Logger;
import teammates.common.util.SanitizationHelper;
import teammates.common.util.StatusMessage;
import teammates.common.util.StatusMessageColor;
import teammates.common.util.StringHelper;
import teammates.common.util.Templates;
import teammates.common.util.Url;
import teammates.logic.api.EmailGenerator;
import teammates.logic.backdoor.BackDoorLogic;
import teammates.ui.pagedata.AdminHomePageData;

public class AdminInstructorAccountAddAction extends Action {

    private static final Logger log = Logger.getLogger();

    @Override
    protected ActionResult execute() {

        gateKeeper.verifyAdminPrivileges(account);

        AdminHomePageData data = new AdminHomePageData(account, sessionToken);

        data.instructorShortName = getNonNullRequestParamValue(Const.ParamsNames.INSTRUCTOR_SHORT_NAME).trim();
        data.instructorName = getNonNullRequestParamValue(Const.ParamsNames.INSTRUCTOR_NAME).trim();
        data.instructorEmail = getNonNullRequestParamValue(Const.ParamsNames.INSTRUCTOR_EMAIL).trim();
        data.instructorInstitution = getNonNullRequestParamValue(Const.ParamsNames.INSTRUCTOR_INSTITUTION).trim();
        data.isInstructorAddingResultForAjax = true;
        data.statusForAjax = """";

        data.instructorShortName = data.instructorShortName.trim();
        data.instructorName = data.instructorName.trim();
        data.instructorEmail = data.instructorEmail.trim();
        data.instructorInstitution = data.instructorInstitution.trim();

        try {
            logic.verifyInputForAdminHomePage(data.instructorShortName, data.instructorName,
                                              data.instructorInstitution, data.instructorEmail);
        } catch (InvalidParametersException e) {
            data.statusForAjax = e.getMessage().replace(Const.EOL, Const.HTML_BR_TAG);
            data.isInstructorAddingResultForAjax = false;
            statusToUser.add(new StatusMessage(data.statusForAjax, StatusMessageColor.DANGER));
            return createAjaxResult(data);
        }

        String courseId = null;

        try {
            courseId = importDemoData(data);
        } catch (Exception e) {

            String retryUrl = Const.ActionURIs.ADMIN_INSTRUCTORACCOUNT_ADD;
            retryUrl = Url.addParamToUrl(retryUrl, Const.ParamsNames.INSTRUCTOR_SHORT_NAME, data.instructorShortName);
            retryUrl = Url.addParamToUrl(retryUrl, Const.ParamsNames.INSTRUCTOR_NAME, data.instructorName);
            retryUrl = Url.addParamToUrl(retryUrl, Const.ParamsNames.INSTRUCTOR_EMAIL, data.instructorEmail);
            retryUrl = Url.addParamToUrl(retryUrl, Const.ParamsNames.INSTRUCTOR_INSTITUTION, data.instructorInstitution);
            retryUrl = Url.addParamToUrl(retryUrl, Const.ParamsNames.SESSION_TOKEN, data.getSessionToken());

            StringBuilder errorMessage = new StringBuilder(100);
            String retryLink = ""<a href="" + retryUrl + "">Exception in Importing Data, Retry</a>"";
            errorMessage.append(retryLink);

            statusToUser.add(new StatusMessage(errorMessage.toString(), StatusMessageColor.DANGER));

            String message = ""<span class=\""text-danger\"">Servlet Action failure in AdminInstructorAccountAddAction"" + ""<br>""
                             + e.getClass() + "": "" + TeammatesException.toStringWithStackTrace(e) + ""<br></span>"";

            errorMessage.append(""<br>"").append(message);
            statusToUser.add(new StatusMessage(""<br>"" + message, StatusMessageColor.DANGER));
            statusToAdmin = message;

            data.isInstructorAddingResultForAjax = false;
            data.statusForAjax = errorMessage.toString();
            return createAjaxResult(data);
        }

        List<InstructorAttributes> instructorList = logic.getInstructorsForCourse(courseId);
        String joinLink = Config.getAppUrl(Const.ActionURIs.INSTRUCTOR_COURSE_JOIN)
                                .withRegistrationKey(StringHelper.encrypt(instructorList.get(0).key))
                                .withInstructorInstitution(data.instructorInstitution)
                                .toAbsoluteString();
        EmailWrapper email = new EmailGenerator().generateNewInstructorAccountJoinEmail(
                instructorList.get(0).email, data.instructorShortName, joinLink);
        try {
            emailSender.sendEmail(email);
        } catch (EmailSendingException e) {
            log.severe(""Instructor welcome email failed to send: "" + TeammatesException.toStringWithStackTrace(e));
        }
        data.statusForAjax = ""Instructor "" + SanitizationHelper.sanitizeForHtml(data.instructorName)
                             + "" has been successfully created with join link:<br>"" + joinLink;
        statusToUser.add(new StatusMessage(data.statusForAjax, StatusMessageColor.SUCCESS));
        statusToAdmin = ""A New Instructor <span class=\""bold\"">""
                + SanitizationHelper.sanitizeForHtmlTag(data.instructorName) + ""</span> has been created.<br>""
                + ""<span class=\""bold\"">Id: </span>""
                + ""ID will be assigned when the verification link was clicked and confirmed""
                + ""<br>""
                + ""<span class=\""bold\"">Email: </span>"" + SanitizationHelper.sanitizeForHtmlTag(data.instructorEmail)
                + ""<span class=\""bold\"">Institution: </span>""
                + SanitizationHelper.sanitizeForHtmlTag(data.instructorInstitution);

        return createAjaxResult(data);
    }

    /**
     * Imports Demo course to new instructor.
     * @param pageData data from AdminHomePageData
     * @return the ID of Demo course
     */
    private String importDemoData(AdminHomePageData pageData)
            throws InvalidParametersException, EntityDoesNotExistException {

        String courseId = generateDemoCourseId(pageData.instructorEmail);
        Calendar c = Calendar.getInstance(TimeZone.getTimeZone(""UTC""));
        c.set(Calendar.AM_PM, Calendar.PM);
        c.set(Calendar.HOUR, 11);
        c.set(Calendar.MINUTE, 59);
        c.set(Calendar.YEAR, c.get(Calendar.YEAR) + 1);
        DateFormat formatter = new SimpleDateFormat(""yyyy-MM-dd hh:mm a Z"");

        String jsonString = Templates.populateTemplate(Templates.INSTRUCTOR_SAMPLE_DATA,
                // replace email
                ""teammates.demo.instructor@demo.course"", pageData.instructorEmail,
                // replace name
                ""Demo_Instructor"", pageData.instructorName,
                // replace course
                ""demo.course"", courseId,
                // update feedback session time
                ""2013-04-01 11:59 PM UTC"", formatter.format(c.getTime()));

        DataBundle data = JsonUtils.fromJson(jsonString, DataBundle.class);

        BackDoorLogic backDoorLogic = new BackDoorLogic();
        backDoorLogic.persistDataBundle(data);

        List<FeedbackResponseCommentAttributes> frComments =
                logic.getFeedbackResponseCommentForGiver(courseId, pageData.instructorEmail);
        List<StudentAttributes> students = logic.getStudentsForCourse(courseId);
        List<InstructorAttributes> instructors = logic.getInstructorsForCourse(courseId);

        logic.putFeedbackResponseCommentDocuments(frComments);
        logic.putStudentDocuments(students);
        logic.putInstructorDocuments(instructors);

        return courseId;
    }

    // Strategy to Generate New Demo Course Id:
    // a. keep the part of email before ""@""
    //    replace ""@"" with "".""
    //    replace email host with their first 3 chars. eg, gmail.com -> gma
    //    append ""-demo""
    //    to sum up: lebron@gmail.com -> lebron.gma-demo
    //
    // b. if the generated courseId already exists, create another one by appending a integer to the previous courseId.
    //    if the newly generate id still exists, increment the id, until we find a feasible one
    //    eg.
    //    lebron@gmail.com -> lebron.gma-demo  // already exists!
    //    lebron@gmail.com -> lebron.gma-demo0 // already exists!
    //    lebron@gmail.com -> lebron.gma-demo1 // already exists!
    //    ...
    //    lebron@gmail.com -> lebron.gma-demo99 // already exists!
    //    lebron@gmail.com -> lebron.gma-demo100 // found! a feasible id
    //
    // c. in any cases(a or b), if generated Id is longer than FieldValidator.COURSE_ID_MAX_LENGTH, shorten the part
    //    before ""@"" of the intial input email, by continuously remove its last character

    /**
     * Generate a course ID for demo course, and if the generated id already exists, try another one.
     *
     * @param instructorEmail is the instructor email.
     * @return generated course id
     */
    private String generateDemoCourseId(String instructorEmail) {
        String proposedCourseId = generateNextDemoCourseId(instructorEmail, FieldValidator.COURSE_ID_MAX_LENGTH);
        while (logic.getCourse(proposedCourseId) != null) {
            proposedCourseId = generateNextDemoCourseId(proposedCourseId, FieldValidator.COURSE_ID_MAX_LENGTH);
        }
        return proposedCourseId;
    }

    /**
     * Generate a course ID for demo course from a given email.
     *
     * @param instructorEmail is the instructor email.
     * @return the first proposed course id. eg.lebron@gmail.com -> lebron.gma-demo
     */
    private String getDemoCourseIdRoot(String instructorEmail) {
        String[] emailSplit = instructorEmail.split(""@"");

        String username = emailSplit[0];
        String host = emailSplit[1];

        String head = StringHelper.replaceIllegalChars(username, FieldValidator.REGEX_COURSE_ID, '_');
        String hostAbbreviation = host.substring(0, 3);

        return head + ""."" + hostAbbreviation + ""-demo"";
    }

    /**
     * Generate a course ID for demo course from a given email or a generated course Id.
     *
     * <p>Here we check the input string is an email or course Id and handle them accordingly;
     * check the resulting course id, and if bigger than maximumIdLength, cut it so that it equals maximumIdLength.
     *
     * @param instructorEmailOrProposedCourseId is the instructor email or a proposed course id that already exists.
     * @param maximumIdLength is the maximum resulting id length allowed, above which we will cut the part before ""@""
     * @return the proposed course id, e.g.:
     *         <ul>
     *         <li>lebron@gmail.com -> lebron.gma-demo</li>
     *         <li>lebron.gma-demo -> lebron.gma-demo0</li>
     *         <li>lebron.gma-demo0 -> lebron.gma-demo1</li>
     *         <li>012345678901234567890123456789.gma-demo9 -> 01234567890123456789012345678.gma-demo10 (being cut)</li>
     *         </ul>
     */
    private String generateNextDemoCourseId(String instructorEmailOrProposedCourseId, int maximumIdLength) {
        final boolean isFirstCourseId = instructorEmailOrProposedCourseId.contains(""@"");
        if (isFirstCourseId) {
            return StringHelper.truncateHead(getDemoCourseIdRoot(instructorEmailOrProposedCourseId),
                                             maximumIdLength);
        }

        final boolean isFirstTimeDuplicate = instructorEmailOrProposedCourseId.endsWith(""-demo"");
        if (isFirstTimeDuplicate) {
            return StringHelper.truncateHead(instructorEmailOrProposedCourseId + ""0"",
                                             maximumIdLength);
        }

        final int lastIndexOfDemo = instructorEmailOrProposedCourseId.lastIndexOf(""-demo"");
        final String root = instructorEmailOrProposedCourseId.substring(0, lastIndexOfDemo);
        final int previousDedupSuffix = Integer.parseInt(instructorEmailOrProposedCourseId.substring(lastIndexOfDemo + 5));

        return StringHelper.truncateHead(root + ""-demo"" + (previousDedupSuffix + 1), maximumIdLength);
    }
}
"
AdminSearchPageAction.java,ui-controller,"package teammates.ui.controller;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import teammates.common.datatransfer.attributes.AccountAttributes;
import teammates.common.datatransfer.attributes.CourseAttributes;
import teammates.common.datatransfer.attributes.FeedbackSessionAttributes;
import teammates.common.datatransfer.attributes.InstructorAttributes;
import teammates.common.datatransfer.attributes.StudentAttributes;
import teammates.common.util.Config;
import teammates.common.util.Const;
import teammates.common.util.SanitizationHelper;
import teammates.common.util.StatusMessage;
import teammates.common.util.StatusMessageColor;
import teammates.common.util.StringHelper;
import teammates.common.util.Url;
import teammates.ui.pagedata.AdminSearchPageData;

public class AdminSearchPageAction extends Action {

    private static final String OPEN_CLOSE_DATES_SESSION_TEMPLATE = ""[%s - %s]"";

    private Map<String, String> tempCourseIdToInstituteMap = new HashMap<>();
    private Map<String, String> tempCourseIdToInstructorGoogleIdMap = new HashMap<>();

    @Override
    protected ActionResult execute() {

        gateKeeper.verifyAdminPrivileges(account);

        String searchKey = getRequestParamValue(Const.ParamsNames.ADMIN_SEARCH_KEY);
        String searchButtonHit = getRequestParamValue(Const.ParamsNames.ADMIN_SEARCH_BUTTON_HIT);

        AdminSearchPageData data = new AdminSearchPageData(account, sessionToken);

        if (searchKey == null || searchKey.trim().isEmpty()) {

            if (searchButtonHit == null) {
                statusToAdmin = ""AdminSearchPaga Page Load"";
            } else {
                statusToUser.add(new StatusMessage(""Search key cannot be empty"", StatusMessageColor.WARNING));
                statusToAdmin = ""Invalid Search: Search key cannot be empty"";
                isError = true;
            }
            return createShowPageResult(Const.ViewURIs.ADMIN_SEARCH, data);
        }

        data.searchKey = SanitizationHelper.sanitizeForHtml(searchKey);

        data.studentResultBundle = logic.searchStudentsInWholeSystem(searchKey);

        data = putFeedbackSessionLinkIntoMap(data.studentResultBundle.studentList, data);
        data = putStudentHomePageLinkIntoMap(data.studentResultBundle.studentList, data);
        data = putStudentRecordsPageLinkIntoMap(data.studentResultBundle.studentList, data);
        data = putStudentInstituteIntoMap(data.studentResultBundle.studentList, data);

        data.instructorResultBundle = logic.searchInstructorsInWholeSystem(searchKey);
        data = putInstructorInstituteIntoMap(data.instructorResultBundle.instructorList, data);
        data = putInstructorHomePageLinkIntoMap(data.instructorResultBundle.instructorList, data);
        data = putInstructorCourseJoinLinkIntoMap(data.instructorResultBundle.instructorList, data);

        data = putCourseNameIntoMap(data.studentResultBundle.studentList,
                                    data.instructorResultBundle.instructorList,
                                    data);

        int numOfResults = data.studentResultBundle.numberOfResults
                           + data.instructorResultBundle.numberOfResults;

        if (numOfResults > 0) {
            statusToUser.add(new StatusMessage(""Total results found: "" + numOfResults, StatusMessageColor.INFO));
            statusToAdmin = ""Search Key: "" + data.searchKey + ""<br>"" + ""Total results found: "" + numOfResults;
            isError = false;
        } else {
            statusToUser.add(new StatusMessage(""No result found, please try again"", StatusMessageColor.WARNING));
            statusToAdmin = ""Search Key: "" + data.searchKey + ""<br>"" + ""No result found"";
            isError = true;
        }

        data.init();
        return createShowPageResult(Const.ViewURIs.ADMIN_SEARCH, data);
    }

    private AdminSearchPageData putCourseNameIntoMap(List<StudentAttributes> students,
                                                     List<InstructorAttributes> instructors,
                                                     AdminSearchPageData data) {
        for (StudentAttributes student : students) {
            if (student.course != null && !data.courseIdToCourseNameMap.containsKey(student.course)) {
                CourseAttributes course = logic.getCourse(student.course);
                if (course != null) {
                    //TODO: [CourseAttribute] remove desanitization after data migration
                    data.courseIdToCourseNameMap.put(
                            student.course, SanitizationHelper.desanitizeIfHtmlSanitized(course.getName()));
                }
            }
        }

        for (InstructorAttributes instructor : instructors) {
            if (instructor.courseId != null && !data.courseIdToCourseNameMap.containsKey(instructor.courseId)) {
                CourseAttributes course = logic.getCourse(instructor.courseId);
                if (course != null) {
                    //TODO: [CourseAttribute] remove desanitization after data migration
                    data.courseIdToCourseNameMap.put(
                            instructor.courseId, SanitizationHelper.desanitizeIfHtmlSanitized(course.getName()));
                }
            }
        }

        return data;
    }

    private AdminSearchPageData putInstructorCourseJoinLinkIntoMap(List<InstructorAttributes> instructors,
                                                                   AdminSearchPageData data) {

        for (InstructorAttributes instructor : instructors) {

            String googleIdOfAlreadyRegisteredInstructor = findAvailableInstructorGoogleIdForCourse(instructor.courseId);

            if (!googleIdOfAlreadyRegisteredInstructor.isEmpty()) {
                String joinLinkWithoutInstitute = Config.getAppUrl(Const.ActionURIs.INSTRUCTOR_COURSE_JOIN)
                                                .withRegistrationKey(StringHelper.encrypt(instructor.key))
                                                .toAbsoluteString();
                data.instructorCourseJoinLinkMap.put(instructor.getIdentificationString(),
                                                     joinLinkWithoutInstitute);
            }

        }

        return data;
    }

    private AdminSearchPageData putInstructorInstituteIntoMap(List<InstructorAttributes> instructors,
                                                              AdminSearchPageData data) {
        for (InstructorAttributes instructor : instructors) {

            if (tempCourseIdToInstituteMap.get(instructor.courseId) != null) {
                data.instructorInstituteMap.put(instructor.getIdentificationString(),
                                                tempCourseIdToInstituteMap.get(instructor.courseId));
                continue;
            }

            String googleId = findAvailableInstructorGoogleIdForCourse(instructor.courseId);

            AccountAttributes account = logic.getAccount(googleId);
            if (account == null) {
                continue;
            }

            String institute = account.institute.trim().isEmpty() ? ""None"" : account.institute;

            tempCourseIdToInstituteMap.put(instructor.courseId, institute);
            data.instructorInstituteMap.put(instructor.getIdentificationString(), institute);
        }

        return data;
    }

    private AdminSearchPageData putInstructorHomePageLinkIntoMap(List<InstructorAttributes> instructors,
                                                                 AdminSearchPageData data) {

        for (InstructorAttributes instructor : instructors) {

            if (instructor.googleId == null) {
                continue;
            }

            String curLink = Url.addParamToUrl(Const.ActionURIs.INSTRUCTOR_HOME_PAGE,
                                                        Const.ParamsNames.USER_ID,
                                                        instructor.googleId);

            data.instructorHomePageLinkMap.put(instructor.googleId, curLink);
        }

        return data;
    }

    private AdminSearchPageData putStudentInstituteIntoMap(List<StudentAttributes> students, AdminSearchPageData data) {
        for (StudentAttributes student : students) {

            if (tempCourseIdToInstituteMap.get(student.course) != null) {
                data.studentInstituteMap.put(student.getIdentificationString(),
                                             tempCourseIdToInstituteMap.get(student.course));
                continue;
            }

            String instructorForCourseGoogleId = findAvailableInstructorGoogleIdForCourse(student.course);

            AccountAttributes account = logic.getAccount(instructorForCourseGoogleId);
            if (account == null) {
                continue;
            }

            String institute = account.institute.trim().isEmpty() ? ""None"" : account.institute;

            tempCourseIdToInstituteMap.put(student.course, institute);

            data.studentInstituteMap.put(student.getIdentificationString(), institute);
        }

        return data;
    }

    private AdminSearchPageData putStudentHomePageLinkIntoMap(List<StudentAttributes> students, AdminSearchPageData data) {

        for (StudentAttributes student : students) {

            if (student.googleId == null) {
                continue;
            }

            String curLink = Url.addParamToUrl(Const.ActionURIs.STUDENT_HOME_PAGE,
                                                        Const.ParamsNames.USER_ID,
                                                        student.googleId);

            data.studentIdToHomePageLinkMap.put(student.googleId, curLink);
        }

        return data;
    }

    private AdminSearchPageData putStudentRecordsPageLinkIntoMap(List<StudentAttributes> students,
                                                                 AdminSearchPageData data) {

        for (StudentAttributes student : students) {

            if (student.course == null || student.email == null) {
                continue;
            }

            String curLink = Url.addParamToUrl(Const.ActionURIs.INSTRUCTOR_STUDENT_RECORDS_PAGE,
                                                        Const.ParamsNames.COURSE_ID,
                                                        student.course);
            curLink = Url.addParamToUrl(curLink, Const.ParamsNames.STUDENT_EMAIL, student.email);
            String availableGoogleId = findAvailableInstructorGoogleIdForCourse(student.course);

            if (!availableGoogleId.isEmpty()) {
                curLink = Url.addParamToUrl(curLink, Const.ParamsNames.USER_ID, availableGoogleId);
                data.studentRecordsPageLinkMap.put(student.getIdentificationString(), curLink);
            }
        }

        return data;
    }

    /**
     * Finds the googleId of a registered instructor with co-owner privileges.
     * If there is no such instructor, finds the googleId of a registered
     * instructor with the privilege to modify instructors.
     *
     * @param courseId
     *            the ID of the course
     * @return the googleId of a suitable instructor if found, otherwise an
     *         empty string
     */
    private String findAvailableInstructorGoogleIdForCourse(String courseId) {

        if (tempCourseIdToInstructorGoogleIdMap.get(courseId) != null) {
            return tempCourseIdToInstructorGoogleIdMap.get(courseId);
        }

        List<InstructorAttributes> instructorList = logic.getInstructorsForCourse(courseId);

        if (instructorList.isEmpty()) {
            return """";
        }

        for (InstructorAttributes instructor : instructorList) {

            if (instructor.isRegistered() && instructor.hasCoownerPrivileges()) {
                tempCourseIdToInstructorGoogleIdMap.put(courseId, instructor.googleId);
                return instructor.googleId;
            }
        }

        for (InstructorAttributes instructor : instructorList) {

            if (instructor.isRegistered()
                    && instructor.isAllowedForPrivilege(Const.ParamsNames.INSTRUCTOR_PERMISSION_MODIFY_INSTRUCTOR)) {

                tempCourseIdToInstructorGoogleIdMap.put(courseId, instructor.googleId);
                return instructor.googleId;
            }
        }

        return """";
    }

    private AdminSearchPageData putFeedbackSessionLinkIntoMap(List<StudentAttributes> students,
                                                              AdminSearchPageData rawData) {

        AdminSearchPageData processedData = rawData;

        for (StudentAttributes student : students) {
            List<FeedbackSessionAttributes> feedbackSessions = logic.getFeedbackSessionsForCourse(student.course);

            for (FeedbackSessionAttributes fsa : feedbackSessions) {
                processedData = extractDataFromFeedbackSession(fsa, processedData, student);
            }
        }

        return processedData;

    }

    private AdminSearchPageData extractDataFromFeedbackSession(FeedbackSessionAttributes fsa,
                                                               AdminSearchPageData data,
                                                               StudentAttributes student) {

        String submitUrl = Config.getAppUrl(Const.ActionURIs.STUDENT_FEEDBACK_SUBMISSION_EDIT_PAGE)
                               .withCourseId(student.course)
                               .withSessionName(fsa.getFeedbackSessionName())
                               .withRegistrationKey(StringHelper.encrypt(student.key))
                               .withStudentEmail(student.email)
                               .toAbsoluteString();

        String openCloseDateFragment = generateOpenCloseDateInfo(fsa.getStartTimeString(), fsa.getEndTimeString());

        if (fsa.isOpened()) {
            if (data.studentOpenFeedbackSessionLinksMap.get(student.getIdentificationString()) == null) {
                List<String> submitUrlList = new ArrayList<>();
                submitUrlList.add(submitUrl);
                data.studentOpenFeedbackSessionLinksMap.put(student.getIdentificationString(), submitUrlList);
            } else {
                data.studentOpenFeedbackSessionLinksMap.get(student.getIdentificationString()).add(submitUrl);
            }

            data.feedbackSessionLinkToNameMap.put(submitUrl, fsa.getFeedbackSessionName() + "" ""
                    + openCloseDateFragment);

        } else {
            if (data.studentUnOpenedFeedbackSessionLinksMap.get(student.getIdentificationString()) == null) {
                List<String> submitUrlList = new ArrayList<>();
                submitUrlList.add(submitUrl);
                data.studentUnOpenedFeedbackSessionLinksMap.put(student.getIdentificationString(), submitUrlList);
            } else {
                data.studentUnOpenedFeedbackSessionLinksMap.get(student.getIdentificationString()).add(submitUrl);
            }

            data.feedbackSessionLinkToNameMap.put(submitUrl, fsa.getFeedbackSessionName() + "" (Currently Not Open) ""
                    + openCloseDateFragment);
        }

        String viewResultUrl = Config.getAppUrl(Const.ActionURIs.STUDENT_FEEDBACK_RESULTS_PAGE)
                                   .withCourseId(student.course)
                                   .withSessionName(fsa.getFeedbackSessionName())
                                   .withRegistrationKey(StringHelper.encrypt(student.key))
                                   .withStudentEmail(student.email)
                                   .toAbsoluteString();

        if (fsa.isPublished()) {
            if (data.studentPublishedFeedbackSessionLinksMap.get(student.getIdentificationString()) == null) {
                List<String> viewResultUrlList = new ArrayList<>();
                viewResultUrlList.add(viewResultUrl);
                data.studentPublishedFeedbackSessionLinksMap.put(student.getIdentificationString(), viewResultUrlList);
            } else {
                data.studentPublishedFeedbackSessionLinksMap.get(student.getIdentificationString()).add(viewResultUrl);
            }

            data.feedbackSessionLinkToNameMap.put(viewResultUrl, fsa.getFeedbackSessionName() + "" (Published) ""
                    + openCloseDateFragment);
        }
        return data;
    }

    private String generateOpenCloseDateInfo(String startTime, String endTime) {
        return String.format(OPEN_CLOSE_DATES_SESSION_TEMPLATE, startTime, endTime);
    }

}
"
AdminSessionsPageAction.java,ui-controller,"package teammates.ui.controller;

import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import teammates.common.datatransfer.attributes.AccountAttributes;
import teammates.common.datatransfer.attributes.FeedbackSessionAttributes;
import teammates.common.datatransfer.attributes.InstructorAttributes;
import teammates.common.util.Const;
import teammates.common.util.SanitizationHelper;
import teammates.common.util.StatusMessage;
import teammates.common.util.StatusMessageColor;
import teammates.common.util.TimeHelper;
import teammates.ui.pagedata.AdminSessionsPageData;

public class AdminSessionsPageAction extends Action {

    private static final String UNKNOWN_INSTITUTION = ""Unknown"";

    private AdminSessionsPageData data;

    private Map<String, List<FeedbackSessionAttributes>> map;
    private Map<String, String> sessionToInstructorIdMap = new HashMap<>();
    private int totalOngoingSessions;
    private int totalOpenStatusSessions;
    private int totalClosedStatusSessions;
    private int totalWaitToOpenStatusSessions;
    private int totalInstitutes;
    private Date rangeStart;
    private Date rangeEnd;
    private double zone;
    private boolean isShowAll;

    @Override
    protected ActionResult execute() {

        gateKeeper.verifyAdminPrivileges(account);
        data = new AdminSessionsPageData(account, sessionToken);

        isShowAll = getRequestParamAsBoolean(""all"");

        ActionResult result = createShowPageResultIfParametersInvalid();
        if (result != null) {
            return result;
        }

        List<FeedbackSessionAttributes> allOpenFeedbackSessionsList =
                logic.getAllOpenFeedbackSessions(this.rangeStart, this.rangeEnd, this.zone);

        result = createShowPageResultIfNoOngoingSession(allOpenFeedbackSessionsList);
        if (result != null) {
            return result;
        }

        result = createAdminSessionPageResult(allOpenFeedbackSessionsList);

        return result;

    }

    private void putIntoUnknownList(
            Map<String, List<FeedbackSessionAttributes>> map, FeedbackSessionAttributes fs) {
        if (map.get(""Unknown"") == null) {
            List<FeedbackSessionAttributes> newList = new ArrayList<>();
            newList.add(fs);
            map.put(""Unknown"", newList);
        } else {
            map.get(""Unknown"").add(fs);
        }
    }

    private void prepareDefaultPageData(Calendar calStart, Calendar calEnd) {
        this.map = new HashMap<>();
        this.totalOngoingSessions = 0;
        this.totalOpenStatusSessions = 0;
        this.totalClosedStatusSessions = 0;
        this.totalOpenStatusSessions = 0;
        this.totalInstitutes = 0;
        this.rangeStart = calStart.getTime();
        this.rangeEnd = calEnd.getTime();
    }

    private ActionResult createShowPageResultIfParametersInvalid() {
        String startDate = getRequestParamValue(Const.ParamsNames.FEEDBACK_SESSION_STARTDATE);
        String endDate = getRequestParamValue(Const.ParamsNames.FEEDBACK_SESSION_ENDDATE);
        String startHour = getRequestParamValue(Const.ParamsNames.FEEDBACK_SESSION_STARTHOUR);
        String endHour = getRequestParamValue(Const.ParamsNames.FEEDBACK_SESSION_ENDHOUR);
        String startMin = getRequestParamValue(Const.ParamsNames.FEEDBACK_SESSION_STARTMINUTE);
        String endMin = getRequestParamValue(Const.ParamsNames.FEEDBACK_SESSION_ENDMINUTE);
        String timeZone = getRequestParamValue(Const.ParamsNames.FEEDBACK_SESSION_TIMEZONE);

        Date start;
        Date end;
        double zone = 0.0;

        Calendar calStart = TimeHelper.now(zone);
        Calendar calEnd = TimeHelper.now(zone);
        calStart.add(Calendar.DAY_OF_YEAR, -3);
        calEnd.add(Calendar.DAY_OF_YEAR, 4);

        if (checkAllParameters(""null"")) {
            start = calStart.getTime();
            end = calEnd.getTime();
        } else if (checkAllParameters(""notNull"")) {

            SanitizationHelper.sanitizeForHtml(startDate);
            SanitizationHelper.sanitizeForHtml(endDate);
            SanitizationHelper.sanitizeForHtml(startHour);
            SanitizationHelper.sanitizeForHtml(endHour);
            SanitizationHelper.sanitizeForHtml(startMin);
            SanitizationHelper.sanitizeForHtml(endMin);
            SanitizationHelper.sanitizeForHtml(timeZone);

            zone = Double.parseDouble(timeZone);

            start = TimeHelper.convertToDate(TimeHelper.convertToRequiredFormat(startDate, startHour, startMin));
            end = TimeHelper.convertToDate(TimeHelper.convertToRequiredFormat(endDate, endHour, endMin));

            if (start.after(end)) {
                isError = true;
                statusToUser.add(new StatusMessage(""The filter range is not valid.""
                                 + "" End time should be after start time."", StatusMessageColor.DANGER));
                statusToAdmin = ""Admin Sessions Page Load<br>""
                              + ""<span class=\""bold\""> Error: invalid filter range</span>"";

                prepareDefaultPageData(calStart, calEnd);
                data.init(this.map, this.sessionToInstructorIdMap, this.totalOngoingSessions,
                          this.totalOpenStatusSessions, this.totalClosedStatusSessions,
                          this.totalWaitToOpenStatusSessions, this.totalInstitutes, this.rangeStart,
                          this.rangeEnd, this.zone, this.isShowAll);
                return createShowPageResult(Const.ViewURIs.ADMIN_SESSIONS, data);
            }

        } else {

            isError = true;
            statusToUser.add(new StatusMessage(""Error: Missing Parameters"", StatusMessageColor.DANGER));
            statusToAdmin = ""Admin Sessions Page Load<br>""
                          + ""<span class=\""bold\""> Error: Missing Parameters</span>"";

            prepareDefaultPageData(calStart, calEnd);
            data.init(this.map, this.sessionToInstructorIdMap, this.totalOngoingSessions,
                      this.totalOpenStatusSessions, this.totalClosedStatusSessions, this.totalWaitToOpenStatusSessions,
                      this.totalInstitutes, this.rangeStart, this.rangeEnd, this.zone, this.isShowAll);
            return createShowPageResult(Const.ViewURIs.ADMIN_SESSIONS, data);

        }

        this.rangeStart = start;
        this.rangeEnd = end;
        this.zone = zone;

        return null;
    }

    private ActionResult createShowPageResultIfNoOngoingSession(
            List<FeedbackSessionAttributes> allOpenFeedbackSessionsList) {
        if (allOpenFeedbackSessionsList.isEmpty()) {

            isError = false;
            statusToUser.add(new StatusMessage(""Currently No Ongoing Sessions"", StatusMessageColor.WARNING));
            statusToAdmin = ""Admin Sessions Page Load<br>""
                          + ""<span class=\""bold\""> No Ongoing Sessions</span>"";

            this.map = new HashMap<>();
            this.totalOngoingSessions = 0;
            this.totalOpenStatusSessions = 0;
            this.totalClosedStatusSessions = 0;
            this.totalWaitToOpenStatusSessions = 0;
            this.totalInstitutes = 0;
            data.init(this.map, this.sessionToInstructorIdMap, this.totalOngoingSessions,
                      this.totalOpenStatusSessions, this.totalClosedStatusSessions, this.totalWaitToOpenStatusSessions,
                      this.totalInstitutes, this.rangeStart, this.rangeEnd, this.zone, this.isShowAll);
            return createShowPageResult(Const.ViewURIs.ADMIN_SESSIONS, data);
        }

        return null;

    }

    private ActionResult createAdminSessionPageResult(List<FeedbackSessionAttributes> allOpenFeedbackSessionsList) {
        HashMap<String, List<FeedbackSessionAttributes>> map = new HashMap<>();
        this.totalOngoingSessions = allOpenFeedbackSessionsList.size();
        this.totalOpenStatusSessions = getTotalNumOfOpenStatusSession(allOpenFeedbackSessionsList);
        this.totalClosedStatusSessions = getTotalNumOfCloseStatusSession(allOpenFeedbackSessionsList);
        this.totalWaitToOpenStatusSessions = getTotalNumOfWaitToOpenStatusSession(allOpenFeedbackSessionsList);

        for (FeedbackSessionAttributes fs : allOpenFeedbackSessionsList) {

            List<InstructorAttributes> instructors = logic.getInstructorsForCourse(fs.getCourseId());

            if (instructors.isEmpty()) {
                putIntoUnknownList(map, fs);
            } else {
                AccountAttributes account = getRegisteredInstructorAccountFromInstructors(instructors);

                if (account == null) {
                    putIntoUnknownList(map, fs);
                    continue;
                }

                if (map.get(account.institute) == null) {
                    List<FeedbackSessionAttributes> newList = new ArrayList<>();
                    newList.add(fs);
                    map.put(account.institute, newList);
                } else {
                    map.get(account.institute).add(fs);
                }

            }
        }
        this.map = map;
        this.totalInstitutes = getTotalInstitutes(map);
        statusToAdmin = ""Admin Sessions Page Load<br>""
                      + ""<span class=\""bold\"">Total Ongoing Sessions:</span> ""
                      + this.totalOngoingSessions
                      + ""<span class=\""bold\"">Total Opened Sessions:</span> ""
                      + this.totalOpenStatusSessions;

        constructSessionToInstructorIdMap();
        data.init(this.map, this.sessionToInstructorIdMap, this.totalOngoingSessions,
                  this.totalOpenStatusSessions, this.totalClosedStatusSessions, this.totalWaitToOpenStatusSessions,
                  this.totalInstitutes, this.rangeStart, this.rangeEnd, this.zone, this.isShowAll);
        return createShowPageResult(Const.ViewURIs.ADMIN_SESSIONS, data);
    }

    private void constructSessionToInstructorIdMap() {
        for (Map.Entry<String, List<FeedbackSessionAttributes>> entry : this.map.entrySet()) {
            for (FeedbackSessionAttributes fs : entry.getValue()) {
                String googleId = findAvailableInstructorGoogleIdForCourse(fs.getCourseId());
                this.sessionToInstructorIdMap.put(fs.getIdentificationString(), googleId);
            }
        }
    }

    /**
     * This method loops through all instructors for the given course until a registered Instructor is found.
     * It returns the google id of the found instructor.
     * @return empty string if no available instructor google id is found
     */
    private String findAvailableInstructorGoogleIdForCourse(String courseId) {

        for (InstructorAttributes instructor : logic.getInstructorsForCourse(courseId)) {

            if (instructor.googleId != null) {
                return instructor.googleId;
            }
        }

        return """";
    }

    private AccountAttributes getRegisteredInstructorAccountFromInstructors(List<InstructorAttributes> instructors) {

        for (InstructorAttributes instructor : instructors) {
            if (instructor.googleId != null) {
                return logic.getAccount(instructor.googleId);
            }
        }

        return null;
    }

    private int getTotalNumOfOpenStatusSession(List<FeedbackSessionAttributes> allOpenFeedbackSessionsList) {

        int numOfTotal = 0;
        for (FeedbackSessionAttributes sessionAttributes : allOpenFeedbackSessionsList) {
            if (sessionAttributes.isOpened()) {
                numOfTotal += 1;
            }
        }

        return numOfTotal;
    }

    private int getTotalNumOfCloseStatusSession(List<FeedbackSessionAttributes> allOpenFeedbackSessionsList) {

        int numOfTotal = 0;
        for (FeedbackSessionAttributes sessionAttributes : allOpenFeedbackSessionsList) {
            if (sessionAttributes.isClosed()) {
                numOfTotal += 1;
            }
        }

        return numOfTotal;
    }

    private int getTotalNumOfWaitToOpenStatusSession(List<FeedbackSessionAttributes> allOpenFeedbackSessionsList) {

        int numOfTotal = 0;
        for (FeedbackSessionAttributes sessionAttributes : allOpenFeedbackSessionsList) {
            if (sessionAttributes.isWaitingToOpen()) {
                numOfTotal += 1;
            }
        }

        return numOfTotal;
    }

    private int getTotalInstitutes(Map<String, List<FeedbackSessionAttributes>> map) {

        int numOfTotal = 0;
        for (String key : map.keySet()) {
            if (!key.equals(UNKNOWN_INSTITUTION)) {
                numOfTotal += 1;
            }
        }
        return numOfTotal;
    }

    private boolean checkAllParameters(String condition) {

        String startDate = getRequestParamValue(Const.ParamsNames.FEEDBACK_SESSION_STARTDATE);
        String endDate = getRequestParamValue(Const.ParamsNames.FEEDBACK_SESSION_ENDDATE);
        String startHour = getRequestParamValue(Const.ParamsNames.FEEDBACK_SESSION_STARTHOUR);
        String endHour = getRequestParamValue(Const.ParamsNames.FEEDBACK_SESSION_ENDHOUR);
        String startMin = getRequestParamValue(Const.ParamsNames.FEEDBACK_SESSION_STARTMINUTE);
        String endMin = getRequestParamValue(Const.ParamsNames.FEEDBACK_SESSION_ENDMINUTE);
        String timeZone = getRequestParamValue(Const.ParamsNames.FEEDBACK_SESSION_TIMEZONE);

        if (condition.contentEquals(""null"")) {

            return startDate == null && endDate == null && startHour == null
                   && endHour == null && startMin == null && endMin == null && timeZone == null;

        } else if (condition.contentEquals(""notNull"")) {

            return startDate != null && endDate != null && startHour != null
                   && endHour != null && startMin != null && endMin != null && timeZone != null
                   && !startDate.trim().isEmpty() && !endDate.trim().isEmpty() && !startHour.trim().isEmpty()
                   && !endHour.trim().isEmpty() && !startMin.trim().isEmpty()
                   && !endMin.trim().isEmpty() && !timeZone.trim().isEmpty();

        } else {
            return false;
        }

    }

}
"
AdminStudentGoogleIdResetAction.java,ui-controller,"package teammates.ui.controller;

import teammates.common.datatransfer.attributes.StudentAttributes;
import teammates.common.exception.EntityDoesNotExistException;
import teammates.common.exception.InvalidParametersException;
import teammates.common.util.Const;
import teammates.common.util.StatusMessage;
import teammates.common.util.StatusMessageColor;
import teammates.ui.pagedata.AdminStudentGoogleIdResetPageData;

/**
 * This Action is used in AdminSearchPage to reset the google id of a
 * registered student in the searched results. Selected student in a
 * specific course will have its google id attribute reset to null.
 * Reset is done through Ajax and once the reset is successfully completed,
 * an notification will be sent to the original email address associated with the student.
 */
public class AdminStudentGoogleIdResetAction extends Action {

    @Override
    protected ActionResult execute() throws EntityDoesNotExistException {

        gateKeeper.verifyAdminPrivileges(account);

        String studentEmail = getRequestParamValue(Const.ParamsNames.STUDENT_EMAIL);
        String studentCourseId = getRequestParamValue(Const.ParamsNames.COURSE_ID);
        String wrongGoogleId = getRequestParamValue(Const.ParamsNames.STUDENT_ID);

        AdminStudentGoogleIdResetPageData data = new AdminStudentGoogleIdResetPageData(account, sessionToken);

        if (studentEmail != null && studentCourseId != null) {
            try {
                logic.resetStudentGoogleId(studentEmail, studentCourseId);
                taskQueuer.scheduleCourseRegistrationInviteToStudent(studentCourseId, studentEmail, true);
            } catch (InvalidParametersException e) {
                statusToUser.add(new StatusMessage(Const.StatusMessages.STUDENT_GOOGLEID_RESET_FAIL,
                                                   StatusMessageColor.DANGER));
                statusToAdmin = Const.StatusMessages.STUDENT_GOOGLEID_RESET_FAIL + ""<br>""
                              + ""Email: "" + studentEmail + ""<br>""
                              + ""CourseId: "" + studentCourseId + ""<br>""
                              + ""Failed with error<br>""
                              + e.getMessage();
                isError = true;
            }

            StudentAttributes updatedStudent = logic.getStudentForEmail(studentCourseId, studentEmail);

            if (updatedStudent.googleId == null || updatedStudent.googleId.isEmpty()) {

                statusToUser.add(new StatusMessage(Const.StatusMessages.STUDENT_GOOGLEID_RESET, StatusMessageColor.SUCCESS));
                statusToUser.add(new StatusMessage(""Email : "" + studentEmail, StatusMessageColor.SUCCESS));
                statusToUser.add(new StatusMessage(""CourseId : "" + studentCourseId, StatusMessageColor.SUCCESS));

                statusToAdmin = Const.StatusMessages.STUDENT_GOOGLEID_RESET + ""<br>""
                              + ""Email: "" + studentEmail + ""<br>""
                              + ""CourseId: "" + studentCourseId;

                data.statusForAjax = Const.StatusMessages.STUDENT_GOOGLEID_RESET + ""<br>""
                                   + ""Email : "" + studentEmail + ""<br>""
                                   + ""CourseId : "" + studentCourseId;

                data.isGoogleIdReset = true;
                deleteAccountIfNeeded(wrongGoogleId);
            } else {
                data.isGoogleIdReset = false;
                statusToUser.add(new StatusMessage(Const.StatusMessages.STUDENT_GOOGLEID_RESET_FAIL,
                                                   StatusMessageColor.DANGER));
                statusToAdmin = Const.StatusMessages.STUDENT_GOOGLEID_RESET_FAIL + ""<br>""
                              + ""Email: "" + studentEmail + ""<br>""
                              + ""CourseId: "" + studentCourseId + ""<br>"";
                data.statusForAjax = Const.StatusMessages.STUDENT_GOOGLEID_RESET_FAIL + ""<br>""
                                   + ""Email : "" + studentEmail + ""<br>""
                                   + ""CourseId : "" + studentCourseId;
            }

            isError = false;
            return createAjaxResult(data);
        }

        isError = true;
        return createAjaxResult(data);
    }

    private void deleteAccountIfNeeded(String wrongGoogleId) {
        if (logic.getStudentsForGoogleId(wrongGoogleId).isEmpty()
                && logic.getInstructorsForGoogleId(wrongGoogleId).isEmpty()) {
            logic.deleteAccount(wrongGoogleId);
        }
    }
}
"
AjaxResult.java,ui-controller,"package teammates.ui.controller;

import java.io.IOException;
import java.util.List;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import teammates.common.datatransfer.attributes.AccountAttributes;
import teammates.common.util.Const;
import teammates.common.util.JsonUtils;
import teammates.common.util.StatusMessage;
import teammates.ui.pagedata.PageData;

public class AjaxResult extends ActionResult {

    /** The data that will be sent back to the caller. */
    public PageData data;
    private boolean isClearingStatusMessage = true;

    public AjaxResult(String destination,
                      AccountAttributes account,
                      List<StatusMessage> status) {
        super(destination, account, status);
    }

    public AjaxResult(AccountAttributes account,
                      List<StatusMessage> status,
                      PageData data) {
        super("""", account, status);
        this.data = data;
    }

    public AjaxResult(AccountAttributes account,
                      List<StatusMessage> status,
                      PageData data, boolean isClearingStatusMessage) {
        this(account, status, data);
        this.isClearingStatusMessage = isClearingStatusMessage;
    }

    @Override
    public void send(HttpServletRequest req, HttpServletResponse resp) throws IOException {

        req.setAttribute(Const.ParamsNames.ERROR, Boolean.toString(isError));

        addStatusMessagesToPageData(req);

        if (isClearingStatusMessage) {
            clearStatusMessageForRequest(req);
        }

        resp.setContentType(""application/json"");
        resp.setCharacterEncoding(""UTF-8"");
        String jsonData = JsonUtils.toJson(data);

        resp.getWriter().write(jsonData);
    }

    /**
     * Adds the list of status messages (if any) to the page data.
     * @param req HttpServletRequest object
     */
    private void addStatusMessagesToPageData(HttpServletRequest req) {
        @SuppressWarnings(""unchecked"")
        List<StatusMessage> statusMessagesToUser =
                (List<StatusMessage>) req.getSession().getAttribute(Const.ParamsNames.STATUS_MESSAGES_LIST);

        // If the list of status messages can be found in the session and it is not empty,
        // means there are status messages to be shown to the user, add them to the page data.
        if (statusMessagesToUser != null && !statusMessagesToUser.isEmpty()) {
            data.setStatusMessagesToUser(statusMessagesToUser);
        }
    }

    /**
     * Clears the list of status message in session variable.
     * @param req HttpServeletRequest object
     */
    private void clearStatusMessageForRequest(HttpServletRequest req) {
        @SuppressWarnings(""unchecked"")
        List<StatusMessage> statusMessagesToUser =
                (List<StatusMessage>) req.getSession().getAttribute(Const.ParamsNames.STATUS_MESSAGES_LIST);

        if (statusMessagesToUser != null) {
            req.getSession().removeAttribute(Const.ParamsNames.STATUS_MESSAGES_LIST);
        }
    }
}
"
AppstatsFilter.java,ui-controller,"package teammates.ui.controller;

import java.io.IOException;

import javax.servlet.FilterChain;
import javax.servlet.ServletException;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;
import javax.servlet.http.HttpServletRequest;

import teammates.common.util.Config;
import teammates.common.util.Const;

/**
 * Custom filter which can exclude Appstats calculation for certain conditions, e.g URL patterns.
 */
public class AppstatsFilter extends com.google.appengine.tools.appstats.AppstatsFilter {

    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
            throws IOException, ServletException {
        if (!(request instanceof HttpServletRequest)) {
            chain.doFilter(request, response);
            return;
        }

        // Actions which write data to Google Cloud Storage need to be excluded from Appstats
        // calculation in the dev server due to a bug in the App Engine GCS client library.
        // The bug occurs for App Engine SDK 1.9.28 and above, highly likely due to the removed Files API.
        // The bug does not occur on production servers.

        String url = ((HttpServletRequest) request).getRequestURI();
        boolean isUrlForActionWritingDataToGcs =
                url.equals(Const.ActionURIs.STUDENT_PROFILE_PICTURE_UPLOAD)
                        || url.equals(Const.ActionURIs.STUDENT_PROFILE_PICTURE_EDIT);
        if (Config.isDevServer() && isUrlForActionWritingDataToGcs) {
            chain.doFilter(request, response);
            return;
        }

        super.doFilter(request, response, chain);
    }

}
"
ControllerServlet.java,ui-controller,"package teammates.ui.controller;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import com.google.appengine.api.datastore.DatastoreTimeoutException;
import com.google.apphosting.api.DeadlineExceededException;

import teammates.common.datatransfer.UserType;
import teammates.common.exception.EntityNotFoundException;
import teammates.common.exception.FeedbackSessionNotVisibleException;
import teammates.common.exception.InvalidOriginException;
import teammates.common.exception.NullPostParameterException;
import teammates.common.exception.PageNotFoundException;
import teammates.common.exception.TeammatesException;
import teammates.common.exception.UnauthorizedAccessException;
import teammates.common.util.Const;
import teammates.common.util.HttpRequestHelper;
import teammates.common.util.LogMessageGenerator;
import teammates.common.util.Logger;
import teammates.common.util.StatusMessage;
import teammates.common.util.StatusMessageColor;
import teammates.common.util.TimeHelper;
import teammates.logic.api.GateKeeper;

/**
 * Receives requests from the Browser, executes the matching action and sends
 * the result back to the Browser. The result can be a page to view or instructions
 * for the Browser to send another request for a different follow up Action.
 */
@SuppressWarnings(""serial"")
public class ControllerServlet extends HttpServlet {

    private static final Logger log = Logger.getLogger();

    @Override
    public void init() throws ServletException {
        TimeHelper.setSystemTimeZoneIfRequired();
    }

    @Override
    public final void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException {
        this.doPost(req, resp);
    }

    @Override
    @SuppressWarnings(""PMD.AvoidCatchingThrowable"") // used as fallback
    public final void doPost(HttpServletRequest req, HttpServletResponse resp) throws IOException {

        UserType userType = new GateKeeper().getCurrentUser();
        String url = HttpRequestHelper.getRequestedUrl(req);
        Map<String, String[]> params = HttpRequestHelper.getParameterMap(req);

        try {
            /* We are using the Template Method Design Pattern here.
             * This method contains the high level logic of the request processing.
             * Concrete details of the processing steps are to be implemented by child
             * classes, based on request-specific needs.
             */
            long startTime = System.currentTimeMillis();

            log.info(""Request received : ["" + req.getMethod() + ""] "" + req.getRequestURL().toString()
                    + "":"" + HttpRequestHelper.printRequestParameters(req));
            log.info(""User agent : "" + req.getHeader(""User-Agent""));

            Action c = new ActionFactory().getAction(req);
            if (c.isValidUser()) {
                ActionResult actionResult = c.executeAndPostProcess();
                actionResult.writeSessionTokenToCookieIfRequired(req, resp);
                actionResult.send(req, resp);
            } else {
                resp.sendRedirect(c.getAuthenticationRedirectUrl());
            }

            long timeTaken = System.currentTimeMillis() - startTime;
            // This is the log message that is used to generate the 'activity log' for the admin.

            log.info(c.getLogMessage() + ""|||"" + timeTaken);

        } catch (PageNotFoundException e) {
            log.warning(new LogMessageGenerator()
                                .generateActionFailureLogMessage(url, params, e, userType));
            cleanUpStatusMessageInSession(req);
            resp.sendRedirect(Const.ViewURIs.ACTION_NOT_FOUND_PAGE);
        } catch (EntityNotFoundException e) {
            log.warning(new LogMessageGenerator()
                                .generateActionFailureLogMessage(url, params, e, userType));
            cleanUpStatusMessageInSession(req);
            resp.sendRedirect(Const.ViewURIs.ENTITY_NOT_FOUND_PAGE);

        } catch (FeedbackSessionNotVisibleException e) {
            log.warning(new LogMessageGenerator()
                                .generateActionFailureLogMessage(url, params, e, userType));
            cleanUpStatusMessageInSession(req);
            req.getSession().setAttribute(Const.ParamsNames.FEEDBACK_SESSION_NOT_VISIBLE, e.getStartTimeString());
            resp.sendRedirect(Const.ViewURIs.FEEDBACK_SESSION_NOT_VISIBLE);

        } catch (InvalidOriginException e) {
            log.warning(new LogMessageGenerator()
                                .generateActionFailureLogMessage(url, params, e, userType));
            cleanUpStatusMessageInSession(req);
            resp.sendRedirect(Const.ViewURIs.INVALID_ORIGIN);

        } catch (UnauthorizedAccessException e) {
            log.warning(new LogMessageGenerator()
                                .generateActionFailureLogMessage(url, params, e, userType));
            cleanUpStatusMessageInSession(req);
            resp.sendRedirect(Const.ViewURIs.UNAUTHORIZED);

        } catch (DeadlineExceededException | DatastoreTimeoutException e) {
            /*This exception may not be caught because GAE kills
              the request soon after throwing it. In that case, the error
              message in the log will be emailed to the admin by a separate
              cron job.*/
            cleanUpStatusMessageInSession(req);
            log.severe(""Deadline exceeded exception caught by ControllerServlet : ""
                    + TeammatesException.toStringWithStackTrace(e));
            resp.sendRedirect(Const.ViewURIs.DEADLINE_EXCEEDED_ERROR_PAGE);

        //TODO: handle invalid parameters exception
        } catch (NullPostParameterException e) {
            String requestUrl = req.getRequestURL().toString();
            log.info(e.getMessage());
            cleanUpStatusMessageInSession(req);

            List<StatusMessage> statusMessagesToUser = new ArrayList<>();
            statusMessagesToUser.add(new StatusMessage(Const.StatusMessages.NULL_POST_PARAMETER_MESSAGE,
                                                       StatusMessageColor.WARNING));
            req.getSession().setAttribute(Const.ParamsNames.STATUS_MESSAGES_LIST, statusMessagesToUser);

            if (requestUrl.contains(""/instructor"")) {
                resp.sendRedirect(Const.ActionURIs.INSTRUCTOR_HOME_PAGE);
            } else if (requestUrl.contains(""/student"")) {
                resp.sendRedirect(Const.ActionURIs.STUDENT_HOME_PAGE);
            } else if (requestUrl.contains(""/admin"")) {
                resp.sendRedirect(Const.ActionURIs.ADMIN_HOME_PAGE);
            } else {
                cleanUpStatusMessageInSession(req);
                resp.sendRedirect(Const.ViewURIs.ERROR_PAGE);
            }
        } catch (Throwable t) {
            /* Log only stack trace to prevent delay in termination of request
             * which can result in GAE shutting down the instance.
             * Note that severe logs are sent by email automatically in the cron job auto/compileLogs.
             */
            log.severe(""Unexpected exception caught by ControllerServlet : ""
                        + TeammatesException.toStringWithStackTrace(t));
            cleanUpStatusMessageInSession(req);
            resp.sendRedirect(Const.ViewURIs.ERROR_PAGE);
        }

    }

    private void cleanUpStatusMessageInSession(HttpServletRequest req) {
        req.getSession().removeAttribute(Const.ParamsNames.STATUS_MESSAGES_LIST);
    }
}
"
CourseStatsPageAction.java,ui-controller,"package teammates.ui.controller;

import teammates.common.exception.EntityDoesNotExistException;
import teammates.common.util.Assumption;
import teammates.common.util.Const;
import teammates.ui.pagedata.CourseStatsPageData;

public class CourseStatsPageAction extends Action {

    @Override
    protected ActionResult execute() throws EntityDoesNotExistException {
        String courseId = getRequestParamValue(Const.ParamsNames.COURSE_ID);
        Assumption.assertPostParamNotNull(Const.ParamsNames.COURSE_ID, courseId);

        CourseStatsPageData data = new CourseStatsPageData(account, sessionToken);

        gateKeeper.verifyInstructorPrivileges(account);

        data.courseDetails = logic.getCourseDetails(courseId);

        return createAjaxResult(data);
    }
}
"
CreateImageUploadUrlAction.java,ui-controller,"package teammates.ui.controller;

import com.google.appengine.api.blobstore.BlobstoreFailureException;

import teammates.common.util.Const;
import teammates.common.util.GoogleCloudStorageHelper;
import teammates.common.util.Url;
import teammates.ui.pagedata.CreateImageUploadUrlAjaxPageData;

/**
 * Action: creates a URL for uploading an image.
 */
public class CreateImageUploadUrlAction extends Action {

    @Override
    protected ActionResult execute() {
        return createAjaxResult(getCreateImageUploadUrlPageData());
    }

    protected final CreateImageUploadUrlAjaxPageData getCreateImageUploadUrlPageData() {
        CreateImageUploadUrlAjaxPageData data = new CreateImageUploadUrlAjaxPageData(account, sessionToken);

        try {
            data.nextUploadUrl = getUploadUrl();
            data.ajaxStatus = ""Image upload url created, proceed to uploading"";
        } catch (BlobstoreFailureException | IllegalArgumentException e) {
            data.nextUploadUrl = null;
            isError = true;
            data.ajaxStatus = ""An error occurred when creating upload URL, please try again"";
        }

        return data;
    }

    protected String getUploadUrl() {
        String callbackUrl =
                Url.addParamToUrl(Const.ActionURIs.IMAGE_UPLOAD, Const.ParamsNames.SESSION_TOKEN, sessionToken);
        return GoogleCloudStorageHelper.getNewUploadUrl(callbackUrl);
    }

}
"
EntityModifiedLogsServlet.java,ui-controller,"package teammates.ui.controller;

import java.io.IOException;
import java.io.PrintWriter;
import java.util.Date;
import java.util.List;

import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import com.google.appengine.api.log.AppLogLine;
import com.google.appengine.api.log.LogQuery;
import com.google.appengine.api.log.LogService;
import com.google.appengine.api.log.LogServiceFactory;
import com.google.appengine.api.log.RequestLogs;

import teammates.common.exception.TeammatesException;
import teammates.common.util.Logger;

@SuppressWarnings(""serial"")
public class EntityModifiedLogsServlet extends HttpServlet {

    private static final Logger log = Logger.getLogger();

    @Override
    public void doGet(HttpServletRequest req, HttpServletResponse resp) {
        doPost(req, resp);
    }

    @Override
    public void doPost(HttpServletRequest req, HttpServletResponse resp) {
        resp.setContentType(""application/json"");
        try {
            PrintWriter writer = resp.getWriter();
            LogService logService = LogServiceFactory.getLogService();

            long endTime = new Date().getTime();
            long queryRange = 1000 * 60 * 60 * 24;
            long startTime = endTime - queryRange;

            LogQuery q = LogQuery.Builder.withDefaults()
                                         .includeAppLogs(true)
                                         .startTimeMillis(startTime)
                                         .endTimeMillis(endTime);
            Iterable<RequestLogs> logs = logService.fetch(q);

            for (RequestLogs requestLogs : logs) {
                List<AppLogLine> logList = requestLogs.getAppLogLines();

                for (int i = 0; i < logList.size(); i++) {
                    AppLogLine currentLog = logList.get(i);
                    String logMessage = currentLog.getLogMessage();
                    if (logMessage.contains(""modified course::"")) {
                        String[] tokens = logMessage.split(""::"");
                        String courseId = tokens[1];
                        writer.println(courseId);
                    }
                }
            }
        } catch (IOException e) {
            log.severe(TeammatesException.toStringWithStackTrace(e));
        }
    }

}
"
FeedbackSessionStatsPageAction.java,ui-controller,"package teammates.ui.controller;

import teammates.common.datatransfer.attributes.FeedbackSessionAttributes;
import teammates.common.datatransfer.attributes.InstructorAttributes;
import teammates.common.exception.EntityDoesNotExistException;
import teammates.common.util.Assumption;
import teammates.common.util.Const;
import teammates.ui.pagedata.FeedbackSessionStatsPageData;

public class FeedbackSessionStatsPageAction extends Action {

    @Override
    protected ActionResult execute() throws EntityDoesNotExistException {
        String courseId = getRequestParamValue(Const.ParamsNames.COURSE_ID);
        Assumption.assertPostParamNotNull(Const.ParamsNames.COURSE_ID, courseId);

        String feedbackSessionName = getRequestParamValue(Const.ParamsNames.FEEDBACK_SESSION_NAME);
        Assumption.assertPostParamNotNull(Const.ParamsNames.FEEDBACK_SESSION_NAME, feedbackSessionName);

        FeedbackSessionStatsPageData data = new FeedbackSessionStatsPageData(account, sessionToken);

        FeedbackSessionAttributes fsa = logic.getFeedbackSession(feedbackSessionName, courseId);

        InstructorAttributes instructor = logic.getInstructorForGoogleId(courseId, account.googleId);

        gateKeeper.verifyAccessible(instructor, fsa, false);

        data.sessionDetails = logic.getFeedbackSessionDetails(feedbackSessionName, courseId);

        return createAjaxResult(data);
    }
}
"
FeedbackSubmissionEditPageAction.java,ui-controller,"package teammates.ui.controller;

import teammates.common.datatransfer.FeedbackSessionQuestionsBundle;
import teammates.common.datatransfer.attributes.FeedbackSessionAttributes;
import teammates.common.exception.EntityDoesNotExistException;
import teammates.common.util.Assumption;
import teammates.common.util.Const;
import teammates.common.util.StatusMessage;
import teammates.common.util.StatusMessageColor;
import teammates.ui.pagedata.FeedbackSubmissionEditPageData;

public abstract class FeedbackSubmissionEditPageAction extends Action {
    protected String courseId;
    protected String feedbackSessionName;
    protected FeedbackSubmissionEditPageData data;

    @Override
    protected ActionResult execute() throws EntityDoesNotExistException {
        courseId = getRequestParamValue(Const.ParamsNames.COURSE_ID);
        feedbackSessionName = getRequestParamValue(Const.ParamsNames.FEEDBACK_SESSION_NAME);
        Assumption.assertPostParamNotNull(Const.ParamsNames.COURSE_ID, courseId);
        Assumption.assertPostParamNotNull(Const.ParamsNames.FEEDBACK_SESSION_NAME, feedbackSessionName);

        if (!isSpecificUserJoinedCourse()) {
            return createPleaseJoinCourseResponse(courseId);
        }

        FeedbackSessionAttributes feedbackSession = logic.getFeedbackSession(feedbackSessionName, courseId);

        if (feedbackSession == null) {
            statusToUser.add(new StatusMessage(Const.StatusMessages.FEEDBACK_SESSION_DELETED_NO_ACCESS,
                                               StatusMessageColor.WARNING));

            return createSpecificRedirectResult();
        }

        verifyAccessibleForSpecificUser(feedbackSession);

        String regKey = getRequestParamValue(Const.ParamsNames.REGKEY);
        String email = getRequestParamValue(Const.ParamsNames.STUDENT_EMAIL);

        String userEmailForCourse = getUserEmailForCourse();
        data = new FeedbackSubmissionEditPageData(account, student, sessionToken);
        data.bundle = getDataBundle(userEmailForCourse);

        data.setSessionOpenForSubmission(isSessionOpenForSpecificUser(data.bundle.feedbackSession));

        setStatusToAdmin();

        if (!data.isSessionOpenForSubmission()) {
            statusToUser.add(new StatusMessage(Const.StatusMessages.FEEDBACK_SUBMISSIONS_NOT_OPEN,
                                               StatusMessageColor.WARNING));
        }

        data.init(regKey, email, courseId);

        return createSpecificShowPageResult();
    }

    protected abstract boolean isSpecificUserJoinedCourse();

    protected abstract void verifyAccessibleForSpecificUser(FeedbackSessionAttributes fsa);

    protected abstract String getUserEmailForCourse();

    protected abstract FeedbackSessionQuestionsBundle getDataBundle(String userEmailForCourse)
            throws EntityDoesNotExistException;

    protected abstract boolean isSessionOpenForSpecificUser(FeedbackSessionAttributes session);

    protected abstract void setStatusToAdmin();

    protected abstract ShowPageResult createSpecificShowPageResult();

    protected abstract RedirectResult createSpecificRedirectResult() throws EntityDoesNotExistException;
}
"
FeedbackSubmissionEditSaveAction.java,ui-controller,"package teammates.ui.controller;

import java.util.ArrayList;
import java.util.Calendar;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TimeZone;

import com.google.appengine.api.datastore.Text;

import teammates.common.datatransfer.FeedbackParticipantType;
import teammates.common.datatransfer.FeedbackSessionQuestionsBundle;
import teammates.common.datatransfer.attributes.FeedbackQuestionAttributes;
import teammates.common.datatransfer.attributes.FeedbackResponseAttributes;
import teammates.common.datatransfer.attributes.FeedbackSessionAttributes;
import teammates.common.datatransfer.attributes.InstructorAttributes;
import teammates.common.datatransfer.attributes.StudentAttributes;
import teammates.common.datatransfer.questions.FeedbackQuestionDetails;
import teammates.common.datatransfer.questions.FeedbackQuestionType;
import teammates.common.datatransfer.questions.FeedbackResponseDetails;
import teammates.common.exception.EmailSendingException;
import teammates.common.exception.EntityAlreadyExistsException;
import teammates.common.exception.EntityDoesNotExistException;
import teammates.common.exception.InvalidParametersException;
import teammates.common.exception.TeammatesException;
import teammates.common.util.Assumption;
import teammates.common.util.Const;
import teammates.common.util.EmailWrapper;
import teammates.common.util.Logger;
import teammates.common.util.SanitizationHelper;
import teammates.common.util.StatusMessage;
import teammates.common.util.StatusMessageColor;
import teammates.logic.api.EmailGenerator;
import teammates.ui.pagedata.FeedbackSubmissionEditPageData;

public abstract class FeedbackSubmissionEditSaveAction extends Action {

    private static final Logger log = Logger.getLogger();

    protected String courseId;
    protected String feedbackSessionName;
    protected FeedbackSubmissionEditPageData data;
    protected boolean hasValidResponse;
    protected boolean isSendSubmissionEmail;
    protected List<FeedbackResponseAttributes> responsesToSave = new ArrayList<>();
    protected List<FeedbackResponseAttributes> responsesToDelete = new ArrayList<>();
    protected List<FeedbackResponseAttributes> responsesToUpdate = new ArrayList<>();

    @Override
    protected ActionResult execute() throws EntityDoesNotExistException {
        courseId = getRequestParamValue(Const.ParamsNames.COURSE_ID);
        feedbackSessionName = getRequestParamValue(Const.ParamsNames.FEEDBACK_SESSION_NAME);
        Assumption.assertPostParamNotNull(Const.ParamsNames.COURSE_ID, courseId);
        Assumption.assertPostParamNotNull(Const.ParamsNames.FEEDBACK_SESSION_NAME, feedbackSessionName);

        setAdditionalParameters();
        verifyAccessibleForSpecificUser();

        String userEmailForCourse = getUserEmailForCourse();

        data = new FeedbackSubmissionEditPageData(account, student, sessionToken);
        data.bundle = getDataBundle(userEmailForCourse);
        Assumption.assertNotNull(""Feedback session "" + feedbackSessionName
                                 + "" does not exist in "" + courseId + ""."", data.bundle);

        checkAdditionalConstraints();

        setStatusToAdmin();

        if (!isSessionOpenForSpecificUser(data.bundle.feedbackSession)) {
            isError = true;
            statusToUser.add(new StatusMessage(Const.StatusMessages.FEEDBACK_SUBMISSIONS_NOT_OPEN,
                                               StatusMessageColor.WARNING));
            return createSpecificRedirectResult();
        }

        String userTeamForCourse = getUserTeamForCourse();
        String userSectionForCourse = getUserSectionForCourse();

        int numOfQuestionsToGet = data.bundle.questionResponseBundle.size();

        for (int questionIndx = 1; questionIndx <= numOfQuestionsToGet; questionIndx++) {
            String totalResponsesForQuestion = getRequestParamValue(
                    Const.ParamsNames.FEEDBACK_QUESTION_RESPONSETOTAL + ""-"" + questionIndx);

            if (totalResponsesForQuestion == null) {
                continue; // question has been skipped (not displayed).
            }

            List<FeedbackResponseAttributes> responsesForQuestion = new ArrayList<>();
            String questionId = getRequestParamValue(
                    Const.ParamsNames.FEEDBACK_QUESTION_ID + ""-"" + questionIndx);
            FeedbackQuestionAttributes questionAttributes = data.bundle.getQuestionAttributes(questionId);
            if (questionAttributes == null) {
                statusToUser.add(new StatusMessage(""The feedback session or questions may have changed ""
                                                       + ""while you were submitting. Please check your responses ""
                                                       + ""to make sure they are saved correctly."",
                                                   StatusMessageColor.WARNING));
                isError = true;
                log.warning(""Question not found. (deleted or invalid id passed?) id: ""
                            + questionId + "" index: "" + questionIndx);
                continue;
            }

            FeedbackQuestionDetails questionDetails = questionAttributes.getQuestionDetails();

            int numOfResponsesToGet = Integer.parseInt(totalResponsesForQuestion);

            Set<String> emailSet = data.bundle.getRecipientEmails(questionAttributes.getId());
            emailSet.add("""");
            emailSet = SanitizationHelper.desanitizeFromHtml(emailSet);

            ArrayList<String> responsesRecipients = new ArrayList<>();
            List<String> errors = new ArrayList<>();

            for (int responseIndx = 0; responseIndx < numOfResponsesToGet; responseIndx++) {
                FeedbackResponseAttributes response =
                        extractFeedbackResponseData(requestParameters, questionIndx, responseIndx, questionAttributes);

                if (response.feedbackQuestionType != questionAttributes.questionType) {
                    errors.add(String.format(Const.StatusMessages.FEEDBACK_RESPONSES_WRONG_QUESTION_TYPE, questionIndx));
                }

                boolean isExistingResponse = response.getId() != null;
                // test that if editing an existing response, that the edited response's id
                // came from the original set of existing responses loaded on the submission page
                if (isExistingResponse && !isExistingResponseValid(response)) {
                    errors.add(String.format(Const.StatusMessages.FEEDBACK_RESPONSES_INVALID_ID, questionIndx));
                    continue;
                }

                responsesRecipients.add(response.recipient);
                // if the answer is not empty but the recipient is empty
                if (response.recipient.isEmpty() && !response.responseMetaData.getValue().isEmpty()) {
                    errors.add(String.format(Const.StatusMessages.FEEDBACK_RESPONSES_MISSING_RECIPIENT, questionIndx));
                }

                if (response.responseMetaData.getValue().isEmpty()) {
                    // deletes the response since answer is empty
                    addToPendingResponses(response);
                } else {
                    response.giver = questionAttributes.giverType.isTeam() ? userTeamForCourse
                                                                                : userEmailForCourse;
                    response.giverSection = userSectionForCourse;
                    responsesForQuestion.add(response);
                }
            }

            List<String> questionSpecificErrors =
                    questionDetails.validateResponseAttributes(responsesForQuestion,
                                                               data.bundle.recipientList.get(questionId).size());
            errors.addAll(questionSpecificErrors);

            if (!emailSet.containsAll(responsesRecipients)) {
                errors.add(String.format(Const.StatusMessages.FEEDBACK_RESPONSE_INVALID_RECIPIENT, questionIndx));
            }

            if (errors.isEmpty()) {
                for (FeedbackResponseAttributes response : responsesForQuestion) {
                    addToPendingResponses(response);
                }
            } else {
                List<StatusMessage> errorMessages = new ArrayList<>();

                for (String error : errors) {
                    errorMessages.add(new StatusMessage(error, StatusMessageColor.DANGER));
                }

                statusToUser.addAll(errorMessages);
                isError = true;
            }
        }

        saveNewReponses(responsesToSave);
        deleteResponses(responsesToDelete);
        updateResponses(responsesToUpdate);

        if (!isError) {
            statusToUser.add(new StatusMessage(Const.StatusMessages.FEEDBACK_RESPONSES_SAVED, StatusMessageColor.SUCCESS));
        }

        if (isUserRespondentOfSession()) {
            appendRespondent();
        } else {
            removeRespondent();
        }

        boolean isSubmissionEmailRequested = ""on"".equals(getRequestParamValue(Const.ParamsNames.SEND_SUBMISSION_EMAIL));
        if (!isError && isSendSubmissionEmail && isSubmissionEmailRequested) {
            FeedbackSessionAttributes session = logic.getFeedbackSession(feedbackSessionName, courseId);
            Assumption.assertNotNull(session);

            String user = account == null ? null : account.googleId;
            String unregisteredStudentEmail = student == null ? null : student.email;
            String unregisteredStudentRegisterationKey = student == null ? null : student.key;
            StudentAttributes student = null;
            InstructorAttributes instructor = null;
            if (user != null) {
                student = logic.getStudentForGoogleId(courseId, user);
                instructor = logic.getInstructorForGoogleId(courseId, user);
            }
            if (student == null && unregisteredStudentEmail != null) {
                student = new StudentAttributes();
                student.email = unregisteredStudentEmail;
                student.name = unregisteredStudentEmail;
                student.key = unregisteredStudentRegisterationKey;
            }
            Assumption.assertFalse(student == null && instructor == null);

            try {
                Calendar timestamp = Calendar.getInstance(TimeZone.getTimeZone(""UTC""));
                EmailWrapper email = instructor == null
                        ? new EmailGenerator().generateFeedbackSubmissionConfirmationEmailForStudent(session,
                                student, timestamp)
                        : new EmailGenerator().generateFeedbackSubmissionConfirmationEmailForInstructor(session,
                                instructor, timestamp);
                emailSender.sendEmail(email);
            } catch (EmailSendingException e) {
                log.severe(""Submission confirmation email failed to send: ""
                           + TeammatesException.toStringWithStackTrace(e));
            }
        }
        return createSpecificRedirectResult();
    }

    /**
     * If the {@code response} is an existing response, check that
     * the questionId and responseId that it has
     * is in {@code data.bundle.questionResponseBundle}.
     * @param response  a response which has non-null id
     */
    private boolean isExistingResponseValid(FeedbackResponseAttributes response) {

        String questionId = response.feedbackQuestionId;
        FeedbackQuestionAttributes question = data.bundle.getQuestionAttributes(questionId);

        if (!data.bundle.questionResponseBundle.containsKey(question)) {
            // question id is invalid
            return false;
        }

        List<FeedbackResponseAttributes> existingResponses = data.bundle.questionResponseBundle.get(question);
        List<String> existingResponsesId = new ArrayList<>();
        for (FeedbackResponseAttributes existingResponse : existingResponses) {
            existingResponsesId.add(existingResponse.getId());
        }

        // checks if response id is valid
        return existingResponsesId.contains(response.getId());
    }

    private void addToPendingResponses(FeedbackResponseAttributes response) {
        boolean isExistingResponse = response.getId() != null;
        if (isExistingResponse) {
            // Delete away response if any empty fields
            if (response.responseMetaData.getValue().isEmpty() || response.recipient.isEmpty()) {
                responsesToDelete.add(response);
                return;
            }
            responsesToUpdate.add(response);
        } else if (!response.responseMetaData.getValue().isEmpty()
                   && !response.recipient.isEmpty()) {
            responsesToSave.add(response);
        }
    }

    private void saveNewReponses(List<FeedbackResponseAttributes> responsesToSave)
            throws EntityDoesNotExistException {
        try {
            logic.createFeedbackResponses(responsesToSave);
            hasValidResponse = true;
        } catch (InvalidParametersException e) {
            setStatusForException(e);
        }
    }

    private void deleteResponses(List<FeedbackResponseAttributes> responsesToDelete) {
        for (FeedbackResponseAttributes response : responsesToDelete) {
            logic.deleteFeedbackResponse(response);
        }
    }

    private void updateResponses(List<FeedbackResponseAttributes> responsesToUpdate)
            throws EntityDoesNotExistException {
        for (FeedbackResponseAttributes response : responsesToUpdate) {
            try {
                logic.updateFeedbackResponse(response);
                hasValidResponse = true;
            } catch (EntityAlreadyExistsException | InvalidParametersException e) {
                setStatusForException(e);
            }
        }
    }

    private FeedbackResponseAttributes extractFeedbackResponseData(
            Map<String, String[]> requestParameters, int questionIndx, int responseIndx,
            FeedbackQuestionAttributes feedbackQuestionAttributes) {

        FeedbackQuestionDetails questionDetails = feedbackQuestionAttributes.getQuestionDetails();
        FeedbackResponseAttributes response = new FeedbackResponseAttributes();

        // This field can be null if the response is new
        response.setId(getRequestParamValue(
                Const.ParamsNames.FEEDBACK_RESPONSE_ID + ""-"" + questionIndx + ""-"" + responseIndx));

        response.feedbackSessionName = getRequestParamValue(Const.ParamsNames.FEEDBACK_SESSION_NAME);
        Assumption.assertPostParamNotNull(Const.ParamsNames.FEEDBACK_SESSION_NAME, response.feedbackSessionName);

        response.courseId = getRequestParamValue(Const.ParamsNames.COURSE_ID);
        Assumption.assertPostParamNotNull(Const.ParamsNames.COURSE_ID, response.courseId);

        response.feedbackQuestionId = getRequestParamValue(
                Const.ParamsNames.FEEDBACK_QUESTION_ID + ""-"" + questionIndx);
        Assumption.assertPostParamNotNull(Const.ParamsNames.FEEDBACK_QUESTION_ID + ""-"" + questionIndx,
                response.feedbackQuestionId);
        Assumption.assertEquals(""feedbackQuestionId Mismatch"", feedbackQuestionAttributes.getId(),
                                response.feedbackQuestionId);

        response.recipient = getRequestParamValue(
                Const.ParamsNames.FEEDBACK_RESPONSE_RECIPIENT + ""-"" + questionIndx + ""-"" + responseIndx);
        Assumption.assertPostParamNotNull(Const.ParamsNames.FEEDBACK_RESPONSE_RECIPIENT + ""-"" + questionIndx + ""-""
                + responseIndx, response.recipient);

        String feedbackQuestionType = getRequestParamValue(
                Const.ParamsNames.FEEDBACK_QUESTION_TYPE + ""-"" + questionIndx);
        Assumption.assertPostParamNotNull(Const.ParamsNames.FEEDBACK_QUESTION_TYPE + ""-"" + questionIndx,
                feedbackQuestionType);
        response.feedbackQuestionType = FeedbackQuestionType.valueOf(feedbackQuestionType);

        FeedbackParticipantType recipientType = feedbackQuestionAttributes.recipientType;
        if (recipientType == FeedbackParticipantType.INSTRUCTORS || recipientType == FeedbackParticipantType.NONE) {
            response.recipientSection = Const.DEFAULT_SECTION;
        } else if (recipientType == FeedbackParticipantType.TEAMS) {
            response.recipientSection = logic.getSectionForTeam(courseId, response.recipient);
        } else if (recipientType == FeedbackParticipantType.STUDENTS) {
            StudentAttributes student = logic.getStudentForEmail(courseId, response.recipient);
            response.recipientSection = student == null ? Const.DEFAULT_SECTION : student.section;
        } else {
            response.recipientSection = getUserSectionForCourse();
        }

        // This field can be null if the question is skipped
        String paramName = Const.ParamsNames.FEEDBACK_RESPONSE_TEXT + ""-"" + questionIndx + ""-"" + responseIndx;
        String[] answer = getRequestParamValues(paramName);

        if (questionDetails.isQuestionSkipped(answer)) {
            response.responseMetaData = new Text("""");
        } else {
            FeedbackResponseDetails responseDetails =
                    FeedbackResponseDetails.createResponseDetails(answer, questionDetails.getQuestionType(),
                                                                  questionDetails, requestParameters,
                                                                  questionIndx, responseIndx);
            response.setResponseDetails(responseDetails);
        }

        return response;
    }

    /**
     * To be used to set any extra parameters or attributes that
     * a class inheriting FeedbackSubmissionEditSaveAction requires.
     */
    protected abstract void setAdditionalParameters() throws EntityDoesNotExistException;

    /**
     * To be used to test any constraints that a class inheriting FeedbackSubmissionEditSaveAction
     * needs. For example, this is used in moderations that check that instructors did not
     * respond to any question that they did not have access to during moderation.
     *
     * <p>Called after FeedbackSubmissionEditPageData data is set, and after setAdditionalParameters
     */
    protected abstract void checkAdditionalConstraints();

    /**
     * Note that when overriding this method, this should not use {@code respondingStudentList}
     * or {@code respondingInstructorList} of {@code FeedbackSessionAttributes}, because this method
     * is used to update {@code respondingStudentList} and {@code respondingInstructorList}.
     *
     * @return true if user has responses in the feedback session
     */
    protected boolean isUserRespondentOfSession() {
        // if there is no valid response on the form submission,
        // we need to use logic to check the database to handle cases where not all questions are displayed
        // e.g. on FeedbackQuestionSubmissionEditSaveAction,
        // or if the submitter can submit both as a student and instructor
        return hasValidResponse
            || logic.hasGiverRespondedForSession(getUserEmailForCourse(), feedbackSessionName, courseId);
    }

    protected abstract void appendRespondent();

    protected abstract void removeRespondent();

    protected abstract void verifyAccessibleForSpecificUser();

    protected abstract String getUserEmailForCourse();

    protected abstract String getUserTeamForCourse();

    protected abstract String getUserSectionForCourse();

    protected abstract FeedbackSessionQuestionsBundle getDataBundle(String userEmailForCourse)
            throws EntityDoesNotExistException;

    protected abstract void setStatusToAdmin();

    protected abstract boolean isSessionOpenForSpecificUser(FeedbackSessionAttributes session);

    protected abstract RedirectResult createSpecificRedirectResult();
}
"
FileDownloadResult.java,ui-controller,"package teammates.ui.controller;

import java.io.IOException;
import java.io.PrintWriter;
import java.util.List;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import teammates.common.datatransfer.attributes.AccountAttributes;
import teammates.common.util.SanitizationHelper;
import teammates.common.util.StatusMessage;
import teammates.common.util.StringHelper;

public class FileDownloadResult extends ActionResult {

    private String fileContent = """";
    private String fileName = """";

    public FileDownloadResult(String destination, AccountAttributes account,
            List<StatusMessage> status) {
        super(destination, account, status);
    }

    public FileDownloadResult(
            String destination, AccountAttributes account,
            List<StatusMessage> status,
            String fileName, String fileContent) {
        super(destination, account, status);
        this.fileName = fileName;
        this.fileContent = fileContent;
    }

    @Override
    public void send(HttpServletRequest req, HttpServletResponse resp) throws IOException {
        /*
         * We have to call setContentType() instead of setHeader() in order
         *     to make the servlet aware of the specified charset encoding
         */
        resp.setContentType(""text/csv; charset=UTF-8"");
        // Content-Disposition is a header on the HTTP response to suggest a filename
        // if the contents of the response is saved to a file.
        resp.setHeader(""Content-Disposition"", getContentDispositionHeader());
        PrintWriter writer = resp.getWriter();
        writer.write(""\uFEFF"");
        writer.append(fileContent);
    }

    /**
     * Suggests a filename for the content of the response to be saved as.
     * @return value of the HTTP Content-Disposition header
     */
    public String getContentDispositionHeader() {
        return ""attachment; filename=\"""" + getAsciiOnlyCsvFileName() + ""\"";""
               + ""filename*= UTF-8''"" + getUrlEscapedCsvFileName();
    }

    private String getAsciiOnlyCsvFileName() {
        return StringHelper.removeNonAscii(fileName) + "".csv"";
    }

    private String getUrlEscapedCsvFileName() {
        return SanitizationHelper.sanitizeForUri(fileName) + "".csv"";
    }

    public String getFileName() {
        return this.fileName;
    }

    public String getFileContent() {
        return this.fileContent;
    }

}
"
ImageResult.java,ui-controller,"package teammates.ui.controller;

import java.io.IOException;
import java.util.List;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import com.google.appengine.api.blobstore.BlobKey;
import com.google.appengine.api.blobstore.BlobstoreService;
import com.google.appengine.api.blobstore.BlobstoreServiceFactory;

import teammates.common.datatransfer.attributes.AccountAttributes;
import teammates.common.util.Const;
import teammates.common.util.StatusMessage;

public class ImageResult extends ActionResult {

    /** The Google Cloud Storage blob key for the image. */
    public String blobKey;

    public ImageResult(String destination, String blobKey, AccountAttributes account,
            List<StatusMessage> status) {
        super(destination, account, status);
        this.blobKey = blobKey;
    }

    @Override
    public void send(HttpServletRequest req, HttpServletResponse resp) throws IOException {

        if (blobKey.isEmpty()) {
            resp.sendRedirect(Const.SystemParams.DEFAULT_PROFILE_PICTURE_PATH);
        } else {
            resp.setContentType(""image/png"");
            BlobstoreService blobstoreService = BlobstoreServiceFactory.getBlobstoreService();
            blobstoreService.serve(new BlobKey(blobKey), resp);
        }
    }

}
"
ImageUploadAction.java,ui-controller,"package teammates.ui.controller;

import java.util.List;
import java.util.Map;

import com.google.appengine.api.blobstore.BlobInfo;
import com.google.appengine.api.blobstore.BlobKey;
import com.google.appengine.api.blobstore.BlobstoreFailureException;
import com.google.appengine.api.blobstore.BlobstoreServiceFactory;

import teammates.common.util.AppUrl;
import teammates.common.util.Config;
import teammates.common.util.Const;
import teammates.common.util.Logger;
import teammates.ui.pagedata.FileUploadPageData;

/**
 * Action: uploads an image to Google Cloud Storage.
 */
public class ImageUploadAction extends Action {

    private static final Logger log = Logger.getLogger();

    private FileUploadPageData data;

    @Override
    protected ActionResult execute() {
        data = prepareData();

        return createAjaxResult(data);
    }

    protected String getImageKeyParam() {
        return Const.ParamsNames.IMAGE_TO_UPLOAD;
    }

    protected FileUploadPageData prepareData() {
        FileUploadPageData data = new FileUploadPageData(account, sessionToken);
        BlobInfo blobInfo = extractImageKey(getImageKeyParam());

        if (blobInfo == null) {
            data.isFileUploaded = false;
            data.fileSrcUrl = null;
            log.warning(""Image Upload Failed"");
            statusToAdmin = ""Image Upload Failed"";

            return data;
        }

        BlobKey blobKey = blobInfo.getBlobKey();

        data.isFileUploaded = true;
        AppUrl fileSrcUrl = Config.getAppUrl(Const.ActionURIs.PUBLIC_IMAGE_SERVE)
                .withParam(Const.ParamsNames.BLOB_KEY, blobKey.getKeyString());
        String absoluteFileSrcUrl = fileSrcUrl.toAbsoluteString();
        data.fileSrcUrl = fileSrcUrl.toString();

        log.info(""New Image Uploaded : "" + absoluteFileSrcUrl);
        statusToAdmin = ""New Image Uploaded : "" + ""<a href="" + data.fileSrcUrl + "" target=\""_blank\"">""
                + absoluteFileSrcUrl + ""</a>"";
        data.ajaxStatus = ""Image Successfully Uploaded to Google Cloud Storage"";

        return data;
    }

    /**
     * Extracts the image metadata by the passed image key parameter.
     */
    protected BlobInfo extractImageKey(String param) {
        try {
            Map<String, List<BlobInfo>> blobsMap = BlobstoreServiceFactory.getBlobstoreService().getBlobInfos(request);
            List<BlobInfo> blobs = blobsMap.get(param);

            if (blobs == null || blobs.isEmpty()) {
                data.ajaxStatus = Const.StatusMessages.NO_IMAGE_GIVEN;
                isError = true;
                return null;
            }

            BlobInfo image = blobs.get(0);
            return validateImage(image);
        } catch (IllegalStateException e) {
            return null;
        }
    }

    /**
     * Validates the image by size and content type.
     */
    protected BlobInfo validateImage(BlobInfo image) {
        if (image.getSize() > Const.SystemParams.MAX_PROFILE_PIC_SIZE) {
            deleteImage(image.getBlobKey());
            isError = true;
            data.ajaxStatus = Const.StatusMessages.IMAGE_TOO_LARGE;
            return null;
        } else if (!image.getContentType().contains(""image/"")) {
            deleteImage(image.getBlobKey());
            isError = true;
            data.ajaxStatus = Const.StatusMessages.FILE_NOT_A_PICTURE;
            return null;
        }

        return image;
    }

    /**
     * Deletes the uploaded image.
     */
    protected void deleteImage(BlobKey blobKey) {
        if (blobKey.equals(new BlobKey(""""))) {
            return;
        }

        try {
            deleteUploadedFile(blobKey);
        } catch (BlobstoreFailureException bfe) {
            statusToAdmin = Const.ACTION_RESULT_FAILURE
                    + "" : Unable to delete picture (possible unused picture with key: ""
                    + blobKey.getKeyString()
                    + "" || Error Message: ""
                    + bfe.getMessage() + Const.EOL;
        }
    }

    /**
     * Deletes the uploaded file from Google Cloud Storage.
     */
    protected void deleteUploadedFile(BlobKey blobKey) {
        logic.deleteUploadedFile(blobKey);
    }
}
"
InstructorCourseAddAction.java,ui-controller,"package teammates.ui.controller;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import teammates.common.datatransfer.attributes.CourseAttributes;
import teammates.common.datatransfer.attributes.InstructorAttributes;
import teammates.common.exception.EntityAlreadyExistsException;
import teammates.common.exception.InvalidParametersException;
import teammates.common.util.Assumption;
import teammates.common.util.Const;
import teammates.common.util.SanitizationHelper;
import teammates.common.util.StatusMessage;
import teammates.common.util.StatusMessageColor;
import teammates.common.util.StringHelper;
import teammates.ui.pagedata.InstructorCoursesPageData;

/**
 * Action: adding a course for an instructor.
 */
public class InstructorCourseAddAction extends Action {
    private InstructorCoursesPageData data;

    @Override
    public ActionResult execute() {
        String newCourseId = getRequestParamValue(Const.ParamsNames.COURSE_ID);
        Assumption.assertPostParamNotNull(Const.ParamsNames.COURSE_ID, newCourseId);
        String newCourseName = getRequestParamValue(Const.ParamsNames.COURSE_NAME);
        Assumption.assertPostParamNotNull(Const.ParamsNames.COURSE_NAME, newCourseName);
        String newCourseTimeZone = getRequestParamValue(Const.ParamsNames.COURSE_TIME_ZONE);
        Assumption.assertPostParamNotNull(Const.ParamsNames.COURSE_TIME_ZONE, newCourseTimeZone);

        /* Check if user has the right to execute the action */
        gateKeeper.verifyInstructorPrivileges(account);

        /* Create a new course in the database */
        data = new InstructorCoursesPageData(account, sessionToken);
        CourseAttributes newCourse = new CourseAttributes(newCourseId, newCourseName, newCourseTimeZone);
        createCourse(newCourse);

        /* Prepare data for the refreshed page after executing the adding action */
        Map<String, InstructorAttributes> instructorsForCourses = new HashMap<>();
        List<CourseAttributes> activeCourses = new ArrayList<>();
        List<CourseAttributes> archivedCourses = new ArrayList<>();

        // Get list of InstructorAttributes that belong to the user.
        List<InstructorAttributes> instructorList = logic.getInstructorsForGoogleId(data.account.googleId);
        for (InstructorAttributes instructor : instructorList) {
            instructorsForCourses.put(instructor.courseId, instructor);
        }

        // Get corresponding courses of the instructors.
        List<CourseAttributes> allCourses = logic.getCoursesForInstructor(instructorList);

        List<String> archivedCourseIds = logic.getArchivedCourseIds(allCourses, instructorsForCourses);
        for (CourseAttributes course : allCourses) {
            if (archivedCourseIds.contains(course.getId())) {
                archivedCourses.add(course);
            } else {
                activeCourses.add(course);
            }
        }

        // Sort CourseDetailsBundle lists by course id
        CourseAttributes.sortById(activeCourses);
        CourseAttributes.sortById(archivedCourses);

        String courseIdToShowParam = """";
        String courseNameToShowParam = """";

        if (isError) { // there is error in adding the course
            courseIdToShowParam = SanitizationHelper.sanitizeForHtml(newCourse.getId());
            courseNameToShowParam = SanitizationHelper.sanitizeForHtml(newCourse.getName());

            List<String> statusMessageTexts = new ArrayList<>();

            for (StatusMessage msg : statusToUser) {
                statusMessageTexts.add(msg.getText());
            }

            statusToAdmin = StringHelper.toString(statusMessageTexts, ""<br>"");
        } else {
            statusToAdmin = ""Course added : "" + newCourse.getId();
            statusToAdmin += ""<br>Total courses: "" + allCourses.size();
        }

        data.init(activeCourses, archivedCourses, instructorsForCourses, courseIdToShowParam, courseNameToShowParam);

        return isError ? createShowPageResult(Const.ViewURIs.INSTRUCTOR_COURSES, data)
                : createRedirectResult(Const.ActionURIs.INSTRUCTOR_COURSES_PAGE);
    }

    private void createCourse(CourseAttributes course) {
        try {
            logic.createCourseAndInstructor(data.account.googleId, course.getId(), course.getName(),
                                            course.getTimeZone());
            String statusMessage = Const.StatusMessages.COURSE_ADDED.replace(""${courseEnrollLink}"",
                    data.getInstructorCourseEnrollLink(course.getId())).replace(""${courseEditLink}"",
                    data.getInstructorCourseEditLink(course.getId()));
            statusToUser.add(new StatusMessage(statusMessage, StatusMessageColor.SUCCESS));
            isError = false;

        } catch (EntityAlreadyExistsException e) {
            setStatusForException(e, Const.StatusMessages.COURSE_EXISTS);
        } catch (InvalidParametersException e) {
            setStatusForException(e);
        }

        if (isError) {
            return;
        }
    }

}
"
InstructorCourseArchiveAction.java,ui-controller,"package teammates.ui.controller;

import teammates.common.util.Assumption;
import teammates.common.util.Const;
import teammates.common.util.StatusMessage;
import teammates.common.util.StatusMessageColor;

public class InstructorCourseArchiveAction extends Action {

    @Override
    protected ActionResult execute() {

        String idOfCourseToArchive = getRequestParamValue(Const.ParamsNames.COURSE_ID);
        Assumption.assertPostParamNotNull(Const.ParamsNames.COURSE_ID, idOfCourseToArchive);
        String archiveStatus = getRequestParamValue(Const.ParamsNames.COURSE_ARCHIVE_STATUS);
        Assumption.assertPostParamNotNull(Const.ParamsNames.COURSE_ARCHIVE_STATUS, archiveStatus);
        boolean isArchive = Boolean.parseBoolean(archiveStatus);

        gateKeeper.verifyAccessible(logic.getInstructorForGoogleId(idOfCourseToArchive, account.googleId),
                                    logic.getCourse(idOfCourseToArchive));

        try {

            // Set the archive status and status shown to user and admin
            logic.setArchiveStatusOfInstructor(account.googleId, idOfCourseToArchive, isArchive);
            if (isArchive) {
                if (isRedirectedToHomePage()) {
                    statusToUser.add(new StatusMessage(String.format(Const.StatusMessages.COURSE_ARCHIVED_FROM_HOMEPAGE,
                                                                       idOfCourseToArchive), StatusMessageColor.SUCCESS));
                } else {
                    statusToUser.add(new StatusMessage(String.format(Const.StatusMessages.COURSE_ARCHIVED,
                                                                       idOfCourseToArchive), StatusMessageColor.SUCCESS));
                }
                statusToAdmin = ""Course archived: "" + idOfCourseToArchive;
            } else {
                statusToUser.add(new StatusMessage(String.format(Const.StatusMessages.COURSE_UNARCHIVED,
                                                                       idOfCourseToArchive), StatusMessageColor.SUCCESS));
                statusToAdmin = ""Course unarchived: "" + idOfCourseToArchive;
            }
        } catch (Exception e) {
            setStatusForException(e);
        }

        if (isRedirectedToHomePage()) {
            return createRedirectResult(Const.ActionURIs.INSTRUCTOR_HOME_PAGE);
        }
        return createRedirectResult(Const.ActionURIs.INSTRUCTOR_COURSES_PAGE);
    }

    /**
     * Checks if the action is executed in homepage or 'Courses' pages based on its redirection.
     */
    private boolean isRedirectedToHomePage() {
        String nextUrl = getRequestParamValue(Const.ParamsNames.NEXT_URL);
        return nextUrl != null && nextUrl.equals(Const.ActionURIs.INSTRUCTOR_HOME_PAGE);
    }
}
"
InstructorCourseDeleteAction.java,ui-controller,"package teammates.ui.controller;

import teammates.common.util.Assumption;
import teammates.common.util.Const;
import teammates.common.util.StatusMessage;
import teammates.common.util.StatusMessageColor;

/**
 * Action: Delete a course for an instructor.
 */
public class InstructorCourseDeleteAction extends Action {

    @Override
    public ActionResult execute() {

        String idOfCourseToDelete = getRequestParamValue(Const.ParamsNames.COURSE_ID);
        Assumption.assertPostParamNotNull(Const.ParamsNames.COURSE_ID, idOfCourseToDelete);

        gateKeeper.verifyAccessible(logic.getInstructorForGoogleId(idOfCourseToDelete, account.googleId),
                                    logic.getCourse(idOfCourseToDelete),
                                    Const.ParamsNames.INSTRUCTOR_PERMISSION_MODIFY_COURSE);

        /* Delete the course and setup status to be shown to user and admin */
        logic.deleteCourse(idOfCourseToDelete);
        String statusMessage = String.format(Const.StatusMessages.COURSE_DELETED, idOfCourseToDelete);
        statusToUser.add(new StatusMessage(statusMessage, StatusMessageColor.SUCCESS));
        statusToAdmin = ""Course deleted: "" + idOfCourseToDelete;

        if (isRedirectedToHomePage()) {
            return createRedirectResult(Const.ActionURIs.INSTRUCTOR_HOME_PAGE);
        }
        return createRedirectResult(Const.ActionURIs.INSTRUCTOR_COURSES_PAGE);
    }

    /**
     * Checks if the action is executed in homepage or 'Courses' pages based on its redirection.
     */
    private boolean isRedirectedToHomePage() {
        String nextUrl = getRequestParamValue(Const.ParamsNames.NEXT_URL);
        return nextUrl != null && nextUrl.equals(Const.ActionURIs.INSTRUCTOR_HOME_PAGE);
    }
}
"
InstructorCourseDetailsPageAction.java,ui-controller,"package teammates.ui.controller;

import java.util.List;

import teammates.common.datatransfer.CourseDetailsBundle;
import teammates.common.datatransfer.attributes.InstructorAttributes;
import teammates.common.exception.EntityDoesNotExistException;
import teammates.common.util.Assumption;
import teammates.common.util.Const;
import teammates.common.util.StatusMessage;
import teammates.common.util.StatusMessageColor;
import teammates.common.util.StringHelper;
import teammates.ui.pagedata.InstructorCourseDetailsPageData;

/**
 * Action: showing the details page for a course of an instructor.
 */
public class InstructorCourseDetailsPageAction extends Action {

    @Override
    public ActionResult execute() throws EntityDoesNotExistException {

        String courseId = getRequestParamValue(Const.ParamsNames.COURSE_ID);

        //this is for ajax loading of the htm table in the modal
        boolean isHtmlTableNeeded = getRequestParamAsBoolean(Const.ParamsNames.CSV_TO_HTML_TABLE_NEEDED);

        Assumption.assertPostParamNotNull(Const.ParamsNames.COURSE_ID, courseId);

        InstructorAttributes instructor = logic.getInstructorForGoogleId(courseId, account.googleId);
        gateKeeper.verifyAccessible(instructor, logic.getCourse(courseId));

        /* Setup page data for the ""Course Details"" page */
        InstructorCourseDetailsPageData data = new InstructorCourseDetailsPageData(account, sessionToken);

        if (isHtmlTableNeeded) {
            String courseStudentListAsCsv = logic.getCourseStudentListAsCsv(courseId, account.googleId);
            data.setStudentListHtmlTableAsString(StringHelper.csvToHtmlTable(courseStudentListAsCsv));

            statusToAdmin = ""instructorCourseDetails Page Ajax Html table Load<br>""
                            + ""Viewing Student List Table for Course <span class=\""bold\"">["" + courseId + ""]</span>"";

            return createAjaxResult(data);
        }

        CourseDetailsBundle courseDetails = logic.getCourseDetails(courseId);
        List<InstructorAttributes> instructors = logic.getInstructorsForCourse(courseId);

        data.init(instructor, courseDetails, instructors);

        if (courseDetails.getStats().getStudentsTotal() == 0) {
            String message = String.format(Const.StatusMessages.INSTRUCTOR_COURSE_EMPTY,
                                           data.getInstructorCourseEnrollLink(courseId));
            statusToUser.add(new StatusMessage(message, StatusMessageColor.WARNING));
        }

        statusToAdmin = ""instructorCourseDetails Page Load<br>""
                        + ""Viewing Course Details for Course <span class=\""bold\"">["" + courseId + ""]</span>"";

        return createShowPageResult(Const.ViewURIs.INSTRUCTOR_COURSE_DETAILS, data);
    }
}
"
InstructorCourseEditPageAction.java,ui-controller,"package teammates.ui.controller;

import java.util.ArrayList;
import java.util.List;

import teammates.common.datatransfer.attributes.CourseAttributes;
import teammates.common.datatransfer.attributes.FeedbackSessionAttributes;
import teammates.common.datatransfer.attributes.InstructorAttributes;
import teammates.common.exception.EntityDoesNotExistException;
import teammates.common.util.Assumption;
import teammates.common.util.Const;
import teammates.ui.pagedata.InstructorCourseEditPageData;

/**
 * Action: showing the 'Edit' page for a course of an instructor.
 */
public class InstructorCourseEditPageAction extends Action {

    //TODO: display privileges in the database properly
    @Override
    public ActionResult execute() throws EntityDoesNotExistException {

        String courseId = getRequestParamValue(Const.ParamsNames.COURSE_ID);
        Assumption.assertPostParamNotNull(Const.ParamsNames.COURSE_ID, courseId);
        String instructorEmail = getRequestParamValue(Const.ParamsNames.INSTRUCTOR_EMAIL);
        String index = getRequestParamValue(Const.ParamsNames.COURSE_EDIT_MAIN_INDEX);

        InstructorAttributes instructor = logic.getInstructorForGoogleId(courseId, account.googleId);
        CourseAttributes courseToEdit = logic.getCourse(courseId);

        gateKeeper.verifyAccessible(instructor, courseToEdit);

        /* Setup page data for 'Edit' page of a course for an instructor */
        List<InstructorAttributes> instructorList = new ArrayList<>();

        int instructorToShowIndex = -1; // -1 means showing all instructors

        if (instructorEmail == null) {
            instructorList = logic.getInstructorsForCourse(courseId);
        } else {
            instructorList.add(logic.getInstructorForEmail(courseId, instructorEmail));
            instructorToShowIndex = Integer.parseInt(index);
        }

        List<String> sectionNames = logic.getSectionNamesForCourse(courseId);
        List<String> feedbackNames = new ArrayList<>();

        List<FeedbackSessionAttributes> feedbacks = logic.getFeedbackSessionsForCourse(courseId);
        for (FeedbackSessionAttributes feedback : feedbacks) {
            feedbackNames.add(feedback.getFeedbackSessionName());
        }

        InstructorCourseEditPageData data = new InstructorCourseEditPageData(account, sessionToken, courseToEdit,
                                                                             instructorList, instructor,
                                                                             instructorToShowIndex,
                                                                             sectionNames, feedbackNames);

        statusToAdmin = ""instructorCourseEdit Page Load<br>""
                        + ""Editing information for Course <span class=\""bold\"">["" + courseId + ""]</span>"";

        return createShowPageResult(Const.ViewURIs.INSTRUCTOR_COURSE_EDIT, data);
    }
}
"
InstructorCourseEditSaveAction.java,ui-controller,"package teammates.ui.controller;

import teammates.common.datatransfer.attributes.CourseAttributes;
import teammates.common.datatransfer.attributes.InstructorAttributes;
import teammates.common.exception.EntityDoesNotExistException;
import teammates.common.exception.InvalidParametersException;
import teammates.common.util.Assumption;
import teammates.common.util.Const;
import teammates.common.util.StatusMessage;
import teammates.common.util.StatusMessageColor;

public class InstructorCourseEditSaveAction extends Action {
    @Override
    protected ActionResult execute() throws EntityDoesNotExistException {
        String courseId = getRequestParamValue(Const.ParamsNames.COURSE_ID);
        Assumption.assertPostParamNotNull(Const.ParamsNames.COURSE_ID, courseId);

        String courseName = getRequestParamValue(Const.ParamsNames.COURSE_NAME);
        Assumption.assertPostParamNotNull(Const.ParamsNames.COURSE_NAME, courseName);

        String courseTimeZone = getRequestParamValue(Const.ParamsNames.COURSE_TIME_ZONE);
        Assumption.assertPostParamNotNull(Const.ParamsNames.COURSE_TIME_ZONE, courseTimeZone);

        InstructorAttributes instructor = logic.getInstructorForGoogleId(courseId, account.googleId);
        gateKeeper.verifyAccessible(instructor, logic.getCourse(courseId),
                                    Const.ParamsNames.INSTRUCTOR_PERMISSION_MODIFY_COURSE);

        CourseAttributes courseToEdit = new CourseAttributes(courseId, courseName, courseTimeZone);

        try {
            logic.updateCourse(courseToEdit);

            statusToUser.add(new StatusMessage(Const.StatusMessages.COURSE_EDITED, StatusMessageColor.SUCCESS));
            statusToAdmin = ""Course name for Course <span class=\""bold\"">["" + courseId + ""]</span> edited.<br>""
                          + ""New name: "" + courseName;
        } catch (InvalidParametersException e) {
            setStatusForException(e);
        }

        RedirectResult result = createRedirectResult(Const.ActionURIs.INSTRUCTOR_COURSE_EDIT_PAGE);
        result.addResponseParam(Const.ParamsNames.COURSE_ID, courseId);
        return result;
    }
}
"
InstructorCourseEnrollPageAction.java,ui-controller,"package teammates.ui.controller;

import teammates.common.datatransfer.attributes.InstructorAttributes;
import teammates.common.util.Assumption;
import teammates.common.util.Const;
import teammates.common.util.StatusMessage;
import teammates.common.util.StatusMessageColor;
import teammates.ui.pagedata.InstructorCourseEnrollPageData;

/**
 * Action: showing page to enroll students into a course for an instructor.
 */
public class InstructorCourseEnrollPageAction extends Action {

    @Override
    public ActionResult execute() {
        String courseId = getRequestParamValue(Const.ParamsNames.COURSE_ID);
        String studentsInfo = getRequestParamValue(Const.ParamsNames.STUDENTS_ENROLLMENT_INFO);

        Assumption.assertPostParamNotNull(Const.ParamsNames.COURSE_ID, courseId);

        InstructorAttributes instructor = logic.getInstructorForGoogleId(courseId, account.googleId);
        gateKeeper.verifyAccessible(
                instructor, logic.getCourse(courseId), Const.ParamsNames.INSTRUCTOR_PERMISSION_MODIFY_STUDENT);

        /* Setup page data for 'Enroll' page of a course */
        InstructorCourseEnrollPageData pageData =
                new InstructorCourseEnrollPageData(account, sessionToken, courseId, studentsInfo);

        statusToAdmin = String.format(Const.StatusMessages.ADMIN_LOG_INSTRUCTOR_COURSE_ENROLL_PAGE_LOAD,
                                      courseId);
        addDataLossWarningToStatusToUser(courseId);

        return createShowPageResult(Const.ViewURIs.INSTRUCTOR_COURSE_ENROLL, pageData);
    }

    private void addDataLossWarningToStatusToUser(String courseId) {
        if (hasExistingResponses(courseId)) {
            statusToUser.add(new StatusMessage(Const.StatusMessages.COURSE_ENROLL_POSSIBLE_DATA_LOSS,
                                               StatusMessageColor.WARNING));
        }
    }

    private boolean hasExistingResponses(String courseId) {
        return logic.hasResponsesForCourse(courseId);
    }

}
"
InstructorCourseEnrollSaveAction.java,ui-controller,"package teammates.ui.controller;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;

import teammates.common.datatransfer.CourseEnrollmentResult;
import teammates.common.datatransfer.StudentUpdateStatus;
import teammates.common.datatransfer.attributes.FeedbackSessionAttributes;
import teammates.common.datatransfer.attributes.InstructorAttributes;
import teammates.common.datatransfer.attributes.StudentAttributes;
import teammates.common.exception.EnrollException;
import teammates.common.exception.EntityAlreadyExistsException;
import teammates.common.exception.EntityDoesNotExistException;
import teammates.common.exception.InvalidParametersException;
import teammates.common.util.Assumption;
import teammates.common.util.Const;
import teammates.common.util.Logger;
import teammates.common.util.SanitizationHelper;
import teammates.common.util.StatusMessage;
import teammates.common.util.StatusMessageColor;
import teammates.ui.pagedata.InstructorCourseEnrollPageData;
import teammates.ui.pagedata.InstructorCourseEnrollResultPageData;

/**
 * Action: saving the list of enrolled students for a course of an instructor.
 */
public class InstructorCourseEnrollSaveAction extends Action {

    private static final Logger log = Logger.getLogger();

    @Override
    public ActionResult execute() throws EntityDoesNotExistException {

        String courseId = getRequestParamValue(Const.ParamsNames.COURSE_ID);
        Assumption.assertPostParamNotNull(Const.ParamsNames.COURSE_ID, courseId);
        String studentsInfo = getRequestParamValue(Const.ParamsNames.STUDENTS_ENROLLMENT_INFO);
        String sanitizedStudentsInfo = SanitizationHelper.sanitizeForHtml(studentsInfo);
        Assumption.assertPostParamNotNull(Const.ParamsNames.STUDENTS_ENROLLMENT_INFO, studentsInfo);

        InstructorAttributes instructor = logic.getInstructorForGoogleId(courseId, account.googleId);
        gateKeeper.verifyAccessible(instructor, logic.getCourse(courseId),
                                    Const.ParamsNames.INSTRUCTOR_PERMISSION_MODIFY_STUDENT);

        /* Process enrollment list and setup data for page result */
        try {
            List<StudentAttributes>[] students = enrollAndProcessResultForDisplay(studentsInfo, courseId);
            boolean hasSection = hasSections(students);

            InstructorCourseEnrollResultPageData pageData = new InstructorCourseEnrollResultPageData(account, sessionToken,
                                                                    courseId, students, hasSection, studentsInfo);

            statusToAdmin = ""Students Enrolled in Course <span class=\""bold\"">[""
                            + courseId + ""]:</span><br>"" + sanitizedStudentsInfo.replace(""\n"", ""<br>"");

            return createShowPageResult(Const.ViewURIs.INSTRUCTOR_COURSE_ENROLL_RESULT, pageData);

        } catch (EnrollException | InvalidParametersException e) {
            setStatusForException(e);

            statusToAdmin += ""<br>Enrollment string entered by user:<br>"" + sanitizedStudentsInfo.replace(""\n"", ""<br>"");

            InstructorCourseEnrollPageData pageData =
                    new InstructorCourseEnrollPageData(account, sessionToken, courseId, studentsInfo);

            return createShowPageResult(Const.ViewURIs.INSTRUCTOR_COURSE_ENROLL, pageData);
        } catch (EntityAlreadyExistsException e) {
            setStatusForException(e);

            statusToUser.add(
                    new StatusMessage(""The enrollment failed, possibly because some students were re-enrolled before ""
                                      + ""the previous enrollment action was still being processed by TEAMMATES database ""
                                      + ""servers. Please try again after about 10 minutes. If the problem persists, ""
                                      + ""please contact TEAMMATES support"", StatusMessageColor.DANGER));

            InstructorCourseEnrollPageData pageData =
                    new InstructorCourseEnrollPageData(account, sessionToken, courseId, studentsInfo);

            log.severe(""Entity already exists exception occurred when updating student: "" + e.getMessage());
            return createShowPageResult(Const.ViewURIs.INSTRUCTOR_COURSE_ENROLL, pageData);
        }
    }

    private boolean hasSections(List<StudentAttributes>[] students) {
        for (List<StudentAttributes> studentList : students) {
            for (StudentAttributes student : studentList) {
                if (!student.section.equals(Const.DEFAULT_SECTION)) {
                    return true;
                }
            }
        }
        return false;
    }

    private List<StudentAttributes>[] enrollAndProcessResultForDisplay(String studentsInfo, String courseId)
            throws EnrollException, EntityDoesNotExistException, InvalidParametersException, EntityAlreadyExistsException {
        CourseEnrollmentResult enrollResult = logic.enrollStudents(studentsInfo, courseId);
        List<StudentAttributes> students = enrollResult.studentList;

        // Adjust submissions for all feedback responses within the course
        List<FeedbackSessionAttributes> feedbackSessions = logic.getFeedbackSessionsForCourse(courseId);
        for (FeedbackSessionAttributes session : feedbackSessions) {
            // Schedule adjustment of submissions for feedback session in course
            taskQueuer.scheduleFeedbackResponseAdjustmentForCourse(
                    courseId, session.getFeedbackSessionName(), enrollResult.enrollmentList);
        }

        Collections.sort(students, new Comparator<StudentAttributes>() {
            @Override
            public int compare(StudentAttributes o1, StudentAttributes o2) {
                return o1.updateStatus.numericRepresentation - o2.updateStatus.numericRepresentation;
            }
        });

        return separateStudents(students);
    }

    /**
     * Separate the StudentData objects in the list into different categories based
     * on their updateStatus. Each category is put into a separate list.<br>
     *
     * @return An array of lists of StudentData objects in which each list contains
     *         student with the same updateStatus
     */
    @SuppressWarnings(""unchecked"")
    private List<StudentAttributes>[] separateStudents(List<StudentAttributes> students) {

        ArrayList<StudentAttributes>[] lists = new ArrayList[StudentUpdateStatus.STATUS_COUNT];
        for (int i = 0; i < StudentUpdateStatus.STATUS_COUNT; i++) {
            lists[i] = new ArrayList<>();
        }

        for (StudentAttributes student : students) {
            lists[student.updateStatus.numericRepresentation].add(student);
        }

        for (int i = 0; i < StudentUpdateStatus.STATUS_COUNT; i++) {
            StudentAttributes.sortByNameAndThenByEmail(lists[i]);
        }

        return lists;
    }

}
"
InstructorCourseInstructorAbstractAction.java,ui-controller,"package teammates.ui.controller;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;

import teammates.common.datatransfer.attributes.FeedbackSessionAttributes;
import teammates.common.datatransfer.attributes.InstructorAttributes;
import teammates.common.exception.EntityDoesNotExistException;
import teammates.common.util.Const;

public abstract class InstructorCourseInstructorAbstractAction extends Action {

    /**
     * Updates section and session level privileges for the instructor.
     *
     * @param courseId   Course that the instructor is being added to.
     * @param instructor Instructor that will be added.
     *                       This will be modified within the method.
     */
    protected void updateInstructorWithSectionLevelPrivileges(String courseId, InstructorAttributes instructor) {
        List<String> sectionNames = null;
        try {
            sectionNames = logic.getSectionNamesForCourse(courseId);
        } catch (EntityDoesNotExistException e) {
            return;
        }
        HashMap<String, Boolean> isSectionSpecialMappings = new HashMap<>();
        for (String sectionName : sectionNames) {
            isSectionSpecialMappings.put(sectionName, false);
        }

        List<String> feedbackNames = new ArrayList<>();

        List<FeedbackSessionAttributes> feedbacks = logic.getFeedbackSessionsForCourse(courseId);
        for (FeedbackSessionAttributes feedback : feedbacks) {
            feedbackNames.add(feedback.getFeedbackSessionName());
        }
        Map<String, List<String>> sectionNamesMap = getSectionsWithSpecialPrivilegesFromParameters(
                                                                instructor, sectionNames,
                                                                isSectionSpecialMappings);
        for (Entry<String, List<String>> entry : sectionNamesMap.entrySet()) {
            String sectionGroupName = entry.getKey();
            List<String> specialSectionsInSectionGroup = entry.getValue();

            updateInstructorPrivilegesForSectionInSectionLevel(sectionGroupName,
                    specialSectionsInSectionGroup, instructor);

            //check if session-specific permissions are to be used
            String setSessionsStr = getRequestParamValue(""is"" + sectionGroupName + ""sessionsset"");
            boolean isSessionsForSectionGroupSpecial = Boolean.parseBoolean(setSessionsStr);
            if (isSessionsForSectionGroupSpecial) {
                updateInstructorPrivilegesForSectionInSessionLevel(sectionGroupName,
                        specialSectionsInSectionGroup, feedbackNames, instructor);
            } else {
                removeSessionLevelPrivileges(instructor, specialSectionsInSectionGroup);
            }
        }
        for (Entry<String, Boolean> entry : isSectionSpecialMappings.entrySet()) {
            String sectionNameToBeChecked = entry.getKey();
            boolean isSectionSpecial = entry.getValue().booleanValue();
            if (!isSectionSpecial) {
                instructor.privileges.removeSectionLevelPrivileges(sectionNameToBeChecked);
            }
        }
    }

    /**
     * Updates course level privileges for the instructor by retrieving request parameters.
     *
     * @param instructor Instructor that will be edited.
     *                       This will be modified within the method.
     */
    protected void updateInstructorCourseLevelPrivileges(InstructorAttributes instructor) {
        boolean isModifyCourseChecked =
                getRequestParamValue(Const.ParamsNames.INSTRUCTOR_PERMISSION_MODIFY_COURSE) != null;
        boolean isModifyInstructorChecked =
                getRequestParamValue(Const.ParamsNames.INSTRUCTOR_PERMISSION_MODIFY_INSTRUCTOR) != null;
        boolean isModifySessionChecked =
                getRequestParamValue(Const.ParamsNames.INSTRUCTOR_PERMISSION_MODIFY_SESSION) != null;
        boolean isModifyStudentChecked =
                getRequestParamValue(Const.ParamsNames.INSTRUCTOR_PERMISSION_MODIFY_STUDENT) != null;

        boolean isViewStudentInSectionsChecked =
                getRequestParamValue(Const.ParamsNames.INSTRUCTOR_PERMISSION_VIEW_STUDENT_IN_SECTIONS) != null;

        boolean isViewSessionInSectionsChecked =
                getRequestParamValue(Const.ParamsNames.INSTRUCTOR_PERMISSION_VIEW_SESSION_IN_SECTIONS) != null;
        boolean isSubmitSessionInSectionsChecked =
                getRequestParamValue(Const.ParamsNames.INSTRUCTOR_PERMISSION_SUBMIT_SESSION_IN_SECTIONS) != null;
        boolean isModifySessionInSectionsChecked =
                getRequestParamValue(Const.ParamsNames.INSTRUCTOR_PERMISSION_MODIFY_SESSION_COMMENT_IN_SECTIONS) != null;

        instructor.privileges.updatePrivilege(Const.ParamsNames.INSTRUCTOR_PERMISSION_MODIFY_COURSE,
                                              isModifyCourseChecked);
        instructor.privileges.updatePrivilege(Const.ParamsNames.INSTRUCTOR_PERMISSION_MODIFY_INSTRUCTOR,
                                              isModifyInstructorChecked);
        instructor.privileges.updatePrivilege(Const.ParamsNames.INSTRUCTOR_PERMISSION_MODIFY_SESSION,
                                              isModifySessionChecked);
        instructor.privileges.updatePrivilege(Const.ParamsNames.INSTRUCTOR_PERMISSION_MODIFY_STUDENT,
                                              isModifyStudentChecked);

        instructor.privileges.updatePrivilege(Const.ParamsNames.INSTRUCTOR_PERMISSION_VIEW_STUDENT_IN_SECTIONS,
                                              isViewStudentInSectionsChecked);

        instructor.privileges.updatePrivilege(Const.ParamsNames.INSTRUCTOR_PERMISSION_VIEW_SESSION_IN_SECTIONS,
                                              isViewSessionInSectionsChecked);
        instructor.privileges.updatePrivilege(Const.ParamsNames.INSTRUCTOR_PERMISSION_SUBMIT_SESSION_IN_SECTIONS,
                                              isSubmitSessionInSectionsChecked);
        instructor.privileges.updatePrivilege(Const.ParamsNames.INSTRUCTOR_PERMISSION_MODIFY_SESSION_COMMENT_IN_SECTIONS,
                                              isModifySessionInSectionsChecked);
    }

    /**
     * Removes session level privileges for the instructor under the given sections.
     *
     * @param instructor   Instructor that will be added.
     *                         This will be modified within the method.
     * @param sectionNames List of section names to be removed.
     */
    protected void removeSessionLevelPrivileges(InstructorAttributes instructor, List<String> sectionNames) {
        for (String sectionName : sectionNames) {
            instructor.privileges.removeSessionsPrivilegesForSection(sectionName);
        }
    }

    /**
     * Gets the sections that are special for the instructor to be added.
     *
     * @param instructor          Instructor that will be added.
     * @param sectionNames             List of section names in the course.
     * @param isSectionSpecialMappings Mapping of names of sections to boolean values indicating if they are special.
     *                                     This will be modified within the method.
     * @return List of section group names with their associated special sections.
     */
    protected Map<String, List<String>> getSectionsWithSpecialPrivilegesFromParameters(
            InstructorAttributes instructor, List<String> sectionNames,
            Map<String, Boolean> isSectionSpecialMappings) {
        HashMap<String, List<String>> specialSectionsInSectionGroups = new HashMap<>();
        if (instructor.role.equals(Const.InstructorPermissionRoleNames.INSTRUCTOR_PERMISSION_ROLE_CUSTOM)) {
            getSectionsWithSpecialPrivilegesForCustomInstructor(sectionNames, isSectionSpecialMappings,
                                                                specialSectionsInSectionGroups);
        }
        return specialSectionsInSectionGroups;
    }

    /**
     * Gets the sections that are special for the custom instructor to be added.
     * Prereq: the added instructor must be given a custom role.
     *
     * @param sectionNames                   List of section names in the course.
     * @param isSectionSpecialMappings       Mapping of names of sections to boolean values indicating if they are special.
     *                                           This will be modified within the method.
     * @param specialSectionsInSectionGroups Mapping of section group names to the special sections that they contain.
     *                                           This will be modified within the method.
     */
    protected void getSectionsWithSpecialPrivilegesForCustomInstructor(List<String> sectionNames,
            Map<String, Boolean> isSectionSpecialMappings,
            Map<String, List<String>> specialSectionsInSectionGroups) {
        for (int i = 0; i < sectionNames.size(); i++) {
            String sectionGroupIsSetStr =
                    getRequestParamValue(""is"" + Const.ParamsNames.INSTRUCTOR_SECTION_GROUP + i + ""set"");
            boolean isSectionGroupSpecial = Boolean.parseBoolean(sectionGroupIsSetStr);

            for (int j = 0; j < sectionNames.size(); j++) {
                String sectionNameFromParam = getRequestParamValue(
                                                     Const.ParamsNames.INSTRUCTOR_SECTION_GROUP + i
                                                     + Const.ParamsNames.INSTRUCTOR_SECTION + j);
                boolean isSectionParamValid = sectionNameFromParam != null
                                              && isSectionSpecialMappings.containsKey(sectionNameFromParam);
                if (isSectionGroupSpecial && isSectionParamValid) {
                    markSectionAsSpecial(isSectionSpecialMappings, specialSectionsInSectionGroups,
                                         i, sectionNameFromParam);
                }
            }
        }
    }

    /**
     * Marks {@code sectionToMark} as special in the associated mappings.
     *
     * @param isSectionSpecialMappings       Mapping of names of sections to boolean values indicating if they are special.
     *                                           This will be modified within the method.
     * @param specialSectionsInSectionGroups Mapping of section group names to the special sections that they contain.
     *                                           This will be modified within the method.
     * @param sectionGroupIndex              Index of the section group to be updated.
     * @param sectionToMark                  Section that will be marked as special.
     */
    protected void markSectionAsSpecial(Map<String, Boolean> isSectionSpecialMappings,
            Map<String, List<String>> specialSectionsInSectionGroups, int sectionGroupIndex,
            String sectionToMark) {
        // indicate that section group covers the section
        // and mark that this section is special
        String sectionGroupParamName = Const.ParamsNames.INSTRUCTOR_SECTION_GROUP + sectionGroupIndex;
        if (specialSectionsInSectionGroups.get(sectionGroupParamName) == null) {
            specialSectionsInSectionGroups.put(sectionGroupParamName, new ArrayList<String>());
        }
        specialSectionsInSectionGroups.get(sectionGroupParamName).add(sectionToMark);
        isSectionSpecialMappings.put(sectionToMark, true);
    }

    /**
     * Updates instructor privileges at section level by retrieving request parameters.
     * The parameters that are retrieved are based off {@code sectionGroupName}.
     *
     * @param sectionGroupName              Name of the section group.
     * @param specialSectionsInSectionGroup Sections marked as special under the section group.
     * @param instructor                    Instructor that will be edited.
     *                                          This will be modified within the method.
     */
    protected void updateInstructorPrivilegesForSectionInSectionLevel(String sectionGroupName,
            List<String> specialSectionsInSectionGroup, InstructorAttributes instructor) {
        boolean isViewStudentInSectionsChecked =
                getRequestParamValue(Const.ParamsNames.INSTRUCTOR_PERMISSION_VIEW_STUDENT_IN_SECTIONS
                                     + sectionGroupName) != null;

        boolean isViewSessionInSectionsChecked =
                getRequestParamValue(Const.ParamsNames.INSTRUCTOR_PERMISSION_VIEW_SESSION_IN_SECTIONS
                                     + sectionGroupName) != null;
        boolean isSubmitSessionInSectionsChecked =
                getRequestParamValue(Const.ParamsNames.INSTRUCTOR_PERMISSION_SUBMIT_SESSION_IN_SECTIONS
                                     + sectionGroupName) != null;
        boolean isModifySessionInSectionsChecked =
                getRequestParamValue(Const.ParamsNames.INSTRUCTOR_PERMISSION_MODIFY_SESSION_COMMENT_IN_SECTIONS
                                     + sectionGroupName) != null;

        for (String sectionName : specialSectionsInSectionGroup) {
            instructor.privileges.updatePrivilege(
                    sectionName, Const.ParamsNames.INSTRUCTOR_PERMISSION_VIEW_STUDENT_IN_SECTIONS,
                    isViewStudentInSectionsChecked);
            instructor.privileges.updatePrivilege(
                    sectionName, Const.ParamsNames.INSTRUCTOR_PERMISSION_VIEW_SESSION_IN_SECTIONS,
                    isViewSessionInSectionsChecked);
            instructor.privileges.updatePrivilege(
                    sectionName, Const.ParamsNames.INSTRUCTOR_PERMISSION_SUBMIT_SESSION_IN_SECTIONS,
                    isSubmitSessionInSectionsChecked);
            instructor.privileges.updatePrivilege(
                    sectionName, Const.ParamsNames.INSTRUCTOR_PERMISSION_MODIFY_SESSION_COMMENT_IN_SECTIONS,
                    isModifySessionInSectionsChecked);
        }
    }

    /**
     * Updates instructor privileges at session level by retrieving request parameters.
     * The parameters that are retrieved are based off {@code sectionGroupName} and {@code feedbackNames}.
     *
     * @param sectionGroupName              Name of the section group.
     * @param specialSectionsInSectionGroup Sections marked as special under the section group.
     * @param feedbackNames                 List of feedback names under the course.
     * @param instructor                    Instructor that will be added.
     *                                          This will be modified within the method.
     */
    protected void updateInstructorPrivilegesForSectionInSessionLevel(String sectionGroupName,
            List<String> specialSectionsInSectionGroup, List<String> feedbackNames,
            InstructorAttributes instructor) {
        for (String feedbackName : feedbackNames) {
            boolean isViewSessionInSectionsChecked =
                    getRequestParamValue(Const.ParamsNames.INSTRUCTOR_PERMISSION_VIEW_SESSION_IN_SECTIONS
                                         + sectionGroupName + ""feedback"" + feedbackName) != null;
            boolean isSubmitSessionInSectionsChecked =
                    getRequestParamValue(Const.ParamsNames.INSTRUCTOR_PERMISSION_SUBMIT_SESSION_IN_SECTIONS
                                         + sectionGroupName + ""feedback"" + feedbackName) != null;
            boolean isModifySessionInSectionsChecked =
                    getRequestParamValue(Const.ParamsNames.INSTRUCTOR_PERMISSION_MODIFY_SESSION_COMMENT_IN_SECTIONS
                                         + sectionGroupName + ""feedback"" + feedbackName) != null;

            for (String sectionName : specialSectionsInSectionGroup) {
                instructor.privileges.updatePrivilege(sectionName, feedbackName,
                        Const.ParamsNames.INSTRUCTOR_PERMISSION_VIEW_SESSION_IN_SECTIONS,
                        isViewSessionInSectionsChecked);
                instructor.privileges.updatePrivilege(sectionName, feedbackName,
                        Const.ParamsNames.INSTRUCTOR_PERMISSION_SUBMIT_SESSION_IN_SECTIONS,
                        isSubmitSessionInSectionsChecked);
                instructor.privileges.updatePrivilege(sectionName, feedbackName,
                        Const.ParamsNames.INSTRUCTOR_PERMISSION_MODIFY_SESSION_COMMENT_IN_SECTIONS,
                        isModifySessionInSectionsChecked);
            }
        }
    }
}
"
InstructorCourseInstructorAddAction.java,ui-controller,"package teammates.ui.controller;

import teammates.common.datatransfer.InstructorPrivileges;
import teammates.common.datatransfer.attributes.InstructorAttributes;
import teammates.common.exception.EntityAlreadyExistsException;
import teammates.common.exception.InvalidParametersException;
import teammates.common.util.Assumption;
import teammates.common.util.Const;
import teammates.common.util.SanitizationHelper;
import teammates.common.util.StatusMessage;
import teammates.common.util.StatusMessageColor;

/**
 * Action: add another instructor to a course that already exists.
 */
public class InstructorCourseInstructorAddAction extends InstructorCourseInstructorAbstractAction {

    @Override
    protected ActionResult execute() {

        String courseId = getRequestParamValue(Const.ParamsNames.COURSE_ID);
        Assumption.assertPostParamNotNull(Const.ParamsNames.COURSE_ID, courseId);
        String instructorName = getRequestParamValue(Const.ParamsNames.INSTRUCTOR_NAME);
        Assumption.assertPostParamNotNull(Const.ParamsNames.INSTRUCTOR_NAME, instructorName);
        String instructorEmail = getRequestParamValue(Const.ParamsNames.INSTRUCTOR_EMAIL);
        Assumption.assertPostParamNotNull(Const.ParamsNames.INSTRUCTOR_EMAIL, instructorEmail);

        InstructorAttributes instructor = logic.getInstructorForGoogleId(courseId, account.googleId);
        gateKeeper.verifyAccessible(
                instructor, logic.getCourse(courseId), Const.ParamsNames.INSTRUCTOR_PERMISSION_MODIFY_INSTRUCTOR);

        InstructorAttributes instructorToAdd = extractCompleteInstructor(
                courseId, instructorName, instructorEmail);

        /* Process adding the instructor and setup status to be shown to user and admin */
        try {
            logic.createInstructor(instructorToAdd);
            taskQueuer.scheduleCourseRegistrationInviteToInstructor(
                    loggedInUser.googleId, instructorEmail, courseId);

            statusToUser.add(new StatusMessage(String.format(Const.StatusMessages.COURSE_INSTRUCTOR_ADDED,
                                                             instructorName, instructorEmail),
                                               StatusMessageColor.SUCCESS));
            statusToAdmin = ""New instructor (<span class=\""bold\""> "" + instructorEmail + ""</span>)""
                    + "" for Course <span class=\""bold\"">["" + courseId + ""]</span> created.<br>"";
        } catch (EntityAlreadyExistsException e) {
            setStatusForException(e, Const.StatusMessages.COURSE_INSTRUCTOR_EXISTS);
        } catch (InvalidParametersException e) {
            setStatusForException(e);
        }

        RedirectResult redirectResult = createRedirectResult(Const.ActionURIs.INSTRUCTOR_COURSE_EDIT_PAGE);
        redirectResult.addResponseParam(Const.ParamsNames.COURSE_ID, courseId);
        return redirectResult;
    }

    /**
     * Creates a new instructor with all information filled in, using request parameters.
     * This includes basic information as well as custom privileges (if applicable).
     *
     * @param courseId        Id of the course the instructor is being added to.
     * @param instructorName  Name of the instructor.
     * @param instructorEmail Email of the instructor.
     * @return An instructor with all relevant info filled in.
     */
    private InstructorAttributes extractCompleteInstructor(String courseId, String instructorName, String instructorEmail) {
        String instructorRole = getRequestParamValue(Const.ParamsNames.INSTRUCTOR_ROLE_NAME);
        Assumption.assertPostParamNotNull(Const.ParamsNames.INSTRUCTOR_ROLE_NAME, instructorRole);
        boolean isDisplayedToStudents = getRequestParamValue(Const.ParamsNames.INSTRUCTOR_IS_DISPLAYED_TO_STUDENT) != null;
        String displayedName = getRequestParamValue(Const.ParamsNames.INSTRUCTOR_DISPLAY_NAME);
        if (displayedName == null || displayedName.isEmpty()) {
            displayedName = InstructorAttributes.DEFAULT_DISPLAY_NAME;
        }
        instructorRole = SanitizationHelper.sanitizeName(instructorRole);
        displayedName = SanitizationHelper.sanitizeName(displayedName);

        InstructorAttributes instructorToAdd = createInstructorWithBasicAttributes(courseId, instructorName,
                instructorEmail, instructorRole, isDisplayedToStudents, displayedName);

        if (instructorRole.equals(Const.InstructorPermissionRoleNames.INSTRUCTOR_PERMISSION_ROLE_CUSTOM)) {
            updateInstructorCourseLevelPrivileges(instructorToAdd);
        }

        updateInstructorWithSectionLevelPrivileges(courseId, instructorToAdd);

        instructorToAdd.privileges.validatePrivileges();

        return instructorToAdd;
    }

    /**
     * Creates a new instructor with basic information.
     * This consists of everything apart from custom privileges.
     *
     * @param courseId              Id of the course the instructor is being added to.
     * @param instructorName        Name of the instructor.
     * @param instructorEmail       Email of the instructor.
     * @param instructorRole        Role of the instructor.
     * @param isDisplayedToStudents Whether the instructor should be visible to students.
     * @param displayedName         Name to be visible to students.
     *                                  Should not be {@code null} even if {@code isDisplayedToStudents} is false.
     * @return An instructor with basic info, excluding custom privileges
     */
    private InstructorAttributes createInstructorWithBasicAttributes(String courseId, String instructorName,
            String instructorEmail, String instructorRole,
            boolean isDisplayedToStudents, String displayedName) {
        String instrName = SanitizationHelper.sanitizeName(instructorName);
        String instrEmail = SanitizationHelper.sanitizeEmail(instructorEmail);
        String instrRole = SanitizationHelper.sanitizeName(instructorRole);
        String instrDisplayedName = SanitizationHelper.sanitizeName(displayedName);
        InstructorPrivileges privileges = new InstructorPrivileges(instructorRole);

        return InstructorAttributes.builder(null, courseId, instrName, instrEmail)
                .withRole(instrRole)
                .withIsDisplayedToStudents(isDisplayedToStudents)
                .withDisplayedName(instrDisplayedName)
                .withPrivileges(privileges)
                .build();
    }
}
"
InstructorCourseInstructorDeleteAction.java,ui-controller,"package teammates.ui.controller;

import java.util.List;

import teammates.common.datatransfer.attributes.InstructorAttributes;
import teammates.common.util.Assumption;
import teammates.common.util.Const;
import teammates.common.util.StatusMessage;
import teammates.common.util.StatusMessageColor;

/**
 * Action: deleting an instructor for a course by another instructor.
 */
public class InstructorCourseInstructorDeleteAction extends Action {

    @Override
    protected ActionResult execute() {

        String courseId = getRequestParamValue(Const.ParamsNames.COURSE_ID);
        Assumption.assertPostParamNotNull(Const.ParamsNames.COURSE_ID, courseId);
        String instructorEmail = getRequestParamValue(Const.ParamsNames.INSTRUCTOR_EMAIL);
        Assumption.assertPostParamNotNull(Const.ParamsNames.INSTRUCTOR_EMAIL, instructorEmail);

        InstructorAttributes instructor = logic.getInstructorForGoogleId(courseId, account.googleId);
        gateKeeper.verifyAccessible(
                instructor, logic.getCourse(courseId), Const.ParamsNames.INSTRUCTOR_PERMISSION_MODIFY_INSTRUCTOR);

        /* Process deleting an instructor and setup status to be shown to user and admin */
        if (hasAlternativeInstructor(courseId, instructorEmail)) {
            logic.deleteInstructor(courseId, instructorEmail);

            statusToUser.add(new StatusMessage(Const.StatusMessages.COURSE_INSTRUCTOR_DELETED, StatusMessageColor.SUCCESS));
            statusToAdmin = ""Instructor <span class=\""bold\""> "" + instructorEmail + ""</span>""
                + "" in Course <span class=\""bold\"">["" + courseId + ""]</span> deleted.<br>"";
        } else {
            isError = true;
            statusToUser.add(new StatusMessage(Const.StatusMessages.COURSE_INSTRUCTOR_DELETE_NOT_ALLOWED,
                                               StatusMessageColor.DANGER));
            statusToAdmin = ""Instructor <span class=\""bold\""> "" + instructorEmail + ""</span>""
                    + "" in Course <span class=\""bold\"">["" + courseId + ""]</span> could not be deleted ""
                    + ""as there is only one instructor left to be able to modify instructors.<br>"";
        }

        /* Create redirection. It will redirect back to 'Courses' page if the instructor deletes himself */
        RedirectResult result = null;
        if (logic.isInstructorOfCourse(account.googleId, courseId)) {
            result = createRedirectResult(Const.ActionURIs.INSTRUCTOR_COURSE_EDIT_PAGE);
            result.addResponseParam(Const.ParamsNames.COURSE_ID, courseId);
        } else {
            result = createRedirectResult(Const.ActionURIs.INSTRUCTOR_COURSES_PAGE);
        }

        return result;
    }

    /**
     * Returns true if there is a joined instructor (other than the instructor to delete)
     * with the privilege of modifying instructors.
     *
     * @param courseId                Id of the course
     * @param instructorToDeleteEmail Email of the instructor who is being deleted
     */
    private boolean hasAlternativeInstructor(String courseId, String instructorToDeleteEmail) {

        List<InstructorAttributes> instructors = logic.getInstructorsForCourse(courseId);

        for (InstructorAttributes instr : instructors) {

            boolean isAlternativeInstructor =
                        instr.isRegistered()
                        && !instr.getEmail().equals(instructorToDeleteEmail)
                        && instr.isAllowedForPrivilege(Const.ParamsNames.INSTRUCTOR_PERMISSION_MODIFY_INSTRUCTOR);

            if (isAlternativeInstructor) {
                return true;
            }
        }

        return false;
    }
}
"
InstructorCourseInstructorEditSaveAction.java,ui-controller,"package teammates.ui.controller;

import java.util.List;

import teammates.common.datatransfer.InstructorPrivileges;
import teammates.common.datatransfer.attributes.InstructorAttributes;
import teammates.common.exception.EntityDoesNotExistException;
import teammates.common.exception.InvalidParametersException;
import teammates.common.util.Assumption;
import teammates.common.util.Const;
import teammates.common.util.SanitizationHelper;
import teammates.common.util.StatusMessage;
import teammates.common.util.StatusMessageColor;

public class InstructorCourseInstructorEditSaveAction extends InstructorCourseInstructorAbstractAction {

    @Override
    protected ActionResult execute() throws EntityDoesNotExistException {

        String courseId = getRequestParamValue(Const.ParamsNames.COURSE_ID);
        Assumption.assertPostParamNotNull(Const.ParamsNames.COURSE_ID, courseId);
        String instructorId = getRequestParamValue(Const.ParamsNames.INSTRUCTOR_ID);
        String instructorName = getRequestParamValue(Const.ParamsNames.INSTRUCTOR_NAME);
        Assumption.assertPostParamNotNull(Const.ParamsNames.INSTRUCTOR_NAME, instructorName);
        String instructorEmail = getRequestParamValue(Const.ParamsNames.INSTRUCTOR_EMAIL);
        Assumption.assertPostParamNotNull(Const.ParamsNames.INSTRUCTOR_EMAIL, instructorEmail);

        InstructorAttributes instructor = logic.getInstructorForGoogleId(courseId, account.googleId);
        gateKeeper.verifyAccessible(instructor, logic.getCourse(courseId),
                                    Const.ParamsNames.INSTRUCTOR_PERMISSION_MODIFY_INSTRUCTOR);

        InstructorAttributes instructorToEdit =
                extractUpdatedInstructor(courseId, instructorId, instructorName, instructorEmail);
        updateToEnsureValidityOfInstructorsForTheCourse(courseId, instructorToEdit);

        try {
            if (instructorId == null) {
                logic.updateInstructorByEmail(instructorEmail, instructorToEdit);
            } else {
                logic.updateInstructorByGoogleId(instructorId, instructorToEdit);
            }

            statusToUser.add(new StatusMessage(String.format(Const.StatusMessages.COURSE_INSTRUCTOR_EDITED, instructorName),
                                               StatusMessageColor.SUCCESS));
            statusToAdmin = ""Instructor <span class=\""bold\""> "" + instructorName + ""</span>""
                    + "" for Course <span class=\""bold\"">["" + courseId + ""]</span> edited.<br>""
                    + ""New Name: "" + instructorName + ""<br>New Email: "" + instructorEmail;
        } catch (InvalidParametersException e) {
            setStatusForException(e);
        }

        /* Create redirection to 'Edit' page with corresponding course id */
        RedirectResult result = createRedirectResult(Const.ActionURIs.INSTRUCTOR_COURSE_EDIT_PAGE);
        result.addResponseParam(Const.ParamsNames.COURSE_ID, courseId);
        return result;
    }

    /**
     * Checks if there are any other registered instructors that can modify instructors.
     * If there are none, the instructor currently being edited will be granted the privilege
     * of modifying instructors automatically.
     *
     * @param courseId         Id of the course.
     * @param instructorToEdit Instructor that will be edited.
     *                             This may be modified within the method.
     */
    private void updateToEnsureValidityOfInstructorsForTheCourse(String courseId, InstructorAttributes instructorToEdit) {
        List<InstructorAttributes> instructors = logic.getInstructorsForCourse(courseId);
        int numOfInstrCanModifyInstructor = 0;
        InstructorAttributes instrWithModifyInstructorPrivilege = null;
        for (InstructorAttributes instructor : instructors) {
            if (instructor.isAllowedForPrivilege(Const.ParamsNames.INSTRUCTOR_PERMISSION_MODIFY_INSTRUCTOR)) {
                numOfInstrCanModifyInstructor++;
                instrWithModifyInstructorPrivilege = instructor;
            }
        }
        boolean isLastRegInstructorWithPrivilege = numOfInstrCanModifyInstructor <= 1
                                                   && instrWithModifyInstructorPrivilege != null
                                                   && (!instrWithModifyInstructorPrivilege.isRegistered()
                                                           || instrWithModifyInstructorPrivilege.googleId
                                                                     .equals(instructorToEdit.googleId));
        if (isLastRegInstructorWithPrivilege) {
            instructorToEdit.privileges.updatePrivilege(Const.ParamsNames.INSTRUCTOR_PERMISSION_MODIFY_INSTRUCTOR, true);
        }
    }

    /**
     * Creates a new instructor representing the updated instructor with all information filled in,
     * using request parameters.
     * This includes basic information as well as custom privileges (if applicable).
     *
     * @param courseId        Id of the course the instructor is being added to.
     * @param instructorId    Id of the instructor.
     * @param instructorName  Name of the instructor.
     * @param instructorEmail Email of the instructor.
     * @return The updated instructor with all relevant info filled in.
     */
    private InstructorAttributes extractUpdatedInstructor(String courseId, String instructorId,
                                                          String instructorName, String instructorEmail) {
        String instructorRole = getRequestParamValue(Const.ParamsNames.INSTRUCTOR_ROLE_NAME);
        Assumption.assertPostParamNotNull(Const.ParamsNames.INSTRUCTOR_ROLE_NAME, instructorRole);
        boolean isDisplayedToStudents = getRequestParamValue(Const.ParamsNames.INSTRUCTOR_IS_DISPLAYED_TO_STUDENT) != null;
        String displayedName = getRequestParamValue(Const.ParamsNames.INSTRUCTOR_DISPLAY_NAME);
        if (displayedName == null || displayedName.isEmpty()) {
            displayedName = InstructorAttributes.DEFAULT_DISPLAY_NAME;
        }
        instructorRole = SanitizationHelper.sanitizeName(instructorRole);
        displayedName = SanitizationHelper.sanitizeName(displayedName);

        InstructorAttributes instructorToEdit =
                updateBasicInstructorAttributes(courseId, instructorId, instructorName, instructorEmail,
                                                instructorRole, isDisplayedToStudents, displayedName);

        if (instructorRole.equals(Const.InstructorPermissionRoleNames.INSTRUCTOR_PERMISSION_ROLE_CUSTOM)) {
            updateInstructorCourseLevelPrivileges(instructorToEdit);
        }

        updateInstructorWithSectionLevelPrivileges(courseId, instructorToEdit);

        instructorToEdit.privileges.validatePrivileges();

        return instructorToEdit;
    }

    /**
     * Edits an existing instructor's basic information.
     * This consists of everything apart from custom privileges.
     *
     * @param courseId              Id of the course the instructor is being added to.
     * @param instructorId          Id of the instructor.
     * @param instructorName        Name of the instructor.
     * @param instructorEmail       Email of the instructor.
     * @param instructorRole        Role of the instructor.
     * @param isDisplayedToStudents Whether the instructor should be visible to students.
     * @param displayedName         Name to be visible to students.
     *                                  Should not be {@code null} even if {@code isDisplayedToStudents} is false.
     * @return The edited instructor with updated basic info, and its old custom privileges (if applicable)
     */
    private InstructorAttributes updateBasicInstructorAttributes(String courseId,
            String instructorId, String instructorName, String instructorEmail,
            String instructorRole, boolean isDisplayedToStudents, String displayedName) {
        InstructorAttributes instructorToEdit = null;
        if (instructorId == null) {
            instructorToEdit = logic.getInstructorForEmail(courseId, instructorEmail);
        } else {
            instructorToEdit = logic.getInstructorForGoogleId(courseId, instructorId);
        }
        instructorToEdit.name = SanitizationHelper.sanitizeName(instructorName);
        instructorToEdit.email = SanitizationHelper.sanitizeEmail(instructorEmail);
        instructorToEdit.role = SanitizationHelper.sanitizeName(instructorRole);
        instructorToEdit.displayedName = SanitizationHelper.sanitizeName(displayedName);
        instructorToEdit.isDisplayedToStudents = isDisplayedToStudents;
        instructorToEdit.privileges = new InstructorPrivileges(instructorToEdit.role);

        return instructorToEdit;
    }
}
"
InstructorCourseJoinAction.java,ui-controller,"package teammates.ui.controller;

import teammates.common.datatransfer.attributes.InstructorAttributes;
import teammates.common.util.Assumption;
import teammates.common.util.Const;
import teammates.common.util.Url;
import teammates.ui.pagedata.InstructorCourseJoinConfirmationPageData;

/**
 * This action handles instructors that attempts to join a course.
 * It asks the instructor for confirmation that the logged in account
 * belongs to him before redirecting him to the actual join action,
 * {@link InstructorCourseJoinAuthenticatedAction}.
 * <br><br>
 * This is done to prevent instructor from accidentally linking
 * his registration key with another instructor's google account.
 */
public class InstructorCourseJoinAction extends Action {

    @Override
    public ActionResult execute() {

        String institute = getRequestParamValue(Const.ParamsNames.INSTRUCTOR_INSTITUTION);

        Assumption.assertNotNull(regkey);

        gateKeeper.verifyLoggedInUserPrivileges();

        /* Process confirmation for instructor if needed and setup status to be shown to admin */
        statusToAdmin = ""Action Instructor Clicked Join Link""
                        + ""<br>Google ID: "" + account.googleId
                        + ""<br>Key: "" + regkey;

        InstructorAttributes instructor = logic.getInstructorForRegistrationKey(regkey);

        if (instructor != null && instructor.isRegistered()) {
            // Bypass confirmation if instructor is already registered
            String redirectUrl = Url.addParamToUrl(Const.ActionURIs.INSTRUCTOR_COURSE_JOIN_AUTHENTICATED,
                                                   Const.ParamsNames.REGKEY, regkey);

            //for the link of instructor added by admin, an additional parameter institute is needed
            //so it must be passed to instructorCourseJoinAuthenticated action
            if (institute != null) {
                redirectUrl = Url.addParamToUrl(redirectUrl, Const.ParamsNames.INSTRUCTOR_INSTITUTION, institute);
            }

            return createRedirectResult(redirectUrl);
        }

        //1.For instructors added by admin, institute is passed from the join link and should be passed
        //to the confirmation page and later to authenticated action for account creation
        //2.For instructors added by other instructors, institute is not passed from the link so the value
        //will be null

        InstructorCourseJoinConfirmationPageData pageData =
                new InstructorCourseJoinConfirmationPageData(account, sessionToken, regkey, institute);

        return createShowPageResult(Const.ViewURIs.INSTRUCTOR_COURSE_JOIN_CONFIRMATION, pageData);
    }
}
"
InstructorCourseJoinAuthenticatedAction.java,ui-controller,"package teammates.ui.controller;

import teammates.common.datatransfer.attributes.InstructorAttributes;
import teammates.common.exception.EntityDoesNotExistException;
import teammates.common.exception.InvalidParametersException;
import teammates.common.exception.JoinCourseException;
import teammates.common.util.Assumption;
import teammates.common.util.Const;
import teammates.common.util.Logger;
import teammates.common.util.StringHelper;

/**
 * This action handles instructors who attempt to join a course after
 * the instructor has been forced to re-authenticate himself by
 * {@link InstructorCourseJoinAction}. This action does the actual
 * joining of the instructor to the course.
 */
public class InstructorCourseJoinAuthenticatedAction extends Action {

    private static final Logger log = Logger.getLogger();

    @Override
    protected ActionResult execute() throws EntityDoesNotExistException {
        Assumption.assertNotNull(regkey);

        String institute = getRequestParamValue(Const.ParamsNames.INSTRUCTOR_INSTITUTION);

        gateKeeper.verifyLoggedInUserPrivileges();

        /* Process authentication for the instructor to join course */
        try {

            if (institute == null) {
                logic.joinCourseForInstructor(regkey, account.googleId);
            } else {
                logic.joinCourseForInstructor(regkey, account.googleId, institute);
            }

        } catch (JoinCourseException | InvalidParametersException e) {
            // Does not sanitize for html to allow insertion of mailto link
            setStatusForException(e, e.getMessage());
            log.info(e.getMessage());
        }

        /* Set status to be shown to admin */
        StringBuffer joinedCourseMsg = new StringBuffer(100);
        joinedCourseMsg.append(""Action Instructor Joins Course<br>Google ID: "").append(account.googleId);
        try {
            joinedCourseMsg.append(""<br>Key : "").append(StringHelper.decrypt(regkey));
        } catch (InvalidParametersException e) {
            joinedCourseMsg.append(""<br>Key could not be decrypted."");
            // no need to do setStatusForException and logging, as this case is already caught above
        }

        if (statusToAdmin == null) {
            statusToAdmin = joinedCourseMsg.toString();
        } else {
            statusToAdmin += ""<br><br>"" + joinedCourseMsg.toString();
        }

        /* Create redirection to instructor's homepage */
        RedirectResult response = createRedirectResult(Const.ActionURIs.INSTRUCTOR_HOME_PAGE);
        InstructorAttributes instructor = logic.getInstructorForRegistrationKey(regkey);
        if (instructor != null) {
            response.addResponseParam(Const.ParamsNames.CHECK_PERSISTENCE_COURSE, instructor.courseId);
        }

        return response;
    }
}
"
InstructorCourseRemindAction.java,ui-controller,"package teammates.ui.controller;

import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.TreeMap;

import teammates.common.datatransfer.attributes.CourseAttributes;
import teammates.common.datatransfer.attributes.InstructorAttributes;
import teammates.common.datatransfer.attributes.StudentAttributes;
import teammates.common.exception.EntityDoesNotExistException;
import teammates.common.util.Assumption;
import teammates.common.util.Config;
import teammates.common.util.Const;
import teammates.common.util.StatusMessage;
import teammates.common.util.StatusMessageColor;
import teammates.common.util.StringHelper;

/**
 * Action: remind instructor or student to register for a course by sending reminder emails.
 */
public class InstructorCourseRemindAction extends Action {

    @Override
    public ActionResult execute() throws EntityDoesNotExistException {

        String courseId = getRequestParamValue(Const.ParamsNames.COURSE_ID);
        Assumption.assertPostParamNotNull(Const.ParamsNames.COURSE_ID, courseId);

        CourseAttributes course = logic.getCourse(courseId);
        if (course == null) {
            throw new EntityDoesNotExistException(""Course with ID "" + courseId + "" does not exist!"");
        }

        String studentEmail = getRequestParamValue(Const.ParamsNames.STUDENT_EMAIL);
        String instructorEmail = getRequestParamValue(Const.ParamsNames.INSTRUCTOR_EMAIL);

        InstructorAttributes instructor = logic.getInstructorForGoogleId(courseId, account.googleId);
        boolean isSendingToStudent = studentEmail != null;
        boolean isSendingToInstructor = instructorEmail != null;
        if (isSendingToStudent) {
            gateKeeper.verifyAccessible(
                    instructor, course, Const.ParamsNames.INSTRUCTOR_PERMISSION_MODIFY_STUDENT);
        } else if (isSendingToInstructor) {
            gateKeeper.verifyAccessible(
                    instructor, course, Const.ParamsNames.INSTRUCTOR_PERMISSION_MODIFY_INSTRUCTOR);
        } else {
            // this is sending registration emails to all students in the course and we will check if the instructor
            // canmodifystudent for course level since for modifystudent privilege there is only course level setting for now
            gateKeeper.verifyAccessible(
                    instructor, course, Const.ParamsNames.INSTRUCTOR_PERMISSION_MODIFY_STUDENT);
        }

        /* Process sending emails and setup status to be shown to user and admin */
        Map<String, JoinEmailData> emailDataMap = new TreeMap<>();

        String redirectUrl = """";
        if (isSendingToStudent) {
            taskQueuer.scheduleCourseRegistrationInviteToStudent(courseId, studentEmail, false);
            StudentAttributes studentData = logic.getStudentForEmail(courseId, studentEmail);
            if (studentData == null) {
                throw new EntityDoesNotExistException(""Student with email "" + studentEmail + "" does not exist ""
                                                      + ""in course "" + courseId + ""!"");
            }
            emailDataMap.put(studentEmail,
                             new JoinEmailData(studentData.getName(), extractStudentRegistrationKey(studentData)));

            statusToUser.add(new StatusMessage(Const.StatusMessages.COURSE_REMINDER_SENT_TO + studentEmail,
                                               StatusMessageColor.SUCCESS));
            redirectUrl = Const.ActionURIs.INSTRUCTOR_COURSE_DETAILS_PAGE;
        } else if (isSendingToInstructor) {
            taskQueuer.scheduleCourseRegistrationInviteToInstructor(loggedInUser.googleId,
                    instructorEmail, courseId);

            InstructorAttributes instructorData = logic.getInstructorForEmail(courseId, instructorEmail);
            if (instructorData == null) {
                throw new EntityDoesNotExistException(""Instructor with email "" + instructorEmail + "" does not exist ""
                                                      + ""in course "" + courseId + ""!"");
            }

            emailDataMap.put(instructorEmail,
                    new JoinEmailData(instructorData.getName(), StringHelper.encrypt(instructorData.key)));

            statusToUser.add(new StatusMessage(Const.StatusMessages.COURSE_REMINDER_SENT_TO + instructorEmail,
                                               StatusMessageColor.SUCCESS));
            redirectUrl = Const.ActionURIs.INSTRUCTOR_COURSE_EDIT_PAGE;
        } else {
            List<StudentAttributes> studentDataList = logic.getUnregisteredStudentsForCourse(courseId);
            for (StudentAttributes student : studentDataList) {
                taskQueuer.scheduleCourseRegistrationInviteToStudent(course.getId(), student.getEmail(), false);
                emailDataMap.put(student.getEmail(),
                        new JoinEmailData(student.getName(), extractStudentRegistrationKey(student)));
            }

            statusToUser.add(new StatusMessage(Const.StatusMessages.COURSE_REMINDERS_SENT, StatusMessageColor.SUCCESS));
            redirectUrl = Const.ActionURIs.INSTRUCTOR_COURSE_DETAILS_PAGE;
        }

        statusToAdmin = generateStatusToAdmin(emailDataMap, courseId);

        /* Create redirection with URL based on type of sending email */
        RedirectResult response = createRedirectResult(redirectUrl);
        response.addResponseParam(Const.ParamsNames.COURSE_ID, courseId);

        return response;

    }

    private String generateStatusToAdmin(Map<String, JoinEmailData> emailDataMap, String courseId) {
        StringBuilder statusToAdmin = new StringBuilder(200);
        statusToAdmin.append(""Registration Key sent to the following users in Course <span class=\""bold\"">["")
                     .append(courseId)
                     .append(""]</span>:<br>"");

        Set<Entry<String, JoinEmailData>> entries = emailDataMap.entrySet();

        for (Entry<String, JoinEmailData> entry : entries) {

            String userEmail = entry.getKey();
            JoinEmailData joinEmailData = entry.getValue();

            statusToAdmin.append(joinEmailData.userName)
                         .append(""<span class=\""bold\""> ("").append(userEmail).append("")</span>.<br>"")
                         .append(joinEmailData.regKey).append(""<br>"");
        }

        return statusToAdmin.toString();
    }

    private String extractStudentRegistrationKey(StudentAttributes student) {
        String joinLink = Config.getAppUrl(student.getRegistrationUrl()).toAbsoluteString();
        String keyParam = Const.ParamsNames.REGKEY + ""="";
        int startIndex = joinLink.indexOf(keyParam) + keyParam.length();
        return joinLink.substring(startIndex);
    }

    private static class JoinEmailData {
        String userName;
        String regKey;

        JoinEmailData(String userName, String regKey) {
            this.userName = userName;
            this.regKey = regKey;
        }
    }
}
"
InstructorCoursesPageAction.java,ui-controller,"package teammates.ui.controller;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import teammates.common.datatransfer.attributes.CourseAttributes;
import teammates.common.datatransfer.attributes.InstructorAttributes;
import teammates.common.util.Const;
import teammates.common.util.StatusMessage;
import teammates.common.util.StatusMessageColor;
import teammates.ui.pagedata.InstructorCoursesPageData;

/**
 * Action: loading of the 'Courses' page for an instructor.
 */
public class InstructorCoursesPageAction extends Action {

    @Override
    public ActionResult execute() {
        /* Explanation: First, we extract any parameters from the request object.
         * e.g., idOfCourseToDelete = getRequestParam(Const.ParamsNames.COURSE_ID);
         * After that, we may verify parameters.
         * e.g. Assumption.assertNotNull(courseId);
         * In this Action, there are no parameters.*/

        /* Explanation: Next, check if the user has rights to execute the action.*/
        gateKeeper.verifyInstructorPrivileges(account);

        /* Explanation: This is a 'show page' type action. Therefore, we
         * prepare the matching PageData object, accessing the Logic
         * component if necessary.*/
        InstructorCoursesPageData data = new InstructorCoursesPageData(account, sessionToken);
        String isUsingAjax = getRequestParamValue(Const.ParamsNames.IS_USING_AJAX);
        data.setUsingAjax(isUsingAjax != null);

        Map<String, InstructorAttributes> instructorsForCourses = new HashMap<>();
        List<CourseAttributes> allCourses = new ArrayList<>();
        List<CourseAttributes> activeCourses = new ArrayList<>();
        List<CourseAttributes> archivedCourses = new ArrayList<>();

        if (data.isUsingAjax()) {
            // Get list of InstructorAttributes that belong to the user.
            List<InstructorAttributes> instructorList = logic.getInstructorsForGoogleId(data.account.googleId);
            for (InstructorAttributes instructor : instructorList) {
                instructorsForCourses.put(instructor.courseId, instructor);
            }

            // Get corresponding courses of the instructors.
            allCourses = logic.getCoursesForInstructor(instructorList);

            List<String> archivedCourseIds = logic.getArchivedCourseIds(allCourses, instructorsForCourses);
            for (CourseAttributes course : allCourses) {
                if (archivedCourseIds.contains(course.getId())) {
                    archivedCourses.add(course);
                } else {
                    activeCourses.add(course);
                }
            }

            // Sort CourseDetailsBundle lists by course id
            CourseAttributes.sortById(activeCourses);
            CourseAttributes.sortById(archivedCourses);
        }

        data.init(activeCourses, archivedCourses, instructorsForCourses);

        /* Explanation: Set any status messages that should be shown to the user.*/
        if (data.isUsingAjax() && allCourses.isEmpty()) {
            statusToUser.add(new StatusMessage(Const.StatusMessages.COURSE_EMPTY, StatusMessageColor.WARNING));
        }

        /* Explanation: We must set this variable. It is the text that will
         * represent this particular execution of this action in the
         * 'admin activity log' page.*/
        statusToAdmin = ""instructorCourse Page Load<br>Total courses: "" + allCourses.size();

        /* Explanation: Create the appropriate result object and return it.*/
        return createShowPageResult(Const.ViewURIs.INSTRUCTOR_COURSES, data);
    }
}
"
InstructorCourseStudentDeleteAction.java,ui-controller,"package teammates.ui.controller;

import teammates.common.datatransfer.attributes.InstructorAttributes;
import teammates.common.util.Assumption;
import teammates.common.util.Const;
import teammates.common.util.StatusMessage;
import teammates.common.util.StatusMessageColor;

public class InstructorCourseStudentDeleteAction extends Action {

    @Override
    public ActionResult execute() {

        String courseId = getRequestParamValue(Const.ParamsNames.COURSE_ID);
        Assumption.assertPostParamNotNull(Const.ParamsNames.COURSE_ID, courseId);

        String studentEmail = getRequestParamValue(Const.ParamsNames.STUDENT_EMAIL);
        Assumption.assertPostParamNotNull(Const.ParamsNames.STUDENT_EMAIL, studentEmail);

        InstructorAttributes instructor = logic.getInstructorForGoogleId(courseId, account.googleId);
        gateKeeper.verifyAccessible(
                instructor, logic.getCourse(courseId), Const.ParamsNames.INSTRUCTOR_PERMISSION_MODIFY_STUDENT);

        logic.deleteStudent(courseId, studentEmail);
        statusToUser.add(new StatusMessage(Const.StatusMessages.STUDENT_DELETED, StatusMessageColor.SUCCESS));
        statusToAdmin = ""Student <span class=\""bold\"">"" + studentEmail
                      + ""</span> in Course <span class=\""bold\"">["" + courseId + ""]</span> deleted."";

        RedirectResult result = createRedirectResult(Const.ActionURIs.INSTRUCTOR_COURSE_DETAILS_PAGE);
        result.addResponseParam(Const.ParamsNames.COURSE_ID, courseId);
        return result;

    }

}
"
InstructorCourseStudentDeleteAllAction.java,ui-controller,"package teammates.ui.controller;

import teammates.common.datatransfer.attributes.InstructorAttributes;
import teammates.common.util.Assumption;
import teammates.common.util.Const;
import teammates.common.util.StatusMessage;
import teammates.common.util.StatusMessageColor;

public class InstructorCourseStudentDeleteAllAction extends Action {

    @Override
    public ActionResult execute() {

        String courseId = getRequestParamValue(Const.ParamsNames.COURSE_ID);
        Assumption.assertPostParamNotNull(Const.ParamsNames.COURSE_ID, courseId);

        InstructorAttributes instructor = logic.getInstructorForGoogleId(courseId, account.googleId);
        gateKeeper.verifyAccessible(
                instructor, logic.getCourse(courseId), Const.ParamsNames.INSTRUCTOR_PERMISSION_MODIFY_STUDENT);

        logic.deleteAllStudentsInCourse(courseId);
        statusToUser.add(new StatusMessage(Const.StatusMessages.STUDENTS_DELETED, StatusMessageColor.SUCCESS));
        statusToAdmin = ""All the Students ""
                + ""in Course <span class=\""bold\"">["" + courseId + ""]</span> are deleted."";

        RedirectResult result = createRedirectResult(Const.ActionURIs.INSTRUCTOR_COURSE_DETAILS_PAGE);
        result.addResponseParam(Const.ParamsNames.COURSE_ID, courseId);
        return result;

    }

}
"
InstructorCourseStudentDetailsEditPageAction.java,ui-controller,"package teammates.ui.controller;

import teammates.common.datatransfer.attributes.InstructorAttributes;
import teammates.common.datatransfer.attributes.StudentAttributes;
import teammates.common.exception.EntityDoesNotExistException;
import teammates.common.util.Assumption;
import teammates.common.util.Const;
import teammates.common.util.StatusMessage;
import teammates.common.util.StatusMessageColor;
import teammates.ui.pagedata.InstructorCourseStudentDetailsEditPageData;

public class InstructorCourseStudentDetailsEditPageAction extends Action {

    @Override
    public ActionResult execute() throws EntityDoesNotExistException {

        String courseId = getRequestParamValue(Const.ParamsNames.COURSE_ID);
        Assumption.assertPostParamNotNull(Const.ParamsNames.COURSE_ID, courseId);

        String studentEmail = getRequestParamValue(Const.ParamsNames.STUDENT_EMAIL);
        Assumption.assertPostParamNotNull(Const.ParamsNames.STUDENT_EMAIL, studentEmail);

        InstructorAttributes instructor = logic.getInstructorForGoogleId(courseId, account.googleId);
        gateKeeper.verifyAccessible(
                instructor, logic.getCourse(courseId), Const.ParamsNames.INSTRUCTOR_PERMISSION_MODIFY_STUDENT);

        StudentAttributes student = logic.getStudentForEmail(courseId, studentEmail);

        if (student == null) {
            statusToUser.add(new StatusMessage(Const.StatusMessages.STUDENT_NOT_FOUND_FOR_EDIT,
                                               StatusMessageColor.DANGER));
            isError = true;
            return createRedirectResult(Const.ActionURIs.INSTRUCTOR_HOME_PAGE);
        }

        boolean hasSection = logic.hasIndicatedSections(courseId);
        boolean isOpenOrPublishedEmailSentForTheCourse = logic.isOpenOrPublishedEmailSentForTheCourse(courseId);

        InstructorCourseStudentDetailsEditPageData data =
                new InstructorCourseStudentDetailsEditPageData(account, sessionToken, student, student.email, hasSection,
                        isOpenOrPublishedEmailSentForTheCourse);

        statusToAdmin = ""instructorCourseStudentEdit Page Load<br>""
                        + ""Editing Student <span class=\""bold\"">"" + studentEmail + ""'s</span> details ""
                        + ""in Course <span class=\""bold\"">["" + courseId + ""]</span>"";

        return createShowPageResult(Const.ViewURIs.INSTRUCTOR_COURSE_STUDENT_EDIT, data);

    }
}
"
InstructorCourseStudentDetailsEditSaveAction.java,ui-controller,"package teammates.ui.controller;

import java.util.Arrays;

import teammates.common.datatransfer.attributes.InstructorAttributes;
import teammates.common.datatransfer.attributes.StudentAttributes;
import teammates.common.exception.EnrollException;
import teammates.common.exception.EntityDoesNotExistException;
import teammates.common.exception.InvalidParametersException;
import teammates.common.exception.TeammatesException;
import teammates.common.util.Assumption;
import teammates.common.util.Const;
import teammates.common.util.EmailWrapper;
import teammates.common.util.Logger;
import teammates.common.util.SanitizationHelper;
import teammates.common.util.StatusMessage;
import teammates.common.util.StatusMessageColor;
import teammates.logic.api.EmailGenerator;
import teammates.ui.pagedata.InstructorCourseStudentDetailsEditPageData;

public class InstructorCourseStudentDetailsEditSaveAction extends Action {

    private static final Logger log = Logger.getLogger();

    @Override
    public ActionResult execute() throws EntityDoesNotExistException {

        String courseId = getRequestParamValue(Const.ParamsNames.COURSE_ID);
        Assumption.assertPostParamNotNull(Const.ParamsNames.COURSE_ID, courseId);

        String studentEmail = getRequestParamValue(Const.ParamsNames.STUDENT_EMAIL);
        Assumption.assertPostParamNotNull(Const.ParamsNames.STUDENT_EMAIL, studentEmail);

        InstructorAttributes instructor = logic.getInstructorForGoogleId(courseId, account.googleId);
        gateKeeper.verifyAccessible(
                instructor, logic.getCourse(courseId), Const.ParamsNames.INSTRUCTOR_PERMISSION_MODIFY_STUDENT);

        StudentAttributes student = logic.getStudentForEmail(courseId, studentEmail);

        if (student == null) {
            return redirectWithError(Const.StatusMessages.STUDENT_NOT_FOUND_FOR_EDIT,
                                     ""Student <span class=\""bold\"">"" + studentEmail + ""</span> in ""
                                     + ""Course <span class=\""bold\"">["" + courseId + ""]</span> not found."",
                                     courseId);
        }

        student.name = getRequestParamValue(Const.ParamsNames.STUDENT_NAME);
        student.email = getRequestParamValue(Const.ParamsNames.NEW_STUDENT_EMAIL);
        student.team = getRequestParamValue(Const.ParamsNames.TEAM_NAME);
        student.section = getRequestParamValue(Const.ParamsNames.SECTION_NAME);
        student.comments = getRequestParamValue(Const.ParamsNames.COMMENTS);
        boolean hasSection = logic.hasIndicatedSections(courseId);

        student.name = SanitizationHelper.sanitizeName(student.name);
        student.email = SanitizationHelper.sanitizeEmail(student.email);
        student.team = SanitizationHelper.sanitizeName(student.team);
        student.section = SanitizationHelper.sanitizeName(student.section);
        student.comments = SanitizationHelper.sanitizeTextField(student.comments);

        try {
            StudentAttributes originalStudentAttribute = logic.getStudentForEmail(courseId, studentEmail);
            student.updateWithExistingRecord(originalStudentAttribute);

            boolean isSectionChanged = student.isSectionChanged(originalStudentAttribute);
            boolean isTeamChanged = student.isTeamChanged(originalStudentAttribute);
            boolean isEmailChanged = student.isEmailChanged(originalStudentAttribute);

            if (isSectionChanged) {
                logic.validateSectionsAndTeams(Arrays.asList(student), courseId);
            } else if (isTeamChanged) {
                logic.validateTeams(Arrays.asList(student), courseId);
            }

            logic.updateStudent(studentEmail, student);

            boolean isSessionSummarySendEmail = getRequestParamAsBoolean(Const.ParamsNames.SESSION_SUMMARY_EMAIL_SEND_CHECK);
            if (isEmailChanged) {
                logic.resetStudentGoogleId(student.email, courseId);
                if (isSessionSummarySendEmail) {
                    try {
                        EmailWrapper email = new EmailGenerator().generateFeedbackSessionSummaryOfCourse(courseId, student);
                        emailSender.sendEmail(email);
                    } catch (Exception e) {
                        log.severe(""Error while sending session summary email""
                                    + TeammatesException.toStringWithStackTrace(e));
                    }
                }
            }

            statusToUser.add(new StatusMessage(isSessionSummarySendEmail && isEmailChanged
                                ? Const.StatusMessages.STUDENT_EDITED_AND_EMAIL_SENT
                                : Const.StatusMessages.STUDENT_EDITED, StatusMessageColor.SUCCESS));

            statusToAdmin = ""Student <span class=\""bold\"">"" + studentEmail + ""'s</span> details in ""
                            + ""Course <span class=\""bold\"">["" + courseId + ""]</span> edited.<br>""
                            + ""New Email: "" + student.email + ""<br>New Team: "" + student.team + ""<br>""
                            + ""Comments: "" + student.comments;

            RedirectResult result = createRedirectResult(Const.ActionURIs.INSTRUCTOR_COURSE_DETAILS_PAGE);
            result.addResponseParam(Const.ParamsNames.COURSE_ID, courseId);
            return result;

        } catch (InvalidParametersException | EnrollException e) {
            setStatusForException(e);
            String newEmail = student.email;
            student.email = studentEmail;
            boolean isOpenOrPublishedEmailSentForTheCourse = logic.isOpenOrPublishedEmailSentForTheCourse(courseId);
            InstructorCourseStudentDetailsEditPageData data =
                    new InstructorCourseStudentDetailsEditPageData(account, sessionToken, student, newEmail, hasSection,
                            isOpenOrPublishedEmailSentForTheCourse);
            return createShowPageResult(Const.ViewURIs.INSTRUCTOR_COURSE_STUDENT_EDIT, data);
        }

    }

    private RedirectResult redirectWithError(String errorToUser, String errorToAdmin, String courseId) {
        statusToUser.add(new StatusMessage(errorToUser, StatusMessageColor.DANGER));
        statusToAdmin = errorToAdmin;
        isError = true;

        RedirectResult result = createRedirectResult(Const.ActionURIs.INSTRUCTOR_COURSE_DETAILS_PAGE);
        result.addResponseParam(Const.ParamsNames.COURSE_ID, courseId);
        return result;
    }

}
"
InstructorCourseStudentDetailsPageAction.java,ui-controller,"package teammates.ui.controller;

import teammates.common.datatransfer.attributes.InstructorAttributes;
import teammates.common.datatransfer.attributes.StudentAttributes;
import teammates.common.datatransfer.attributes.StudentProfileAttributes;
import teammates.common.exception.EntityDoesNotExistException;
import teammates.common.util.Assumption;
import teammates.common.util.Const;
import teammates.common.util.StatusMessage;
import teammates.common.util.StatusMessageColor;
import teammates.ui.pagedata.InstructorCourseStudentDetailsPageData;

public class InstructorCourseStudentDetailsPageAction extends Action {

    @Override
    public ActionResult execute() throws EntityDoesNotExistException {

        String courseId = getRequestParamValue(Const.ParamsNames.COURSE_ID);
        Assumption.assertPostParamNotNull(Const.ParamsNames.COURSE_ID, courseId);

        String studentEmail = getRequestParamValue(Const.ParamsNames.STUDENT_EMAIL);
        Assumption.assertPostParamNotNull(Const.ParamsNames.STUDENT_EMAIL, studentEmail);

        StudentAttributes student = logic.getStudentForEmail(courseId, studentEmail);
        if (student == null) {
            statusToUser.add(new StatusMessage(Const.StatusMessages.STUDENT_NOT_FOUND_FOR_COURSE_DETAILS,
                                               StatusMessageColor.DANGER));
            isError = true;
            return createRedirectResult(Const.ActionURIs.INSTRUCTOR_HOME_PAGE);
        }
        InstructorAttributes instructor = logic.getInstructorForGoogleId(courseId, account.googleId);
        gateKeeper.verifyAccessible(instructor, logic.getCourse(courseId), student.section,
                                    Const.ParamsNames.INSTRUCTOR_PERMISSION_VIEW_STUDENT_IN_SECTIONS);

        boolean hasSection = logic.hasIndicatedSections(courseId);

        StudentProfileAttributes studentProfile = loadStudentProfile(student, instructor);

        InstructorCourseStudentDetailsPageData data =
                new InstructorCourseStudentDetailsPageData(account, sessionToken, student, studentProfile,
                                                           hasSection);

        statusToAdmin = ""instructorCourseStudentDetails Page Load<br>""
                        + ""Viewing details for Student <span class=\""bold\"">"" + studentEmail
                        + ""</span> in Course <span class=\""bold\"">["" + courseId + ""]</span>"";

        return createShowPageResult(Const.ViewURIs.INSTRUCTOR_COURSE_STUDENT_DETAILS, data);

    }

    private StudentProfileAttributes loadStudentProfile(StudentAttributes student, InstructorAttributes currentInstructor) {
        StudentProfileAttributes studentProfile = null;
        boolean isInstructorAllowedToViewStudent = currentInstructor.isAllowedForPrivilege(student.section,
                                                        Const.ParamsNames.INSTRUCTOR_PERMISSION_VIEW_STUDENT_IN_SECTIONS);
        boolean isStudentWithProfile = !student.googleId.isEmpty();
        if (isInstructorAllowedToViewStudent && isStudentWithProfile) {
            studentProfile = logic.getStudentProfile(student.googleId);
            Assumption.assertNotNull(studentProfile);

            return studentProfile;
        }

        // this means that the user is returning to the page and is not the first time
        boolean hasExistingStatus = !statusToUser.isEmpty()
                                        || session.getAttribute(Const.ParamsNames.STATUS_MESSAGES_LIST) != null;
        if (!isStudentWithProfile && !hasExistingStatus) {
            statusToUser.add(new StatusMessage(Const.StatusMessages.STUDENT_NOT_JOINED_YET_FOR_RECORDS,
                                               StatusMessageColor.WARNING));
        }
        if (!isInstructorAllowedToViewStudent && !hasExistingStatus) {
            statusToUser.add(new StatusMessage(Const.StatusMessages.STUDENT_PROFILE_UNACCESSIBLE_TO_INSTRUCTOR,
                                               StatusMessageColor.WARNING));
        }
        return null;
    }
}
"
InstructorCourseStudentListDownloadAction.java,ui-controller,"package teammates.ui.controller;

import teammates.common.exception.EntityDoesNotExistException;
import teammates.common.util.Assumption;
import teammates.common.util.Const;

public class InstructorCourseStudentListDownloadAction extends Action {

    @Override
    protected ActionResult execute() throws EntityDoesNotExistException {
        String courseId = getRequestParamValue(Const.ParamsNames.COURSE_ID);
        Assumption.assertPostParamNotNull(Const.ParamsNames.COURSE_ID, courseId);

        gateKeeper.verifyAccessible(
                logic.getInstructorForGoogleId(courseId, account.googleId),
                logic.getCourse(courseId));

        String fileContent = logic.getCourseStudentListAsCsv(courseId, account.googleId);
        String fileName = courseId + ""_studentList"";

        statusToAdmin = ""Students data for Course "" + courseId + "" was downloaded"";

        return createFileDownloadResult(fileName, fileContent);
    }

}
"
InstructorEditInstructorFeedbackPageAction.java,ui-controller,"package teammates.ui.controller;

import teammates.common.datatransfer.attributes.InstructorAttributes;
import teammates.common.exception.EntityDoesNotExistException;
import teammates.common.util.Assumption;
import teammates.common.util.Const;
import teammates.ui.pagedata.FeedbackSubmissionEditPageData;

/**
 * The {@code InstructorEditInstructorFeedbackPageAction} class handles incoming requests to the page.
 * {@code FeedbackSubmissionEditPageData} will be generated and the page requested will be loaded.
 */
public class InstructorEditInstructorFeedbackPageAction extends Action {

    @Override
    protected ActionResult execute() throws EntityDoesNotExistException {
        String courseId = getRequestParamValue(Const.ParamsNames.COURSE_ID);
        String feedbackSessionName = getRequestParamValue(Const.ParamsNames.FEEDBACK_SESSION_NAME);
        String instructorUnderModerationEmail = getRequestParamValue(Const.ParamsNames.FEEDBACK_SESSION_MODERATED_PERSON);

        gateKeeper.verifyAccessible(logic.getInstructorForGoogleId(courseId, account.googleId),
                                    logic.getFeedbackSession(feedbackSessionName, courseId),
                                    false, Const.ParamsNames.INSTRUCTOR_PERMISSION_MODIFY_SESSION);

        InstructorAttributes instructorUnderModeration =
                logic.getInstructorForEmail(courseId, instructorUnderModerationEmail);

        // If the instructor doesn't exist
        if (instructorUnderModeration == null) {
            throw new EntityDoesNotExistException(""Instructor Email ""
                    + instructorUnderModerationEmail + "" does not exist in "" + courseId
                    + ""."");
        }

        String moderatedQuestionId = getRequestParamValue(Const.ParamsNames.FEEDBACK_SESSION_MODERATED_QUESTION_ID);

        Assumption.assertPostParamNotNull(Const.ParamsNames.COURSE_ID, courseId);
        Assumption.assertPostParamNotNull(Const.ParamsNames.FEEDBACK_SESSION_NAME, feedbackSessionName);
        Assumption.assertPostParamNotNull(Const.ParamsNames.FEEDBACK_SESSION_MODERATED_PERSON,
                instructorUnderModerationEmail);

        FeedbackSubmissionEditPageData data = new FeedbackSubmissionEditPageData(account, student, sessionToken);

        data.bundle = logic.getFeedbackSessionQuestionsBundleForInstructor(
                feedbackSessionName,
                courseId,
                instructorUnderModeration.email);

        Assumption.assertNotNull(data.bundle);

        data.setSessionOpenForSubmission(true);
        data.setModeration(true);
        data.setHeaderHidden(true);
        data.setPreviewInstructor(instructorUnderModeration);
        data.setSubmitAction(Const.ActionURIs.INSTRUCTOR_EDIT_INSTRUCTOR_FEEDBACK_SAVE);

        if (moderatedQuestionId != null) {
            data.setModeratedQuestionId(moderatedQuestionId);
        }

        statusToAdmin = ""Moderating feedback session for instructor ("" + instructorUnderModeration.email + "")<br>""
                      + ""Session Name: "" + feedbackSessionName + ""<br>""
                      + ""Course ID: "" + courseId;

        data.bundle.hideUnmoderatableQuestions();
        data.init(courseId);

        return createShowPageResult(Const.ViewURIs.INSTRUCTOR_FEEDBACK_SUBMISSION_EDIT, data);
    }
}
"
InstructorEditInstructorFeedbackSaveAction.java,ui-controller,"package teammates.ui.controller;

import teammates.common.datatransfer.FeedbackParticipantType;
import teammates.common.datatransfer.FeedbackSessionQuestionsBundle;
import teammates.common.datatransfer.attributes.FeedbackQuestionAttributes;
import teammates.common.datatransfer.attributes.FeedbackSessionAttributes;
import teammates.common.datatransfer.attributes.InstructorAttributes;
import teammates.common.exception.EntityDoesNotExistException;
import teammates.common.exception.InvalidParametersException;
import teammates.common.exception.UnauthorizedAccessException;
import teammates.common.util.Assumption;
import teammates.common.util.Const;
import teammates.common.util.Logger;
import teammates.common.util.StatusMessage;
import teammates.common.util.StatusMessageColor;

/**
 * The {@code InstructorEditInstructorFeedbackSaveAction} class handles incoming requests to
 * save the data after moderating the instructor.
 */
public class InstructorEditInstructorFeedbackSaveAction extends FeedbackSubmissionEditSaveAction {

    private static final Logger log = Logger.getLogger();

    private InstructorAttributes moderatedInstructor;

    /**
     * Verifies if the user is allowed to carry out the action.
     */
    @Override
    protected void verifyAccessibleForSpecificUser() {
        InstructorAttributes instructor = logic.getInstructorForGoogleId(courseId, account.googleId);
        FeedbackSessionAttributes session = logic.getFeedbackSession(feedbackSessionName, courseId);

        gateKeeper.verifyAccessible(
                instructor, session, false, Const.ParamsNames.INSTRUCTOR_PERMISSION_MODIFY_SESSION);
    }

    /**
     * Retrieves any additional parameters from request and set them accordingly.
     */
    @Override
    protected void setAdditionalParameters() throws EntityDoesNotExistException {
        String moderatedInstructorEmail = getRequestParamValue(Const.ParamsNames.FEEDBACK_SESSION_MODERATED_PERSON);
        Assumption.assertPostParamNotNull(Const.ParamsNames.FEEDBACK_SESSION_MODERATED_PERSON, moderatedInstructorEmail);

        moderatedInstructor = logic.getInstructorForEmail(courseId, moderatedInstructorEmail);
        isSendSubmissionEmail = false;

        // If the instructor doesn't exist
        if (moderatedInstructor == null) {
            throw new EntityDoesNotExistException(""Instructor Email ""
                    + moderatedInstructorEmail + "" does not exist in "" + courseId
                    + ""."");
        }
    }

    /**
     * Checks if the instructor only submitted responses that he/she should be submitting when moderating.
     */
    @Override
    protected void checkAdditionalConstraints() {
        // check the instructor did not submit responses to questions that he/she should not be able when moderating

        InstructorAttributes instructor = logic.getInstructorForGoogleId(courseId, account.googleId);
        int numOfQuestionsToGet = data.bundle.questionResponseBundle.size();

        for (int questionIndx = 1; questionIndx <= numOfQuestionsToGet; questionIndx++) {
            String paramMapKey = Const.ParamsNames.FEEDBACK_QUESTION_ID + ""-"" + questionIndx;
            String questionId = getRequestParamValue(paramMapKey);

            if (questionId == null) {
                // we do not throw an error if the question was not present on the page for instructors to edit
                continue;
            }

            FeedbackQuestionAttributes questionAttributes = data.bundle.getQuestionAttributes(questionId);

            if (questionAttributes == null) {
                statusToUser.add(new StatusMessage(""The feedback session or questions may have changed ""
                                                       + ""while you were submitting. Please check your responses ""
                                                       + ""to make sure they are saved correctly."",
                                                   StatusMessageColor.WARNING));
                isError = true;
                log.warning(""Question not found in Feedback Session ["" + feedbackSessionName + ""] ""
                            + ""of Course ID ["" + courseId + ""].""
                            + ""(deleted or invalid id passed?) id: "" + questionId + "" index: "" + questionIndx);
                continue;
            }

            checkSessionQuestionAccessPermission(instructor, questionAttributes);
        }
    }

    /**
     * Checks the instructor's access to a particular question in the feedback session.
     * @param instructor the instructor to be checked
     * @param questionAttributes the question to be checked against
     */
    private void checkSessionQuestionAccessPermission(InstructorAttributes instructor,
                                                      FeedbackQuestionAttributes questionAttributes) {
        boolean isGiverVisibleToInstructors =
                questionAttributes.showGiverNameTo.contains(FeedbackParticipantType.INSTRUCTORS);
        boolean isRecipientVisibleToInstructors =
                questionAttributes.showRecipientNameTo.contains(FeedbackParticipantType.INSTRUCTORS);
        boolean isResponseVisibleToInstructors =
                questionAttributes.showResponsesTo.contains(FeedbackParticipantType.INSTRUCTORS);

        if (!isResponseVisibleToInstructors || !isGiverVisibleToInstructors || !isRecipientVisibleToInstructors) {
            isError = true;
            throw new UnauthorizedAccessException(
                    ""Feedback session ["" + feedbackSessionName
                    + ""] question ["" + questionAttributes.getId() + ""] is not accessible ""
                    + ""to instructor ["" + instructor.email + ""]"");
        }
    }

    @Override
    protected void appendRespondent() {
        try {
            logic.addInstructorRespondent(getUserEmailForCourse(), feedbackSessionName, courseId);
        } catch (InvalidParametersException | EntityDoesNotExistException e) {
            log.severe(""Failed to append instructor respondent. ""
                       + ""Feedback Session ["" + feedbackSessionName + ""] of Course ID ["" + courseId + ""]"");
        }
    }

    @Override
    protected void removeRespondent() {
        try {
            logic.deleteInstructorRespondent(getUserEmailForCourse(), feedbackSessionName, courseId);
        } catch (InvalidParametersException | EntityDoesNotExistException e) {
            log.severe(""Failed to append instructor respondent. ""
                       + ""Feedback Session ["" + feedbackSessionName + ""] of Course ID ["" + courseId + ""]"");
        }
    }

    /**
     * Retrieves the email of the user for the course.
     * @return the email of the user
     */
    @Override
    protected String getUserEmailForCourse() {
        return moderatedInstructor.email;
    }

    /**
     * Retrieves the user's team.
     * @return the name of the user's team
     */
    @Override
    protected String getUserTeamForCourse() {
        return Const.USER_TEAM_FOR_INSTRUCTOR;
    }

    /**
     * Retrieves the user's section for the course.
     * @return the name of the user's section
     */
    @Override
    protected String getUserSectionForCourse() {
        return Const.DEFAULT_SECTION;
    }

    /**
     * Gets data bundle for the course specified.
     * @param userEmailForCourse the email of the user
     * @return FeedbackSessionQuestionsBundle object
     */
    @Override
    protected FeedbackSessionQuestionsBundle getDataBundle(String userEmailForCourse)
            throws EntityDoesNotExistException {
        return logic.getFeedbackSessionQuestionsBundleForInstructor(
                feedbackSessionName, courseId, userEmailForCourse);
    }

    /**
     * Sets the message to log.
     */
    @Override
    protected void setStatusToAdmin() {
        statusToAdmin = ""Instructor moderated instructor session<br>""
                      + ""Instructor: "" + account.email + ""<br>""
                      + ""Moderated Instructor: "" + moderatedInstructor + ""<br>""
                      + ""Session Name: "" + feedbackSessionName + ""<br>""
                      + ""Course ID: "" + courseId;
    }

    /**
     * Checks if the session is still open. However, since the instructor is moderating the session,
     * they can moderate it anytime. Therefore, it will be true forever.
     * @return true
     */
    @Override
    protected boolean isSessionOpenForSpecificUser(FeedbackSessionAttributes session) {
        // Feedback session closing date does not matter. Instructors can moderate at any time
        return true;
    }

    /**
     * Creates the page to redirect.
     * @return RedirectResult object
     */
    @Override
    protected RedirectResult createSpecificRedirectResult() {
        RedirectResult result = createRedirectResult(Const.ActionURIs.INSTRUCTOR_EDIT_INSTRUCTOR_FEEDBACK_PAGE);

        result.responseParams.put(Const.ParamsNames.COURSE_ID, moderatedInstructor.courseId);
        result.responseParams.put(Const.ParamsNames.FEEDBACK_SESSION_NAME, feedbackSessionName);
        result.responseParams.put(Const.ParamsNames.FEEDBACK_SESSION_MODERATED_PERSON, moderatedInstructor.email);

        return result;
    }
}
"
InstructorEditStudentFeedbackPageAction.java,ui-controller,"package teammates.ui.controller;

import java.util.List;

import teammates.common.datatransfer.TeamDetailsBundle;
import teammates.common.datatransfer.attributes.StudentAttributes;
import teammates.common.exception.EntityDoesNotExistException;
import teammates.common.util.Assumption;
import teammates.common.util.Const;
import teammates.ui.pagedata.FeedbackSubmissionEditPageData;

public class InstructorEditStudentFeedbackPageAction extends Action {

    @Override
    protected ActionResult execute() throws EntityDoesNotExistException {
        String courseId = getRequestParamValue(Const.ParamsNames.COURSE_ID);
        String moderatedEntityIdentifier = getRequestParamValue(Const.ParamsNames.FEEDBACK_SESSION_MODERATED_PERSON);

        StudentAttributes studentUnderModeration = logic.getStudentForEmail(courseId, moderatedEntityIdentifier);

        if (studentUnderModeration == null) {
            List<TeamDetailsBundle> teams = logic.getTeamsForCourse(courseId);
            boolean isTeam = false;

            for (TeamDetailsBundle team : teams) {
                if (team.name.equals(moderatedEntityIdentifier)) {
                    isTeam = true;
                    studentUnderModeration = team.students.get(0);
                    break;
                }
            }

            if (!isTeam) {
                throw new EntityDoesNotExistException(""An entity with the identifier ""
                        + moderatedEntityIdentifier + "" does not exist in "" + courseId
                        + ""."");
            }
        }

        String feedbackSessionName = getRequestParamValue(Const.ParamsNames.FEEDBACK_SESSION_NAME);

        gateKeeper.verifyAccessible(logic.getInstructorForGoogleId(courseId, account.googleId),
                logic.getFeedbackSession(feedbackSessionName, courseId),
                false, studentUnderModeration.section,
                Const.ParamsNames.INSTRUCTOR_PERMISSION_MODIFY_SESSION_COMMENT_IN_SECTIONS);

        String moderatedQuestionId = getRequestParamValue(Const.ParamsNames.FEEDBACK_SESSION_MODERATED_QUESTION_ID);

        Assumption.assertPostParamNotNull(Const.ParamsNames.COURSE_ID, courseId);
        Assumption.assertPostParamNotNull(Const.ParamsNames.FEEDBACK_SESSION_NAME, feedbackSessionName);
        Assumption.assertPostParamNotNull(Const.ParamsNames.FEEDBACK_SESSION_MODERATED_PERSON, moderatedEntityIdentifier);

        FeedbackSubmissionEditPageData data = new FeedbackSubmissionEditPageData(account, student, sessionToken);

        data.bundle = logic.getFeedbackSessionQuestionsBundleForStudent(
                feedbackSessionName, courseId, studentUnderModeration.email);

        Assumption.assertNotNull(data.bundle);

        data.setSessionOpenForSubmission(true);
        data.setModeration(true);
        data.setHeaderHidden(true);
        data.setStudentToViewPageAs(studentUnderModeration);
        data.setSubmitAction(Const.ActionURIs.INSTRUCTOR_EDIT_STUDENT_FEEDBACK_SAVE);

        if (moderatedQuestionId != null) {
            data.setModeratedQuestionId(moderatedQuestionId);
        }

        statusToAdmin = ""Moderating feedback session for student ("" + studentUnderModeration.email + "")<br>""
                + ""Session Name: "" + feedbackSessionName + ""<br>""
                + ""Course ID: "" + courseId;

        data.bundle.hideUnmoderatableQuestions();
        data.init(courseId);

        return createShowPageResult(Const.ViewURIs.STUDENT_FEEDBACK_SUBMISSION_EDIT, data);
    }
}
"
InstructorEditStudentFeedbackSaveAction.java,ui-controller,"package teammates.ui.controller;

import teammates.common.datatransfer.FeedbackParticipantType;
import teammates.common.datatransfer.FeedbackSessionQuestionsBundle;
import teammates.common.datatransfer.attributes.FeedbackQuestionAttributes;
import teammates.common.datatransfer.attributes.FeedbackSessionAttributes;
import teammates.common.datatransfer.attributes.InstructorAttributes;
import teammates.common.datatransfer.attributes.StudentAttributes;
import teammates.common.exception.EntityDoesNotExistException;
import teammates.common.exception.InvalidParametersException;
import teammates.common.exception.UnauthorizedAccessException;
import teammates.common.util.Assumption;
import teammates.common.util.Const;
import teammates.common.util.Logger;
import teammates.common.util.SanitizationHelper;
import teammates.common.util.StatusMessage;
import teammates.common.util.StatusMessageColor;

public class InstructorEditStudentFeedbackSaveAction extends FeedbackSubmissionEditSaveAction {

    private static final Logger log = Logger.getLogger();

    private StudentAttributes moderatedStudent;

    @Override
    protected void verifyAccessibleForSpecificUser() {
        InstructorAttributes instructor = logic.getInstructorForGoogleId(courseId, account.googleId);
        FeedbackSessionAttributes session = logic.getFeedbackSession(feedbackSessionName, courseId);

        gateKeeper.verifyAccessible(instructor, session, false, moderatedStudent.section,
                Const.ParamsNames.INSTRUCTOR_PERMISSION_MODIFY_SESSION_COMMENT_IN_SECTIONS);
    }

    @Override
    protected void setAdditionalParameters() {
        String moderatedStudentEmail = getRequestParamValue(Const.ParamsNames.FEEDBACK_SESSION_MODERATED_PERSON);
        Assumption.assertPostParamNotNull(Const.ParamsNames.FEEDBACK_SESSION_MODERATED_PERSON, moderatedStudentEmail);

        moderatedStudent = logic.getStudentForEmail(courseId, moderatedStudentEmail);
        isSendSubmissionEmail = false;
    }

    @Override
    protected void checkAdditionalConstraints() {
        // check the instructor did not submit responses to questions that he/she should not be able
        // to view during moderation

        InstructorAttributes instructor = logic.getInstructorForGoogleId(courseId, account.googleId);

        int numOfQuestionsToGet = data.bundle.questionResponseBundle.size();

        for (int questionIndx = 1; questionIndx <= numOfQuestionsToGet; questionIndx++) {
            String questionId = getRequestParamValue(
                    Const.ParamsNames.FEEDBACK_QUESTION_ID + ""-"" + questionIndx);

            if (questionId == null) {
                // we do not throw an error if the question was not present on the page for instructors to edit
                continue;
            }

            FeedbackQuestionAttributes questionAttributes = data.bundle.getQuestionAttributes(questionId);

            if (questionAttributes == null) {
                statusToUser.add(new StatusMessage(""The feedback session or questions may have changed ""
                                                       + ""while you were submitting. Please check your responses ""
                                                       + ""to make sure they are saved correctly."",
                                                   StatusMessageColor.WARNING));
                isError = true;
                log.warning(""Question not found. (deleted or invalid id passed?) id: ""
                            + questionId + "" index: "" + questionIndx);
                continue;
            }

            boolean isGiverVisibleToInstructors =
                    questionAttributes.showGiverNameTo.contains(FeedbackParticipantType.INSTRUCTORS);
            boolean isRecipientVisibleToInstructors =
                    questionAttributes.showRecipientNameTo.contains(FeedbackParticipantType.INSTRUCTORS);
            boolean isResponseVisibleToInstructors =
                    questionAttributes.showResponsesTo.contains(FeedbackParticipantType.INSTRUCTORS);

            if (!isResponseVisibleToInstructors || !isGiverVisibleToInstructors || !isRecipientVisibleToInstructors) {
                isError = true;
                throw new UnauthorizedAccessException(
                        ""Feedback session ["" + feedbackSessionName
                        + ""] question ["" + questionAttributes.getId() + ""] is not accessible ""
                        + ""to instructor ["" + instructor.email + ""]"");
            }
        }
    }

    @Override
    protected void appendRespondent() {
        try {
            logic.addStudentRespondent(getUserEmailForCourse(), feedbackSessionName, courseId);
        } catch (InvalidParametersException | EntityDoesNotExistException e) {
            log.severe(""Fail to append student respondent"");
        }
    }

    @Override
    protected void removeRespondent() {
        try {
            logic.deleteStudentRespondent(getUserEmailForCourse(), feedbackSessionName, courseId);
        } catch (InvalidParametersException | EntityDoesNotExistException e) {
            log.severe(""Fail to remove student respondent"");
        }
    }

    @Override
    protected String getUserEmailForCourse() {
        return moderatedStudent.email;
    }

    @Override
    protected String getUserTeamForCourse() {
        return SanitizationHelper.desanitizeFromHtml(moderatedStudent.team);
    }

    @Override
    protected String getUserSectionForCourse() {
        return moderatedStudent.section;
    }

    @Override
    protected FeedbackSessionQuestionsBundle getDataBundle(String userEmailForCourse)
            throws EntityDoesNotExistException {
        return logic.getFeedbackSessionQuestionsBundleForStudent(
                feedbackSessionName, courseId, userEmailForCourse);
    }

    @Override
    protected void setStatusToAdmin() {
        statusToAdmin = ""Instructor moderated student session<br>""
                      + ""Instructor: "" + account.email + ""<br>""
                      + ""Moderated Student: "" + moderatedStudent + ""<br>""
                      + ""Session Name: "" + feedbackSessionName + ""<br>""
                      + ""Course ID: "" + courseId;
    }

    @Override
    protected boolean isSessionOpenForSpecificUser(FeedbackSessionAttributes session) {
        // Feedback session closing date does not matter. Instructors can moderate at any time
        return true;
    }

    @Override
    protected RedirectResult createSpecificRedirectResult() {
        RedirectResult result = createRedirectResult(Const.ActionURIs.INSTRUCTOR_EDIT_STUDENT_FEEDBACK_PAGE);

        result.responseParams.put(Const.ParamsNames.COURSE_ID, moderatedStudent.course);
        result.responseParams.put(Const.ParamsNames.FEEDBACK_SESSION_NAME, feedbackSessionName);
        result.responseParams.put(Const.ParamsNames.FEEDBACK_SESSION_MODERATED_PERSON, moderatedStudent.email);

        return result;
    }
}
"
InstructorFeedbackAbstractAction.java,ui-controller,"package teammates.ui.controller;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import com.google.appengine.api.datastore.Text;

import teammates.common.datatransfer.FeedbackSessionType;
import teammates.common.datatransfer.attributes.CourseAttributes;
import teammates.common.datatransfer.attributes.FeedbackSessionAttributes;
import teammates.common.datatransfer.attributes.InstructorAttributes;
import teammates.common.util.Const;
import teammates.common.util.EmailType;
import teammates.common.util.Logger;
import teammates.common.util.SanitizationHelper;
import teammates.common.util.TimeHelper;

public abstract class InstructorFeedbackAbstractAction extends Action {

    private static final Logger log = Logger.getLogger();

    /**
     * Creates a feedback session attributes object from the request parameters.
     * @param isCreatingNewSession true if creating a new session; false if editing an existing session.
     * @return feedback session attributes object.
     */
    protected FeedbackSessionAttributes extractFeedbackSessionData(boolean isCreatingNewSession) {
        // TODO: When creating a new session, assert parameters are not null.
        // Not necessary when editing an existing session as null values do not affect data integrity.

        FeedbackSessionAttributes attributes = new FeedbackSessionAttributes();
        attributes.setCourseId(getRequestParamValue(Const.ParamsNames.COURSE_ID));

        String title = getRequestParamValue(Const.ParamsNames.FEEDBACK_SESSION_NAME);
        if (isCreatingNewSession) {
            title = SanitizationHelper.sanitizeTitle(title);
        }
        attributes.setFeedbackSessionName(title);
        attributes.setCreatorEmail(getRequestParamValue(Const.ParamsNames.FEEDBACK_SESSION_CREATOR));

        attributes.setStartTime(TimeHelper.combineDateTime(
                getRequestParamValue(Const.ParamsNames.FEEDBACK_SESSION_STARTDATE),
                getRequestParamValue(Const.ParamsNames.FEEDBACK_SESSION_STARTTIME)));
        attributes.setEndTime(TimeHelper.combineDateTime(
                getRequestParamValue(Const.ParamsNames.FEEDBACK_SESSION_ENDDATE),
                getRequestParamValue(Const.ParamsNames.FEEDBACK_SESSION_ENDTIME)));
        String paramTimeZone = getRequestParamValue(Const.ParamsNames.FEEDBACK_SESSION_TIMEZONE);
        if (paramTimeZone != null) {
            try {
                attributes.setTimeZone(Double.parseDouble(paramTimeZone));
            } catch (NumberFormatException nfe) {
                log.warning(""Failed to parse time zone parameter: "" + paramTimeZone);
            }
        }

        String paramGracePeriod = getRequestParamValue(Const.ParamsNames.FEEDBACK_SESSION_GRACEPERIOD);
        try {
            attributes.setGracePeriod(Integer.parseInt(paramGracePeriod));
        } catch (NumberFormatException nfe) {
            log.warning(""Failed to parse graced period parameter: "" + paramGracePeriod);
        }

        if (isCreatingNewSession) {
            attributes.setCreatedTime(new Date());
            attributes.setSentOpenEmail(false);
            attributes.setSentPublishedEmail(false);
        }

        attributes.setFeedbackSessionType(FeedbackSessionType.STANDARD);
        attributes.setInstructions(new Text(getRequestParamValue(Const.ParamsNames.FEEDBACK_SESSION_INSTRUCTIONS)));

        String type = getRequestParamValue(Const.ParamsNames.FEEDBACK_SESSION_RESULTSVISIBLEBUTTON);
        switch (type) {
        case Const.INSTRUCTOR_FEEDBACK_RESULTS_VISIBLE_TIME_CUSTOM:
            attributes.setResultsVisibleFromTime(TimeHelper.combineDateTime(
                        getRequestParamValue(Const.ParamsNames.FEEDBACK_SESSION_PUBLISHDATE),
                        getRequestParamValue(Const.ParamsNames.FEEDBACK_SESSION_PUBLISHTIME)));
            break;
        case Const.INSTRUCTOR_FEEDBACK_RESULTS_VISIBLE_TIME_ATVISIBLE:
            attributes.setResultsVisibleFromTime(Const.TIME_REPRESENTS_FOLLOW_VISIBLE);
            break;
        case Const.INSTRUCTOR_FEEDBACK_RESULTS_VISIBLE_TIME_LATER:
            attributes.setResultsVisibleFromTime(Const.TIME_REPRESENTS_LATER);
            break;
        case Const.INSTRUCTOR_FEEDBACK_RESULTS_VISIBLE_TIME_NEVER:
            attributes.setResultsVisibleFromTime(Const.TIME_REPRESENTS_NEVER);
            break;
        default:
            log.severe(""Invalid sessionVisibleFrom setting "" + attributes.getIdentificationString());
            break;
        }

        // Handle session visible after results visible to avoid having a
        // results visible date when session is private (session not visible)
        type = getRequestParamValue(Const.ParamsNames.FEEDBACK_SESSION_SESSIONVISIBLEBUTTON);
        switch (type) {
        case Const.INSTRUCTOR_FEEDBACK_SESSION_VISIBLE_TIME_CUSTOM:
            attributes.setSessionVisibleFromTime(TimeHelper.combineDateTime(
                        getRequestParamValue(Const.ParamsNames.FEEDBACK_SESSION_VISIBLEDATE),
                        getRequestParamValue(Const.ParamsNames.FEEDBACK_SESSION_VISIBLETIME)));
            break;
        case Const.INSTRUCTOR_FEEDBACK_SESSION_VISIBLE_TIME_ATOPEN:
            attributes.setSessionVisibleFromTime(Const.TIME_REPRESENTS_FOLLOW_OPENING);
            break;
        case Const.INSTRUCTOR_FEEDBACK_SESSION_VISIBLE_TIME_NEVER:
            attributes.setSessionVisibleFromTime(Const.TIME_REPRESENTS_NEVER);
            // Overwrite if private
            attributes.setResultsVisibleFromTime(Const.TIME_REPRESENTS_NEVER);
            attributes.setFeedbackSessionType(FeedbackSessionType.PRIVATE);
            if (!isCreatingNewSession) {
                attributes.setEndTime(null);
            }
            break;
        default:
            log.severe(""Invalid sessionVisibleFrom setting "" + attributes.getIdentificationString());
            break;
        }

        String[] sendReminderEmailsArray = getRequestParamValues(Const.ParamsNames.FEEDBACK_SESSION_SENDREMINDEREMAIL);
        List<String> sendReminderEmailsList = sendReminderEmailsArray == null ? new ArrayList<String>()
                : Arrays.asList(sendReminderEmailsArray);
        attributes.setOpeningEmailEnabled(sendReminderEmailsList.contains(EmailType.FEEDBACK_OPENING.toString()));
        attributes.setClosingEmailEnabled(sendReminderEmailsList.contains(EmailType.FEEDBACK_CLOSING.toString()));
        attributes.setPublishedEmailEnabled(sendReminderEmailsList.contains(EmailType.FEEDBACK_PUBLISHED.toString()));

        return attributes;
    }

    protected List<FeedbackSessionAttributes> loadFeedbackSessionsList(
            List<InstructorAttributes> instructorList) {
        return logic.getFeedbackSessionsListForInstructor(instructorList);
    }

    protected List<CourseAttributes> loadCoursesList(List<InstructorAttributes> instructorList) {

        List<CourseAttributes> courses = logic.getCoursesForInstructor(instructorList);

        Collections.sort(courses, new Comparator<CourseAttributes>() {
            @Override
            public int compare(CourseAttributes c1, CourseAttributes c2) {
                return c1.getId().compareTo(c2.getId());
            }
        });

        return courses;
    }

    /**
     * Gets a Map with courseId as key, and InstructorAttributes as value.
     */
    protected Map<String, InstructorAttributes> loadCourseInstructorMap(boolean omitArchived) {
        HashMap<String, InstructorAttributes> courseInstructorMap = new HashMap<>();
        List<InstructorAttributes> instructors = logic.getInstructorsForGoogleId(account.googleId, omitArchived);
        for (InstructorAttributes instructor : instructors) {
            courseInstructorMap.put(instructor.courseId, instructor);
        }
        return courseInstructorMap;
    }

}
"
InstructorFeedbackAddAction.java,ui-controller,"package teammates.ui.controller;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

import com.google.gson.reflect.TypeToken;

import teammates.common.datatransfer.attributes.CourseAttributes;
import teammates.common.datatransfer.attributes.FeedbackQuestionAttributes;
import teammates.common.datatransfer.attributes.FeedbackSessionAttributes;
import teammates.common.datatransfer.attributes.InstructorAttributes;
import teammates.common.exception.EntityAlreadyExistsException;
import teammates.common.exception.InvalidParametersException;
import teammates.common.exception.TeammatesException;
import teammates.common.util.Assumption;
import teammates.common.util.Const;
import teammates.common.util.JsonUtils;
import teammates.common.util.Logger;
import teammates.common.util.StatusMessage;
import teammates.common.util.StatusMessageColor;
import teammates.common.util.Templates;
import teammates.common.util.Templates.FeedbackSessionTemplates;
import teammates.ui.pagedata.InstructorFeedbackSessionsPageData;

public class InstructorFeedbackAddAction extends InstructorFeedbackAbstractAction {

    private static final Logger log = Logger.getLogger();

    @Override
    protected ActionResult execute() {

        String courseId = getRequestParamValue(Const.ParamsNames.COURSE_ID);

        Assumption.assertPostParamNotNull(Const.ParamsNames.COURSE_ID, courseId);
        Assumption.assertNotEmpty(courseId);

        InstructorAttributes instructor = logic.getInstructorForGoogleId(courseId, account.googleId);

        gateKeeper.verifyAccessible(
                instructor, logic.getCourse(courseId), Const.ParamsNames.INSTRUCTOR_PERMISSION_MODIFY_SESSION);

        FeedbackSessionAttributes fs = extractFeedbackSessionData(true);

        // Set creator email as instructors' email
        fs.setCreatorEmail(instructor.email);

        // A session opening reminder email is always sent as students
        // without accounts need to receive the email to be able to respond
        fs.setOpeningEmailEnabled(true);

        String feedbackSessionType = getRequestParamValue(Const.ParamsNames.FEEDBACK_SESSION_TYPE);

        InstructorFeedbackSessionsPageData data = new InstructorFeedbackSessionsPageData(account, sessionToken);
        try {
            logic.createFeedbackSession(fs);

            try {
                createTemplateFeedbackQuestions(fs.getCourseId(), fs.getFeedbackSessionName(),
                                                fs.getCreatorEmail(), feedbackSessionType);
            } catch (InvalidParametersException e) {
                // Failed to create feedback questions for specified template/feedback session type.
                //TODO: let the user know an error has occurred? delete the feedback session?
                log.severe(TeammatesException.toStringWithStackTrace(e));
            }

            statusToUser.add(new StatusMessage(Const.StatusMessages.FEEDBACK_SESSION_ADDED, StatusMessageColor.SUCCESS));
            statusToAdmin =
                    ""New Feedback Session <span class=\""bold\"">("" + fs.getFeedbackSessionName() + "")</span> for Course ""
                    + ""<span class=\""bold\"">["" + fs.getCourseId() + ""]</span> created.<br>""
                    + ""<span class=\""bold\"">From:</span> "" + fs.getStartTime()
                    + ""<span class=\""bold\""> to</span> "" + fs.getEndTime() + ""<br>""
                    + ""<span class=\""bold\"">Session visible from:</span> "" + fs.getSessionVisibleFromTime() + ""<br>""
                    + ""<span class=\""bold\"">Results visible from:</span> "" + fs.getResultsVisibleFromTime() + ""<br><br>""
                    + ""<span class=\""bold\"">Instructions:</span> "" + fs.getInstructions();

            //TODO: add a condition to include the status due to inconsistency problem of database
            //      (similar to the one below)
            return createRedirectResult(
                    data.getInstructorFeedbackEditLink(
                            fs.getCourseId(), fs.getFeedbackSessionName()));

        } catch (EntityAlreadyExistsException e) {
            setStatusForException(e, Const.StatusMessages.FEEDBACK_SESSION_EXISTS);
        } catch (InvalidParametersException e) {
            setStatusForException(e);
        }
        // isError == true if an exception occurred above

        boolean shouldOmitArchived = true;
        Map<String, InstructorAttributes> instructors = loadCourseInstructorMap(shouldOmitArchived);
        List<InstructorAttributes> instructorList = new ArrayList<>(instructors.values());
        List<CourseAttributes> courses = loadCoursesList(instructorList);
        List<FeedbackSessionAttributes> feedbackSessions = loadFeedbackSessionsList(instructorList);
        FeedbackSessionAttributes.sortFeedbackSessionsByCreationTimeDescending(feedbackSessions);

        if (feedbackSessions.isEmpty()) {
            statusToUser.add(new StatusMessage(Const.StatusMessages.FEEDBACK_SESSION_ADD_DB_INCONSISTENCY,
                                               StatusMessageColor.WARNING));
        }

        data.initWithoutHighlightedRow(courses, courseId, feedbackSessions, instructors, fs,
                                       feedbackSessionType);

        return createShowPageResult(Const.ViewURIs.INSTRUCTOR_FEEDBACK_SESSIONS, data);
    }

    private void createTemplateFeedbackQuestions(String courseId, String feedbackSessionName,
            String creatorEmail, String feedbackSessionType) throws InvalidParametersException {
        if (feedbackSessionType == null) {
            return;
        }

        List<FeedbackQuestionAttributes> questions =
                getFeedbackSessionTemplateQuestions(feedbackSessionType, courseId, feedbackSessionName, creatorEmail);

        int questionNumber = 1;
        for (FeedbackQuestionAttributes fqa : questions) {
            logic.createFeedbackQuestionForTemplate(fqa, questionNumber);
            questionNumber++;
        }
    }

    /**
     * Gets the list of questions for the specified feedback session template.
     */
    private static List<FeedbackQuestionAttributes> getFeedbackSessionTemplateQuestions(
            String templateType, String courseId, String feedbackSessionName, String creatorEmail) {
        Assumption.assertNotNull(templateType);

        if (""TEAMEVALUATION"".equals(templateType)) {
            String jsonString = Templates.populateTemplate(FeedbackSessionTemplates.TEAM_EVALUATION,
                    ""${courseId}"", courseId,
                    ""${feedbackSessionName}"", feedbackSessionName,
                    ""${creatorEmail}"", creatorEmail);

            Type listType = new TypeToken<ArrayList<FeedbackQuestionAttributes>>(){}.getType();
            return JsonUtils.fromJson(jsonString, listType);
        }

        return new ArrayList<>();
    }
}
"
InstructorFeedbackCopyAction.java,ui-controller,"package teammates.ui.controller;

import teammates.common.datatransfer.attributes.FeedbackSessionAttributes;
import teammates.common.datatransfer.attributes.InstructorAttributes;
import teammates.common.exception.EntityAlreadyExistsException;
import teammates.common.exception.EntityDoesNotExistException;
import teammates.common.exception.InvalidParametersException;
import teammates.common.util.Assumption;
import teammates.common.util.Const;
import teammates.common.util.StatusMessage;
import teammates.common.util.StatusMessageColor;
import teammates.ui.pagedata.PageData;

public class InstructorFeedbackCopyAction extends Action {

    @Override
    protected ActionResult execute() throws EntityDoesNotExistException {

        String copiedFeedbackSessionName = getRequestParamValue(Const.ParamsNames.COPIED_FEEDBACK_SESSION_NAME);
        String copiedCourseId = getRequestParamValue(Const.ParamsNames.COPIED_COURSE_ID);
        String feedbackSessionName = getRequestParamValue(Const.ParamsNames.FEEDBACK_SESSION_NAME);
        String courseId = getRequestParamValue(Const.ParamsNames.COURSE_ID);

        Assumption.assertPostParamNotNull(Const.ParamsNames.COPIED_FEEDBACK_SESSION_NAME, copiedFeedbackSessionName);
        Assumption.assertPostParamNotNull(Const.ParamsNames.COPIED_COURSE_ID, copiedCourseId);
        Assumption.assertPostParamNotNull(Const.ParamsNames.COURSE_ID, courseId);
        Assumption.assertPostParamNotNull(Const.ParamsNames.FEEDBACK_SESSION_NAME, feedbackSessionName);

        InstructorAttributes instructor = logic.getInstructorForGoogleId(courseId, account.googleId);

        gateKeeper.verifyAccessible(
                instructor, logic.getCourse(courseId), Const.ParamsNames.INSTRUCTOR_PERMISSION_MODIFY_SESSION);

        try {

            FeedbackSessionAttributes fs = logic.copyFeedbackSession(copiedFeedbackSessionName.trim(),
                                                                     copiedCourseId,
                                                                     feedbackSessionName,
                                                                     courseId,
                                                                     instructor.email);

            statusToUser.add(new StatusMessage(Const.StatusMessages.FEEDBACK_SESSION_COPIED, StatusMessageColor.SUCCESS));
            statusToAdmin =
                    ""New Feedback Session <span class=\""bold\"">("" + fs.getFeedbackSessionName() + "")</span> ""
                    + ""for Course <span class=\""bold\"">["" + fs.getCourseId() + ""]</span> created.<br>""
                    + ""<span class=\""bold\"">From:</span> "" + fs.getStartTime()
                    + ""<span class=\""bold\""> to</span> "" + fs.getEndTime() + ""<br>""
                    + ""<span class=\""bold\"">Session visible from:</span> "" + fs.getSessionVisibleFromTime() + ""<br>""
                    + ""<span class=\""bold\"">Results visible from:</span> "" + fs.getResultsVisibleFromTime() + ""<br><br>""
                    + ""<span class=\""bold\"">Instructions:</span> "" + fs.getInstructions();

            //TODO: add a condition to include the status due to inconsistency problem of database
            //      (similar to the one below)
            return createRedirectResult(
                    new PageData(account, sessionToken).getInstructorFeedbackEditLink(
                            fs.getCourseId(), fs.getFeedbackSessionName()));

        } catch (EntityAlreadyExistsException e) {
            setStatusForException(e, Const.StatusMessages.FEEDBACK_SESSION_EXISTS);
        } catch (InvalidParametersException e) {
            setStatusForException(e);
        }

        RedirectResult redirectResult = createRedirectResult(Const.ActionURIs.INSTRUCTOR_FEEDBACK_SESSIONS_PAGE);
        redirectResult.responseParams.put(Const.ParamsNames.USER_ID, account.googleId);
        return redirectResult;
    }

}
"
InstructorFeedbackDeleteAction.java,ui-controller,"package teammates.ui.controller;

import teammates.common.util.Assumption;
import teammates.common.util.Const;
import teammates.common.util.StatusMessage;
import teammates.common.util.StatusMessageColor;

public class InstructorFeedbackDeleteAction extends Action {

    @Override
    protected ActionResult execute() {

        String courseId = getRequestParamValue(Const.ParamsNames.COURSE_ID);
        String feedbackSessionName = getRequestParamValue(Const.ParamsNames.FEEDBACK_SESSION_NAME);
        String nextUrl = getRequestParamValue(Const.ParamsNames.NEXT_URL);

        Assumption.assertPostParamNotNull(Const.ParamsNames.COURSE_ID, courseId);
        Assumption.assertPostParamNotNull(Const.ParamsNames.FEEDBACK_SESSION_NAME, feedbackSessionName);

        if (nextUrl == null) {
            nextUrl = Const.ActionURIs.INSTRUCTOR_FEEDBACK_SESSIONS_PAGE;
        }

        gateKeeper.verifyAccessible(
                logic.getInstructorForGoogleId(courseId, account.googleId),
                logic.getFeedbackSession(feedbackSessionName, courseId),
                false,
                Const.ParamsNames.INSTRUCTOR_PERMISSION_MODIFY_SESSION);

        logic.deleteFeedbackSession(feedbackSessionName, courseId);
        statusToUser.add(new StatusMessage(Const.StatusMessages.FEEDBACK_SESSION_DELETED, StatusMessageColor.SUCCESS));
        statusToAdmin = ""Feedback Session <span class=\""bold\"">["" + feedbackSessionName + ""]</span> ""
                        + ""from Course: <span class=\""bold\"">["" + courseId + "" deleted."";

        return createRedirectResult(nextUrl);
    }

}
"
InstructorFeedbackEditCopyAction.java,ui-controller,"package teammates.ui.controller;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import teammates.common.datatransfer.attributes.FeedbackSessionAttributes;
import teammates.common.datatransfer.attributes.InstructorAttributes;
import teammates.common.exception.EntityAlreadyExistsException;
import teammates.common.exception.EntityDoesNotExistException;
import teammates.common.exception.InvalidParametersException;
import teammates.common.util.Assumption;
import teammates.common.util.Config;
import teammates.common.util.Const;
import teammates.common.util.StatusMessage;
import teammates.common.util.StatusMessageColor;
import teammates.common.util.StringHelper;
import teammates.ui.pagedata.InstructorFeedbackEditCopyData;

public class InstructorFeedbackEditCopyAction extends Action {

    @Override
    protected ActionResult execute() throws EntityDoesNotExistException {
        String newFeedbackSessionName = getRequestParamValue(Const.ParamsNames.COPIED_FEEDBACK_SESSION_NAME);
        String[] coursesIdToCopyTo = getRequestParamValues(Const.ParamsNames.COPIED_COURSES_ID);
        String originalFeedbackSessionName = getRequestParamValue(Const.ParamsNames.FEEDBACK_SESSION_NAME);
        String originalCourseId = getRequestParamValue(Const.ParamsNames.COURSE_ID);
        String nextUrl = getRequestParamValue(Const.ParamsNames.NEXT_URL);

        Assumption.assertPostParamNotNull(Const.ParamsNames.COURSE_ID, originalCourseId);
        Assumption.assertPostParamNotNull(Const.ParamsNames.FEEDBACK_SESSION_NAME, originalFeedbackSessionName);
        Assumption.assertPostParamNotNull(Const.ParamsNames.COPIED_FEEDBACK_SESSION_NAME, newFeedbackSessionName);

        if (nextUrl == null) {
            nextUrl = Const.ActionURIs.INSTRUCTOR_FEEDBACK_SESSIONS_PAGE;
        }

        if (coursesIdToCopyTo == null || coursesIdToCopyTo.length == 0) {
            return createAjaxResultWithErrorMessage(Const.StatusMessages.FEEDBACK_SESSION_COPY_NONESELECTED);
        }

        InstructorAttributes instructor = logic.getInstructorForGoogleId(originalCourseId, account.googleId);
        FeedbackSessionAttributes fsa = logic.getFeedbackSession(originalFeedbackSessionName, originalCourseId);

        gateKeeper.verifyAccessible(instructor, logic.getCourse(originalCourseId),
                                    Const.ParamsNames.INSTRUCTOR_PERMISSION_MODIFY_SESSION);
        gateKeeper.verifyAccessible(instructor, fsa, false);

        try {
            // Check if there are no conflicting feedback sessions in all the courses
            List<String> conflictCourses =
                    filterConflictsInCourses(newFeedbackSessionName, coursesIdToCopyTo);

            if (!conflictCourses.isEmpty()) {
                String commaSeparatedListOfCourses = StringHelper.toString(conflictCourses, "","");
                String errorToUser = String.format(Const.StatusMessages.FEEDBACK_SESSION_COPY_ALREADYEXISTS,
                                                   newFeedbackSessionName,
                                                   commaSeparatedListOfCourses);

                return createAjaxResultWithErrorMessage(errorToUser);
            }

            FeedbackSessionAttributes fs = null;
            // Copy the feedback sessions
            // TODO: consider doing this as a batch insert
            for (String courseIdToCopyTo : coursesIdToCopyTo) {
                InstructorAttributes instructorForCourse =
                        logic.getInstructorForGoogleId(courseIdToCopyTo, account.googleId);
                gateKeeper.verifyAccessible(instructorForCourse, logic.getCourse(courseIdToCopyTo),
                                            Const.ParamsNames.INSTRUCTOR_PERMISSION_MODIFY_SESSION);

                fs = logic.copyFeedbackSession(newFeedbackSessionName, courseIdToCopyTo,
                        originalFeedbackSessionName, originalCourseId, instructor.email);
            }

            List<String> courses = Arrays.asList(coursesIdToCopyTo);
            String commaSeparatedListOfCourses = StringHelper.toString(courses, "","");

            statusToUser.add(new StatusMessage(Const.StatusMessages.FEEDBACK_SESSION_COPIED, StatusMessageColor.SUCCESS));
            statusToAdmin =
                    ""Copying to multiple feedback sessions.<br>""
                    + ""New Feedback Session <span class=\""bold\"">("" + fs.getFeedbackSessionName() + "")</span> ""
                    + ""for Courses: <br>"" + commaSeparatedListOfCourses + ""<br>""
                    + ""<span class=\""bold\"">From:</span> "" + fs.getStartTime()
                    + ""<span class=\""bold\""> to</span> "" + fs.getEndTime() + ""<br>""
                    + ""<span class=\""bold\"">Session visible from:</span> "" + fs.getSessionVisibleFromTime() + ""<br>""
                    + ""<span class=\""bold\"">Results visible from:</span> "" + fs.getResultsVisibleFromTime() + ""<br><br>""
                    + ""<span class=\""bold\"">Instructions:</span> "" + fs.getInstructions() + ""<br>""
                    + ""Copied from <span class=\""bold\"">("" + originalFeedbackSessionName + "")</span> for Course ""
                    + ""<span class=\""bold\"">["" + originalCourseId + ""]</span> created.<br>"";

            // Return with redirection url (handled in javascript) to the sessions page after copying,
            // so that the instructor can see the new feedback sessions
            return createAjaxResultWithoutClearingStatusMessage(
                       new InstructorFeedbackEditCopyData(account, sessionToken,
                                                          Config.getAppUrl(nextUrl)
                                                                .withParam(Const.ParamsNames.ERROR,
                                                                           Boolean.FALSE.toString())
                                                                .withParam(Const.ParamsNames.USER_ID,
                                                                           account.googleId)
                                                          ));

        } catch (EntityAlreadyExistsException e) {
            // If conflicts are checked above, this will only occur via race condition
            setStatusForException(e, Const.StatusMessages.FEEDBACK_SESSION_EXISTS);
            return createAjaxResultWithErrorMessage(Const.StatusMessages.FEEDBACK_SESSION_EXISTS);
        } catch (InvalidParametersException e) {
            setStatusForException(e);
            return createAjaxResultWithErrorMessage(e.getMessage());
        }

    }

    /**
     * Given an array of Course Ids, return only the Ids of Courses which has
     * an existing feedback session with a name conflicting with feedbackSessionName.
     */
    private List<String> filterConflictsInCourses(String feedbackSessionName, String[] coursesIdToCopyTo) {
        List<String> courses = new ArrayList<>();

        for (String courseIdToCopy : coursesIdToCopyTo) {
            FeedbackSessionAttributes existingFs =
                    logic.getFeedbackSession(feedbackSessionName, courseIdToCopy);
            boolean hasExistingFs = existingFs != null;

            if (hasExistingFs) {
                courses.add(existingFs.getCourseId());
            }
        }

        return courses;
    }

    private AjaxResult createAjaxResultWithErrorMessage(String errorToUser) {
        isError = true;
        return createAjaxResult(new InstructorFeedbackEditCopyData(account, sessionToken, errorToUser));
    }
}
"
InstructorFeedbackEditCopyPageAction.java,ui-controller,"package teammates.ui.controller;

import java.util.ArrayList;
import java.util.List;

import teammates.common.datatransfer.attributes.CourseAttributes;
import teammates.common.datatransfer.attributes.InstructorAttributes;
import teammates.common.util.Assumption;
import teammates.common.util.Const;
import teammates.ui.pagedata.InstructorFeedbackEditCopyPageData;

public class InstructorFeedbackEditCopyPageAction extends Action {

    @Override
    protected ActionResult execute() {
        String courseId = getRequestParamValue(Const.ParamsNames.COURSE_ID);
        Assumption.assertPostParamNotNull(Const.ParamsNames.COURSE_ID, courseId);

        String feedbackSessionName = getRequestParamValue(Const.ParamsNames.FEEDBACK_SESSION_NAME);
        Assumption.assertPostParamNotNull(Const.ParamsNames.FEEDBACK_SESSION_NAME, feedbackSessionName);

        List<InstructorAttributes> instructors = logic.getInstructorsForGoogleId(account.googleId);
        Assumption.assertNotNull(instructors);

        List<CourseAttributes> allCourses = logic.getCoursesForInstructor(account.googleId);

        List<CourseAttributes> coursesToAddToData = new ArrayList<>();

        // Only add courses to data if the course is not archived and instructor has sufficient permissions
        for (CourseAttributes course : allCourses) {
            InstructorAttributes instructor = logic.getInstructorForGoogleId(course.getId(), account.googleId);

            boolean isAllowedToMakeSession =
                    instructor.isAllowedForPrivilege(Const.ParamsNames.INSTRUCTOR_PERMISSION_MODIFY_SESSION);

            if (!instructor.isArchived && isAllowedToMakeSession) {
                coursesToAddToData.add(course);
            }
        }

        CourseAttributes.sortByCreatedDate(coursesToAddToData);

        InstructorFeedbackEditCopyPageData data = new InstructorFeedbackEditCopyPageData(account, sessionToken,
                coursesToAddToData, courseId, feedbackSessionName);

        return createShowPageResult(Const.ViewURIs.INSTRUCTOR_FEEDBACK_COPY_MODAL, data);
    }

}
"
InstructorFeedbackEditPageAction.java,ui-controller,"package teammates.ui.controller;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import teammates.common.datatransfer.attributes.FeedbackQuestionAttributes;
import teammates.common.datatransfer.attributes.FeedbackSessionAttributes;
import teammates.common.datatransfer.attributes.InstructorAttributes;
import teammates.common.datatransfer.attributes.StudentAttributes;
import teammates.common.exception.EntityDoesNotExistException;
import teammates.common.util.Assumption;
import teammates.common.util.Const;
import teammates.ui.pagedata.InstructorFeedbackEditPageData;

public class InstructorFeedbackEditPageAction extends Action {

    @Override
    protected ActionResult execute() throws EntityDoesNotExistException {

        String courseId = getRequestParamValue(Const.ParamsNames.COURSE_ID);
        Assumption.assertPostParamNotNull(Const.ParamsNames.COURSE_ID, courseId);
        String feedbackSessionName = getRequestParamValue(Const.ParamsNames.FEEDBACK_SESSION_NAME);
        Assumption.assertPostParamNotNull(Const.ParamsNames.FEEDBACK_SESSION_NAME, feedbackSessionName);
        String shouldLoadInEditModeParam = getRequestParamValue(Const.ParamsNames.FEEDBACK_SESSION_ENABLE_EDIT);
        boolean shouldLoadInEditMode = ""true"".equals(shouldLoadInEditModeParam);

        FeedbackSessionAttributes feedbackSession = logic.getFeedbackSession(feedbackSessionName, courseId);
        gateKeeper.verifyAccessible(
                logic.getInstructorForGoogleId(courseId, account.googleId),
                feedbackSession,
                false,
                Const.ParamsNames.INSTRUCTOR_PERMISSION_MODIFY_SESSION);

        List<FeedbackQuestionAttributes> questions = logic.getFeedbackQuestionsForSession(feedbackSessionName, courseId);

        Map<String, Boolean> questionHasResponses = new HashMap<>();

        for (FeedbackQuestionAttributes question : questions) {
            boolean hasResponse = logic.areThereResponsesForQuestion(question.getId());
            questionHasResponses.put(question.getId(), hasResponse);
        }

        List<StudentAttributes> studentList = logic.getStudentsForCourse(courseId);
        Collections.sort(studentList, new Comparator<StudentAttributes>() {
            @Override
            public int compare(StudentAttributes s1, StudentAttributes s2) {
                if (s1.team.equals(s2.team)) {
                    return s1.name.compareToIgnoreCase(s2.name);
                }
                return s1.team.compareToIgnoreCase(s2.team);
            }
        });

        List<InstructorAttributes> instructorList = logic.getInstructorsForCourse(courseId);
        List<InstructorAttributes> instructorsWhoCanSubmit = new ArrayList<>();
        for (InstructorAttributes instructor : instructorList) {
            if (instructor.isAllowedForPrivilege(Const.ParamsNames.INSTRUCTOR_PERMISSION_SUBMIT_SESSION_IN_SECTIONS)) {
                instructorsWhoCanSubmit.add(instructor);
            }
        }
        Collections.sort(instructorList, new Comparator<InstructorAttributes>() {
            @Override
            public int compare(InstructorAttributes i1, InstructorAttributes i2) {
                return i1.name.compareToIgnoreCase(i2.name);
            }
        });

        InstructorAttributes instructor = logic.getInstructorForGoogleId(courseId, account.googleId);

        statusToAdmin = ""instructorFeedbackEdit Page Load<br>""
                        + ""Editing information for Feedback Session ""
                        + ""<span class=\""bold\"">["" + feedbackSessionName + ""]</span>""
                        + ""in Course: <span class=\""bold\"">["" + courseId + ""]</span>"";

        InstructorFeedbackEditPageData data = new InstructorFeedbackEditPageData(account, sessionToken);
        data.init(feedbackSession, questions, questionHasResponses, studentList,
                instructorsWhoCanSubmit, instructor, shouldLoadInEditMode);

        return createShowPageResult(Const.ViewURIs.INSTRUCTOR_FEEDBACK_EDIT, data);
    }

}
"
InstructorFeedbackEditSaveAction.java,ui-controller,"package teammates.ui.controller;

import teammates.common.datatransfer.attributes.FeedbackSessionAttributes;
import teammates.common.exception.EntityDoesNotExistException;
import teammates.common.exception.InvalidParametersException;
import teammates.common.util.Assumption;
import teammates.common.util.Const;
import teammates.common.util.StatusMessage;
import teammates.common.util.StatusMessageColor;
import teammates.ui.pagedata.InstructorFeedbackEditPageData;

public class InstructorFeedbackEditSaveAction extends InstructorFeedbackAbstractAction {

    @Override
    protected ActionResult execute() throws EntityDoesNotExistException {

        String courseId = getRequestParamValue(Const.ParamsNames.COURSE_ID);
        String feedbackSessionName = getRequestParamValue(Const.ParamsNames.FEEDBACK_SESSION_NAME);

        Assumption.assertPostParamNotNull(Const.ParamsNames.COURSE_ID, courseId);
        Assumption.assertPostParamNotNull(Const.ParamsNames.FEEDBACK_SESSION_NAME, feedbackSessionName);

        gateKeeper.verifyAccessible(
                logic.getInstructorForGoogleId(courseId, account.googleId),
                logic.getFeedbackSession(feedbackSessionName, courseId),
                false,
                Const.ParamsNames.INSTRUCTOR_PERMISSION_MODIFY_SESSION);

        InstructorFeedbackEditPageData data = new InstructorFeedbackEditPageData(account, sessionToken);
        FeedbackSessionAttributes feedbackSession = extractFeedbackSessionData(false);

        // A session opening reminder email is always sent as students
        // without accounts need to receive the email to be able to respond
        feedbackSession.setOpeningEmailEnabled(true);

        try {
            logic.updateFeedbackSession(feedbackSession);
            statusToUser.add(new StatusMessage(Const.StatusMessages.FEEDBACK_SESSION_EDITED, StatusMessageColor.SUCCESS));
            statusToAdmin =
                    ""Updated Feedback Session ""
                    + ""<span class=\""bold\"">("" + feedbackSession.getFeedbackSessionName() + "")</span> for Course ""
                    + ""<span class=\""bold\"">["" + feedbackSession.getCourseId() + ""]</span> created.<br>""
                    + ""<span class=\""bold\"">From:</span> "" + feedbackSession.getStartTime()
                    + ""<span class=\""bold\""> to</span> "" + feedbackSession.getEndTime()
                    + ""<br><span class=\""bold\"">Session visible from:</span> "" + feedbackSession.getSessionVisibleFromTime()
                    + ""<br><span class=\""bold\"">Results visible from:</span> "" + feedbackSession.getResultsVisibleFromTime()
                    + ""<br><br><span class=\""bold\"">Instructions:</span> "" + feedbackSession.getInstructions();
            data.setStatusForAjax(Const.StatusMessages.FEEDBACK_SESSION_EDITED);
            data.setHasError(false);
        } catch (InvalidParametersException e) {
            setStatusForException(e);
            data.setStatusForAjax(e.getMessage());
            data.setHasError(true);
        }
        return createAjaxResult(data);
    }
}
"
InstructorFeedbackPreviewAsInstructorAction.java,ui-controller,"package teammates.ui.controller;

import teammates.common.datatransfer.attributes.InstructorAttributes;
import teammates.common.exception.EntityDoesNotExistException;
import teammates.common.util.Assumption;
import teammates.common.util.Const;
import teammates.ui.pagedata.FeedbackSubmissionEditPageData;

public class InstructorFeedbackPreviewAsInstructorAction extends Action {

    @Override
    protected ActionResult execute() throws EntityDoesNotExistException {
        String courseId = getRequestParamValue(Const.ParamsNames.COURSE_ID);
        String feedbackSessionName = getRequestParamValue(Const.ParamsNames.FEEDBACK_SESSION_NAME);
        String previewInstructorEmail = getRequestParamValue(Const.ParamsNames.PREVIEWAS);

        Assumption.assertPostParamNotNull(Const.ParamsNames.COURSE_ID, courseId);
        Assumption.assertPostParamNotNull(Const.ParamsNames.FEEDBACK_SESSION_NAME, feedbackSessionName);
        Assumption.assertPostParamNotNull(Const.ParamsNames.PREVIEWAS, previewInstructorEmail);

        gateKeeper.verifyAccessible(
                logic.getInstructorForGoogleId(courseId, account.googleId),
                logic.getFeedbackSession(feedbackSessionName, courseId),
                false, Const.ParamsNames.INSTRUCTOR_PERMISSION_MODIFY_SESSION);

        InstructorAttributes previewInstructor = logic.getInstructorForEmail(courseId, previewInstructorEmail);

        if (previewInstructor == null) {
            throw new EntityDoesNotExistException(
                    ""Instructor Email "" + previewInstructorEmail + "" does not exist in "" + courseId + ""."");
        }

        FeedbackSubmissionEditPageData data = new FeedbackSubmissionEditPageData(account, student, sessionToken);

        data.bundle = logic.getFeedbackSessionQuestionsBundleForInstructor(
                feedbackSessionName,
                courseId,
                previewInstructor.email);

        data.setSessionOpenForSubmission(true);
        data.setPreview(true);
        data.setHeaderHidden(true);
        data.setPreviewInstructor(previewInstructor);
        data.setSubmitAction(Const.ActionURIs.INSTRUCTOR_FEEDBACK_SUBMISSION_EDIT_SAVE);
        data.bundle.resetAllResponses();

        statusToAdmin = ""Preview feedback session as instructor ("" + previewInstructor.email + "")<br>""
                      + ""Session Name: "" + feedbackSessionName + ""<br>""
                      + ""Course ID: "" + courseId;

        data.init("""", """", courseId);

        return createShowPageResult(Const.ViewURIs.INSTRUCTOR_FEEDBACK_SUBMISSION_EDIT, data);
    }
}
"
InstructorFeedbackPreviewAsStudentAction.java,ui-controller,"package teammates.ui.controller;

import teammates.common.datatransfer.attributes.StudentAttributes;
import teammates.common.exception.EntityDoesNotExistException;
import teammates.common.util.Assumption;
import teammates.common.util.Const;
import teammates.ui.pagedata.FeedbackSubmissionEditPageData;

public class InstructorFeedbackPreviewAsStudentAction extends Action {

    @Override
    protected ActionResult execute() throws EntityDoesNotExistException {
        String courseId = getRequestParamValue(Const.ParamsNames.COURSE_ID);
        String feedbackSessionName = getRequestParamValue(Const.ParamsNames.FEEDBACK_SESSION_NAME);
        String previewStudentEmail = getRequestParamValue(Const.ParamsNames.PREVIEWAS);

        Assumption.assertPostParamNotNull(Const.ParamsNames.COURSE_ID, courseId);
        Assumption.assertPostParamNotNull(Const.ParamsNames.FEEDBACK_SESSION_NAME, feedbackSessionName);
        Assumption.assertPostParamNotNull(Const.ParamsNames.PREVIEWAS, previewStudentEmail);

        gateKeeper.verifyAccessible(
                logic.getInstructorForGoogleId(courseId, account.googleId),
                logic.getFeedbackSession(feedbackSessionName, courseId),
                false, Const.ParamsNames.INSTRUCTOR_PERMISSION_MODIFY_SESSION);

        StudentAttributes previewStudent = logic.getStudentForEmail(courseId, previewStudentEmail);

        if (previewStudent == null) {
            throw new EntityDoesNotExistException(
                    ""Student Email "" + previewStudentEmail + "" does not exist in "" + courseId + ""."");
        }

        FeedbackSubmissionEditPageData data = new FeedbackSubmissionEditPageData(account, student, sessionToken);

        data.bundle = logic.getFeedbackSessionQuestionsBundleForStudent(
                feedbackSessionName, courseId, previewStudent.email);

        data.setSessionOpenForSubmission(true);
        data.setPreview(true);
        data.setHeaderHidden(true);
        data.setStudentToViewPageAs(previewStudent);
        data.setSubmitAction(Const.ActionURIs.STUDENT_FEEDBACK_SUBMISSION_EDIT_SAVE);
        data.bundle.resetAllResponses();

        statusToAdmin = ""Preview feedback session as student ("" + previewStudent.email + "")<br>""
                      + ""Session Name: "" + feedbackSessionName + ""<br>""
                      + ""Course ID: "" + courseId;

        data.init("""", """", courseId);

        return createShowPageResult(Const.ViewURIs.STUDENT_FEEDBACK_SUBMISSION_EDIT, data);
    }
}
"
InstructorFeedbackPublishAction.java,ui-controller,"package teammates.ui.controller;

import teammates.common.datatransfer.attributes.FeedbackSessionAttributes;
import teammates.common.datatransfer.attributes.InstructorAttributes;
import teammates.common.exception.EntityDoesNotExistException;
import teammates.common.exception.InvalidParametersException;
import teammates.common.util.Assumption;
import teammates.common.util.Const;
import teammates.common.util.StatusMessage;
import teammates.common.util.StatusMessageColor;

public class InstructorFeedbackPublishAction extends Action {

    @Override
    protected ActionResult execute() throws EntityDoesNotExistException {
        String courseId = getRequestParamValue(Const.ParamsNames.COURSE_ID);
        String feedbackSessionName = getRequestParamValue(Const.ParamsNames.FEEDBACK_SESSION_NAME);
        String nextUrl = getRequestParamValue(Const.ParamsNames.NEXT_URL);
        Assumption.assertPostParamNotNull(Const.ParamsNames.COURSE_ID, courseId);
        Assumption.assertPostParamNotNull(Const.ParamsNames.FEEDBACK_SESSION_NAME, feedbackSessionName);

        InstructorAttributes instructor = logic.getInstructorForGoogleId(courseId, account.googleId);
        FeedbackSessionAttributes session = logic.getFeedbackSession(feedbackSessionName, courseId);
        boolean isCreatorOnly = false;

        gateKeeper.verifyAccessible(instructor, session, isCreatorOnly,
                                    Const.ParamsNames.INSTRUCTOR_PERMISSION_MODIFY_SESSION);

        try {
            logic.publishFeedbackSession(session);
            if (session.isPublishedEmailEnabled()) {
                taskQueuer.scheduleFeedbackSessionPublishedEmail(session.getCourseId(), session.getFeedbackSessionName());
            }

            statusToUser.add(new StatusMessage(Const.StatusMessages.FEEDBACK_SESSION_PUBLISHED, StatusMessageColor.SUCCESS));
            statusToAdmin = ""Feedback Session <span class=\""bold\"">("" + feedbackSessionName + "")</span> ""
                            + ""for Course <span class=\""bold\"">["" + courseId + ""]</span> published."";
        } catch (InvalidParametersException e) {
            setStatusForException(e);
        }

        if (nextUrl == null) {
            nextUrl = Const.ActionURIs.INSTRUCTOR_FEEDBACK_SESSIONS_PAGE;
        }

        return createRedirectResult(nextUrl);
    }
}
"
InstructorFeedbackQuestionAddAction.java,ui-controller,"package teammates.ui.controller;

import java.util.ArrayList;
import java.util.List;

import com.google.appengine.api.datastore.Text;

import teammates.common.datatransfer.FeedbackParticipantType;
import teammates.common.datatransfer.attributes.FeedbackQuestionAttributes;
import teammates.common.datatransfer.attributes.InstructorAttributes;
import teammates.common.datatransfer.questions.FeedbackQuestionDetails;
import teammates.common.datatransfer.questions.FeedbackQuestionType;
import teammates.common.exception.InvalidParametersException;
import teammates.common.util.Assumption;
import teammates.common.util.Const;
import teammates.common.util.SanitizationHelper;
import teammates.common.util.StatusMessage;
import teammates.common.util.StatusMessageColor;
import teammates.ui.pagedata.PageData;

public class InstructorFeedbackQuestionAddAction extends Action {

    @Override
    protected ActionResult execute() {
        String courseId = getRequestParamValue(Const.ParamsNames.COURSE_ID);
        String feedbackSessionName = getRequestParamValue(Const.ParamsNames.FEEDBACK_SESSION_NAME);
        InstructorAttributes instructorDetailForCourse = logic.getInstructorForGoogleId(courseId, account.googleId);

        gateKeeper.verifyAccessible(instructorDetailForCourse,
                                    logic.getFeedbackSession(feedbackSessionName, courseId),
                                    false, Const.ParamsNames.INSTRUCTOR_PERMISSION_MODIFY_SESSION);

        FeedbackQuestionAttributes feedbackQuestion = extractFeedbackQuestionData(instructorDetailForCourse.email);
        List<String> questionDetailsErrors = feedbackQuestion.getQuestionDetails().validateQuestionDetails();

        List<StatusMessage> questionDetailsErrorsMessages = new ArrayList<>();

        for (String error : questionDetailsErrors) {
            questionDetailsErrorsMessages.add(new StatusMessage(error, StatusMessageColor.DANGER));
        }

        RedirectResult redirectResult = createRedirectResult(new PageData(account, sessionToken)
                .getInstructorFeedbackEditLink(courseId, feedbackSessionName));

        if (!questionDetailsErrors.isEmpty()) {
            statusToUser.addAll(questionDetailsErrorsMessages);
            isError = true;

            return redirectResult;
        }

        String err = validateQuestionGiverRecipientVisibility(feedbackQuestion);

        if (!err.isEmpty()) {
            statusToUser.add(new StatusMessage(err, StatusMessageColor.DANGER));
            isError = true;
        }

        try {
            logic.createFeedbackQuestion(feedbackQuestion);
            statusToUser.add(new StatusMessage(Const.StatusMessages.FEEDBACK_QUESTION_ADDED, StatusMessageColor.SUCCESS));
            statusToAdmin = ""Created Feedback Question for Feedback Session:<span class=\""bold\"">(""
                          + feedbackQuestion.feedbackSessionName + "")</span> for Course <span class=\""bold\"">[""
                          + feedbackQuestion.courseId + ""]</span> created.<br>""
                          + ""<span class=\""bold\"">""
                          + feedbackQuestion.getQuestionDetails().getQuestionTypeDisplayName()
                          + "":</span> ""
                          + SanitizationHelper.sanitizeForHtml(feedbackQuestion.getQuestionDetails().getQuestionText());
        } catch (InvalidParametersException e) {
            statusToUser.add(new StatusMessage(e.getMessage(), StatusMessageColor.DANGER));
            statusToAdmin = e.getMessage();
            isError = true;
        }
        return redirectResult;
    }

    private String validateQuestionGiverRecipientVisibility(FeedbackQuestionAttributes feedbackQuestion) {
        return InstructorFeedbackQuestionEditAction.validateQuestionGiverRecipientVisibility(feedbackQuestion);
    }

    private FeedbackQuestionAttributes extractFeedbackQuestionData(String creatorEmail) {
        FeedbackQuestionAttributes newQuestion = new FeedbackQuestionAttributes();

        newQuestion.creatorEmail = creatorEmail;

        newQuestion.courseId = getRequestParamValue(Const.ParamsNames.COURSE_ID);
        Assumption.assertPostParamNotNull(Const.ParamsNames.COURSE_ID, newQuestion.courseId);

        newQuestion.feedbackSessionName = getRequestParamValue(Const.ParamsNames.FEEDBACK_SESSION_NAME);
        Assumption.assertPostParamNotNull(Const.ParamsNames.FEEDBACK_SESSION_NAME, newQuestion.feedbackSessionName);

        String feedbackQuestionGiverType = getRequestParamValue(Const.ParamsNames.FEEDBACK_QUESTION_GIVERTYPE);
        Assumption.assertPostParamNotNull(Const.ParamsNames.FEEDBACK_QUESTION_GIVERTYPE, feedbackQuestionGiverType);
        newQuestion.giverType = FeedbackParticipantType.valueOf(feedbackQuestionGiverType);

        String feedbackQuestionRecipientType = getRequestParamValue(Const.ParamsNames.FEEDBACK_QUESTION_RECIPIENTTYPE);
        Assumption.assertPostParamNotNull(Const.ParamsNames.FEEDBACK_QUESTION_RECIPIENTTYPE, feedbackQuestionRecipientType);
        newQuestion.recipientType = FeedbackParticipantType.valueOf(feedbackQuestionRecipientType);

        String feedbackQuestionNumber = getRequestParamValue(Const.ParamsNames.FEEDBACK_QUESTION_NUMBER);
        Assumption.assertPostParamNotNull(Const.ParamsNames.FEEDBACK_QUESTION_NUMBER, feedbackQuestionNumber);
        newQuestion.questionNumber = Integer.parseInt(feedbackQuestionNumber);
        Assumption.assertTrue(""Invalid question number"", newQuestion.questionNumber >= 1);

        String numberOfEntityTypes = getRequestParamValue(Const.ParamsNames.FEEDBACK_QUESTION_NUMBEROFENTITIESTYPE);
        Assumption.assertPostParamNotNull(Const.ParamsNames.FEEDBACK_QUESTION_NUMBEROFENTITIESTYPE, numberOfEntityTypes);

        if (""custom"".equals(numberOfEntityTypes)
                && (newQuestion.recipientType == FeedbackParticipantType.STUDENTS
                        || newQuestion.recipientType == FeedbackParticipantType.TEAMS)) {
            String numberOfEntities = getRequestParamValue(Const.ParamsNames.FEEDBACK_QUESTION_NUMBEROFENTITIES);
            Assumption.assertPostParamNotNull(Const.ParamsNames.FEEDBACK_QUESTION_NUMBEROFENTITIES, numberOfEntities);

            newQuestion.numberOfEntitiesToGiveFeedbackTo = Integer.parseInt(numberOfEntities);
        } else {
            newQuestion.numberOfEntitiesToGiveFeedbackTo = Const.MAX_POSSIBLE_RECIPIENTS;
        }

        newQuestion.showResponsesTo = FeedbackParticipantType.getParticipantListFromCommaSeparatedValues(
                getRequestParamValue(Const.ParamsNames.FEEDBACK_QUESTION_SHOWRESPONSESTO));
        newQuestion.showGiverNameTo = FeedbackParticipantType.getParticipantListFromCommaSeparatedValues(
                getRequestParamValue(Const.ParamsNames.FEEDBACK_QUESTION_SHOWGIVERTO));
        newQuestion.showRecipientNameTo = FeedbackParticipantType.getParticipantListFromCommaSeparatedValues(
                getRequestParamValue(Const.ParamsNames.FEEDBACK_QUESTION_SHOWRECIPIENTTO));

        String questionType = getRequestParamValue(Const.ParamsNames.FEEDBACK_QUESTION_TYPE);
        Assumption.assertPostParamNotNull(Const.ParamsNames.FEEDBACK_QUESTION_TYPE, questionType);
        questionType = FeedbackQuestionType.standardizeIfConstSum(questionType);
        newQuestion.questionType = FeedbackQuestionType.valueOf(questionType);

        FeedbackQuestionDetails questionDetails = FeedbackQuestionDetails.createQuestionDetails(
                requestParameters, newQuestion.questionType);
        newQuestion.setQuestionDetails(questionDetails);

        String questionDescription = getRequestParamValue(Const.ParamsNames.FEEDBACK_QUESTION_DESCRIPTION);
        newQuestion.setQuestionDescription(new Text(questionDescription));

        return newQuestion;
    }

}
"
InstructorFeedbackQuestionCopyAction.java,ui-controller,"package teammates.ui.controller;

import teammates.common.datatransfer.attributes.FeedbackQuestionAttributes;
import teammates.common.datatransfer.attributes.InstructorAttributes;
import teammates.common.exception.InvalidParametersException;
import teammates.common.util.Const;
import teammates.common.util.SanitizationHelper;
import teammates.common.util.StatusMessage;
import teammates.common.util.StatusMessageColor;
import teammates.ui.pagedata.PageData;

public class InstructorFeedbackQuestionCopyAction extends Action {

    @Override
    protected ActionResult execute() {
        String courseId = getRequestParamValue(Const.ParamsNames.COURSE_ID);
        String feedbackSessionName = getRequestParamValue(Const.ParamsNames.FEEDBACK_SESSION_NAME);
        InstructorAttributes instructorDetailForCourse = logic.getInstructorForGoogleId(courseId, account.googleId);

        gateKeeper.verifyAccessible(instructorDetailForCourse,
                                    logic.getFeedbackSession(feedbackSessionName, courseId),
                                    false, Const.ParamsNames.INSTRUCTOR_PERMISSION_MODIFY_SESSION);

        String instructorEmail = instructorDetailForCourse.email;

        try {
            int index = 0;
            String feedbackQuestionId = getRequestParamValue(Const.ParamsNames.FEEDBACK_QUESTION_ID + ""-"" + index);
            statusToAdmin = """";

            while (feedbackQuestionId != null) {
                FeedbackQuestionAttributes feedbackQuestion =
                        logic.copyFeedbackQuestion(feedbackQuestionId, feedbackSessionName, courseId, instructorEmail);

                index++;

                feedbackQuestionId = getRequestParamValue(Const.ParamsNames.FEEDBACK_QUESTION_ID + ""-"" + index);

                statusToAdmin += ""Created Feedback Question for Feedback Session:<span class=\""bold\"">(""
                        + feedbackQuestion.feedbackSessionName + "")</span> for Course <span class=\""bold\"">[""
                        + feedbackQuestion.courseId + ""]</span> created.<br>""
                        + ""<span class=\""bold\"">""
                        + feedbackQuestion.getQuestionDetails().getQuestionTypeDisplayName()
                        + "":</span> ""
                        + SanitizationHelper.sanitizeForHtml(feedbackQuestion.getQuestionDetails().getQuestionText());
            }

            if (index > 0) {
                statusToUser.add(new StatusMessage(Const.StatusMessages.FEEDBACK_QUESTION_ADDED,
                                                   StatusMessageColor.SUCCESS));
            } else {
                statusToUser.add(new StatusMessage(""No questions are indicated to be copied"", StatusMessageColor.DANGER));
                isError = true;
            }
        } catch (InvalidParametersException e) {
            // This part is not tested because GateKeeper handles if this happens, would be
            // extremely difficult to replicate a situation whereby it gets past GateKeeper
            statusToUser.add(new StatusMessage(e.getMessage(), StatusMessageColor.DANGER));
            statusToAdmin = e.getMessage();
            isError = true;
        }

        return createRedirectResult(new PageData(account, sessionToken)
                .getInstructorFeedbackEditLink(courseId, feedbackSessionName));
    }
}
"
InstructorFeedbackQuestionCopyPageAction.java,ui-controller,"package teammates.ui.controller;

import java.util.List;

import teammates.common.datatransfer.attributes.FeedbackQuestionAttributes;
import teammates.common.datatransfer.attributes.FeedbackSessionAttributes;
import teammates.common.exception.EntityDoesNotExistException;
import teammates.common.util.Assumption;
import teammates.common.util.Const;
import teammates.ui.pagedata.InstructorFeedbackQuestionCopyPageData;

public class InstructorFeedbackQuestionCopyPageAction extends Action {

    @Override
    protected ActionResult execute() throws EntityDoesNotExistException {

        String courseId = getRequestParamValue(Const.ParamsNames.COURSE_ID);
        Assumption.assertPostParamNotNull(Const.ParamsNames.COURSE_ID, courseId);
        String feedbackSessionName = getRequestParamValue(Const.ParamsNames.FEEDBACK_SESSION_NAME);
        Assumption.assertPostParamNotNull(Const.ParamsNames.FEEDBACK_SESSION_NAME, feedbackSessionName);

        FeedbackSessionAttributes feedbackSession = logic.getFeedbackSession(feedbackSessionName, courseId);
        gateKeeper.verifyAccessible(
                logic.getInstructorForGoogleId(courseId, account.googleId),
                feedbackSession, false,
                Const.ParamsNames.INSTRUCTOR_PERMISSION_MODIFY_SESSION);

        List<FeedbackQuestionAttributes> copiableQuestions = null;

        copiableQuestions = logic.getCopiableFeedbackQuestionsForInstructor(account.googleId);

        InstructorFeedbackQuestionCopyPageData data =
                new InstructorFeedbackQuestionCopyPageData(account, sessionToken, copiableQuestions);
        return createShowPageResult(Const.ViewURIs.INSTRUCTOR_FEEDBACK_QUESTION_COPY_MODAL, data);
    }
}
"
InstructorFeedbackQuestionEditAction.java,ui-controller,"package teammates.ui.controller;

import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.List;

import com.google.appengine.api.datastore.Text;

import teammates.common.datatransfer.FeedbackParticipantType;
import teammates.common.datatransfer.attributes.FeedbackQuestionAttributes;
import teammates.common.datatransfer.questions.FeedbackQuestionDetails;
import teammates.common.datatransfer.questions.FeedbackQuestionType;
import teammates.common.exception.EntityDoesNotExistException;
import teammates.common.exception.InvalidParametersException;
import teammates.common.exception.TeammatesException;
import teammates.common.util.Assumption;
import teammates.common.util.Const;
import teammates.common.util.Logger;
import teammates.common.util.SanitizationHelper;
import teammates.common.util.StatusMessage;
import teammates.common.util.StatusMessageColor;
import teammates.ui.pagedata.PageData;

public class InstructorFeedbackQuestionEditAction extends Action {

    private static final Logger log = Logger.getLogger();

    @Override
    protected ActionResult execute() throws EntityDoesNotExistException {
        String courseId = getRequestParamValue(Const.ParamsNames.COURSE_ID);
        String feedbackSessionName = getRequestParamValue(Const.ParamsNames.FEEDBACK_SESSION_NAME);

        Assumption.assertPostParamNotNull(Const.ParamsNames.COURSE_ID, courseId);
        Assumption.assertPostParamNotNull(Const.ParamsNames.FEEDBACK_SESSION_NAME, feedbackSessionName);

        gateKeeper.verifyAccessible(logic.getInstructorForGoogleId(courseId, account.googleId),
                                    logic.getFeedbackSession(feedbackSessionName, courseId),
                                    false, Const.ParamsNames.INSTRUCTOR_PERMISSION_MODIFY_SESSION);

        String editType = getRequestParamValue(Const.ParamsNames.FEEDBACK_QUESTION_EDITTYPE);
        Assumption.assertPostParamNotNull(Const.ParamsNames.FEEDBACK_QUESTION_EDITTYPE, editType);

        FeedbackQuestionAttributes updatedQuestion = extractFeedbackQuestionData();

        try {
            if (""edit"".equals(editType)) {
                String questionText = getRequestParamValue(Const.ParamsNames.FEEDBACK_QUESTION_TEXT);
                Assumption.assertPostParamNotNull(Const.ParamsNames.FEEDBACK_QUESTION_TEXT, questionText);
                Assumption.assertNotEmpty(""Empty question text"", questionText);

                editQuestion(updatedQuestion);
            } else if (""delete"".equals(editType)) {
                // branch not tested because if it's not edit or delete, Assumption.fail will cause test failure
                deleteQuestion(updatedQuestion);
            } else {
                // Assumption.fails are not tested
                Assumption.fail(""Invalid editType"");
            }
        } catch (InvalidParametersException e) {
            // This part is not tested because GateKeeper handles if this happens, would be
            // extremely difficult to replicate a situation whereby it gets past GateKeeper
            setStatusForException(e);
        }

        return createRedirectResult(new PageData(account, sessionToken)
                                            .getInstructorFeedbackEditLink(courseId, feedbackSessionName));
    }

    private void deleteQuestion(FeedbackQuestionAttributes updatedQuestion) {
        logic.deleteFeedbackQuestion(updatedQuestion.getId());
        statusToUser.add(new StatusMessage(Const.StatusMessages.FEEDBACK_QUESTION_DELETED, StatusMessageColor.SUCCESS));
        statusToAdmin = ""Feedback Question "" + updatedQuestion.questionNumber + "" for session:<span class=\""bold\"">(""
                        + updatedQuestion.feedbackSessionName + "")</span> for Course <span class=\""bold\"">[""
                        + updatedQuestion.courseId + ""]</span> deleted.<br>"";
    }

    private void editQuestion(FeedbackQuestionAttributes updatedQuestion) throws InvalidParametersException,
                                                                                 EntityDoesNotExistException {
        String err = validateQuestionGiverRecipientVisibility(updatedQuestion);

        if (!err.isEmpty()) {
            statusToUser.add(new StatusMessage(err, StatusMessageColor.DANGER));
            isError = true;
        }

        FeedbackQuestionDetails updatedQuestionDetails = updatedQuestion.getQuestionDetails();
        List<String> questionDetailsErrors = updatedQuestionDetails.validateQuestionDetails();
        List<StatusMessage> questionDetailsErrorsMessages = new ArrayList<>();

        for (String error : questionDetailsErrors) {
            questionDetailsErrorsMessages.add(new StatusMessage(error, StatusMessageColor.DANGER));
        }

        if (questionDetailsErrors.isEmpty()) {
            logic.updateFeedbackQuestionNumber(updatedQuestion);

            statusToUser.add(new StatusMessage(Const.StatusMessages.FEEDBACK_QUESTION_EDITED, StatusMessageColor.SUCCESS));
            statusToAdmin = ""Feedback Question "" + updatedQuestion.questionNumber
                          + "" for session:<span class=\""bold\"">(""
                          + updatedQuestion.feedbackSessionName + "")</span> for Course <span class=\""bold\"">[""
                          + updatedQuestion.courseId + ""]</span> edited.<br>""
                          + ""<span class=\""bold\"">""
                          + updatedQuestionDetails.getQuestionTypeDisplayName() + "":</span> ""
                          + SanitizationHelper.sanitizeForHtml(updatedQuestionDetails.getQuestionText());
        } else {
            statusToUser.addAll(questionDetailsErrorsMessages);
            isError = true;
        }
    }

    /**
     * Validates that the giver and recipient for the given FeedbackQuestionAttributes is valid for its question type.
     * Validates that the visibility for the given FeedbackQuestionAttributes is valid for its question type.
     *
     * @return error message detailing the error, or an empty string if valid.
     */
    public static String validateQuestionGiverRecipientVisibility(FeedbackQuestionAttributes feedbackQuestionAttributes) {
        String errorMsg = """";

        FeedbackQuestionDetails questionDetails = null;
        Class<? extends FeedbackQuestionDetails> questionDetailsClass = feedbackQuestionAttributes
                                                                            .questionType.getQuestionDetailsClass();
        Constructor<? extends FeedbackQuestionDetails> questionDetailsClassConstructor;

        try {
            questionDetailsClassConstructor = questionDetailsClass.getConstructor();
            questionDetails = questionDetailsClassConstructor.newInstance();
            Method m = questionDetailsClass.getMethod(""validateGiverRecipientVisibility"",
                                                      FeedbackQuestionAttributes.class);
            errorMsg = (String) m.invoke(questionDetails, feedbackQuestionAttributes);

        } catch (NoSuchMethodException | SecurityException | IllegalAccessException | IllegalArgumentException
                 | InvocationTargetException | InstantiationException e) {
            log.severe(TeammatesException.toStringWithStackTrace(e));
            // Assumption.fails are not tested
            Assumption.fail(""Failed to instantiate Feedback*QuestionDetails instance for ""
                            + feedbackQuestionAttributes.questionType.toString() + "" question type."");
        }

        return errorMsg;
    }

    private FeedbackQuestionAttributes extractFeedbackQuestionData() {
        FeedbackQuestionAttributes newQuestion = new FeedbackQuestionAttributes();

        newQuestion.setId(getRequestParamValue(Const.ParamsNames.FEEDBACK_QUESTION_ID));
        Assumption.assertPostParamNotNull(Const.ParamsNames.FEEDBACK_QUESTION_ID, newQuestion.getId());

        newQuestion.courseId = getRequestParamValue(Const.ParamsNames.COURSE_ID);
        Assumption.assertPostParamNotNull(Const.ParamsNames.COURSE_ID, newQuestion.courseId);

        newQuestion.feedbackSessionName = getRequestParamValue(Const.ParamsNames.FEEDBACK_SESSION_NAME);
        Assumption.assertPostParamNotNull(Const.ParamsNames.FEEDBACK_SESSION_NAME, newQuestion.feedbackSessionName);

        // TODO thoroughly investigate when and why these parameters can be null
        // and check all possibilities in the tests
        // should only be null when deleting. might be good to separate the delete action from this class

        // When editing, usually the following fields are not null. If they are null somehow(edit from browser),
        // Then the field will not update and take on its old value.
        // When deleting, the following fields are null.
        // numofrecipients
        // questiontext
        // numofrecipientstype
        // recipienttype
        // receiverLeaderCheckbox
        // givertype

        // Can be null
        String giverType = getRequestParamValue(Const.ParamsNames.FEEDBACK_QUESTION_GIVERTYPE);
        if (giverType != null) {
            newQuestion.giverType = FeedbackParticipantType.valueOf(giverType);
        }

        // Can be null
        String recipientType = getRequestParamValue(Const.ParamsNames.FEEDBACK_QUESTION_RECIPIENTTYPE);
        if (recipientType != null) {
            newQuestion.recipientType = FeedbackParticipantType.valueOf(recipientType);
        }

        String questionNumber = getRequestParamValue(Const.ParamsNames.FEEDBACK_QUESTION_NUMBER);
        Assumption.assertPostParamNotNull(Const.ParamsNames.FEEDBACK_QUESTION_NUMBER, questionNumber);
        newQuestion.questionNumber = Integer.parseInt(questionNumber);
        Assumption.assertTrue(""Invalid question number"", newQuestion.questionNumber >= 1);

        // Can be null
        String nEntityTypes = getRequestParamValue(Const.ParamsNames.FEEDBACK_QUESTION_NUMBEROFENTITIESTYPE);

        if (numberOfEntitiesIsUserDefined(newQuestion.recipientType, nEntityTypes)) {
            String nEntities = getRequestParamValue(Const.ParamsNames.FEEDBACK_QUESTION_NUMBEROFENTITIES);
            Assumption.assertPostParamNotNull(Const.ParamsNames.FEEDBACK_QUESTION_NUMBEROFENTITIES, nEntities);
            newQuestion.numberOfEntitiesToGiveFeedbackTo = Integer.parseInt(nEntities);
        } else {
            newQuestion.numberOfEntitiesToGiveFeedbackTo = Const.MAX_POSSIBLE_RECIPIENTS;
        }

        newQuestion.showResponsesTo = FeedbackParticipantType.getParticipantListFromCommaSeparatedValues(
                getRequestParamValue(Const.ParamsNames.FEEDBACK_QUESTION_SHOWRESPONSESTO));
        newQuestion.showGiverNameTo = FeedbackParticipantType.getParticipantListFromCommaSeparatedValues(
                getRequestParamValue(Const.ParamsNames.FEEDBACK_QUESTION_SHOWGIVERTO));
        newQuestion.showRecipientNameTo = FeedbackParticipantType.getParticipantListFromCommaSeparatedValues(
                getRequestParamValue(Const.ParamsNames.FEEDBACK_QUESTION_SHOWRECIPIENTTO));

        String questionType = getRequestParamValue(Const.ParamsNames.FEEDBACK_QUESTION_TYPE);
        Assumption.assertPostParamNotNull(Const.ParamsNames.FEEDBACK_QUESTION_TYPE, questionType);
        newQuestion.questionType = FeedbackQuestionType.valueOf(questionType);

        // Can be null
        String questionText = getRequestParamValue(Const.ParamsNames.FEEDBACK_QUESTION_TEXT);
        if (questionText != null && !questionText.isEmpty()) {
            FeedbackQuestionDetails questionDetails = FeedbackQuestionDetails.createQuestionDetails(
                    requestParameters, newQuestion.questionType);
            newQuestion.setQuestionDetails(questionDetails);
        }

        String questionDescription = getRequestParamValue(Const.ParamsNames.FEEDBACK_QUESTION_DESCRIPTION);

        newQuestion.setQuestionDescription(new Text(questionDescription));

        return newQuestion;
    }

    private static boolean numberOfEntitiesIsUserDefined(FeedbackParticipantType recipientType, String nEntityTypes) {
        if (recipientType != FeedbackParticipantType.STUDENTS
                && recipientType != FeedbackParticipantType.TEAMS) {
            return false;
        }

        return ""custom"".equals(nEntityTypes);
    }

}
"
InstructorFeedbackQuestionVisibilityMessageAction.java,ui-controller,"package teammates.ui.controller;

import java.util.List;

import teammates.common.datatransfer.FeedbackParticipantType;
import teammates.common.datatransfer.attributes.FeedbackQuestionAttributes;
import teammates.common.datatransfer.questions.FeedbackQuestionType;
import teammates.common.util.Assumption;
import teammates.common.util.Const;
import teammates.ui.pagedata.InstructorFeedbackQuestionVisibilityMessagePageData;

public class InstructorFeedbackQuestionVisibilityMessageAction extends Action {
    @Override
    protected ActionResult execute() {
        FeedbackQuestionAttributes feedbackQuestion = extractFeedbackQuestionData(account.email);

        List<String> message = feedbackQuestion.getVisibilityMessage();

        InstructorFeedbackQuestionVisibilityMessagePageData data =
                new InstructorFeedbackQuestionVisibilityMessagePageData(account, sessionToken);
        data.visibilityMessage = message;

        return createAjaxResult(data);
    }

    private FeedbackQuestionAttributes extractFeedbackQuestionData(String creatorEmail) {
        FeedbackQuestionAttributes newQuestion = new FeedbackQuestionAttributes();

        newQuestion.creatorEmail = creatorEmail;

        String feedbackQuestionGiverType = getRequestParamValue(Const.ParamsNames.FEEDBACK_QUESTION_GIVERTYPE);

        Assumption.assertPostParamNotNull(Const.ParamsNames.FEEDBACK_QUESTION_GIVERTYPE, feedbackQuestionGiverType);

        newQuestion.giverType = FeedbackParticipantType.valueOf(feedbackQuestionGiverType);

        String feedbackQuestionRecipientType = getRequestParamValue(Const.ParamsNames.FEEDBACK_QUESTION_RECIPIENTTYPE);

        Assumption.assertPostParamNotNull(Const.ParamsNames.FEEDBACK_QUESTION_RECIPIENTTYPE, feedbackQuestionRecipientType);

        newQuestion.recipientType = FeedbackParticipantType.valueOf(feedbackQuestionRecipientType);

        String numberOfEntityTypes = getRequestParamValue(Const.ParamsNames.FEEDBACK_QUESTION_NUMBEROFENTITIESTYPE);

        Assumption.assertPostParamNotNull(Const.ParamsNames.FEEDBACK_QUESTION_NUMBEROFENTITIESTYPE, numberOfEntityTypes);

        if (""custom"".equals(numberOfEntityTypes)
                && (newQuestion.recipientType == FeedbackParticipantType.STUDENTS
                        || newQuestion.recipientType == FeedbackParticipantType.TEAMS)) {
            String numberOfEntities = getRequestParamValue(Const.ParamsNames.FEEDBACK_QUESTION_NUMBEROFENTITIES);

            Assumption.assertPostParamNotNull(Const.ParamsNames.FEEDBACK_QUESTION_NUMBEROFENTITIES, numberOfEntities);

            newQuestion.numberOfEntitiesToGiveFeedbackTo = Integer.parseInt(numberOfEntities);
        } else {
            newQuestion.numberOfEntitiesToGiveFeedbackTo = Const.MAX_POSSIBLE_RECIPIENTS;
        }

        newQuestion.showResponsesTo = FeedbackParticipantType.getParticipantListFromCommaSeparatedValues(
                getRequestParamValue(Const.ParamsNames.FEEDBACK_QUESTION_SHOWRESPONSESTO));
        newQuestion.showGiverNameTo = FeedbackParticipantType.getParticipantListFromCommaSeparatedValues(
                getRequestParamValue(Const.ParamsNames.FEEDBACK_QUESTION_SHOWGIVERTO));
        newQuestion.showRecipientNameTo = FeedbackParticipantType.getParticipantListFromCommaSeparatedValues(
                getRequestParamValue(Const.ParamsNames.FEEDBACK_QUESTION_SHOWRECIPIENTTO));

        String questionType = getRequestParamValue(Const.ParamsNames.FEEDBACK_QUESTION_TYPE);
        Assumption.assertPostParamNotNull(Const.ParamsNames.FEEDBACK_QUESTION_TYPE, questionType);
        questionType = FeedbackQuestionType.standardizeIfConstSum(questionType);

        newQuestion.questionType = FeedbackQuestionType.valueOf(questionType);
        newQuestion.removeIrrelevantVisibilityOptions();

        return newQuestion;
    }

}
"
InstructorFeedbackRemindAction.java,ui-controller,"package teammates.ui.controller;

import teammates.common.util.Const;
import teammates.common.util.StatusMessage;
import teammates.common.util.StatusMessageColor;

public class InstructorFeedbackRemindAction extends Action {

    @Override
    protected ActionResult execute() {
        String courseId = getRequestParamValue(Const.ParamsNames.COURSE_ID);
        String feedbackSessionName = getRequestParamValue(Const.ParamsNames.FEEDBACK_SESSION_NAME);
        String nextUrl = getRequestParamValue(Const.ParamsNames.NEXT_URL);

        if (nextUrl == null) {
            nextUrl = Const.ActionURIs.INSTRUCTOR_FEEDBACK_SESSIONS_PAGE;
        }

        gateKeeper.verifyAccessible(
                logic.getInstructorForGoogleId(courseId, account.googleId),
                logic.getFeedbackSession(feedbackSessionName, courseId),
                false, Const.ParamsNames.INSTRUCTOR_PERMISSION_MODIFY_SESSION);

        taskQueuer.scheduleFeedbackSessionReminders(courseId, feedbackSessionName);

        statusToUser.add(new StatusMessage(Const.StatusMessages.FEEDBACK_SESSION_REMINDERSSENT, StatusMessageColor.SUCCESS));
        statusToAdmin = ""Email sent out to all students who have not completed ""
                      + ""Feedback Session <span class=\""bold\"">("" + feedbackSessionName
                      + "")</span> "" + ""of Course <span class=\""bold\"">["" + courseId + ""]</span>"";

        return createRedirectResult(nextUrl);
    }

}
"
InstructorFeedbackRemindParticularStudentsAction.java,ui-controller,"package teammates.ui.controller;

import teammates.common.util.Const;
import teammates.common.util.StatusMessage;
import teammates.common.util.StatusMessageColor;

public class InstructorFeedbackRemindParticularStudentsAction extends Action {

    @Override
    protected ActionResult execute() {
        String courseId = getRequestParamValue(Const.ParamsNames.COURSE_ID);
        String feedbackSessionName = getRequestParamValue(Const.ParamsNames.FEEDBACK_SESSION_NAME);
        String nextUrl = getRequestParamValue(Const.ParamsNames.NEXT_URL);

        if (nextUrl == null) {
            nextUrl = Const.ActionURIs.INSTRUCTOR_FEEDBACK_SESSIONS_PAGE;
        }

        gateKeeper.verifyAccessible(
                logic.getInstructorForGoogleId(courseId, account.googleId),
                logic.getFeedbackSession(feedbackSessionName, courseId),
                false, Const.ParamsNames.INSTRUCTOR_PERMISSION_MODIFY_SESSION);

        String[] usersToRemind = getRequestParamValues(Const.ParamsNames.SUBMISSION_REMIND_USERLIST);
        if (usersToRemind == null || usersToRemind.length == 0) {
            statusToUser.add(new StatusMessage(Const.StatusMessages.FEEDBACK_SESSION_REMINDERSEMPTYRECIPIENT,
                                               StatusMessageColor.DANGER));
            return createRedirectResult(nextUrl);
        }

        taskQueuer.scheduleFeedbackSessionRemindersForParticularUsers(courseId, feedbackSessionName, usersToRemind);

        statusToUser.add(new StatusMessage(Const.StatusMessages.FEEDBACK_SESSION_REMINDERSSENT, StatusMessageColor.SUCCESS));
        statusToAdmin = ""Email sent out to the selected user(s): "";
        for (String user : usersToRemind) {
            statusToAdmin += ""<br>"" + user;
        }
        statusToAdmin += ""<br>in Feedback Session <span class=\""bold\"">("" + feedbackSessionName
                         + "")</span> "" + ""of Course <span class=\""bold\"">["" + courseId + ""]</span>"";

        return createRedirectResult(nextUrl);
    }
}
"
InstructorFeedbackRemindParticularStudentsPageAction.java,ui-controller,"package teammates.ui.controller;

import teammates.common.datatransfer.FeedbackSessionResponseStatus;
import teammates.common.datatransfer.attributes.FeedbackSessionAttributes;
import teammates.common.datatransfer.attributes.InstructorAttributes;
import teammates.common.exception.EntityDoesNotExistException;
import teammates.common.util.Assumption;
import teammates.common.util.Const;
import teammates.ui.pagedata.InstructorFeedbackRemindParticularStudentsPageData;

public class InstructorFeedbackRemindParticularStudentsPageAction extends Action {

    @Override
    protected ActionResult execute() throws EntityDoesNotExistException {
        String courseId = getRequestParamValue(Const.ParamsNames.COURSE_ID);
        Assumption.assertPostParamNotNull(Const.ParamsNames.COURSE_ID, courseId);

        String feedbackSessionName = getRequestParamValue(Const.ParamsNames.FEEDBACK_SESSION_NAME);
        Assumption.assertPostParamNotNull(Const.ParamsNames.FEEDBACK_SESSION_NAME, feedbackSessionName);

        FeedbackSessionAttributes fsa = logic.getFeedbackSession(feedbackSessionName, courseId);
        InstructorAttributes instructor = logic.getInstructorForGoogleId(courseId, account.googleId);
        gateKeeper.verifyAccessible(instructor, fsa, false);

        FeedbackSessionResponseStatus fsResponseStatus =
                logic.getFeedbackSessionResponseStatus(feedbackSessionName, courseId);

        InstructorFeedbackRemindParticularStudentsPageData data =
                new InstructorFeedbackRemindParticularStudentsPageData(account, sessionToken, fsResponseStatus,
                                                                       courseId, feedbackSessionName);

        return createShowPageResult(Const.ViewURIs.INSTRUCTOR_FEEDBACK_AJAX_REMIND_PARTICULAR_STUDENTS_MODAL, data);
    }

}
"
InstructorFeedbackResponseCommentAbstractAction.java,ui-controller,"package teammates.ui.controller;

import teammates.common.datatransfer.attributes.FeedbackResponseAttributes;
import teammates.common.datatransfer.attributes.FeedbackResponseCommentAttributes;
import teammates.common.datatransfer.attributes.FeedbackSessionAttributes;
import teammates.common.datatransfer.attributes.InstructorAttributes;
import teammates.common.util.Const;

public abstract class InstructorFeedbackResponseCommentAbstractAction extends Action {

    protected void verifyAccessibleForInstructorToFeedbackResponseComment(
            String feedbackResponseCommentId, InstructorAttributes instructor,
            FeedbackSessionAttributes session, FeedbackResponseAttributes response) {
        FeedbackResponseCommentAttributes frc =
                logic.getFeedbackResponseComment(Long.parseLong(feedbackResponseCommentId));
        if (frc == null) {
            return;
        }
        if (instructor != null && frc.giverEmail.equals(instructor.email)) { // giver, allowed by default
            return;
        }
        gateKeeper.verifyAccessible(instructor, session, false, response.giverSection,
                Const.ParamsNames.INSTRUCTOR_PERMISSION_MODIFY_SESSION_COMMENT_IN_SECTIONS);
        gateKeeper.verifyAccessible(instructor, session, false, response.recipientSection,
                Const.ParamsNames.INSTRUCTOR_PERMISSION_MODIFY_SESSION_COMMENT_IN_SECTIONS);
    }
}
"
InstructorFeedbackResponseCommentAddAction.java,ui-controller,"package teammates.ui.controller;

import java.util.ArrayList;
import java.util.Date;

import com.google.appengine.api.datastore.Text;

import teammates.common.datatransfer.FeedbackParticipantType;
import teammates.common.datatransfer.FeedbackSessionResultsBundle;
import teammates.common.datatransfer.attributes.FeedbackResponseAttributes;
import teammates.common.datatransfer.attributes.FeedbackResponseCommentAttributes;
import teammates.common.datatransfer.attributes.FeedbackSessionAttributes;
import teammates.common.datatransfer.attributes.InstructorAttributes;
import teammates.common.exception.EntityDoesNotExistException;
import teammates.common.exception.InvalidParametersException;
import teammates.common.util.Assumption;
import teammates.common.util.Const;
import teammates.common.util.StringHelper;
import teammates.ui.pagedata.InstructorFeedbackResponseCommentAjaxPageData;

/**
 * Action: Create a new {@link FeedbackResponseCommentAttributes}.
 */
public class InstructorFeedbackResponseCommentAddAction extends Action {

    @Override
    protected ActionResult execute() throws EntityDoesNotExistException {
        String courseId = getRequestParamValue(Const.ParamsNames.COURSE_ID);
        Assumption.assertPostParamNotNull(Const.ParamsNames.COURSE_ID, courseId);
        String feedbackSessionName = getRequestParamValue(Const.ParamsNames.FEEDBACK_SESSION_NAME);
        Assumption.assertPostParamNotNull(Const.ParamsNames.FEEDBACK_SESSION_NAME, feedbackSessionName);
        String feedbackQuestionId = getRequestParamValue(Const.ParamsNames.FEEDBACK_QUESTION_ID);
        Assumption.assertPostParamNotNull(Const.ParamsNames.FEEDBACK_QUESTION_ID, feedbackQuestionId);
        String feedbackResponseId = getRequestParamValue(Const.ParamsNames.FEEDBACK_RESPONSE_ID);
        Assumption.assertPostParamNotNull(Const.ParamsNames.FEEDBACK_RESPONSE_ID, feedbackResponseId);
        String commentId = getRequestParamValue(Const.ParamsNames.COMMENT_ID);
        Assumption.assertPostParamNotNull(Const.ParamsNames.COMMENT_ID, commentId);

        InstructorAttributes instructor = logic.getInstructorForGoogleId(courseId, account.googleId);
        FeedbackSessionAttributes session = logic.getFeedbackSession(feedbackSessionName, courseId);
        FeedbackResponseAttributes response = logic.getFeedbackResponse(feedbackResponseId);
        Assumption.assertNotNull(response);
        boolean isCreatorOnly = true;

        gateKeeper.verifyAccessible(instructor, session, !isCreatorOnly, response.giverSection,
                Const.ParamsNames.INSTRUCTOR_PERMISSION_SUBMIT_SESSION_IN_SECTIONS);
        gateKeeper.verifyAccessible(instructor, session, !isCreatorOnly, response.recipientSection,
                Const.ParamsNames.INSTRUCTOR_PERMISSION_SUBMIT_SESSION_IN_SECTIONS);

        InstructorFeedbackResponseCommentAjaxPageData data =
                new InstructorFeedbackResponseCommentAjaxPageData(account, sessionToken);

        String giverEmail = response.giver;
        String recipientEmail = response.recipient;
        FeedbackSessionResultsBundle bundle =
                logic.getFeedbackSessionResultsForInstructor(feedbackSessionName, courseId, instructor.email);

        String giverName = bundle.getGiverNameForResponse(response);
        String giverTeamName = bundle.getTeamNameForEmail(giverEmail);
        data.giverName = bundle.appendTeamNameToName(giverName, giverTeamName);

        String recipientName = bundle.getRecipientNameForResponse(response);
        String recipientTeamName = bundle.getTeamNameForEmail(recipientEmail);
        data.recipientName = bundle.appendTeamNameToName(recipientName, recipientTeamName);

        //Set up comment text
        String commentText = getRequestParamValue(Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_TEXT);
        Assumption.assertPostParamNotNull(Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_TEXT, commentText);
        if (commentText.trim().isEmpty()) {
            data.errorMessage = Const.StatusMessages.FEEDBACK_RESPONSE_COMMENT_EMPTY;
            data.isError = true;
            return createAjaxResult(data);
        }

        FeedbackResponseCommentAttributes feedbackResponseComment = new FeedbackResponseCommentAttributes(courseId,
                feedbackSessionName, feedbackQuestionId, instructor.email, feedbackResponseId, new Date(),
                new Text(commentText), response.giverSection, response.recipientSection);

        //Set up visibility settings
        String showCommentTo = getRequestParamValue(Const.ParamsNames.RESPONSE_COMMENTS_SHOWCOMMENTSTO);
        String showGiverNameTo = getRequestParamValue(Const.ParamsNames.RESPONSE_COMMENTS_SHOWGIVERTO);
        feedbackResponseComment.showCommentTo = new ArrayList<>();
        if (showCommentTo != null && !showCommentTo.isEmpty()) {
            String[] showCommentToArray = showCommentTo.split("","");
            for (String viewer : showCommentToArray) {
                feedbackResponseComment.showCommentTo.add(FeedbackParticipantType.valueOf(viewer.trim()));
            }
        }
        feedbackResponseComment.showGiverNameTo = new ArrayList<>();
        if (showGiverNameTo != null && !showGiverNameTo.isEmpty()) {
            String[] showGiverNameToArray = showGiverNameTo.split("","");
            for (String viewer : showGiverNameToArray) {
                feedbackResponseComment.showGiverNameTo.add(FeedbackParticipantType.valueOf(viewer.trim()));
            }
        }

        FeedbackResponseCommentAttributes createdComment = new FeedbackResponseCommentAttributes();
        try {
            createdComment = logic.createFeedbackResponseComment(feedbackResponseComment);
            logic.putDocument(createdComment);
        } catch (InvalidParametersException e) {
            setStatusForException(e);
            data.errorMessage = e.getMessage();
            data.isError = true;
        }

        if (!data.isError) {
            statusToAdmin += ""InstructorFeedbackResponseCommentAddAction:<br>""
                           + ""Adding comment to response: "" + feedbackResponseComment.feedbackResponseId + ""<br>""
                           + ""in course/feedback session: "" + feedbackResponseComment.courseId + ""/""
                           + feedbackResponseComment.feedbackSessionName + ""<br>""
                           + ""by: "" + feedbackResponseComment.giverEmail + "" at ""
                           + feedbackResponseComment.createdAt + ""<br>""
                           + ""comment text: "" + feedbackResponseComment.commentText.getValue();
        }

        data.comment = createdComment;
        data.commentId = commentId;
        data.showCommentToString = StringHelper.toString(createdComment.showCommentTo, "","");
        data.showGiverNameToString = StringHelper.toString(createdComment.showGiverNameTo, "","");
        data.instructorEmailNameTable = bundle.instructorEmailNameTable;
        data.question = logic.getFeedbackQuestion(feedbackQuestionId);
        data.sessionTimeZone = session.getTimeZone();

        return createShowPageResult(Const.ViewURIs.INSTRUCTOR_FEEDBACK_RESPONSE_COMMENTS_ADD, data);
    }

}
"
InstructorFeedbackResponseCommentDeleteAction.java,ui-controller,"package teammates.ui.controller;

import teammates.common.datatransfer.attributes.FeedbackResponseAttributes;
import teammates.common.datatransfer.attributes.FeedbackResponseCommentAttributes;
import teammates.common.datatransfer.attributes.FeedbackSessionAttributes;
import teammates.common.datatransfer.attributes.InstructorAttributes;
import teammates.common.util.Assumption;
import teammates.common.util.Const;
import teammates.ui.pagedata.InstructorFeedbackResponseCommentAjaxPageData;

/**
 * Action: Delete {@link FeedbackResponseCommentAttributes}.
 */
public class InstructorFeedbackResponseCommentDeleteAction extends InstructorFeedbackResponseCommentAbstractAction {

    @Override
    protected ActionResult execute() {
        String courseId = getRequestParamValue(Const.ParamsNames.COURSE_ID);
        Assumption.assertPostParamNotNull(Const.ParamsNames.COURSE_ID, courseId);
        String feedbackSessionName = getRequestParamValue(Const.ParamsNames.FEEDBACK_SESSION_NAME);
        Assumption.assertPostParamNotNull(Const.ParamsNames.FEEDBACK_SESSION_NAME, feedbackSessionName);
        String feedbackResponseId = getRequestParamValue(Const.ParamsNames.FEEDBACK_RESPONSE_ID);
        Assumption.assertPostParamNotNull(Const.ParamsNames.FEEDBACK_RESPONSE_ID, feedbackResponseId);
        String feedbackResponseCommentId = getRequestParamValue(Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_ID);
        Assumption.assertPostParamNotNull(Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_ID, feedbackResponseCommentId);

        InstructorAttributes instructor = logic.getInstructorForGoogleId(courseId, account.googleId);
        FeedbackSessionAttributes session = logic.getFeedbackSession(feedbackSessionName, courseId);
        FeedbackResponseAttributes response = logic.getFeedbackResponse(feedbackResponseId);
        Assumption.assertNotNull(response);

        verifyAccessibleForInstructorToFeedbackResponseComment(
                feedbackResponseCommentId, instructor, session, response);

        FeedbackResponseCommentAttributes feedbackResponseComment = new FeedbackResponseCommentAttributes();
        feedbackResponseComment.setId(Long.parseLong(feedbackResponseCommentId));

        logic.deleteDocument(feedbackResponseComment);
        logic.deleteFeedbackResponseComment(feedbackResponseComment);

        statusToAdmin += ""InstructorFeedbackResponseCommentDeleteAction:<br>""
                + ""Deleting feedback response comment: "" + feedbackResponseComment.getId() + ""<br>""
                + ""in course/feedback session: "" + courseId + ""/"" + feedbackSessionName + ""<br>"";

        InstructorFeedbackResponseCommentAjaxPageData data =
                new InstructorFeedbackResponseCommentAjaxPageData(account, sessionToken);

        return createAjaxResult(data);
    }
}
"
InstructorFeedbackResponseCommentEditAction.java,ui-controller,"package teammates.ui.controller;

import java.util.ArrayList;
import java.util.Date;

import com.google.appengine.api.datastore.Text;

import teammates.common.datatransfer.FeedbackParticipantType;
import teammates.common.datatransfer.attributes.FeedbackResponseAttributes;
import teammates.common.datatransfer.attributes.FeedbackResponseCommentAttributes;
import teammates.common.datatransfer.attributes.FeedbackSessionAttributes;
import teammates.common.datatransfer.attributes.InstructorAttributes;
import teammates.common.exception.EntityDoesNotExistException;
import teammates.common.exception.InvalidParametersException;
import teammates.common.util.Assumption;
import teammates.common.util.Const;
import teammates.ui.pagedata.InstructorFeedbackResponseCommentAjaxPageData;

/**
 * Action: Edit {@link FeedbackResponseCommentAttributes}.
 */
public class InstructorFeedbackResponseCommentEditAction extends InstructorFeedbackResponseCommentAbstractAction {
    @Override
    protected ActionResult execute() throws EntityDoesNotExistException {
        String courseId = getRequestParamValue(Const.ParamsNames.COURSE_ID);
        Assumption.assertPostParamNotNull(Const.ParamsNames.COURSE_ID, courseId);
        String feedbackSessionName = getRequestParamValue(Const.ParamsNames.FEEDBACK_SESSION_NAME);
        Assumption.assertPostParamNotNull(Const.ParamsNames.FEEDBACK_SESSION_NAME, feedbackSessionName);
        String feedbackResponseId = getRequestParamValue(Const.ParamsNames.FEEDBACK_RESPONSE_ID);
        Assumption.assertPostParamNotNull(Const.ParamsNames.FEEDBACK_RESPONSE_ID, feedbackResponseId);
        String feedbackResponseCommentId = getRequestParamValue(Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_ID);
        Assumption.assertPostParamNotNull(Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_ID, feedbackResponseCommentId);

        InstructorAttributes instructor = logic.getInstructorForGoogleId(courseId, account.googleId);
        FeedbackSessionAttributes session = logic.getFeedbackSession(feedbackSessionName, courseId);
        FeedbackResponseAttributes response = logic.getFeedbackResponse(feedbackResponseId);
        Assumption.assertNotNull(response);

        FeedbackResponseCommentAttributes frc =
                logic.getFeedbackResponseComment(Long.parseLong(feedbackResponseCommentId));
        Assumption.assertNotNull(""FeedbackResponseComment should not be null"", frc);
        verifyAccessibleForInstructorToFeedbackResponseComment(
                feedbackResponseCommentId, instructor, session, response);

        InstructorFeedbackResponseCommentAjaxPageData data =
                new InstructorFeedbackResponseCommentAjaxPageData(account, sessionToken);

        //Edit comment text
        String commentText = getRequestParamValue(Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_TEXT);
        Assumption.assertPostParamNotNull(Const.ParamsNames.FEEDBACK_RESPONSE_COMMENT_TEXT, commentText);
        if (commentText.trim().isEmpty()) {
            data.errorMessage = Const.StatusMessages.FEEDBACK_RESPONSE_COMMENT_EMPTY;
            data.isError = true;
            return createAjaxResult(data);
        }

        FeedbackResponseCommentAttributes feedbackResponseComment = new FeedbackResponseCommentAttributes(
                courseId, feedbackSessionName, null, instructor.email, null, new Date(),
                new Text(commentText), response.giverSection, response.recipientSection);
        feedbackResponseComment.setId(Long.parseLong(feedbackResponseCommentId));

        //Edit visibility settings
        String showCommentTo = getRequestParamValue(Const.ParamsNames.RESPONSE_COMMENTS_SHOWCOMMENTSTO);
        String showGiverNameTo = getRequestParamValue(Const.ParamsNames.RESPONSE_COMMENTS_SHOWGIVERTO);
        feedbackResponseComment.showCommentTo = new ArrayList<>();
        if (showCommentTo != null && !showCommentTo.isEmpty()) {
            String[] showCommentToArray = showCommentTo.split("","");
            for (String viewer : showCommentToArray) {
                feedbackResponseComment.showCommentTo.add(FeedbackParticipantType.valueOf(viewer.trim()));
            }
        }
        feedbackResponseComment.showGiverNameTo = new ArrayList<>();
        if (showGiverNameTo != null && !showGiverNameTo.isEmpty()) {
            String[] showGiverNameToArray = showGiverNameTo.split("","");
            for (String viewer : showGiverNameToArray) {
                feedbackResponseComment.showGiverNameTo.add(FeedbackParticipantType.valueOf(viewer.trim()));
            }
        }

        FeedbackResponseCommentAttributes updatedComment = null;
        try {
            updatedComment = logic.updateFeedbackResponseComment(feedbackResponseComment);
            //TODO: move putDocument to task queue
            logic.putDocument(updatedComment);
        } catch (InvalidParametersException e) {
            setStatusForException(e);
            data.errorMessage = e.getMessage();
            data.isError = true;
        }

        if (!data.isError) {
            statusToAdmin += ""InstructorFeedbackResponseCommentEditAction:<br>""
                           + ""Editing feedback response comment: "" + feedbackResponseComment.getId() + ""<br>""
                           + ""in course/feedback session: "" + feedbackResponseComment.courseId + ""/""
                           + feedbackResponseComment.feedbackSessionName + ""<br>""
                           + ""by: "" + feedbackResponseComment.giverEmail + ""<br>""
                           + ""comment text: "" + feedbackResponseComment.commentText.getValue();

            String commentGiverName = logic.getInstructorForEmail(courseId, frc.giverEmail).name;
            String commentEditorName = instructor.name;

            // createdAt and lastEditedAt fields in updatedComment as well as sessionTimeZone
            // are required to generate timestamps in editedCommentDetails
            data.comment = updatedComment;
            data.sessionTimeZone = session.getTimeZone();

            data.editedCommentDetails = data.createEditedCommentDetails(commentGiverName, commentEditorName);
        }

        return createAjaxResult(data);
    }
}
"
InstructorFeedbackResultsDownloadAction.java,ui-controller,"package teammates.ui.controller;

import teammates.common.datatransfer.attributes.FeedbackSessionAttributes;
import teammates.common.datatransfer.attributes.InstructorAttributes;
import teammates.common.exception.EntityDoesNotExistException;
import teammates.common.exception.ExceedingRangeException;
import teammates.common.util.Assumption;
import teammates.common.util.Const;
import teammates.common.util.StatusMessage;
import teammates.common.util.StatusMessageColor;

public class InstructorFeedbackResultsDownloadAction extends Action {

    @Override
    protected ActionResult execute() throws EntityDoesNotExistException {
        String courseId = getRequestParamValue(Const.ParamsNames.COURSE_ID);
        String feedbackSessionName = getRequestParamValue(Const.ParamsNames.FEEDBACK_SESSION_NAME);
        String section = getRequestParamValue(Const.ParamsNames.SECTION_NAME);
        boolean isMissingResponsesShown = getRequestParamAsBoolean(
                Const.ParamsNames.FEEDBACK_RESULTS_INDICATE_MISSING_RESPONSES);
        boolean isStatsShown = getRequestParamAsBoolean(Const.ParamsNames.FEEDBACK_RESULTS_SHOWSTATS);
        String questionId = getRequestParamValue(Const.ParamsNames.FEEDBACK_QUESTION_ID);
        String questionNumber = getRequestParamValue(Const.ParamsNames.FEEDBACK_QUESTION_NUMBER);

        Assumption.assertPostParamNotNull(Const.ParamsNames.COURSE_ID, courseId);
        Assumption.assertPostParamNotNull(Const.ParamsNames.FEEDBACK_SESSION_NAME, feedbackSessionName);

        InstructorAttributes instructor = logic.getInstructorForGoogleId(courseId, account.googleId);
        FeedbackSessionAttributes session = logic.getFeedbackSession(feedbackSessionName, courseId);
        boolean isCreatorOnly = true;

        gateKeeper.verifyAccessible(instructor, session, !isCreatorOnly);

        String fileContent;
        String fileName;

        try {
            String questionName = """";
            if (questionNumber != null) {
                questionName = ""_question"" + questionNumber;
            }

            if (section == null || ""All"".equals(section)) {
                fileContent = logic.getFeedbackSessionResultSummaryAsCsv(
                        courseId, feedbackSessionName, instructor.email,
                        isMissingResponsesShown, isStatsShown, questionId);

                fileName = courseId + ""_"" + feedbackSessionName + questionName;
                statusToAdmin = ""Summary data for Feedback Session "" + feedbackSessionName
                              + "" in Course "" + courseId + "" was downloaded"";
            } else {
                fileContent = logic.getFeedbackSessionResultSummaryInSectionAsCsv(
                        courseId, feedbackSessionName, instructor.email, section,
                        questionId, isMissingResponsesShown, isStatsShown);
                fileName = courseId + ""_"" + feedbackSessionName + ""_"" + section + questionName;
                statusToAdmin = ""Summary data for Feedback Session "" + feedbackSessionName
                              + "" in Course "" + courseId + "" within "" + section + "" was downloaded"";
            }
        } catch (ExceedingRangeException e) {
            // not tested as the test file is not large enough to reach this catch block
            statusToUser.add(new StatusMessage(""This session has more responses than that can be downloaded in one go. ""
                        + ""Please download responses for ""
                        + (questionNumber == null ? ""one question at a time instead. ""
                        + ""To download responses for a specific question, click on the corresponding question number.""
                                                 : ""section instead.""),
                                                 StatusMessageColor.DANGER));
            isError = true;
            RedirectResult result = createRedirectResult(Const.ActionURIs.INSTRUCTOR_FEEDBACK_RESULTS_PAGE);
            result.addResponseParam(Const.ParamsNames.COURSE_ID, courseId);
            result.addResponseParam(Const.ParamsNames.FEEDBACK_SESSION_NAME, feedbackSessionName);
            return result;
        }

        return createFileDownloadResult(fileName, fileContent);
    }

}
"
InstructorFeedbackResultsPageAction.java,ui-controller,"package teammates.ui.controller;

import teammates.common.datatransfer.FeedbackSessionResultsBundle;
import teammates.common.datatransfer.attributes.FeedbackSessionAttributes;
import teammates.common.datatransfer.attributes.InstructorAttributes;
import teammates.common.exception.EntityDoesNotExistException;
import teammates.common.exception.ExceedingRangeException;
import teammates.common.util.Assumption;
import teammates.common.util.Const;
import teammates.common.util.StatusMessage;
import teammates.common.util.StatusMessageColor;
import teammates.common.util.StringHelper;
import teammates.ui.datatransfer.InstructorFeedbackResultsPageViewType;
import teammates.ui.pagedata.InstructorFeedbackResultsPageData;

public class InstructorFeedbackResultsPageAction extends Action {

    private static final String ALL_SECTION_OPTION = ""All"";
    private static final int DEFAULT_SECTION_QUERY_RANGE = 2500;

    @Override
    protected ActionResult execute() throws EntityDoesNotExistException {

        String courseId = getRequestParamValue(Const.ParamsNames.COURSE_ID);
        String feedbackSessionName = getRequestParamValue(Const.ParamsNames.FEEDBACK_SESSION_NAME);
        String showStats = getRequestParamValue(Const.ParamsNames.FEEDBACK_RESULTS_SHOWSTATS);

        Assumption.assertPostParamNotNull(Const.ParamsNames.COURSE_ID, courseId);
        Assumption.assertPostParamNotNull(Const.ParamsNames.FEEDBACK_SESSION_NAME, feedbackSessionName);

        statusToAdmin = ""Show instructor feedback result page<br>""
                      + ""Session Name: "" + feedbackSessionName + ""<br>""
                      + ""Course ID: "" + courseId;

        InstructorAttributes instructor = logic.getInstructorForGoogleId(courseId, account.googleId);
        FeedbackSessionAttributes session = logic.getFeedbackSession(feedbackSessionName, courseId);
        boolean isCreatorOnly = true;

        gateKeeper.verifyAccessible(instructor, session, !isCreatorOnly);

        InstructorFeedbackResultsPageData data = new InstructorFeedbackResultsPageData(account, sessionToken);
        String selectedSection = getRequestParamValue(Const.ParamsNames.FEEDBACK_RESULTS_GROUPBYSECTION);

        if (selectedSection == null) {
            selectedSection = ALL_SECTION_OPTION;
        }

        boolean isMissingResponsesShown = getRequestParamAsBoolean(
                Const.ParamsNames.FEEDBACK_RESULTS_INDICATE_MISSING_RESPONSES);

        // this is for ajax loading of the html table in the modal
        // ""(Non-English characters not displayed properly in the downloaded file? click here)""
        // TODO move into another action and another page data class
        boolean isLoadingCsvResultsAsHtml = getRequestParamAsBoolean(Const.ParamsNames.CSV_TO_HTML_TABLE_NEEDED);
        if (isLoadingCsvResultsAsHtml) {
            return createAjaxResultForCsvTableLoadedInHtml(
                    courseId, feedbackSessionName, instructor, data, selectedSection,
                    isMissingResponsesShown, Boolean.valueOf(showStats));
        }
        data.setSessionResultsHtmlTableAsString("""");
        data.setAjaxStatus("""");

        String groupByTeam = getRequestParamValue(Const.ParamsNames.FEEDBACK_RESULTS_GROUPBYTEAM);
        String sortType = getRequestParamValue(Const.ParamsNames.FEEDBACK_RESULTS_SORTTYPE);
        String startIndex = getRequestParamValue(Const.ParamsNames.FEEDBACK_RESULTS_MAIN_INDEX);

        if (startIndex != null) {
            data.setStartIndex(Integer.parseInt(startIndex));
        }

        if (sortType == null) {
            // default view: sort by question, statistics shown, grouped by team.
            showStats = ""on"";
            groupByTeam = ""on"";
            sortType = Const.FeedbackSessionResults.QUESTION_SORT_TYPE;
            isMissingResponsesShown = true;
        }

        String questionId = getRequestParamValue(Const.ParamsNames.FEEDBACK_QUESTION_ID);
        String isTestingAjax = getRequestParamValue(Const.ParamsNames.FEEDBACK_RESULTS_NEED_AJAX);

        if (ALL_SECTION_OPTION.equals(selectedSection) && questionId == null
                && !Const.FeedbackSessionResults.QUESTION_SORT_TYPE.equals(sortType)) {
            // bundle for all questions and all sections
            data.setBundle(
                     logic.getFeedbackSessionResultsForInstructorWithinRangeFromView(
                                                                           feedbackSessionName, courseId,
                                                                           instructor.email,
                                                                           DEFAULT_SECTION_QUERY_RANGE, sortType));
        } else if (Const.FeedbackSessionResults.QUESTION_SORT_TYPE.equals(sortType)) {
            data.setBundle(getBundleForQuestionView(isTestingAjax, courseId, feedbackSessionName, instructor, data,
                                                    selectedSection, sortType, questionId));
        } else if (Const.FeedbackSessionResults.GQR_SORT_TYPE.equals(sortType)
                || Const.FeedbackSessionResults.GRQ_SORT_TYPE.equals(sortType)) {
            data.setBundle(logic
                    .getFeedbackSessionResultsForInstructorFromSectionWithinRange(feedbackSessionName, courseId,
                                                                                  instructor.email,
                                                                                  selectedSection,
                                                                                  DEFAULT_SECTION_QUERY_RANGE));
        } else if (Const.FeedbackSessionResults.RQG_SORT_TYPE.equals(sortType)
                || Const.FeedbackSessionResults.RGQ_SORT_TYPE.equals(sortType)) {
            data.setBundle(logic
                    .getFeedbackSessionResultsForInstructorToSectionWithinRange(feedbackSessionName, courseId,
                                                                                instructor.email,
                                                                                selectedSection,
                                                                                DEFAULT_SECTION_QUERY_RANGE));
        }

        if (data.getBundle() == null) {
            throw new EntityDoesNotExistException(""Feedback session "" + feedbackSessionName
                                                  + "" does not exist in "" + courseId + ""."");
        }

        // Warning for section wise viewing in case of many responses.
        boolean isShowSectionWarningForQuestionView = data.isLargeNumberOfRespondents()
                                                   && Const.FeedbackSessionResults.QUESTION_SORT_TYPE.equals(sortType);
        boolean isShowSectionWarningForParticipantView = !data.getBundle().isComplete
                                                   && !Const.FeedbackSessionResults.QUESTION_SORT_TYPE.equals(sortType);

        // Warning for section wise does not make sense if there are no multiple sections.
        boolean isMultipleSectionAvailable = data.getBundle().getRosterSectionTeamNameTable().size() > 1;

        if (selectedSection.equals(ALL_SECTION_OPTION) && (isShowSectionWarningForParticipantView
                                                           || isShowSectionWarningForQuestionView)) {
            if (isMultipleSectionAvailable) {
                statusToUser.add(new StatusMessage(Const.StatusMessages.FEEDBACK_RESULTS_SECTIONVIEWWARNING,
                                                   StatusMessageColor.WARNING));
            } else {
                statusToUser.add(new StatusMessage(Const.StatusMessages.FEEDBACK_RESULTS_QUESTIONVIEWWARNING,
                                                   StatusMessageColor.WARNING));
            }
            isError = true;
        }

        switch (sortType) {
        case Const.FeedbackSessionResults.QUESTION_SORT_TYPE:
            data.initForViewByQuestion(instructor, selectedSection, showStats, groupByTeam, isMissingResponsesShown);
            return createShowPageResult(
                    Const.ViewURIs.INSTRUCTOR_FEEDBACK_RESULTS_BY_QUESTION, data);
        case Const.FeedbackSessionResults.RGQ_SORT_TYPE:
            data.initForSectionPanelViews(instructor, selectedSection, showStats, groupByTeam,
                                          InstructorFeedbackResultsPageViewType.RECIPIENT_GIVER_QUESTION,
                                          isMissingResponsesShown);
            return createShowPageResult(
                    Const.ViewURIs.INSTRUCTOR_FEEDBACK_RESULTS_BY_RECIPIENT_GIVER_QUESTION, data);
        case Const.FeedbackSessionResults.GRQ_SORT_TYPE:
            data.initForSectionPanelViews(instructor, selectedSection, showStats, groupByTeam,
                                          InstructorFeedbackResultsPageViewType.GIVER_RECIPIENT_QUESTION,
                                          isMissingResponsesShown);
            return createShowPageResult(
                    Const.ViewURIs.INSTRUCTOR_FEEDBACK_RESULTS_BY_GIVER_RECIPIENT_QUESTION, data);
        case Const.FeedbackSessionResults.RQG_SORT_TYPE:
            data.initForSectionPanelViews(instructor, selectedSection, showStats, groupByTeam,
                                          InstructorFeedbackResultsPageViewType.RECIPIENT_QUESTION_GIVER,
                                          isMissingResponsesShown);
            return createShowPageResult(
                    Const.ViewURIs.INSTRUCTOR_FEEDBACK_RESULTS_BY_RECIPIENT_QUESTION_GIVER, data);
        case Const.FeedbackSessionResults.GQR_SORT_TYPE:
            data.initForSectionPanelViews(instructor, selectedSection, showStats, groupByTeam,
                                          InstructorFeedbackResultsPageViewType.GIVER_QUESTION_RECIPIENT,
                                          isMissingResponsesShown);
            return createShowPageResult(
                    Const.ViewURIs.INSTRUCTOR_FEEDBACK_RESULTS_BY_GIVER_QUESTION_RECIPIENT, data);
        default:
            sortType = Const.FeedbackSessionResults.RGQ_SORT_TYPE;
            data.initForSectionPanelViews(instructor, selectedSection, showStats, groupByTeam,
                                          InstructorFeedbackResultsPageViewType.RECIPIENT_GIVER_QUESTION,
                                          isMissingResponsesShown);
            return createShowPageResult(
                    Const.ViewURIs.INSTRUCTOR_FEEDBACK_RESULTS_BY_RECIPIENT_GIVER_QUESTION, data);
        }
    }

    private FeedbackSessionResultsBundle getBundleForQuestionView(
            String needAjax, String courseId, String feedbackSessionName, InstructorAttributes instructor,
            InstructorFeedbackResultsPageData data, String selectedSection, String sortType, String questionId)
                    throws EntityDoesNotExistException {
        FeedbackSessionResultsBundle bundle;
        if (questionId == null) {
            if (ALL_SECTION_OPTION.equals(selectedSection)) {
                // load page structure without responses

                data.setLargeNumberOfRespondents(needAjax != null);

                // all sections and all questions for question view
                // set up question tables, responses to load by ajax
                bundle = logic.getFeedbackSessionResultsForInstructorWithinRangeFromView(
                                               feedbackSessionName, courseId,
                                               instructor.email,
                                               1, sortType);
                // set isComplete to true to prevent behavior when there are too many responses,
                // such as the display of warning messages
                bundle.isComplete = true;
            } else {
                // bundle for all questions, with a selected section
                bundle = logic.getFeedbackSessionResultsForInstructorInSection(feedbackSessionName, courseId,
                                                                                    instructor.email,
                                                                                    selectedSection);
            }
        } else {
            if (ALL_SECTION_OPTION.equals(selectedSection)) {
                // bundle for a specific question, with all sections
                bundle = logic.getFeedbackSessionResultsForInstructorFromQuestion(feedbackSessionName, courseId,
                                                                                  instructor.email, questionId);
            } else {
                // bundle for a specific question and a specific section
                bundle = logic.getFeedbackSessionResultsForInstructorFromQuestionInSection(
                                                feedbackSessionName, courseId,
                                                instructor.email, questionId, selectedSection);
            }
        }

        return bundle;
    }

    private ActionResult createAjaxResultForCsvTableLoadedInHtml(String courseId, String feedbackSessionName,
                                    InstructorAttributes instructor, InstructorFeedbackResultsPageData data,
                                    String selectedSection, boolean isMissingResponsesShown,
                                    boolean isStatsShown)
                                    throws EntityDoesNotExistException {
        try {
            if (selectedSection.contentEquals(ALL_SECTION_OPTION)) {
                data.setSessionResultsHtmlTableAsString(
                        StringHelper.csvToHtmlTable(
                                logic.getFeedbackSessionResultSummaryAsCsv(
                                        courseId, feedbackSessionName, instructor.email,
                                        isMissingResponsesShown, isStatsShown, null)));
            } else {
                data.setSessionResultsHtmlTableAsString(
                        StringHelper.csvToHtmlTable(
                                logic.getFeedbackSessionResultSummaryInSectionAsCsv(
                                        courseId, feedbackSessionName, instructor.email,
                                        selectedSection, null, isMissingResponsesShown, isStatsShown)));
            }
        } catch (ExceedingRangeException e) {
            // not tested as the test file is not large enough to reach this catch block
            data.setSessionResultsHtmlTableAsString("""");
            data.setAjaxStatus(""There are too many responses. Please download the feedback results by section."");
        }

        return createAjaxResult(data);
    }

}
"
InstructorFeedbackSessionsPageAction.java,ui-controller,"package teammates.ui.controller;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;

import teammates.common.datatransfer.attributes.CourseAttributes;
import teammates.common.datatransfer.attributes.FeedbackSessionAttributes;
import teammates.common.datatransfer.attributes.InstructorAttributes;
import teammates.common.util.Const;
import teammates.common.util.StatusMessage;
import teammates.common.util.StatusMessageColor;
import teammates.ui.pagedata.InstructorFeedbackSessionsPageData;

public class InstructorFeedbackSessionsPageAction extends InstructorFeedbackAbstractAction {

    @Override
    protected ActionResult execute() {
        // This can be null. Non-null value indicates the page is being loaded
        // to add a feedback to the specified course
        String courseIdForNewSession = getRequestParamValue(Const.ParamsNames.COURSE_ID);
        String feedbackSessionToHighlight = getRequestParamValue(Const.ParamsNames.FEEDBACK_SESSION_NAME);
        String isUsingAjax = getRequestParamValue(Const.ParamsNames.IS_USING_AJAX);

        gateKeeper.verifyInstructorPrivileges(account);

        if (courseIdForNewSession != null) {
            gateKeeper.verifyAccessible(
                    logic.getInstructorForGoogleId(courseIdForNewSession, account.googleId),
                    logic.getCourse(courseIdForNewSession),
                    Const.ParamsNames.INSTRUCTOR_PERMISSION_MODIFY_SESSION);
        }

        InstructorFeedbackSessionsPageData data = new InstructorFeedbackSessionsPageData(account, sessionToken);
        data.setUsingAjax(isUsingAjax != null);

        boolean shouldOmitArchived = true; // TODO: implement as a request parameter
        // HashMap with courseId as key and InstructorAttributes as value
        Map<String, InstructorAttributes> instructors = loadCourseInstructorMap(shouldOmitArchived);

        List<InstructorAttributes> instructorList = new ArrayList<>(instructors.values());
        List<CourseAttributes> courses = loadCoursesList(instructorList);

        List<FeedbackSessionAttributes> existingFeedbackSessions;
        if (courses.isEmpty() || !data.isUsingAjax()) {
            existingFeedbackSessions = new ArrayList<>();
        } else {
            existingFeedbackSessions = loadFeedbackSessionsList(instructorList);
            if (existingFeedbackSessions.isEmpty()) {
                statusToUser.add(new StatusMessage(Const.StatusMessages.FEEDBACK_SESSION_EMPTY, StatusMessageColor.WARNING));
            }
        }

        if (courses.isEmpty()) {
            statusToUser.add(new StatusMessage(Const.StatusMessages.COURSE_EMPTY_IN_INSTRUCTOR_FEEDBACKS
                                                       .replace(""${user}"", ""?user="" + account.googleId),
                                               StatusMessageColor.WARNING));
        }

        statusToAdmin = ""Number of feedback sessions: "" + existingFeedbackSessions.size();

        data.initWithoutDefaultFormValues(courses, courseIdForNewSession, existingFeedbackSessions,
                                        instructors, feedbackSessionToHighlight);

        return createShowPageResult(Const.ViewURIs.INSTRUCTOR_FEEDBACK_SESSIONS, data);
    }
}
"
InstructorFeedbackSubmissionEditPageAction.java,ui-controller,"package teammates.ui.controller;

import teammates.common.datatransfer.FeedbackSessionQuestionsBundle;
import teammates.common.datatransfer.attributes.FeedbackSessionAttributes;
import teammates.common.datatransfer.attributes.InstructorAttributes;
import teammates.common.exception.EntityDoesNotExistException;
import teammates.common.exception.UnauthorizedAccessException;
import teammates.common.util.Const;

public class InstructorFeedbackSubmissionEditPageAction extends FeedbackSubmissionEditPageAction {

    @Override
    protected boolean isSpecificUserJoinedCourse() {
        // Instructor is always already joined
        return true;
    }

    @Override
    protected void verifyAccessibleForSpecificUser(FeedbackSessionAttributes session) {
        InstructorAttributes instructor = logic.getInstructorForGoogleId(courseId, account.googleId);
        boolean isCreatorOnly = false;
        gateKeeper.verifyAccessible(instructor, session, isCreatorOnly);
        boolean shouldEnableSubmit =
                    instructor.isAllowedForPrivilege(Const.ParamsNames.INSTRUCTOR_PERMISSION_SUBMIT_SESSION_IN_SECTIONS);

        if (!shouldEnableSubmit && instructor.isAllowedForPrivilegeAnySection(session.getFeedbackSessionName(),
                                        Const.ParamsNames.INSTRUCTOR_PERMISSION_SUBMIT_SESSION_IN_SECTIONS)) {
            shouldEnableSubmit = true;
        }

        if (!shouldEnableSubmit) {
            throw new UnauthorizedAccessException(""Feedback session ["" + session.getFeedbackSessionName()
                                                  + ""] is not accessible to instructor [""
                                                  + instructor.email + ""] for this purpose"");
        }
    }

    @Override
    protected String getUserEmailForCourse() {
        return logic.getInstructorForGoogleId(courseId, account.googleId).email;
    }

    @Override
    protected FeedbackSessionQuestionsBundle getDataBundle(String userEmailForCourse) throws EntityDoesNotExistException {
        return logic.getFeedbackSessionQuestionsBundleForInstructor(
                             feedbackSessionName, courseId, userEmailForCourse);
    }

    @Override
    protected boolean isSessionOpenForSpecificUser(FeedbackSessionAttributes session) {
        return session.isOpened() || session.isPrivateSession();
    }

    @Override
    protected void setStatusToAdmin() {
        statusToAdmin = ""Show instructor feedback submission edit page<br>""
                        + ""Session Name: "" + feedbackSessionName + ""<br>""
                        + ""Course ID: "" + courseId;
    }

    @Override
    protected ShowPageResult createSpecificShowPageResult() {
        data.setSubmitAction(Const.ActionURIs.INSTRUCTOR_FEEDBACK_SUBMISSION_EDIT_SAVE);

        return createShowPageResult(Const.ViewURIs.INSTRUCTOR_FEEDBACK_SUBMISSION_EDIT, data);
    }

    @Override
    protected RedirectResult createSpecificRedirectResult() {
        return createRedirectResult(Const.ActionURIs.INSTRUCTOR_HOME_PAGE);
    }
}
"
InstructorFeedbackSubmissionEditSaveAction.java,ui-controller,"package teammates.ui.controller;

import teammates.common.datatransfer.FeedbackSessionQuestionsBundle;
import teammates.common.datatransfer.attributes.FeedbackSessionAttributes;
import teammates.common.datatransfer.attributes.InstructorAttributes;
import teammates.common.exception.EntityDoesNotExistException;
import teammates.common.exception.InvalidParametersException;
import teammates.common.exception.UnauthorizedAccessException;
import teammates.common.util.Const;
import teammates.common.util.Logger;

public class InstructorFeedbackSubmissionEditSaveAction extends FeedbackSubmissionEditSaveAction {

    private static final Logger log = Logger.getLogger();

    @Override
    protected void verifyAccessibleForSpecificUser() {
        InstructorAttributes instructor = logic.getInstructorForGoogleId(courseId, account.googleId);
        FeedbackSessionAttributes session = logic.getFeedbackSession(feedbackSessionName, courseId);
        boolean isCreatorOnly = false;
        gateKeeper.verifyAccessible(instructor, session, isCreatorOnly);
        boolean shouldEnableSubmit =
                    instructor.isAllowedForPrivilege(Const.ParamsNames.INSTRUCTOR_PERMISSION_SUBMIT_SESSION_IN_SECTIONS);

        if (!shouldEnableSubmit && instructor.isAllowedForPrivilegeAnySection(session.getFeedbackSessionName(),
                                             Const.ParamsNames.INSTRUCTOR_PERMISSION_SUBMIT_SESSION_IN_SECTIONS)) {
            shouldEnableSubmit = true;
        }

        if (!shouldEnableSubmit) {
            throw new UnauthorizedAccessException(""Feedback session ["" + session.getFeedbackSessionName()
                                                  + ""] is not accessible to instructor [""
                                                  + instructor.email + ""] for this purpose"");
        }
    }

    @Override
    protected void appendRespondent() {
        try {
            logic.addInstructorRespondent(getUserEmailForCourse(), feedbackSessionName, courseId);
        } catch (InvalidParametersException | EntityDoesNotExistException e) {
            log.severe(""Fail to append instructor respondent"");
        }
    }

    @Override
    protected void removeRespondent() {
        try {
            logic.deleteInstructorRespondent(getUserEmailForCourse(), feedbackSessionName, courseId);
        } catch (InvalidParametersException | EntityDoesNotExistException e) {
            log.severe(""Fail to remove instructor respondent"");
        }
    }

    @Override
    protected String getUserEmailForCourse() {
        return logic.getInstructorForGoogleId(courseId, account.googleId).email;
    }

    @Override
    protected String getUserTeamForCourse() {
        return Const.USER_TEAM_FOR_INSTRUCTOR;
    }

    @Override
    protected String getUserSectionForCourse() {
        return Const.DEFAULT_SECTION;
    }

    @Override
    protected FeedbackSessionQuestionsBundle getDataBundle(String userEmailForCourse) throws EntityDoesNotExistException {
        return logic.getFeedbackSessionQuestionsBundleForInstructor(
                             feedbackSessionName, courseId, userEmailForCourse);
    }

    @Override
    protected void setStatusToAdmin() {
        statusToAdmin = ""Show instructor feedback submission edit&save page<br>""
                        + ""Session Name: "" + feedbackSessionName + ""<br>""
                        + ""Course ID: "" + courseId;
    }

    @Override
    protected boolean isSessionOpenForSpecificUser(FeedbackSessionAttributes session) {
        return session.isOpened() || session.isPrivateSession() || session.isInGracePeriod();
    }

    @Override
    protected RedirectResult createSpecificRedirectResult() {
        return createRedirectResult(Const.ActionURIs.INSTRUCTOR_HOME_PAGE);
    }

    @Override
    protected void setAdditionalParameters() {
        isSendSubmissionEmail = true;
    }

    @Override
    protected void checkAdditionalConstraints() {
        // no additional constraints for the standard instructor submit page
    }
}
"
InstructorFeedbackUnpublishAction.java,ui-controller,"package teammates.ui.controller;

import teammates.common.datatransfer.attributes.FeedbackSessionAttributes;
import teammates.common.datatransfer.attributes.InstructorAttributes;
import teammates.common.exception.EntityDoesNotExistException;
import teammates.common.exception.InvalidParametersException;
import teammates.common.util.Assumption;
import teammates.common.util.Const;
import teammates.common.util.StatusMessage;
import teammates.common.util.StatusMessageColor;

public class InstructorFeedbackUnpublishAction extends Action {
    @Override
    protected ActionResult execute() throws EntityDoesNotExistException {
        String courseId = getRequestParamValue(Const.ParamsNames.COURSE_ID);
        String feedbackSessionName = getRequestParamValue(Const.ParamsNames.FEEDBACK_SESSION_NAME);
        String nextUrl = getRequestParamValue(Const.ParamsNames.NEXT_URL);

        Assumption.assertPostParamNotNull(Const.ParamsNames.COURSE_ID, courseId);
        Assumption.assertPostParamNotNull(Const.ParamsNames.FEEDBACK_SESSION_NAME, feedbackSessionName);

        InstructorAttributes instructor = logic.getInstructorForGoogleId(courseId, account.googleId);
        FeedbackSessionAttributes session = logic.getFeedbackSession(feedbackSessionName, courseId);
        boolean isCreatorOnly = false;

        gateKeeper.verifyAccessible(
                instructor, session, isCreatorOnly, Const.ParamsNames.INSTRUCTOR_PERMISSION_MODIFY_SESSION);

        try {
            logic.unpublishFeedbackSession(session);
            if (session.isPublishedEmailEnabled()) {
                taskQueuer.scheduleFeedbackSessionUnpublishedEmail(session.getCourseId(), session.getFeedbackSessionName());
            }

            statusToUser.add(new StatusMessage(Const.StatusMessages.FEEDBACK_SESSION_UNPUBLISHED,
                                               StatusMessageColor.SUCCESS));
            statusToAdmin = ""Feedback Session <span class=\""bold\"">("" + feedbackSessionName + "")</span> ""
                            + ""for Course <span class=\""bold\"">["" + courseId + ""]</span> unpublished."";
        } catch (InvalidParametersException e) {
            setStatusForException(e);
        }

        if (nextUrl == null) {
            nextUrl = Const.ActionURIs.INSTRUCTOR_FEEDBACK_SESSIONS_PAGE;
        }

        return createRedirectResult(nextUrl);
    }
}
"
InstructorHomePageAction.java,ui-controller,"package teammates.ui.controller;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;

import teammates.common.datatransfer.CourseSummaryBundle;
import teammates.common.datatransfer.attributes.FeedbackSessionAttributes;
import teammates.common.datatransfer.attributes.InstructorAttributes;
import teammates.common.exception.EntityDoesNotExistException;
import teammates.common.util.Const;
import teammates.common.util.Const.StatusMessages;
import teammates.common.util.StatusMessage;
import teammates.common.util.StatusMessageColor;
import teammates.ui.pagedata.InstructorHomeCourseAjaxPageData;
import teammates.ui.pagedata.InstructorHomePageData;

public class InstructorHomePageAction extends Action {
    @Override
    public ActionResult execute() throws EntityDoesNotExistException {
        if (!account.isInstructor && isPersistenceIssue()) {
            statusToUser.add(new StatusMessage(Const.StatusMessages.INSTRUCTOR_PERSISTENCE_ISSUE,
                                               StatusMessageColor.WARNING));
            statusToAdmin = ""instructorHome "" + Const.StatusMessages.INSTRUCTOR_PERSISTENCE_ISSUE;
            return createShowPageResult(Const.ViewURIs.INSTRUCTOR_HOME, new InstructorHomePageData(account, sessionToken));
        }

        gateKeeper.verifyInstructorPrivileges(account);

        String courseToLoad = getRequestParamValue(Const.ParamsNames.COURSE_TO_LOAD);
        return courseToLoad == null ? loadPage() : loadCourse(courseToLoad);
    }

    private ActionResult loadCourse(String courseToLoad) throws EntityDoesNotExistException {
        int index = Integer.parseInt(getRequestParamValue(""index""));

        InstructorAttributes instructor = logic.getInstructorForGoogleId(courseToLoad, account.googleId);

        CourseSummaryBundle course = logic.getCourseSummaryWithFeedbackSessions(instructor);
        FeedbackSessionAttributes.sortFeedbackSessionsByCreationTimeDescending(course.feedbackSessions);

        InstructorHomeCourseAjaxPageData data = new InstructorHomeCourseAjaxPageData(account, sessionToken);
        data.init(index, course, instructor);

        statusToAdmin = ""instructorHome Course Load:<br>"" + courseToLoad;

        return createShowPageResult(Const.ViewURIs.INSTRUCTOR_HOME_AJAX_COURSE_TABLE, data);
    }

    private ActionResult loadPage() {
        boolean shouldOmitArchived = true;
        Map<String, CourseSummaryBundle> courses = logic.getCourseSummariesWithoutStatsForInstructor(
                                                                 account.googleId, shouldOmitArchived);

        ArrayList<CourseSummaryBundle> courseList = new ArrayList<>(courses.values());

        String sortCriteria = getSortCriteria();
        sortCourse(courseList, sortCriteria);

        InstructorHomePageData data = new InstructorHomePageData(account, sessionToken);
        data.init(courseList, sortCriteria);

        if (logic.isNewInstructor(account.googleId)) {
            statusToUser.add(new StatusMessage(StatusMessages.HINT_FOR_NEW_INSTRUCTOR, StatusMessageColor.INFO));
        }
        statusToAdmin = ""instructorHome Page Load<br>"" + ""Total Courses: "" + courseList.size();

        return createShowPageResult(Const.ViewURIs.INSTRUCTOR_HOME, data);
    }

    private String getSortCriteria() {
        String sortCriteria = getRequestParamValue(Const.ParamsNames.COURSE_SORTING_CRITERIA);
        if (sortCriteria == null) {
            sortCriteria = Const.DEFAULT_SORT_CRITERIA;
        }

        return sortCriteria;
    }

    private void sortCourse(List<CourseSummaryBundle> courseList, String sortCriteria) {
        switch (sortCriteria) {
        case Const.SORT_BY_COURSE_ID:
            CourseSummaryBundle.sortSummarizedCoursesByCourseId(courseList);
            break;
        case Const.SORT_BY_COURSE_NAME:
            CourseSummaryBundle.sortSummarizedCoursesByCourseName(courseList);
            break;
        case Const.SORT_BY_COURSE_CREATION_DATE:
            CourseSummaryBundle.sortSummarizedCoursesByCreationDate(courseList);
            break;
        default:
            throw new RuntimeException(""Invalid course sorting criteria."");
        }
    }
}
"
InstructorSearchPageAction.java,ui-controller,"package teammates.ui.controller;

import java.util.HashSet;
import java.util.List;
import java.util.Set;

import teammates.common.datatransfer.FeedbackResponseCommentSearchResultBundle;
import teammates.common.datatransfer.StudentSearchResultBundle;
import teammates.common.datatransfer.attributes.InstructorAttributes;
import teammates.common.util.Const;
import teammates.common.util.StatusMessage;
import teammates.common.util.StatusMessageColor;
import teammates.ui.pagedata.InstructorSearchPageData;

/**
 * Action: Showing the InstructorSearchPage for an instructor.
 */
public class InstructorSearchPageAction extends Action {

    @Override
    protected ActionResult execute() {
        gateKeeper.verifyInstructorPrivileges(account);
        String searchKey = getRequestParamValue(Const.ParamsNames.SEARCH_KEY);
        if (searchKey == null) {
            searchKey = """";
        }

        int numberOfSearchOptions = 0;

        boolean isSearchForStudents = getRequestParamAsBoolean(Const.ParamsNames.SEARCH_STUDENTS);
        if (isSearchForStudents) {
            numberOfSearchOptions++;
        }

        boolean isSearchCommentForResponses = getRequestParamAsBoolean(Const.ParamsNames.SEARCH_COMMENTS_FOR_RESPONSES);
        if (isSearchCommentForResponses) {
            numberOfSearchOptions++;
        }

        FeedbackResponseCommentSearchResultBundle frCommentSearchResults = new FeedbackResponseCommentSearchResultBundle();
        StudentSearchResultBundle studentSearchResults = new StudentSearchResultBundle();
        int totalResultsSize = 0;

        if (searchKey.isEmpty() || numberOfSearchOptions == 0) {
            //display search tips and tutorials
            statusToUser.add(new StatusMessage(Const.StatusMessages.INSTRUCTOR_SEARCH_TIPS, StatusMessageColor.INFO));
        } else {
            //Start searching
            List<InstructorAttributes> instructors = logic.getInstructorsForGoogleId(account.googleId);
            if (isSearchCommentForResponses) {
                frCommentSearchResults = logic.searchFeedbackResponseComments(searchKey, instructors);
            }
            if (isSearchForStudents) {
                studentSearchResults = logic.searchStudents(searchKey, instructors);
            }

            totalResultsSize = frCommentSearchResults.numberOfResults + studentSearchResults.numberOfResults;

            Set<String> instructorEmails = new HashSet<>();

            for (InstructorAttributes instructor : instructors) {
                instructorEmails.add(instructor.email);
            }

            if (totalResultsSize == 0) {
                statusToUser.add(new StatusMessage(Const.StatusMessages.INSTRUCTOR_SEARCH_NO_RESULTS,
                                                   StatusMessageColor.WARNING));
            }
        }

        InstructorSearchPageData data = new InstructorSearchPageData(account, sessionToken);
        data.init(frCommentSearchResults, studentSearchResults, searchKey, isSearchCommentForResponses, isSearchForStudents);

        return createShowPageResult(Const.ViewURIs.INSTRUCTOR_SEARCH, data);
    }
}
"
InstructorStudentListAjaxPageAction.java,ui-controller,"package teammates.ui.controller;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

import teammates.common.datatransfer.SectionDetailsBundle;
import teammates.common.datatransfer.TeamDetailsBundle;
import teammates.common.datatransfer.attributes.CourseAttributes;
import teammates.common.datatransfer.attributes.InstructorAttributes;
import teammates.common.datatransfer.attributes.StudentAttributes;
import teammates.common.exception.EntityDoesNotExistException;
import teammates.common.util.Assumption;
import teammates.common.util.Const;
import teammates.common.util.Url;
import teammates.ui.pagedata.InstructorStudentListAjaxPageData;

public class InstructorStudentListAjaxPageAction extends Action {

    @Override
    protected ActionResult execute() throws EntityDoesNotExistException {

        String courseId = getRequestParamValue(Const.ParamsNames.COURSE_ID);
        Assumption.assertPostParamNotNull(Const.ParamsNames.COURSE_ID, courseId);

        String courseIndexString = getRequestParamValue(Const.ParamsNames.COURSE_INDEX);
        Assumption.assertPostParamNotNull(Const.ParamsNames.COURSE_INDEX, courseIndexString);

        gateKeeper.verifyInstructorPrivileges(account);

        InstructorAttributes instructor = logic.getInstructorForGoogleId(courseId, account.googleId);
        CourseAttributes course = logic.getCourse(courseId);

        gateKeeper.verifyAccessible(instructor, course);

        List<SectionDetailsBundle> courseSectionDetails = logic.getSectionsForCourse(courseId);
        int courseIndex = Integer.parseInt(courseIndexString);
        boolean hasSection = logic.hasIndicatedSections(courseId);

        Map<String, String> emailPhotoUrlMapping = new HashMap<>();
        Map<String, Map<String, Boolean>> sectionPrivileges = new HashMap<>();
        for (SectionDetailsBundle sectionDetails : courseSectionDetails) {
            for (TeamDetailsBundle teamDetails : sectionDetails.teams) {
                for (StudentAttributes student : teamDetails.students) {
                    String studentPhotoUrl = student.getPublicProfilePictureUrl();
                    studentPhotoUrl = Url.addParamToUrl(studentPhotoUrl,
                                                    Const.ParamsNames.USER_ID, account.googleId);
                    emailPhotoUrlMapping.put(student.email, studentPhotoUrl);
                }
            }
            Map<String, Boolean> sectionPrivilege = new HashMap<>();
            sectionPrivilege.put(Const.ParamsNames.INSTRUCTOR_PERMISSION_VIEW_STUDENT_IN_SECTIONS,
                                 instructor.isAllowedForPrivilege(
                                         sectionDetails.name,
                                         Const.ParamsNames.INSTRUCTOR_PERMISSION_VIEW_STUDENT_IN_SECTIONS));
            sectionPrivilege.put(Const.ParamsNames.INSTRUCTOR_PERMISSION_MODIFY_STUDENT,
                                 instructor.isAllowedForPrivilege(sectionDetails.name,
                                                                  Const.ParamsNames.INSTRUCTOR_PERMISSION_MODIFY_STUDENT));
            sectionPrivileges.put(sectionDetails.name, sectionPrivilege);
        }

        InstructorStudentListAjaxPageData data = new InstructorStudentListAjaxPageData(account, sessionToken, courseId,
                courseIndex, hasSection, courseSectionDetails, sectionPrivileges, emailPhotoUrlMapping);

        return createShowPageResult(Const.ViewURIs.INSTRUCTOR_STUDENT_LIST_AJAX, data);
    }

}
"
InstructorStudentListPageAction.java,ui-controller,"package teammates.ui.controller;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import teammates.common.datatransfer.attributes.CourseAttributes;
import teammates.common.datatransfer.attributes.InstructorAttributes;
import teammates.common.util.Const;
import teammates.common.util.StatusMessage;
import teammates.common.util.StatusMessageColor;
import teammates.ui.datatransfer.InstructorStudentListPageCourseData;
import teammates.ui.pagedata.InstructorStudentListPageData;

public class InstructorStudentListPageAction extends Action {

    @Override
    public ActionResult execute() {

        gateKeeper.verifyInstructorPrivileges(account);

        String searchKey = getRequestParamValue(Const.ParamsNames.SEARCH_KEY);
        Boolean displayArchive = getRequestParamAsBoolean(Const.ParamsNames.DISPLAY_ARCHIVE);
        Map<String, InstructorAttributes> instructors = new HashMap<>();

        List<CourseAttributes> courses = logic.getCoursesForInstructor(account.googleId);
        // Sort by creation date
        Collections.sort(courses, new Comparator<CourseAttributes>() {
            @Override
            public int compare(CourseAttributes c1, CourseAttributes c2) {
                return c1.createdAt.compareTo(c2.createdAt);
            }
        });

        // Get instructor attributes
        List<InstructorAttributes> instructorList = logic.getInstructorsForGoogleId(account.googleId);

        for (InstructorAttributes instructor : instructorList) {
            instructors.put(instructor.courseId, instructor);
        }

        if (courses.isEmpty()) {
            statusToUser.add(new StatusMessage(Const.StatusMessages.INSTRUCTOR_NO_COURSE_AND_STUDENTS,
                                               StatusMessageColor.WARNING));
        }

        statusToAdmin = ""instructorStudentList Page Load<br>"" + ""Total Courses: "" + courses.size();

        List<InstructorStudentListPageCourseData> coursesToDisplay = new ArrayList<>();
        for (CourseAttributes course : courses) {
            InstructorAttributes instructor = instructors.get(course.getId());
            boolean isInstructorAllowedToModify = instructor.isAllowedForPrivilege(
                                            Const.ParamsNames.INSTRUCTOR_PERMISSION_MODIFY_STUDENT);

            boolean isCourseDisplayed = displayArchive || !instructor.isArchived;
            if (isCourseDisplayed) {
                coursesToDisplay.add(new InstructorStudentListPageCourseData(course, instructor.isArchived,
                                                                             isInstructorAllowedToModify));
            }
        }

        InstructorStudentListPageData data =
                new InstructorStudentListPageData(account, sessionToken, searchKey, displayArchive, coursesToDisplay);

        return createShowPageResult(Const.ViewURIs.INSTRUCTOR_STUDENT_LIST, data);
    }

}
"
InstructorStudentRecordsAjaxPageAction.java,ui-controller,"package teammates.ui.controller;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;

import teammates.common.datatransfer.FeedbackSessionResultsBundle;
import teammates.common.datatransfer.attributes.FeedbackSessionAttributes;
import teammates.common.datatransfer.attributes.InstructorAttributes;
import teammates.common.datatransfer.attributes.SessionAttributes;
import teammates.common.datatransfer.attributes.StudentAttributes;
import teammates.common.exception.EntityDoesNotExistException;
import teammates.common.util.Assumption;
import teammates.common.util.Const;
import teammates.common.util.StatusMessage;
import teammates.common.util.StatusMessageColor;
import teammates.ui.pagedata.InstructorStudentRecordsAjaxPageData;

public class InstructorStudentRecordsAjaxPageAction extends Action {

    @Override
    public ActionResult execute() throws EntityDoesNotExistException {

        String courseId = getRequestParamValue(Const.ParamsNames.COURSE_ID);
        Assumption.assertPostParamNotNull(Const.ParamsNames.COURSE_ID, courseId);

        String studentEmail = getRequestParamValue(Const.ParamsNames.STUDENT_EMAIL);
        Assumption.assertPostParamNotNull(Const.ParamsNames.STUDENT_EMAIL, studentEmail);

        String targetSessionName = getRequestParamValue(Const.ParamsNames.FEEDBACK_SESSION_NAME);
        Assumption.assertPostParamNotNull(Const.ParamsNames.FEEDBACK_SESSION_NAME, targetSessionName);

        InstructorAttributes instructor = logic.getInstructorForGoogleId(courseId, account.googleId);

        gateKeeper.verifyAccessible(instructor, logic.getCourse(courseId));

        StudentAttributes student = logic.getStudentForEmail(courseId, studentEmail);
        if (student == null) {
            statusToUser.add(new StatusMessage(Const.StatusMessages.STUDENT_NOT_FOUND_FOR_RECORDS,
                                               StatusMessageColor.DANGER));
            isError = true;
            return createRedirectResult(Const.ActionURIs.INSTRUCTOR_HOME_PAGE);
        }

        List<FeedbackSessionAttributes> feedbacks = logic.getFeedbackSessionsListForInstructor(account.googleId, false);

        filterFeedbackSessions(courseId, feedbacks, instructor, student);

        List<SessionAttributes> sessions = new ArrayList<>();
        sessions.addAll(feedbacks);
        Collections.sort(sessions, SessionAttributes.DESCENDING_ORDER);

        List<FeedbackSessionResultsBundle> results = new ArrayList<>();
        for (SessionAttributes session : sessions) {
            if (session instanceof FeedbackSessionAttributes) {
                if (!targetSessionName.isEmpty() && targetSessionName.equals(session.getSessionName())) {
                    FeedbackSessionResultsBundle result = logic.getFeedbackSessionResultsForInstructor(
                                                    session.getSessionName(), courseId, instructor.email);
                    results.add(result);
                }
            } else {
                Assumption.fail(""Unknown session type"");
            }
        }
        statusToAdmin = ""instructorStudentRecords Ajax Page Load<br>""
                      + ""Viewing <span class=\""bold\"">"" + studentEmail + ""'s</span> records ""
                      + ""for session <span class=\""bold\"">["" + targetSessionName + ""]</span> ""
                      + ""in course <span class=\""bold\"">["" + courseId + ""]</span>"";

        InstructorStudentRecordsAjaxPageData data =
                                        new InstructorStudentRecordsAjaxPageData(account, student, sessionToken, results);

        return createShowPageResult(Const.ViewURIs.INSTRUCTOR_STUDENT_RECORDS_AJAX, data);
    }

    private void filterFeedbackSessions(String courseId, List<FeedbackSessionAttributes> feedbacks,
                                        InstructorAttributes currentInstructor, StudentAttributes student) {
        Iterator<FeedbackSessionAttributes> iterFs = feedbacks.iterator();
        while (iterFs.hasNext()) {
            FeedbackSessionAttributes tempFs = iterFs.next();
            if (!tempFs.getCourseId().equals(courseId)
                    || !currentInstructor.isAllowedForPrivilege(student.section, tempFs.getSessionName(),
                                              Const.ParamsNames.INSTRUCTOR_PERMISSION_VIEW_SESSION_IN_SECTIONS)) {
                iterFs.remove();
            }
        }
    }

}
"
InstructorStudentRecordsPageAction.java,ui-controller,"package teammates.ui.controller;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;

import teammates.common.datatransfer.attributes.FeedbackSessionAttributes;
import teammates.common.datatransfer.attributes.InstructorAttributes;
import teammates.common.datatransfer.attributes.StudentAttributes;
import teammates.common.datatransfer.attributes.StudentProfileAttributes;
import teammates.common.util.Assumption;
import teammates.common.util.Const;
import teammates.common.util.SanitizationHelper;
import teammates.common.util.StatusMessage;
import teammates.common.util.StatusMessageColor;
import teammates.ui.pagedata.InstructorStudentRecordsPageData;

public class InstructorStudentRecordsPageAction extends Action {

    @Override
    public ActionResult execute() {

        String courseId = getRequestParamValue(Const.ParamsNames.COURSE_ID);
        Assumption.assertPostParamNotNull(Const.ParamsNames.COURSE_ID, courseId);

        InstructorAttributes instructor = logic.getInstructorForGoogleId(courseId, account.googleId);
        gateKeeper.verifyAccessible(instructor, logic.getCourse(courseId));

        String studentEmail = getRequestParamValue(Const.ParamsNames.STUDENT_EMAIL);
        Assumption.assertPostParamNotNull(Const.ParamsNames.STUDENT_EMAIL, studentEmail);

        StudentAttributes student = logic.getStudentForEmail(courseId, studentEmail);

        if (student == null) {
            statusToUser.add(new StatusMessage(Const.StatusMessages.STUDENT_NOT_FOUND_FOR_RECORDS,
                                               StatusMessageColor.DANGER));
            isError = true;
            return createRedirectResult(Const.ActionURIs.INSTRUCTOR_HOME_PAGE);
        }

        List<FeedbackSessionAttributes> sessions = logic.getFeedbackSessionsListForInstructor(account.googleId, false);

        filterFeedbackSessions(courseId, sessions, instructor, student);

        Collections.sort(sessions, FeedbackSessionAttributes.DESCENDING_ORDER);

        StudentProfileAttributes studentProfile = null;

        boolean isInstructorAllowedToViewStudent = instructor.isAllowedForPrivilege(student.section,
                                                        Const.ParamsNames.INSTRUCTOR_PERMISSION_VIEW_STUDENT_IN_SECTIONS);
        boolean isStudentWithProfile = !student.googleId.isEmpty();
        if (isInstructorAllowedToViewStudent && isStudentWithProfile) {
            studentProfile = logic.getStudentProfile(student.googleId);
            Assumption.assertNotNull(studentProfile);
        } else {
            if (student.googleId.isEmpty()) {
                statusToUser.add(new StatusMessage(Const.StatusMessages.STUDENT_NOT_JOINED_YET_FOR_RECORDS,
                                                   StatusMessageColor.WARNING));
            } else if (!isInstructorAllowedToViewStudent) {
                statusToUser.add(new StatusMessage(Const.StatusMessages.STUDENT_PROFILE_UNACCESSIBLE_TO_INSTRUCTOR,
                                                   StatusMessageColor.WARNING));
            }
        }

        if (sessions.isEmpty()) {
            statusToUser.add(new StatusMessage(Const.StatusMessages.INSTRUCTOR_NO_STUDENT_RECORDS,
                                               StatusMessageColor.WARNING));
        }

        List<String> sessionNames = new ArrayList<>();
        for (FeedbackSessionAttributes fsa : sessions) {
            sessionNames.add(fsa.getFeedbackSessionName());
        }

        InstructorStudentRecordsPageData data =
                new InstructorStudentRecordsPageData(account, student, sessionToken, courseId, studentProfile, sessionNames);

        statusToAdmin = ""instructorStudentRecords Page Load<br>""
                      + ""Viewing <span class=\""bold\"">"" + studentEmail + ""'s</span> records ""
                      + ""for Course <span class=\""bold\"">["" + courseId + ""]</span><br>""
                      + ""Number of sessions: "" + sessions.size() + ""<br>""
                      + ""Student Profile: ""
                      + (studentProfile == null ? ""No Profile""
                                                : SanitizationHelper.sanitizeForHtmlTag(studentProfile.toString()));

        return createShowPageResult(Const.ViewURIs.INSTRUCTOR_STUDENT_RECORDS, data);
    }

    private void filterFeedbackSessions(String courseId, List<FeedbackSessionAttributes> feedbacks,
                                        InstructorAttributes instructor, StudentAttributes student) {
        Iterator<FeedbackSessionAttributes> iterFs = feedbacks.iterator();
        while (iterFs.hasNext()) {
            FeedbackSessionAttributes tempFs = iterFs.next();
            if (!tempFs.getCourseId().equals(courseId)
                    || !instructor.isAllowedForPrivilege(student.section, tempFs.getSessionName(),
                                                         Const.ParamsNames.INSTRUCTOR_PERMISSION_VIEW_SESSION_IN_SECTIONS)) {
                iterFs.remove();
            }
        }
    }

}
"
LoginServlet.java,ui-controller,"package teammates.ui.controller;

import java.io.IOException;

import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import teammates.common.datatransfer.UserType;
import teammates.common.util.Const;
import teammates.logic.api.GateKeeper;

@SuppressWarnings(""serial"")
/**
 * Servlet to handle Login
 */
public class LoginServlet extends HttpServlet {

    @Override
    public final void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException {
        this.doPost(req, resp);
    }

    @Override
    public final void doPost(HttpServletRequest req, HttpServletResponse resp) throws IOException {
        GateKeeper gateKeeper = new GateKeeper();
        UserType user = gateKeeper.getCurrentUser();
        boolean isInstructor = req.getParameter(Const.ParamsNames.LOGIN_INSTRUCTOR) != null;
        boolean isStudent = req.getParameter(Const.ParamsNames.LOGIN_STUDENT) != null;
        boolean isAdmin = req.getParameter(Const.ParamsNames.LOGIN_ADMIN) != null;

        if (isInstructor) {
            if (isMasqueradeMode(user)) {
                resp.sendRedirect(Const.ActionURIs.INSTRUCTOR_HOME_PAGE);
            } else {
                resp.sendRedirect(gateKeeper.getLoginUrl(Const.ActionURIs.INSTRUCTOR_HOME_PAGE));
            }
        } else if (isStudent) {
            if (isMasqueradeMode(user)) {
                resp.sendRedirect(Const.ActionURIs.STUDENT_HOME_PAGE);
            } else {
                resp.sendRedirect(gateKeeper.getLoginUrl(Const.ActionURIs.STUDENT_HOME_PAGE));
            }
        } else if (isAdmin) { // TODO: do we need this branch?
            if (isMasqueradeMode(user)) {
                resp.sendRedirect(Const.ActionURIs.ADMIN_HOME_PAGE);
            } else {
                resp.sendRedirect(gateKeeper.getLoginUrl(Const.ActionURIs.ADMIN_HOME_PAGE));
            }
        } else {
            resp.sendRedirect(Const.ViewURIs.ERROR_PAGE);
        }
    }

    private boolean isMasqueradeMode(UserType user) {
        return user != null;
    }
}
"
LogoutServlet.java,ui-controller,"package teammates.ui.controller;

import java.io.IOException;

import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import teammates.common.util.Const;
import teammates.common.util.StringHelper;
import teammates.logic.api.GateKeeper;

/**
 * Servlet to handle Logout.
 */
@SuppressWarnings(""serial"")
public class LogoutServlet extends HttpServlet {

    @Override
    public final void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException {
        this.doPost(req, resp);
    }

    @Override
    public final void doPost(HttpServletRequest req, HttpServletResponse resp) throws IOException {
        String nextUrl = req.getParameter(Const.ParamsNames.NEXT_URL);
        if (nextUrl == null) {
            nextUrl = ""/"";
        }
        String expectedId = req.getParameter(Const.ParamsNames.HINT);
        String actualId = req.getParameter(Const.ParamsNames.USER_ID);
        String logoutUrl = new GateKeeper().getLogoutUrl(nextUrl);
        if (expectedId == null || actualId == null) {
            resp.sendRedirect(logoutUrl);
            return;
        }
        try {
            req.setAttribute(Const.ParamsNames.HINT, StringHelper.decrypt(expectedId));
            req.setAttribute(Const.ParamsNames.USER_ID, StringHelper.decrypt(actualId));
            req.setAttribute(Const.ParamsNames.NEXT_URL, logoutUrl);
            req.getRequestDispatcher(Const.ViewURIs.GOOGLE_ACCOUNT_HINT).forward(req, resp);
        } catch (Exception e) {
            resp.sendRedirect(logoutUrl);
        }
    }

}
"
package-info.java,ui-controller,"/**
 * Contains servlets and action classes for user-invoked actions.
 */
package teammates.ui.controller;
"
PublicImageServlet.java,ui-controller,"package teammates.ui.controller;

import java.io.IOException;
import java.util.Map;

import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import com.google.appengine.api.blobstore.BlobKey;
import com.google.appengine.api.blobstore.BlobstoreService;
import com.google.appengine.api.blobstore.BlobstoreServiceFactory;

import teammates.common.datatransfer.UserType;
import teammates.common.exception.TeammatesException;
import teammates.common.util.Assumption;
import teammates.common.util.Const;
import teammates.common.util.HttpRequestHelper;
import teammates.common.util.LogMessageGenerator;
import teammates.common.util.Logger;
import teammates.logic.api.GateKeeper;

/**
 * Serves the public image stored in google cloud storage using the blobkey.<br>
 * Correct blobkey is required for image serving.
 */
@SuppressWarnings(""serial"")
public class PublicImageServlet extends HttpServlet {

    private static final Logger log = Logger.getLogger();

    @Override
    public void doGet(HttpServletRequest req, HttpServletResponse resp) {
        doPost(req, resp);
    }

    @SuppressWarnings(""unchecked"")
    @Override
    public void doPost(HttpServletRequest req, HttpServletResponse resp) {
        String url = HttpRequestHelper.getRequestedUrl(req);

        UserType userType = new GateKeeper().getCurrentUser();
        Map<String, String[]> requestParameters = req.getParameterMap();
        String blobKey = HttpRequestHelper.getValueFromParamMap(requestParameters, Const.ParamsNames.BLOB_KEY);
        Assumption.assertPostParamNotNull(Const.ParamsNames.BLOB_KEY, blobKey);

        try {
            if (blobKey.isEmpty()) {
                String message = ""Failed to serve image with URL : blobKey is missing"";
                Map<String, String[]> params = HttpRequestHelper.getParameterMap(req);
                log.info(new LogMessageGenerator().generateBasicActivityLogMessage(url, params, message, userType));
                resp.sendError(1, ""No image found"");
            } else {
                resp.setContentType(""image/png"");
                BlobstoreService blobstoreService = BlobstoreServiceFactory.getBlobstoreService();
                blobstoreService.serve(new BlobKey(blobKey), resp);
                // TODO : restrict image request to those ""public"" files only

                String message = ""Public image request with URL: <br>""
                               + ""<a href=\"""" + url + ""\"" target=\""_blank\"" rel=\""noopener noreferrer\"" >""
                               + url + ""</a>"";

                Map<String, String[]> params = HttpRequestHelper.getParameterMap(req);
                log.info(new LogMessageGenerator().generateBasicActivityLogMessage(url, params, message, userType));
            }
        } catch (IOException ioe) {
            Map<String, String[]> params = HttpRequestHelper.getParameterMap(req);
            log.warning(new LogMessageGenerator().generateActionFailureLogMessage(url, params, ioe, userType));
        } catch (Exception e) {
            log.severe(""Exception occured while performing "" + Const.PublicActionNames.PUBLIC_IMAGE_SERVE_ACTION
                    + "": "" + TeammatesException.toStringWithStackTrace(e));
        }
    }

}
"
RedirectResult.java,ui-controller,"package teammates.ui.controller;

import java.io.IOException;
import java.util.List;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import teammates.common.datatransfer.attributes.AccountAttributes;
import teammates.common.util.StatusMessage;

/** A 'redirect' type result. That is, the Browser will be required to make
 * another request to the specified {@code destination}.
 */
public class RedirectResult extends ActionResult {

    public RedirectResult(
            String destination,
            AccountAttributes account,
            List<StatusMessage> status) {
        super(destination, account, status);
    }

    @Override
    public void send(HttpServletRequest req, HttpServletResponse resp) throws IOException {
        resp.sendRedirect(getDestinationWithParams());
    }

}
"
ShowPageResult.java,ui-controller,"package teammates.ui.controller;

import java.io.IOException;
import java.util.List;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import teammates.common.datatransfer.attributes.AccountAttributes;
import teammates.common.util.Const;
import teammates.common.util.StatusMessage;
import teammates.ui.pagedata.PageData;

/**
 * A result that shows a page in the Browser. These are usually implemented as
 * JSP pages.
 */
public class ShowPageResult extends ActionResult {

    /** The data that will be used to render the page. */
    public PageData data;

    public ShowPageResult(
            String destination,
            AccountAttributes account,
            List<StatusMessage> status) {
        super(destination, account, status);
    }

    public ShowPageResult(
            String destination,
            AccountAttributes account,
            PageData data,
            List<StatusMessage> status) {
        super(destination, account, status);
        this.data = data;
    }

    @Override
    public void send(HttpServletRequest req, HttpServletResponse resp)
            throws IOException, ServletException {

        addStatusMessagesToPageData(req);
        req.setAttribute(""data"", data);

        /* These two are required for the 'status message' section of the page
         * Although these two are also sent as parameters in the URL,
         *  they should be set as attributes too, because the status message
         *  section is a {@code jsp:include} and cannot see parameters encoded
         *  in the URL
         */
        req.setAttribute(Const.ParamsNames.ERROR, Boolean.toString(isError));

        req.getRequestDispatcher(getDestinationWithParams()).forward(req, resp);
    }

    /**
     * Adds the list of status messages (if any) to the page data.
     * @param req HttpServletRequest object
     */
    private void addStatusMessagesToPageData(HttpServletRequest req) {
        @SuppressWarnings(""unchecked"")
        List<StatusMessage> statusMessagesToUser =
                (List<StatusMessage>) req.getSession().getAttribute(Const.ParamsNames.STATUS_MESSAGES_LIST);

        // If the list of status messages can be found in the session and it is not empty,
        // means there are status messages to be shown to the user, add them to the page data.
        if (statusMessagesToUser != null && !statusMessagesToUser.isEmpty()) {
            req.getSession().removeAttribute(Const.ParamsNames.STATUS_MESSAGES_LIST);
            data.setStatusMessagesToUser(statusMessagesToUser);
        }
    }
}
"
StudentCourseDetailsPageAction.java,ui-controller,"package teammates.ui.controller;

import teammates.common.datatransfer.attributes.CourseAttributes;
import teammates.common.exception.EntityDoesNotExistException;
import teammates.common.util.Assumption;
import teammates.common.util.Const;
import teammates.common.util.SanitizationHelper;
import teammates.ui.pagedata.StudentCourseDetailsPageData;

public class StudentCourseDetailsPageAction extends Action {

    @Override
    public ActionResult execute() throws EntityDoesNotExistException {

        String courseId = getRequestParamValue(Const.ParamsNames.COURSE_ID);
        Assumption.assertPostParamNotNull(Const.ParamsNames.COURSE_ID, courseId);

        if (!isJoinedCourse(courseId)) {
            return createPleaseJoinCourseResponse(courseId);
        }

        CourseAttributes course = logic.getCourse(courseId);
        gateKeeper.verifyAccessible(logic.getStudentForGoogleId(courseId, account.googleId), course);

        StudentCourseDetailsPageData data = new StudentCourseDetailsPageData(account, sessionToken);

        data.init(logic.getCourseDetails(courseId), logic.getInstructorsForCourse(courseId),
                      logic.getStudentForGoogleId(courseId, account.googleId),
                      logic.getTeamDetailsForStudent(logic.getStudentForGoogleId(courseId, account.googleId)));

        statusToAdmin = ""studentCourseDetails Page Load<br>""
                        + ""Viewing team details for <span class=\""bold\"">["" + courseId + ""] ""
                        + SanitizationHelper.sanitizeForHtml(course.getName()) + ""</span>"";

        return createShowPageResult(Const.ViewURIs.STUDENT_COURSE_DETAILS, data);
    }

}
"
StudentCourseJoinAction.java,ui-controller,"package teammates.ui.controller;

import teammates.common.util.Assumption;
import teammates.common.util.Config;
import teammates.common.util.Const;
import teammates.common.util.SanitizationHelper;
import teammates.common.util.StatusMessage;
import teammates.common.util.StatusMessageColor;
import teammates.ui.pagedata.StudentCourseJoinConfirmationPageData;

/**
 * This action handles students that attempts to join a course.
 * It asks the student for confirmation that the logged in account
 * belongs to him before redirecting him to the actual join action,
 * {@link StudentCourseJoinAuthenticatedAction}.
 * <br><br>
 * This is done to prevent students from accidentally linking
 * his registration key with another student's google account.
 */
public class StudentCourseJoinAction extends Action {

    @Override
    public ActionResult execute() {
        Assumption.assertPostParamNotNull(Const.ParamsNames.REGKEY, regkey);

        statusToAdmin = ""Action Student Clicked Join Link""
                        + (account.googleId == null ? ""<br>Email: "" + account.email
                                                    : ""<br>Google ID: "" + account.googleId + ""<br>Key: "" + regkey);

        if (student == null) {
            statusToAdmin += ""<br>Student course join failed as student does not exist."";
            String courseId = getRequestParamValue(Const.ParamsNames.COURSE_ID);
            Assumption.assertPostParamNotNull(Const.ParamsNames.COURSE_ID, courseId);
            isError = true;
            statusToUser.add(new StatusMessage(
                    String.format(Const.StatusMessages.NON_EXISTENT_STUDENT_ATTEMPTING_TO_JOIN_COURSE, courseId),
                    StatusMessageColor.WARNING));
            return createRedirectResult(Const.ActionURIs.STUDENT_HOME_PAGE);
        }

        String nextUrl = getNextUrl();
        if (gateKeeper.getCurrentUser() == null) {
            return createRedirectToAuthenticatedJoinPage(nextUrl);
        }

        String confirmUrl = Const.ActionURIs.STUDENT_COURSE_JOIN_AUTHENTICATED
                + ""?"" + Const.ParamsNames.REGKEY + ""="" + regkey
                + ""&"" + Const.ParamsNames.NEXT_URL + ""="" + SanitizationHelper.sanitizeForNextUrl(nextUrl);
        String nextUrlType = getPageTypeOfUrl(nextUrl);
        // the student is redirected to join page because he/she is not registered in the course
        boolean isRedirectResult = !Const.SystemParams.PAGES_ACCESSIBLE_WITHOUT_REGISTRATION.contains(nextUrlType);
        boolean isNextUrlAccessibleWithoutLogin =
                        Const.SystemParams.PAGES_ACCESSIBLE_WITHOUT_GOOGLE_LOGIN.contains(nextUrlType);
        String courseId = student.course;
        StudentCourseJoinConfirmationPageData data =
                new StudentCourseJoinConfirmationPageData(
                        account, student, sessionToken, confirmUrl,
                        gateKeeper.getLogoutUrl(SanitizationHelper.sanitizeForNextUrl(confirmUrl)),
                        isRedirectResult, courseId, isNextUrlAccessibleWithoutLogin);
        excludeStudentDetailsFromResponseParams();

        return createShowPageResult(
                Const.ViewURIs.STUDENT_COURSE_JOIN_CONFIRMATION, data);
    }

    private String getNextUrl() {
        String nextUrl = getRequestParamValue(Const.ParamsNames.NEXT_URL);
        if (nextUrl == null) {
            nextUrl = Const.ActionURIs.STUDENT_HOME_PAGE;
        }

        return nextUrl;
    }

    private ActionResult createRedirectToAuthenticatedJoinPage(String nextUrl) {
        // send straight to next page as the user can choose to login as he wishes
        String redirectUrl = Config.getAppUrl(Const.ActionURIs.STUDENT_COURSE_JOIN_AUTHENTICATED)
                .withRegistrationKey(regkey)
                .withParam(Const.ParamsNames.NEXT_URL, nextUrl)
                .toString();

        excludeStudentDetailsFromResponseParams();

        return createRedirectResult(redirectUrl);
    }

    /**
     * Gets the page type out of a URL, e.g the type of
     * <code>/page/xyz?param1=value1&amp;param2=value2</code> is <code>/page/xyz</code>.
     * The page type is assumed to be in the form of /page/ followed by alphabets
     * (case-insensitive) only, as per the design of {@link Const.ActionURIs}.
     */
    public static String getPageTypeOfUrl(String url) {
        /*
         * Regex meaning: from the beginning of the string, tries to match /page/
         * followed by one or more case-insensitive alphabets, followed by ? and
         * any amount of any character until the end of the string.
         * Returns everything before ? if matches or the original string otherwise.
         */
        return url.replaceFirst(""^(/page/[A-Za-z]+)\\?.*$"", ""$1"");
    }

}
"
StudentCourseJoinAuthenticatedAction.java,ui-controller,"package teammates.ui.controller;

import java.util.List;

import teammates.common.datatransfer.attributes.CourseAttributes;
import teammates.common.datatransfer.attributes.FeedbackSessionAttributes;
import teammates.common.datatransfer.attributes.StudentAttributes;
import teammates.common.datatransfer.attributes.StudentProfileAttributes;
import teammates.common.exception.EntityDoesNotExistException;
import teammates.common.exception.InvalidParametersException;
import teammates.common.exception.JoinCourseException;
import teammates.common.exception.UnauthorizedAccessException;
import teammates.common.util.Assumption;
import teammates.common.util.Const;
import teammates.common.util.Logger;
import teammates.common.util.SanitizationHelper;
import teammates.common.util.StatusMessage;
import teammates.common.util.StatusMessageColor;

/**
 * This action handles students who attempt to join a course after
 * the student has been forced to re-authenticate himself by
 * {@link StudentCourseJoinAction}. This action does the actual
 * joining of the student to the course.
 */
public class StudentCourseJoinAuthenticatedAction extends Action {

    private static final Logger log = Logger.getLogger();

    @Override
    protected ActionResult execute() throws EntityDoesNotExistException {
        Assumption.assertNotNull(regkey);

        // the next URL can be specified either in registration key
        // (see {@link Action#parseAndInitializeRegkeyFromRequest()}
        // or as a parameter in the request
        String nextUrl = nextUrlFromRegkey == null ? getRequestParamValue(Const.ParamsNames.NEXT_URL) : nextUrlFromRegkey;
        Assumption.assertPostParamNotNull(Const.ParamsNames.NEXT_URL, nextUrl);
        nextUrl = SanitizationHelper.desanitizeFromNextUrl(nextUrl);

        ensureStudentExists();

        try {
            logic.joinCourseForStudent(regkey, account.googleId);
        } catch (JoinCourseException | InvalidParametersException e) {
            // Does not sanitize for html to allow insertion of mailto link
            if (Const.StatusCodes.INVALID_KEY.equals(e.errorCode)) {
                setStatusForException(e, String.format(e.getMessage(), requestUrl));
            } else {
                setStatusForException(e, e.getMessage());
            }
            nextUrl = Const.ActionURIs.STUDENT_HOME_PAGE;
            excludeStudentDetailsFromResponseParams();

            return createRedirectResult(nextUrl);
        }

        final String studentInfo = ""Action Student Joins Course""
                + ""<br>Google ID: "" + account.googleId
                + ""<br>Key : "" + regkey;
        RedirectResult response = createRedirectResult(nextUrl);
        response.addResponseParam(Const.ParamsNames.CHECK_PERSISTENCE_COURSE, getStudent().course);
        excludeStudentDetailsFromResponseParams();

        if (statusToAdmin == null || statusToAdmin.trim().isEmpty()) {
            statusToAdmin = studentInfo;
        } else {
            statusToAdmin += ""<br><br>"" + studentInfo;
        }

        addStatusMessageToUser();

        return response;
    }

    private void addStatusMessageToUser() throws EntityDoesNotExistException {
        CourseAttributes course = logic.getCourse(getStudent().course);
        String courseDisplayText = ""["" + course.getId() + ""] "" + SanitizationHelper.sanitizeForHtml(course.getName());

        statusToUser.add(new StatusMessage(String.format(Const.StatusMessages.STUDENT_COURSE_JOIN_SUCCESSFUL,
                                                           courseDisplayText), StatusMessageColor.SUCCESS));

        List<FeedbackSessionAttributes> fsa =
                logic.getFeedbackSessionsForUserInCourse(getStudent().course, getStudent().email);
        if (fsa.isEmpty()) {
            statusToUser.add(new StatusMessage(String.format(Const.StatusMessages.HINT_FOR_NO_SESSIONS_STUDENT,
                                                               courseDisplayText), StatusMessageColor.INFO));

            StudentProfileAttributes spa = logic.getStudentProfile(account.googleId);

            String updateProfileMessage = spa.generateUpdateMessageForStudent();
            if (!updateProfileMessage.isEmpty()) {
                statusToUser.add(new StatusMessage(updateProfileMessage, StatusMessageColor.INFO));
            }
        }

    }

    private void ensureStudentExists() {
        StudentAttributes student = getStudent();
        if (student == null) {
            log.info(""Student object not found for regkey: "" + regkey);
            throw new UnauthorizedAccessException(""No student with given registration key:"" + regkey);
        }
    }

    private StudentAttributes getStudent() {
        if (student == null) {
            student = logic.getStudentForRegistrationKey(regkey);
        }

        return student;
    }

}
"
StudentFeedbackResultsPageAction.java,ui-controller,"package teammates.ui.controller;

import java.util.List;
import java.util.Map;

import teammates.common.datatransfer.attributes.FeedbackQuestionAttributes;
import teammates.common.datatransfer.attributes.FeedbackResponseAttributes;
import teammates.common.datatransfer.attributes.StudentAttributes;
import teammates.common.exception.EntityDoesNotExistException;
import teammates.common.exception.UnauthorizedAccessException;
import teammates.common.util.Const;
import teammates.common.util.StatusMessage;
import teammates.common.util.StatusMessageColor;
import teammates.ui.pagedata.StudentFeedbackResultsPageData;

public class StudentFeedbackResultsPageAction extends Action {
    @Override
    protected ActionResult execute() throws EntityDoesNotExistException {
        String courseId = getRequestParamValue(Const.ParamsNames.COURSE_ID);
        String feedbackSessionName = getRequestParamValue(Const.ParamsNames.FEEDBACK_SESSION_NAME);

        if (courseId == null || feedbackSessionName == null) {
            return createRedirectResult(Const.ActionURIs.STUDENT_HOME_PAGE);
        }

        if (!isJoinedCourse(courseId)) {
            return createPleaseJoinCourseResponse(courseId);
        }

        gateKeeper.verifyAccessible(getCurrentStudent(courseId),
                                    logic.getFeedbackSession(feedbackSessionName, courseId));

        StudentFeedbackResultsPageData data = new StudentFeedbackResultsPageData(account, student, sessionToken);

        data.student = getCurrentStudent(courseId);
        data.setBundle(logic.getFeedbackSessionResultsForStudent(feedbackSessionName, courseId, data.student.email));

        if (data.getBundle() == null) {
            // not covered because GateKeeper will detect this as unauthorized exception, but we can
            // leave this here as a safety net on the off cases that GateKeeper fails to catch the Exception
            throw new EntityDoesNotExistException(""Feedback session "" + feedbackSessionName
                                                  + "" does not exist in "" + courseId + ""."");
        }

        if (!data.getBundle().feedbackSession.isPublished()) {
            throw new UnauthorizedAccessException(""This feedback session is not yet visible."");
        }

        if (data.getBundle().isStudentHasSomethingNewToSee(data.student)) {
            statusToUser.add(new StatusMessage(Const.StatusMessages.FEEDBACK_RESULTS_SOMETHINGNEW,
                                               StatusMessageColor.INFO));
        } else {
            statusToUser.add(new StatusMessage(Const.StatusMessages.FEEDBACK_RESULTS_NOTHINGNEW,
                                               StatusMessageColor.WARNING));
        }

        statusToAdmin = ""Show student feedback result page<br>""
                        + ""Session Name: "" + feedbackSessionName + ""<br>""
                        + ""Course ID: "" + courseId;

        Map<FeedbackQuestionAttributes, List<FeedbackResponseAttributes>> questionsWithResponses =
                                        data.getBundle().getQuestionResponseMapSortedByRecipient();
        data.init(questionsWithResponses);
        return createShowPageResult(Const.ViewURIs.STUDENT_FEEDBACK_RESULTS, data);
    }

    private StudentAttributes getCurrentStudent(String courseId) {
        if (student == null) {
            return logic.getStudentForGoogleId(courseId, account.googleId);
        }
        return student;
    }
}
"
StudentFeedbackSubmissionEditPageAction.java,ui-controller,"package teammates.ui.controller;

import teammates.common.datatransfer.FeedbackSessionQuestionsBundle;
import teammates.common.datatransfer.attributes.FeedbackSessionAttributes;
import teammates.common.datatransfer.attributes.StudentAttributes;
import teammates.common.exception.EntityDoesNotExistException;
import teammates.common.util.Const;

public class StudentFeedbackSubmissionEditPageAction extends FeedbackSubmissionEditPageAction {
    @Override
    protected boolean isSpecificUserJoinedCourse() {
        if (student == null) {
            return isJoinedCourse(courseId);
        }
        return student.course.equals(courseId);
    }

    @Override
    protected void verifyAccessibleForSpecificUser(FeedbackSessionAttributes fsa) {
        gateKeeper.verifyAccessible(getStudent(), fsa);
    }

    @Override
    protected String getUserEmailForCourse() {
        if (student == null) {
            // Not covered as this shouldn't happen since verifyAccessibleForSpecific user is always
            // called before this, calling getStudent() and making student not null in any case
            // This still acts as a safety net, however, and should stay
            return getStudent().email;
        }
        return student.email;
    }

    @Override
    protected FeedbackSessionQuestionsBundle getDataBundle(String userEmailForCourse) throws EntityDoesNotExistException {
        return logic.getFeedbackSessionQuestionsBundleForStudent(feedbackSessionName, courseId, userEmailForCourse);
    }

    @Override
    protected boolean isSessionOpenForSpecificUser(FeedbackSessionAttributes session) {
        return session.isOpened();
    }

    @Override
    protected void setStatusToAdmin() {
        statusToAdmin = ""Show student feedback submission edit page<br>"" + ""Session Name: ""
                        + feedbackSessionName + ""<br>"" + ""Course ID: "" + courseId;
    }

    @Override
    protected ShowPageResult createSpecificShowPageResult() {
        data.setSubmitAction(Const.ActionURIs.STUDENT_FEEDBACK_SUBMISSION_EDIT_SAVE);

        return createShowPageResult(Const.ViewURIs.STUDENT_FEEDBACK_SUBMISSION_EDIT, data);
    }

    @Override
    protected RedirectResult createSpecificRedirectResult() throws EntityDoesNotExistException {
        if (!isRegisteredStudent()) {
            throw new EntityDoesNotExistException(""unregistered student trying to access non-existent session"");
        }
        return createRedirectResult(Const.ActionURIs.STUDENT_HOME_PAGE);
    }

    private StudentAttributes getStudent() {
        if (student == null) {
            // branch of student != null is not covered since student is not set elsewhere, but this
            // helps to speed up the process of 'getting' a student so we should leave it here
            student = logic.getStudentForGoogleId(courseId, account.googleId);
        }

        return student;
    }

    protected boolean isRegisteredStudent() {
        return account.isUserRegistered();
    }
}
"
StudentFeedbackSubmissionEditSaveAction.java,ui-controller,"package teammates.ui.controller;

import teammates.common.datatransfer.FeedbackSessionQuestionsBundle;
import teammates.common.datatransfer.attributes.FeedbackSessionAttributes;
import teammates.common.datatransfer.attributes.StudentAttributes;
import teammates.common.exception.EntityDoesNotExistException;
import teammates.common.exception.InvalidParametersException;
import teammates.common.util.Const;
import teammates.common.util.Logger;
import teammates.common.util.SanitizationHelper;

public class StudentFeedbackSubmissionEditSaveAction extends FeedbackSubmissionEditSaveAction {

    private static final Logger log = Logger.getLogger();

    @Override
    protected void verifyAccessibleForSpecificUser() {
        gateKeeper.verifyAccessible(getStudent(), logic.getFeedbackSession(feedbackSessionName, courseId));
    }

    @Override
    protected void appendRespondent() {
        try {
            logic.addStudentRespondent(getUserEmailForCourse(), feedbackSessionName, courseId);
        } catch (InvalidParametersException | EntityDoesNotExistException e) {
            log.severe(""Fail to append student respondent"");
        }
    }

    @Override
    protected void removeRespondent() {
        try {
            logic.deleteStudentRespondent(getUserEmailForCourse(), feedbackSessionName, courseId);
        } catch (InvalidParametersException | EntityDoesNotExistException e) {
            log.severe(""Fail to remove student respondent"");
        }
    }

    @Override
    protected String getUserEmailForCourse() {
        return getStudent().email;
    }

    @Override
    protected String getUserTeamForCourse() {
        return SanitizationHelper.desanitizeFromHtml(getStudent().team);
    }

    @Override
    protected String getUserSectionForCourse() {
        return getStudent().section;
    }

    @Override
    protected FeedbackSessionQuestionsBundle getDataBundle(String userEmailForCourse) throws EntityDoesNotExistException {
        return logic.getFeedbackSessionQuestionsBundleForStudent(feedbackSessionName, courseId,
                                                                 userEmailForCourse);
    }

    @Override
    protected void setStatusToAdmin() {
        statusToAdmin = ""Show student feedback edit result page<br>"" + ""Session Name: ""
                        + feedbackSessionName + ""<br>"" + ""Course ID: "" + courseId;
    }

    @Override
    protected boolean isSessionOpenForSpecificUser(FeedbackSessionAttributes session) {
        return session.isOpened() || session.isInGracePeriod();
    }

    @Override
    protected RedirectResult createSpecificRedirectResult() {
        if (!isRegisteredStudent()) {
            // Always remains at student feedback submission edit page if user is unregistered
            // Link given to unregistered student already contains course id & session name
            return createRedirectResult(Const.ActionURIs.STUDENT_FEEDBACK_SUBMISSION_EDIT_PAGE);
        }
        if (isError) {
            // Return to student feedback submission edit page if there is an error and user is registered
            RedirectResult result = createRedirectResult(Const.ActionURIs.STUDENT_FEEDBACK_SUBMISSION_EDIT_PAGE);

            // Provide course id and session name for the redirected page
            result.responseParams.put(Const.ParamsNames.COURSE_ID, student.course);
            result.responseParams.put(Const.ParamsNames.FEEDBACK_SESSION_NAME,
                                      getRequestParamValue(Const.ParamsNames.FEEDBACK_SESSION_NAME));

            return result;
        }

        // Return to student home page if there is no error and user is registered
        return createRedirectResult(Const.ActionURIs.STUDENT_HOME_PAGE);
    }

    private StudentAttributes getStudent() {
        if (student == null) {
            student = logic.getStudentForGoogleId(courseId, account.googleId);
        }

        return student;
    }

    private boolean isRegisteredStudent() {
        // a registered student must have an associated google Id, therefore 2 branches are missed here
        // and not covered, if they happen, it signifies a much larger problem.
        // i.e. that student.googleId cannot be empty or null if student != null
        return student != null && student.googleId != null && !student.googleId.isEmpty();
    }

    @Override
    protected void setAdditionalParameters() {
        isSendSubmissionEmail = true;
    }

    @Override
    protected void checkAdditionalConstraints() {
        // no additional constraints to check for the standard student submit page
    }
}
"
StudentHomePageAction.java,ui-controller,"package teammates.ui.controller;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import teammates.common.datatransfer.CourseDetailsBundle;
import teammates.common.datatransfer.FeedbackSessionDetailsBundle;
import teammates.common.datatransfer.attributes.FeedbackSessionAttributes;
import teammates.common.datatransfer.attributes.StudentAttributes;
import teammates.common.exception.EntityDoesNotExistException;
import teammates.common.util.Assumption;
import teammates.common.util.Const;
import teammates.common.util.StatusMessage;
import teammates.common.util.StatusMessageColor;
import teammates.ui.pagedata.StudentHomePageData;

public class StudentHomePageAction extends Action {

    @Override
    public ActionResult execute() {
        gateKeeper.verifyLoggedInUserPrivileges();

        String recentlyJoinedCourseId = getRequestParamValue(Const.ParamsNames.CHECK_PERSISTENCE_COURSE);

        List<CourseDetailsBundle> courses = new ArrayList<>();
        Map<FeedbackSessionAttributes, Boolean> sessionSubmissionStatusMap = new HashMap<>();

        try {
            courses = logic.getCourseDetailsListForStudent(account.googleId);
            sessionSubmissionStatusMap = generateFeedbackSessionSubmissionStatusMap(courses, account.googleId);

            CourseDetailsBundle.sortDetailedCourses(courses);

            statusToAdmin = ""studentHome Page Load<br>"" + ""Total courses: "" + courses.size();

            boolean isDataConsistent = isCourseIncluded(recentlyJoinedCourseId, courses);
            if (!isDataConsistent) {
                addPlaceholderCourse(courses, recentlyJoinedCourseId, sessionSubmissionStatusMap);
            }

            for (CourseDetailsBundle course : courses) {
                FeedbackSessionDetailsBundle.sortFeedbackSessionsByCreationTime(course.feedbackSessions);
            }

        } catch (EntityDoesNotExistException e) {
            if (recentlyJoinedCourseId == null) {
                statusToUser.add(new StatusMessage(Const.StatusMessages.STUDENT_FIRST_TIME, StatusMessageColor.WARNING));
                statusToAdmin = Const.ACTION_RESULT_FAILURE + "" :"" + e.getMessage();
            } else {
                addPlaceholderCourse(courses, recentlyJoinedCourseId, sessionSubmissionStatusMap);
            }
        }

        StudentHomePageData data = new StudentHomePageData(account, sessionToken, courses, sessionSubmissionStatusMap);

        return createShowPageResult(Const.ViewURIs.STUDENT_HOME, data);
    }

    private Map<FeedbackSessionAttributes, Boolean> generateFeedbackSessionSubmissionStatusMap(
            List<CourseDetailsBundle> courses, String googleId) {
        Map<FeedbackSessionAttributes, Boolean> returnValue = new HashMap<>();

        for (CourseDetailsBundle c : courses) {
            for (FeedbackSessionDetailsBundle fsb : c.feedbackSessions) {
                FeedbackSessionAttributes f = fsb.feedbackSession;
                returnValue.put(f, getStudentStatusForSession(f, googleId));
            }
        }
        return returnValue;
    }

    private boolean getStudentStatusForSession(FeedbackSessionAttributes fs, String googleId) {
        StudentAttributes student = logic.getStudentForGoogleId(fs.getCourseId(), googleId);
        Assumption.assertNotNull(student);

        String studentEmail = student.email;

        return logic.hasStudentSubmittedFeedback(fs, studentEmail);
    }

    private boolean isCourseIncluded(String recentlyJoinedCourseId, List<CourseDetailsBundle> courses) {
        boolean isCourseIncluded = false;

        if (recentlyJoinedCourseId == null) {
            isCourseIncluded = true;
        } else {
            for (CourseDetailsBundle currentCourse : courses) {
                if (currentCourse.course.getId().equals(recentlyJoinedCourseId)) {
                    isCourseIncluded = true;
                }
            }
        }

        return isCourseIncluded;
    }

    private void showEventualConsistencyMessage(String recentlyJoinedCourseId) {
        String errorMessage = String.format(Const.StatusMessages.EVENTUAL_CONSISTENCY_MESSAGE_STUDENT,
                                            recentlyJoinedCourseId);
        statusToUser.add(new StatusMessage(errorMessage, StatusMessageColor.DANGER));
    }

    private void addPlaceholderCourse(List<CourseDetailsBundle> courses, String courseId,
            Map<FeedbackSessionAttributes, Boolean> sessionSubmissionStatusMap) {
        try {
            CourseDetailsBundle course = logic.getCourseDetails(courseId);
            courses.add(course);

            addPlaceholderFeedbackSessions(course, sessionSubmissionStatusMap);
            FeedbackSessionDetailsBundle.sortFeedbackSessionsByCreationTime(course.feedbackSessions);

        } catch (EntityDoesNotExistException e) {
            showEventualConsistencyMessage(courseId);
            statusToAdmin = Const.ACTION_RESULT_FAILURE + "" :"" + e.getMessage();
        }
    }

    private void addPlaceholderFeedbackSessions(CourseDetailsBundle course,
                                                Map<FeedbackSessionAttributes, Boolean> sessionSubmissionStatusMap) {
        for (FeedbackSessionDetailsBundle fsb : course.feedbackSessions) {
            sessionSubmissionStatusMap.put(fsb.feedbackSession, true);
        }
    }
}
"
StudentProfileCreateFormUrlAction.java,ui-controller,"package teammates.ui.controller;

import com.google.appengine.api.blobstore.BlobstoreFailureException;

import teammates.common.util.Const;
import teammates.common.util.GoogleCloudStorageHelper;
import teammates.common.util.Logger;
import teammates.common.util.Url;
import teammates.ui.pagedata.StudentProfileCreateFormUrlAjaxPageData;

/**
 * Action: generates the UploadUrl for pictures given by students.
 *         A dynamic generation is done to circumvent the 10 minute
 *         time limit for such URLs
 */
public class StudentProfileCreateFormUrlAction extends Action {

    private static final Logger log = Logger.getLogger();

    @Override
    protected ActionResult execute() {
        StudentProfileCreateFormUrlAjaxPageData data =
                new StudentProfileCreateFormUrlAjaxPageData(account, sessionToken, getUploadUrl(), isError);
        return createAjaxResult(data);
    }

    private String getUploadUrl() {
        String callbackUrl = Url.addParamToUrl(Const.ActionURIs.STUDENT_PROFILE_PICTURE_UPLOAD,
                Const.ParamsNames.SESSION_TOKEN, sessionToken);
        try {
            String uploadUrl = GoogleCloudStorageHelper.getNewUploadUrl(callbackUrl);
            statusToAdmin = ""Created Url successfully: "" + uploadUrl;
            return uploadUrl;
        } catch (BlobstoreFailureException e) {
            isError = true;
            statusToAdmin = ""Failed to create profile picture upload-url: "" + e.getMessage();
        } catch (IllegalArgumentException e) {
            // This branch is not tested as this error can and should never occur
            isError = true;
            log.severe(callbackUrl + "" was found to be illegal success path. Error: "" + e.getMessage());
            statusToAdmin = ""Failed to create profile picture upload-url: "" + e.getMessage();
        }
        return """";
    }

}
"
StudentProfileEditSaveAction.java,ui-controller,"package teammates.ui.controller;

import teammates.common.datatransfer.attributes.StudentProfileAttributes;
import teammates.common.exception.EntityDoesNotExistException;
import teammates.common.exception.InvalidParametersException;
import teammates.common.util.Assumption;
import teammates.common.util.Const;
import teammates.common.util.SanitizationHelper;
import teammates.common.util.StatusMessage;
import teammates.common.util.StatusMessageColor;
import teammates.common.util.StringHelper;

/**
 * Action: saves the new profile details given by a student.
 *         A purely Action based URI as it redirects back to
 *         StudentProfilePageAction once completed
 */
public class StudentProfileEditSaveAction extends Action {

    @Override
    protected ActionResult execute() throws EntityDoesNotExistException {
        try {
            account.studentProfile = extractProfileData();
            logic.updateStudentProfile(account.studentProfile);
            statusToUser.add(new StatusMessage(Const.StatusMessages.STUDENT_PROFILE_EDITED, StatusMessageColor.SUCCESS));
            statusToAdmin = ""Student Profile for <span class=\""bold\"">("" + account.googleId
                          + "")</span> edited.<br>""
                          + SanitizationHelper.sanitizeForHtmlTag(account.studentProfile.toString());
        } catch (InvalidParametersException ipe) {
            setStatusForException(ipe);
        }
        return createRedirectResult(Const.ActionURIs.STUDENT_PROFILE_PAGE);
    }

    private void validatePostParameters(StudentProfileAttributes studentProfile) {
        Assumption.assertPostParamNotNull(Const.ParamsNames.STUDENT_SHORT_NAME, studentProfile.shortName);
        Assumption.assertPostParamNotNull(Const.ParamsNames.STUDENT_EMAIL, studentProfile.email);
        Assumption.assertPostParamNotNull(Const.ParamsNames.STUDENT_GENDER, studentProfile.gender);
        Assumption.assertPostParamNotNull(Const.ParamsNames.STUDENT_NATIONALITY, studentProfile.nationality);
        Assumption.assertPostParamNotNull(Const.ParamsNames.STUDENT_PROFILE_INSTITUTION, studentProfile.institute);
        Assumption.assertPostParamNotNull(Const.ParamsNames.STUDENT_PROFILE_MOREINFO, studentProfile.moreInfo);
    }

    private StudentProfileAttributes extractProfileData() {
        StudentProfileAttributes editedProfile = StudentProfileAttributes.builder().build();

        editedProfile.googleId = account.googleId;
        editedProfile.shortName = getRequestParamValue(Const.ParamsNames.STUDENT_SHORT_NAME);
        editedProfile.email = getRequestParamValue(Const.ParamsNames.STUDENT_PROFILE_EMAIL);
        editedProfile.institute = getRequestParamValue(Const.ParamsNames.STUDENT_PROFILE_INSTITUTION);
        editedProfile.nationality = getRequestParamValue(Const.ParamsNames.STUDENT_NATIONALITY);
        if ("""".equals(editedProfile.nationality)) {
            editedProfile.nationality = getRequestParamValue(""existingNationality"");
        }
        editedProfile.gender = getRequestParamValue(Const.ParamsNames.STUDENT_GENDER);
        editedProfile.moreInfo = getRequestParamValue(Const.ParamsNames.STUDENT_PROFILE_MOREINFO);
        editedProfile.pictureKey = """";

        preprocessParameters(editedProfile);
        validatePostParameters(editedProfile);

        return editedProfile;
    }

    private void preprocessParameters(StudentProfileAttributes studentProfile) {
        studentProfile.shortName = StringHelper.trimIfNotNull(studentProfile.shortName);
        studentProfile.email = StringHelper.trimIfNotNull(studentProfile.email);
        studentProfile.gender = StringHelper.trimIfNotNull(studentProfile.gender);
        studentProfile.nationality = StringHelper.trimIfNotNull(studentProfile.nationality);
        studentProfile.institute = StringHelper.trimIfNotNull(studentProfile.institute);
        studentProfile.moreInfo = StringHelper.trimIfNotNull(studentProfile.moreInfo);
    }

}
"
StudentProfilePageAction.java,ui-controller,"package teammates.ui.controller;

import teammates.common.util.Const;
import teammates.common.util.Logger;
import teammates.common.util.SanitizationHelper;
import teammates.ui.pagedata.StudentProfilePageData;

/**
 * Action: showing the profile page for a student in a course.
 */
public class StudentProfilePageAction extends Action {

    private static final Logger log = Logger.getLogger();

    @Override
    protected ActionResult execute() {
        account.studentProfile = logic.getStudentProfile(account.googleId);
        String isEditingPhoto = getRequestParamValue(Const.ParamsNames.STUDENT_PROFILE_PHOTOEDIT);
        if (isEditingPhoto == null) {
            isEditingPhoto = ""false"";
        }

        if (account.studentProfile == null) {
            log.severe(""Student Profile returned as null for "" + account.toString());
            return createRedirectResult(Const.ActionURIs.STUDENT_HOME_PAGE);
        }

        StudentProfilePageData data = new StudentProfilePageData(account, sessionToken, isEditingPhoto);
        statusToAdmin = ""studentProfile Page Load <br> Profile: ""
                + SanitizationHelper.sanitizeForHtmlTag(account.studentProfile.toString());

        return createShowPageResult(Const.ViewURIs.STUDENT_PROFILE_PAGE, data);
    }

}
"
StudentProfilePictureAction.java,ui-controller,"package teammates.ui.controller;

import teammates.common.datatransfer.attributes.StudentAttributes;
import teammates.common.datatransfer.attributes.StudentProfileAttributes;
import teammates.common.exception.EntityDoesNotExistException;
import teammates.common.exception.InvalidParametersException;
import teammates.common.util.Assumption;
import teammates.common.util.Const;
import teammates.common.util.Logger;
import teammates.common.util.StringHelper;

/**
 * Action: serves a profile picture that is stored in Google Cloud Storage.
 */
public class StudentProfilePictureAction extends Action {

    private static final Logger log = Logger.getLogger();

    @Override
    protected ActionResult execute() throws EntityDoesNotExistException {
        boolean isRequestFromStudent = getRequestParamValue(Const.ParamsNames.BLOB_KEY) != null;
        boolean isRequestFromInstructorOrOtherStudent =
                                        getRequestParamValue(Const.ParamsNames.STUDENT_EMAIL) != null;

        if (!isRequestFromStudent && !isRequestFromInstructorOrOtherStudent) {
            Assumption.fail(""expected blob-key, or student email with courseId"");
        }

        ActionResult result = null;
        if (isRequestFromStudent) {
            result = handleRequestWithBlobKey();
            statusToAdmin = ""Requested Profile Picture by student directly"";
        } else if (isRequestFromInstructorOrOtherStudent) {
            result = handleRequestWithEmailAndCourse();
            statusToAdmin = ""Requested Profile Picture by instructor/other students"";
        }

        return result;
    }

    private ActionResult handleRequestWithBlobKey() {
        String blobKey = getBlobKeyFromRequest();
        log.info(""blob-key given: "" + blobKey);
        return createImageResult(blobKey);
    }

    private ActionResult handleRequestWithEmailAndCourse()
            throws EntityDoesNotExistException {
        String email;
        String courseId;
        try {
            email = getStudentEmailFromRequest();
            courseId = getCourseIdFromRequest();
        } catch (InvalidParametersException e) {
            log.warning(""Attempting to decrypt malformed ciphertext when retrieving email or course id from request."");
            throw new EntityDoesNotExistException(e);
        }

        log.info(""email: "" + email + "", course: "" + courseId);

        StudentAttributes student = getStudentForGivenParameters(courseId, email);
        gateKeeper.verifyAccessibleForCurrentUserAsInstructorOrTeamMember(account, courseId, student.section, email);

        return createImageResult(getPictureKeyForStudent(student));
    }

    private StudentAttributes getStudentForGivenParameters(String courseId, String email)
            throws EntityDoesNotExistException {
        StudentAttributes student = logic.getStudentForEmail(courseId, email);
        if (student == null) {
            throw new EntityDoesNotExistException(""student with "" + courseId + ""/"" + email);
        }
        return student;
    }

    private String getBlobKeyFromRequest() {
        String blobKey = getRequestParamValue(Const.ParamsNames.BLOB_KEY);
        Assumption.assertPostParamNotNull(Const.ParamsNames.BLOB_KEY, blobKey);
        return blobKey;
    }

    private String getCourseIdFromRequest() throws InvalidParametersException {
        String courseId = getRequestParamValue(Const.ParamsNames.COURSE_ID);
        Assumption.assertPostParamNotNull(Const.ParamsNames.COURSE_ID, courseId);
        courseId = StringHelper.decrypt(courseId);
        return courseId;
    }

    private String getStudentEmailFromRequest() throws InvalidParametersException {
        String email = getRequestParamValue(Const.ParamsNames.STUDENT_EMAIL);
        Assumption.assertPostParamNotNull(Const.ParamsNames.STUDENT_EMAIL, email);
        email = StringHelper.decrypt(email);
        return email;
    }

    private String getPictureKeyForStudent(StudentAttributes student) {
        // picture request is only relevant for registered student
        if (!student.googleId.isEmpty()) {
            StudentProfileAttributes profile = logic.getStudentProfile(student.googleId);

            // TODO: remove the null check once all legacy data has been ported
            if (profile != null) {
                return profile.pictureKey;
            }
        }
        return """";
    }

}
"
StudentProfilePictureEditAction.java,ui-controller,"package teammates.ui.controller;

import java.io.IOException;

import com.google.appengine.api.blobstore.BlobKey;
import com.google.appengine.api.images.CompositeTransform;
import com.google.appengine.api.images.Image;
import com.google.appengine.api.images.ImagesService;
import com.google.appengine.api.images.ImagesServiceFactory;
import com.google.appengine.api.images.OutputSettings;
import com.google.appengine.api.images.Transform;

import teammates.common.util.Assumption;
import teammates.common.util.Const;
import teammates.common.util.GoogleCloudStorageHelper;
import teammates.common.util.StatusMessage;
import teammates.common.util.StatusMessageColor;

/**
 * Action: edits the profile picture based on the coordinates of
 *         the cropped photograph.
 */
public class StudentProfilePictureEditAction extends Action {

    private BlobKey blobKey;
    private String widthString;
    private String heightString;
    private String bottomYString;
    private String rightXString;
    private String topYString;
    private String leftXString;
    private String rotateString;

    @Override
    protected ActionResult execute() {
        gateKeeper.verifyLoggedInUserPrivileges();
        readAllPostParameterValuesToFields();
        if (!validatePostParameters()) {
            return createRedirectResult(Const.ActionURIs.STUDENT_PROFILE_PAGE);
        }

        try {
            byte[] transformedImage = this.transformImage();
            if (!isError) {
                // this branch is covered in UiTests (look at todo in transformImage())
                GoogleCloudStorageHelper.writeImageDataToGcs(account.googleId, transformedImage);
            }
        } catch (IOException e) {
            // Happens when GCS Service is down
            isError = true;
            statusToUser.add(new StatusMessage(Const.StatusMessages.STUDENT_PROFILE_PIC_SERVICE_DOWN,
                                               StatusMessageColor.DANGER));
            statusToAdmin = Const.ACTION_RESULT_FAILURE + "" : Writing transformed image to file failed. Error: ""
                          + e.getMessage();
        }

        return createRedirectResult(Const.ActionURIs.STUDENT_PROFILE_PAGE);
    }

    private byte[] transformImage() {
        try {
            /*
             * This branch is covered in UiTests as the following method does
             * not behave the same in dev as in staging.
             * TODO: find a way to cover it in Action Tests.
             */
            Image newImage = getTransformedImage();
            return newImage.getImageData();
        } catch (RuntimeException re) {
            isError = true;
            statusToUser.add(new StatusMessage(Const.StatusMessages.STUDENT_PROFILE_PICTURE_EDIT_FAILED,
                                               StatusMessageColor.DANGER));
            statusToAdmin = Const.ACTION_RESULT_FAILURE + "" : Reading and transforming image failed.""
                          + re.getMessage();
        }

        return new byte[0];
    }

    private Image getTransformedImage() {
        Assumption.assertNotNull(blobKey);

        Image oldImage = ImagesServiceFactory.makeImageFromBlob(blobKey);
        CompositeTransform finalTransform = getCompositeTransformToApply();
        OutputSettings settings = new OutputSettings(ImagesService.OutputEncoding.PNG);

        return ImagesServiceFactory.getImagesService().applyTransform(finalTransform, oldImage, settings);
    }

    private Transform getScaleTransform() {
        Double width = Double.parseDouble(widthString);
        Double height = Double.parseDouble(heightString);
        return ImagesServiceFactory.makeResize((int) Math.round(width), (int) Math.round(height));
    }

    private Transform getRotateTransform() {
        Double rotate = Double.parseDouble(rotateString);
        return ImagesServiceFactory.makeRotate((int) Math.round(rotate));
    }

    private Transform getCropTransform() {
        Double height = Double.parseDouble(heightString);
        Double width = Double.parseDouble(widthString);
        Double leftX = Double.parseDouble(leftXString) / width;
        Double topY = Double.parseDouble(topYString) / height;
        Double rightX = Double.parseDouble(rightXString) / width;
        Double bottomY = Double.parseDouble(bottomYString) / height;
        return ImagesServiceFactory.makeCrop(leftX, topY, rightX, bottomY);
    }

    private CompositeTransform getCompositeTransformToApply() {
        Transform standardCompress = ImagesServiceFactory.makeResize(150, 150);
        return ImagesServiceFactory.makeCompositeTransform()
                .concatenate(getScaleTransform())
                .concatenate(getRotateTransform())
                .concatenate(getCropTransform())
                .concatenate(standardCompress);
    }

    /**
     * Checks that the information given via POST is valid.
     */
    private boolean validatePostParameters() {
        if (leftXString.isEmpty() || topYString.isEmpty()
                || rightXString.isEmpty() || bottomYString.isEmpty()) {
            isError = true;
            statusToUser.add(new StatusMessage(""Given crop locations were not valid. Please try again"",
                                               StatusMessageColor.DANGER));
            statusToAdmin = Const.ACTION_RESULT_FAILURE + "" : One or more of the given coords were empty."";
            return false;
        } else if (heightString.isEmpty() || widthString.isEmpty()) {
            isError = true;
            statusToUser.add(new StatusMessage(""Given crop locations were not valid. Please try again"",
                                               StatusMessageColor.DANGER));
            statusToAdmin = Const.ACTION_RESULT_FAILURE + "" : One or both of the image dimensions were empty."";
            return false;
        } else if (Double.parseDouble(widthString) == 0
                || Double.parseDouble(heightString) == 0) {
            isError = true;
            statusToUser.add(new StatusMessage(""Given crop locations were not valid. Please try again"",
                                               StatusMessageColor.DANGER));
            statusToAdmin = Const.ACTION_RESULT_FAILURE + "" : One or both of the image dimensions were zero."";
            return false;
        }
        return true;
    }

    /**
     * Gets all the parameters from the Request and ensures that they are not null.
     */
    private void readAllPostParameterValuesToFields() {
        leftXString = getLeftXString();
        topYString = getTopYString();
        rightXString = getRightXString();
        bottomYString = getBottomYString();
        heightString = getPictureHeight();
        widthString = getPictureWidth();
        blobKey = getBlobKey();
        rotateString = getRotateString();
    }

    private BlobKey getBlobKey() {
        Assumption.assertPostParamNotNull(Const.ParamsNames.BLOB_KEY,
                                          getRequestParamValue(Const.ParamsNames.BLOB_KEY));
        return new BlobKey(getRequestParamValue(Const.ParamsNames.BLOB_KEY));
    }

    private String getPictureWidth() {
        Assumption.assertPostParamNotNull(Const.ParamsNames.PROFILE_PICTURE_WIDTH,
                                          getRequestParamValue(Const.ParamsNames.PROFILE_PICTURE_WIDTH));
        return getRequestParamValue(Const.ParamsNames.PROFILE_PICTURE_WIDTH);
    }

    private String getPictureHeight() {
        Assumption.assertPostParamNotNull(Const.ParamsNames.PROFILE_PICTURE_HEIGHT,
                                          getRequestParamValue(Const.ParamsNames.PROFILE_PICTURE_HEIGHT));
        return getRequestParamValue(Const.ParamsNames.PROFILE_PICTURE_HEIGHT);
    }

    private String getBottomYString() {
        Assumption.assertPostParamNotNull(Const.ParamsNames.PROFILE_PICTURE_BOTTOMY,
                                          getRequestParamValue(Const.ParamsNames.PROFILE_PICTURE_BOTTOMY));
        return getRequestParamValue(Const.ParamsNames.PROFILE_PICTURE_BOTTOMY);
    }

    private String getRightXString() {
        Assumption.assertPostParamNotNull(Const.ParamsNames.PROFILE_PICTURE_RIGHTX,
                                          getRequestParamValue(Const.ParamsNames.PROFILE_PICTURE_RIGHTX));
        return getRequestParamValue(Const.ParamsNames.PROFILE_PICTURE_RIGHTX);
    }

    private String getTopYString() {
        Assumption.assertPostParamNotNull(Const.ParamsNames.PROFILE_PICTURE_TOPY,
                                          getRequestParamValue(Const.ParamsNames.PROFILE_PICTURE_TOPY));
        return getRequestParamValue(Const.ParamsNames.PROFILE_PICTURE_TOPY);
    }

    private String getLeftXString() {
        Assumption.assertPostParamNotNull(Const.ParamsNames.PROFILE_PICTURE_LEFTX,
                                          getRequestParamValue(Const.ParamsNames.PROFILE_PICTURE_LEFTX));
        return getRequestParamValue(Const.ParamsNames.PROFILE_PICTURE_LEFTX);
    }

    private String getRotateString() {
        Assumption.assertPostParamNotNull(Const.ParamsNames.PROFILE_PICTURE_ROTATE,
                                          getRequestParamValue(Const.ParamsNames.PROFILE_PICTURE_ROTATE));
        return getRequestParamValue(Const.ParamsNames.PROFILE_PICTURE_ROTATE);
    }
}
"
StudentProfilePictureUploadAction.java,ui-controller,"package teammates.ui.controller;

import java.io.IOException;
import java.io.InputStream;
import java.util.List;
import java.util.Map;

import com.google.appengine.api.blobstore.BlobInfo;
import com.google.appengine.api.blobstore.BlobKey;
import com.google.appengine.api.blobstore.BlobstoreFailureException;
import com.google.appengine.api.blobstore.BlobstoreInputStream;
import com.google.appengine.api.blobstore.BlobstoreServiceFactory;

import teammates.common.exception.EntityDoesNotExistException;
import teammates.common.util.Assumption;
import teammates.common.util.Const;
import teammates.common.util.GoogleCloudStorageHelper;
import teammates.common.util.StatusMessage;
import teammates.common.util.StatusMessageColor;

/**
 * Action: saves the file information of the profile picture
 *         that was just uploaded.
 */
public class StudentProfilePictureUploadAction extends Action {
    /*
     * This class is not tested in ActionTests as it is difficult to
     * reproduce the upload action done by Google Blobstore API
     * without the server running.
     * This class is covered in UiTests.
     */
    @Override
    protected ActionResult execute() throws EntityDoesNotExistException {
        gateKeeper.verifyLoggedInUserPrivileges();

        String pictureKey = """";
        BlobKey blobKey = new BlobKey("""");
        RedirectResult r = createRedirectResult(Const.ActionURIs.STUDENT_PROFILE_PAGE);

        try {
            BlobInfo blobInfo = extractProfilePictureKey();
            if (!isError) {
                blobKey = blobInfo.getBlobKey();
                pictureKey = renameFileToGoogleId(blobInfo);
                logic.updateStudentProfilePicture(account.googleId, pictureKey);
                statusToUser.add(new StatusMessage(Const.StatusMessages.STUDENT_PROFILE_PICTURE_SAVED,
                                                   StatusMessageColor.SUCCESS));
                r.addResponseParam(Const.ParamsNames.STUDENT_PROFILE_PHOTOEDIT, ""true"");
            }
        } catch (BlobstoreFailureException | IOException bfe) {
            deletePicture(blobKey);
            updateStatusesForBlobstoreFailure();
            isError = true;
        } catch (Exception e) {
            /*
             * This is for other exceptions like EntityNotFound, IllegalState, etc
             * that occur rarely and are handled higher up.
             */
            deletePicture(new BlobKey(pictureKey));
            statusToUser.clear();
            throw e;
        }

        return r;
    }

    private String renameFileToGoogleId(BlobInfo blobInfo) throws IOException {
        Assumption.assertNotNull(blobInfo);

        BlobKey blobKey = blobInfo.getBlobKey();
        InputStream blobStream = new BlobstoreInputStream(blobKey);
        byte[] imageData = new byte[(int) blobInfo.getSize()];
        blobStream.read(imageData);
        blobStream.close();

        deletePicture(blobKey);
        return GoogleCloudStorageHelper.writeImageDataToGcs(account.googleId, imageData);
    }

    private BlobInfo extractProfilePictureKey() {
        try {
            Map<String, List<BlobInfo>> blobsMap = BlobstoreServiceFactory.getBlobstoreService()
                                                                          .getBlobInfos(request);
            List<BlobInfo> blobs = blobsMap.get(Const.ParamsNames.STUDENT_PROFILE_PHOTO);
            if (blobs == null || blobs.isEmpty()) {
                statusToUser.add(new StatusMessage(Const.StatusMessages.STUDENT_PROFILE_NO_PICTURE_GIVEN,
                                                   StatusMessageColor.DANGER));
                isError = true;
                return null;
            }
            BlobInfo profilePic = blobs.get(0);
            return validateProfilePicture(profilePic);
        } catch (IllegalStateException e) {
            /*
             * This means the action was called directly (and not via BlobStore API callback).
             * Simply redirect to ProfilePage.
             */
            return null;
        }
    }

    private BlobInfo validateProfilePicture(BlobInfo profilePic) {
        if (profilePic.getSize() > Const.SystemParams.MAX_PROFILE_PIC_SIZE) {
            deletePicture(profilePic.getBlobKey());
            isError = true;
            statusToUser.add(new StatusMessage(Const.StatusMessages.STUDENT_PROFILE_PIC_TOO_LARGE,
                                               StatusMessageColor.DANGER));
            return null;
        } else if (!profilePic.getContentType().contains(""image/"")) {
            deletePicture(profilePic.getBlobKey());
            isError = true;
            statusToUser.add(new StatusMessage(Const.StatusMessages.STUDENT_PROFILE_NOT_A_PICTURE,
                                               StatusMessageColor.DANGER));
            return null;
        }

        return profilePic;
    }

    private void deletePicture(BlobKey blobKey) {
        if (blobKey.equals(new BlobKey(""""))) {
            return;
        }
        try {
            logic.deletePicture(blobKey);
        } catch (BlobstoreFailureException bfe) {
            statusToAdmin = Const.ACTION_RESULT_FAILURE
                          + "" : Unable to delete profile picture (possible unused picture with key: ""
                          + blobKey.getKeyString() + "" || Error Message: ""
                          + bfe.getMessage() + Const.EOL;
        }
    }

    private void updateStatusesForBlobstoreFailure() {
        statusToAdmin += Const.ACTION_RESULT_FAILURE + "" : Could not delete profile picture for account (""
                       + account.googleId + "")"" + Const.EOL;
        statusToUser.clear();
        statusToUser.add(new StatusMessage(Const.StatusMessages.STUDENT_PROFILE_PIC_SERVICE_DOWN,
                                           StatusMessageColor.DANGER));
    }

}
"
Activity.java,util,"package teammates.common.util;

/**
 * This is not used at the moment. It is for future reference. We plan
 * to pass Activity as an additional parameter to access control methods for
 * finer-grain access control. e.g., to block some instructors from viewing
 * results of an evaluation.
 */
public enum Activity {
    ADD, VIEW, UPDATE, DELETE
}
"
ActivityLogEntry.java,util,"package teammates.common.util;

import java.util.Arrays;
import java.util.regex.Pattern;

import com.google.appengine.api.log.AppLogLine;

/**
 * A log entry to describe an action carried out by the app.
 */
public final class ActivityLogEntry {
    // The following constants describe the positions of the attributes
    // in the log message. i.e
    // TEAMMATESLOG|||ACTION_NAME|||ACTION_RESPONSE|||TO_SHOW|||ROLE|||NAME|||GOOGLE_ID|||EMAIL
    // |||MESSAGE(IN HTML)|||URL|||TIME_TAKEN
    private static final int POSITION_OF_ACTION_NAME = 1;
    private static final int POSITION_OF_ACTION_RESPONSE = 2;
    private static final int POSITION_OF_USER_ROLE = 4;
    private static final int POSITION_OF_USER_NAME = 5;
    private static final int POSITION_OF_USER_GOOGLEID = 6;
    private static final int POSITION_OF_USER_EMAIL = 7;
    private static final int POSITION_OF_LOG_MESSAGE = 8;
    private static final int POSITION_OF_ACTION_URL = 9;
    private static final int POSITION_OF_LOG_ID = 10;
    private static final int POSITION_OF_LOG_TIMETAKEN = 11;

    private static final Logger log = Logger.getLogger();

    // Required fields

    // id can be in the form of <googleId>%<time> e.g. bamboo3250%20151103170618465
    // or <studentemail>%<courseId>%<time> (for unregistered students)
    //     e.g. bamboo@gmail.tmt%instructor.ema-demo%20151103170618465
    private String logId;

    private long logTime;
    private String actionUrl;
    private String actionName;
    private String actionResponse;

    // Optional fields

    private String userRole;
    private boolean isMasqueradeUserRole;

    private String userName;
    private String userEmail;
    private String userGoogleId;

    private String logMessage;

    private long actionTimeTaken;

    // this field will always be true in log message for history reason
    private boolean shouldShowLog = true;

    private ActivityLogEntry() {
        // private constructor to prevent instantiation
    }

    /**
     * Generates a log message that will be logged in the server.
     */
    public String generateLogMessage() {
        // TEAMMATESLOG|||SERVLET_NAME|||ACTION|||TO_SHOW|||ROLE|||NAME|||GOOGLE_ID|||EMAIL|||MESSAGE(IN HTML)|||URL|||ID
        String userRoleSuffix = isMasqueradeUserRole ? Const.ActivityLog.ROLE_MASQUERADE_POSTFIX : """";
        return StringHelper.join(Const.ActivityLog.FIELD_SEPARATOR, Const.ActivityLog.TEAMMATESLOG,
                actionName, actionResponse, Boolean.toString(shouldShowLog), userRole + userRoleSuffix,
                userName, userGoogleId, userEmail, logMessage, actionUrl, logId);
    }

    public String getLogId() {
        return logId;
    }

    public boolean getShouldShowLog() {
        return shouldShowLog;
    }

    public String getActionUrl() {
        return actionUrl;
    }

    public String getLogMessage() {
        return logMessage;
    }

    public long getLogTime() {
        return logTime;
    }

    public long getActionTimeTaken() {
        return actionTimeTaken;
    }

    public String getActionName() {
        return actionName;
    }

    public String getActionResponse() {
        return actionResponse;
    }

    public String getUserRole() {
        return userRole;
    }

    public boolean isMasqueradeUserRole() {
        return isMasqueradeUserRole;
    }

    public String getUserName() {
        return userName;
    }

    public String getUserGoogleId() {
        return userGoogleId;
    }

    public String getUserEmail() {
        return userEmail;
    }

    /**
     * Checks whether the activity log is related to testing data or not.
     */
    public boolean isTestingData() {
        return userEmail.endsWith(Const.ActivityLog.TESTING_DATA_EMAIL_POSTFIX);
    }

    /**
     * Builds an {@link ActivityLogEntry} from {@link AppLogLine} provided by GAE.
     *
     * <p>If the log message in {@link AppLogLine} is not in desired format, an instance will still
     * be constructed, but with log message: {@link Const.ActivityLog.MESSAGE_ERROR_LOG_MESSAGE_FORMAT}
     */
    public static ActivityLogEntry buildFromAppLog(AppLogLine appLog) {
        String[] tokens = appLog.getLogMessage().split(Pattern.quote(Const.ActivityLog.FIELD_SEPARATOR), -1);
        if (tokens.length < POSITION_OF_LOG_ID + 1) {
            // the number of fields is not enough, which should be an error
            return initActivityLogAsFailure(appLog);
        }
        return initActivityLogUsingAppLogMessage(appLog, tokens);
    }

    private static ActivityLogEntry initActivityLogAsFailure(AppLogLine appLog) {
        Builder builder =
                new Builder(Const.ActivityLog.UNKNOWN, Const.ActivityLog.UNKNOWN, appLog.getTimeUsec() / 1000);
        String logMessage = ""<span class=\""text-danger\"">""
                            + Const.ActivityLog.MESSAGE_ERROR_LOG_MESSAGE_FORMAT + ""</span><br>"";
        builder.withLogMessage(logMessage);
        return builder.build();
    }

    private static ActivityLogEntry initActivityLogUsingAppLogMessage(AppLogLine appLog, String[] tokens) {
        // TEAMMATESLOG|||ACTION_NAME|||ACTION_RESPONSE|||TO_SHOW|||ROLE|||NAME|||GOOGLE_ID|||EMAIL
        // |||MESSAGE(IN HTML)|||URL|||TIME_TAKEN
        String actionName = tokens[POSITION_OF_ACTION_NAME];
        String actionUrl = tokens[POSITION_OF_ACTION_URL];
        long time = appLog.getTimeUsec() / 1000;
        Builder builder = new Builder(actionName, actionUrl, time);

        builder.withActionResponse(tokens[POSITION_OF_ACTION_RESPONSE])
                .withLogId(tokens[POSITION_OF_LOG_ID])
                .withLogMessage(tokens[POSITION_OF_LOG_MESSAGE])
                .withMasqueradeUserRole(
                        tokens[POSITION_OF_USER_ROLE].contains(Const.ActivityLog.ROLE_MASQUERADE_POSTFIX))
                .withUserEmail(tokens[POSITION_OF_USER_EMAIL])
                .withUserGoogleId(tokens[POSITION_OF_USER_GOOGLEID])
                .withUserName(tokens[POSITION_OF_USER_NAME]);
        String userRole = tokens[POSITION_OF_USER_ROLE];
        builder.withUserRole(userRole.replace(Const.ActivityLog.ROLE_MASQUERADE_POSTFIX, """"));

        try {
            long actionTimeTaken = tokens.length == ActivityLogEntry.POSITION_OF_LOG_TIMETAKEN + 1
                                 ? Long.parseLong(tokens[ActivityLogEntry.POSITION_OF_LOG_TIMETAKEN].trim())
                                 : 0;
            builder.withActionTimeTaken(actionTimeTaken);
        } catch (NumberFormatException e) {
            log.severe(String.format(Const.ActivityLog.MESSAGE_ERROR_LOG_MESSAGE_FORMAT, Arrays.toString(tokens)));
        }

        return builder.build();
    }

    /**
     * A builder class for {@link ActivityLogEntry}.
     *
     * <p>All optional fields are initialized to {@link Const.ActivityLog.UNKNOWN}.
     * Field actionResponse will be initialized to have the same value as actionName.
     * All null values (if possible) that are passed into the builder will be ignored.
     *
     * @see ActivityLogEntry
     */
    public static class Builder {
        // Required parameters
        private String actionName;
        private String actionUrl;
        private long logTime;
        private String actionResponse;

        // Optional parameters - initialized to default values
        private long actionTimeTaken;
        private String userRole = Const.ActivityLog.UNKNOWN;
        private String userName = Const.ActivityLog.UNKNOWN;
        private String userGoogleId = Const.ActivityLog.UNKNOWN;
        private String userEmail = Const.ActivityLog.UNKNOWN;
        private String logMessage = Const.ActivityLog.UNKNOWN;
        private String logId = Const.ActivityLog.UNKNOWN;
        private boolean isMasqueradeUserRole;

        public Builder(String name, String url, long time) {
            actionName = name == null ? Const.ActivityLog.UNKNOWN : name;
            actionUrl = url == null ? Const.ActivityLog.UNKNOWN : url;
            logTime = time;

            actionResponse = actionName;
        }

        public Builder withActionResponse(String val) {
            if (val != null) {
                actionResponse = val;
            }
            return this;
        }

        public Builder withUserRole(String val) {
            if (val != null) {
                userRole = val;
            }
            return this;
        }

        public Builder withUserName(String val) {
            if (val != null) {
                userName = val;
            }
            return this;
        }

        public Builder withUserGoogleId(String val) {
            if (val != null) {
                userGoogleId = val;
            }
            return this;
        }

        public Builder withUserEmail(String val) {
            if (val != null) {
                userEmail = val;
            }
            return this;
        }

        public Builder withMasqueradeUserRole(boolean val) {
            isMasqueradeUserRole = val;
            return this;
        }

        public Builder withLogId(String val) {
            if (val != null) {
                logId = val;
            }
            return this;
        }

        public Builder withLogMessage(String val) {
            if (val != null) {
                logMessage = val;
            }
            return this;
        }

        public Builder withActionTimeTaken(long val) {
            actionTimeTaken = val;
            return this;
        }

        public long getLogTime() {
            return logTime;
        }

        public String getActionName() {
            return actionName;
        }

        // use builder to build ActivityLogEntry
        @SuppressWarnings({""PMD.AccessorMethodGeneration"", ""PMD.AccessorClassGeneration""})
        public ActivityLogEntry build() {
            ActivityLogEntry entry = new ActivityLogEntry();

            entry.logTime = logTime;
            entry.actionName = actionName;
            entry.actionTimeTaken = actionTimeTaken;
            entry.actionResponse = actionResponse;
            entry.userRole = userRole;
            entry.userName = userName;
            entry.userGoogleId = userGoogleId;
            entry.userEmail = userEmail;
            entry.logMessage = logMessage;
            entry.actionUrl = actionUrl;
            entry.logId = logId;
            entry.actionTimeTaken = actionTimeTaken;
            entry.isMasqueradeUserRole = isMasqueradeUserRole;
            return entry;
        }
    }
}
"
AdminLogQuery.java,util,"package teammates.common.util;

import java.util.List;

import com.google.appengine.api.log.LogQuery;
import com.google.appengine.api.log.LogService.LogLevel;

/**
 * A wrapper class for LogQuery to retrieve logs from GAE server.
 */
public class AdminLogQuery {
    /**
     * A flag to decide whether to include application logs in result or not.
     */
    private static final boolean SHOULD_INCLUDE_APP_LOG = true;

    /**
     * Affects the internal strategy to get logs. It doesn't affect the result.
     */
    private static final int BATCH_SIZE = 1000;
    private static final LogLevel MIN_LOG_LEVEL = LogLevel.INFO;

    private LogQuery query;
    private long startTime;
    private long endTime;

    /**
     * Sets values for query.
     * If startTime is null, it will be considered as 0.
     * If endTime is null, it will be considered as the current time.
     *
     * @param versionsToQuery decide which versions to find logs from.
     */
    public AdminLogQuery(List<String> versionsToQuery, Long startTime, Long endTime) {
        Assumption.assertNotNull(versionsToQuery);

        query = LogQuery.Builder.withDefaults();
        query.includeAppLogs(SHOULD_INCLUDE_APP_LOG);
        query.batchSize(BATCH_SIZE);
        query.minLogLevel(MIN_LOG_LEVEL);
        setTimePeriod(startTime, endTime);
        query.majorVersionIds(versionsToQuery);
    }

    /**
     * Gets query to retrieve logs.
     */
    public LogQuery getQuery() {
        return query;
    }

    /**
     * Sets time period to search for query.
     * If startTime is null, it will be considered as 0.
     * If endTime is null, it will be considered as the current time.
     *
     * <p>The time is in Unix time. https://en.wikipedia.org/wiki/Unix_time
     * 0 means it will take logs after Thursday, 1 January 1970 (since forever).
     */
    public void setTimePeriod(Long startTimeParam, Long endTimeParam) {
        long startTime = startTimeParam == null ? 0L : startTimeParam;
        long endTime = endTimeParam == null ? TimeHelper.now(0.0).getTimeInMillis() : endTimeParam;
        query.startTimeMillis(startTime);
        query.endTimeMillis(endTime);
        this.startTime = startTime;
        this.endTime = endTime;
    }

    /**
     * Gets end time of the query.
     */
    public long getEndTime() {
        return endTime;
    }

    /**
     * Gets start time of the query.
     */
    public long getStartTime() {
        return startTime;
    }

    /**
     * Moves the time period to query logs to the next period in the past with a length of timeInMillis.
     * @param timeInMillis the length of the next period in milliseconds.
     */
    public void moveTimePeriodBackward(long timeInMillis) {
        long nextEndTime = getStartTime() - 1;
        long nextStartTime = nextEndTime - timeInMillis;
        setTimePeriod(nextStartTime, nextEndTime);
    }
}
"
AppUrl.java,util,"package teammates.common.util;

/**
 * A specific implementation of {@link Url} used to encapsulate URLs of the application.
 */
public class AppUrl extends Url {

    public AppUrl(String url) {
        super(url);
        Assumption.assertTrue(url.startsWith(""http"")); // must either be http or https
    }

    public AppUrl withUserId(String userId) {
        return withParam(Const.ParamsNames.USER_ID, userId);
    }

    public AppUrl withRegistrationKey(String key) {
        return withParam(Const.ParamsNames.REGKEY, key);
    }

    public AppUrl withInstructorInstitution(String institute) {
        return withParam(Const.ParamsNames.INSTRUCTOR_INSTITUTION, institute);
    }

    public AppUrl withCourseId(String courseId) {
        return withParam(Const.ParamsNames.COURSE_ID, courseId);
    }

    public AppUrl withSessionName(String feedbackSessionName) {
        return withParam(Const.ParamsNames.FEEDBACK_SESSION_NAME, feedbackSessionName);
    }

    public AppUrl withStudentEmail(String email) {
        return withParam(Const.ParamsNames.STUDENT_EMAIL, email);
    }

    public AppUrl withInstructorId(String instructorId) {
        return withParam(Const.ParamsNames.INSTRUCTOR_ID, instructorId);
    }

    public AppUrl withQuestionNumber(String questionNumber) {
        return withParam(Const.ParamsNames.FEEDBACK_QUESTION_NUMBER, questionNumber);
    }

    public AppUrl withEnableSessionEditDetails(boolean shouldLoadInEditMode) {
        return withParam(Const.ParamsNames.FEEDBACK_SESSION_ENABLE_EDIT, Boolean.toString(shouldLoadInEditMode));
    }

}
"
Assumption.java,util,"package teammates.common.util;

import teammates.common.exception.NullPostParameterException;

/**
 * This class provides a set of static method to verify assumptions about the
 * system. When the real runtime condition differs from the assumed situation,
 * an unchecked AssertionFailedError will be thrown at runtime.
 *
 * <p>Normally, we uses Java assertion to do runtime checking, but GAE does not
 * support the assertions.is This file is a copy of org.junit.Assert v4.10.
 * Cannot use default java assert due to GAE environment restriction
 *
 * @see org.junit.Assert
 */
public final class Assumption {

    private Assumption() {
        // utility class
        // Intentional private constructor to prevent instantiation.
    }

    /**
     * Asserts that a condition is true. If it isn't it throws an
     * AssertionFailedError with the given message.
     */
    public static void assertTrue(String message, boolean condition) {
        if (!condition) {
            fail(message);
        }
    }

    /**
     * Asserts that a condition is true. If it isn't it throws an
     * AssertionFailedError.
     */
    public static void assertTrue(boolean condition) {
        assertTrue(null, condition);
    }

    /**
     * Asserts that a condition is false. If it isn't it throws an
     * AssertionFailedError with the given message.
     */
    public static void assertFalse(String message, boolean condition) {
        assertTrue(message, !condition);
    }

    /**
     * Asserts that a condition is false. If it isn't it throws an
     * AssertionFailedError.
     */
    public static void assertFalse(boolean condition) {
        assertFalse(null, condition);
    }

    /**
     * Fails a test with the given message.
     */
    public static void fail(String message) {
        throw new AssertionError(message);
    }

    /**
     * Fails a test with no message.
     */
    public static void fail() {
        fail(null);
    }

    /**
     * Asserts that two objects are equal. If they are not an
     * AssertionFailedError is thrown with the given message.
     */
    public static void assertEquals(String message, Object expected,
            Object actual) {
        if (expected == null && actual == null) {
            return;
        }

        if (expected != null && expected.equals(actual)) {
            return;
        }

        failNotEquals(message, expected, actual);
    }

    /**
     * Asserts that two objects are equal. If they are not an
     * AssertionFailedError is thrown.
     */
    public static void assertEquals(Object expected, Object actual) {
        assertEquals(null, expected, actual);
    }

    /**
     * Asserts that two Strings are equal.
     */
    public static void assertEquals(String message, String expected,
            String actual) {
        if (expected == null && actual == null) {
            return;
        }

        if (expected != null && expected.equals(actual)) {
            return;
        }

        throw new AssertionError(format(message, expected, actual));
    }

    /**
     * Asserts that two Strings are equal.
     */
    public static void assertEquals(String expected, String actual) {
        assertEquals(null, expected, actual);
    }

    /**
     * Asserts that two doubles are equal concerning a delta. If they are not an
     * AssertionFailedError is thrown with the given message. If the expected
     * value is infinity then the delta value is ignored.
     */
    public static void assertEquals(String message, double expected,
            double actual, double delta) {
        if (Double.compare(expected, actual) == 0) {
            return;
        }

        if (Math.abs(expected - actual) > delta) {
            failNotEquals(message, Double.valueOf(expected), Double.valueOf(actual));
        }
    }

    /**
     * Asserts that two doubles are equal concerning a delta. If the expected
     * value is infinity then the delta value is ignored.
     */
    public static void assertEquals(double expected, double actual, double delta) {
        assertEquals(null, expected, actual, delta);
    }

    /**
     * Asserts that two floats are equal concerning a positive delta. If they
     * are not an AssertionFailedError is thrown with the given message. If the
     * expected value is infinity then the delta value is ignored.
     */
    public static void assertEquals(String message, float expected,
            float actual, float delta) {
        if (Float.compare(expected, actual) == 0) {
            return;
        }

        if (Math.abs(expected - actual) > delta) {
            failNotEquals(message, Float.valueOf(expected), Float.valueOf(actual));
        }
    }

    /**
     * Asserts that two floats are equal concerning a delta. If the expected
     * value is infinity then the delta value is ignored.
     */
    public static void assertEquals(float expected, float actual, float delta) {
        assertEquals(null, expected, actual, delta);
    }

    /**
     * Asserts that two longs are equal. If they are not an AssertionFailedError
     * is thrown with the given message.
     */
    public static void assertEquals(String message, long expected, long actual) {
        assertEquals(message, Long.valueOf(expected), Long.valueOf(actual));
    }

    /**
     * Asserts that two longs are equal.
     */
    public static void assertEquals(long expected, long actual) {
        assertEquals(null, expected, actual);
    }

    /**
     * Asserts that two booleans are equal. If they are not an
     * AssertionFailedError is thrown with the given message.
     */
    public static void assertEquals(String message, boolean expected,
            boolean actual) {
        assertEquals(message, Boolean.valueOf(expected),
                Boolean.valueOf(actual));
    }

    /**
     * Asserts that two booleans are equal.
     */
    public static void assertEquals(boolean expected, boolean actual) {
        assertEquals(null, expected, actual);
    }

    /**
     * Asserts that two bytes are equal. If they are not an AssertionFailedError
     * is thrown with the given message.
     */
    public static void assertEquals(String message, byte expected, byte actual) {
        assertEquals(message, Byte.valueOf(expected), Byte.valueOf(actual));
    }

    /**
     * Asserts that two bytes are equal.
     */
    public static void assertEquals(byte expected, byte actual) {
        assertEquals(null, expected, actual);
    }

    /**
     * Asserts that two chars are equal. If they are not an AssertionFailedError
     * is thrown with the given message.
     */
    public static void assertEquals(String message, char expected, char actual) {
        assertEquals(message, Character.valueOf(expected), Character.valueOf(actual));
    }

    /**
     * Asserts that two chars are equal.
     */
    public static void assertEquals(char expected, char actual) {
        assertEquals(null, expected, actual);
    }

    /**
     * Asserts that two shorts are equal. If they are not an
     * AssertionFailedError is thrown with the given message.
     */
    public static void assertEquals(String message, short expected, short actual) {
        assertEquals(message, Short.valueOf(expected), Short.valueOf(actual));
    }

    /**
     * Asserts that two shorts are equal.
     */
    public static void assertEquals(short expected, short actual) {
        assertEquals(null, expected, actual);
    }

    /**
     * Asserts that two ints are equal. If they are not an AssertionFailedError
     * is thrown with the given message.
     */
    public static void assertEquals(String message, int expected, int actual) {
        assertEquals(message, Integer.valueOf(expected), Integer.valueOf(actual));
    }

    /**
     * Asserts that two ints are equal.
     */
    public static void assertEquals(int expected, int actual) {
        assertEquals(null, expected, actual);
    }

    /**
     * Asserts that an object isn't null.
     */
    public static void assertNotNull(Object object) {
        assertNotNull(null, object);
    }

    /**
     * Asserts that an object isn't null. If it is an AssertionFailedError is
     * thrown with the given message.
     */
    public static void assertNotNull(String message, Object object) {
        assertTrue(message, object != null);
    }

    /**
     * Asserts that an object is null.
     */
    public static void assertNull(Object object) {
        assertNull(null, object);
    }

    /**
     * Asserts that an object is null. If it is not an AssertionFailedError is
     * thrown with the given message.
     */
    public static void assertNull(String message, Object object) {
        assertTrue(message, object == null);
    }

    /**
     * Asserts that two objects refer to the same object. If they are not an
     * AssertionFailedError is thrown with the given message.
     */
    @SuppressWarnings(""PMD.CompareObjectsWithEquals"")
    // PMD.CompareObjectsWithEquals is suppressed as assertSame are checking if
    // the expected and actual are the same objects (not just equal to each other)
    public static void assertSame(String message, Object expected, Object actual) {
        if (expected == actual) {
            return;
        }

        failNotSame(message, expected, actual);
    }

    /**
     * Asserts that two objects refer to the same object. If they are not the
     * same an AssertionFailedError is thrown.
     */
    @SuppressWarnings(""PMD.CompareObjectsWithEquals"")
    // PMD.CompareObjectsWithEquals is suppressed as assertSame are checking if
    // the expected and actual are the same objects (not just equal to each other)
    public static void assertSame(Object expected, Object actual) {
        assertSame(null, expected, actual);
    }

    /**
     * Asserts that two objects do not refer to the same object. If they do
     * refer to the same object an AssertionFailedError is thrown with the given
     * message.
     */
    @SuppressWarnings(""PMD.CompareObjectsWithEquals"")
    // PMD.CompareObjectsWithEquals is suppressed as assertNotSame is checking if
    // the expected and actual are the different objects (not just equal to each other)
    public static void assertNotSame(String message, Object expected,
            Object actual) {
        if (expected == actual) {
            failSame(message);
        }
    }

    /**
     * Asserts that two objects do not refer to the same object. If they do
     * refer to the same object an AssertionFailedError is thrown.
     */
    public static void assertNotSame(Object expected, Object actual) {
        assertNotSame(null, expected, actual);
    }

    public static void failSame(String message) {
        String formatted = """";
        if (message != null) {
            formatted = message + "" "";
        }
        fail(formatted + ""expected not same"");
    }

    public static void failNotSame(String message, Object expected,
            Object actual) {
        String formatted = """";
        if (message != null) {
            formatted = message + "" "";
        }
        fail(formatted + ""expected same:<"" + expected + ""> was not:<"" + actual + "">"");
    }

    public static void failNotEquals(String message, Object expected,
            Object actual) {
        fail(format(message, expected, actual));
    }

    public static String format(String message, Object expected, Object actual) {
        String formatted = """";
        if (message != null) {
            formatted = message + "" "";
        }
        return formatted + ""expected:<"" + expected + ""> but was:<"" + actual + "">"";
    }

    public static <T> void assertPostParamNotNull(String parameterName, T postParameter) {
        if (postParameter == null) {
            throw new NullPostParameterException(String.format(Const.StatusCodes.NULL_POST_PARAMETER,
                    parameterName));
        }
    }

    public static void assertNotEmpty(String str) {
        assertFalse(str.isEmpty());
    }

    public static void assertNotEmpty(String message, String str) {
        assertFalse(message, str.isEmpty());
    }

    public static void assertIsEmpty(String str) {
        assertTrue(str.isEmpty());
    }

    public static void assertIsEmpty(String message, String str) {
        assertTrue(message, str.isEmpty());
    }
}
"
Config.java,util,"package teammates.common.util;

import java.io.IOException;
import java.util.Properties;

import com.google.appengine.api.utils.SystemProperty;

/**
 * Represents the deployment-specific configuration values of the system.
 * This can be used to access values in the build.properties file too.
 */
public final class Config {

    /** The value of the ""app.url"" in build.properties file. */
    public static final String APP_URL;

    /** The value of the ""app.gcs.bucketname"" in build.properties file. */
    public static final String GCS_BUCKETNAME;

    /** The value of the ""app.backdoor.key"" in build.properties file. */
    public static final String BACKDOOR_KEY;

    /** The value of the ""app.encryption.key"" in build.properties file. */
    public static final String ENCRYPTION_KEY;

    /** The value of the ""app.persistence.checkduration"" in build.properties file. */
    public static final int PERSISTENCE_CHECK_DURATION;

    /** The value of the ""app.crashreport.email"" in build.properties file. */
    public static final String SUPPORT_EMAIL;

    /** The value of the ""app.student.motd.url"" in build.properties file. */
    public static final String STUDENT_MOTD_URL;

    /** The value of the ""app.email.senderemail"" in build.properties file. */
    public static final String EMAIL_SENDEREMAIL;

    /** The value of the ""app.email.sendername"" in build.properties file. */
    public static final String EMAIL_SENDERNAME;

    /** The value of the ""app.email.replyto"" in build.properties file. */
    public static final String EMAIL_REPLYTO;

    /** The value of the ""app.email.service"" in build.properties file. */
    public static final String EMAIL_SERVICE;

    /** The value of the ""app.sendgrid.apikey"" in build.properties file. */
    public static final String SENDGRID_APIKEY;

    /** The value of the ""app.mailgun.apikey"" in build.properties file. */
    public static final String MAILGUN_APIKEY;

    /** The value of the ""app.mailgun.domainname"" in build.properties file. */
    public static final String MAILGUN_DOMAINNAME;

    /** The value of the ""app.mailjet.apikey"" in build.properties file. */
    public static final String MAILJET_APIKEY;

    /** The value of the ""app.mailjet.secretkey"" in build.properties file. */
    public static final String MAILJET_SECRETKEY;

    static {
        Properties properties = new Properties();
        try {
            properties.load(FileHelper.getResourceAsStream(""build.properties""));
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
        APP_URL = Url.trimTrailingSlash(properties.getProperty(""app.url""));
        BACKDOOR_KEY = properties.getProperty(""app.backdoor.key"");
        GCS_BUCKETNAME = properties.getProperty(""app.gcs.bucketname"");
        ENCRYPTION_KEY = properties.getProperty(""app.encryption.key"");
        PERSISTENCE_CHECK_DURATION = Integer.parseInt(properties.getProperty(""app.persistence.checkduration""));
        SUPPORT_EMAIL = properties.getProperty(""app.crashreport.email"");
        STUDENT_MOTD_URL = properties.getProperty(""app.student.motd.url"");
        EMAIL_SENDEREMAIL = properties.getProperty(""app.email.senderemail"");
        EMAIL_SENDERNAME = properties.getProperty(""app.email.sendername"");
        EMAIL_REPLYTO = properties.getProperty(""app.email.replyto"");
        EMAIL_SERVICE = properties.getProperty(""app.email.service"");
        SENDGRID_APIKEY = properties.getProperty(""app.sendgrid.apikey"");
        MAILGUN_APIKEY = properties.getProperty(""app.mailgun.apikey"");
        MAILGUN_DOMAINNAME = properties.getProperty(""app.mailgun.domainname"");
        MAILJET_APIKEY = properties.getProperty(""app.mailjet.apikey"");
        MAILJET_SECRETKEY = properties.getProperty(""app.mailjet.secretkey"");
    }

    private Config() {
        // access static fields directly
    }

    /**
     * This method is not to be used by classes not compiled by GAE (e.g non-production codes).
     * @return The app ID specified in appengine-web.xml, e.g. ""teammatesv4""
     */
    public static String getAppId() {
        return SystemProperty.applicationId.get();
    }

    /**
     * Returns The app version specifed in appengine-web.xml but with '.' instead of '-' e.g., ""4.53"".
     */
    public static String getAppVersion() {
        String appVersion = SystemProperty.applicationVersion.get();
        return appVersion == null ? null : appVersion.split(""\\."")[0].replace(""-"", ""."");
    }

    /**
     * This method is not to be used by classes not compiled by GAE (e.g non-production codes).
     * @return true if the system is running at development environment
     */
    public static boolean isDevServer() {
        return SystemProperty.environment.value() == SystemProperty.Environment.Value.Development;
    }

    /**
     * Creates an {@link AppUrl} for the supplied {@code relativeUrl} parameter.
     * The base URL will be the value of app.url in build.properties.
     * {@code relativeUrl} must start with a ""/"".
     */
    public static AppUrl getAppUrl(String relativeUrl) {
        return new AppUrl(APP_URL + relativeUrl);
    }

    public static boolean isUsingSendgrid() {
        return ""sendgrid"".equalsIgnoreCase(EMAIL_SERVICE) && SENDGRID_APIKEY != null && !SENDGRID_APIKEY.isEmpty();
    }

    public static boolean isUsingMailgun() {
        return ""mailgun"".equalsIgnoreCase(EMAIL_SERVICE) && MAILGUN_APIKEY != null && !MAILGUN_APIKEY.isEmpty()
                && MAILGUN_DOMAINNAME != null && !MAILGUN_DOMAINNAME.isEmpty();
    }

    public static boolean isUsingMailjet() {
        return ""mailjet"".equalsIgnoreCase(EMAIL_SERVICE) && MAILJET_APIKEY != null && !MAILJET_APIKEY.isEmpty()
                && MAILJET_SECRETKEY != null && !MAILJET_SECRETKEY.isEmpty();
    }

}
"
Const.java,util,"package teammates.common.util;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Date;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.TimeZone;

import org.joda.time.DateTimeZone;

import teammates.common.datatransfer.FeedbackParticipantType;

/**
 * Stores constants that are widely used across classes.
 * this class contains several nested classes, each containing a specific
 * category of constants.
 */
public final class Const {

    /*
     * This section holds constants that are defined as constants primarily
     * because they are repeated in many places.
     */
    public static final String EOL = System.getProperty(""line.separator"");
    public static final String HTML_BR_TAG = ""<br>"";

    public static final String USER_NOBODY_TEXT = ""-"";
    public static final String USER_UNKNOWN_TEXT = ""Unknown user"";
    public static final String TEAM_OF_EMAIL_OWNER = ""'s Team"";

    public static final String NONE_OF_THE_ABOVE = ""None of the above"";

    public static final String INSTRUCTOR_FEEDBACK_SESSION_VISIBLE_TIME_CUSTOM = ""custom"";
    public static final String INSTRUCTOR_FEEDBACK_SESSION_VISIBLE_TIME_ATOPEN = ""atopen"";
    public static final String INSTRUCTOR_FEEDBACK_SESSION_VISIBLE_TIME_NEVER = ""never"";

    public static final String INSTRUCTOR_FEEDBACK_RESULTS_VISIBLE_TIME_CUSTOM = ""custom"";
    public static final String INSTRUCTOR_FEEDBACK_RESULTS_VISIBLE_TIME_ATVISIBLE = ""atvisible"";
    public static final String INSTRUCTOR_FEEDBACK_RESULTS_VISIBLE_TIME_LATER = ""later"";
    public static final String INSTRUCTOR_FEEDBACK_RESULTS_VISIBLE_TIME_NEVER = ""never"";
    public static final String INSTRUCTOR_FEEDBACK_RESULTS_MISSING_RESPONSE = ""No Response"";

    public static final String STUDENT_COURSE_STATUS_YET_TO_JOIN = ""Yet to join"";
    public static final String STUDENT_COURSE_STATUS_JOINED = ""Joined"";
    public static final String STUDENT_PROFILE_FIELD_NOT_FILLED = ""Not Specified"";

    public static final String USER_NAME_FOR_SELF = ""Myself"";
    public static final String USER_TEAM_FOR_INSTRUCTOR = ""Instructors"";
    public static final String NO_SPECIFIC_RECIPIENT = ""No specific recipient"";

    public static final String DISPLAYED_NAME_FOR_SELF_IN_COMMENTS = ""You"";
    public static final String DISPLAYED_NAME_FOR_ANONYMOUS_COMMENT_PARTICIPANT = ""Anonymous"";

    public static final String ACTION_RESULT_FAILURE = ""Servlet Action Failure"";
    public static final String ACTION_RESULT_SYSTEM_ERROR_REPORT = ""System Error Report"";

    public static final int SIZE_LIMIT_PER_ENROLLMENT = 150;
    public static final int INSTRUCTOR_VIEW_RESPONSE_LIMIT = 8000;

    // for course sorting in instructorHomePage
    public static final String SORT_BY_COURSE_ID = ""id"";
    public static final String SORT_BY_COURSE_NAME = ""name"";
    public static final String SORT_BY_COURSE_CREATION_DATE = ""createdAt"";
    public static final String DEFAULT_SORT_CRITERIA = SORT_BY_COURSE_CREATION_DATE;

    public static final String DEFAULT_SECTION = ""None"";

    public static final String DEFAULT_TIMEZONE = DateTimeZone.UTC.getID();

    /*
     * These constants are used as variable values to mean that the variable
     * is in a 'special' state.
     */
    public static final int INT_UNINITIALIZED = -9999;
    public static final double DOUBLE_UNINITIALIZED = -9999.0;

    public static final int MAX_POSSIBLE_RECIPIENTS = -100;

    public static final int POINTS_EQUAL_SHARE = 100;
    public static final int POINTS_NOT_SURE = -101;
    public static final int POINTS_NOT_SUBMITTED = -999;

    public static final int VISIBILITY_TABLE_GIVER = 0;
    public static final int VISIBILITY_TABLE_RECIPIENT = 1;

    public static final String GENERAL_QUESTION = ""%GENERAL%"";
    public static final String USER_IS_TEAM = ""%TEAM%"";
    public static final String USER_IS_NOBODY = ""%NOBODY%"";
    public static final String USER_IS_MISSING = ""%MISSING%"";

    public static final Date TIME_REPRESENTS_FOLLOW_OPENING;
    public static final Date TIME_REPRESENTS_FOLLOW_VISIBLE;
    public static final Date TIME_REPRESENTS_NEVER;
    public static final Date TIME_REPRESENTS_LATER;
    public static final Date TIME_REPRESENTS_NOW;
    public static final Date TIME_REPRESENTS_DEFAULT_TIMESTAMP;

    static {
        TIME_REPRESENTS_FOLLOW_OPENING = TimeHelper.convertToDate(""1970-12-31 00:00 AM UTC"");
        TIME_REPRESENTS_FOLLOW_VISIBLE = TimeHelper.convertToDate(""1970-06-22 00:00 AM UTC"");
        TIME_REPRESENTS_NEVER = TimeHelper.convertToDate(""1970-11-27 00:00 AM UTC"");
        TIME_REPRESENTS_LATER = TimeHelper.convertToDate(""1970-01-01 00:00 AM UTC"");
        TIME_REPRESENTS_NOW = TimeHelper.convertToDate(""1970-02-14 00:00 AM UTC"");
        TIME_REPRESENTS_DEFAULT_TIMESTAMP = TimeHelper.convertToDate(""2011-01-01 00:00 AM UTC"");
    }

    public static final String TIME_FORMAT_ISO_8601_UTC = ""yyyy-MM-dd'T'HH:mm:ss'Z'"";

    /*
     * Other Constants
     */

    private Const() {
        // Utility class containing constants
    }

    public static class SystemParams {

        public static final String ENCODING = ""UTF8"";
        public static final int NUMBER_OF_HOURS_BEFORE_CLOSING_ALERT = 24;

        /** This is the limit after which TEAMMATES will send error message.
         * Must be within the range of int */
        public static final int MAX_PROFILE_PIC_SIZE = 5000000;

        /** This is the limit given to Blobstore API, beyond which an ugly error page is shown. */
        public static final long MAX_FILE_LIMIT_FOR_BLOBSTOREAPI = 11000000;

        /** e.g. ""2014-04-01 11:59 PM UTC"" */
        public static final String DEFAULT_DATE_TIME_FORMAT = ""yyyy-MM-dd h:mm a Z"";

        /** Number to trim the Google ID when displaying to the user. */
        public static final int USER_ID_MAX_DISPLAY_LENGTH = 23;

        /* Field sizes and error messages for invalid fields can be found
         * in the FieldValidator class.
         */
        public static final String ADMIN_TIME_ZONE = ""Asia/Singapore"";
        public static final double ADMIN_TIME_ZONE_DOUBLE = 8.0;

        public static final TimeZone TIME_ZONE = TimeZone.getTimeZone(""UTC"");

        public static final String DEFAULT_PROFILE_PICTURE_PATH = ""/images/profile_picture_default.png"";

        public static final List<String> PAGES_REQUIRING_ORIGIN_VALIDATION = Collections.unmodifiableList(
                Arrays.asList(
                        ActionURIs.ADMIN_ACCOUNT_DELETE,
                        ActionURIs.ADMIN_EMAIL_COMPOSE_SAVE,
                        ActionURIs.ADMIN_EMAIL_COMPOSE_SEND,
                        ActionURIs.ADMIN_EMAIL_CREATE_GROUP_RECEIVER_LIST_UPLOAD_URL,
                        ActionURIs.ADMIN_EMAIL_CREATE_IMAGE_UPLOAD_URL,
                        ActionURIs.ADMIN_EMAIL_GROUP_RECEIVER_LIST_UPLOAD,
                        ActionURIs.ADMIN_EMAIL_IMAGE_UPLOAD,
                        ActionURIs.ADMIN_EMAIL_MOVE_OUT_TRASH,
                        ActionURIs.ADMIN_EMAIL_MOVE_TO_TRASH,
                        ActionURIs.ADMIN_EMAIL_TRASH_DELETE,
                        ActionURIs.ADMIN_INSTRUCTORACCOUNT_ADD,
                        ActionURIs.ADMIN_STUDENT_GOOGLE_ID_RESET,
                        ActionURIs.CREATE_IMAGE_UPLOAD_URL,
                        ActionURIs.IMAGE_UPLOAD,
                        ActionURIs.INSTRUCTOR_COURSE_ADD,
                        ActionURIs.INSTRUCTOR_COURSE_ARCHIVE,
                        ActionURIs.INSTRUCTOR_COURSE_DELETE,
                        ActionURIs.INSTRUCTOR_COURSE_EDIT_SAVE,
                        ActionURIs.INSTRUCTOR_COURSE_ENROLL_SAVE,
                        ActionURIs.INSTRUCTOR_COURSE_INSTRUCTOR_ADD,
                        ActionURIs.INSTRUCTOR_COURSE_INSTRUCTOR_DELETE,
                        ActionURIs.INSTRUCTOR_COURSE_INSTRUCTOR_EDIT_SAVE,
                        ActionURIs.INSTRUCTOR_COURSE_REMIND,
                        ActionURIs.INSTRUCTOR_COURSE_STUDENT_DELETE,
                        ActionURIs.INSTRUCTOR_COURSE_STUDENT_DELETE_ALL,
                        ActionURIs.INSTRUCTOR_COURSE_STUDENT_DETAILS_EDIT_SAVE,
                        ActionURIs.INSTRUCTOR_EDIT_INSTRUCTOR_FEEDBACK_SAVE,
                        ActionURIs.INSTRUCTOR_EDIT_STUDENT_FEEDBACK_SAVE,
                        ActionURIs.INSTRUCTOR_FEEDBACK_ADD,
                        ActionURIs.INSTRUCTOR_FEEDBACK_COPY,
                        ActionURIs.INSTRUCTOR_FEEDBACK_DELETE,
                        ActionURIs.INSTRUCTOR_FEEDBACK_EDIT_COPY,
                        ActionURIs.INSTRUCTOR_FEEDBACK_EDIT_SAVE,
                        ActionURIs.INSTRUCTOR_FEEDBACK_PUBLISH,
                        ActionURIs.INSTRUCTOR_FEEDBACK_QUESTION_ADD,
                        ActionURIs.INSTRUCTOR_FEEDBACK_QUESTION_COPY,
                        ActionURIs.INSTRUCTOR_FEEDBACK_QUESTION_EDIT,
                        ActionURIs.INSTRUCTOR_FEEDBACK_REMIND,
                        ActionURIs.INSTRUCTOR_FEEDBACK_REMIND_PARTICULAR_STUDENTS,
                        ActionURIs.INSTRUCTOR_FEEDBACK_RESPONSE_COMMENT_ADD,
                        ActionURIs.INSTRUCTOR_FEEDBACK_RESPONSE_COMMENT_DELETE,
                        ActionURIs.INSTRUCTOR_FEEDBACK_RESPONSE_COMMENT_EDIT,
                        ActionURIs.INSTRUCTOR_FEEDBACK_SUBMISSION_EDIT_SAVE,
                        ActionURIs.INSTRUCTOR_FEEDBACK_UNPUBLISH,
                        ActionURIs.STUDENT_FEEDBACK_SUBMISSION_EDIT_SAVE,
                        ActionURIs.STUDENT_PROFILE_CREATEUPLOADFORMURL,
                        ActionURIs.STUDENT_PROFILE_EDIT_SAVE,
                        ActionURIs.STUDENT_PROFILE_PICTURE_EDIT,
                        ActionURIs.STUDENT_PROFILE_PICTURE_UPLOAD));

        public static final List<String> PAGES_ACCESSIBLE_WITHOUT_GOOGLE_LOGIN = Collections.unmodifiableList(
                Arrays.asList(
                        ActionURIs.STUDENT_COURSE_JOIN,
                        ActionURIs.STUDENT_COURSE_JOIN_NEW,
                        ActionURIs.STUDENT_FEEDBACK_RESULTS_PAGE,
                        ActionURIs.STUDENT_FEEDBACK_SUBMISSION_EDIT_PAGE,
                        ActionURIs.STUDENT_FEEDBACK_SUBMISSION_EDIT_SAVE));

        public static final List<String> PAGES_ACCESSIBLE_WITHOUT_REGISTRATION = Collections.unmodifiableList(
                Arrays.asList(
                        ActionURIs.STUDENT_COURSE_JOIN_AUTHENTICATED,
                        ActionURIs.STUDENT_HOME_PAGE,
                        ActionURIs.INSTRUCTOR_COURSE_JOIN,
                        ActionURIs.INSTRUCTOR_COURSE_JOIN_AUTHENTICATED));

        public static final List<String> LEGACY_PAGES_WITH_REDUCED_SECURITY = Collections.unmodifiableList(
                Arrays.asList(ActionURIs.STUDENT_COURSE_JOIN));

        public static final String COURSE_BACKUP_LOG_MSG = ""Recently modified course::"";

    }

    /* Text displayed to the user when the mouse hover over certain elements in
     * the UI.
     */
    public static class Tooltips {

        public static final String COURSE_ENROLL = ""Enroll student into the course"";
        public static final String COURSE_DETAILS = ""View, edit and send invitation emails to the students in the course"";
        public static final String COURSE_EDIT = ""Edit Course information and instructor list"";
        public static final String COURSE_DELETE = ""Delete the course and its corresponding students and sessions"";
        public static final String COURSE_ARCHIVE =
                ""Archive the course so that it will not be shown in the home page any more ""
                + ""(you can still access it from the 'Courses' tab)"";
        public static final String COURSE_ADD_FEEDBACKSESSION = ""Add a feedback session for the course"";
        public static final String CLAIMED = ""This is the student's own estimation of his/her contributions"";
        public static final String PERCEIVED =
                ""This is the average of what other team members think this student contributed"";

        public static final String COURSE_INFO_EDIT = ""Edit course name"";
        public static final String COURSE_INSTRUCTOR_EDIT = ""Edit instructor details"";
        public static final String COURSE_INSTRUCTOR_CANCEL_EDIT = ""Cancel editing instructor details"";
        public static final String COURSE_INSTRUCTOR_DELETE = ""Delete the instructor from the course"";
        public static final String COURSE_INSTRUCTOR_REMIND = ""Send invitation email to the instructor"";

        public static final String COURSE_STUDENT_DETAILS = ""View the details of the student"";
        public static final String COURSE_STUDENT_EDIT =
                ""Use this to edit the details of this student. <br>To edit multiple students""
                + "" in one go, you can use the enroll page: <br>""
                + ""Simply enroll students using the updated data and existing data will be updated accordingly"";
        public static final String COURSE_STUDENT_REMIND =
                ""Email an invitation to the student requesting him/her to join the course using his/her ""
                + ""Google Account. Note: Students can use TEAMMATES without joining, ""
                + ""but a joined student can access extra features e.g. set up a user profile"";
        public static final String COURSE_STUDENT_DELETE =
                ""Delete the student and the corresponding submissions from the course"";
        public static final String COURSE_STUDENT_RECORDS = ""View all data about this student"";

        public static final String COURSE_REMIND =
                ""Email an invitation to all students yet to join requesting them to join the course ""
                + ""using their Google Accounts. Note: Students can use TEAMMATES without joining, ""
                + ""but a joined student can access extra features e.g. set up a user profile"";

        public static final String INSTRUCTOR_DISPLAYED_TO_STUDENT =
                ""If this is unselected, the instructor will be completely invisible to students.""
                + "" E.g. to give access to a colleague for auditing your course"";

        public static final String INSTRUCTOR_DISPLAYED_AS =
                ""Specify the role of this instructor in this course as shown to the students"";

        public static final String STUDENT_COURSE_DETAILS = ""View and edit information regarding your team"";

        public static final String STUDENT_FEEDBACK_SESSION_STATUS_AWAITING =
                ""The session is not open for submission at this time. It is expected to open later."";
        public static final String STUDENT_FEEDBACK_SESSION_STATUS_PENDING =
                ""The feedback session is yet to be completed by you."";
        public static final String STUDENT_FEEDBACK_SESSION_STATUS_SUBMITTED =
                ""You have submitted your feedback for this session."";
        public static final String STUDENT_FEEDBACK_SESSION_STATUS_CLOSED =
                ""<br>The session is now closed for submissions."";
        public static final String STUDENT_FEEDBACK_SESSION_STATUS_PUBLISHED =
                ""<br>The responses for the session can now be viewed."";

        public static final String FEEDBACK_CONTRIBUTION_DIFF = ""Perceived Contribution - Claimed Contribution"";
        public static final String FEEDBACK_CONTRIBUTION_POINTS_RECEIVED =
                ""The list of points that this student received from others"";

        public static final String FEEDBACK_CONTRIBUTION_NOT_AVAILABLE =
                ""Not Available: There is no data for this or the data is not enough"";
        public static final String FEEDBACK_CONTRIBUTION_NOT_SURE = ""Not sure about the contribution"";

        public static final String FEEDBACK_SESSION_COURSE =
                ""Please select the course for which the feedback session is to be created."";
        public static final String FEEDBACK_SESSION_INPUT_NAME =
                ""Enter the name of the feedback session e.g. Feedback Session 1."";
        public static final String FEEDBACK_SESSION_STARTDATE =
                ""Please select the date and time for which users can start submitting responses for the feedback session."";
        public static final String FEEDBACK_SESSION_ENDDATE =
                ""Please select the date and time after which the feedback session ""
                + ""will no longer accept submissions from users."";
        public static final String FEEDBACK_SESSION_VISIBLEDATE =
                ""Select this option to enter in a custom date and time for which ""
                + ""the feedback session will become visible.<br>""
                + ""Note that you can make a session visible before it is open for submissions ""
                + ""so that users can preview the questions."";
        public static final String FEEDBACK_SESSION_PUBLISHDATE =
                ""Select this option to enter in a custom date and time for which</br>""
                + ""the responses for this feedback session will become visible."";
        public static final String FEEDBACK_SESSION_SESSIONVISIBLELABEL =
                ""Please select when you want the questions for the feedback session to be visible to ""
                + ""users who need to participate. ""
                + ""Note that users cannot submit their responses until the submissions opening time set below."";
        public static final String FEEDBACK_SESSION_SESSIONVISIBLEATOPEN =
                ""Select this option to have the feedback session become visible ""
                + ""when it is open for submissions (as selected above)."";
        public static final String FEEDBACK_SESSION_SESSIONVISIBLENEVER =
                ""Select this option if you want the feedback session to be private. ""
                + ""A private session is never visible to anyone. ""
                + ""Private sessions can be used to record your own comments about others, for your own reference."";
        public static final String FEEDBACK_SESSION_RESULTSVISIBLELABEL =
                ""Please select when the responses for the feedback session will be visible to the designated recipients.""
                + ""<br>You can select the response visibility for each type of user and question later."";
        public static final String FEEDBACK_SESSION_RESULTSVISIBLECUSTOM =
                ""Select this option to use a custom time for when the responses of the feedback session<br>""
                + ""will be visible to the designated recipients."";
        public static final String FEEDBACK_SESSION_RESULTSVISIBLEATVISIBLE =
                ""Select this option to have the feedback responses be immediately visible<br>""
                + ""when the session becomes visible to users."";
        public static final String FEEDBACK_SESSION_RESULTSVISIBLELATER =
                ""Select this option if you intend to manually publish the responses for this session later on."";
        public static final String FEEDBACK_SESSION_RESULTSVISIBLENEVER =
                ""Select this option if you intend never to publish the responses."";
        public static final String FEEDBACK_SESSION_SENDOPENEMAIL =
                ""Select this option to automatically send an email to students to notify them ""
                + ""when the session is open for submission."";
        public static final String FEEDBACK_SESSION_SENDCLOSINGEMAIL =
                ""Select this option to automatically send an email to students to remind them to submit ""
                + ""24 hours before the end of the session."";
        public static final String FEEDBACK_SESSION_SENDPUBLISHEDEMAIL =
                ""Select this option to automatically send an email to students to notify them ""
                + ""when the session results is published."";
        public static final String FEEDBACK_SESSION_INSTRUCTIONS =
                ""Enter instructions for this feedback session. e.g. Avoid comments which are too critical.<br> ""
                + ""It will be displayed at the top of the page when users respond to the session."";
        public static final String FEEDBACK_SESSION_STATUS_PRIVATE = ""This is a private session. Nobody can see it but you."";
        public static final String FEEDBACK_SESSION_STATUS_VISIBLE = "", is visible"";
        public static final String FEEDBACK_SESSION_STATUS_AWAITING = "", and is waiting to open"";
        public static final String FEEDBACK_SESSION_STATUS_OPEN = "", and is open for submissions"";
        public static final String FEEDBACK_SESSION_STATUS_CLOSED = "", and has ended"";
        public static final String FEEDBACK_SESSION_STATUS_PUBLISHED = "".<br>The responses for this session are visible"";

        public static final String FEEDBACK_SESSION_INPUT_TIMEZONE =
                ""You should not need to change this as your timezone is auto-detected. <br><br>""
                + ""However, note that daylight saving is not taken into account i.e. if you are in UTC -8:00 and there is ""
                + ""daylight saving, you should choose UTC -7:00 and its corresponding timings."";

        public static final String FEEDBACK_SESSION_INPUT_GRACEPERIOD =
                ""Please select the amount of time that the system will continue accepting <br>""
                + ""submissions after the specified deadline."";

        public static final String FEEDBACK_SESSION_RESPONSE_RATE = ""Number of students submitted / Class size"";
        public static final String FEEDBACK_SESSION_RESULTS = ""View the submitted responses for this feedback session"";
        public static final String FEEDBACK_SESSION_EDIT = ""Edit feedback session details"";
        public static final String FEEDBACK_SESSION_COPY = ""Copy feedback session details"";
        public static final String FEEDBACK_SESSION_REMIND =
                ""Send e-mails to remind students and instructors who have not submitted their feedbacks to do so"";
        public static final String FEEDBACK_SESSION_DELETE = ""Delete the feedback session"";
        public static final String FEEDBACK_SESSION_SUBMIT = ""Start submitting feedback"";
        public static final String FEEDBACK_SESSION_PUBLISH = ""Make session responses available for viewing"";
        public static final String FEEDBACK_SESSION_UNPUBLISH = ""Make responses no longer visible"";
        public static final String FEEDBACK_SESSION_AWAITING = ""This session is not yet opened"";
        public static final String FEEDBACK_SESSION_EDIT_SUBMITTED_RESPONSE = ""Edit submitted feedback"";
        public static final String FEEDBACK_SESSION_VIEW_SUBMITTED_RESPONSE = ""View submitted feedback"";
        public static final String FEEDBACK_SESSION_RECIPIENT = ""Who the feedback is about"";
        public static final String FEEDBACK_SESSION_GIVER = ""Who will give feedback"";

        public static final String FEEDBACK_SESSION_EDIT_SAVE =
                ""You can save your responses at any time and come back later to continue."";

        public static final String FEEDBACK_SESSION_MODERATE_FEEDBACK = ""Edit the responses given by this student"";

        public static final String FEEDBACK_PREVIEW_ASSTUDENT =
                ""View how this session would look like to a student who is submitting feedback.<br>""
                + ""Preview is unavailable if the course has yet to have any student enrolled."";
        public static final String FEEDBACK_PREVIEW_ASINSTRUCTOR =
                ""View how this session would look like to an instructor who is submitting feedback.<br>""
                + ""Only instructors with submit privileges are included in the list."";

        public static final String FEEDBACK_QUESTION_INPUT_INSTRUCTIONS =
                ""Please enter the question for users to give feedback about. ""
                + ""e.g. What is the biggest weakness of the presented product?"";
        public static final String FEEDBACK_QUESTION_EDIT =
                ""Edit the existing question. Do remember to save the changes before moving on to editing another question."";
        public static final String FEEDBACK_QUESTION_DISCARDCHANGES =
                ""Discard any unsaved edits and revert back to original question."";
        public static final String FEEDBACK_QUESTION_CANCEL_NEW =
                ""Cancel adding new question. No new question will be added to the feedback session."";
        public static final String FEEDBACK_QUESTION_INPUT_DESCRIPTION =
                ""Please enter the description of the question."";
        public static final String FEEDBACK_QUESTION_CONSTSUMPOINTS_OPTION =
                ""Respondents will have to distribute the total points specified here among the options, ""
                + ""e.g. if you specify 100 points here and there are 3 options, ""
                + ""respondents will have to distribute 100 points among 3 options."";
        public static final String FEEDBACK_QUESTION_CONSTSUMPOINTS_RECIPIENT =
                ""Respondents will have to distribute the total points specified here among the recipients, ""
                + ""e.g. if you specify 100 points here and there are 3 recipients, ""
                + ""respondents will have to distribute 100 points among 3 recipients."";
        public static final String FEEDBACK_QUESTION_CONSTSUMPOINTSFOREACHOPTION =
                ""The number of points to distribute will vary based on the number of options, ""
                + ""e.g. if you specify 100 points here and there are 3 options, ""
                + ""the total number of points to distribute among 3 options will be 300 (i.e. 100 x 3)."";
        public static final String FEEDBACK_QUESTION_CONSTSUMPOINTSFOREACHRECIPIENT =
                ""The number of points to distribute will vary based on the number of recipients, ""
                + ""e.g. if you specify 100 points here and there are 3 recipients, ""
                + ""the total number of points to distribute among 3 recipients will be 300 (i.e. 100 x 3)."";
        public static final String FEEDBACK_QUESTION_NUMSCALE_MAX = ""Maximum acceptable response value"";
        public static final String FEEDBACK_QUESTION_NUMSCALE_STEP = ""Value to be increased/decreased each step"";
        public static final String FEEDBACK_QUESTION_NUMSCALE_MIN = ""Minimum acceptable response value"";
        public static final String FEEDBACK_QUESTION_RUBRIC_ASSIGN_WEIGHTS =
                ""Assign weights to the columns for calculating statistics."";

        public static final String STUDENT_PROFILE_PICTURE = ""Upload a profile picture"";
        public static final String STUDENT_PROFILE_SHORTNAME = ""This is the name you prefer to be called by"";
        public static final String STUDENT_PROFILE_EMAIL = ""This is a long term contact email"";
        public static final String STUDENT_PROFILE_INSTITUTION = ""This is the institution that you represent"";
        public static final String STUDENT_PROFILE_NATIONALITY = ""This is your nationality"";
        public static final String STUDENT_PROFILE_MOREINFO = ""You may specify miscellaneous info about yourself ""
                + ""e.g. links to home page, online CV, portfolio etc."";

        public static final String VISIBILITY_OPTIONS_RECIPIENT = ""Control what feedback recipient(s) can view"";
        public static final String VISIBILITY_OPTIONS_GIVER_TEAM_MEMBERS =
                ""Control what team members of feedback giver can view"";
        public static final String VISIBILITY_OPTIONS_RECIPIENT_TEAM_MEMBERS =
                ""Control what team members of feedback recipients can view"";
        public static final String VISIBILITY_OPTIONS_OTHER_STUDENTS = ""Control what other students can view"";
        public static final String VISIBILITY_OPTIONS_INSTRUCTORS = ""Control what instructors can view"";

        public static final String COMMENT_ADD = ""Add comment"";
        public static final String COMMENT_EDIT = ""Edit this comment"";
        public static final String COMMENT_DELETE = ""Delete this comment"";

        public static final String SEARCH_STUDENT = ""Search for student's information, e.g. name, email"";

        public static final String ACTION_NOT_ALLOWED = ""You do not have the permissions to access this feature"";
    }

    public static class FeedbackQuestion {

        public static final Map<String, String> COMMON_VISIBILITY_OPTIONS;

        static {
            Map<String, String> visibilityOptionInit = new LinkedHashMap<>();

            visibilityOptionInit.put(""ANONYMOUS_TO_RECIPIENT_AND_INSTRUCTORS"",
                                     ""Shown anonymously to recipient and instructors"");
            visibilityOptionInit.put(""ANONYMOUS_TO_RECIPIENT_VISIBLE_TO_INSTRUCTORS"",
                                     ""Shown anonymously to recipient, visible to instructors"");
            visibilityOptionInit.put(""ANONYMOUS_TO_RECIPIENT_AND_TEAM_VISIBLE_TO_INSTRUCTORS"",
                                     ""Shown anonymously to recipient and team members, visible to instructors"");
            visibilityOptionInit.put(""VISIBLE_TO_INSTRUCTORS_ONLY"", ""Visible to instructors only"");
            visibilityOptionInit.put(""VISIBLE_TO_RECIPIENT_AND_INSTRUCTORS"", ""Visible to recipient and instructors"");

            COMMON_VISIBILITY_OPTIONS = Collections.unmodifiableMap(visibilityOptionInit);
        }

        public static final Map<FeedbackParticipantType, List<FeedbackParticipantType>>
                COMMON_FEEDBACK_PATHS;

        static {
            Map<FeedbackParticipantType, List<FeedbackParticipantType>> initializer = new LinkedHashMap<>();

            initializer.put(FeedbackParticipantType.SELF,
                    new ArrayList<>(
                            Arrays.asList(FeedbackParticipantType.NONE,
                                    FeedbackParticipantType.SELF,
                                    FeedbackParticipantType.INSTRUCTORS)));

            initializer.put(FeedbackParticipantType.STUDENTS,
                    new ArrayList<>(
                            Arrays.asList(FeedbackParticipantType.NONE,
                                    FeedbackParticipantType.SELF,
                                    FeedbackParticipantType.INSTRUCTORS,
                                    FeedbackParticipantType.OWN_TEAM_MEMBERS,
                                    FeedbackParticipantType.OWN_TEAM_MEMBERS_INCLUDING_SELF)));

            initializer.put(FeedbackParticipantType.INSTRUCTORS,
                    new ArrayList<>(
                            Arrays.asList(FeedbackParticipantType.NONE,
                                    FeedbackParticipantType.SELF,
                                    FeedbackParticipantType.INSTRUCTORS)));

            COMMON_FEEDBACK_PATHS = Collections.unmodifiableMap(initializer);
        }

        // Mcq
        public static final int MCQ_MIN_NUM_OF_CHOICES = 2;
        public static final String MCQ_ERROR_NOT_ENOUGH_CHOICES =
                ""Too little choices for "" + Const.FeedbackQuestionTypeNames.MCQ + "". Minimum number of options is: "";
        public static final String MCQ_ERROR_INVALID_OPTION =
                "" is not a valid option for the "" + Const.FeedbackQuestionTypeNames.MCQ + ""."";

        // Msq
        public static final int MSQ_MIN_NUM_OF_CHOICES = 2;
        public static final String MSQ_ERROR_NOT_ENOUGH_CHOICES =
                ""Too little choices for "" + Const.FeedbackQuestionTypeNames.MSQ + "". Minimum number of options is: "";
        public static final String MSQ_ERROR_INVALID_OPTION =
                "" is not a valid option for the "" + Const.FeedbackQuestionTypeNames.MSQ + ""."";

        // Numscale
        public static final String NUMSCALE_ERROR_MIN_MAX =
                ""Minimum value must be < maximum value for "" + Const.FeedbackQuestionTypeNames.NUMSCALE + ""."";
        public static final String NUMSCALE_ERROR_STEP =
                ""Step value must be > 0 for "" + Const.FeedbackQuestionTypeNames.NUMSCALE + ""."";
        public static final String NUMSCALE_ERROR_OUT_OF_RANGE =
                "" is out of the range for "" + Const.FeedbackQuestionTypeNames.NUMSCALE + ""."";

        // Contribution
        public static final String CONTRIB_ERROR_INVALID_OPTION =
                ""Invalid option for the "" + Const.FeedbackQuestionTypeNames.CONTRIB + ""."";
        public static final String CONTRIB_ERROR_INVALID_FEEDBACK_PATH =
                Const.FeedbackQuestionTypeNames.CONTRIB + "" must have ""
                + FeedbackParticipantType.STUDENTS.toDisplayGiverName()
                + "" and "" + FeedbackParticipantType.OWN_TEAM_MEMBERS_INCLUDING_SELF.toDisplayRecipientName()
                + "" as the feedback giver and recipient respectively.""
                + "" These values will be used instead."";
        public static final String CONTRIB_ERROR_INVALID_VISIBILITY_OPTIONS =
                Const.FeedbackQuestionTypeNames.CONTRIB + "" must use one of the common visibility options. The \""""
                + Const.FeedbackQuestion.COMMON_VISIBILITY_OPTIONS
                                        .get(""ANONYMOUS_TO_RECIPIENT_AND_TEAM_VISIBLE_TO_INSTRUCTORS"")
                + ""\"" option will be used instead."";

        // Constant sum
        public static final int CONST_SUM_MIN_NUM_OF_OPTIONS = 2;
        public static final int CONST_SUM_MIN_NUM_OF_POINTS = 1;
        public static final String CONST_SUM_ERROR_NOT_ENOUGH_OPTIONS =
                ""Too little options for "" + Const.FeedbackQuestionTypeNames.CONSTSUM_OPTION
                + "". Minimum number of options is: "";
        public static final String CONST_SUM_ERROR_DUPLICATE_OPTIONS = ""Duplicate options are not allowed."";
        public static final String CONST_SUM_ERROR_NOT_ENOUGH_POINTS =
                ""Too little points for "" + Const.FeedbackQuestionTypeNames.CONSTSUM_RECIPIENT
                + "". Minimum number of points is: "";
        public static final String CONST_SUM_ERROR_MISMATCH =
                ""Please distribute all the points for distribution questions. ""
                + ""To skip a distribution question, leave the boxes blank."";
        public static final String CONST_SUM_ERROR_NEGATIVE = ""Points given must be 0 or more."";
        public static final String CONST_SUM_ERROR_UNIQUE = ""Every option must be given a different number of points."";

        // Rubric
        public static final int RUBRIC_MIN_NUM_OF_CHOICES = 2;
        public static final String RUBRIC_ERROR_NOT_ENOUGH_CHOICES =
                ""Too little choices for "" + Const.FeedbackQuestionTypeNames.RUBRIC + "". Minimum number of options is: "";
        public static final int RUBRIC_MIN_NUM_OF_SUB_QUESTIONS = 1;
        public static final String RUBRIC_ERROR_NOT_ENOUGH_SUB_QUESTIONS =
                ""Too little sub-questions for "" + Const.FeedbackQuestionTypeNames.RUBRIC + "". ""
                + ""Minimum number of sub-questions is: "";
        public static final String RUBRIC_ERROR_DESC_INVALID_SIZE =
                ""Invalid number of descriptions for "" + Const.FeedbackQuestionTypeNames.RUBRIC;
        public static final String RUBRIC_ERROR_EMPTY_SUB_QUESTION =
                ""Sub-questions for "" + Const.FeedbackQuestionTypeNames.RUBRIC + "" cannot be empty."";
        public static final String RUBRIC_ERROR_INVALID_WEIGHT =
                ""The weights for the choices of a ""
                + Const.FeedbackQuestionTypeNames.RUBRIC
                + "" must be valid numbers with precision up to 2 decimal places."";
    }

    public static class FeedbackQuestionTypeNames {
        public static final String TEXT = ""Essay question"";
        public static final String MCQ = ""Multiple-choice (single answer) question"";
        public static final String MSQ = ""Multiple-choice (multiple answers) question"";
        public static final String NUMSCALE = ""Numerical-scale question"";
        public static final String CONSTSUM_OPTION = ""Distribute points (among options) question"";
        public static final String CONSTSUM_RECIPIENT = ""Distribute points (among recipients) question"";
        public static final String RANK_OPTION = ""Rank (options) question"";
        public static final String RANK_RECIPIENT = ""Rank (recipients) question"";
        public static final String CONTRIB = ""Team contribution question"";
        public static final String RUBRIC = ""Rubric question"";
    }

    public static class FeedbackSessionResults {
        public static final String QUESTION_SORT_TYPE = ""question"";
        public static final String GRQ_SORT_TYPE = ""giver-recipient-question"";
        public static final String RGQ_SORT_TYPE = ""recipient-giver-question"";
        public static final String GQR_SORT_TYPE = ""giver-question-recipient"";
        public static final String RQG_SORT_TYPE = ""recipient-question-giver"";
    }

    public static class InstructorPermissionRoleNames {
        public static final String INSTRUCTOR_PERMISSION_ROLE_COOWNER = ""Co-owner"";
        public static final String INSTRUCTOR_PERMISSION_ROLE_MANAGER = ""Manager"";
        public static final String INSTRUCTOR_PERMISSION_ROLE_OBSERVER = ""Observer"";
        public static final String INSTRUCTOR_PERMISSION_ROLE_TUTOR = ""Tutor"";
        public static final String INSTRUCTOR_PERMISSION_ROLE_CUSTOM = ""Custom"";
    }

    public static class GenderTypes {
        public static final String MALE = ""male"";
        public static final String FEMALE = ""female"";
        public static final String OTHER = ""other"";
    }

    public static class ParamsNames {

        public static final String IS_USING_AJAX = ""isusingAjax"";
        public static final String IS_STUDENT_REJOINING = ""isstudentrejoining"";

        public static final String BLOB_KEY = ""blob-key"";
        public static final String SESSION_TOKEN = ""token"";

        public static final String COPIED_FEEDBACK_SESSION_NAME = ""copiedfsname"";
        public static final String COPIED_COURSE_ID = ""copiedcourseid"";
        public static final String COPIED_COURSES_ID = ""copiedcoursesid"";

        public static final String CSV_TO_HTML_TABLE_NEEDED = ""csvtohtmltable"";

        public static final String COURSE_ID = ""courseid"";
        public static final String COURSE_NAME = ""coursename"";
        public static final String COURSE_INDEX = ""courseidx"";
        public static final String COURSE_TIME_ZONE = ""coursetimezone"";
        public static final String COURSE_EDIT_MAIN_INDEX = ""courseeditmainindex"";
        public static final String INSTRUCTOR_SHORT_NAME = ""instructorshortname"";
        public static final String INSTRUCTOR_ID = ""instructorid"";
        public static final String INSTRUCTOR_EMAIL = ""instructoremail"";
        public static final String INSTRUCTOR_INSTITUTION = ""instructorinstitution"";
        public static final String INSTRUCTOR_NAME = ""instructorname"";
        public static final String STUDENTS_ENROLLMENT_INFO = ""enrollstudents"";

        public static final String INSTRUCTOR_IS_DISPLAYED_TO_STUDENT = ""instructorisdisplayed"";
        public static final String INSTRUCTOR_DISPLAY_NAME = ""instructordisplayname"";
        public static final String INSTRUCTOR_ROLE_NAME = ""instructorrole"";
        public static final String INSTRUCTOR_SECTION = ""section"";
        public static final String INSTRUCTOR_SECTION_GROUP = ""sectiongroup"";

        public static final String INSTRUCTOR_PERMISSION_MODIFY_COURSE = ""canmodifycourse"";
        public static final String INSTRUCTOR_PERMISSION_MODIFY_INSTRUCTOR = ""canmodifyinstructor"";
        public static final String INSTRUCTOR_PERMISSION_MODIFY_SESSION = ""canmodifysession"";
        public static final String INSTRUCTOR_PERMISSION_MODIFY_STUDENT = ""canmodifystudent"";

        public static final String INSTRUCTOR_PERMISSION_VIEW_STUDENT_IN_SECTIONS = ""canviewstudentinsection"";
        public static final String INSTRUCTOR_PERMISSION_VIEW_SESSION_IN_SECTIONS = ""canviewsessioninsection"";
        public static final String INSTRUCTOR_PERMISSION_SUBMIT_SESSION_IN_SECTIONS = ""cansubmitsessioninsection"";
        public static final String INSTRUCTOR_PERMISSION_MODIFY_SESSION_COMMENT_IN_SECTIONS =
                ""canmodifysessioncommentinsection"";

        public static final String COURSE_SORTING_CRITERIA = ""sortby"";
        public static final String COURSE_TO_LOAD = ""coursetoload"";

        public static final String COURSE_ARCHIVE_STATUS = ""archive"";

        public static final String IMAGE_TO_UPLOAD = ""imagetoupload"";

        public static final String ADMIN_SEARCH_KEY = ""searchkey"";
        public static final String ADMIN_SEARCH_BUTTON_HIT = ""searchbuttonhit"";

        public static final String ADMIN_EMAIL_CONTENT = ""emailcontent"";
        public static final String ADMIN_EMAIL_SUBJECT = ""emailsubject"";
        public static final String ADMIN_EMAIL_RECEIVER = ""emailreceiver"";
        public static final String ADMIN_EMAIL_ADDRESS_RECEIVERS = ""adminemailaddressreceivers"";
        public static final String ADMIN_EMAIL_GROUP_RECEIVER_LIST_FILE_KEY = ""adminemailgroupreceiverlistfilekey"";
        public static final String ADMIN_EMAIL_IMAGE_TO_UPLOAD = ""emailimagetoupload"";
        public static final String ADMIN_EMAIL_GROUP_RECEIVER_LIST_TO_UPLOAD = ""emailgroupreceiverlisttoupload"";

        public static final String ADMIN_EMAIL_ID = ""emailid"";
        public static final String ADMIN_EMAIL_EMPTY_TRASH_BIN = ""emptytrashbin"";
        public static final String ADMIN_EMAIL_TRASH_ACTION_REDIRECT = ""redirect"";

        public static final String ADMIN_GROUP_RECEIVER_EMAIL_LIST_INDEX = ""emaillistindex"";
        public static final String ADMIN_GROUP_RECEIVER_EMAIL_INDEX = ""emailindex"";

        public static final String FEEDBACK_SESSION_NAME = ""fsname"";
        public static final String FEEDBACK_SESSION_INDEX = ""fsindex"";
        public static final String FEEDBACK_SESSION_CREATOR = ""fscreator"";
        public static final String FEEDBACK_SESSION_STARTDATE = ""startdate"";
        public static final String FEEDBACK_SESSION_STARTTIME = ""starttime"";
        public static final String FEEDBACK_SESSION_STARTHOUR = ""starthour"";
        public static final String FEEDBACK_SESSION_STARTMINUTE = ""startminute"";
        public static final String FEEDBACK_SESSION_ENDDATE = ""enddate"";
        public static final String FEEDBACK_SESSION_ENDTIME = ""endtime"";
        public static final String FEEDBACK_SESSION_ENDHOUR = ""endhour"";
        public static final String FEEDBACK_SESSION_ENDMINUTE = ""endminute"";
        public static final String FEEDBACK_SESSION_VISIBLEDATE = ""visibledate"";
        public static final String FEEDBACK_SESSION_VISIBLETIME = ""visibletime"";
        public static final String FEEDBACK_SESSION_PUBLISHDATE = ""publishdate"";
        public static final String FEEDBACK_SESSION_PUBLISHTIME = ""publishtime"";
        public static final String FEEDBACK_SESSION_TIMEZONE = ""timezone"";
        public static final String FEEDBACK_SESSION_GRACEPERIOD = ""graceperiod"";
        public static final String FEEDBACK_SESSION_TYPE = ""fstype"";
        public static final String FEEDBACK_SESSION_SESSIONVISIBLEBUTTON = ""sessionVisibleFromButton"";
        public static final String FEEDBACK_SESSION_RESULTSVISIBLEBUTTON = ""resultsVisibleFromButton"";
        public static final String FEEDBACK_SESSION_SENDREMINDEREMAIL = ""sendreminderemail"";
        public static final String FEEDBACK_SESSION_INSTRUCTIONS = ""instructions"";
        public static final String FEEDBACK_SESSION_MODERATED_PERSON = ""moderatedperson"";
        public static final String FEEDBACK_SESSION_MODERATED_QUESTION_ID = ""moderatedquestionid"";
        public static final String FEEDBACK_SESSION_ENABLE_EDIT = ""editsessiondetails"";

        public static final String FEEDBACK_QUESTION_ID = ""questionid"";
        public static final String FEEDBACK_QUESTION_NUMBER = ""questionnum"";
        public static final String FEEDBACK_QUESTION_TEXT = ""questiontext"";
        public static final String FEEDBACK_QUESTION_TEXT_RECOMMENDEDLENGTH = ""recommendedlength"";
        public static final String FEEDBACK_QUESTION_DESCRIPTION = ""questiondescription"";
        public static final String FEEDBACK_QUESTION_TYPE = ""questiontype"";
        public static final String FEEDBACK_QUESTION_NUMBEROFCHOICECREATED = ""noofchoicecreated"";
        public static final String FEEDBACK_QUESTION_MCQCHOICE = ""mcqOption"";
        public static final String FEEDBACK_QUESTION_MCQOTHEROPTION = ""mcqOtherOption"";
        public static final String FEEDBACK_QUESTION_MCQOTHEROPTIONFLAG = ""mcqOtherOptionFlag"";
        public static final String FEEDBACK_QUESTION_MCQ_ISOTHEROPTIONANSWER = ""mcqIsOtherOptionAnswer"";
        public static final String FEEDBACK_QUESTION_MSQCHOICE = ""msqOption"";
        public static final String FEEDBACK_QUESTION_MSQOTHEROPTION = ""msqOtherOption"";
        public static final String FEEDBACK_QUESTION_MSQOTHEROPTIONFLAG = ""msqOtherOptionFlag"";
        public static final String FEEDBACK_QUESTION_MSQ_ISOTHEROPTIONANSWER = ""msqIsOtherOptionAnswer"";
        public static final String FEEDBACK_QUESTION_CONSTSUMOPTION = ""constSumOption"";
        public static final String FEEDBACK_QUESTION_CONSTSUMTORECIPIENTS = ""constSumToRecipients"";
        public static final String FEEDBACK_QUESTION_CONSTSUMNUMOPTION = ""constSumNumOption"";
        // TODO: rename FEEDBACK_QUESTION_CONSTSUMPOINTSPEROPTION to a more accurate name
        public static final String FEEDBACK_QUESTION_CONSTSUMPOINTSPEROPTION = ""constSumPointsPerOption"";
        public static final String FEEDBACK_QUESTION_CONSTSUMPOINTS = ""constSumPoints"";
        public static final String FEEDBACK_QUESTION_CONSTSUMPOINTSFOREACHOPTION = ""constSumPointsForEachOption"";
        public static final String FEEDBACK_QUESTION_CONSTSUMPOINTSFOREACHRECIPIENT = ""constSumPointsForEachRecipient"";
        public static final String FEEDBACK_QUESTION_CONSTSUMDISTRIBUTEUNEVENLY = ""constSumUnevenDistribution"";
        public static final String FEEDBACK_QUESTION_CONTRIBISNOTSUREALLOWED = ""isNotSureAllowedCheck"";
        public static final String FEEDBACK_QUESTION_GENERATEDOPTIONS = ""generatedOptions"";
        public static final String FEEDBACK_QUESTION_GIVERTYPE = ""givertype"";
        public static final String FEEDBACK_QUESTION_RECIPIENTTYPE = ""recipienttype"";
        public static final String FEEDBACK_QUESTION_NUMBEROFENTITIES = ""numofrecipients"";
        public static final String FEEDBACK_QUESTION_NUMBEROFENTITIESTYPE = ""numofrecipientstype"";
        public static final String FEEDBACK_QUESTION_EDITTEXT = ""questionedittext"";
        public static final String FEEDBACK_QUESTION_DISCARDCHANGES = ""questiondiscardchanges"";
        public static final String FEEDBACK_QUESTION_EDITTYPE = ""questionedittype"";
        public static final String FEEDBACK_QUESTION_SAVECHANGESTEXT = ""questionsavechangestext"";
        public static final String FEEDBACK_QUESTION_SHOWRESPONSESTO = ""showresponsesto"";
        public static final String FEEDBACK_QUESTION_SHOWGIVERTO = ""showgiverto"";
        public static final String FEEDBACK_QUESTION_SHOWRECIPIENTTO = ""showrecipientto"";
        public static final String FEEDBACK_QUESTION_RESPONSETOTAL = ""questionresponsetotal"";
        public static final String FEEDBACK_QUESTION_NUMSCALE_MIN = ""numscalemin"";
        public static final String FEEDBACK_QUESTION_NUMSCALE_MAX = ""numscalemax"";
        public static final String FEEDBACK_QUESTION_NUMSCALE_STEP = ""numscalestep"";
        public static final String FEEDBACK_QUESTION_RUBRIC_EDIT_TABLE = ""rubricEditTable"";
        public static final String FEEDBACK_QUESTION_RUBRIC_SUBQUESTION = ""rubricSubQn"";
        public static final String FEEDBACK_QUESTION_RUBRIC_CHOICE = ""rubricChoice"";
        public static final String FEEDBACK_QUESTION_RUBRIC_DESCRIPTION = ""rubricDesc"";
        public static final String FEEDBACK_QUESTION_RUBRIC_WEIGHTS_ASSIGNED = ""rubricAssignWeights"";
        public static final String FEEDBACK_QUESTION_RUBRIC_WEIGHT = ""rubricWeight"";
        public static final String FEEDBACK_QUESTION_RUBRIC_NUM_ROWS = ""rubricNumRows"";
        public static final String FEEDBACK_QUESTION_RUBRIC_NUM_COLS = ""rubricNumCols"";
        public static final String FEEDBACK_QUESTION_RUBRIC_MOVE_COL_LEFT = ""rubric-move-col-left"";
        public static final String FEEDBACK_QUESTION_RUBRIC_MOVE_COL_RIGHT = ""rubric-move-col-right"";
        public static final String FEEDBACK_QUESTION_RANKOPTION = ""rankOption"";
        public static final String FEEDBACK_QUESTION_RANKTORECIPIENTS = ""rankToRecipients"";
        public static final String FEEDBACK_QUESTION_RANKNUMOPTIONS = ""rankNumOptions"";
        public static final String FEEDBACK_QUESTION_RANKISDUPLICATESALLOWED = ""rankAreDuplicatesAllowed"";

        public static final String FEEDBACK_RESPONSE_ID = ""responseid"";
        public static final String FEEDBACK_RESPONSE_RECIPIENT = ""responserecipient"";
        public static final String FEEDBACK_RESPONSE_TEXT = ""responsetext"";

        public static final String FEEDBACK_RESPONSE_COMMENT_ID = ""responsecommentid"";
        public static final String FEEDBACK_RESPONSE_COMMENT_TEXT = ""responsecommenttext"";

        public static final String FEEDBACK_RESULTS_UPLOADDOWNLOADBUTTON = ""fruploaddownloadbtn"";
        public static final String FEEDBACK_RESULTS_SORTTYPE = ""frsorttype"";
        public static final String FEEDBACK_RESULTS_GROUPBYTEAM = ""frgroupbyteam"";
        public static final String FEEDBACK_RESULTS_GROUPBYSECTION = ""frgroupbysection"";
        public static final String FEEDBACK_RESULTS_SHOWSTATS = ""frshowstats"";
        public static final String FEEDBACK_RESULTS_INDICATE_MISSING_RESPONSES = ""frindicatemissingresponses"";
        public static final String FEEDBACK_RESULTS_NEED_AJAX = ""frneedajax"";
        public static final String FEEDBACK_RESULTS_MAIN_INDEX = ""frmainindex"";

        public static final String PREVIEWAS = ""previewas"";

        public static final String STUDENT_ID = ""googleid"";
        public static final String INVITER_ID = ""invitergoogleid"";

        public static final String REGKEY = ""key"";
        public static final String STUDENT_EMAIL = ""studentemail"";
        public static final String NEW_STUDENT_EMAIL = ""newstudentemail"";

        public static final String STUDENT_SHORT_NAME = ""studentshortname"";
        public static final String STUDENT_PROFILE_EMAIL = ""studentprofileemail"";
        public static final String STUDENT_PROFILE_INSTITUTION = ""studentprofileinstitute"";
        public static final String STUDENT_NATIONALITY = ""studentnationality"";
        public static final String STUDENT_GENDER = ""studentgender"";
        public static final String STUDENT_PROFILE_MOREINFO = ""studentprofilemoreinfo"";
        public static final String STUDENT_PROFILE_PHOTO = ""studentprofilephoto"";
        public static final String STUDENT_PROFILE_PHOTOEDIT = ""editphoto"";

        public static final String STUDENT_NAME = ""studentname"";
        public static final String RESPONSE_COMMENTS_SHOWCOMMENTSTO = ""showresponsecommentsto"";
        public static final String RESPONSE_COMMENTS_SHOWGIVERTO = ""showresponsegiverto"";
        public static final String SECTION_NAME = ""sectionname"";

        public static final String TEAM_NAME = ""teamname"";
        public static final String COMMENTS = ""comments"";
        public static final String TEAMMATES = ""teammates"";

        public static final String STATUS_MESSAGES_LIST = ""statusMessagesToUser"";
        public static final String ERROR = ""error"";
        public static final String NEXT_URL = ""next"";
        public static final String USER_ID = ""user"";
        public static final String HINT = ""hint"";
        public static final String FEEDBACK_SESSION_NOT_VISIBLE = ""feedbacksessionnotvisible"";

        public static final String LOGIN_ADMIN = ""admin"";
        public static final String LOGIN_INSTRUCTOR = ""instructor"";
        public static final String LOGIN_STUDENT = ""student"";

        //Email parameters
        public static final String EMAIL_RECEIVER = ""user"";
        public static final String EMAIL_COURSE = ""course"";
        public static final String EMAIL_FEEDBACK = ""feedback"";
        public static final String EMAIL_TYPE = ""type"";
        public static final String SESSION_SUMMARY_EMAIL_SEND_CHECK = ""sessionsummarysendemail"";
        public static final String OPEN_OR_PUBLISHED_EMAIL_SEND_CHECK = ""openorpublishedemailsent"";

        public static final String EMAIL_CONTENT = ""content"";
        public static final String EMAIL_SENDER = ""sender"";
        public static final String EMAIL_SENDERNAME = ""sendername"";
        public static final String EMAIL_SUBJECT = ""subject"";
        public static final String EMAIL_REPLY_TO_ADDRESS = ""reply"";

        public static final String COMMENT_EDITTYPE = ""commentedittype"";
        public static final String COMMENT_ID = ""commentid"";
        public static final String COMMENT_TEXT = ""commenttext"";

        public static final String SEND_SUBMISSION_EMAIL = ""sendsubmissionemail"";

        //Submission parameters for Task Queue
        public static final String SUBMISSION_COURSE = ""course"";
        public static final String SUBMISSION_FEEDBACK = ""feedback"";
        public static final String SUBMISSION_REMIND_USERLIST = ""usersToRemind"";

        public static final String ENROLLMENT_DETAILS = ""enrollmentdetails"";

        public static final String SEARCH_KEY = ""searchkey"";
        public static final String DISPLAY_ARCHIVE = ""displayarchive"";

        //Parameters for checking persistence of data during Eventual Consistency
        public static final String CHECK_PERSISTENCE_COURSE = ""persistencecourse"";

        public static final String PROFILE_PICTURE_LEFTX = ""cropboxleftx"";
        public static final String PROFILE_PICTURE_TOPY = ""cropboxtopy"";
        public static final String PROFILE_PICTURE_RIGHTX = ""cropboxrightx"";
        public static final String PROFILE_PICTURE_BOTTOMY = ""cropboxbottomy"";
        public static final String PROFILE_PICTURE_HEIGHT = ""pictureheight"";
        public static final String PROFILE_PICTURE_WIDTH = ""picturewidth"";
        public static final String PROFILE_PICTURE_ROTATE = ""picturerotate"";

        public static final String SEARCH_STUDENTS = ""searchstudents"";
        public static final String SEARCH_COMMENTS_FOR_RESPONSES = ""searchcommentforresponses"";
    }

    public static class SearchIndex {
        public static final String FEEDBACK_RESPONSE_COMMENT = ""feedbackresponsecomment"";
        public static final String STUDENT = ""student"";
        public static final String INSTRUCTOR = ""instructor"";
    }

    public static class SearchDocumentField {
        public static final String STUDENT_ATTRIBUTE = ""studentAttribute"";
        public static final String INSTRUCTOR_ATTRIBUTE = ""instructorAttribute"";
        public static final String FEEDBACK_RESPONSE_COMMENT_ATTRIBUTE = ""frCommentAttibute"";
        public static final String FEEDBACK_RESPONSE_COMMENT_GIVER_NAME = ""frCommentGiverName"";
        public static final String FEEDBACK_RESPONSE_COMMENT_GIVER_EMAIL = ""frCommentGiverEmail"";
        public static final String FEEDBACK_RESPONSE_ATTRIBUTE = ""feedbackResponseAttibute"";
        public static final String FEEDBACK_RESPONSE_GIVER_NAME = ""feedbackResponseGiverName"";
        public static final String FEEDBACK_RESPONSE_RECEIVER_NAME = ""feedbackResponseReceiverName"";
        public static final String FEEDBACK_QUESTION_ATTRIBUTE = ""feedbackQuestionAttibute"";
        public static final String FEEDBACK_SESSION_ATTRIBUTE = ""feedbackSessionAttibute"";
        public static final String SEARCHABLE_TEXT = ""searchableText"";
        public static final String CREATED_DATE = ""createdDate"";
        public static final String COURSE_ID = ""courseId"";
        public static final String GIVER_EMAIL = ""giverEmail"";
        public static final String GIVER_SECTION = ""giverSection"";
        public static final String RECIPIENT_EMAIL = ""recipientEmail"";
        public static final String RECIPIENT_SECTION = ""recipientSection"";
        public static final String IS_VISIBLE_TO_INSTRUCTOR = ""isVisibleToInstructor"";
        public static final String IS_VISIBLE_TO_RECEIVER = ""isVisibleToReceiver"";
        public static final String IS_VISIBLE_TO_GIVER = ""isVisibleToGiver"";
    }

    public static class ActionURIs {

        /* _PAGE/Page in the Action URI name means 'show page' */

        public static final String LOGOUT = ""/logout"";

        public static final String INSTRUCTOR_HOME_PAGE = ""/page/instructorHomePage"";
        public static final String INSTRUCTOR_COURSES_PAGE = ""/page/instructorCoursesPage"";
        public static final String INSTRUCTOR_COURSE_ADD = ""/page/instructorCourseAdd"";
        public static final String INSTRUCTOR_COURSE_DELETE = ""/page/instructorCourseDelete"";
        public static final String INSTRUCTOR_COURSE_ARCHIVE = ""/page/instructorCourseArchive"";
        public static final String INSTRUCTOR_COURSE_DETAILS_PAGE = ""/page/instructorCourseDetailsPage"";
        public static final String INSTRUCTOR_COURSE_EDIT_PAGE = ""/page/instructorCourseEditPage"";
        public static final String INSTRUCTOR_COURSE_EDIT_SAVE = ""/page/instructorCourseEditSave"";
        public static final String INSTRUCTOR_COURSE_STUDENT_DETAILS_PAGE = ""/page/instructorCourseStudentDetailsPage"";
        public static final String INSTRUCTOR_COURSE_STUDENT_DETAILS_EDIT = ""/page/instructorCourseStudentDetailsEdit"";
        public static final String INSTRUCTOR_COURSE_STUDENT_DETAILS_EDIT_SAVE =
                ""/page/instructorCourseStudentDetailsEditSave"";
        public static final String INSTRUCTOR_COURSE_STUDENT_DELETE = ""/page/instructorCourseStudentDelete"";
        public static final String INSTRUCTOR_COURSE_STUDENT_DELETE_ALL = ""/page/instructorCourseStudentDeleteAll"";
        public static final String INSTRUCTOR_COURSE_STUDENT_LIST_DOWNLOAD = ""/page/instructorCourseStudentListDownload"";
        public static final String INSTRUCTOR_COURSE_ENROLL_PAGE = ""/page/instructorCourseEnrollPage"";
        public static final String INSTRUCTOR_COURSE_ENROLL_SAVE = ""/page/instructorCourseEnrollSave"";
        public static final String INSTRUCTOR_COURSE_REMIND = ""/page/instructorCourseRemind"";
        public static final String INSTRUCTOR_COURSE_INSTRUCTOR_ADD = ""/page/instructorCourseInstructorAdd"";
        public static final String INSTRUCTOR_COURSE_INSTRUCTOR_EDIT_SAVE = ""/page/instructorCourseInstructorEditSave"";
        public static final String INSTRUCTOR_COURSE_INSTRUCTOR_DELETE = ""/page/instructorCourseInstructorDelete"";
        public static final String INSTRUCTOR_COURSE_JOIN = ""/page/instructorCourseJoin"";
        public static final String INSTRUCTOR_COURSE_JOIN_AUTHENTICATED = ""/page/instructorCourseJoinAuthenticated"";
        public static final String INSTRUCTOR_SEARCH_PAGE = ""/page/instructorSearchPage"";
        public static final String INSTRUCTOR_STUDENT_LIST_PAGE = ""/page/instructorStudentListPage"";
        public static final String INSTRUCTOR_STUDENT_LIST_AJAX_PAGE = ""/page/instructorStudentListAjaxPage"";

        public static final String INSTRUCTOR_STUDENT_RECORDS_PAGE = ""/page/instructorStudentRecordsPage"";
        public static final String INSTRUCTOR_STUDENT_RECORDS_AJAX_PAGE = ""/page/instructorStudentRecordsAjaxPage"";

        public static final String INSTRUCTOR_EDIT_STUDENT_FEEDBACK_PAGE = ""/page/instructorEditStudentFeedbackPage"";
        public static final String INSTRUCTOR_EDIT_STUDENT_FEEDBACK_SAVE = ""/page/instructorEditStudentFeedbackSave"";
        public static final String INSTRUCTOR_EDIT_INSTRUCTOR_FEEDBACK_PAGE = ""/page/instructorEditInstructorFeedbackPage"";
        public static final String INSTRUCTOR_EDIT_INSTRUCTOR_FEEDBACK_SAVE = ""/page/instructorEditInstructorFeedbackSave"";
        public static final String INSTRUCTOR_FEEDBACK_SESSIONS_PAGE = ""/page/instructorFeedbackSessionsPage"";
        public static final String INSTRUCTOR_FEEDBACK_ADD = ""/page/instructorFeedbackAdd"";
        public static final String INSTRUCTOR_FEEDBACK_COPY = ""/page/instructorFeedbackCopy"";
        public static final String INSTRUCTOR_FEEDBACK_DELETE = ""/page/instructorFeedbackDelete"";
        public static final String INSTRUCTOR_FEEDBACK_REMIND = ""/page/instructorFeedbackRemind"";
        public static final String INSTRUCTOR_FEEDBACK_REMIND_PARTICULAR_STUDENTS_PAGE =
                ""/page/instructorFeedbackRemindParticularStudentsPage"";
        public static final String INSTRUCTOR_FEEDBACK_REMIND_PARTICULAR_STUDENTS =
                ""/page/instructorFeedbackRemindParticularStudents"";
        public static final String INSTRUCTOR_FEEDBACK_PUBLISH = ""/page/instructorFeedbackPublish"";
        public static final String INSTRUCTOR_FEEDBACK_UNPUBLISH = ""/page/instructorFeedbackUnpublish"";
        public static final String INSTRUCTOR_FEEDBACK_EDIT_COPY_PAGE = ""/page/instructorFeedbackEditCopyPage"";
        public static final String INSTRUCTOR_FEEDBACK_EDIT_COPY = ""/page/instructorFeedbackEditCopy"";
        public static final String INSTRUCTOR_FEEDBACK_EDIT_PAGE = ""/page/instructorFeedbackEditPage"";
        public static final String INSTRUCTOR_FEEDBACK_EDIT_SAVE = ""/page/instructorFeedbackEditSave"";
        public static final String INSTRUCTOR_FEEDBACK_RESULTS_PAGE = ""/page/instructorFeedbackResultsPage"";
        public static final String INSTRUCTOR_FEEDBACK_RESULTS_DOWNLOAD = ""/page/instructorFeedbackResultsDownload"";
        public static final String INSTRUCTOR_FEEDBACK_PREVIEW_ASSTUDENT = ""/page/instructorFeedbackPreviewAsStudent"";
        public static final String INSTRUCTOR_FEEDBACK_PREVIEW_ASINSTRUCTOR = ""/page/instructorFeedbackPreviewAsInstructor"";

        public static final String INSTRUCTOR_FEEDBACK_QUESTION_ADD = ""/page/instructorFeedbackQuestionAdd"";
        public static final String INSTRUCTOR_FEEDBACK_QUESTION_COPY_PAGE = ""/page/instructorFeedbackQuestionCopyPage"";
        public static final String INSTRUCTOR_FEEDBACK_QUESTION_COPY = ""/page/instructorFeedbackQuestionCopy"";
        public static final String INSTRUCTOR_FEEDBACK_QUESTION_EDIT = ""/page/instructorFeedbackQuestionEdit"";
        public static final String INSTRUCTOR_FEEDBACK_QUESTION_VISIBILITY_MESSAGE =
                ""/page/instructorFeedbackQuestionvisibilityMessage"";

        public static final String INSTRUCTOR_FEEDBACK_RESPONSE_COMMENT_ADD = ""/page/instructorFeedbackResponseCommentAdd"";
        public static final String INSTRUCTOR_FEEDBACK_RESPONSE_COMMENT_EDIT = ""/page/instructorFeedbackResponseCommentEdit"";
        public static final String INSTRUCTOR_FEEDBACK_RESPONSE_COMMENT_DELETE =
                ""/page/instructorFeedbackResponseCommentDelete"";

        public static final String INSTRUCTOR_COURSE_STATS_PAGE = ""/page/courseStatsPage"";
        public static final String INSTRUCTOR_FEEDBACK_STATS_PAGE = ""/page/feedbackSessionStatsPage"";

        public static final String INSTRUCTOR_FEEDBACK_SUBMISSION_EDIT_PAGE = ""/page/instructorFeedbackSubmissionEditPage"";
        public static final String INSTRUCTOR_FEEDBACK_SUBMISSION_EDIT_SAVE = ""/page/instructorFeedbackSubmissionEditSave"";

        public static final String CREATE_IMAGE_UPLOAD_URL = ""/page/createImageUploadUrl"";
        public static final String IMAGE_UPLOAD = ""/page/imageUpload"";

        public static final String STUDENT_HOME_PAGE = ""/page/studentHomePage"";
        public static final String STUDENT_COURSE_JOIN = ""/page/studentCourseJoin"";
        public static final String STUDENT_COURSE_JOIN_NEW = ""/page/studentCourseJoinAuthentication"";
        public static final String STUDENT_COURSE_JOIN_AUTHENTICATED = ""/page/studentCourseJoinAuthenticated"";
        public static final String STUDENT_COURSE_DETAILS_PAGE = ""/page/studentCourseDetailsPage"";

        public static final String STUDENT_FEEDBACK_SUBMISSION_EDIT_PAGE = ""/page/studentFeedbackSubmissionEditPage"";
        public static final String STUDENT_FEEDBACK_SUBMISSION_EDIT_SAVE = ""/page/studentFeedbackSubmissionEditSave"";

        public static final String STUDENT_FEEDBACK_RESULTS_PAGE = ""/page/studentFeedbackResultsPage"";
        public static final String STUDENT_PROFILE_PAGE = ""/page/studentProfilePage"";
        public static final String STUDENT_PROFILE_EDIT_SAVE = ""/page/studentProfileEditSave"";
        public static final String STUDENT_PROFILE_PICTURE = ""/page/studentProfilePic"";
        public static final String STUDENT_PROFILE_PICTURE_UPLOAD = ""/page/studentProfilePictureUpload"";
        public static final String STUDENT_PROFILE_PICTURE_EDIT = ""/page/studentProfilePictureEdit"";
        public static final String STUDENT_PROFILE_CREATEUPLOADFORMURL = ""/page/studentProfileCreateFormUrl"";

        public static final String ADMIN_EMAIL_LOG_PAGE = ""/admin/adminEmailLogPage"";
        public static final String ADMIN_HOME_PAGE = ""/admin/adminHomePage"";
        public static final String ADMIN_INSTRUCTORACCOUNT_ADD = ""/admin/adminInstructorAccountAdd"";
        public static final String ADMIN_ACCOUNT_MANAGEMENT_PAGE = ""/admin/adminAccountManagementPage"";
        public static final String ADMIN_ACCOUNT_DETAILS_PAGE = ""/admin/adminAccountDetailsPage"";
        public static final String ADMIN_ACCOUNT_DELETE = ""/admin/adminAccountDelete"";
        public static final String ADMIN_EXCEPTION_TEST = ""/admin/adminExceptionTest"";
        public static final String ADMIN_ACTIVITY_LOG_PAGE = ""/admin/adminActivityLogPage"";
        public static final String ADMIN_SESSIONS_PAGE = ""/admin/adminSessionsPage"";
        public static final String ADMIN_SEARCH_PAGE = ""/admin/adminSearchPage"";
        public static final String ADMIN_EMAIL_COMPOSE_PAGE = ""/admin/adminEmailComposePage"";
        public static final String ADMIN_EMAIL_COMPOSE_SAVE = ""/admin/adminEmailComposeSave"";
        public static final String ADMIN_EMAIL_COMPOSE_SEND = ""/admin/adminEmailComposeSend"";
        public static final String ADMIN_EMAIL_SENT_PAGE = ""/admin/adminEmailSentPage"";
        public static final String ADMIN_EMAIL_TRASH_PAGE = ""/admin/adminEmailTrashPage"";
        public static final String ADMIN_EMAIL_TRASH_DELETE = ""/admin/adminEmailTrashDelete"";
        public static final String ADMIN_EMAIL_DRAFT_PAGE = ""/admin/adminEmailDraftPage"";
        public static final String ADMIN_EMAIL_MOVE_TO_TRASH = ""/admin/adminEmailMoveToTrash"";
        public static final String ADMIN_EMAIL_MOVE_OUT_TRASH = ""/admin/adminEmailMoveOutTrash"";
        public static final String ADMIN_EMAIL_IMAGE_UPLOAD = ""/admin/adminEmailImageUpload"";
        public static final String ADMIN_EMAIL_CREATE_IMAGE_UPLOAD_URL = ""/admin/adminEmailCreateImageUploadUrl"";

        public static final String ADMIN_EMAIL_GROUP_RECEIVER_LIST_UPLOAD = ""/admin/adminEmailGroupReceiverListUpload"";
        public static final String ADMIN_EMAIL_CREATE_GROUP_RECEIVER_LIST_UPLOAD_URL =
                ""/admin/adminEmailCreateGroupReceiverListUploadUrl"";

        public static final String PUBLIC_IMAGE_SERVE = ""/public/publicImageServe"";
        public static final String PUBLIC_EMAIL_FILE_SERVE = ""/public/publicEmailImageServe"";
        public static final String ADMIN_STUDENT_GOOGLE_ID_RESET = ""/admin/adminStudentGoogleIdReset"";

        public static final String AUTOMATED_LOG_COMPILATION = ""/auto/compileLogs"";
        public static final String AUTOMATED_FEEDBACK_OPENING_REMINDERS = ""/auto/feedbackSessionOpeningReminders"";
        public static final String AUTOMATED_FEEDBACK_CLOSED_REMINDERS = ""/auto/feedbackSessionClosedReminders"";
        public static final String AUTOMATED_FEEDBACK_CLOSING_REMINDERS = ""/auto/feedbackSessionClosingReminders"";
        public static final String AUTOMATED_FEEDBACK_PUBLISHED_REMINDERS = ""/auto/feedbackSessionPublishedReminders"";

        public static final String BACKDOOR = ""/backdoor"";

    }

    /**
     * Configurations for task queue.
     */
    public static class TaskQueue {

        public static final String ADMIN_PREPARE_EMAIL_ADDRESS_MODE_QUEUE_NAME = ""admin-prepare-email-address-mode-queue"";
        public static final String ADMIN_PREPARE_EMAIL_ADDRESS_MODE_WORKER_URL = ""/worker/adminPrepareEmailAddressMode"";

        public static final String ADMIN_PREPARE_EMAIL_GROUP_MODE_QUEUE_NAME = ""admin-prepare-email-group-mode-queue"";
        public static final String ADMIN_PREPARE_EMAIL_GROUP_MODE_WORKER_URL = ""/worker/adminPrepareEmailGroupMode"";

        public static final String ADMIN_SEND_EMAIL_QUEUE_NAME = ""admin-send-email-queue"";
        public static final String ADMIN_SEND_EMAIL_WORKER_URL = ""/worker/adminSendEmail"";

        public static final String FEEDBACK_RESPONSE_ADJUSTMENT_QUEUE_NAME = ""feedback-response-adjustment-queue"";
        public static final String FEEDBACK_RESPONSE_ADJUSTMENT_WORKER_URL = ""/worker/feedbackResponseAdjustment"";

        public static final String FEEDBACK_SESSION_PUBLISHED_EMAIL_QUEUE_NAME =
                ""feedback-session-published-email-queue"";
        public static final String FEEDBACK_SESSION_PUBLISHED_EMAIL_WORKER_URL =
                ""/worker/feedbackSessionPublishedEmail"";

        public static final String FEEDBACK_SESSION_REMIND_EMAIL_QUEUE_NAME = ""feedback-session-remind-email-queue"";
        public static final String FEEDBACK_SESSION_REMIND_EMAIL_WORKER_URL = ""/worker/feedbackSessionRemindEmail"";

        public static final String FEEDBACK_SESSION_REMIND_PARTICULAR_USERS_EMAIL_QUEUE_NAME =
                ""feedback-session-remind-particular-users-email-queue"";
        public static final String FEEDBACK_SESSION_REMIND_PARTICULAR_USERS_EMAIL_WORKER_URL =
                ""/worker/feedbackSessionRemindParticularUsersEmail"";

        public static final String FEEDBACK_SESSION_UNPUBLISHED_EMAIL_QUEUE_NAME =
                ""feedback-session-unpublished-email-queue"";
        public static final String FEEDBACK_SESSION_UNPUBLISHED_EMAIL_WORKER_URL =
                ""/worker/feedbackSessionUnpublishedEmail"";

        public static final String INSTRUCTOR_COURSE_JOIN_EMAIL_QUEUE_NAME = ""instructor-course-join-email-queue"";
        public static final String INSTRUCTOR_COURSE_JOIN_EMAIL_WORKER_URL = ""/worker/instructorCourseJoinEmail"";

        public static final String SEND_EMAIL_QUEUE_NAME = ""send-email-queue"";
        public static final String SEND_EMAIL_WORKER_URL = ""/worker/sendEmail"";

        public static final String STUDENT_COURSE_JOIN_EMAIL_QUEUE_NAME = ""student-course-join-email-queue"";
        public static final String STUDENT_COURSE_JOIN_EMAIL_WORKER_URL = ""/worker/studentCourseJoinEmail"";

    }

    public static class PublicActionNames {
        public static final String PUBLIC_IMAGE_SERVE_ACTION = ""publicImageServeAction"";
    }

    public static class PageNames {
        public static final String INSTRUCTOR_HOME_PAGE = ""instructorHomePage"";
        public static final String INSTRUCTOR_FEEDBACK_SESSIONS_PAGE = ""instructorFeedbackSessionsPage"";
        public static final String INSTRUCTOR_FEEDBACK_EDIT_PAGE = ""instructorFeedbackEditPage"";
        public static final String INSTRUCTOR_FEEDBACK_COPY = ""instructorFeedbackCopy"";
    }

    public static class ViewURIs {

        /* We omit adding the 'page' prefix to views because all of them are ""pages"" */

        public static final String INSTRUCTOR_HOME = ""/jsp/instructorHome.jsp"";
        public static final String INSTRUCTOR_HOME_AJAX_COURSE_TABLE = ""/jsp/instructorHomeAjaxCourse.jsp"";
        public static final String INSTRUCTOR_FEEDBACK_RESPONSE_COMMENTS_ADD =
                ""/jsp/instructorFeedbackResponseCommentsAdd.jsp"";
        public static final String INSTRUCTOR_COURSES = ""/jsp/instructorCourses.jsp"";
        public static final String INSTRUCTOR_COURSE_EDIT = ""/jsp/instructorCourseEdit.jsp"";
        public static final String INSTRUCTOR_COURSE_DETAILS = ""/jsp/instructorCourseDetails.jsp"";
        public static final String INSTRUCTOR_COURSE_STUDENT_DETAILS = ""/jsp/instructorCourseStudentDetails.jsp"";
        public static final String INSTRUCTOR_COURSE_STUDENT_EDIT = ""/jsp/instructorCourseStudentEdit.jsp"";
        public static final String INSTRUCTOR_COURSE_ENROLL = ""/jsp/instructorCourseEnroll.jsp"";
        public static final String INSTRUCTOR_COURSE_ENROLL_RESULT = ""/jsp/instructorCourseEnrollResult.jsp"";
        public static final String INSTRUCTOR_COURSE_JOIN_CONFIRMATION = ""/jsp/instructorCourseJoinConfirmation.jsp"";
        public static final String INSTRUCTOR_FEEDBACK_SESSIONS = ""/jsp/instructorFeedbacks.jsp"";
        public static final String INSTRUCTOR_FEEDBACK_COPY_MODAL = ""/jsp/instructorFeedbackCopyModal.jsp"";
        public static final String INSTRUCTOR_FEEDBACK_AJAX_REMIND_PARTICULAR_STUDENTS_MODAL =
                ""/jsp/instructorFeedbackAjaxRemindParticularStudentsModal.jsp"";
        public static final String INSTRUCTOR_FEEDBACK_EDIT = ""/jsp/instructorFeedbackEdit.jsp"";
        public static final String INSTRUCTOR_FEEDBACK_RESULTS_TOP = ""/jsp/instructorFeedbackResultsTop.jsp"";
        public static final String INSTRUCTOR_FEEDBACK_RESULTS_BOTTOM = ""/jsp/instructorFeedbackResultsBottom.jsp"";
        public static final String INSTRUCTOR_FEEDBACK_RESULTS_BY_GIVER_RECIPIENT_QUESTION =
                ""/jsp/instructorFeedbackResultsByGiverRecipientQuestion.jsp"";
        public static final String INSTRUCTOR_FEEDBACK_RESULTS_BY_RECIPIENT_GIVER_QUESTION =
                ""/jsp/instructorFeedbackResultsByRecipientGiverQuestion.jsp"";
        public static final String INSTRUCTOR_FEEDBACK_RESULTS_BY_GIVER_QUESTION_RECIPIENT =
                ""/jsp/instructorFeedbackResultsByGiverQuestionRecipient.jsp"";
        public static final String INSTRUCTOR_FEEDBACK_RESULTS_BY_RECIPIENT_QUESTION_GIVER =
                ""/jsp/instructorFeedbackResultsByRecipientQuestionGiver.jsp"";
        public static final String INSTRUCTOR_FEEDBACK_RESULTS_BY_QUESTION = ""/jsp/instructorFeedbackResultsByQuestion.jsp"";
        public static final String INSTRUCTOR_FEEDBACK_SUBMISSION_EDIT = ""/jsp/instructorFeedbackSubmissionEdit.jsp"";
        public static final String INSTRUCTOR_FEEDBACK_QUESTION_SUBMISSION_EDIT =
                ""/jsp/instructorFeedbackQuestionSubmissionEdit.jsp"";
        public static final String INSTRUCTOR_FEEDBACK_QUESTION_COPY_MODAL =
                ""/jsp/instructorFeedbackQuestionCopyModal.jsp"";
        public static final String INSTRUCTOR_SEARCH = ""/jsp/instructorSearch.jsp"";
        public static final String INSTRUCTOR_STUDENT_LIST = ""/jsp/instructorStudentList.jsp"";
        public static final String INSTRUCTOR_STUDENT_LIST_AJAX = ""/jsp/instructorStudentListAjax.jsp"";
        public static final String INSTRUCTOR_STUDENT_RECORDS = ""/jsp/instructorStudentRecords.jsp"";
        public static final String INSTRUCTOR_STUDENT_RECORDS_AJAX = ""/jsp/instructorStudentRecordsAjax.jsp"";

        public static final String STUDENT_HOME = ""/jsp/studentHome.jsp"";
        public static final String STUDENT_COURSE_JOIN_CONFIRMATION = ""/jsp/studentCourseJoinConfirmation.jsp"";
        public static final String STUDENT_COURSE_DETAILS = ""/jsp/studentCourseDetails.jsp"";
        public static final String STUDENT_FEEDBACK_SUBMISSION_EDIT = ""/jsp/studentFeedbackSubmissionEdit.jsp"";
        public static final String STUDENT_FEEDBACK_QUESTION_SUBMISSION_EDIT =
                ""/jsp/studentFeedbackQuestionSubmissionEdit.jsp"";
        public static final String STUDENT_FEEDBACK_RESULTS = ""/jsp/studentFeedbackResults.jsp"";
        public static final String STUDENT_PROFILE_PAGE = ""/jsp/studentProfilePage.jsp"";

        public static final String ADMIN_HOME = ""/jsp/adminHome.jsp"";
        public static final String ADMIN_ACCOUNT_MANAGEMENT = ""/jsp/adminAccountManagement.jsp"";
        public static final String ADMIN_SEARCH = ""/jsp/adminSearch.jsp"";
        public static final String ADMIN_EMAIL = ""/jsp/adminEmail.jsp"";
        public static final String ADMIN_ACTIVITY_LOG = ""/jsp/adminActivityLog.jsp"";
        public static final String ADMIN_ACTIVITY_LOG_AJAX = ""/jsp/adminActivityLogAjax.jsp"";
        public static final String ADMIN_ACCOUNT_DETAILS = ""/jsp/adminAccountDetails.jsp"";
        public static final String ADMIN_SESSIONS = ""/jsp/adminSessions.jsp"";
        public static final String ADMIN_EMAIL_LOG = ""/jsp/adminEmailLog.jsp"";
        public static final String ADMIN_EMAIL_LOG_AJAX = ""/jsp/adminEmailLogAjax.jsp"";

        public static final String GOOGLE_ACCOUNT_HINT = ""/googleAccountHint.jsp"";
        public static final String ENABLE_JS = ""/enableJs.jsp"";
        public static final String INVALID_ORIGIN = ""/invalidOrigin.jsp"";
        public static final String UNAUTHORIZED = ""/unauthorized.jsp"";
        public static final String ERROR_PAGE = ""/errorPage.jsp"";
        public static final String DEADLINE_EXCEEDED_ERROR_PAGE = ""/deadlineExceededErrorPage.jsp"";
        public static final String ENTITY_NOT_FOUND_PAGE = ""/entityNotFoundPage.jsp"";
        public static final String ACTION_NOT_FOUND_PAGE = ""/pageNotFound.jsp"";
        public static final String FEEDBACK_SESSION_NOT_VISIBLE = ""/feedbackSessionNotVisible.jsp"";

        public static final String JS_UNIT_TEST = ""/test/allJsUnitTests.jsp"";
        public static final String MASHUP = ""/test/mashup.jsp"";
        public static final String TABLE_SORT = ""/test/tableSort.jsp"";
        public static final String TIMEZONE = ""/test/timezone.jsp"";
    }

    /* These are status messages that may be shown to the user */
    public static class StatusMessages {

        public static final String IMAGE_TOO_LARGE = ""The uploaded image was too large. "";
        public static final String FILE_NOT_A_PICTURE = ""The file that you have uploaded is not a picture. "";
        public static final String NO_IMAGE_GIVEN = ""Please specify a image to be uploaded."";
        public static final String EMAIL_NOT_FOUND = ""The requested email was not found"";
        public static final String EMAIL_DRAFT_SAVED = ""Email draft has been saved"";

        public static final String NOT_A_RECEIVER_LIST_FILE =
                ""The file that you have uploaded is not a receiver list file. "";
        public static final String NO_GROUP_RECEIVER_LIST_FILE_GIVEN = ""Please specify a receiver list file to be uploaded."";

        public static final String STUDENT_FIRST_TIME =
                ""<div class=\""align-left\"">""
                    + ""<div class=\""align-center text-color-red text-bold\"">""
                        + ""Ooops! Your Google account is not known to TEAMMATES""
                    + ""</div>""
                    + ""<br>""
                    + ""To access a course on TEAMMATES, you need to wait until an instructor adds you to ""
                    + ""that course. As a confirmation, TEAMMATES will send you instructions on how to access ""
                    + ""that particular course.""
                    + ""<br><br>""
                    + ""If you 'joined' the course in TEAMMATES using a Google account before, but cannot login ""
                    + ""anymore, these are the possible reasons:""
                    + ""<ol>""
                        + ""<li>""
                            + ""You used a different Google account to access TEAMMATES in the past. ""
                            + ""In that case, you need to use the same Google account to access TEAMMATES again. ""
                            + ""Logout and re-login using the other Google account. ""
                            + ""If you don't remember which Google account you used previously, ""
                            + ""email us from the same email account to which you receive TEAMMATES emails.""
                        + ""</li>""
                        + ""<li>""
                            + ""You changed the primary email from a non-Gmail address to a Gmail address recently. ""
                            + ""In that case, <a href=\""/contact.jsp\"">email us</a> ""
                            + ""so that we can reconfigure your account to use the new Gmail address.""
                        + ""</li>""
                        + ""<li>""
                            + ""You joined this course just a few seconds ago and your data ""
                            + ""may be still in the process of propagating through our servers. ""
                            + ""In that case, please click on the ""
                            + ""<a href="" + ActionURIs.STUDENT_HOME_PAGE + "">Home</a> link above in a few minutes. ""
                        + ""</li>""
                    + ""</ol>""
                + ""</div>"";

        public static final String COURSE_ADDED =
                ""The course has been added. Click <a href=\""${courseEnrollLink}\"">here</a> to add students to the course ""
                + ""or click <a href=\""${courseEditLink}\"">here</a> to add other instructors.<br>""
                + ""If you don't see the course in the list below, please refresh the page after a few moments."";
        public static final String COURSE_EXISTS =
                ""A course by the same ID already exists in the system, possibly created by another user. ""
                + ""Please choose a different course ID"";
        public static final String COURSE_EDITED = ""The course has been edited."";
        public static final String COURSE_ARCHIVED =
                ""The course %s has been archived. It will not appear in the home page any more."";
        // TODO: Let undo process to be in the Course page for now.
        // Should implement to be able to undo the archiving from the home page later.
        public static final String COURSE_ARCHIVED_FROM_HOMEPAGE =
                COURSE_ARCHIVED + "" You can access archived courses from the 'Courses' tab.<br>""
                + ""Go there to undo the archiving and bring the course back to the home page."";
        public static final String COURSE_UNARCHIVED = ""The course %s has been unarchived."";
        public static final String COURSE_DELETED = ""The course %s has been deleted."";
        public static final String COURSE_EMPTY =
                ""You have not created any courses yet. Use the form above to create a course."";
        public static final String COURSE_EMPTY_IN_INSTRUCTOR_FEEDBACKS =
                ""You have not created any courses yet, or you have no active courses. Go <a href=\""""
                + ActionURIs.INSTRUCTOR_COURSES_PAGE + ""${user}\"">here</a> to create or unarchive a course."";
        public static final String COURSE_REMINDER_SENT_TO = ""An email has been sent to "";
        public static final String COURSE_REMINDERS_SENT = ""Emails have been sent to unregistered students."";

        public static final String COURSE_ENROLL_POSSIBLE_DATA_LOSS = ""There are existing feedback responses ""
                + ""for this course. Modifying records of enrolled students will result in some existing ""
                + ""responses from those modified students to be deleted. You may wish to download the data ""
                + ""before you make the changes."";
        public static final String COURSE_ENROLL_STUDENTS_ERROR = ""Errors on %d student(s):"";
        public static final String COURSE_ENROLL_STUDENTS_ADDED = ""%d student(s) added:"";
        public static final String COURSE_ENROLL_STUDENTS_MODIFIED = ""%d student(s) modified:"";
        public static final String COURSE_ENROLL_STUDENTS_UNMODIFIED = ""%d student(s) updated with no changes:"";
        public static final String COURSE_ENROLL_STUDENTS_NOT_IN_LIST = ""%d student(s) remain unmodified:"";
        public static final String COURSE_ENROLL_STUDENTS_UNKNOWN = ""%d student(s) with unknown enrolment status:"";

        public static final String TEAM_INVALID_SECTION_EDIT =
                ""The team \""%s\"" is in multiple sections. ""
                + ""The team ID should be unique across the entire course ""
                + ""and a team cannot be spread across multiple sections.<br>"";
        public static final String SECTION_QUOTA_EXCEED =
                ""You are trying enroll more than 100 students in section \""%s\"". ""
                + ""To avoid performance problems, please do not enroll more than 100 students in a single section.<br>"";
        public static final String QUOTA_PER_ENROLLMENT_EXCEED =
                ""You are trying to enroll more than 100 students. ""
                + ""To avoid performance problems, please enroll no more than 100 students at a time."";

        public static final String COURSE_INSTRUCTOR_ADDED = ""The instructor %s has been added successfully. ""
                + ""An email containing how to 'join' this course will be sent to %s in a few minutes."";
        public static final String COURSE_INSTRUCTOR_EXISTS =
                ""An instructor with the same email address already exists in the course."";
        public static final String COURSE_INSTRUCTOR_EDITED = ""The changes to the instructor %s has been updated."";
        public static final String COURSE_INSTRUCTOR_DELETED = ""The instructor has been deleted from the course."";
        public static final String COURSE_INSTRUCTOR_DELETE_NOT_ALLOWED =
                ""The instructor you are trying to delete is the last instructor in the course. ""
                + ""Deleting the last instructor from the course is not allowed."";

        public static final String JOIN_COURSE_KEY_BELONGS_TO_DIFFERENT_USER =
                ""The join link used belongs to a different user whose Google ID is ""
                + ""%s (only part of the Google ID is shown to protect privacy). ""
                + ""If that Google ID is owned by you, please logout and re-login ""
                + ""using that Google account. If it doesnt belong to you, please ""
                + ""<a href=\""mailto:"" + Config.SUPPORT_EMAIL + ""?""
                + ""body=Your name:%%0AYour course:%%0AYour university:\"">""
                + ""contact us</a> so that we can investigate."";
        public static final String JOIN_COURSE_GOOGLE_ID_BELONGS_TO_DIFFERENT_USER =
                ""The Google ID %s belongs to an existing user in the course.""
                + ""Please login again using a different Google account, and try to join the course again."";

        public static final String STUDENT_GOOGLEID_RESET = ""The student's google id has been reset"";
        public static final String STUDENT_GOOGLEID_RESET_FAIL =
                ""An error occurred when trying to reset student's google id"";

        public static final String STUDENT_EVENTUAL_CONSISTENCY =
                ""If the student was created during the last few minutes, ""
                + ""try again in a few more minutes as the student may still be being saved."";

        public static final String STUDENT_EDITED = ""The student has been edited successfully."";
        public static final String STUDENT_EDITED_AND_EMAIL_SENT = STUDENT_EDITED
                + "" A summary of the course has been sent to the new email."";
        public static final String STUDENT_NOT_FOUND_FOR_EDIT =
                ""The student you tried to edit does not exist. "" + STUDENT_EVENTUAL_CONSISTENCY;
        public static final String STUDENT_DELETED = ""The student has been removed from the course"";
        public static final String STUDENTS_DELETED = ""All the students have been removed from the course"";
        public static final String STUDENT_PROFILE_EDITED = ""Your profile has been edited successfully"";
        public static final String STUDENT_PROFILE_PICTURE_SAVED = ""Your profile picture has been saved successfully"";
        public static final String STUDENT_PROFILE_PIC_TOO_LARGE = ""The uploaded profile picture was too large. ""
                + ""Please try again with a smaller picture."";
        public static final String STUDENT_PROFILE_PIC_SERVICE_DOWN = ""We were unable to upload your picture at this time. ""
                + ""Please try again after some time"";
        public static final String STUDENT_EMAIL_TAKEN_MESSAGE =
                ""Trying to update to an email that is already used by: %s/%s"";

        public static final String FEEDBACK_SESSION_ADDED =
                ""The feedback session has been added. ""
                + ""Click the \""Add New Question\"" button below to begin adding questions for the feedback session."";
        public static final String FEEDBACK_SESSION_ADD_DB_INCONSISTENCY =
                ""If you do not see existing feedback sessions in the list below, ""
                + ""please refresh the page after a few moments"";
        public static final String FEEDBACK_SESSION_COPIED =
                ""The feedback session has been copied. Please modify settings/questions as necessary."";
        public static final String FEEDBACK_SESSION_COPY_NONESELECTED =
                ""You have not selected any course to copy the feedback session to"";
        public static final String FEEDBACK_SESSION_COPY_ALREADYEXISTS =
                ""A feedback session with the name \""%s\"" already exists in the following course(s): %s."";
        public static final String FEEDBACK_SESSION_EDITED = ""The feedback session has been updated."";
        public static final String FEEDBACK_SESSION_END_TIME_EARLIER_THAN_START_TIME =
                ""The end time for this feedback session cannot be earlier than the start time."";
        public static final String FEEDBACK_SESSION_DELETED = ""The feedback session has been deleted."";
        public static final String FEEDBACK_SESSION_DELETED_NO_ACCESS =
                ""The feedback session has been deleted and is no longer accessible."";
        public static final String FEEDBACK_SESSION_PUBLISHED =
                ""The feedback session has been published. ""
                + ""Please allow up to 1 hour for all the notification emails to be sent out."";
        public static final String FEEDBACK_SESSION_UNPUBLISHED = ""The feedback session has been unpublished."";
        public static final String FEEDBACK_SESSION_REMINDERSSENT =
                ""Reminder e-mails have been sent out to those students and instructors. ""
                + ""Please allow up to 1 hour for all the notification emails to be sent out."";
        public static final String FEEDBACK_SESSION_REMINDERSEMPTYRECIPIENT = ""You have not selected any student to remind."";
        public static final String FEEDBACK_SESSION_EXISTS =
                ""A feedback session by this name already exists under this course"";
        public static final String FEEDBACK_SESSION_EMPTY =
                ""You have not created any sessions yet. Use the form above to create a session."";

        public static final String FEEDBACK_QUESTION_ADDED = ""The question has been added to this feedback session."";
        public static final String FEEDBACK_QUESTION_EDITED = ""The changes to the question have been updated."";
        public static final String FEEDBACK_QUESTION_DELETED = ""The question has been deleted."";
        public static final String FEEDBACK_QUESTION_EMPTY =
                ""You have not created any questions for this feedback session yet. ""
                + ""Click the button below to add a feedback question."";
        public static final String FEEDBACK_QUESTION_NUMBEROFENTITIESINVALID =
                ""Please enter the maximum number of recipients each respondents should give feedback to."";
        public static final String FEEDBACK_QUESTION_TEXTINVALID =
                ""Please enter a valid question. The question text cannot be empty."";

        public static final String FEEDBACK_RESPONSES_SAVED = ""All responses submitted successfully!"";
        public static final String FEEDBACK_RESPONSES_MISSING_RECIPIENT =
                ""You did not specify a recipient for your response in question %s."";
        public static final String FEEDBACK_RESPONSES_WRONG_QUESTION_TYPE =
                ""Incorrect question type for response in question %s."";
        public static final String FEEDBACK_RESPONSES_INVALID_ID = ""You are modifying an invalid response in question %s"";

        public static final String FEEDBACK_RESPONSE_COMMENT_EMPTY = ""Comment cannot be empty"";
        public static final String FEEDBACK_RESPONSE_INVALID_RECIPIENT =
                ""Trying to update recipient to an invalid recipient for question %d."";

        public static final String FEEDBACK_SUBMISSIONS_NOT_OPEN =
                ""<strong>The feedback session is currently not open for submissions.</strong> ""
                + ""You can view the questions and any submitted responses for this feedback session ""
                + ""but cannot submit new responses."";

        public static final String FEEDBACK_RESULTS_SOMETHINGNEW =
                ""You have received feedback from others. Please see below."";
        public static final String FEEDBACK_RESULTS_NOTHINGNEW =
                ""You have not received any new feedback but you may review your own submissions below."";
        public static final String FEEDBACK_RESULTS_SECTIONVIEWWARNING =
                ""This session seems to have a large number of responses. ""
                + ""It is recommended to view the results one question/section at a time. ""
                + ""To view responses for a particular question, click on the question below. ""
                + ""To view response for a particular section, choose the section from the drop-down box above."";
        public static final String FEEDBACK_RESULTS_QUESTIONVIEWWARNING =
                ""This session seems to have a large number of responses. ""
                + ""It is recommended to view the results for one question at a time. ""
                + ""To view responses for a particular question, click on the question below."";
        public static final String ENROLL_LINE_EMPTY = ""Please input at least one student detail."";
        public static final String ENROLL_LINES_PROBLEM_DETAIL_PREFIX = ""&bull;"";
        public static final String ENROLL_LINES_PROBLEM =
                ""<p><span class=\""bold\"">Problem in line : <span class=\""invalidLine\"">%s</span></span>""
                + ""<br><span class=\""problemDetail\"">"" + ENROLL_LINES_PROBLEM_DETAIL_PREFIX + "" %s</span></p>"";

        public static final String EVENTUAL_CONSISTENCY_MESSAGE_STUDENT =
                ""You have successfully joined the course %1$s. ""
                + ""<br>Updating of the course data on our servers is currently in progress ""
                + ""and will be completed in a few minutes. ""
                + ""<br>Please refresh this page in a few minutes to see the course %1$s in the list below."";

        public static final String NULL_POST_PARAMETER_MESSAGE =
                ""You have been redirected to this page due to a possible expiry of the previous login.""
                + ""<br>If you have previously typed some data and wish to retrieve it, ""
                + ""you may use the 'Back' button of your Browser to navigate to the ""
                + ""previous page containing the data you typed in."";

        public static final String INSTRUCTOR_STATUS_DELETED = ""The Instructor status has been deleted"";
        public static final String INSTRUCTOR_ACCOUNT_DELETED = ""The Account has been deleted"";
        public static final String INSTRUCTOR_REMOVED_FROM_COURSE = ""The Instructor has been removed from the Course"";

        public static final String INSTRUCTOR_COURSE_EMPTY =
                ""There are no students in this course. Click <a href=\""%s\"">here</a> to enroll students."";
        public static final String INSTRUCTOR_PERSISTENCE_ISSUE =
                ""Account creation is still in progress. Please reload the page""
                + "" after sometime."";
        public static final String INSTRUCTOR_NO_MODIFY_PERMISSION_FOR_ACTIVE_COURSES_SESSIONS =
                ""No permission to modify any sessions in un-archived courses"";
        public static final String INSTRUCTOR_NO_ACTIVE_COURSES = ""No un-archived courses"";
        public static final String INSTRUCTOR_NO_COURSE_AND_STUDENTS =
                ""There are no course or students information to be displayed"";
        public static final String INSTRUCTOR_NO_STUDENT_RECORDS = ""No records were found for this student"";
        public static final String INSTRUCTOR_SEARCH_NO_RESULTS = ""No results found."";
        public static final String INSTRUCTOR_SEARCH_TIPS =
                ""Search Tips:<br>""
                + ""<ul>""
                    + ""<li>Put more keywords to search for more precise results.</li>""
                    + ""<li>Put quotation marks around words <b>\""[any word]\""</b>""
                            + "" to search for an exact phrase in an exact order.</li>""
                + ""</ul>"";

        public static final String HINT_FOR_NEW_INSTRUCTOR = ""New to TEAMMATES? You may wish to have a look at our ""
                + ""<a href=\""/instructorHelp.jsp#gs\"" target=\""_blank\"">Getting Started Guide</a>.<br>A video tour""
                + "" is also available in our <a href=\""/\"" target=\""_blank\"">home page</a>."";

        public static final String NEW_INSTRUCTOR_TEXT_MESSAGE = ""New to TEAMMATES? You may wish to have a look at our ""
                + ""Getting Started Guide.\n""
                + ""A video tour is also available in our home page."";

        public static final String HINT_FOR_NO_SESSIONS_STUDENT =
                ""Currently, there are no open feedback sessions in the course %s. ""
                + ""When a session is open for submission you will be notified."";
        public static final String STUDENT_UPDATE_PROFILE =
                ""Meanwhile, you can update your profile <a href=\"""" + Const.ActionURIs.STUDENT_PROFILE_PAGE + ""\"">here</a>."";
        public static final String STUDENT_UPDATE_PROFILE_SHORTNAME =
                ""Meanwhile, you can provide a name that you would prefer to be called by ""
                + ""<a href=\"""" + Const.ActionURIs.STUDENT_PROFILE_PAGE + ""\"">here</a>."";
        public static final String STUDENT_UPDATE_PROFILE_EMAIL =
                ""Meanwhile, you can provide an email for your instructors to contact you beyond graduation ""
                + ""<a href=\"""" + Const.ActionURIs.STUDENT_PROFILE_PAGE + ""\"">here</a>."";
        public static final String STUDENT_UPDATE_PROFILE_PICTURE =
                ""Meanwhile, you can upload a profile picture ""
                + ""<a href=\"""" + Const.ActionURIs.STUDENT_PROFILE_PAGE + ""\"">here</a>."";
        public static final String STUDENT_UPDATE_PROFILE_MOREINFO =
                ""Meanwhile, you can provide more information about yourself ""
                + ""<a href=\"""" + Const.ActionURIs.STUDENT_PROFILE_PAGE + ""\"">here</a>."";
        public static final String STUDENT_UPDATE_PROFILE_NATIONALITY =
                ""Meanwhile, you can provide your nationality ""
                + ""<a href=\"""" + Const.ActionURIs.STUDENT_PROFILE_PAGE + ""\"">here</a>."";

        // Messages that are templates only
        /** Template String. Parameters: Student's name, Course ID */
        public static final String STUDENT_COURSE_JOIN_SUCCESSFUL = ""You have been successfully added to the course %s."";

        /** Template String. Parameters:  Course ID */
        public static final String NON_EXISTENT_STUDENT_ATTEMPTING_TO_JOIN_COURSE =
                ""Unable to join course %s as you are currently not in the student list of that course. ""
                + ""Please contact your course instructor for assistance."";
        public static final String STUDENT_PROFILE_NOT_A_PICTURE = ""The file that you have uploaded is not a picture. ""
                + ""Please upload a picture (usually it ends with .jpg or .png)"";
        public static final String STUDENT_PROFILE_NO_PICTURE_GIVEN = ""Please specify a file to be uploaded."";
        public static final String STUDENT_NOT_FOUND_FOR_RECORDS =
                ""The student you tried to view records for does not exist. "" + STUDENT_EVENTUAL_CONSISTENCY;
        public static final String STUDENT_NOT_FOUND_FOR_COURSE_DETAILS =
                ""The student you tried to view details for does not exist. "" + STUDENT_EVENTUAL_CONSISTENCY;
        public static final String STUDENT_PROFILE_PICTURE_EDIT_FAILED =
                ""The photo that was edited did not belong to the user. ""
                + ""Please upload another picture to begin editing"";
        public static final String STUDENT_NOT_JOINED_YET_FOR_RECORDS =
                ""Normally, we would show the students profile here. ""
                + ""However, this student has not created a profile yet"";
        public static final String STUDENT_PROFILE_UNACCESSIBLE_TO_INSTRUCTOR =
                ""Normally, we would show the students profile here. ""
                + ""However, you do not have access to view this student's profile"";

        public static final String UNREGISTERED_STUDENT_MESSAGE = ""You may submit feedback for sessions ""
                + ""that are currently open and view results without logging in. To access other features ""
                + ""you need <a href='%s' class='link'>to login using a Google account</a> (recommended)."";
        public static final String UNREGISTERED_STUDENT = ""You are submitting feedback as ""
                + ""<span class='text-danger text-bold text-large'>%s</span>. ""
                + UNREGISTERED_STUDENT_MESSAGE;
        public static final String UNREGISTERED_STUDENT_RESULTS = ""You are viewing feedback results as ""
                + ""<span class='text-danger text-bold text-large'>%s</span>. ""
                + UNREGISTERED_STUDENT_MESSAGE;
        public static final String ADMIN_LOG_INSTRUCTOR_COURSE_ENROLL_PAGE_LOAD =
                ""instructorCourseEnroll Page Load"" + Const.HTML_BR_TAG
                + ""Enrollment for Course <span class=\""bold\"">[%s]</span>"";
    }

    /* These indicate status of an operation, but they are not shown to the user */
    public static class StatusCodes {

        // Backdoor responses
        public static final String BACKDOOR_STATUS_SUCCESS = ""[BACKDOOR_STATUS_SUCCESS]"";
        public static final String BACKDOOR_STATUS_FAILURE = ""[BACKDOOR_STATUS_FAILURE]"";

        // General Error codes
        public static final String ALREADY_JOINED = ""ERRORCODE_ALREADY_JOINED"";
        public static final String NULL_PARAMETER = ""ERRORCODE_NULL_PARAMETER"";
        public static final String INVALID_KEY = ""ERRORCODE_INVALID_KEY"";
        public static final String KEY_BELONGS_TO_DIFFERENT_USER = ""ERRORCODE_KEY_BELONGS_TO_DIFFERENT_USER"";

        // Error message used across DB level
        public static final String DBLEVEL_NULL_INPUT = ""Supplied parameter was null"";

        // POST parameter null message
        public static final String NULL_POST_PARAMETER = ""The %s POST parameter is null%n"";
    }

    public static class PlaceholderText {
        public static final String FEEDBACK_QUESTION = ""A concise version of the question e.g. ""
                + ""&quot;How well did the team member communicate?&quot;"";
        public static final String FEEDBACK_QUESTION_DESCRIPTION = ""More details about the question e.g. &quot;In answering ""
                + ""the question, do consider communications made informally within the team, and formal communications with ""
                + ""the instructors and tutors.&quot;"";
    }

    /**
     * These are constants that may be used in {@link ActivityLogEntry}.
     */
    public static class ActivityLog {
        public static final String TEAMMATESLOG = ""TEAMMATESLOG"";

        public static final String UNKNOWN = ""Unknown"";

        public static final String ROLE_ADMIN = ""Admin"";
        public static final String ROLE_INSTRUCTOR = ""Instructor"";
        public static final String ROLE_STUDENT = ""Student"";
        public static final String ROLE_AUTO = ""Auto"";
        public static final String ROLE_UNREGISTERED = ""Unregistered"";
        public static final String ROLE_MASQUERADE_POSTFIX = ""(M)"";

        public static final String PREFIX_STUDENT_PAGE = ""student"";
        public static final String PREFIX_INSTRUCTOR_PAGE = ""instructor"";
        public static final String PREFIX_AUTO_PAGE = ""/auto"";

        public static final String AUTH_NOT_LOGIN = ""Unknown"";

        public static final String FIELD_SEPARATOR = ""|||"";
        public static final String FIELD_CONNECTOR = ""%"";

        public static final String TIME_FORMAT_LOGID = ""yyyyMMddHHmmssSS"";

        public static final String TESTING_DATA_EMAIL_POSTFIX = "".tmt"";

        public static final int TIME_TAKEN_EXPECTED = 10000;
        public static final int TIME_TAKEN_MODERATE = 20000;

        public static final String MESSAGE_ERROR_ACTION_NAME = ""Error when getting ActionName for requestUrl : %1$s"";
        public static final String MESSAGE_ERROR_LOG_MESSAGE_FORMAT = ""Log message format not as expected: %1$s"";
    }

    /**
     * These are constants that may be used in {@link EmailLogEntry}.
     */
    public static class EmailLog {
        public static final String TEAMMATES_EMAIL_LOG = ""TEAMMATESEMAILLOG"";
        public static final String FIELD_SEPARATOR = ""|||"";

        public static final String TEST_DATA_POSTFIX = "".tmt"";

        public static final String ERROR_LOG_FORMAT = ""Email log message is not in expected format.""
                + "" Raw log message: %1$s"";
    }

}
"
CryptoHelper.java,util,"package teammates.common.util;

import java.nio.charset.Charset;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;

import javax.crypto.Mac;
import javax.crypto.spec.SecretKeySpec;

/**
 * Cryptographic helper functions.
 */
public final class CryptoHelper {
    private CryptoHelper() {
        // utility class
    }

    /**
     * Computes session token from session ID using the HMAC-MD5 algorithm.
     * Uses {@link Config#ENCRYPTION_KEY} as the secret key for the HMAC-MD5.
     */
    public static String computeSessionToken(String sessionId) {
        SecretKeySpec sks = new SecretKeySpec(StringHelper.hexStringToByteArray(Config.ENCRYPTION_KEY), ""AES"");
        Mac mac = null;
        try {
            mac = Mac.getInstance(""HmacMD5"");
            mac.init(sks);
        } catch (NoSuchAlgorithmException e) {
            Assumption.fail(""Algorithm specified does not exist."");
        } catch (InvalidKeyException e) {
            Assumption.fail(""Invalid encryption key encountered. Check your build.properties file."");
        }
        Charset charset = Charset.forName(""UTF-8"");
        byte[] encryptedSessionId = mac.doFinal(sessionId.getBytes(charset));
        return StringHelper.byteArrayToHexString(encryptedSessionId);
    }
}
"
EmailLogEntry.java,util,"package teammates.common.util;

import java.util.regex.Pattern;

import com.google.appengine.api.log.AppLogLine;

/**
 * A log entry which contains info about subject, receiver, content
 * and sent date of a sent email.
 */
public class EmailLogEntry {

    private static final Logger log = Logger.getLogger();

    private String receiver;
    private String subject;
    private String content;
    private long time;

    public EmailLogEntry(EmailWrapper msg) {
        receiver = msg.getRecipient();
        subject = msg.getSubject();
        content = msg.getContent();
    }

    public EmailLogEntry(AppLogLine appLog) {
        time = appLog.getTimeUsec() / 1000;
        String[] tokens = appLog.getLogMessage()
                .split(Pattern.quote(Const.EmailLog.FIELD_SEPARATOR), -1);

        try {
            receiver = tokens[1];
            subject = tokens[2];
            content = tokens[3];
        } catch (ArrayIndexOutOfBoundsException e) {
            receiver = """";
            subject = """";
            content = """";

            log.severe(String.format(Const.EmailLog.ERROR_LOG_FORMAT, appLog.getLogMessage()));
        }
    }

    /**
     * Generates a log message that will be logged in the server.
     */
    public String generateLogMessage() {
        // TEAMMATESEMAILSLOG|||RECEIVER|||SUBJECT|||CONTENT
        return StringHelper.join(Const.EmailLog.FIELD_SEPARATOR, Const.EmailLog.TEAMMATES_EMAIL_LOG,
                receiver, subject, content);
    }

    public boolean isTestData() {
        return receiver.endsWith(Const.EmailLog.TEST_DATA_POSTFIX);
    }

    // -------- Getter methods --------

    public String getReceiver() {
        return receiver;
    }

    public String getSubject() {
        return subject;
    }

    public long getTime() {
        return time;
    }

    public String getContent() {
        return content;
    }
}
"
EmailType.java,util,"package teammates.common.util;

/**
 * The type object that defines an email based on its purpose.
 */
public enum EmailType {

    FEEDBACK_OPENING(""TEAMMATES: Feedback session now open [Course: %s][Feedback Session: %s]""),
    FEEDBACK_SESSION_REMINDER(""TEAMMATES: Feedback session reminder [Course: %s][Feedback Session: %s]""),
    FEEDBACK_SUBMISSION_CONFIRMATION(
            ""TEAMMATES: Feedback responses successfully recorded [Course: %s][Feedback Session: %s]""),
    FEEDBACK_CLOSING(""TEAMMATES: Feedback session closing soon [Course: %s][Feedback Session: %s]""),
    FEEDBACK_CLOSED(""TEAMMATES: Feedback session closed [Course: %s][Feedback Session: %s]""),
    FEEDBACK_PUBLISHED(""TEAMMATES: Feedback session results published [Course: %s][Feedback Session: %s]""),
    FEEDBACK_UNPUBLISHED(""TEAMMATES: Feedback session results unpublished [Course: %s][Feedback Session: %s]""),
    STUDENT_EMAIL_CHANGED(""TEAMMATES: Summary of course [%s][Course ID: %s]""),
    NEW_INSTRUCTOR_ACCOUNT(""TEAMMATES: Welcome to TEAMMATES! %s""),
    STUDENT_COURSE_JOIN(""TEAMMATES: Invitation to join course [%s][Course ID: %s]""),
    STUDENT_COURSE_REJOIN_AFTER_GOOGLE_ID_RESET(""TEAMMATES: Your account has been reset for course [%s][Course ID: %s]""),
    INSTRUCTOR_COURSE_JOIN(""TEAMMATES: Invitation to join course as an instructor [%s][Course ID: %s]""),
    SEVERE_LOGS_COMPILATION(""TEAMMATES (%s): Severe Error Logs Compilation"");

    private final String subject;

    EmailType(String subject) {
        this.subject = subject;
    }

    /**
     * Gets the subject heading of this email type.
     */
    public String getSubject() {
        return subject;
    }

}
"
EmailWrapper.java,util,"package teammates.common.util;

/**
 * Represents an email message and its important metadata.
 */
public class EmailWrapper {

    private String senderName;
    private String senderEmail;
    private String replyTo;
    private String recipient;
    private String bcc;
    private String subject;
    private String content;

    public String getSenderName() {
        return senderName;
    }

    public void setSenderName(String senderName) {
        this.senderName = senderName;
    }

    public String getSenderEmail() {
        return senderEmail;
    }

    public void setSenderEmail(String senderEmail) {
        this.senderEmail = senderEmail;
    }

    public String getReplyTo() {
        return replyTo;
    }

    public void setReplyTo(String replyTo) {
        this.replyTo = replyTo;
    }

    public String getRecipient() {
        return recipient;
    }

    public void setRecipient(String recipient) {
        this.recipient = recipient;
    }

    public String getBcc() {
        return bcc;
    }

    public void setBcc(String bcc) {
        this.bcc = bcc;
    }

    public String getSubject() {
        return subject;
    }

    public void setSubject(String subject) {
        this.subject = subject;
    }

    public String getContent() {
        return content;
    }

    public void setContent(String content) {
        this.content = content;
    }

    public String getInfoForLogging() {
        return ""[Email sent]to="" + getRecipient()
               + ""|from="" + getSenderEmail()
               + ""|subject="" + getSubject();
    }

}
"
FieldValidator.java,util,"package teammates.common.util;

import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Set;

import org.joda.time.DateTimeZone;

import com.google.appengine.api.datastore.Text;

import teammates.common.datatransfer.FeedbackParticipantType;

/**
 * Used to handle the data validation aspect e.g. validate emails, names, etc.
 */
public class FieldValidator {

    /////////////////
    // FIELD TYPES //
    /////////////////

    // name-related
    public static final String PERSON_NAME_FIELD_NAME = ""person name"";
    public static final int PERSON_NAME_MAX_LENGTH = 100;

    public static final String NATIONALITY_FIELD_NAME = ""nationality"";
    public static final int NATIONALITY_MAX_LENGTH = 55; // one more than longest official nationality name

    public static final String COURSE_NAME_FIELD_NAME = ""course name"";
    public static final int COURSE_NAME_MAX_LENGTH = 64;

    public static final String FEEDBACK_SESSION_NAME_FIELD_NAME = ""feedback session name"";
    public static final int FEEDBACK_SESSION_NAME_MAX_LENGTH = 38;

    public static final String TEAM_NAME_FIELD_NAME = ""team name"";
    public static final int TEAM_NAME_MAX_LENGTH = 60;

    public static final String SECTION_NAME_FIELD_NAME = ""section name"";
    public static final int SECTION_NAME_MAX_LENGTH = 60;

    public static final String INSTITUTE_NAME_FIELD_NAME = ""institute name"";
    public static final int INSTITUTE_NAME_MAX_LENGTH = 64;

    // email-related
    public static final String EMAIL_FIELD_NAME = ""email"";
    public static final int EMAIL_MAX_LENGTH = 254;

    public static final String EMAIL_SUBJECT_FIELD_NAME = ""email subject"";
    public static final int EMAIL_SUBJECT_MAX_LENGTH = 200;

    public static final String EMAIL_CONTENT_FIELD_NAME = ""email content"";
    public static final String EMAIL_CONTENT_ERROR_MESSAGE = EMAIL_CONTENT_FIELD_NAME + "" should not be empty."";

    // others
    public static final String STUDENT_ROLE_COMMENTS_FIELD_NAME = ""comments about a student enrolled in a course"";
    public static final int STUDENT_ROLE_COMMENTS_MAX_LENGTH = 500;

    /*
     * =======================================================================
     * Field: Course ID
     * Unique: system-wide, not just among the course of that instructor.
     * Technically, we can get rid of CourseID field and enforce users to use
     * CourseName as a unique ID. In that case, we have to enforce CourseName
     * must be unique across the full system. However, users expect names to be
     * non-unique and more tolerant of enforcing uniqueness on an ID. Whenever
     * possible, must be displayed in the same case as user entered. This is
     * because the case of the letters can mean something. Furthermore,
     * converting to same case can reduce readability.
     *
     * Course ID is necessary because the course name is not unique enough to
     * distinguish between courses because the same course can be offered
     * multiple times and courses can be shared between instructors and many
     * students. Allowing same Course ID among different instructors could be
     * problematic if we allow multiple instructors for a single course.
     * TODO: make case insensitive
     */
    public static final String COURSE_ID_FIELD_NAME = ""course ID"";
    public static final int COURSE_ID_MAX_LENGTH = 40;

    public static final String SESSION_START_TIME_FIELD_NAME = ""start time"";
    public static final String SESSION_END_TIME_FIELD_NAME = ""end time"";
    public static final String COURSE_TIME_ZONE_FIELD_NAME = ""course time zone"";

    public static final String GOOGLE_ID_FIELD_NAME = ""Google ID"";
    public static final int GOOGLE_ID_MAX_LENGTH = 254;

    public static final String GENDER_FIELD_NAME = ""gender"";
    public static final List<String> GENDER_ACCEPTED_VALUES =
            Collections.unmodifiableList(
                    Arrays.asList(Const.GenderTypes.MALE, Const.GenderTypes.FEMALE, Const.GenderTypes.OTHER));

    public static final String ROLE_FIELD_NAME = ""access-level"";
    public static final List<String> ROLE_ACCEPTED_VALUES =
            Collections.unmodifiableList(
                    Arrays.asList(Const.InstructorPermissionRoleNames.INSTRUCTOR_PERMISSION_ROLE_COOWNER,
                            Const.InstructorPermissionRoleNames.INSTRUCTOR_PERMISSION_ROLE_MANAGER,
                            Const.InstructorPermissionRoleNames.INSTRUCTOR_PERMISSION_ROLE_OBSERVER,
                            Const.InstructorPermissionRoleNames.INSTRUCTOR_PERMISSION_ROLE_TUTOR,
                            Const.InstructorPermissionRoleNames.INSTRUCTOR_PERMISSION_ROLE_CUSTOM));

    public static final String GIVER_TYPE_NAME = ""feedback giver"";
    public static final String RECIPIENT_TYPE_NAME = ""feedback recipient"";
    public static final String VIEWER_TYPE_NAME = ""feedback viewer"";

    ////////////////////
    // ERROR MESSAGES //
    ////////////////////

    // possible reasons for invalidity
    public static final String REASON_EMPTY = ""is empty"";
    public static final String REASON_TOO_LONG = ""is too long"";
    public static final String REASON_INCORRECT_FORMAT = ""is not in the correct format"";
    public static final String REASON_CONTAINS_INVALID_CHAR = ""contains invalid characters"";
    public static final String REASON_START_WITH_NON_ALPHANUMERIC_CHAR = ""starts with a non-alphanumeric character"";
    public static final String REASON_UNAVAILABLE_AS_CHOICE = ""not available as a choice"";

    // error message components
    public static final String EMPTY_STRING_ERROR_INFO =
            ""The field '${fieldName}' is empty."";
    public static final String ERROR_INFO =
            ""\""${userInput}\"" is not acceptable to TEAMMATES as a/an ${fieldName} because it ${reason}."";
    public static final String HINT_FOR_CORRECT_FORMAT_FOR_SIZE_CAPPED_POSSIBLY_EMPTY =
            ""The value of a/an ${fieldName} should be no longer than ${maxLength} characters."";
    public static final String HINT_FOR_CORRECT_FORMAT_FOR_SIZE_CAPPED_NON_EMPTY =
            HINT_FOR_CORRECT_FORMAT_FOR_SIZE_CAPPED_POSSIBLY_EMPTY + "" It should not be empty."";
    public static final String HINT_FOR_CORRECT_FORMAT_FOR_SIZE_CAPPED_NON_EMPTY_NO_SPACES =
            ""It cannot be longer than ${maxLength} characters, cannot be empty and cannot contain spaces."";
    public static final String HINT_FOR_CORRECT_FORMAT_FOR_INVALID_NAME =
            ""All ${fieldName} must start with an alphanumeric character, and cannot contain any vertical bar ""
            + ""(|) or percent sign (%)."";

    // generic (i.e., not specific to any field) error messages
    public static final String SIZE_CAPPED_NON_EMPTY_STRING_ERROR_MESSAGE =
            ERROR_INFO + "" "" + HINT_FOR_CORRECT_FORMAT_FOR_SIZE_CAPPED_NON_EMPTY;
    public static final String SIZE_CAPPED_NON_EMPTY_STRING_ERROR_MESSAGE_EMPTY_STRING =
            EMPTY_STRING_ERROR_INFO + "" "" + HINT_FOR_CORRECT_FORMAT_FOR_SIZE_CAPPED_NON_EMPTY;
    public static final String SIZE_CAPPED_POSSIBLY_EMPTY_STRING_ERROR_MESSAGE =
            ERROR_INFO + "" "" + HINT_FOR_CORRECT_FORMAT_FOR_SIZE_CAPPED_POSSIBLY_EMPTY;
    public static final String INVALID_NAME_ERROR_MESSAGE =
            ERROR_INFO + "" "" + HINT_FOR_CORRECT_FORMAT_FOR_INVALID_NAME;
    public static final String WHITESPACE_ONLY_OR_EXTRA_WHITESPACE_ERROR_MESSAGE =
            ""The provided ${fieldName} is not acceptable to TEAMMATES as it contains only whitespace ""
            + ""or contains extra spaces at the beginning or at the end of the text."";
    public static final String NON_HTML_FIELD_ERROR_MESSAGE =
            SanitizationHelper.sanitizeForHtml(""The provided ${fieldName} is not acceptable to TEAMMATES ""
                                                + ""as it cannot contain the following special html characters""
                                                + "" in brackets: (< > \"" / ' &)"");
    public static final String NON_NULL_FIELD_ERROR_MESSAGE =
            ""The provided ${fieldName} is not acceptable to TEAMMATES as it cannot be empty."";

    // field-specific error messages
    public static final String HINT_FOR_CORRECT_EMAIL =
            ""An email address contains some text followed by one '@' sign followed by some more text. ""
            + HINT_FOR_CORRECT_FORMAT_FOR_SIZE_CAPPED_NON_EMPTY_NO_SPACES;
    public static final String EMAIL_ERROR_MESSAGE =
            ERROR_INFO + "" "" + HINT_FOR_CORRECT_EMAIL;
    public static final String EMAIL_ERROR_MESSAGE_EMPTY_STRING =
            EMPTY_STRING_ERROR_INFO + "" "" + HINT_FOR_CORRECT_EMAIL;

    public static final String HINT_FOR_CORRECT_COURSE_ID =
            ""A course ID can contain letters, numbers, fullstops, hyphens, underscores, and dollar signs. ""
            + HINT_FOR_CORRECT_FORMAT_FOR_SIZE_CAPPED_NON_EMPTY_NO_SPACES;
    public static final String COURSE_ID_ERROR_MESSAGE =
            ERROR_INFO + "" "" + HINT_FOR_CORRECT_COURSE_ID;
    public static final String COURSE_ID_ERROR_MESSAGE_EMPTY_STRING =
            EMPTY_STRING_ERROR_INFO + "" "" + HINT_FOR_CORRECT_COURSE_ID;

    public static final String HINT_FOR_CORRECT_FORMAT_OF_GOOGLE_ID =
            ""A Google ID must be a valid id already registered with Google. ""
            + HINT_FOR_CORRECT_FORMAT_FOR_SIZE_CAPPED_NON_EMPTY_NO_SPACES;
    public static final String GOOGLE_ID_ERROR_MESSAGE =
            ERROR_INFO + "" "" + HINT_FOR_CORRECT_FORMAT_OF_GOOGLE_ID;
    public static final String GOOGLE_ID_ERROR_MESSAGE_EMPTY_STRING =
            EMPTY_STRING_ERROR_INFO + "" "" + HINT_FOR_CORRECT_FORMAT_OF_GOOGLE_ID;

    public static final String HINT_FOR_CORRECT_COURSE_TIME_ZONE =
            ""The value must be one of the values from the time zone dropdown selector."";
    public static final String COURSE_TIME_ZONE_ERROR_MESSAGE =
            ERROR_INFO + "" "" + HINT_FOR_CORRECT_COURSE_TIME_ZONE;

    public static final String HINT_FOR_CORRECT_NATIONALITY =
            ""The value must be one of the values from the nationality dropdown selector."";
    public static final String NATIONALITY_ERROR_MESSAGE =
            ""\""%s\"" is not an accepted "" + NATIONALITY_FIELD_NAME + "" to TEAMMATES. ""
            + HINT_FOR_CORRECT_NATIONALITY;

    public static final String GENDER_ERROR_MESSAGE =
            ""\""%s\"" is not an accepted "" + GENDER_FIELD_NAME + "" to TEAMMATES. ""
            + ""Values have to be one of: "" + Const.GenderTypes.MALE + "", ""
            + Const.GenderTypes.FEMALE + "", "" + Const.GenderTypes.OTHER + ""."";

    public static final String ROLE_ERROR_MESSAGE =
            ""\""%s\"" is not an accepted "" + ROLE_FIELD_NAME + "" to TEAMMATES. "";

    public static final String SESSION_VISIBLE_TIME_FIELD_NAME = ""time when the session will be visible"";
    public static final String RESULTS_VISIBLE_TIME_FIELD_NAME = ""time when the results will be visible"";
    public static final String TIME_FRAME_ERROR_MESSAGE =
                ""The %s for this feedback session cannot be earlier than the %s."";

    public static final String PARTICIPANT_TYPE_ERROR_MESSAGE = ""%s is not a valid %s."";
    public static final String PARTICIPANT_TYPE_TEAM_ERROR_MESSAGE =
            ""The feedback recipients cannot be \""%s\"" when the feedback giver is \""%s\"". ""
            + ""Did you mean to use \""Self\"" instead?"";

    ///////////////////////////////////////
    // VALIDATION REGEX FOR INTERNAL USE //
    ///////////////////////////////////////

    /**
     * Must start with alphanumeric character, cannot contain vertical bar(|) or percent sign(%).
     */
    public static final String REGEX_NAME = ""^[\\p{IsL}\\p{IsN}][^|%]*+$"";

    /**
     * Allows English alphabet, numbers, underscore,  dot, dollar sign and hyphen.
     */
    public static final String REGEX_COURSE_ID = ""[a-zA-Z0-9_.$-]+"";

    /**
     * A normal course ID followed by the word '-demo' and then followed any amount of digits.
     */
    public static final String REGEX_SAMPLE_COURSE_ID = REGEX_COURSE_ID + ""-demo\\d*"";

    /**
     * Local part:
     * <li>Can only start with letters, digits, hyphen or plus sign;
     * <li>Special characters allowed are ! # $ % & ' * + - / = ? ^ _ ` { } ~
     * <li>Dot can only appear between any 2 characters and cannot appear continuously<br>
     * Domain part:
     * <li>Only allow letters, digits, hyphen and dot; Must end with letters
     */
    public static final String REGEX_EMAIL = ""^[\\w+-][\\w+!#$%&'*/=?^_`{}~-]*+(\\.[\\w+!#$%&'*/=?^_`{}~-]+)*+""
                                            + ""@([A-Za-z0-9-]+\\.)*[A-Za-z]+$"";

    /**
     * Allows English alphabet, numbers, underscore,  dot and hyphen.
     */
    public static final String REGEX_GOOGLE_ID_NON_EMAIL = ""[a-zA-Z0-9_.-]+"";

    /*
     * =======================================================================
     * Regex used for checking header column name in enroll lines
     */
    public static final List<String> REGEX_COLUMN_SECTION = Collections.unmodifiableList(
            Arrays.asList(
                    new String[] {""sections?"", ""sect?"", ""courses?\\s+sec(tion)?s?""}));
    public static final List<String> REGEX_COLUMN_TEAM = Collections.unmodifiableList(
            Arrays.asList(
                    new String[] {""teams?"", ""groups?"", ""students?\\s+teams?"", ""students?\\s+groups?"",
                                  ""courses?\\s+teams?""}));
    public static final List<String> REGEX_COLUMN_NAME = Collections.unmodifiableList(
            Arrays.asList(
                    new String[] {""names?"", ""students?\\s+names?"", ""full\\s+names?"", ""students?\\s+full\\s+names?""}));
    public static final List<String> REGEX_COLUMN_EMAIL = Collections.unmodifiableList(
            Arrays.asList(
                    new String[] {""emails?"", ""mails?"", ""e-mails?"", ""e\\s+mails?"", ""emails?\\s+address(es)?"",
                                  ""e-mails?\\s+address(es)?"", ""contacts?""}));
    public static final List<String> REGEX_COLUMN_COMMENT = Collections.unmodifiableList(
            Arrays.asList(
                    new String[] {""comments?"", ""notes?""}));

    /////////////////////////////////////////
    // VALIDATION METHODS FOR EXTERNAL USE //
    /////////////////////////////////////////

    /**
     * Checks if {@code emailContent} is not null and not empty.
     * @return An explanation of why the {@code emailContent} is not acceptable.
     *         Returns an empty string if the {@code emailContent} is acceptable.
     */
    public String getInvalidityInfoForEmailContent(Text emailContent) {
        Assumption.assertTrue(""Non-null value expected"", emailContent != null);
        if (emailContent.getValue().isEmpty()) {
            return EMAIL_CONTENT_ERROR_MESSAGE;
        }
        return """";
    }

    /**
     * Checks if {@code emailSubject} is a non-null non-empty string no longer than the specified length
     * {@code EMAIL_SUBJECT_MAX_LENGTH}, and also does not contain any invalid characters (| or %).
     * @return An explanation of why the {@code emailSubject} is not acceptable.
     *         Returns an empty string if the {@code emailSubject} is acceptable.
     */
    public String getInvalidityInfoForEmailSubject(String emailSubject) {
        return getValidityInfoForAllowedName(
                EMAIL_SUBJECT_FIELD_NAME, EMAIL_SUBJECT_MAX_LENGTH, emailSubject);
    }

    /**
     * Checks if {@code email} is not null, not empty, not longer than {@code EMAIL_MAX_LENGTH}, and is a
     * valid email address according to {@code REGEX_EMAIL}.
     * @return An explanation of why the {@code email} is not acceptable.
     *         Returns an empty string if the {@code email} is acceptable.
     */
    public String getInvalidityInfoForEmail(String email) {

        Assumption.assertTrue(""Non-null value expected"", email != null);
        String sanitizedValue = SanitizationHelper.sanitizeForHtml(email);

        if (email.isEmpty()) {
            return getPopulatedEmptyStringErrorMessage(EMAIL_ERROR_MESSAGE_EMPTY_STRING, EMAIL_FIELD_NAME,
                                            EMAIL_MAX_LENGTH);
        } else if (isUntrimmed(email)) {
            return WHITESPACE_ONLY_OR_EXTRA_WHITESPACE_ERROR_MESSAGE.replace(""${fieldName}"", EMAIL_FIELD_NAME);
        } else if (email.length() > EMAIL_MAX_LENGTH) {
            return getPopulatedErrorMessage(EMAIL_ERROR_MESSAGE, sanitizedValue, EMAIL_FIELD_NAME,
                                            REASON_TOO_LONG, EMAIL_MAX_LENGTH);
        } else if (!StringHelper.isMatching(email, REGEX_EMAIL)) {
            return getPopulatedErrorMessage(EMAIL_ERROR_MESSAGE, sanitizedValue, EMAIL_FIELD_NAME,
                                            REASON_INCORRECT_FORMAT, EMAIL_MAX_LENGTH);
        }
        return """";
    }

    /**
     * Checks if {@code googleId} is not null, not empty, not longer than {@code GOOGLE_ID_MAX_LENGTH}, does
     * not contain any invalid characters (| or %), AND is either a Google username (without the ""@gmail.com"")
     * or a valid email address that does not end in ""@gmail.com"".
     * @return An explanation of why the {@code googleId} is not acceptable.
     *         Returns an empty string if the {@code googleId} is acceptable.
     */
    public String getInvalidityInfoForGoogleId(String googleId) {

        Assumption.assertTrue(""Non-null value expected"", googleId != null);
        Assumption.assertTrue(""\"""" + googleId + ""\"""" + ""is not expected to be a gmail address."",
                !googleId.toLowerCase().endsWith(""@gmail.com""));
        String sanitizedValue = SanitizationHelper.sanitizeForHtml(googleId);

        boolean isValidFullEmail = StringHelper.isMatching(googleId, REGEX_EMAIL);
        boolean isValidEmailWithoutDomain = StringHelper.isMatching(googleId, REGEX_GOOGLE_ID_NON_EMAIL);

        if (googleId.isEmpty()) {
            return getPopulatedEmptyStringErrorMessage(GOOGLE_ID_ERROR_MESSAGE_EMPTY_STRING,
                                            GOOGLE_ID_FIELD_NAME, GOOGLE_ID_MAX_LENGTH);
        } else if (isUntrimmed(googleId)) {
            return WHITESPACE_ONLY_OR_EXTRA_WHITESPACE_ERROR_MESSAGE.replace(""${fieldName}"", GOOGLE_ID_FIELD_NAME);
        } else if (googleId.length() > GOOGLE_ID_MAX_LENGTH) {
            return getPopulatedErrorMessage(GOOGLE_ID_ERROR_MESSAGE, sanitizedValue, GOOGLE_ID_FIELD_NAME,
                                            REASON_TOO_LONG, GOOGLE_ID_MAX_LENGTH);
        } else if (!(isValidFullEmail || isValidEmailWithoutDomain)) {
            return getPopulatedErrorMessage(GOOGLE_ID_ERROR_MESSAGE, sanitizedValue, GOOGLE_ID_FIELD_NAME,
                                            REASON_INCORRECT_FORMAT, GOOGLE_ID_MAX_LENGTH);
        }
        return """";
    }

    /**
     * Checks if {@code courseId} is not null, not empty, has no surrounding whitespaces, not longer than
     * {@code COURSE_ID_MAX_LENGTH}, is sanitized for HTML, and match the REGEX {@code REGEX_COURSE_ID}.
     * @return An explanation of why the {@code courseId} is not acceptable.
     *         Returns an empty string if the {@code courseId} is acceptable.
     */
    public String getInvalidityInfoForCourseId(String courseId) {

        Assumption.assertTrue(""Non-null value expected"", courseId != null);

        if (courseId.isEmpty()) {
            return getPopulatedEmptyStringErrorMessage(COURSE_ID_ERROR_MESSAGE_EMPTY_STRING,
                                            COURSE_ID_FIELD_NAME, COURSE_ID_MAX_LENGTH);
        }
        if (isUntrimmed(courseId)) {
            return WHITESPACE_ONLY_OR_EXTRA_WHITESPACE_ERROR_MESSAGE.replace(""${fieldName}"",
                    COURSE_NAME_FIELD_NAME);
        }
        String sanitizedValue = SanitizationHelper.sanitizeForHtml(courseId);
        if (courseId.length() > COURSE_ID_MAX_LENGTH) {
            return getPopulatedErrorMessage(COURSE_ID_ERROR_MESSAGE, sanitizedValue, COURSE_ID_FIELD_NAME,
                                            REASON_TOO_LONG, COURSE_ID_MAX_LENGTH);
        }
        if (!StringHelper.isMatching(courseId, REGEX_COURSE_ID)) {
            return getPopulatedErrorMessage(COURSE_ID_ERROR_MESSAGE, sanitizedValue, COURSE_ID_FIELD_NAME,
                                            REASON_INCORRECT_FORMAT, COURSE_ID_MAX_LENGTH);
        }
        return """";
    }

    /**
     * Checks if {@code sectionName} is a non-null non-empty string no longer than the specified length
     * {@code SECTION_NAME_MAX_LENGTH}, and also does not contain any invalid characters (| or %).
     * @return An explanation of why the {@code sectionName} is not acceptable.
     *         Returns an empty string if the {@code sectionName} is acceptable.
     */
    public String getInvalidityInfoForSectionName(String sectionName) {
        return getValidityInfoForAllowedName(SECTION_NAME_FIELD_NAME, SECTION_NAME_MAX_LENGTH, sectionName);
    }

    /**
     * Checks if {@code teamName} is a non-null non-empty string no longer than the specified length
     * {@code TEAM_NAME_MAX_LENGTH}, and also does not contain any invalid characters (| or %).
     * @return An explanation of why the {@code teamName} is not acceptable.
     *         Returns an empty string if the {@code teamName} is acceptable.
     */
    public String getInvalidityInfoForTeamName(String teamName) {
        return getValidityInfoForAllowedName(TEAM_NAME_FIELD_NAME, TEAM_NAME_MAX_LENGTH, teamName);
    }

    /**
     * Checks if the given studentRoleComments is a non-null string no longer than
     * the specified length {@code STUDENT_ROLE_COMMENTS_MAX_LENGTH}. However, this string can be empty.
     * @return An explanation of why the {@code studentRoleComments} is not acceptable.
     *         Returns an empty string """" if the {@code studentRoleComments} is acceptable.
     */
    public String getInvalidityInfoForStudentRoleComments(String studentRoleComments) {
        return getValidityInfoForSizeCappedPossiblyEmptyString(STUDENT_ROLE_COMMENTS_FIELD_NAME,
                                                               STUDENT_ROLE_COMMENTS_MAX_LENGTH,
                                                               studentRoleComments);
    }

    /**
     * Checks if {@code gender} is one of the recognized genders {@code GENDER_ACCEPTED_VALUES}.
     * @return An explanation of why the {@code gender} is not acceptable.
     *         Returns an empty string if the {@code gender} is acceptable.
     */
    public String getInvalidityInfoForGender(String gender) {
        Assumption.assertTrue(""Non-null value expected"", gender != null);
        String sanitizedValue = SanitizationHelper.sanitizeForHtml(gender);

        if (!GENDER_ACCEPTED_VALUES.contains(gender)) {
            return String.format(GENDER_ERROR_MESSAGE, sanitizedValue);
        }
        return """";
    }

    /**
     * Checks if {@code feedbackSessionName} is a non-null non-empty string no longer than the specified length
     * {@code FEEDBACK_SESSION_NAME_MAX_LENGTH}, does not contain any invalid characters (| or %), and has no
     * unsanitized HTML characters.
     * @return An explanation of why the {@code feedbackSessionName} is not acceptable.
     *         Returns an empty string if the {@code feedbackSessionName} is acceptable.
     */
    public String getInvalidityInfoForFeedbackSessionName(String feedbackSessionName) {
        String errorsFromAllowedNameValidation = getValidityInfoForAllowedName(
                FEEDBACK_SESSION_NAME_FIELD_NAME, FEEDBACK_SESSION_NAME_MAX_LENGTH, feedbackSessionName);

        // return early if error already exists because session name is too long etc.
        if (!errorsFromAllowedNameValidation.isEmpty()) {
            return errorsFromAllowedNameValidation;
        }

        // checks for unsanitized HTML characters
        return getValidityInfoForNonHtmlField(FEEDBACK_SESSION_NAME_FIELD_NAME, feedbackSessionName);
    }

    /**
     * Checks if {@code courseName} is a non-null non-empty string no longer than the specified length
     * {@code COURSE_NAME_MAX_LENGTH}, and also does not contain any invalid characters (| or %).
     * @return An explanation of why the {@code courseName} is not acceptable.
     *         Returns an empty string if the {@code courseName} is acceptable.
     */
    public String getInvalidityInfoForCourseName(String courseName) {
        return getValidityInfoForAllowedName(COURSE_NAME_FIELD_NAME, COURSE_NAME_MAX_LENGTH, courseName);
    }

    /**
     * Checks if {@code nationality} is a non-null non-empty string contained in the {@link NationalityHelper}'s
     * list of nationalities.
     * @return An explanation of why the {@code nationality} is not acceptable.
     *         Returns an empty string if the {@code nationality} is acceptable.
     */
    public String getInvalidityInfoForNationality(String nationality) {
        Assumption.assertNotNull(""Non-null value expected"", nationality);
        if (!NationalityHelper.getNationalities().contains(nationality)) {
            return String.format(NATIONALITY_ERROR_MESSAGE, SanitizationHelper.sanitizeForHtml(nationality));
        }
        return """";
    }

    /**
     * Checks if {@code instituteName} is a non-null non-empty string no longer than the specified length
     * {@code INSTITUTE_NAME_MAX_LENGTH}, and also does not contain any invalid characters (| or %).
     * @return An explanation of why the {@code instituteName} is not acceptable.
     *         Returns an empty string if the {@code instituteName} is acceptable.
     */
    public String getInvalidityInfoForInstituteName(String instituteName) {
        return getValidityInfoForAllowedName(INSTITUTE_NAME_FIELD_NAME, INSTITUTE_NAME_MAX_LENGTH,
                                             instituteName);
    }

    /**
     * Checks if {@code personName} is a non-null non-empty string no longer than the specified length
     * {@code PERSON_NAME_MAX_LENGTH}, and also does not contain any invalid characters (| or %).
     * @return An explanation of why the {@code personName} is not acceptable.
     *         Returns an empty string if the {@code personName} is acceptable.
     */
    public String getInvalidityInfoForPersonName(String personName) {
        return getValidityInfoForAllowedName(PERSON_NAME_FIELD_NAME, PERSON_NAME_MAX_LENGTH, personName);
    }

    /**
     * Checks if the given string is a non-null string contained in {@link DateTimeZone}'s
     * list of time zone IDs.
     * @return An explanation of why the {@code timeZoneValue} is not acceptable.
     *         Returns an empty string if the {@code timeZoneValue} is acceptable.
     */
    public String getInvalidityInfoForCourseTimeZone(String timeZoneValue) {
        Assumption.assertTrue(""Non-null value expected"", timeZoneValue != null);
        if (!DateTimeZone.getAvailableIDs().contains(timeZoneValue)) {
            return getPopulatedErrorMessage(COURSE_TIME_ZONE_ERROR_MESSAGE, timeZoneValue, COURSE_TIME_ZONE_FIELD_NAME,
                                            REASON_UNAVAILABLE_AS_CHOICE);
        }
        return """";
    }

    /**
     * Checks if {@code role} is one of the recognized roles {@link #ROLE_ACCEPTED_VALUES}.
     *
     * @return An explanation of why the {@code role} is not acceptable.
     *         Returns an empty string if the {@code role} is acceptable.
     */
    public String getInvalidityInfoForRole(String role) {
        Assumption.assertTrue(""Non-null value expected"", role != null);
        String sanitizedValue = SanitizationHelper.sanitizeForHtml(role);

        if (!ROLE_ACCEPTED_VALUES.contains(role)) {
            return String.format(ROLE_ERROR_MESSAGE, sanitizedValue);
        }
        return """";
    }

    /**
     * Checks if the given name (including person name, institute name, course name, feedback session and team name)
     * is a non-null non-empty string no longer than the specified length {@code maxLength},
     * and also does not contain any invalid characters (| or %).
     *
     * @param fieldName
     *            A descriptive name of the field e.g., ""student name"", to be
     *            used in the return value to make the explanation more
     *            descriptive.
     * @param value
     *            The string to be checked.
     * @return An explanation of why the {@code value} is not acceptable.
     *         Returns an empty string """" if the {@code value} is acceptable.
     */
    public String getValidityInfoForAllowedName(String fieldName, int maxLength, String value) {

        Assumption.assertTrue(""Non-null value expected for "" + fieldName, value != null);

        if (value.isEmpty()) {
            return getPopulatedEmptyStringErrorMessage(SIZE_CAPPED_NON_EMPTY_STRING_ERROR_MESSAGE_EMPTY_STRING,
                                            fieldName, maxLength);
        }
        if (isUntrimmed(value)) {
            return WHITESPACE_ONLY_OR_EXTRA_WHITESPACE_ERROR_MESSAGE.replace(""${fieldName}"", fieldName);
        }
        String sanitizedValue = SanitizationHelper.sanitizeForHtml(value);
        if (value.length() > maxLength) {
            return getPopulatedErrorMessage(SIZE_CAPPED_NON_EMPTY_STRING_ERROR_MESSAGE, sanitizedValue,
                                            fieldName, REASON_TOO_LONG, maxLength);
        }
        if (!Character.isLetterOrDigit(value.codePointAt(0))) {
            boolean hasStartingBrace = value.charAt(0) == '{' && value.contains(""}"");
            if (!hasStartingBrace) {
                return getPopulatedErrorMessage(INVALID_NAME_ERROR_MESSAGE, sanitizedValue,
                                                fieldName, REASON_START_WITH_NON_ALPHANUMERIC_CHAR);
            }
            if (!StringHelper.isMatching(value.substring(1), REGEX_NAME)) {
                return getPopulatedErrorMessage(INVALID_NAME_ERROR_MESSAGE, sanitizedValue, fieldName,
                                                REASON_CONTAINS_INVALID_CHAR);
            }
            return """";
        }
        if (!StringHelper.isMatching(value, REGEX_NAME)) {
            return getPopulatedErrorMessage(INVALID_NAME_ERROR_MESSAGE, sanitizedValue, fieldName,
                                            REASON_CONTAINS_INVALID_CHAR);
        }
        return """";
    }

    /**
     * Checks if the given string is a non-null string no longer than
     * the specified length {@code maxLength}. However, this string can be empty.
     *
     * @param fieldName
     *            A descriptive name of the field e.g., ""student name"", to be
     *            used in the return value to make the explanation more
     *            descriptive.
     * @param value
     *            The string to be checked.
     * @return An explanation of why the {@code value} is not acceptable.
     *         Returns an empty string """" if the {@code value} is acceptable.
     */
    public String getValidityInfoForSizeCappedPossiblyEmptyString(String fieldName, int maxLength, String value) {
        Assumption.assertTrue(""Non-null value expected for "" + fieldName, value != null);

        if (isUntrimmed(value)) {
            return WHITESPACE_ONLY_OR_EXTRA_WHITESPACE_ERROR_MESSAGE.replace(""${fieldName}"", fieldName);
        }
        if (value.length() > maxLength) {
            String sanitizedValue = SanitizationHelper.sanitizeForHtml(value);
            return getPopulatedErrorMessage(SIZE_CAPPED_POSSIBLY_EMPTY_STRING_ERROR_MESSAGE, sanitizedValue,
                                            fieldName, REASON_TOO_LONG, maxLength);
        }
        return """";
    }

    /**
     * Checks if Session Start Time is before Session End Time.
     * @return Error string if {@code sessionStart} is before {@code sessionEnd}
     *         Empty string if {@code sessionStart} is after {@code sessionEnd}
     */
    public String getInvalidityInfoForTimeForSessionStartAndEnd(Date sessionStart, Date sessionEnd) {
        return getInvalidityInfoForFirstTimeIsBeforeSecondTime(
                sessionStart, sessionEnd, SESSION_START_TIME_FIELD_NAME, SESSION_END_TIME_FIELD_NAME);
    }

    /**
     * Checks if Session Visibility Start Time is before Session Start Time.
     * @return Error string if {@code visibilityStart} is before {@code sessionStart}
     *         Empty string if {@code visibilityStart} is after {@code sessionStart}
     */
    public String getInvalidityInfoForTimeForVisibilityStartAndSessionStart(Date visibilityStart,
                                                                            Date sessionStart) {
        return getInvalidityInfoForFirstTimeIsBeforeSecondTime(
                visibilityStart, sessionStart, SESSION_VISIBLE_TIME_FIELD_NAME, SESSION_START_TIME_FIELD_NAME);
    }

    /**
     * Checks if Visibility Start Time is before Results Publish Time.
     * @return Error string if {@code visibilityStart} is before {@code resultsPublish}
     *         Empty string if {@code visibilityStart} is after {@code resultsPublish}
     */
    public String getInvalidityInfoForTimeForVisibilityStartAndResultsPublish(Date visibilityStart,
                                                                              Date resultsPublish) {
        return getInvalidityInfoForFirstTimeIsBeforeSecondTime(visibilityStart, resultsPublish,
                SESSION_VISIBLE_TIME_FIELD_NAME, RESULTS_VISIBLE_TIME_FIELD_NAME);
    }

    private String getInvalidityInfoForFirstTimeIsBeforeSecondTime(
            Date earlierTime, Date laterTime, String earlierTimeFieldName, String laterTimeFieldName) {
        Assumption.assertTrue(""Non-null value expected"", earlierTime != null);
        Assumption.assertTrue(""Non-null value expected"", laterTime != null);
        if (TimeHelper.isSpecialTime(earlierTime) || TimeHelper.isSpecialTime(laterTime)) {
            return """";
        }
        if (laterTime.before(earlierTime)) {
            return String.format(TIME_FRAME_ERROR_MESSAGE, laterTimeFieldName, earlierTimeFieldName);
        }
        return """";
    }

    public List<String> getValidityInfoForFeedbackParticipantType(
            FeedbackParticipantType giverType, FeedbackParticipantType recipientType) {

        Assumption.assertNotNull(""Non-null value expected"", giverType);
        Assumption.assertNotNull(""Non-null value expected"", recipientType);

        List<String> errors = new LinkedList<>();
        if (!giverType.isValidGiver()) {
            errors.add(String.format(PARTICIPANT_TYPE_ERROR_MESSAGE, giverType.toString(), GIVER_TYPE_NAME));
        }
        if (!recipientType.isValidRecipient()) {
            errors.add(String.format(PARTICIPANT_TYPE_ERROR_MESSAGE, recipientType.toString(), RECIPIENT_TYPE_NAME));
        }
        if (giverType == FeedbackParticipantType.TEAMS
                && (recipientType == FeedbackParticipantType.OWN_TEAM
                        || recipientType == FeedbackParticipantType.OWN_TEAM_MEMBERS)) {
            errors.add(String.format(PARTICIPANT_TYPE_TEAM_ERROR_MESSAGE,
                    recipientType.toDisplayRecipientName(),
                    giverType.toDisplayGiverName()));
        }

        return errors;
    }

    public List<String> getValidityInfoForFeedbackResponseVisibility(
            List<FeedbackParticipantType> showResponsesTo,
            List<FeedbackParticipantType> showGiverNameTo,
            List<FeedbackParticipantType> showRecipientNameTo) {

        Assumption.assertNotNull(""Non-null value expected"", showResponsesTo);
        Assumption.assertNotNull(""Non-null value expected"", showGiverNameTo);
        Assumption.assertNotNull(""Non-null value expected"", showRecipientNameTo);
        Assumption.assertTrue(""Non-null value expected"", !showResponsesTo.contains(null));
        Assumption.assertTrue(""Non-null value expected"", !showGiverNameTo.contains(null));
        Assumption.assertTrue(""Non-null value expected"", !showRecipientNameTo.contains(null));

        List<String> errors = new LinkedList<>();

        for (FeedbackParticipantType type : showGiverNameTo) {
            if (!type.isValidViewer()) {
                errors.add(String.format(PARTICIPANT_TYPE_ERROR_MESSAGE,
                        type.toString(), VIEWER_TYPE_NAME));
            }
            if (!showResponsesTo.contains(type)) {
                errors.add(""Trying to show giver name to ""
                        + type.toString()
                        + "" without showing response first."");
            }
        }

        for (FeedbackParticipantType type : showRecipientNameTo) {
            if (!type.isValidViewer()) {
                errors.add(String.format(PARTICIPANT_TYPE_ERROR_MESSAGE,
                        type.toString(), VIEWER_TYPE_NAME));
            }
            if (!showResponsesTo.contains(type)) {
                errors.add(""Trying to show recipient name to ""
                        + type.toString()
                        + "" without showing response first."");
            }
        }

        for (FeedbackParticipantType type : showResponsesTo) {
            if (!type.isValidViewer()) {
                errors.add(String.format(PARTICIPANT_TYPE_ERROR_MESSAGE,
                        type.toString(), VIEWER_TYPE_NAME));
            }
        }

        return errors;
    }

    public String getValidityInfoForNonHtmlField(String fieldName, String value) {
        String sanitizedValue = SanitizationHelper.sanitizeForHtml(value);
        //Fails if sanitized value is not same as value
        return value.equals(sanitizedValue) ? """" : NON_HTML_FIELD_ERROR_MESSAGE.replace(""${fieldName}"", fieldName);
    }

    public String getValidityInfoForNonNullField(String fieldName, Object value) {
        return value == null ? NON_NULL_FIELD_ERROR_MESSAGE.replace(""${fieldName}"", fieldName) : """";
    }

    public static boolean isUntrimmed(String value) {
        return value.length() != value.trim().length();
    }

    /**
     * Checks whether a given text input represents a format of a valid email address.
     * @param email text input which needs the validation
     * @return true if it is a valid email address, else false.
     */
    public static boolean isValidEmailAddress(String email) {
        return StringHelper.isMatching(email, REGEX_EMAIL);
    }

    /**
     * Checks whether all the elements in a Collection are unique.
     * @param elements The Collection of elements to be checked.
     * @return true if all elements are unique, else false.
     */
    public static <T> boolean areElementsUnique(Collection<T> elements) {
        Set<T> uniqueElements = new HashSet<>(elements);
        return uniqueElements.size() == elements.size();
    }

    public static String getPopulatedErrorMessage(
            String messageTemplate, String userInput, String fieldName, String errorReason, int maxLength) {
        return getPopulatedErrorMessage(messageTemplate, userInput, fieldName, errorReason)
                   .replace(""${maxLength}"", String.valueOf(maxLength));
    }

    private static String getPopulatedErrorMessage(
            String messageTemplate, String userInput, String fieldName, String errorReason) {
        return messageTemplate.replace(""${userInput}"", userInput)
                              .replace(""${fieldName}"", fieldName)
                              .replace(""${reason}"", errorReason);
    }

    public static String getPopulatedEmptyStringErrorMessage(String messageTemplate,
            String fieldName, int maxLength) {
        return messageTemplate.replace(""${fieldName}"", fieldName)
                              .replace(""${maxLength}"", String.valueOf(maxLength));
    }
}
"
FileHelper.java,util,"package teammates.common.util;

import java.io.InputStream;
import java.util.Scanner;

/**
 * Holds file-related functions.
 */
public final class FileHelper {

    private FileHelper() {
        // utility class
    }

    /**
     * Reads the contents of a file in the {@code resources} folder
     * as an {@link InputStream}.
     * @param file The file name, which must be in the {@code resources} folder.
     */
    public static InputStream getResourceAsStream(String file) {
        return Config.class.getClassLoader().getResourceAsStream(file);
    }

    /**
     * Reads the contents of a file in the {@code resources} folder.
     * @param file The file name, which must be in the {@code resources} folder.
     */
    public static String readResourceFile(String file) {
        InputStream is = getResourceAsStream(file);
        Scanner scanner = new Scanner(is, Const.SystemParams.ENCODING);
        try {
            return scanner.useDelimiter(""\\Z"").next();
        } finally {
            scanner.close();
        }
    }

}
"
FrontEndLibrary.java,util,"package teammates.common.util;

import com.google.gson.JsonObject;

/**
 * Represents the directory of a client-side external library.
 */
public final class FrontEndLibrary {

    public static final String BLANKET;
    public static final String BOOTBOX;
    public static final String BOOTSTRAP_CSS;
    public static final String BOOTSTRAP_THEME_CSS;
    public static final String BOOTSTRAP;
    public static final String D3;
    public static final String DATAMAPS;
    public static final String JQUERY;
    public static final String JQUERY_GUILLOTINE;
    public static final String JQUERY_GUILLOTINE_CSS;
    public static final String JQUERY_HIGHLIGHT;
    public static final String JQUERY_PRINTTHIS;
    public static final String JQUERY_UI;
    public static final String MOMENT;
    public static final String MOMENT_TIMEZONE;
    public static final String QUNIT_CSS;
    public static final String QUNIT;
    public static final String TINYMCE;
    public static final String TOPOJSON;
    public static final String WORLDMAP;

    private static final JsonObject DEPENDENCIES_CONFIG;

    private FrontEndLibrary() {
        // utility class; not meant to be instantiated
    }

    static {

        String dependenciesConfigString = FileHelper.readResourceFile(""package.json"");
        DEPENDENCIES_CONFIG = JsonUtils.parse(dependenciesConfigString).getAsJsonObject()
                                       .get(""dependencies"").getAsJsonObject();

        BLANKET = getLibrarySource(""blanket"", ""dist/qunit/blanket.min.js"");
        BOOTBOX = getLibrarySource(""bootbox"", ""bootbox.min.js"");
        BOOTSTRAP_CSS = getLibrarySource(""bootstrap"", ""dist/css/bootstrap.min.css"");
        BOOTSTRAP_THEME_CSS = getLibrarySource(""bootstrap"", ""dist/css/bootstrap-theme.min.css"");
        BOOTSTRAP = getLibrarySource(""bootstrap"", ""dist/js/bootstrap.min.js"");
        D3 = getLibrarySource(""d3"", ""d3.min.js"");
        DATAMAPS = getLibrarySource(""datamaps"", ""dist/datamaps.none.min.js"");
        JQUERY = getLibrarySource(""jquery"", ""dist/jquery.min.js"");
        JQUERY_GUILLOTINE = getLibrarySource(""guillotine"", ""js/jquery.guillotine.min.js"");
        JQUERY_GUILLOTINE_CSS = getLibrarySource(""guillotine"", ""css/jquery.guillotine.css"");
        JQUERY_HIGHLIGHT = getLibrarySource(""jquery-highlight"", ""jquery.highlight.js"");
        JQUERY_PRINTTHIS = getLibrarySource(""printthis"", ""printThis.js"");
        JQUERY_UI = getLibrarySource(""jquery-ui-dist"", ""jquery-ui.min.js"");
        MOMENT = getLibrarySource(""moment"", ""min/moment.min.js"");
        MOMENT_TIMEZONE = getLibrarySource(""moment-timezone"", ""builds/moment-timezone-with-data-2010-2020.min.js"");
        QUNIT_CSS = getLibrarySource(""qunitjs"", ""qunit/qunit.css"");
        QUNIT = getLibrarySource(""qunitjs"", ""qunit/qunit.js"");
        TINYMCE = getLibrarySource(""tinymce"", ""tinymce.min.js"");
        TOPOJSON = getLibrarySource(""topojson"", ""build/topojson.min.js"");
        WORLDMAP = getLibrarySource(""datamaps"", ""src/js/data/world.hires.topo.json"");
    }

    private static String getLibrarySource(String libraryNameInNpm, String fileDir) {
        return ""https://unpkg.com/"" + libraryNameInNpm + ""@""
                + DEPENDENCIES_CONFIG.get(libraryNameInNpm).getAsString() + ""/"" + fileDir;
    }

}
"
GaeLogApi.java,util,"package teammates.common.util;

import java.util.LinkedList;
import java.util.List;

import com.google.appengine.api.log.AppLogLine;
import com.google.appengine.api.log.LogServiceFactory;
import com.google.appengine.api.log.RequestLogs;

/**
 * An utility to fetch logs from GAE server.
 */
public class GaeLogApi {
    /**
     * Retrieves logs using the query.
     * @return logs fetched from server.
     */
    public List<AppLogLine> fetchLogs(AdminLogQuery query) {
        List<AppLogLine> logs = new LinkedList<>();
        //fetch request log
        Iterable<RequestLogs> records = LogServiceFactory.getLogService().fetch(query.getQuery());
        for (RequestLogs record : records) {
            //fetch application log
            List<AppLogLine> appLogLines = record.getAppLogLines();
            logs.addAll(appLogLines);
        }
        return logs;
    }
}
"
GaeVersionApi.java,util,"package teammates.common.util;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import com.google.appengine.api.modules.ModulesService;
import com.google.appengine.api.modules.ModulesServiceFactory;

/**
 * Provides access to application versions via Google AppEngine API.
 */
public class GaeVersionApi {

    private static final Logger log = Logger.getLogger();

    /**
     * Gets all available versions.
     */
    public List<Version> getAvailableVersions() {
        ModulesService modulesService = ModulesServiceFactory.getModulesService();
        List<String> versionListInString = new ArrayList<>(modulesService.getVersions(null)); // null == default module
        List<Version> versionList = new ArrayList<>();
        for (String versionInString : versionListInString) {
            versionList.add(new Version(versionInString));
        }
        Collections.sort(versionList);
        return versionList;
    }

    /**
     * Gets the current version of the application.
     */
    public Version getCurrentVersion() {
        ModulesService modulesService = ModulesServiceFactory.getModulesService();
        return new Version(modulesService.getCurrentVersion());
    }

    /**
     * Gets a number of most recent versions.
     * @return a list of versions.
     */
    public List<String> getMostRecentVersions(int numVersions) {
        List<Version> versionList = getAvailableVersions();
        Version currentVersion = getCurrentVersion();

        List<String> resultVersions = new ArrayList<>();
        try {
            int currentVersionIndex = versionList.indexOf(currentVersion);
            resultVersions = getSublistOfVersionList(versionList, currentVersionIndex, numVersions);
        } catch (Exception e) {
            resultVersions.add(currentVersion.toStringWithDashes());
            log.severe(e.getMessage());
        }
        return resultVersions;
    }

    /**
     * Finds a sublist of versionList, starting from startIndex and at most `maxAmount` elements.
     * @param startIndex starting position to get versions
     */
    private List<String> getSublistOfVersionList(List<Version> versionList, int startIndex, int maxAmount) {
        int endIndex = Math.min(startIndex + maxAmount, versionList.size());
        List<Version> versionSubList = versionList.subList(startIndex, endIndex);
        List<String> versionListInString = new ArrayList<>();
        for (Version version : versionSubList) {
            versionListInString.add(version.toStringWithDashes());
        }
        return versionListInString;
    }
}
"
GoogleCloudStorageHelper.java,util,"package teammates.common.util;

import java.io.IOException;
import java.io.InputStream;
import java.nio.ByteBuffer;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.List;

import com.google.appengine.api.blobstore.BlobInfoFactory;
import com.google.appengine.api.blobstore.BlobKey;
import com.google.appengine.api.blobstore.BlobstoreInputStream;
import com.google.appengine.api.blobstore.BlobstoreServiceFactory;
import com.google.appengine.api.blobstore.UploadOptions;
import com.google.appengine.tools.cloudstorage.GcsFileOptions;
import com.google.appengine.tools.cloudstorage.GcsFilename;
import com.google.appengine.tools.cloudstorage.GcsOutputChannel;
import com.google.appengine.tools.cloudstorage.GcsServiceFactory;
import com.google.appengine.tools.cloudstorage.RetryParams;

/**
 * Holds functions for operations related to Google Cloud Storage.
 */
public final class GoogleCloudStorageHelper {

    private static final int MAX_READING_LENGTH = 900000;
    private static final Logger log = Logger.getLogger();

    private GoogleCloudStorageHelper() {
        // utility class
    }

    /**
     * Returns true if a file with the specified {@link BlobKey} exists in the
     *         Google Cloud Storage.
     */
    public static boolean doesFileExistInGcs(BlobKey fileKey) {
        try {
            BlobstoreServiceFactory.getBlobstoreService().fetchData(fileKey, 0, 1);
            return true;
        } catch (IllegalArgumentException e) {
            return false;
        }
    }

    /**
     * Deletes the file with the specified {@link BlobKey} in the Google Cloud Storage.
     */
    public static void deleteFile(BlobKey fileKey) {
        try {
            BlobstoreServiceFactory.getBlobstoreService().delete(fileKey);
        } catch (Exception e) {
            log.warning(""Trying to delete non-existent file with key: "" + fileKey.getKeyString());
        }
    }

    /**
     * Writes a byte array {@code imageData} as image to the Google Cloud Storage,
     * with the {@code googleId} as the identifier name for the image.
     * @return the {@link BlobKey} used as the image's identifier in Google Cloud Storage
     */
    public static String writeImageDataToGcs(String googleId, byte[] imageData) throws IOException {
        GcsFilename gcsFilename = new GcsFilename(Config.GCS_BUCKETNAME, googleId);
        GcsOutputChannel outputChannel =
                GcsServiceFactory.createGcsService(RetryParams.getDefaultInstance())
                                 .createOrReplace(gcsFilename,
                                                  new GcsFileOptions.Builder().mimeType(""image/png"").build());

        outputChannel.write(ByteBuffer.wrap(imageData));
        outputChannel.close();

        return BlobstoreServiceFactory.getBlobstoreService()
                .createGsBlobKey(""/gs/"" + Config.GCS_BUCKETNAME + ""/"" + googleId).getKeyString();
    }

    /**
     * Creates and invokes a URL for uploading a large blob to Google Cloud Storage.
     * Upon completion of the upload, a callback is made to the specified {@code callbackUrl}.<br>
     * Refer to {@link com.google.appengine.api.blobstore.BlobstoreService#createUploadUrl}.
     */
    public static String getNewUploadUrl(String callbackUrl) {
        UploadOptions uploadOptions =
                UploadOptions.Builder.withDefaults()
                             .googleStorageBucketName(Config.GCS_BUCKETNAME)
                             .maxUploadSizeBytes(Const.SystemParams.MAX_FILE_LIMIT_FOR_BLOBSTOREAPI);

        return BlobstoreServiceFactory.getBlobstoreService()
                                      .createUploadUrl(callbackUrl, uploadOptions);
    }

    /**
     * Gets the file with the specified {@link BlobKey} in the Google Cloud Storage,
     * parses it and returns it as a list of list.<br>
     * Assumption: the file represented by {@code blobKey} is a valid txt file
     *             that can be parsed into a comma-separated list
     */
    public static List<List<String>> getGroupReceiverList(BlobKey blobKey) throws IOException {
        Assumption.assertNotNull(blobKey);

        // It turns out that error will occur if we read more than around 900000 bytes of data per time
        // from the blobstream, which also brings problems when this large number of emails are all stored in one
        // list. As a result, to prevent unexpected errors, we read the txt file several times and each time
        // at most 900000 bytes are read, after which a new list is created to store all the emails addresses that
        // happen to be in the newly read bytes.

        // For email address which happens to be broken according to two consecutive reading, a check will be done
        // before storing all emails separated from the second reading into a new list.
        // Broken email will be fixed by deleting the first item of the email list from current reading
        // AND appending it to the last item of the email list from last reading.

        // The email list from each reading is inserted into an upper list (list of list).
        // The structure is as below:

        // ListOfList:
        //       ListFromReading_1 :
        //                     [example@email.com]
        //                            ...
        //       ListFromReading_2 :
        //                     [example@email.com]
        //                            ...

        // This is the list of list
        List<List<String>> listOfList = new LinkedList<>();

        // Offset is needed for remembering where it stops from last reading
        int offset = 0;

        // File size is needed to track the number of unread bytes
        int size = (int) getFileSize(blobKey);

        while (size > 0) {
            // Make sure not to over-read
            int bytesToRead = Math.min(size, MAX_READING_LENGTH);
            InputStream blobStream = new BlobstoreInputStream(blobKey, offset);
            byte[] array = new byte[bytesToRead];

            blobStream.read(array);

            // Remember where it stops reading
            offset += MAX_READING_LENGTH;
            // Decrease unread bytes
            size -= MAX_READING_LENGTH;

            // Get the read bytes into string and split it by "",""
            String readString = new String(array);
            List<String> newList = Arrays.asList(readString.split("",""));

            if (listOfList.isEmpty()) {
                // This is the first time reading
                listOfList.add(newList);
            } else {
                // Check if the last reading stopped in the middle of a email address string
                List<String> lastAddedList = listOfList.get(listOfList.size() - 1);
                // Get the last item of the list from last reading
                String lastStringOfLastAddedList = lastAddedList.get(lastAddedList.size() - 1);
                // Get the first item of the list from current reading
                String firstStringOfNewList = newList.get(0);

                if (lastStringOfLastAddedList.contains(""@"") && firstStringOfNewList.contains(""@"")) {
                    // No broken email from last reading found, simply add the list
                    // from current reading into the upper list.
                    listOfList.add(newList);
                } else {
                    // Either the left part or the right part of the broken email string does not contains a ""@"".
                    // Simply append the right part to the left part (last item of the list from last reading).
                    listOfList.get(listOfList.size() - 1)
                              .set(lastAddedList.size() - 1, lastStringOfLastAddedList + firstStringOfNewList);

                    // And also needs to delete the right part which is the first item of the list from current reading
                    listOfList.add(newList.subList(1, newList.size() - 1));
                }
            }

            blobStream.close();
        }

        return listOfList;
    }

    private static long getFileSize(BlobKey blobKey) {
        BlobInfoFactory blobInfoFactory = new BlobInfoFactory();
        return blobInfoFactory.loadBlobInfo(blobKey).getSize();
    }

}
"
HttpRequestHelper.java,util,"package teammates.common.util;

import java.util.Enumeration;
import java.util.Map;

import javax.servlet.http.Cookie;
import javax.servlet.http.HttpServletRequest;

public final class HttpRequestHelper {

    private HttpRequestHelper() {
        // utility class
    }

    /**
     * Returns the first value for the key in the parameter map, or null if key not found.
     *
     * @param paramMap A parameter map (e.g., the kind found in HttpServletRequests)
     */
    public static String getValueFromParamMap(Map<String, String[]> paramMap, String key) {
        String[] values = paramMap.get(key);
        return values == null ? null : values[0];
    }

    /**
     * Returns all values for the key in the parameter map, or null if key not found.
     *
     * @param paramMap A parameter map (e.g., the kind found in HttpServletRequests)
     */
    public static String[] getValuesFromParamMap(Map<String, String[]> paramMap, String key) {
        String[] values = paramMap.get(key);
        return values == null ? null : values;
    }

    /**
     * Returns the first value for the key in the request's parameter map, or null if key not found.
     *
     * @param req An HttpServletRequest which contains the parameters map
     */
    @SuppressWarnings(""unchecked"")
    public static String getValueFromRequestParameterMap(HttpServletRequest req, String key) {
        return getValueFromParamMap(req.getParameterMap(), key);
    }

    /**
     * Returns all values for the key in the request's parameter map, or null if key not found.
     *
     * @param req An HttpServletRequest which contains the parameters map
     */
    @SuppressWarnings(""unchecked"")
    public static String[] getValuesFromRequestParameterMap(HttpServletRequest req, String key) {
        return getValuesFromParamMap(req.getParameterMap(), key);
    }

    /**
     * Gets the parameter map from HttpServletRequest.
     */
    @SuppressWarnings(""unchecked"")
    public static Map<String, String[]> getParameterMap(HttpServletRequest req) {
        return (Map<String, String[]>) req.getParameterMap();
    }

    //TODO: rename to a better name
    public static String printRequestParameters(HttpServletRequest request) {
        StringBuilder requestParameters = new StringBuilder();
        requestParameters.append('{');
        for (Enumeration<?> f = request.getParameterNames(); f.hasMoreElements();) {
            String param = f.nextElement().toString();
            requestParameters.append(param).append(""::"");
            String[] parameterValues = request.getParameterValues(param);
            for (String parameterValue : parameterValues) {
                requestParameters.append(parameterValue).append(""//"");
            }
            requestParameters.setLength(requestParameters.length() - 2);
            requestParameters.append("", "");
        }
        if (!""{"".equals(requestParameters.toString())) {
            requestParameters.setLength(requestParameters.length() - 2);
        }
        return requestParameters.append(""}"").toString();
    }

    /**
     * Returns the URL used for the HTTP request but without the domain, e.g. ""/page/studentHome?user=james""
     */
    public static String getRequestedUrl(HttpServletRequest req) {
        String link = req.getRequestURI();
        String query = req.getQueryString();

        if (query != null && !query.trim().isEmpty()) {
            return link + ""?"" + query;
        }
        return link;
    }

    /**
     * Returns the cookie value, or null if said cookie does not exist.
     */
    public static String getCookieValueFromRequest(HttpServletRequest req, String cookieName) {
        Cookie[] existingCookies = req.getCookies();

        if (existingCookies == null) {
            return null;
        }

        for (Cookie cookie : existingCookies) {
            if (cookie.getName().equals(cookieName)) {
                return cookie.getValue();
            }
        }

        return null;
    }

}
"
JsonUtils.java,util,"package teammates.common.util;

import java.lang.reflect.Type;
import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonParser;
import com.google.gson.JsonPrimitive;
import com.google.gson.JsonSerializationContext;
import com.google.gson.JsonSerializer;
import com.google.gson.JsonSyntaxException;

/**
 * Provides means to handle, manipulate, and convert JSON objects to/from strings.
 */
public final class JsonUtils {

    private JsonUtils() {
        // utility class
    }

    /**
     * This creates a Gson object that can handle the Date format we use in the
     * Json file and also reformat the Json string in pretty-print format.
     */
    private static Gson getTeammatesGson() {
        return new GsonBuilder().registerTypeAdapter(Date.class, new TeammatesDateAdapter())
                                .setPrettyPrinting()
                                .disableHtmlEscaping()
                                .create();
    }

    /**
     * Serializes the specified object into its equivalent JSON string.
     *
     * @see Gson#toJson(Object, Type)
     */
    public static String toJson(Object src, Type typeOfSrc) {
        return getTeammatesGson().toJson(src, typeOfSrc);
    }

    /**
     * Serializes the specified object into its equivalent JSON string.
     *
     * @see Gson#toJson(Object)
     */
    public static String toJson(Object src) {
        return getTeammatesGson().toJson(src);
    }

    /**
     * Deserializes the specified JSON string into an object of the specified type.
     *
     * @see Gson#fromJson(String, Type)
     */
    public static <T> T fromJson(String json, Type typeOfT) {
        try {
            return getTeammatesGson().fromJson(json, typeOfT);
        } catch (JsonSyntaxException e) {
            // some of the existing data does not use the prescribed date format
            return new Gson().fromJson(json, typeOfT);
        }
    }

    /**
     * Parses the specified JSON string into a {@link JsonElement} object.
     *
     * @see JsonParser#parse(String)
     */
    public static JsonElement parse(String json) {
        JsonParser parser = new JsonParser();
        return parser.parse(json);
    }

    /**
     * Ensures that JSON date output is in the standard time zone.
     * This workaround is necessary as the default GSON date serializer always uses the local time zone,
     * leading to unpredictable JSON output that depends on the system time zone.
     */
    private static class TeammatesDateAdapter implements JsonSerializer<Date>, JsonDeserializer<Date> {

        private final DateFormat dateFormat;

        TeammatesDateAdapter() {
            dateFormat = new SimpleDateFormat(Const.SystemParams.DEFAULT_DATE_TIME_FORMAT);
            dateFormat.setTimeZone(Const.SystemParams.TIME_ZONE);
        }

        @Override
        public synchronized JsonElement serialize(Date date, Type type, JsonSerializationContext context) {
            return new JsonPrimitive(dateFormat.format(date));
        }

        @Override
        public synchronized Date deserialize(JsonElement element, Type type, JsonDeserializationContext context) {
            try {
                return dateFormat.parse(element.getAsString());
            } catch (ParseException e) {
                throw new JsonSyntaxException(element.getAsString(), e);
            }
        }
    }

}
"
Logger.java,util,"package teammates.common.util;

/**
 * Allows any component of the application to log messages at appropriate levels.
 */
public final class Logger {

    private java.util.logging.Logger log;

    private Logger() {
        StackTraceElement logRequester = Thread.currentThread().getStackTrace()[2];
        this.log = java.util.logging.Logger.getLogger(logRequester.getClassName());
    }

    public static Logger getLogger() {
        return new Logger();
    }

    /**
     * Logs a message at FINE level.
     *
     * @see java.util.logging.Logger#fine(String)
     */
    public void fine(String msg) {
        log.fine(msg);
    }

    /**
     * Logs a message at INFO level.
     *
     * @see java.util.logging.Logger#info(String)
     */
    public void info(String msg) {
        log.info(msg);
    }

    /**
     * Logs a message at WARNING level.
     *
     * @see java.util.logging.Logger#warning(String)
     */
    public void warning(String msg) {
        log.warning(msg);
    }

    /**
     * Logs a message at SEVERE level.
     *
     * @see java.util.logging.Logger#severe(String)
     */
    public void severe(String msg) {
        log.severe(msg);
    }

}
"
LogMessageGenerator.java,util,"package teammates.common.util;

import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Map;
import java.util.TimeZone;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import teammates.common.datatransfer.UserType;
import teammates.common.datatransfer.attributes.AccountAttributes;
import teammates.common.datatransfer.attributes.StudentAttributes;
import teammates.common.exception.TeammatesException;
import teammates.common.util.ActivityLogEntry.Builder;

/**
 * Factory to generate log messages.
 */
public class LogMessageGenerator {
    public static final Pattern PATTERN_ACTION_NAME = Pattern.compile(""^/\\S+?/(?<actionName>[^\\s\\?]*)"");
    public static final String PATTERN_ACTION_NAME_GROUP = ""actionName"";

    /**
     * Generates the log message for an *Action.
     *
     * @param url URL of the action
     * @param params parameterMap of the request
     * @param currUser login information generated by {@link teammates.logic.api.GateKeeper}
     * @param userAccount authentication user account generated by action
     * @param unregisteredStudent authentication unregisteredStudent attributes generated by action
     * @param logMessage log message to show to admin
     * @return log message in the form specified in {@link ActivityLogEntry}
     */
    public String generatePageActionLogMessage(String url, Map<String, String[]> params, UserType currUser,
            AccountAttributes userAccount, StudentAttributes unregisteredStudent, String logMessage) {
        Builder builder = generateBasicLogEntryBuilder(url, params, currUser);

        boolean isUnregisteredStudent = unregisteredStudent != null;
        boolean isAccountWithGoogleId = userAccount != null && userAccount.googleId != null;
        if (isUnregisteredStudent) {
            updateInfoForUnregisteredStudent(builder, unregisteredStudent);
        } else if (isAccountWithGoogleId) {
            updateInfoForNormalUser(builder, currUser, userAccount);
        }

        builder.withLogMessage(logMessage);
        return builder.build().generateLogMessage();
    }

    private void updateInfoForUnregisteredStudent(Builder builder, StudentAttributes unregisteredStudent) {
        String role = Const.ActivityLog.ROLE_UNREGISTERED;
        if (unregisteredStudent.course != null && !unregisteredStudent.course.isEmpty()) {
            role = Const.ActivityLog.ROLE_UNREGISTERED + "":"" + unregisteredStudent.course;
        }
        builder.withUserRole(role)
               .withUserName(unregisteredStudent.name)
               .withUserEmail(unregisteredStudent.email);
    }

    private void updateInfoForNormalUser(Builder builder, UserType currUser, AccountAttributes userAccount) {
        checkAndUpdateForMasqueradeMode(builder, currUser, userAccount);
        builder.withUserGoogleId(userAccount.googleId)
               .withUserEmail(userAccount.email)
               .withUserName(userAccount.name);
    }

    private void checkAndUpdateForMasqueradeMode(Builder builder, UserType loggedInUser, AccountAttributes account) {
        if (loggedInUser != null && loggedInUser.id != null && account != null) {
            boolean isMasqueradeMode = !loggedInUser.id.equals(account.googleId);
            builder.withMasqueradeUserRole(isMasqueradeMode);
        }
    }

    /**
     * Generates log message for servlet action failure.
     *
     * @param url URL of the request
     * @param params parameterMap of the request
     * @param e Exception thrown in the failure
     * @param currUser login information generated by {@link teammates.logic.api.GateKeeper}
     * @return log message in the form specified in {@link ActivityLogEntry}
     */
    public String generateActionFailureLogMessage(String url, Map<String, String[]> params,
            Exception e, UserType currUser) {
        Builder builder = generateBasicLogEntryBuilder(url, params, currUser);

        String message = ""<span class=\""text-danger\"">Servlet Action failure in ""
                         + builder.getActionName() + ""<br>""
                         + e.getClass() + "": "" + TeammatesException.toStringWithStackTrace(e) + ""<br>""
                         + JsonUtils.toJson(params, Map.class) + ""</span>"";
        builder.withLogMessage(message);

        builder.withActionResponse(Const.ACTION_RESULT_FAILURE);

        return builder.build().generateLogMessage();
    }

    /**
     * Generates log message with basic information.
     *
     * @param url URL of the request
     * @param params parameterMap of the request
     * @param message log message to show to admin
     * @param currUser login information generated by {@link teammates.logic.api.GateKeeper}
     * @return log message in form specified in {@link ActivityLogEntry}
     */
    public String generateBasicActivityLogMessage(String url, Map<String, String[]> params, String message,
            UserType currUser) {
        Builder builder = generateBasicLogEntryBuilder(url, params, currUser);

        builder.withLogMessage(message);

        return builder.build().generateLogMessage();
    }

    /**
     * Generates a basic builder for activityLogEntry.
     *
     * @param url URL of the request
     * @param params parameterMap of the request
     * @param currUser login information generated by {@link teammates.logic.api.GateKeeper}
     * @return Builder builder with basic information
     */
    private Builder generateBasicLogEntryBuilder(String url, Map<String, String[]> params, UserType currUser) {
        String actionName = getActionNameFromUrl(url);
        long currTime = System.currentTimeMillis();
        Builder builder = new Builder(actionName, url, currTime);

        if (isAutomatedAction(url)) {
            builder.withLogId(generateLogIdForAutomatedAction(currTime))
                    .withUserRole(Const.ActivityLog.ROLE_AUTO);
        } else if (currUser == null) {
            builder.withLogId(generateLogIdWithoutGoogleId(params, currTime))
                    .withUserGoogleId(Const.ActivityLog.AUTH_NOT_LOGIN);
        } else {
            builder.withLogId(generateLogIdWithGoogleId(currUser.id, currTime))
                    .withUserGoogleId(currUser.id);
            updateRoleForLoggedInUser(builder, currUser);
        }

        return builder;
    }

    private void updateRoleForLoggedInUser(Builder builder, UserType currUser) {
        if (currUser.isAdmin) {
            builder.withUserRole(Const.ActivityLog.ROLE_ADMIN);
            downgradeRoleToStudentIfNecessary(builder);
            downgradeRoleToInstructorIfNecessary(builder);
        } else if (currUser.isInstructor && currUser.isStudent) {
            builder.withUserRole(Const.ActivityLog.ROLE_INSTRUCTOR);
            downgradeRoleToStudentIfNecessary(builder);
        } else if (currUser.isStudent) {
            builder.withUserRole(Const.ActivityLog.ROLE_STUDENT);
        } else if (currUser.isInstructor) {
            builder.withUserRole(Const.ActivityLog.ROLE_INSTRUCTOR);
        } else {
            builder.withUserRole(Const.ActivityLog.ROLE_UNREGISTERED);
        }
    }

    private void downgradeRoleToStudentIfNecessary(Builder builder) {
        if (isStudentPage(builder.getActionName())) {
            builder.withUserRole(Const.ActivityLog.ROLE_STUDENT);
        }
    }

    private void downgradeRoleToInstructorIfNecessary(Builder builder) {
        if (isInstructorPage(builder.getActionName())) {
            builder.withUserRole(Const.ActivityLog.ROLE_INSTRUCTOR);
        }
    }

    private boolean isInstructorPage(String actionName) {
        return actionName.toLowerCase().startsWith(Const.ActivityLog.PREFIX_INSTRUCTOR_PAGE)
                || Const.ActionURIs.INSTRUCTOR_FEEDBACK_STATS_PAGE.contains(actionName)
                || Const.ActionURIs.INSTRUCTOR_COURSE_STATS_PAGE.contains(actionName);
    }

    private boolean isStudentPage(String actionName) {
        return actionName.toLowerCase().startsWith(Const.ActivityLog.PREFIX_STUDENT_PAGE);
    }

    private boolean isAutomatedAction(String actionName) {
        return actionName.startsWith(Const.ActivityLog.PREFIX_AUTO_PAGE);
    }

    private String getActionNameFromUrl(String requestUrl) {
        Matcher m = PATTERN_ACTION_NAME.matcher(requestUrl);
        return m.find() ? m.group(PATTERN_ACTION_NAME_GROUP)
                        : String.format(Const.ActivityLog.MESSAGE_ERROR_ACTION_NAME, requestUrl);
    }

    private String generateLogIdForAutomatedAction(long time) {
        return StringHelper.join(Const.ActivityLog.FIELD_CONNECTOR,
                Const.ActivityLog.ROLE_AUTO, formatTimeForId(new Date(time)));
    }

    private String generateLogIdWithoutGoogleId(Map<String, String[]> params, long time) {
        String courseId = HttpRequestHelper.getValueFromParamMap(params, Const.ParamsNames.COURSE_ID);
        String studentEmail = HttpRequestHelper.getValueFromParamMap(params, Const.ParamsNames.STUDENT_EMAIL);
        if (courseId != null && studentEmail != null) {
            return StringHelper.join(Const.ActivityLog.FIELD_CONNECTOR,
                    studentEmail, courseId, formatTimeForId(new Date(time)));
        }
        return StringHelper.join(Const.ActivityLog.FIELD_CONNECTOR,
                Const.ActivityLog.AUTH_NOT_LOGIN, formatTimeForId(new Date(time)));
    }

    private String generateLogIdWithGoogleId(String googleId, long time) {
        return StringHelper.join(Const.ActivityLog.FIELD_CONNECTOR, googleId, formatTimeForId(new Date(time)));
    }

    private String formatTimeForId(Date date) {
        SimpleDateFormat sdf = new SimpleDateFormat(Const.ActivityLog.TIME_FORMAT_LOGID);
        sdf.setTimeZone(TimeZone.getTimeZone(Const.SystemParams.ADMIN_TIME_ZONE));
        return sdf.format(date.getTime());
    }
}
"
NationalityHelper.java,util,"package teammates.common.util;

import java.util.Arrays;
import java.util.List;

/**
 * This is a helper class to hold nationality-related functions.
 */
public final class NationalityHelper {

    /**
     * This list of nationalities was created for the dropdown list and contains
     * 198 nationalities and an 'Other' option.
     * reference : ""https://mytaskhelper.com/forums/5-faq-s/topics/98-nationality-dropdown-list""
     */
    private static final String[] NATIONALITIES = {
            ""Afghan"",
            ""Albanian"",
            ""Algerian"",
            ""American"",
            ""Andorran"",
            ""Angolan"",
            ""Antiguans"",
            ""Argentinean"",
            ""Armenian"",
            ""Australian"",
            ""Austrian"",
            ""Azerbaijani"",
            ""Bahamian"",
            ""Bahraini"",
            ""Bangladeshi"",
            ""Barbadian"",
            ""Barbudans"",
            ""Batswana"",
            ""Belarusian"",
            ""Belgian"",
            ""Belizean"",
            ""Beninese"",
            ""Bhutanese"",
            ""Bolivian"",
            ""Bosnian"",
            ""Brazilian"",
            ""British"",
            ""Bruneian"",
            ""Bulgarian"",
            ""Burkinabe"",
            ""Burmese"",
            ""Burundian"",
            ""Cambodian"",
            ""Cameroonian"",
            ""Canadian"",
            ""Cape Verdean"",
            ""Central African"",
            ""Chadian"",
            ""Chilean"",
            ""Chinese"",
            ""Colombian"",
            ""Comoran"",
            ""Congolese"",
            ""Congolese"",
            ""Costa Rican"",
            ""Croatian"",
            ""Cuban"",
            ""Cypriot"",
            ""Czech"",
            ""Danish"",
            ""Djibouti"",
            ""Dominican"",
            ""Dutch"",
            ""Dutchman"",
            ""Dutchwoman"",
            ""East Timorese"",
            ""Ecuadorean"",
            ""Egyptian"",
            ""Emirian"",
            ""Equatorial Guinean"",
            ""Eritrean"",
            ""Estonian"",
            ""Ethiopian"",
            ""Fijian"",
            ""Filipino"",
            ""Finnish"",
            ""French"",
            ""Gabonese"",
            ""Gambian"",
            ""Georgian"",
            ""German"",
            ""Ghanaian"",
            ""Greek"",
            ""Grenadian"",
            ""Guatemalan"",
            ""Guinea-Bissauan"",
            ""Guinean"",
            ""Guyanese"",
            ""Haitian"",
            ""Herzegovinian"",
            ""Honduran"",
            ""Hungarian"",
            ""I-Kiribati"",
            ""Icelander"",
            ""Indian"",
            ""Indonesian"",
            ""Iranian"",
            ""Iraqi"",
            ""Irish"",
            ""Irish"",
            ""Israeli"",
            ""Italian"",
            ""Ivorian"",
            ""Jamaican"",
            ""Japanese"",
            ""Jordanian"",
            ""Kazakhstani"",
            ""Kenyan"",
            ""Kittian and Nevisian"",
            ""Kuwaiti"",
            ""Kyrgyz"",
            ""Laotian"",
            ""Latvian"",
            ""Lebanese"",
            ""Liberian"",
            ""Libyan"",
            ""Liechtensteiner"",
            ""Lithuanian"",
            ""Luxembourger"",
            ""Macedonian"",
            ""Malagasy"",
            ""Malawian"",
            ""Malaysian"",
            ""Maldivan"",
            ""Malian"",
            ""Maltese"",
            ""Marshallese"",
            ""Mauritanian"",
            ""Mauritian"",
            ""Mexican"",
            ""Micronesian"",
            ""Moldovan"",
            ""Monacan"",
            ""Mongolian"",
            ""Moroccan"",
            ""Mosotho"",
            ""Motswana"",
            ""Mozambican"",
            ""Namibian"",
            ""Nauruan"",
            ""Nepalese"",
            ""Netherlander"",
            ""New Zealander"",
            ""Ni-Vanuatu"",
            ""Nicaraguan"",
            ""Nigerian"",
            ""Nigerien"",
            ""North Korean"",
            ""Northern Irish"",
            ""Norwegian"",
            ""Omani"",
            ""Pakistani"",
            ""Palauan"",
            ""Panamanian"",
            ""Papua New Guinean"",
            ""Paraguayan"",
            ""Peruvian"",
            ""Polish"",
            ""Portuguese"",
            ""Qatari"",
            ""Romanian"",
            ""Russian"",
            ""Rwandan"",
            ""Saint Lucian"",
            ""Salvadoran"",
            ""Samoan"",
            ""San Marinese"",
            ""Sao Tomean"",
            ""Saudi"",
            ""Scottish"",
            ""Senegalese"",
            ""Serbian"",
            ""Seychellois"",
            ""Sierra Leonean"",
            ""Singaporean"",
            ""Slovakian"",
            ""Solomon Islander"",
            ""Somali"",
            ""South African"",
            ""South Korean"",
            ""Spanish"",
            ""Sri Lankan"",
            ""Sudanese"",
            ""Surinamer"",
            ""Swazi"",
            ""Swedish"",
            ""Swiss"",
            ""Syrian"",
            ""Taiwanese"",
            ""Tajik"",
            ""Tanzanian"",
            ""Thai"",
            ""Togolese"",
            ""Tongan"",
            ""Tobagonian"",
            ""Tunisian"",
            ""Turkish"",
            ""Tuvaluan"",
            ""Ugandan"",
            ""Ukrainian"",
            ""Uruguayan"",
            ""Uzbekistani"",
            ""Venezuelan"",
            ""Vietnamese"",
            ""Welsh"",
            ""Yemenite"",
            ""Zambian"",
            ""Zimbabwean"",
            ""Other""
    };

    /**
     * This prevents instantiation. This is necessary because this is a utility class.
     */
    private NationalityHelper() {
    }

    /**
     * Returns with the nationalities list.
     */
    public static List<String> getNationalities() {
        return Arrays.asList(NATIONALITIES);
    }

}
"
package-info.java,util,"/**
 * Contains utility classes and helpers to be used by all components of the application.
 */
package teammates.common.util;
"
MaximumRetriesExceededException.java,util,"package teammates.common.util.retry;

@SuppressWarnings(""serial"")
public class MaximumRetriesExceededException extends Exception {

    /**
     * An optional final message updated by the task before its final failure.
     */
    public String finalMessage;

    /**
     * An optional final data object updated by the task before its final failure.
     */
    public Object finalData;

    public MaximumRetriesExceededException(Retryable task) {
        this(task, null);
    }

    public MaximumRetriesExceededException(Retryable task, Throwable cause) {
        super(task.getName() + "" failed after maximum retries"", cause);
        finalMessage = task.finalMessage;
        finalData = task.finalData;
    }
}
"
package-info.java,util,"/**
 * Contains infrastructure and helpers needed for retrying arbitrary code.
 */
package teammates.common.util.retry;
"
Retryable.java,util,"package teammates.common.util.retry;

/**
 * Represents a task that can be retried.
 * @param <T> Result type.
 * @param <E> Throwable type for signalling that the task should not be retried.
 */
public abstract class Retryable<T, E extends Throwable> {

    protected String name;

    /**
     * An optional final message to show in the {@link MaximumRetriesExceededException} thrown
     * should the task fail after maximum retries.
     */
    protected String finalMessage;

    /**
     * An optional final object to embed in the {@link MaximumRetriesExceededException} thrown
     * should the task fail after maximum retries.
     */
    protected Object finalData;

    public Retryable(String name) {
        this.name = name;
    }

    /**
     * Executes a method that runs the task once and returns the result.
     */
    protected abstract T runExec() throws E;

    /**
     * Executes a method that checks whether the task succeeded.
     */
    protected abstract boolean isSuccessfulExec() throws E;

    /**
     * Performs additional steps required before each retry of the task.
     */
    @SuppressWarnings(""PMD.EmptyMethodInAbstractClassShouldBeAbstract"")
    public void beforeRetry() throws E {
        // Does nothing by default so that it can be skipped entirely in anonymous classes when not used.
    }

    /**
     * Returns the name of the task.
     */
    public String getName() {
        return name;
    }
}
"
RetryableTask.java,util,"package teammates.common.util.retry;

/**
 * Convenience subclass of {link RetryableTaskThrows} for when checked exceptions are not thrown.
 */
public abstract class RetryableTask extends RetryableTaskThrows<RuntimeException> {
    public RetryableTask(String name) {
        super(name);
    }
}
"
RetryableTaskReturns.java,util,"package teammates.common.util.retry;

/**
 * Convenience subclass of {link RetryableTaskReturnsThrows} for when checked exceptions are not thrown.
 * @param <T> Result type.
 */
public abstract class RetryableTaskReturns<T> extends RetryableTaskReturnsThrows<T, RuntimeException> {
    public RetryableTaskReturns(String name) {
        super(name);
    }
}
"
RetryableTaskReturnsThrows.java,util,"package teammates.common.util.retry;

/**
 * Abstract implementation of a {@link Retryable} task that returns a result, for easy extending through anonymous classes.
 * @param <T> Result type.
 * @param <E> Throwable type for signalling that the task should not be retried.
 */
public abstract class RetryableTaskReturnsThrows<T, E extends Throwable> extends Retryable<T, E> {

    private T result;

    public RetryableTaskReturnsThrows(String name) {
        super(name);
    }

    /**
     * Runs the task once and returns the result.
     */
    public abstract T run() throws E;

    @Override
    protected final T runExec() throws E {
        result = run();
        return result;
    }

    /**
     * Checks whether the task succeeded.
     */
    public boolean isSuccessful(T result) throws E {
        return true;
    }

    protected final T getResult() {
        return result;
    }

    /**
     * Checks whether the result is null.
     */
    public final boolean isResultNull() {
        return result == null;
    }

    @Override
    protected final boolean isSuccessfulExec() throws E {
        return isSuccessful(result);
    }
}
"
RetryableTaskThrows.java,util,"package teammates.common.util.retry;

/**
 * Abstract implementation of a {@link Retryable} task, for easy extending through anonymous classes.
 * @param <E> Throwable type for signalling that the task should not be retried.
 */
public abstract class RetryableTaskThrows<E extends Throwable> extends Retryable<Void, E> {

    public RetryableTaskThrows(String name) {
        super(name);
    }

    /**
     * Runs the task once.
     */
    public abstract void run() throws E;

    @Override
    protected final Void runExec() throws E {
        run();
        return null;
    }

    /**
     * Checks whether the task succeeded.
     */
    public boolean isSuccessful() throws E {
        return true;
    }

    @Override
    protected final boolean isSuccessfulExec() throws E {
        return isSuccessful();
    }
}
"
RetryManager.java,util,"package teammates.common.util.retry;

import teammates.common.util.Assumption;
import teammates.common.util.Logger;
import teammates.common.util.ThreadHelper;

/**
 * Handles running and retrying of {@link Retryable} tasks.
 * Generally, the methods retry tasks with exponential backoff until one of the following conditions is met:
 * <ul>
 *     <li>Task is successful (see specific method documentation for definition of success).</li>
 *     <li>Maximum retries are exceeded (as determined by the specified maximum delay).</li>
 *     <li>A {@link Throwable} of type specified in the task is encountered (this is thrown upwards).</li>
 * </ul>
 */
public final class RetryManager {

    private static final Logger log = Logger.getLogger();

    private final int maxDelayInS;

    /**
     * Creates a new {@link RetryManager} that contains methods to retry tasks.
     *
     * @param maxDelayInS maximum delay (in seconds) to wait before final retry.
     */
    public RetryManager(int maxDelayInS) {
        this.maxDelayInS = maxDelayInS;
    }

    private enum SuccessCondition {
        /**
         * The task's {@code isSuccessfulExec()} method must return true for the task to be considered successful.
         */
        DEFAULT {
            @Override
            public <T, E extends Throwable> boolean isSuccessful(Retryable<T, E> task) throws E {
                return task.isSuccessfulExec();
            }
        },

        /**
         * The task's {@code isResultNull()} method must return false for the task to be considered successful.
         * Only applicable if the task is an instance of {@link RetryableTaskReturnsThrows}.
         */
        NOT_NULL {
            @Override
            public <T, E extends Throwable> boolean isSuccessful(Retryable<T, E> task) throws E {
                Assumption.assertTrue(""Success condition "" + NOT_NULL + "" is only applicable to subclasses of ""
                        + RetryableTaskReturnsThrows.class.getSimpleName(),
                        RetryableTaskReturnsThrows.class.isInstance(task));

                return !((RetryableTaskReturnsThrows<T, E>) task).isResultNull();
            }
        };

        /**
         * Checks whether the {@code task} ran successfully based based on the {@code SuccessCondition}.
         */
        public abstract <T, E extends Throwable> boolean isSuccessful(Retryable<T, E> task) throws E;
    }

    /**
     * Runs {@code task}, retrying if needed using exponential backoff, until task is successful.
     *
     * @returns {@code task} result or null if none.
     * @throws E if encountered while running or evaluating {@code task}.
     * @throws MaximumRetriesExceededException if maximum retries are exceeded.
     */
    public <T, E extends Throwable> T runUntilSuccessful(Retryable<T, E> task) throws E, MaximumRetriesExceededException {
        return doRetry(task, SuccessCondition.DEFAULT);
    }

    /**
     * Runs {@code task}, retrying if needed using exponential backoff, until task returns a non-null result.
     *
     * @returns {@code task} result or null if none.
     * @throws E if encountered while running or evaluating {@code task}.
     * @throws MaximumRetriesExceededException if maximum retries are exceeded.
     */
    public <T, E extends Throwable> T runUntilNotNull(RetryableTaskReturnsThrows<T, E> task)
            throws E, MaximumRetriesExceededException {
        return doRetry(task, SuccessCondition.NOT_NULL);
    }

    /**
     * Runs {@code task}, retrying if needed using exponential backoff, until no exceptions of the specified
     * {@code recognizedExceptionTypes} are caught.
     *
     * @returns {@code task} result or null if none.
     * @throws E if encountered while running or evaluating {@code task}.
     * @throws MaximumRetriesExceededException if maximum retries are exceeded.
     */
    @SafeVarargs
    public final <T, E extends Throwable> T runUntilNoRecognizedException(
            Retryable<T, E> task, Class<? extends Throwable>... recognizedExceptionTypes)
            throws E, MaximumRetriesExceededException {
        return doRetry(task, recognizedExceptionTypes);
    }

    private <T, E extends Throwable> T doRetry(Retryable<T, E> task, SuccessCondition condition)
            throws E, MaximumRetriesExceededException {
        T result = task.runExec();
        for (int delay = 1; !condition.isSuccessful(task) && delay <= maxDelayInS; delay *= 2) {
            logFailure(task, delay);
            ThreadHelper.waitFor(delay * 1000);
            task.beforeRetry();
            result = task.runExec();
        }
        if (!condition.isSuccessful(task)) {
            throw new MaximumRetriesExceededException(task);
        }
        return result;
    }

    @SafeVarargs
    @SuppressWarnings(""PMD.AvoidCatchingThrowable"") // allow users to catch specific errors e.g. AssertionError
    private final <T, E extends Throwable> T doRetry(
            Retryable<T, E> task, Class<? extends Throwable>... recognizedExceptionTypes)
            throws E, MaximumRetriesExceededException {
        for (int delay = 1; delay <= maxDelayInS; delay *= 2) {
            try {
                return task.runExec();
            } catch (Throwable e) {
                if (!isThrowableTypeIn(e, recognizedExceptionTypes)) {
                    throw e;
                }
                // continue retry process
            }
            logFailure(task, delay);
            ThreadHelper.waitFor(delay * 1000);
            task.beforeRetry();
        }
        try {
            return task.runExec();
        } catch (Throwable e) {
            if (!isThrowableTypeIn(e, recognizedExceptionTypes)) {
                throw e;
            }
            throw new MaximumRetriesExceededException(task, e);
        }
    }

    @SafeVarargs
    private static boolean isThrowableTypeIn(Throwable e, Class<? extends Throwable>... recognizedExceptionTypes) {
        for (Class recognizedExceptionType : recognizedExceptionTypes) {
            if (recognizedExceptionType.isInstance(e)) {
                return true;
            }
        }
        return false;
    }

    private static <T, E extends Throwable> void logFailure(Retryable<T, E> task, int delay) {
        log.info(task.getName() + "" failed; waiting "" + delay + ""s before retry"");
    }
}
"
SanitizationHelper.java,util,"package teammates.common.util;

import java.io.UnsupportedEncodingException;
import java.net.URLEncoder;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Set;
import java.util.TreeSet;

import org.owasp.html.HtmlPolicyBuilder;
import org.owasp.html.PolicyFactory;

import com.google.appengine.api.datastore.Text;

/**
 * Class contains methods to sanitize user provided
 * parameters so that they conform to our data format
 * and possible threats can be removed first
 * as well as methods to revert sanitized text
 * back to its previous unsanitized state.
 */
public final class SanitizationHelper {

    private static PolicyFactory richTextPolicy =
            new HtmlPolicyBuilder()
                .allowStandardUrlProtocols()
                .allowAttributes(""title"").globally()
                .allowAttributes(""href"").onElements(""a"")
                .allowAttributes(""src"").onElements(""img"")
                .allowAttributes(""align"")
                    .matching(true, ""center"", ""left"", ""right"", ""justify"", ""char"")
                    .onElements(""p"")
                .allowAttributes(""colspan"", ""rowspan"").onElements(""td"", ""th"")
                .allowAttributes(""cellspacing"").onElements(""table"")
                .allowElements(
                    ""a"", ""p"", ""div"", ""i"", ""b"", ""em"", ""blockquote"", ""tt"", ""strong"", ""hr"",
                    ""br"", ""ul"", ""ol"", ""li"", ""h1"", ""h2"", ""h3"", ""h4"", ""h5"", ""h6"", ""img"", ""span"",
                    ""table"", ""tr"", ""td"", ""th"", ""tbody"", ""tfoot"", ""thead"", ""caption"", ""colgroup"",
                    ""sup"", ""sub"", ""code"")
                .allowElements(""quote"", ""ecode"")
                .allowStyling()
                .toFactory();
    private static final Logger log = Logger.getLogger();

    private SanitizationHelper() {
        // utility class
    }

    /**
     * Sanitizes a google ID by removing leading/trailing whitespace
     * and the trailing ""@gmail.com"".
     *
     * @return the sanitized google ID or null (if the parameter was null).
     */
    public static String sanitizeGoogleId(String rawGoogleId) {
        if (rawGoogleId == null) {
            return null;
        }

        String sanitized = rawGoogleId.trim();
        if (sanitized.toLowerCase().endsWith(""@gmail.com"")) {
            sanitized = sanitized.split(""@"")[0];
        }
        return sanitized.trim();
    }

    /**
     * Sanitizes an email address by removing leading/trailing whitespace.
     *
     * @return the sanitized email address or null (if the parameter was null).
     */
    public static String sanitizeEmail(String rawEmail) {
        return StringHelper.trimIfNotNull(rawEmail);
    }

    /**
     * Sanitizes name by removing leading, trailing, and duplicate internal whitespace.
     *
     * @return the sanitized name or null (if the parameter was null).
     */
    public static String sanitizeName(String rawName) {
        return StringHelper.removeExtraSpace(rawName);
    }

    /**
     * Sanitizes title by removing leading, trailing, and duplicate internal whitespace.
     *
     * @return the sanitized title or null (if the parameter was null).
     */
    public static String sanitizeTitle(String rawTitle) {
        return StringHelper.removeExtraSpace(rawTitle);
    }

    /**
     * Sanitizes a user input text field by removing leading/trailing whitespace.
     * i.e. comments, instructions, etc.
     *
     * @return the sanitized text or null (if the parameter was null).
     */
    public static String sanitizeTextField(String rawText) {
        return StringHelper.trimIfNotNull(rawText);
    }

    /**
     * Escape the string for inserting into javascript code.
     * This automatically calls {@link #sanitizeForHtml} so make it safe for HTML too.
     *
     * @return the sanitized string or null (if the parameter was null).
     */
    public static String sanitizeForJs(String str) {
        if (str == null) {
            return null;
        }
        return SanitizationHelper.sanitizeForHtml(
                str.replace(""\\"", ""\\\\"")
                .replace(""\"""", ""\\\"""")
                .replace(""'"", ""\\'"")
                .replace(""#"", ""\\#""));
    }

    /**
     * Sanitizes the string with rich-text.
     * Removes disallowed elements based on defined policy.
     */
    public static String sanitizeForRichText(String content) {
        if (content == null) {
            return null;
        }
        return richTextPolicy.sanitize(sanitizeTextField(content));
    }

    /**
     * Sanitizes the {@link Text} with rich-text.
     * Removes disallowed elements based on defined policy.
     * @return A new sanitized {@link Text} or null if the input was null.
     */
    public static Text sanitizeForRichText(Text text) {
        if (text == null || text.getValue() == null) {
            return null;
        }
        return new Text(sanitizeForRichText(text.getValue()));
    }

    /**
     * Sanitizes the string for inserting into HTML. Converts special characters
     * into HTML-safe equivalents.
     */
    public static String sanitizeForHtml(String unsanitizedString) {
        if (unsanitizedString == null) {
            return null;
        }
        return unsanitizedString.replace(""<"", ""&lt;"")
                .replace("">"", ""&gt;"")
                .replace(""\"""", ""&quot;"")
                .replace(""/"", ""&#x2f;"")
                .replace(""'"", ""&#39;"")
                //To ensure when apply sanitizeForHtml for multiple times, the string's still fine
                //Regex meaning: replace '&' with safe encoding, but not the one that is safe already
                .replaceAll(""&(?!(amp;)|(lt;)|(gt;)|(quot;)|(#x2f;)|(#39;))"", ""&amp;"");
    }

    /**
     * Sanitizes a list of strings for inserting into HTML.
     */
    public static List<String> sanitizeForHtml(List<String> list) {
        List<String> sanitizedList = new ArrayList<>();
        for (String str : list) {
            sanitizedList.add(sanitizeForHtml(str));
        }
        return sanitizedList;
    }

    /**
     * Sanitizes a set of strings for inserting into HTML.
     */
    public static Set<String> sanitizeForHtml(Set<String> set) {
        Set<String> sanitizedSet = new TreeSet<>();
        for (String str : set) {
            sanitizedSet.add(sanitizeForHtml(str));
        }
        return sanitizedSet;
    }

    /**
     * Recovers a html-sanitized string using {@link #sanitizeForHtml}
     * to original encoding for appropriate display in files such as csv file.<br>
     * It restores encoding for < > \ / ' &  <br>
     * The method should only be used once on sanitized html
     *
     * @return recovered string
     */
    public static String desanitizeFromHtml(String sanitizedString) {

        if (sanitizedString == null) {
            return null;
        }

        return sanitizedString.replace(""&lt;"", ""<"")
                              .replace(""&gt;"", "">"")
                              .replace(""&quot;"", ""\"""")
                              .replace(""&#x2f;"", ""/"")
                              .replace(""&#39;"", ""'"")
                              .replace(""&amp;"", ""&"");
    }

    /**
     * This recovers a set of html-sanitized string using {@link #sanitizeForHtml}
     * to original encoding for appropriate display in files such as csv file.<br>
     * It restores encoding for < > \ / ' &  <br>
     * The method should only be used once on sanitized html
     *
     * @return recovered string set
     */
    public static Set<String> desanitizeFromHtml(Set<String> sanitizedStringSet) {
        Set<String> textSetTemp = new HashSet<>();
        for (String text : sanitizedStringSet) {
            textSetTemp.add(desanitizeFromHtml(text));
        }
        return textSetTemp;
    }

    /**
     * Escapes HTML tag safely. This function can be applied multiple times.
     */
    public static String sanitizeForHtmlTag(String string) {
        if (string == null) {
            return null;
        }
        return string.replace(""<"", ""&lt;"").replace("">"", ""&gt;"");
    }

    /**
     * Converts a string to be put in URL (replaces some characters).
     */
    public static String sanitizeForUri(String uri) {
        try {
            return URLEncoder.encode(uri, Const.SystemParams.ENCODING);
        } catch (UnsupportedEncodingException wontHappen) {
            log.warning(""Unexpected UnsupportedEncodingException in ""
                        + ""SanitizationHelper.sanitizeForUri("" + uri + "", "" + Const.SystemParams.ENCODING + "")"");
            return uri;
        }
    }

    /**
     * Sanitizes the given URL for the parameter {@link Const.ParamsNames#NEXT_URL}.
     * The following characters will be sanitized:
     * <ul>
     * <li>&, to prevent the parameters of the next URL from being considered as
     *     part of the original URL</li>
     * <li>%2B (encoded +), to prevent Google from decoding it back to +,
     *     which is used to encode whitespace in some cases</li>
     * <li>%23 (encoded #), to prevent Google from decoding it back to #,
     *     which is used to traverse the HTML document to a certain id</li>
     * </ul>
     *
     * @return the sanitized url or null (if the parameter was null).
     */
    public static String sanitizeForNextUrl(String url) {
        if (url == null) {
            return null;
        }
        return url.replace(""&"", ""${amp}"").replace(""%2B"", ""${plus}"").replace(""%23"", ""${hash}"");
    }

    /**
     * Recovers the URL from sanitization due to {@link SanitizationHelper#sanitizeForNextUrl}.
     * In addition, any un-encoded whitespace (they may be there due to Google's
     * behind-the-screen decoding process) will be encoded again to +.
     * @return the unsanitized url or null (if the parameter was null).
     */
    public static String desanitizeFromNextUrl(String sanitizedUrl) {
        if (sanitizedUrl == null) {
            return null;
        }
        return sanitizedUrl.replace(""${amp}"", ""&"")
                           .replace(""${plus}"", ""%2B"")
                           .replace(""${hash}"", ""%23"")
                           .replace("" "", ""+"");
    }

    /**
     * Sanitize the string for searching.
     */
    public static String sanitizeForSearch(String str) {
        if (str == null) {
            return null;
        }
        return str
                //general case for punctuation
                .replace(""`"", "" "").replace(""!"", "" "").replace(""#"", "" "").replace(""$"", "" "").replace(""%"", "" "").replace(""^"", "" "")
                .replace(""&"", "" "").replace(""["", "" "").replace(""]"", "" "").replace(""{"", "" "").replace(""}"", "" "").replace(""|"", "" "")
                .replace("";"", "" "").replace(""*"", "" "").replace(""."", "" "").replace(""?"", "" "").replace(""'"", "" "").replace(""/"", "" "")
                //to prevent injection
                .replace(""="", "" "")
                .replace("":"", "" "")
                .replace(""<"", ""&lt;"")
                .replace("">"", ""&gt;"");
    }

    /**
     * Sanitizes the string for comma-separated values (CSV) file output.<br>
     * We follow the definition described by RFC 4180.
     *
     * @see <a href=""http://tools.ietf.org/html/rfc4180"">http://tools.ietf.org/html/rfc4180</a>
     */
    public static String sanitizeForCsv(String str) {
        return ""\"""" + str.replace(""\"""", ""\""\"""") + ""\"""";
    }

    /**
     * Sanitizes the list of strings for comma-separated values (CSV) file output.<br>
     * We follow the definition described by RFC 4180.
     *
     * @see <a href=""http://tools.ietf.org/html/rfc4180"">http://tools.ietf.org/html/rfc4180</a>
     */
    public static List<String> sanitizeListForCsv(List<String> strList) {
        List<String> sanitizedStrList = new ArrayList<>();

        Iterator<String> itr = strList.iterator();
        while (itr.hasNext()) {
            sanitizedStrList.add(sanitizeForCsv(itr.next()));
        }

        return sanitizedStrList;
    }

    /**
     * Convert the string to a safer version for XPath
     * For example:
     * Will o' The Wisp => concat('Will o' , ""'"" , ' The Wisp' , '')
     * This will result in the same string when read by XPath.
     *
     * <p>This is used when writing the test case for some special characters
     * such as ' and ""
     *
     * @return safer version of the text for XPath
     */
    public static String sanitizeStringForXPath(String text) {
        StringBuilder result = new StringBuilder();
        int startOfChain = 0;
        int textLength = text.length();
        boolean isSingleQuotationChain = false;
        // currentPos iterates one position beyond text length to include last chain
        for (int currentPos = 0; currentPos <= textLength; currentPos++) {
            boolean isChainBroken = currentPos >= textLength
                                    || isSingleQuotationChain && text.charAt(currentPos) != '\''
                                    || !isSingleQuotationChain && text.charAt(currentPos) == '\'';
            if (isChainBroken && startOfChain < currentPos) {
                // format text.substring(startOfChain, currentPos) and append to result
                char wrapper = isSingleQuotationChain ? '\""' : '\'';
                result.append(wrapper).append(text.substring(startOfChain, currentPos)).append(wrapper).append(',');
                startOfChain = currentPos;
            }
            // flip isSingleQuotationChain if chain is broken
            if (isChainBroken) {
                isSingleQuotationChain = !isSingleQuotationChain;
            }
        }
        if (result.length() == 0) {
            return ""''"";
        }
        return ""concat("" + result.toString() + ""'')"";
    }

    /**
     * Returns true if the {@code string} has evidence of having been sanitized.
     * A string is considered sanitized if it does not contain any of the chars '<', '>', '/', '\""', '\'',
     * and contains at least one of their sanitized equivalents or the sanitized equivalent of '&'.
     *
     * <p>Eg. ""No special characters"", ""{@code <p>&quot;with quotes&quot;</p>}"" are considered to be not sanitized.<br>
     *     ""{@code &lt;p&gt; a p tag &lt;&#x2f;p&gt;}"" is considered to be sanitized.
     * </p>
     */
    public static boolean isSanitizedHtml(String string) {
        return string != null
                && !StringHelper.isTextContainingAny(string, ""<"", "">"", ""\"""", ""/"", ""\'"")
                && StringHelper.isTextContainingAny(string, ""&lt;"", ""&gt;"", ""&quot;"", ""&#x2f;"", ""&#39;"", ""&amp;"");
    }

    /**
     * Returns the desanitized {@code string} if it is sanitized, otherwise returns the unchanged string.
     */
    public static String desanitizeIfHtmlSanitized(String string) {
        return isSanitizedHtml(string) ? desanitizeFromHtml(string) : string;
    }
}
"
StatusMessage.java,util,"package teammates.common.util;

import java.io.Serializable;

/**
 * The {@code StatusMessage} class encapsulates the text of status message
 * and its level of seriousness of the status message (the color of the message).
 */
@SuppressWarnings(""serial"")
public class StatusMessage implements Serializable {
    private String text;
    private StatusMessageColor color;

    public StatusMessage(String text, StatusMessageColor color) {
        this.text = text;
        this.color = color;
    }

    public String getText() {
        return text;
    }

    public String getColor() {
        return color.name().toLowerCase();
    }
}
"
StatusMessageColor.java,util,"package teammates.common.util;

/**
 * Represents the level of seriousness (""color"") of a status message.
 */
public enum StatusMessageColor {
    INFO, SUCCESS, WARNING, DANGER
}
"
StringHelper.java,util,"package teammates.common.util;

import java.text.DecimalFormat;
import java.util.ArrayList;
import java.util.List;
import java.util.Set;
import java.util.TreeSet;
import java.util.regex.Pattern;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.spec.SecretKeySpec;

import teammates.common.exception.InvalidParametersException;

/**
 * Holds String-related helper functions.
 */

public final class StringHelper {
    private static final Logger log = Logger.getLogger();

    private StringHelper() {
        // utility class
    }

    /**
     * Checks whether the input string is empty or equals {@code null}.
     * @param s The string to be checked
     */
    public static boolean isEmpty(String s) {
        return s == null || s.isEmpty();
    }

    public static String generateStringOfLength(int length, char character) {
        Assumption.assertTrue(length >= 0);
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < length; i++) {
            sb.append(character);
        }
        return sb.toString();
    }

    public static boolean isWhiteSpace(String string) {
        return string.trim().isEmpty();
    }

    /**
     * Checks whether the input string matches the regex.
     * @param input The string to be matched
     * @param regex The regex  used for the matching
     */
    public static boolean isMatching(String input, String regex) {
        // Important to use the CANON_EQ flag to make sure that canonical characters
        // such as  is correctly matched regardless of single/double code point encoding
        return Pattern.compile(regex, Pattern.CANON_EQ).matcher(input).matches();
    }

    /**
     * Checks whether any substring of the input string matches any of the group of given regex expressions.
     * @param input The string to be matched
     * @param regexList The regex list used for the matching
     */
    public static boolean isAnyMatching(String input, List<String> regexList) {
        for (String regex : regexList) {
            if (isMatching(input.trim().toLowerCase(), regex)) {
                return true;
            }
        }
        return false;
    }

    public static String getIndent(int length) {
        return generateStringOfLength(length, ' ');
    }

    /**
     * Checks whether the {@code inputString} is longer than a specified length
     * if so returns the truncated name appended by ellipsis,
     * otherwise returns the original input. <br>
     * E.g., ""12345678"" truncated to length 6 returns ""123...""
     */
    public static String truncate(String inputString, int truncateLength) {
        if (inputString.length() <= truncateLength) {
            return inputString;
        }
        String result = inputString;
        if (inputString.length() > truncateLength) {
            result = inputString.substring(0, truncateLength - 3) + ""..."";
        }
        return result;
    }

    /**
     * Trims head of the String if it is longer than specified Length.
     *  E.g., String ""12345678"" with maximumStringLength = 6, returns ""345678""
     * @param maximumStringLength - maximum required length of the string
     * @return String with at most maximumStringLength length
     */
    public static String truncateHead(String inputString, final int maximumStringLength) {
        final int inputStringLength = inputString.length();
        if (inputStringLength <= maximumStringLength) {
            return inputString;
        }
        return inputString.substring(inputStringLength - maximumStringLength);
    }

    /**
     * Checks whether the {@code longId} is longer than the length specified
     * in {@link Const.SystemParams},
     * if so returns the truncated longId appended by ellipsis,
     * otherwise returns the original longId.
     */
    public static String truncateLongId(String longId) {
        return truncate(longId, Const.SystemParams.USER_ID_MAX_DISPLAY_LENGTH);
    }

    /**
     * Substitutes the middle third of the given string with dots
     * and returns the ""obscured"" string.
     */
    public static String obscure(String inputString) {
        Assumption.assertNotNull(inputString);
        String frontPart = inputString.substring(0, inputString.length() / 3);
        String endPart = inputString.substring(2 * inputString.length() / 3);
        return frontPart + "".."" + endPart;
    }

    public static String encrypt(String value) {
        try {
            SecretKeySpec sks = new SecretKeySpec(hexStringToByteArray(Config.ENCRYPTION_KEY), ""AES"");
            Cipher cipher = Cipher.getInstance(""AES/ECB/PKCS5Padding"");
            cipher.init(Cipher.ENCRYPT_MODE, sks, cipher.getParameters());
            byte[] encrypted = cipher.doFinal(value.getBytes());
            return byteArrayToHexString(encrypted);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    /*
     * Decrypts the supplied string.
     *
     * @param message the ciphertext as a hexadecimal string
     * @return the plaintext
     * @throws InvalidParameterException if the ciphertext is invalid.
     * @throws RuntimeException if the decryption fails for any other reason, such as {@code Cipher} initialization failure.
     */
    public static String decrypt(String message) throws InvalidParametersException {
        try {
            SecretKeySpec sks = new SecretKeySpec(hexStringToByteArray(Config.ENCRYPTION_KEY), ""AES"");
            Cipher cipher = Cipher.getInstance(""AES/ECB/PKCS5Padding"");
            cipher.init(Cipher.DECRYPT_MODE, sks);
            byte[] decrypted = cipher.doFinal(hexStringToByteArray(message));
            return new String(decrypted);
        } catch (NumberFormatException | IllegalBlockSizeException | BadPaddingException e) {
            log.warning(""Attempted to decrypt invalid ciphertext: "" + message);
            throw new InvalidParametersException(e);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    /**
     * Converts and concatenates a list of objects to a single string, separated by line breaks.
     * The conversion is done by using the {@link Object#toString()} method.
     * @return Concatenated string.
     */
    public static <T> String toString(List<T> list) {
        return toString(list, Const.EOL);
    }

    /**
     * Converts and concatenates a list of objects to a single string, separated by the given delimiter.
     * The conversion is done by using the {@link Object#toString()} method.
     * @return Concatenated string.
     */
    public static <T> String toString(List<T> list, String delimiter) {
        if (list.isEmpty()) {
            return """";
        }

        StringBuilder returnValue = new StringBuilder();
        for (int i = 0; i < list.size() - 1; i++) {
            returnValue.append(list.get(i)).append(delimiter);
        }
        //append the last item
        returnValue.append(list.get(list.size() - 1));

        return returnValue.toString();
    }

    public static String toDecimalFormatString(double doubleVal) {
        DecimalFormat df = new DecimalFormat(""0.###"");
        return df.format(doubleVal);
    }

    public static String toUtcFormat(double hourOffsetTimeZone) {
        String utcFormatTimeZone = ""UTC"";
        if (hourOffsetTimeZone == 0) {
            return utcFormatTimeZone;
        }

        if ((int) hourOffsetTimeZone == hourOffsetTimeZone) {
            return utcFormatTimeZone + String.format("" %+03d:00"", (int) hourOffsetTimeZone);
        }

        return utcFormatTimeZone + String.format(
                                    "" %+03d:%02d"",
                                    (int) hourOffsetTimeZone,
                                    (int) (Math.abs(hourOffsetTimeZone - (int) hourOffsetTimeZone) * 300 / 5));
    }

    /**
     * split a full name string into first and last names
     * <br>
     * 1.If passed in empty string, both last and first name will be empty string
     * <br>
     * 2.If single word, this will be last name and first name will be an empty string
     * <br>
     * 3.If more than two words, the last word will be last name and
     * the rest will be first name.
     * <br>
     * 4.If the last name is enclosed with braces ""{}"" such as first {Last1 Last2},
     * the last name will be the String inside the braces
     * <br>
     * Example:
     * <br><br>
     * full name ""Danny Tim Lin""<br>
     * first name: ""Danny Tim"" <br>
     * last name: ""Lin"" <br>
     * processed full name: ""Danny Tim Lin"" <br>
     * <br>
     * full name ""Danny {Tim Lin}""<br>
     * first name: ""Danny"" <br>
     * last name: ""Tim Lin"" <br>
     * processed full name: ""Danny Tim Lin"" <br>
     *
     *
     * @return split name array{0--> first name, 1--> last name, 2--> processed full name by removing ""{}""}
     */

    public static String[] splitName(String fullName) {

        if (fullName == null) {
            return new String[] {};
        }

        String lastName;
        String firstName;

        if (fullName.contains(""{"") && fullName.contains(""}"")) {
            int startIndex = fullName.indexOf('{');
            int endIndex = fullName.indexOf('}');
            lastName = fullName.substring(startIndex + 1, endIndex);
            firstName = fullName.replace(""{"", """")
                                .replace(""}"", """")
                                .replace(lastName, """")
                                .trim();

        } else {
            lastName = fullName.substring(fullName.lastIndexOf(' ') + 1).trim();
            firstName = fullName.replace(lastName, """").trim();
        }

        String processedfullName = fullName.replace(""{"", """")
                                           .replace(""}"", """");

        return new String[] {firstName, lastName, processedfullName};
    }

    /**
     * Trims the string and reduces consecutive white spaces to only one space.
     * Example: "" a   a  "" --> ""a a"".
     * @return processed string, returns null if parameter is null
     */
    public static String removeExtraSpace(String str) {
        if (str == null) {
            return null;
        }
        return str.trim().replaceAll(""\\s+"", "" "");
    }

    /**
     * Trims all strings in the set and reduces consecutive white spaces to only one space.
     */
    public static Set<String> removeExtraSpace(Set<String> strSet) {
        if (strSet == null) {
            return null;
        }
        Set<String> result = new TreeSet<>();
        for (String s : strSet) {
            result.add(removeExtraSpace(s));
        }
        return result;
    }

    /**
     * Replaces every character in {@code str} that does not match
     * {@code regex} with the character {@code replacement}.
     *
     * @param str String to be replaced.
     * @param regex Pattern that every character is to be matched against.
     * @param replacement Character unmatching characters should be replaced with.
     * @return String with all unmatching characters replaced; null if input is null.
     */
    public static String replaceIllegalChars(String str, String regex, char replacement) {
        if (str == null) {
            return null;
        }

        char[] charArray = str.toCharArray();

        for (int i = 0; i < charArray.length; i++) {
            if (!isMatching(Character.toString(charArray[i]), regex)) {
                charArray[i] = replacement;
            }
        }

        return String.valueOf(charArray);
    }

    public static String byteArrayToHexString(byte[] bytes) {
        StringBuilder sb = new StringBuilder(bytes.length * 2);
        for (byte b : bytes) {
            int v = b & 0xff;
            if (v < 16) {
                sb.append('0');
            }
            sb.append(Integer.toHexString(v));
        }
        return sb.toString().toUpperCase();
    }

    public static byte[] hexStringToByteArray(String s) {
        byte[] b = new byte[s.length() / 2];
        for (int i = 0; i < b.length; i++) {
            int index = i * 2;
            int v = Integer.parseInt(s.substring(index, index + 2), 16);
            b[i] = (byte) v;
        }
        return b;
    }

    /**
     * Converts a csv string to a html table string for displaying.
     * @return html table string
     */
    public static String csvToHtmlTable(String str) {
        String[] lines = handleNewLine(str).split(Const.EOL);

        StringBuilder result = new StringBuilder();

        for (String line : lines) {

            List<String> rowData = getTableData(line);

            if (checkIfEmptyRow(rowData)) {
                continue;
            }

            result.append(""<tr>"");
            for (String td : rowData) {
                result.append(String.format(""<td>%s</td>"", SanitizationHelper.sanitizeForHtml(td)));
            }
            result.append(""</tr>"");
        }

        return String.format(""<table class=\""table table-bordered table-striped table-condensed\"">%s</table>"",
                             result.toString());
    }

    private static String handleNewLine(String str) {

        StringBuilder buffer = new StringBuilder();
        char[] chars = str.toCharArray();

        boolean isInQuote = false;

        for (char c : chars) {
            if (c == '""') {
                isInQuote = !isInQuote;
            }

            if (c == '\n' && isInQuote) {
                buffer.append(""<br>"");
            } else {
                buffer.append(c);
            }
        }

        return buffer.toString();
    }

    private static List<String> getTableData(String str) {
        List<String> data = new ArrayList<>();

        boolean inquote = false;
        StringBuilder buffer = new StringBuilder();
        char[] chars = str.toCharArray();

        for (int i = 0; i < chars.length; i++) {
            if (chars[i] == '""') {
                if (i + 1 < chars.length && chars[i + 1] == '""') {
                    i++;
                } else {
                    inquote = !inquote;
                    continue;
                }
            }

            if (chars[i] == ',') {
                if (inquote) {
                    buffer.append(chars[i]);
                } else {
                    data.add(buffer.toString());
                    buffer.delete(0, buffer.length());
                }
            } else {
                buffer.append(chars[i]);
            }

        }

        data.add(buffer.toString().trim());

        return data;
    }

    private static boolean checkIfEmptyRow(List<String> rowData) {

        for (String td : rowData) {
            if (!td.isEmpty()) {
                return false;
            }
        }

        return true;
    }

    /**
     * From: http://stackoverflow.com/questions/11969840/how-to-convert-a-base-10-number-to-alphabetic-like-ordered-list-in-html
     * Converts an integer to alphabetical form (base26)
     * 1 - a
     * 2 - b
     * ...
     * 26 - z
     * 27 - aa
     * 28 - ab
     * ...
     *
     * @param n - number to convert
     */
    public static String integerToLowerCaseAlphabeticalIndex(int n) {
        StringBuilder result = new StringBuilder();
        int n0 = n;
        while (n0 > 0) {
            n0--; // 1 => a, not 0 => a
            int remainder = n0 % 26;
            char digit = (char) (remainder + 97);
            result.append(digit);
            n0 = (n0 - remainder) / 26;
        }
        return result.reverse().toString();
    }

    /**
     * Trims the string if it is not null.
     *
     * @return the trimmed string or null (if the parameter was null).
     */
    public static String trimIfNotNull(String string) {
        return string == null ? null : string.trim();
    }

    /**
     * Counts the number of empty strings passed as the argument. Null is
     * considered an empty string, while whitespace is not.
     *
     * @return number of empty strings passed
     */
    public static int countEmptyStrings(String... strings) {
        int numOfEmptyStrings = 0;
        for (String s : strings) {
            if (isEmpty(s)) {
                numOfEmptyStrings += 1;
            }
        }
        return numOfEmptyStrings;
    }

    /**
     * Converts null input to empty string. Non-null inputs will be left as is.
     * This method is for displaying purpose.
     *
     * @return empty string if null, the string itself otherwise
     */
    public static String convertToEmptyStringIfNull(String str) {
        return str == null ? """" : str;
    }

    /**
     * Removes the outermost enclosing square brackets surrounding a string.
     *
     * @return the string without the outermost enclosing square brackets
     *         if the given string is enclosed by square brackets <br>
     *         the string itself if the given string is not enclosed by square brackets <br>
     *         null if the given string is null
     */
    public static String removeEnclosingSquareBrackets(String str) {
        if (str == null) {
            return null;
        }

        if (!str.startsWith(""["") || !str.endsWith(""]"")) {
            return str;
        }

        return str.substring(1, str.length() - 1);
    }

    /**
     * Returns a String array after removing white spaces leading and
     * trailing any string in the input array.
     */
    public static String[] trim(String[] stringsToTrim) {
        String[] stringsAfterTrim = new String[stringsToTrim.length];
        int i = 0;
        for (String stringToTrim : stringsToTrim) {
            stringsAfterTrim[i++] = stringToTrim.trim();
        }
        return stringsAfterTrim;
    }

    /**
     * Returns text with all non-ASCII characters removed.
     */
    public static String removeNonAscii(String text) {
        return text.replaceAll(""[^\\x00-\\x7F]"", """");
    }

    /**
     * Returns a new String composed of copies of the String elements joined together
     * with a copy of the specified delimiter.
     */
    public static String join(String delimiter, String... elements) {
        if (delimiter == null || elements == null) {
            throw new IllegalArgumentException(""Provided arguments cannot be null"");
        }

        StringBuilder result = new StringBuilder();
        for (String element : elements) {
            result.append(element).append(delimiter);
        }
        if (result.length() > 0 && delimiter.length() > 0) {
            result.delete(result.length() - delimiter.length(), result.length());
        }
        return result.toString();
    }

    /**
     * Returns a new String composed of copies of the String elements joined together
     * with a copy of the specified delimiter.
     */
    public static String join(String delimiter, List<Integer> elements) {
        return join(delimiter, toStringArray(elements));
    }

    /**
     * Converts list of integer to array of strings.
     */
    private static String[] toStringArray(List<Integer> elements) {
        if (elements == null) {
            throw new IllegalArgumentException(""Provided arguments cannot be null"");
        }

        String[] elementsArr = new String[elements.size()];

        for (int i = 0; i < elements.size(); i++) {
            elementsArr[i] = String.valueOf(elements.get(i));
        }

        return elementsArr;
    }

    /**
     * Returns true if {@code text} contains at least one of the {@code strings} or if {@code strings} is empty.
     * If {@code text} is null, false is returned.
     */
    public static boolean isTextContainingAny(String text, String... strings) {
        if (text == null) {
            return false;
        }

        if (strings.length == 0) {
            return true;
        }

        for (String string : strings) {
            if (text.contains(string)) {
                return true;
            }
        }
        return false;
    }
}
"
TaskWrapper.java,util,"package teammates.common.util;

import java.util.Map;

/**
 * Represents a task to be added to the task queue.
 */
public class TaskWrapper {

    private final String queueName;
    private final String workerUrl;
    private final Map<String, String[]> paramMap;

    public TaskWrapper(String queueName, String workerUrl, Map<String, String[]> paramMap) {
        this.queueName = queueName;
        this.workerUrl = workerUrl;
        this.paramMap = paramMap;
    }

    public String getQueueName() {
        return queueName;
    }

    public String getWorkerUrl() {
        return workerUrl;
    }

    public Map<String, String[]> getParamMap() {
        return paramMap;
    }

}
"
Templates.java,util,"package teammates.common.util;

public final class Templates {

    public static final String INSTRUCTOR_SAMPLE_DATA = FileHelper.readResourceFile(""InstructorSampleData.json"");

    private Templates() {
        // utility class
    }

    /**
     * Populates the HTML templates by replacing variables in the template string
     * with the given value strings.
     * @param template The template html to be populated
     * @param keyValuePairs Array of a variable, even number of key-value pairs:
     *                   { ""key1"", ""val1"", ""key2"", ""val2"", ... }
     * @return The populated template
     */
    public static String populateTemplate(String template, String... keyValuePairs) {
        Assumption.assertTrue(""The number of elements in keyValuePairs passed in must be even"",
                keyValuePairs.length % 2 == 0);
        String populatedTemplate = template;
        for (int i = 0; i < keyValuePairs.length; i += 2) {
            populatedTemplate = populatedTemplate.replace(keyValuePairs[i], keyValuePairs[i + 1]);
        }
        return populatedTemplate;
    }

    /**
     * Collection of templates of emails to be sent by the system.
     */
    public static class EmailTemplates {
        public static final String USER_COURSE_JOIN =
                FileHelper.readResourceFile(""userEmailTemplate-courseJoin.html"");
        public static final String FRAGMENT_STUDENT_COURSE_JOIN =
                FileHelper.readResourceFile(""studentEmailFragment-courseJoin.html"");
        public static final String FRAGMENT_STUDENT_COURSE_REJOIN_AFTER_GOOGLE_ID_RESET =
                FileHelper.readResourceFile(""studentEmailFragment-googleIdReset.html"");
        public static final String FRAGMENT_INSTRUCTOR_COURSE_JOIN =
                FileHelper.readResourceFile(""instructorEmailFragment-courseJoin.html"");
        public static final String USER_FEEDBACK_SESSION =
                FileHelper.readResourceFile(""userEmailTemplate-feedbackSession.html"");
        public static final String FRAGMENT_CLOSED_SESSION_ADDITIONAL_INSTRUCTIONS =
                FileHelper.readResourceFile(""userEmailFragment-sessionClosedAdditionalInstructionsFragment.html"");
        public static final String USER_FEEDBACK_SESSION_CLOSING =
                FileHelper.readResourceFile(""userEmailTemplate-feedbackSessionClosing.html"");
        public static final String USER_FEEDBACK_SESSION_PUBLISHED =
                FileHelper.readResourceFile(""userEmailTemplate-feedbackSessionPublished.html"");
        public static final String USER_FEEDBACK_SUBMISSION_CONFIRMATION =
                FileHelper.readResourceFile(""userEmailTemplate-feedbackSubmissionConfirmation.html"");
        public static final String USER_FEEDBACK_SESSION_UNPUBLISHED =
                FileHelper.readResourceFile(""userEmailTemplate-feedbackSessionUnpublished.html"");
        public static final String FRAGMENT_SINGLE_FEEDBACK_SESSION_LINKS =
                FileHelper.readResourceFile(""userEmailTemplateFragment-feedbackSessionResendAllLinks.html"");
        public static final String USER_FEEDBACK_SESSION_RESEND_ALL_LINKS =
                FileHelper.readResourceFile(""userEmailTemplate-feedbackSessionResendAllLinks.html"");
        public static final String SEVERE_ERROR_LOG_LINE =
                FileHelper.readResourceFile(""severeErrorLogLine.html"");
        public static final String NEW_INSTRUCTOR_ACCOUNT_WELCOME =
                FileHelper.readResourceFile(""newInstructorAccountWelcome.html"");
    }

    public static class FeedbackQuestion {

        public static class FormTemplates {
            public static final String FEEDBACK_QUESTION_ADDITIONAL_INFO =
                    FileHelper.readResourceFile(""feedbackQuestionAdditionalInfoTemplate.html"");

            public static final String TEXT_SUBMISSION_FORM =
                    FileHelper.readResourceFile(""feedbackQuestionTextSubmissionFormTemplate.html"");
            public static final String TEXT_RESULT_STATS =
                    FileHelper.readResourceFile(""feedbackQuestionTextResultStatsTemplate.html"");
            public static final String TEXT_EDIT_FORM =
                    FileHelper.readResourceFile(""feedbackQuestionTextEditFormTemplate.html"");

            public static final String MCQ_SUBMISSION_FORM =
                    FileHelper.readResourceFile(""feedbackQuestionMcqSubmissionFormTemplate.html"");
            public static final String MCQ_SUBMISSION_FORM_OPTIONFRAGMENT =
                    FileHelper.readResourceFile(""feedbackQuestionMcqSubmissionFormOptionFragment.html"");
            public static final String MCQ_SUBMISSION_FORM_OTHEROPTIONFRAGMENT =
                    FileHelper.readResourceFile(""feedbackQuestionMcqSubmissionFormOtherOptionFragment.html"");
            public static final String MCQ_EDIT_FORM =
                    FileHelper.readResourceFile(""feedbackQuestionMcqEditFormTemplate.html"");
            public static final String MCQ_EDIT_FORM_OPTIONFRAGMENT =
                    FileHelper.readResourceFile(""feedbackQuestionMcqEditFormOptionFragment.html"");
            public static final String MCQ_ADDITIONAL_INFO_FRAGMENT =
                    FileHelper.readResourceFile(""feedbackQuestionMcqAdditionalInfoFragment.html"");
            public static final String MCQ_ADDITIONAL_INFO =
                    FileHelper.readResourceFile(""feedbackQuestionMcqAdditionalInfoTemplate.html"");
            public static final String MCQ_RESULT_STATS =
                    FileHelper.readResourceFile(""feedbackQuestionMcqResultStatsTemplate.html"");
            public static final String MCQ_RESULT_STATS_OPTIONFRAGMENT =
                    FileHelper.readResourceFile(""feedbackQuestionMcqResultStatsOptionFragment.html"");

            public static final String MSQ_SUBMISSION_FORM =
                    FileHelper.readResourceFile(""feedbackQuestionMsqSubmissionFormTemplate.html"");
            public static final String MSQ_SUBMISSION_FORM_OPTIONFRAGMENT =
                    FileHelper.readResourceFile(""feedbackQuestionMsqSubmissionFormOptionFragment.html"");
            public static final String MSQ_SUBMISSION_FORM_OTHEROPTIONFRAGMENT =
                    FileHelper.readResourceFile(""feedbackQuestionMsqSubmissionFormOtherOptionFragment.html"");
            public static final String MSQ_EDIT_FORM =
                    FileHelper.readResourceFile(""feedbackQuestionMsqEditFormTemplate.html"");
            public static final String MSQ_EDIT_FORM_OPTIONFRAGMENT =
                    FileHelper.readResourceFile(""feedbackQuestionMsqEditFormOptionFragment.html"");
            public static final String MSQ_ADDITIONAL_INFO_FRAGMENT =
                    FileHelper.readResourceFile(""feedbackQuestionMsqAdditionalInfoFragment.html"");
            public static final String MSQ_ADDITIONAL_INFO =
                    FileHelper.readResourceFile(""feedbackQuestionMsqAdditionalInfoTemplate.html"");

            public static final String NUMSCALE_EDIT_FORM =
                    FileHelper.readResourceFile(""feedbackQuestionNumScaleEditFormTemplate.html"");
            public static final String NUMSCALE_SUBMISSION_FORM =
                    FileHelper.readResourceFile(""feedbackQuestionNumScaleSubmissionFormTemplate.html"");
            public static final String NUMSCALE_RESULT_STATS =
                    FileHelper.readResourceFile(""feedbackQuestionNumScaleResultStatsTemplate.html"");
            public static final String NUMSCALE_RESULTS_STATS_FRAGMENT =
                    FileHelper.readResourceFile(""feedbackQuestionNumScaleResultsStatsFragment.html"");
            public static final String NUMSCALE_RESULT_STATS_WITH_SELF_RESPONSE =
                    FileHelper.readResourceFile(""feedbackQuestionNumScaleResultStatsTemplateWithSelfResponse.html"");
            public static final String NUMSCALE_RESULTS_STATS_FRAGMENT_WITH_SELF_RESPONSE =
                    FileHelper.readResourceFile(""feedbackQuestionNumScaleResultsStatsFragmentWithSelfResponse.html"");

            public static final String CONSTSUM_SUBMISSION_FORM =
                    FileHelper.readResourceFile(""feedbackQuestionConstSumSubmissionFormTemplate.html"");
            public static final String CONSTSUM_SUBMISSION_FORM_OPTIONFRAGMENT =
                    FileHelper.readResourceFile(""feedbackQuestionConstSumSubmissionFormOptionFragment.html"");
            public static final String CONSTSUM_EDIT_FORM =
                    FileHelper.readResourceFile(""feedbackQuestionConstSumEditFormTemplate.html"");
            public static final String CONSTSUM_EDIT_FORM_OPTIONFRAGMENT =
                    FileHelper.readResourceFile(""feedbackQuestionConstSumEditFormOptionFragment.html"");
            public static final String CONSTSUM_RESULT_OPTION_STATS =
                    FileHelper.readResourceFile(""feedbackQuestionConstSumResultStatsTemplate.html"");
            public static final String CONSTSUM_RESULT_STATS_OPTIONFRAGMENT =
                    FileHelper.readResourceFile(""feedbackQuestionConstSumResultStatsOptionFragment.html"");
            public static final String CONSTSUM_RESULT_RECIPIENT_STATS =
                    FileHelper.readResourceFile(""feedbackQuestionConstSumResultStatsRecipientTemplate.html"");
            public static final String CONSTSUM_RESULT_STATS_RECIPIENTFRAGMENT =
                    FileHelper.readResourceFile(""feedbackQuestionConstSumResultStatsRecipientFragment.html"");

            public static final String CONTRIB_ADDITIONAL_INFO =
                    FileHelper.readResourceFile(""feedbackQuestionContribAdditionalInfoTemplate.html"");
            public static final String CONTRIB_EDIT_FORM =
                    FileHelper.readResourceFile(""feedbackQuestionContribEditFormTemplate.html"");
            public static final String CONTRIB_SUBMISSION_FORM =
                    FileHelper.readResourceFile(""feedbackQuestionContribSubmissionFormTemplate.html"");
            public static final String CONTRIB_RESULT_STATS =
                    FileHelper.readResourceFile(""feedbackQuestionContribResultStatsTemplate.html"");
            public static final String CONTRIB_RESULT_STATS_FRAGMENT =
                    FileHelper.readResourceFile(""feedbackQuestionContribResultStatsFragment.html"");
            public static final String CONTRIB_RESULT_STATS_STUDENT =
                    FileHelper.readResourceFile(""feedbackQuestionContribResultStatsStudentViewTemplate.html"");
            public static final String CONTRIB_RESULT_STATS_STUDENT_INFO =
                    FileHelper.readResourceFile(""feedbackQuestionContribResultStatsStudentViewAdditionalInfo.html"");

            public static final String RUBRIC_SUBMISSION_FORM =
                    FileHelper.readResourceFile(""feedbackQuestionRubricSubmissionFormTemplate.html"");
            public static final String RUBRIC_SUBMISSION_FORM_MOBILE_PANEL_FRAGMENT =
                    FileHelper.readResourceFile(""feedbackQuestionRubricSubmissionFormMobilePanelFragment.html"");
            public static final String RUBRIC_SUBMISSION_FORM_MOBILE_PANEL =
                    FileHelper.readResourceFile(""feedbackQuestionRubricSubmissionFormMobilePanel.html"");
            public static final String RUBRIC_SUBMISSION_FORM_HEADER_FRAGMENT =
                    FileHelper.readResourceFile(""feedbackQuestionRubricSubmissionFormHeaderFragment.html"");
            public static final String RUBRIC_SUBMISSION_FORM_BODY_FRAGMENT =
                    FileHelper.readResourceFile(""feedbackQuestionRubricSubmissionFormBodyFragment.html"");
            public static final String RUBRIC_SUBMISSION_FORM_BODY =
                    FileHelper.readResourceFile(""feedbackQuestionRubricSubmissionFormBody.html"");
            public static final String RUBRIC_EDIT_FORM =
                    FileHelper.readResourceFile(""feedbackQuestionRubricEditFormTemplate.html"");
            public static final String RUBRIC_EDIT_FORM_HEADER_FRAGMENT =
                    FileHelper.readResourceFile(""feedbackQuestionRubricEditFormHeaderFragment.html"");
            public static final String RUBRIC_EDIT_FORM_WEIGHT_FRAGMENT =
                    FileHelper.readResourceFile(""feedbackQuestionRubricEditFormWeightFragment.html"");
            public static final String RUBRIC_EDIT_FORM_BODY_FRAGMENT =
                    FileHelper.readResourceFile(""feedbackQuestionRubricEditFormBodyFragment.html"");
            public static final String RUBRIC_EDIT_FORM_BODY =
                    FileHelper.readResourceFile(""feedbackQuestionRubricEditFormBody.html"");
            public static final String RUBRIC_EDIT_FORM_TABLE_OPTIONS =
                    FileHelper.readResourceFile(""feedbackQuestionRubricEditFormTableOptions.html"");
            public static final String RUBRIC_EDIT_FORM_TABLE_OPTIONS_FRAGMENT =
                    FileHelper.readResourceFile(""feedbackQuestionRubricEditFormTableOptionsFragment.html"");
            public static final String RUBRIC_RESULT_STATS =
                    FileHelper.readResourceFile(""feedbackQuestionRubricResultStatsTemplate.html"");
            public static final String RUBRIC_RESULT_STATS_HEADER_FRAGMENT =
                    FileHelper.readResourceFile(""feedbackQuestionRubricResultStatsHeaderFragment.html"");
            public static final String RUBRIC_RESULT_STATS_BODY_FRAGMENT =
                    FileHelper.readResourceFile(""feedbackQuestionRubricResultStatsBodyFragment.html"");
            public static final String RUBRIC_RESULT_STATS_BODY =
                    FileHelper.readResourceFile(""feedbackQuestionRubricResultStatsBody.html"");
            public static final String RUBRIC_ADDITIONAL_INFO =
                    FileHelper.readResourceFile(""feedbackQuestionRubricAdditionalInfoTemplate.html"");

            public static final String RANK_SUBMISSION_FORM =
                    FileHelper.readResourceFile(""feedbackQuestionRankSubmissionFormTemplate.html"");
            public static final String RANK_SUBMISSION_FORM_OPTIONFRAGMENT =
                    FileHelper.readResourceFile(""feedbackQuestionRankSubmissionFormOptionFragment.html"");
            public static final String RANK_EDIT_RECIPIENTS_FORM =
                    FileHelper.readResourceFile(""feedbackQuestionRankRecipientsEditFormTemplate.html"");
            public static final String RANK_EDIT_OPTIONS_FORM =
                    FileHelper.readResourceFile(""feedbackQuestionRankOptionsEditFormTemplate.html"");
            public static final String RANK_EDIT_FORM_OPTIONFRAGMENT =
                    FileHelper.readResourceFile(""feedbackQuestionRankEditFormOptionFragment.html"");
            public static final String RANK_RESULT_OPTION_STATS =
                    FileHelper.readResourceFile(""feedbackQuestionRankResultStatsTemplate.html"");
            public static final String RANK_RESULT_STATS_OPTIONFRAGMENT =
                    FileHelper.readResourceFile(""feedbackQuestionRankResultStatsOptionFragment.html"");
            public static final String RANK_RESULT_RECIPIENT_STATS =
                    FileHelper.readResourceFile(""feedbackQuestionRankResultStatsRecipientTemplate.html"");
            public static final String RANK_RESULT_STATS_RECIPIENTFRAGMENT =
                    FileHelper.readResourceFile(""feedbackQuestionRankResultStatsRecipientFragment.html"");
        }

        public static class Slots {

            public static final String QUESTION_INDEX = ""${questionIndex}"";
            public static final String RESPONSE_INDEX = ""${responseIndex}"";
            public static final String DISABLED = ""${disabled}"";
            public static final String DESCRIPTION = ""${description}"";
            public static final String FEEDBACK_RESPONSE_TEXT = ""${Const.ParamsNames.FEEDBACK_RESPONSE_TEXT}"";
            public static final String CHECKED = ""${checked}"";
            public static final String OPTION_RECIPIENT_DISPLAY_NAME = ""${optionRecipientDisplayName}"";
            public static final String NUMBER_OF_CHOICE_CREATED =
                    ""${Const.ParamsNames.FEEDBACK_QUESTION_NUMBEROFCHOICECREATED}"";
            public static final String QUESTION_NUMBER = ""${questionNumber}"";
            public static final String CHECKED_OTHER_OPTION_ENABLED = ""${checkedOtherOptionEnabled}"";
            public static final String GENERATED_OPTIONS = ""${Const.ParamsNames.FEEDBACK_QUESTION_GENERATEDOPTIONS}"";
            public static final String GENERATE_OPTIONS_FOR_VALUE = ""${generateOptionsForValue}"";
            public static final String STUDENT_SELECTED = ""${studentSelected}"";
            public static final String TEAM_SELECTED = ""${teamSelected}"";
            public static final String INSTRUCTOR_SELECTED = ""${instructorSelected}"";
            public static final String STUDENTS_TO_STRING = ""${FeedbackParticipantType.STUDENTS.toString()}"";
            public static final String TEAMS_TO_STRING = ""${FeedbackParticipantType.TEAMS.toString()}"";
            public static final String INSTRUCTORS_TO_STRING = ""${FeedbackParticipantType.INSTRUCTORS.toString()}"";
            public static final String QUESTION_ADDITIONAL_INFO = ""${questionAdditionalInfo}"";
            public static final String ADDITIONAL_INFO_ID = ""${additionalInfoId}"";
            public static final String LESS = ""${less}"";
            public static final String MORE = ""${more}"";
            public static final String TEXT_DISABLED = ""${text-disabled}"";
            public static final String QUESTION_TYPE_NAME = ""${questionTypeName}"";
            public static final String COUNT = ""${count}"";
            public static final String PERCENTAGE = ""${percentage}"";
            public static final String AVERAGE = ""${Average}"";
            public static final String MAX = ""${Max}"";
            public static final String MIN = ""${Min}"";
            public static final String FRAGMENTS = ""${fragments}"";
            public static final String EXISTING_ANSWER = ""${existingAnswer}"";
            public static final String POSSIBLE_VALUES_STRING = ""${possibleValuesString}"";
            public static final String POSSIBLE_VALUES = ""${possibleValues}"";
            public static final String RECIPIENT_TEAM = ""${recipientTeam}"";
            public static final String RECIPIENT_NAME = ""${recipientName}"";
            public static final String SUMMARY_TITLE = ""${summaryTitle}"";
            public static final String STATS_TITLE = ""${statsTitle}"";
            public static final String STATS_FRAGMENTS = ""${statsFragments}"";
            public static final String OPTION_INDEX = ""${optionIdx}"";
            public static final String OPTIONS = ""${options}"";
            public static final String TEAM = ""${team}"";
            public static final String MOBILE_HTML = ""${mobileHtml}"";
            public static final String PANEL_BODY = ""${panelBody}"";
            public static final String ITERATOR = ""${i}"";

            // TEXT
            public static final String TEXT_EXISTING_RESPONSE = ""${existingResponse}"";

            // MCQ
            public static final String MCQ_CHOICE_VALUE = ""${mcqChoiceValue}"";
            public static final String MCQ_OTHER_OPTION_ANSWER = ""${mcqOtherOptionAnswer}"";
            public static final String MCQ_CHECKED_GENERATED_OPTION = ""${checkedGeneratedOptions}"";
            public static final String MCQ_SUBMISSION_FORM_OPTION_FRAGMENTS = ""${mcqSubmissionFormOptionFragments}"";
            public static final String MCQ_PARAM_IS_OTHER_OPTION_ANSWER =
                    ""${Const.ParamsNames.FEEDBACK_QUESTION_MCQ_ISOTHEROPTIONANSWER}"";
            public static final String MCQ_EDIT_FORM_OPTION_FRAGMENTS = ""${mcqEditFormOptionFragments}"";
            public static final String MCQ_NUM_OF_MCQ_CHOICES = ""${numOfMcqChoices}"";
            public static final String MCQ_ADDITIONAL_INFO_FRAGMENTS = ""${mcqAdditionalInfoFragments}"";
            public static final String MCQ_PARAM_CHOICE = ""${Const.ParamsNames.FEEDBACK_QUESTION_MCQCHOICE}"";
            public static final String MCQ_PARAM_OTHER_OPTION = ""${Const.ParamsNames.FEEDBACK_QUESTION_MCQOTHEROPTION}"";
            public static final String MCQ_PARAM_OTHER_OPTION_FLAG =
                    ""${Const.ParamsNames.FEEDBACK_QUESTION_MCQOTHEROPTIONFLAG}"";

            // MSQ
            public static final String MSQ_CHOICE_VALUE = ""${msqChoiceValue}"";
            public static final String MSQ_CHOICE_TEXT = ""${msqChoiceText}"";
            public static final String MSQ_OTHER_OPTION_ANSWER = ""${msqOtherOptionAnswer}"";
            public static final String MSQ_SUBMISSION_FORM_OPTION_FRAGMENTS = ""${msqSubmissionFormOptionFragments}"";
            public static final String MSQ_NUMBER_OF_CHOICES = ""${numOfMsqChoices}"";
            public static final String MSQ_CHECKED_GENERATED_OPTIONS = ""${checkedGeneratedOptions}"";
            public static final String MSQ_ADDITIONAL_INFO_FRAGMENTS = ""${msqAdditionalInfoFragments}"";
            public static final String MSQ_PARAM_CHOICE = ""${Const.ParamsNames.FEEDBACK_QUESTION_MSQCHOICE}"";
            public static final String MSQ_PARAM_OTHER_OPTION = ""${Const.ParamsNames.FEEDBACK_QUESTION_MSQOTHEROPTION}"";
            public static final String MSQ_PARAM_OTHER_OPTION_FLAG =
                    ""${Const.ParamsNames.FEEDBACK_QUESTION_MSQOTHEROPTIONFLAG}"";
            public static final String MSQ_EDIT_FORM_OPTION_FRAGMENTS = ""${msqEditFormOptionFragments}"";
            public static final String MSQ_PARAM_IS_OTHER_OPTION_ANSWER =
                    ""${Const.ParamsNames.FEEDBACK_QUESTION_MSQ_ISOTHEROPTIONANSWER}"";

            // Numscale
            public static final String MIN_SCALE = ""${minScale}"";
            public static final String MAX_SCALE = ""${maxScale}"";
            public static final String STEP = ""${step}"";
            public static final String AVERAGE_EXCLUDING_SELF_RESPONSE = ""${AverageExcludingSelfResponse}"";
            public static final String NUMSCALE_MIN = ""${Const.ParamsNames.FEEDBACK_QUESTION_NUMSCALE_MIN}"";
            public static final String NUMSCALE_MAX = ""${Const.ParamsNames.FEEDBACK_QUESTION_NUMSCALE_MAX}"";
            public static final String NUMSCALE_STEP = ""${Const.ParamsNames.FEEDBACK_QUESTION_NUMSCALE_STEP}"";
            public static final String NUMSCALE_TOOLTIPS_MIN = ""${Const.ToolTips.FEEDBACK_QUESTION_NUMSCALE_MIN}"";
            public static final String NUMSCALE_TOOLTIPS_MAX = ""${Const.ToolTips.FEEDBACK_QUESTION_NUMSCALE_MAX}"";
            public static final String NUMSCALE_TOOLTIPS_STEP = ""${Const.ToolTips.FEEDBACK_QUESTION_NUMSCALE_STEP}"";

            // Constant Sum
            public static final String CONSTSUM_OPTION_VISIBILITY = ""${constSumOptionVisibility}"";
            public static final String CONSTSUM_OPTION_POINT = ""${constSumOptionPoint}"";
            public static final String CONSTSUM_OPTION_VALUE = ""${constSumOptionValue}"";
            public static final String MARGIN_LEFT = ""${marginLeft}"";
            public static final String CONSTSUM_PARAM_POINTS = ""${Const.ParamsNames.FEEDBACK_QUESTION_CONSTSUMPOINTS}"";
            public static final String CONSTSUM_PARAM_POINTSFOREACHOPTION =
                    ""${Const.ParamsNames.FEEDBACK_QUESTION_CONSTSUMPOINTSFOREACHOPTION}"";
            public static final String CONSTSUM_PARAM_POINTSFOREACHRECIPIENT =
                    ""${Const.ParamsNames.FEEDBACK_QUESTION_CONSTSUMPOINTSFOREACHRECIPIENT}"";
            public static final String CONSTSUM_TO_RECIPIENTS_VALUE = ""${constSumToRecipientsValue}"";
            public static final String CONSTSUM_TO_RECIPIENTS =
                    ""${Const.ParamsNames.FEEDBACK_QUESTION_CONSTSUMTORECIPIENTS}"";
            public static final String CONSTSUM_SUBMISSION_FORM_OPTION_FRAGMENT = ""${constSumSubmissionFormOptionFragments}"";
            public static final String CONSTSUM_EDIT_FORM_OPTION_FRAGMENT = ""${constSumEditFormOptionFragments}"";
            public static final String CONSTSUM_NUM_OPTION_VALUE = ""${constSumNumOptionValue}"";
            public static final String CONSTSUM_POINTS_PER_OPTION_VALUE = ""${constSumPointsPerOptionValue}"";
            public static final String CONSTSUM_UNEVEN_DISTRIBUTION_VALUE = ""${constSumUnevenDistributionValue}"";
            public static final String CONSTSUM_NUM_OPTION = ""${Const.ParamsNames.FEEDBACK_QUESTION_CONSTSUMNUMOPTION}"";
            public static final String CONSTSUM_POINTS_VALUE = ""${constSumPointsValue}"";
            public static final String CONSTSUM_NUMBER_OF_OPTIONS = ""${numOfConstSumOptions}"";
            public static final String CONSTSUM_SELECTED_POINTS_PER_OPTION = ""${selectedConstSumPointsPerOption}"";
            public static final String CONSTSUM_OPTION_TABLE_VISIBILITY = ""${constSumOptionTableVisibility}"";
            public static final String CONSTSUM_DISTRIBUTE_UNEVENLY = ""${distributeUnevenly}"";
            public static final String CONSTSUM_POINTS = ""${constSumPoints}"";
            public static final String CONSTSUM_POINTS_RECEIVED = ""${pointsReceived}"";
            public static final String CONSTSUM_AVERAGE_POINTS = ""${averagePoints}"";
            public static final String CONSTSUM_TOTAL_POINTS = ""${totalPoints}"";
            public static final String CONSTSUM_PARAM_OPTION = ""${Const.ParamsNames.FEEDBACK_QUESTION_CONSTSUMOPTION}"";
            public static final String CONSTSUM_PARAM_DISTRIBUTE_UNEVENLY =
                    ""${Const.ParamsNames.FEEDBACK_QUESTION_CONSTSUMDISTRIBUTEUNEVENLY}"";
            public static final String CONSTSUM_POINTS_PER_OPTION =
                    ""${Const.ParamsNames.FEEDBACK_QUESTION_CONSTSUMPOINTSPEROPTION}"";
            public static final String CONSTSUM_TOOLTIP_POINTS = ""${Const.Tooltips.FEEDBACK_QUESTION_CONSTSUMPOINTS}"";
            public static final String CONSTSUM_TOOLTIP_POINTS_PER_OPTION =
                    ""${Const.Tooltips.FEEDBACK_QUESTION_CONSTSUMPOINTSFOREACHOPTION}"";
            public static final String CONSTSUM_TOOLTIP_POINTS_PER_RECIPIENT =
                    ""${Const.Tooltips.FEEDBACK_QUESTION_CONSTSUMPOINTSFOREACHRECIPIENT}"";
            public static final String OPTION_DISPLAY = ""${optionDisplay}"";
            public static final String RECIPIENT_DISPLAY = ""${recipientDisplay}"";
            public static final String PER_OPTION_CHECKED = ""${perOptionChecked}"";
            public static final String PER_RECIPIENT_CHECKED = ""${perRecipientChecked}"";

            // Contribution
            public static final String CONTRIB_SELECT_FRAGMENTS_HTML = ""${contribSelectFragmentsHtml}"";
            public static final String CONTRIB_IS_NOT_SURE_ALLOWED_CHECKED = ""${isNotSureAllowedChecked}"";
            public static final String CONTRIB_PARAM_IS_NOT_SURE_ALLOWED_CHECKED =
                    ""${Const.ParamsNames.FEEDBACK_QUESTION_CONTRIBISNOTSUREALLOWED}"";
            public static final String CONTRIB_ADDITIONAL_INFO = ""${contribAdditionalInfo}"";
            public static final String CONTRIB_MY_VIEW_OF_ME = ""${myViewOfMe}"";
            public static final String CONTRIB_MY_VIEW_OF_OTHERS = ""${myViewOfOthers}"";
            public static final String CONTRIB_TEAM_VIEW_OF_ME = ""${teamViewOfMe}"";
            public static final String CONTRIB_TEAM_VIEW_OF_OTHERS = ""${teamViewOfOthers}"";
            public static final String CONTRIB_STUDENT_TEAM = ""${studentTeam}"";
            public static final String CONTRIB_STUDENT_NAME = ""${studentName}"";
            public static final String CONTRIB_FRAGMENTS = ""${contribFragments}"";
            public static final String CONTRIB_CC = ""${CC}"";
            public static final String CONTRIB_PC = ""${PC}"";
            public static final String CONTRIB_DIFF = ""${Diff}"";
            public static final String CONTRIB_RR = ""${RR}"";
            public static final String CONTRIB_TOOLTIPS_CLAIMED = ""${Const.Tooltips.CLAIMED}"";
            public static final String CONTRIB_TOOLTIPS_PERCEIVED = ""${Const.Tooltips.PERCEIVED}"";
            public static final String CONTRIB_TOOLTIPS_DIFF = ""${Const.Tooltips.FEEDBACK_CONTRIBUTION_DIFF}"";
            public static final String CONTRIB_TOOLTIPS_POINTS_RECEIVED =
                    ""${Const.Tooltips.FEEDBACK_CONTRIBUTION_POINTS_RECEIVED}"";
            public static final String CONTRIB_PARAM_STUDENT_NAME = ""${Const.ParamsNames.STUDENT_NAME}"";
            public static final String CONTRIB_EQUAL_SHARE_HELP = ""${equalShareHelp}"";

            // Rank
            public static final String RANK_OPTION_VISIBILITY = ""${rankOptionVisibility}"";
            public static final String RANK_OPTION_VALUE = ""${rankOptionValue}"";
            public static final String RANK_TO_RECIPIENTS_VALUE = ""${rankToRecipientsValue}"";
            public static final String RANK_NUM_OPTION_VALUE = ""${rankNumOptionValue}"";
            public static final String RANK_NUM_OPTIONS = ""${numOfRankOptions}"";
            public static final String RANK_RECIEVED = ""${ranksReceived}"";
            public static final String RANK_SELF = ""${selfRank}"";
            public static final String RANK_AVERAGE = ""${averageRank}"";
            public static final String RANK_EXCLUDING_SELF_AVERAGE = ""${averageRankExcludingSelf}"";
            public static final String RANK_EDIT_FORM_OPTION_FRAGMENTS = ""${rankEditFormOptionFragments}"";
            public static final String RANK_ARE_DUPLICATES_ALLOWED_VALUE = ""${areDuplicatesAllowedValue}"";
            public static final String RANK_ARE_DUPLICATES_ALLOWED_CHECKED = ""${areDuplicatesAllowedChecked}"";
            public static final String RANK_SUBMISSION_FORM_OPTION_FRAGMENTS = ""${rankSubmissionFormOptionFragments}"";
            public static final String RANK_OPTION_RECIPIENT_DISPLAY_NAME = ""${optionRecipientDisplayName}"";
            public static final String RANK_PARAM_TO_RECIPIENT = ""${Const.ParamsNames.FEEDBACK_QUESTION_RANKTORECIPIENTS}"";
            public static final String RANK_PARAM_NUM_OPTION =
                    ""${Const.ParamsNames.FEEDBACK_QUESTION_RANKNUMOPTION}"";
            public static final String RANK_PARAM_IS_DUPLICATES_ALLOWED =
                    ""${Const.ParamsNames.FEEDBACK_QUESTION_RANKISDUPLICATESALLOWED}"";
            public static final String RANK_PARAM_OPTION = ""${Const.ParamsNames.FEEDBACK_QUESTION_RANKOPTION}"";
            public static final String RANK_PARAM_NUMBER_OF_CHOICE_CREATED =
                    ""${Const.ParamsNames.FEEDBACK_QUESTION_NUMBEROFCHOICECREATED}"";

            // Rubric
            public static final String CURRENT_ROWS = ""${currRows}"";
            public static final String CURRENT_COLS = ""${currCols}"";
            public static final String RUBRIC_ROW_BODY_FRAGMENTS = ""${rubricRowBodyFragments}"";
            public static final String TABLE_HEADER_ROW_FRAGMENT_HTML = ""${tableHeaderRowFragmentHtml}"";
            public static final String TABLE_BODY_HTML = ""${tableBodyHtml}"";
            public static final String SUB_QUESTION = ""${subQuestion}"";
            public static final String ROW = ""${row}"";
            public static final String COL = ""${col}"";
            public static final String RUBRIC_PERCENTAGE_FREQUENCY_OR_AVERAGE = ""${percentageFrequencyOrAverage}"";
            public static final String CHECK_ASSIGN_WEIGHTS = ""${checkAssignWeights}"";
            public static final String RUBRIC_WEIGHT = ""${rubricWeight}"";
            public static final String RUBRIC_CHOICE_VALUE = ""${rubricChoiceValue}"";
            public static final String RUBRIC_TABLE_WEIGHT_ROW_FRAGMENT_HTML = ""${tableWeightRowFragmentHtml}"";
            public static final String RUBRIC_ADDITIONAL_INFO_FRAGMENTS = ""${rubricAdditionalInfoFragments}"";
            public static final String RUBRIC_TOOLTIPS_ASSIGN_WEIGHTS =
                    ""${Const.Tooltips.FEEDBACK_QUESTION_RUBRIC_ASSIGN_WEIGHTS}"";
            public static final String RUBRIC_PARAM_ASSIGN_WEIGHTS =
                    ""${Const.ParamsNames.FEEDBACK_QUESTION_RUBRIC_WEIGHTS_ASSIGNED}"";
            public static final String RUBRIC_PARAM_NUM_ROWS = ""${Const.ParamNames.FEEDBACK_QUESTION_RUBRIC_NUM_ROWS}"";
            public static final String RUBRIC_PARAM_NUM_COLS = ""${Const.ParamNames.FEEDBACK_QUESTION_RUBRIC_NUM_COLS}"";
            public static final String RUBRIC_PARAM_SUB_QUESTION =
                    ""${Const.ParamsNames.FEEDBACK_QUESTION_RUBRICSUBQUESTION}"";
            public static final String RUBRIC_PARAM_DESCRIPTION = ""${Const.ParamsNames.FEEDBACK_QUESTION_RUBRICDESCRIPTION}"";
            public static final String RUBRIC_PARAM_WEIGHT = ""${Const.ParamsNames.FEEDBACK_QUESTION_RUBRIC_WEIGHT}"";
            public static final String RUBRIC_PARAM_CHOICE = ""${Const.ParamsNames.FEEDBACK_QUESTION_RUBRICCHOICE}"";
            public static final String RUBRIC_TABLE_OPTIONS = ""${tableOptionsHtml}"";
            public static final String RUBRIC_TABLE_OPTIONS_FRAGMENT = ""${rubricColumnOptionsFragments}"";
        }
    }

    // TODO: Consider adding instructions for the feedback session into template?
    // TODO: Or simply use static strings here?
    public static class FeedbackSessionTemplates {
        public static final String TEAM_EVALUATION =
                FileHelper.readResourceFile(""feedbackSessionTeamEvaluationTemplate.json"");
    }
}
"
ThreadHelper.java,util,"package teammates.common.util;

import java.io.PrintWriter;
import java.io.StringWriter;

import teammates.common.exception.TeammatesException;

public final class ThreadHelper {
    public static final int WAIT_DURATION = 20;
    private static final Logger log = Logger.getLogger();

    private ThreadHelper() {
        // utility class
    }

    public static void waitBriefly() {
        try {
            Thread.sleep(ThreadHelper.WAIT_DURATION);
        } catch (InterruptedException e) {
            log.severe(TeammatesException.toStringWithStackTrace(e));
        }
    }

    /**
     * Makes the thread sleep for the specified time.
     */
    public static void waitFor(int timeInMilliSeconds) {
        try {
            Thread.sleep(timeInMilliSeconds);
        } catch (InterruptedException e) {
            log.severe(TeammatesException.toStringWithStackTrace(e));
        }
    }

    public static String getCurrentThreadStack() {
        StringWriter sw = new StringWriter();
        new Throwable("""").printStackTrace(new PrintWriter(sw));
        return ""\n"" + sw.toString();
    }

}
"
TimeHelper.java,util,"package teammates.common.util;

import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.TimeZone;

import teammates.common.util.Const.SystemParams;

/** A helper class to hold time-related functions (e.g., converting dates to strings etc.).
 * Time zone is assumed as UTC unless specifically mentioned.
 */
public final class TimeHelper {

    private static final Logger log = Logger.getLogger();

    private static final Map<String, String> TIME_ZONE_CITIES_MAP = new HashMap<>();
    private static final List<Double> TIME_ZONE_VALUES = new ArrayList<>();

    /*
     *This time zone - city map was created by selecting major cities from each time zone.
     *reference: http://en.wikipedia.org/wiki/List_of_UTC_time_offsets
     *The map was verified by comparing with world clock from http://www.timeanddate.com/worldclock/
     *Note: No DST is handled here.
     */

    static {
        map(""-12.0"", ""Baker Island, Howland Island"");
        map(""-11.0"", ""American Samoa, Niue"");
        map(""-10.0"", ""Hawaii, Cook Islands"");
        map(""-9.5"", ""Marquesas Islands"");
        map(""-9.0"", ""Gambier Islands, Alaska"");
        map(""-8.0"", ""Los Angeles, Vancouver, Tijuana"");
        map(""-7.0"", ""Phoenix, Calgary, Ciudad Jurez"");
        map(""-6.0"", ""Chicago, Guatemala City, Mexico City, San Jos, San Salvador, Tegucigalpa, Winnipeg"");
        map(""-5.0"", ""New York, Lima, Toronto, Bogot, Havana, Kingston"");
        map(""-4.5"", ""Caracas"");
        map(""-4.0"", ""Santiago, La Paz, San Juan de Puerto Rico, Manaus, Halifax"");
        map(""-3.5"", ""St. John's"");
        map(""-3.0"", ""Buenos Aires, Montevideo, So Paulo"");
        map(""-2.0"", ""Fernando de Noronha, South Georgia and the South Sandwich Islands"");
        map(""-1.0"", ""Cape Verde, Greenland, Azores islands"");
        map(""0.0"", ""Accra, Abidjan, Casablanca, Dakar, Dublin, Lisbon, London"");
        map(""1.0"", ""Belgrade, Berlin, Brussels, Lagos, Madrid, Paris, Rome, Tunis, Vienna, Warsaw"");
        map(""2.0"", ""Athens, Sofia, Cairo, Kiev, Istanbul, Beirut, Helsinki, Jerusalem, Johannesburg, Bucharest"");
        map(""3.0"", ""Nairobi, Baghdad, Doha, Khartoum, Minsk, Riyadh"");
        map(""3.5"", ""Tehran"");
        map(""4.0"", ""Baku, Dubai, Moscow"");
        map(""4.5"", ""Kabul"");
        map(""5.0"", ""Karachi, Tashkent"");
        map(""5.5"", ""Colombo, Delhi"");
        map(""5.75"", ""Kathmandu"");
        map(""6.0"", ""Almaty, Dhaka, Yekaterinburg"");
        map(""6.5"", ""Yangon"");
        map(""7.0"", ""Jakarta, Bangkok, Novosibirsk, Hanoi"");
        map(""8.0"", ""Perth, Beijing, Manila, Singapore, Kuala Lumpur, Denpasar, Krasnoyarsk"");
        map(""8.75"", ""Eucla"");
        map(""9.0"", ""Seoul, Tokyo, Pyongyang, Ambon, Irkutsk"");
        map(""9.5"", ""Adelaide"");
        map(""10.0"", ""Canberra, Yakutsk, Port Moresby"");
        map(""10.5"", ""Lord Howe Islands"");
        map(""11.0"", ""Vladivostok, Noumea"");
        map(""12.0"", ""Auckland, Suva"");
        map(""12.75"", ""Chatham Islands"");
        map(""13.0"", ""Phoenix Islands, Tokelau, Tonga"");
        map(""14.0"", ""Line Islands"");

    }

    private TimeHelper() {
        // utility class
    }

    private static void map(String timeZone, String cities) {
        TIME_ZONE_CITIES_MAP.put(timeZone, cities);
        TIME_ZONE_VALUES.add(Double.parseDouble(timeZone));
    }

    /**
     * Sets the system time zone if it differs from the standard one defined in {@link SystemParams#TIME_ZONE}.
     */
    public static void setSystemTimeZoneIfRequired() {
        TimeZone originalTimeZone = TimeZone.getDefault();
        if (SystemParams.TIME_ZONE.equals(originalTimeZone)) {
            return;
        }

        TimeZone.setDefault(SystemParams.TIME_ZONE);
        log.info(""Time zone set to "" + SystemParams.TIME_ZONE.getID() + "" (was "" + originalTimeZone.getID() + "")"");
    }

    public static String getCitiesForTimeZone(String zone) {
        return TIME_ZONE_CITIES_MAP.get(zone);
    }

    public static List<Double> getTimeZoneValues() {
        return new ArrayList<>(TIME_ZONE_VALUES);
    }

    /**
     * Returns the current date and time as a {@code Calendar} object for the given timezone.
     */
    public static Calendar now(double timeZone) {
        return TimeHelper.convertToUserTimeZone(
                Calendar.getInstance(SystemParams.TIME_ZONE), timeZone);
    }

    /**
     * Convert a date string and time string into a Date object. Returns null on error.
     *
     * @param inputDate
     *            The date in format dd/MM/yyyy
     * @param inputTimeHours
     *            The time as number of hours
     */
    public static Date combineDateTime(String inputDate, String inputTimeHours) {
        if (inputDate == null || inputTimeHours == null) {
            return null;
        }

        int inputTimeInt = 0;
        try {
            inputTimeInt = Integer.parseInt(inputTimeHours) * 100;
        } catch (NumberFormatException nfe) {
            return null;
        }
        return convertToDate(inputDate, inputTimeInt);
    }

    /**
     * Returns the date object with specified offset in number of days from now.
     */
    public static Date getDateOffsetToCurrentTime(int offsetDays) {
        Calendar cal = Calendar.getInstance(SystemParams.TIME_ZONE);
        cal.setTime(cal.getTime());
        cal.add(Calendar.DATE, +offsetDays);
        return cal.getTime();
    }

    /**
     * Returns the date object with specified offset in number of ms from now.
     */
    public static Date getMsOffsetToCurrentTime(int offsetMilliseconds) {
        Calendar cal = Calendar.getInstance(SystemParams.TIME_ZONE);
        cal.setTime(cal.getTime());
        cal.add(Calendar.MILLISECOND, +offsetMilliseconds);
        return cal.getTime();
    }

    public static Date getMsOffsetToCurrentTimeInUserTimeZone(int offset, double timeZone) {
        Date d = getMsOffsetToCurrentTime(offset);
        Calendar c = Calendar.getInstance(SystemParams.TIME_ZONE);
        c.setTime(d);
        return convertToUserTimeZone(c, timeZone).getTime();
    }

    public static Calendar convertToUserTimeZone(Calendar time, double timeZone) {
        Calendar newTime = (Calendar) time.clone();
        newTime.add(Calendar.MILLISECOND, (int) (60 * 60 * 1000 * timeZone));
        return newTime; // for chaining
    }

    /**
     * Converts the {@code localDate} from {@code localTimeZone}) to UTC through shifting by the offset.
     *
     * @deprecated Method should be removed once all time data is migrated to UTC.
     */
    @Deprecated
    public static Date convertLocalDateToUtc(Date localDate, double localTimeZone) {
        if (localDate == null) {
            return null;
        }
        Calendar localCal = dateToCalendar(localDate);
        localCal.add(Calendar.MINUTE, (int) (60 * (-localTimeZone)));
        return localCal.getTime();
    }

    /**
     * Formats a date in the corresponding option value in 'Time' dropdowns The
     * hour just after midnight is converted to option 24 (i.e., 2359 as shown
     * to the user) 23.59 is also converted to 24. (i.e., 23.59-00.59 ---> 24)
     */
    public static int convertToOptionValueInTimeDropDown(Date date) {
        //TODO: see if we can eliminate this method (i.e., merge with convertToDisplayValueInTimeDropDown)
        Calendar c = Calendar.getInstance(SystemParams.TIME_ZONE);
        c.setTime(date);
        int hour = c.get(Calendar.HOUR_OF_DAY);
        int minutes = c.get(Calendar.MINUTE);
        hour = hour == 0 ? 24 : hour;
        hour = hour == 23 && minutes == 59 ? 24 : hour;
        return hour;
    }

    /**
     * Formats a date in the format dd/MM/yyyy.
     */
    public static String formatDate(Date date) {
        if (date == null) {
            return """";
        }
        SimpleDateFormat sdf = new SimpleDateFormat(""dd/MM/yyyy"");
        sdf.setTimeZone(SystemParams.TIME_ZONE);
        return sdf.format(date);
    }

    /**
     * Formats a date in the format dd MMM yyyy, hh:mm a. Example: 05 May 2012,
     * 2:04 PM<br>
     */
    public static String formatTime12H(Date date) {
        if (date == null) {
            return """";
        }
        SimpleDateFormat sdf = null;
        Calendar c = Calendar.getInstance(SystemParams.TIME_ZONE);
        c.setTime(date);
        if (c.get(Calendar.HOUR_OF_DAY) == 12 && c.get(Calendar.MINUTE) == 0) {
            sdf = new SimpleDateFormat(""EEE, dd MMM yyyy, hh:mm"");
            sdf.setTimeZone(SystemParams.TIME_ZONE);
            return sdf.format(date) + "" NOON"";
        }
        sdf = new SimpleDateFormat(""EEE, dd MMM yyyy, hh:mm a"");
        sdf.setTimeZone(SystemParams.TIME_ZONE);
        return sdf.format(date);
    }

    public static String formatDateTimeForSessions(Date dateInUtc, double sessionTimeZone) {
        if (dateInUtc == null) {
            return """";
        }
        SimpleDateFormat sdf = null;
        Calendar c = Calendar.getInstance(SystemParams.TIME_ZONE);
        TimeZone timeZone = getTimeZoneFromDoubleOffset(sessionTimeZone);
        c.setTimeZone(timeZone);
        c.setTime(dateInUtc);
        String periodIndicator =
                c.get(Calendar.HOUR_OF_DAY) == 12 && c.get(Calendar.MINUTE) == 0 ? ""'NOON'"" : ""a"";
        sdf = new SimpleDateFormat(""EEE, dd MMM yyyy, hh:mm "" + periodIndicator + "" 'UTC'Z"");
        sdf.setTimeZone(timeZone);
        return sdf.format(dateInUtc);
    }

    /**
     * Formats a date in the format d MMM h:mm a. Example: 5 May 11:59 PM
     */
    public static String formatDateTimeForInstructorHomePage(Date date) {
        if (date == null) {
            return """";
        }
        SimpleDateFormat sdf = null;
        Calendar c = Calendar.getInstance(SystemParams.TIME_ZONE);
        c.setTime(date);
        if (c.get(Calendar.HOUR_OF_DAY) == 12 && c.get(Calendar.MINUTE) == 0) {
            sdf = new SimpleDateFormat(""d MMM h:mm"");
            sdf.setTimeZone(SystemParams.TIME_ZONE);
            return sdf.format(date) + "" NOON"";
        }
        sdf = new SimpleDateFormat(""d MMM h:mm a"");
        sdf.setTimeZone(SystemParams.TIME_ZONE);
        return sdf.format(date);
    }

    /**
     * Formats {@code dateInUtc} according to the ISO8601 format.
     */
    public static String formatDateToIso8601Utc(Date dateInUtc) {
        if (dateInUtc == null) {
            return """";
        }
        SimpleDateFormat sdf = new SimpleDateFormat(Const.TIME_FORMAT_ISO_8601_UTC);
        sdf.setTimeZone(SystemParams.TIME_ZONE);
        return sdf.format(dateInUtc);
    }

    public static String calendarToString(Calendar c) {
        if (c == null) {
            return """";
        }
        return new SimpleDateFormat(""MM/dd/yyyy HH:mm:ss SSS"").format(c.getTime());
    }

    /**
     * Converts the date string to a Date object.
     *
     * @param dateInStringFormat should be in the format {@link SystemParams#DEFAULT_DATE_TIME_FORMAT}
     */
    public static Date convertToDate(String dateInStringFormat) {
        try {
            DateFormat df = new SimpleDateFormat(SystemParams.DEFAULT_DATE_TIME_FORMAT);
            return df.parse(dateInStringFormat);
        } catch (ParseException e) {
            Assumption.fail(""Date in String is in wrong format."");
            return null;
        }
    }

    public static Calendar dateToCalendar(Date date) {
        Calendar c = Calendar.getInstance(SystemParams.TIME_ZONE);
        if (date == null) {
            return c;
        }
        c.setTime(date);
        return c;
    }

    /**
     * Returns the date object representing the next full hour from now.
     * Example: If now is 1055, this will return 1100
     */
    public static Date getNextHour() {
        Calendar cal = Calendar.getInstance(SystemParams.TIME_ZONE);
        cal.add(Calendar.HOUR_OF_DAY, 1);
        cal.set(Calendar.MINUTE, 0);
        cal.set(Calendar.SECOND, 0);
        cal.set(Calendar.MILLISECOND, 0);
        return cal.getTime();
    }

    /**
     * Returns whether the given date is being used as a special representation,
     * signifying it's face value should not be used without proper processing.
     * A null date is not a special time.
     */
    public static boolean isSpecialTime(Date date) {

        if (date == null) {
            return false;
        }

        return date.equals(Const.TIME_REPRESENTS_FOLLOW_OPENING)
               || date.equals(Const.TIME_REPRESENTS_FOLLOW_VISIBLE)
               || date.equals(Const.TIME_REPRESENTS_LATER)
               || date.equals(Const.TIME_REPRESENTS_NEVER)
               || date.equals(Const.TIME_REPRESENTS_NOW);

    }

    public static boolean isOlderThanAYear(Date compareDate) {
        Date currentDate = new Date();
        int differenceInDays;

        differenceInDays = (int) ((currentDate.getTime() - compareDate.getTime()) / (1000 * 60 * 60 * 24));

        return differenceInDays > 365;
    }

    /**
     * Returns true if the {@code time} falls within the last hour.
     * That is exactly one hour or less from the current time but earlier than current time.
     * Precision is at millisecond level.
     */
    public static boolean isWithinPastHourFromNow(Date time) {
        return isWithinPastHour(time, new Date());
    }

    /**
     * Returns true if the {@code time1} falls within past 1 hour of {@code time2}.
     * That is exactly one hour or less from time2 but earlier than time2.
     * Precision is at millisecond level.
     */
    public static boolean isWithinPastHour(Date time1, Date time2) {
        Calendar calendarTime1 = Calendar.getInstance(SystemParams.TIME_ZONE);
        calendarTime1.setTime(time1);

        Calendar calendarTime2 = Calendar.getInstance(SystemParams.TIME_ZONE);
        calendarTime2.setTime(time2);

        long time1Millis = calendarTime1.getTimeInMillis();
        long time2Millis = calendarTime2.getTimeInMillis();
        long differenceBetweenNowAndCal = (time2Millis - time1Millis) / (60 * 60 * 1000);
        return differenceBetweenNowAndCal == 0 && calendarTime2.after(calendarTime1);
    }

    /**
     * Checks if the time falls between the period specified. Possible scenarios:
     * <ul>
     *  <li>{@code startTime <= time <= endTime}</li>
     *  <li>{@code startTime <= time < endTime}</li>
     *  <li>{@code startTime < time <= endTime}</li>
     *  <li>{@code startTime < time < endTime}</li>
     * </ul>
     * @param startTime the start time of the period
     * @param endTime the end time of the period
     * @param time the time to be checked
     * @param isStartInclusive true to allow time to fall on start time
     * @param isEndInclusive true to allow time to fall on end time
     * @return true if the time falls between the start and end time
     */
    public static boolean isTimeWithinPeriod(Date startTime, Date endTime, Date time,
                                             boolean isStartInclusive, boolean isEndInclusive) {
        if (startTime == null || endTime == null || time == null) {
            return false;
        }

        boolean isAfterStartTime = time.after(startTime) || isStartInclusive && time.equals(startTime);
        boolean isBeforeEndTime = time.before(endTime) || isEndInclusive && time.equals(endTime);

        return isAfterStartTime && isBeforeEndTime;
    }

    public static double getLocalTimezoneHourOffset() {
        // getOffset returns the offset from UTC in milliseconds
        // so we need to divide it by (1000 * 60 * 60) to get it in hours
        return TimeZone.getDefault().getOffset(new Date().getTime()) / 1000.0 / 60.0 / 60.0;
    }

    private static Date convertToDate(String date, int time) {
        SimpleDateFormat sdf = new SimpleDateFormat(""dd/MM/yyyy"");
        sdf.setTimeZone(SystemParams.TIME_ZONE);
        Calendar calendar = Calendar.getInstance(SystemParams.TIME_ZONE);

        // Perform date manipulation
        try {
            Date newDate = sdf.parse(date);
            calendar.setTime(newDate);

            if (time == 2400) {
                calendar.set(Calendar.HOUR, 23);
                calendar.set(Calendar.MINUTE, 59);
            } else {
                calendar.set(Calendar.HOUR, time / 100);
                calendar.set(Calendar.MINUTE, time % 100);
            }

            return calendar.getTime();
        } catch (Exception e) {
            return null;
        }

    }

    /**
     * Returns Duration in format m:s:ms.
     *
     * <p>Example: 1200 milliseconds ---> 0:1:200.
     */

    public static String convertToStandardDuration(Long timeInMilliseconds) {

        return timeInMilliseconds == null
             ? """"
             : String.format(""%d:%d:%d"",
                             timeInMilliseconds / 60000,
                             timeInMilliseconds / 1000,
                             timeInMilliseconds % 1000);
    }

    /**
     * Combines separated date, hour and minute string into standard format.
     *
     * <p>required parameter format:
     * date: dd/MM/yyyy  hour: hh   min:mm
     *
     * @return Date String in the format {@link SystemParams#DEFAULT_DATE_TIME_FORMAT}.<br>
     *         Example: If date is 01/04/2014, hour is 23, min is 59, result will be  2014-04-01 11:59 PM UTC.
     */
    public static String convertToRequiredFormat(String date, String hour, String min) {

        if (date == null || hour == null || min == null) {
            return null;
        }

        final String OLD_FORMAT = ""dd/MM/yyyy"";
        final String NEW_FORMAT = ""yyyy-MM-dd"";

        SimpleDateFormat sdf = new SimpleDateFormat(OLD_FORMAT);
        try {
            Date d = sdf.parse(date);
            sdf.applyPattern(NEW_FORMAT);
            int intHour = Integer.parseInt(hour);
            String amOrPm = intHour >= 12 ? ""PM"" : ""AM"";
            intHour = intHour >= 13 ? intHour - 12 : intHour;
            return sdf.format(d) + "" "" + intHour + "":"" + min + "" "" + amOrPm + "" UTC"";
        } catch (ParseException e) {
            Assumption.fail(""Date in String is in wrong format."");
            return null;
        }

    }

    public static TimeZone getTimeZoneFromDoubleOffset(double sessionTimeZone) {
        int hours = (int) sessionTimeZone;
        int minutes = (int) ((Math.abs(sessionTimeZone) - Math.floor(Math.abs(sessionTimeZone))) * 60);
        return TimeZone.getTimeZone(String.format(""GMT%+03d:%02d"", hours, minutes));
    }

}
"
Url.java,util,"package teammates.common.util;

import java.net.MalformedURLException;
import java.net.URL;

/**
 * The Url class represents a URL string.
 * It provides methods to manipulate the URL string and extract values from it.
 */
public class Url {

    private final String baseUrl;
    private final String relativeUrl;
    private String query;

    public Url(String urlString) {
        // parse and validate the urlString with the built-in URL object
        URL url = null;
        try {
            url = new URL(urlString);
        } catch (MalformedURLException e) {
            Assumption.fail(""MalformedURLException for ["" + urlString + ""]: "" + e.getMessage());
        }

        this.baseUrl = url.getProtocol() + ""://"" + url.getAuthority();
        this.relativeUrl = StringHelper.convertToEmptyStringIfNull(url.getPath());
        String query = url.getQuery();
        this.query = query == null ? """" : ""?"" + query;
    }

    /**
      * Returns the relative part (path) of the URL, after the
      * authority (host name + port number if specified) but before the query.<br>
      * Example:
      * <ul>
      * <li><code>new Url(""http://localhost:8888/index.jsp"").getRelativeUrl()</code>
      * returns <code>/index.jsp</code></li>
      * <li><code>new Url(""http://google.com"").getRelativeUrl()</code>
      * returns <i>[empty string]</i></li>
      * <li><code>new Url(""https://teammatesv4.appspot.com/page/studentHomePage?user=abc"").getRelativeUrl()</code>
      * returns <code>/page/studentHomePage</code></li>
      * </ul>
      */
    public String getRelativeUrl() {
        return relativeUrl;
    }

    /**
      * Returns the first part of the URL, including the protocol and
      * authority (host name + port number if specified) but not the path.<br>
      * Example:
      * <ul>
      * <li><code>new Url(""http://localhost:8888/index.jsp"").getBaseUrl()</code>
      * returns <code>http://localhost:8888</code></li>
      * <li><code>new Url(""https://teammatesv4.appspot.com/index.jsp"").getBaseUrl()</code>
      * returns <code>https://teammatesv4.appspot.com</code></li>
      * </ul>
      */
    public String getBaseUrl() {
        return baseUrl;
    }

    /**
     * Returns the value of the {@code parameterName} parameter. Null if no such parameter.
     */
    public String get(String parameterName) {
        /*
         * Regex meaning: from the start of the string, try to find either:
         * 1. ""?"" followed by ""{parameterName}=""
         * 2. Any amount of any character followed by ""&{parameterName}=""
         * followed by as many characters as possible until the first & is found.
         * Returns the first occurrence if found, null otherwise.
         */
        String keyValuePairRegex = ""^(\\?|.*&)"" + parameterName + ""=([^&]*).*"";
        return query.matches(keyValuePairRegex) ? query.replaceFirst(keyValuePairRegex, ""$2"") : null;
    }

    @SuppressWarnings(""unchecked"")
    public <T extends Url> T withParam(String paramName, String paramValue) {
        query = addParamToUrl(query, paramName, paramValue);
        return (T) this;
    }

    /**
     * Returns the URL with the specified key-value pair parameter added.
     * The parameter will also be sanitized according to URL specification.
     * Unchanged if either the key or value is null, or the key already exists<br>
     * Example:
     * <ul>
     * <li><code>addParam(""index.jsp"",""action"",""add"")</code> returns
     * <code>index.jsp?action=add</code></li>
     * <li><code>addParam(""index.jsp?action=add"",""courseid"",""cs1101"")</code>
     * returns <code>index.jsp?action=add&courseid=cs1101</code></li>
     * <li><code>addParam(""index.jsp"",""message"",null)</code> returns
     * <code>index.jsp</code></li>
     * </ul>
     */
    public static String addParamToUrl(String url, String key, String value) {
        if (key == null || key.isEmpty() || value == null || value.isEmpty()
                || url.contains(""?"" + key + ""="") || url.contains(""&"" + key + ""="")) {
            // return the url if any of the key or the value is null or empty
            // or if the key is already included in the url
            return url;
        }
        return url + (url.contains(""?"") ? ""&"" : ""?"") + key + ""="" + SanitizationHelper.sanitizeForUri(value);
    }

    public static String trimTrailingSlash(String url) {
        return url.trim().replaceAll(""/(?=$)"", """");
    }

    @Override
    public String toString() {
        return relativeUrl + query;
    }

    /**
     * Returns the absolute version of the URL by appending the base URL
     * to the URL input.
     */
    public String toAbsoluteString() {
        return baseUrl + toString();
    }

}
"
Version.java,util,"package teammates.common.util;

/**
 * Represents a version by 3 parts: major version, minor version and patch version.
 *
 * <p>If the version has fewer than 3 numbers, the numbers will be assigned to major then to minor (if possible).
 * Those without number will be null.
 *
 * <p>If the version has more than 3 numbers, the first number will be major, the second number
 * will be minor and the rest will be patch.
 *
 * <p>For example:
 * <ul>
 * <li>version = 15: major = ""15"", minor = null and patch = null</li>
 * <li>version = 15.01: major = ""15"", minor = ""01"" and patch = null</li>
 * <li>version = 15.01.03: major = ""15"", minor = ""01"" and patch = ""03""</li>
 * <li>version = 15.01.03.01: major = ""15"", minor = ""01"" and patch = ""03.01""</li>
 * </ul>
 *
 * <p>It also support RC versions, which has ""rc"" appended at the end of the string.
 * For example: 5rc, 4.55rc, 5.55.01rc
 */
public class Version implements Comparable<Version> {
    /**
     * The original String of the version. It could be either XX-XX-XXXXX or XX.XX.XXXX format.
     */
    private String originalRepresentation;
    private String major;
    private String minor;
    private String patch;
    private boolean isRcVersion;

    /**
     * Creates a new instance of Version from string.
     * It accepts either XX-XX-XXXXX or XX.XX.XXXX format.
     */
    public Version(String versionInString) {
        originalRepresentation = versionInString;
        isRcVersion = versionInString.endsWith(""rc"");

        String[] list = versionInString.contains(""-"") // split to at most 3 parts
                      ? versionInString.replace(""rc"", """").split(""-"", 3)
                      : versionInString.replace(""rc"", """").split(""\\."", 3); // regex escape for dots '.'
        if (list.length > 0) {
            major = list[0];
        }
        if (list.length > 1) {
            minor = list[1];
        }
        if (list.length > 2) {
            patch = list[2];
        }
    }

    /**
     * Compares by string representation.
     */
    @Override
    public boolean equals(Object anotherVersion) {
        if (anotherVersion == null) {
            return false;
        }
        return toString().equals(anotherVersion.toString());
    }

    /**
     * Gets hash code for this version.
     */
    @Override
    public int hashCode() {
        return toString().hashCode();
    }

    /**
     * Converts Version to String in format XX.XX.XXXX.
     */
    @Override
    public String toString() {
        return originalRepresentation.replace('-', '.');
    }

    /**
     * Converts to String in format XX-XX-XXXX.
     */
    public String toStringWithDashes() {
        return originalRepresentation.replace('.', '-');
    }

    /**
     * Compares version numbers.
     * If their length are different, 0s will be appended in front of shorter string until
     * the length are the same.
     */
    private int compareVersionString(String s1, String s2) {
        if (s1 == null && s2 == null) {
            return 0;
        }
        if (s1 == null) {
            return 1;
        }
        if (s2 == null) {
            return -1;
        }
        String convertedS1;
        String convertedS2;
        if (s1.length() == s2.length()) {
            convertedS1 = s1;
            convertedS2 = s2;
        } else if (s1.length() > s2.length()) {
            convertedS1 = s1;
            convertedS2 = StringHelper.generateStringOfLength(s1.length() - s2.length(), '0') + s2;
        } else {
            convertedS1 = StringHelper.generateStringOfLength(s2.length() - s1.length(), '0') + s1;
            convertedS2 = s2;
        }
        return convertedS2.compareTo(convertedS1);
    }

    /**
     * Compares versions by major, minor then by patch.
     * The version with greater major, minor or patch will be smaller.
     */
    @Override
    public int compareTo(Version anotherVersion) {
        int majorComparisonResult = compareVersionString(this.major, anotherVersion.major);
        if (majorComparisonResult != 0) {
            return majorComparisonResult;
        }
        int minorComparisonResult = compareVersionString(this.minor, anotherVersion.minor);
        if (minorComparisonResult != 0) {
            return minorComparisonResult;
        }
        int patchComparisonResult = compareVersionString(this.patch, anotherVersion.patch);
        if (patchComparisonResult != 0) {
            return patchComparisonResult;
        }
        return Boolean.compare(anotherVersion.isRcVersion, isRcVersion);
    }
}
"
